Initialize the program!
Verify Test Cases
Building:src at:
/home/ubuntu/spr-fast/tests/corebench/grep/grep-case-8a025cf8-8f08d8e2/tempworkdir-l/srcRunning test command:
/home/ubuntu/spr-fast/tools/grep-test.py /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-8a025cf8-8f08d8e2/tempworkdir-l/src /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-8a025cf8-8f08d8e2/tempworkdir-l/tests /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-8a025cf8-8f08d8e2/tempworkdir-l 0  > __res
Running test command:
/home/ubuntu/spr-fast/tools/grep-test.py /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-8a025cf8-8f08d8e2/tempworkdir-l/src /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-8a025cf8-8f08d8e2/tempworkdir-l/tests /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-8a025cf8-8f08d8e2/tempworkdir-l 11 14 17 22  > __res
All passed!
Done Verification
Generating repair candidates!
Processing src/dfasearch.c
In dir /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-8a025cf8-8f08d8e2/tempworkdir-l/src
Total 16012 different repair candidate templates!!!!
Total 16012 different repair candidate templates!!!!
Total 30048 different repair candidate!!!
Trying different candidates!
BasicTester pointer: 0x2fd5430
CondTester pointer: 0x42e68c0
Counter: 1
Batcher Size:0
Preprocess the following candidate with CondTester:
Priority 20000
At location src/dfasearch.c:72
--Src File: src/dfasearch.c
Fragment 0:
if ((match_icase && (__ctype_get_mb_cur_max()) > 1) && !(__abst_hole(match_icase, must, buf, n, kwset)))
    buf = mbtolower(must, &n);
else
    buf = must;


CondTester, a patch instance with id 0:
//src_file:src/dfasearch.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); void* memset(void*, int, unsigned long); 
/* dfasearch.c - searching subroutines using dfa and regex for grep.
   Copyright 1992, 1998, 2000, 2007, 2009-2010 Free Software Foundation, Inc.

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 3, or (at your option)
   any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program; if not, write to the Free Software
   Foundation, Inc., 51 Franklin Street - Fifth Floor, Boston, MA
   02110-1301, USA.  */

/* Written August 1992 by Mike Haertel. */

#include <config.h>
#include "search.h"
#include "dfa.h"

/* For -w, we also consider _ to be word constituent.  */
#define WCHAR(C) (ISALNUM(C) || (C) == '_')

/* KWset compiled pattern.  For Ecompile and Gcompile, we compile
   a list of strings, at least one of which is known to occur in
   any string matching the regexp. */
static kwset_t kwset;

/* DFA compiled regexp. */
static struct dfa dfa;

/* The Regex compiled patterns.  */
static struct patterns
{
  /* Regex compiled regexp. */
  struct re_pattern_buffer regexbuf;
  struct re_registers regs; /* This is here on account of a BRAIN-DEAD
			       Q@#%!# library interface in regex.c.  */
} patterns0;

struct patterns *patterns;
size_t pcount;

void
dfaerror (char const *mesg)
{
  error (EXIT_TROUBLE, 0, "%s", mesg);

  /* notreached */
  /* Tell static analyzers that this function does not return.  */
  abort ();
}

/* Number of compiled fixed strings known to exactly match the regexp.
   If kwsexec returns < kwset_exact_matches, then we don't need to
   call the regexp matcher at all. */
static int kwset_exact_matches;

static char const *
kwsincr_case (const char *must)
{
  const char *buf;
  size_t n;

  n = strlen (must);
#ifdef MBS_SUPPORT
  
//Patch 0:
if ((match_icase && (__ctype_get_mb_cur_max()) > 1) && !(__is_neg(5, &(match_icase), sizeof (match_icase), &(must), sizeof (must), &(buf), sizeof (buf), &(n), sizeof (n), &(kwset), sizeof (kwset))))
    buf = mbtolower(must, &n);
else
    buf = must;

//CodeSeg 1:
  return kwsincr (kwset, buf, n);
}

/* If the DFA turns out to have some set of fixed strings one of
   which must occur in the match, then we build a kwset matcher
   to find those strings, and thus quickly filter out impossible
   matches. */
static void
kwsmusts (void)
{
  struct dfamust const *dm;
  char const *err;

  if (dfa.musts)
    {
      kwsinit (&kwset);
      /* First, we compile in the substrings known to be exact
	 matches.  The kwset matcher will return the index
	 of the matching string that it chooses. */
      for (dm = dfa.musts; dm; dm = dm->next)
	{
	  if (!dm->exact)
	    continue;
	  ++kwset_exact_matches;
	  if ((err = kwsincr_case (dm->must)) != NULL)
	    error (EXIT_TROUBLE, 0, "%s", err);
	}
      /* Now, we compile the substrings that will require
	 the use of the regexp matcher.  */
      for (dm = dfa.musts; dm; dm = dm->next)
	{
	  if (dm->exact)
	    continue;
	  if ((err = kwsincr_case (dm->must)) != NULL)
	    error (EXIT_TROUBLE, 0, "%s", err);
	}
      if ((err = kwsprep (kwset)) != NULL)
	error (EXIT_TROUBLE, 0, "%s", err);
    }
}

void
GEAcompile (char const *pattern, size_t size, reg_syntax_t syntax_bits)
{
  const char *err;
  const char *p, *sep;
  size_t total = size;
  char *motif;

  if (match_icase)
    syntax_bits |= RE_ICASE;
  re_set_syntax (syntax_bits);
  dfasyntax (syntax_bits, match_icase, eolbyte);

  /* For GNU regex compiler we have to pass the patterns separately to detect
     errors like "[\nallo\n]\n".  The patterns here are "[", "allo" and "]"
     GNU regex should have raise a syntax error.  The same for backref, where
     the backref should have been local to each pattern.  */
  p = pattern;
  do
    {
      size_t len;
      sep = memchr (p, '\n', total);
      if (sep)
	{
	  len = sep - p;
	  sep++;
	  total -= (len + 1);
	}
      else
	{
	  len = total;
	  total = 0;
	}

      patterns = realloc (patterns, (pcount + 1) * sizeof (*patterns));
      if (patterns == NULL)
	error (EXIT_TROUBLE, errno, _("memory exhausted"));
      patterns[pcount] = patterns0;

      if ((err = re_compile_pattern (p, len,
				    &(patterns[pcount].regexbuf))) != NULL)
	error (EXIT_TROUBLE, 0, "%s", err);
      pcount++;

      p = sep;
    } while (sep && total != 0);

  /* In the match_words and match_lines cases, we use a different pattern
     for the DFA matcher that will quickly throw out cases that won't work.
     Then if DFA succeeds we do some hairy stuff using the regex matcher
     to decide whether the match should really count. */
  if (match_words || match_lines)
    {
      static char const line_beg_no_bk[] = "^(";
      static char const line_end_no_bk[] = ")$";
      static char const word_beg_no_bk[] = "(^|[^[:alnum:]_])(";
      static char const word_end_no_bk[] = ")([^[:alnum:]_]|$)";
      static char const line_beg_bk[] = "^\\(";
      static char const line_end_bk[] = "\\)$";
      static char const word_beg_bk[] = "\\(^\\|[^[:alnum:]_]\\)\\(";
      static char const word_end_bk[] = "\\)\\([^[:alnum:]_]\\|$\\)";
      int bk = !(syntax_bits & RE_NO_BK_PARENS);
      char *n = xmalloc (sizeof word_beg_bk - 1 + size + sizeof word_end_bk);

      strcpy (n, match_lines ? (bk ? line_beg_bk : line_beg_no_bk)
			     : (bk ? word_beg_bk : word_beg_no_bk));
      total = strlen(n);
      memcpy (n + total, pattern, size);
      total += size;
      strcpy (n + total, match_lines ? (bk ? line_end_bk : line_end_no_bk)
				     : (bk ? word_end_bk : word_end_no_bk));
      total += strlen (n + total);
      pattern = motif = n;
      size = total;
    }
  else
    motif = NULL;

  dfacomp (pattern, size, &dfa, 1);
  kwsmusts ();

  free(motif);
}

size_t
EGexecute (char const *buf, size_t size, size_t *match_size,
	   char const *start_ptr)
{
  char const *buflim, *beg, *end, *match, *best_match, *mb_start;
  char eol = eolbyte;
  int backref, start, len, best_len;
  struct kwsmatch kwsm;
  size_t i, ret_val;
#ifdef MBS_SUPPORT
  if (MB_CUR_MAX > 1)
    {
      if (match_icase)
        {
          /* mbtolower adds a NUL byte at the end.  That will provide
	     space for the sentinel byte dfaexec may add.  */
          char *case_buf = mbtolower (buf, &size);
	  if (start_ptr)
	    start_ptr = case_buf + (start_ptr - buf);
          buf = case_buf;
        }
    }
#endif /* MBS_SUPPORT */

  mb_start = buf;
  buflim = buf + size;

  for (beg = end = buf; end < buflim; beg = end)
    {
      if (!start_ptr)
	{
	  /* We don't care about an exact match.  */
	  if (kwset)
	    {
	      /* Find a possible match using the KWset matcher. */
	      size_t offset = kwsexec (kwset, beg, buflim - beg, &kwsm);
	      if (offset == (size_t) -1)
		goto failure;
	      beg += offset;
	      /* Narrow down to the line containing the candidate, and
		 run it through DFA. */
	      if ((end = memchr(beg, eol, buflim - beg)) != NULL)
	        end++;
              else
                end = buflim;
	      match = beg;
	      while (beg > buf && beg[-1] != eol)
		--beg;
	      if (kwsm.index < kwset_exact_matches)
                {
#ifdef MBS_SUPPORT
                  if (mb_start < beg)
                    mb_start = beg;
                  if (MB_CUR_MAX == 1 || !is_mb_middle (&mb_start, match, buflim))
#endif
                    goto success;
                }
	      if (dfaexec (&dfa, beg, (char *) end, 0, NULL, &backref) == NULL)
		continue;
	    }
	  else
	    {
	      /* No good fixed strings; start with DFA. */
	      char const *next_beg = dfaexec (&dfa, beg, (char *) buflim,
					      0, NULL, &backref);
	      if (next_beg == NULL)
		break;
	      /* Narrow down to the line we've found. */
	      beg = next_beg;
	      if ((end = memchr(beg, eol, buflim - beg)) != NULL)
	        end++;
              else
                end = buflim;
	      while (beg > buf && beg[-1] != eol)
		--beg;
	    }
	  /* Successful, no backreferences encountered! */
	  if (!backref)
	    goto success;
	}
      else
	{
	  /* We are looking for the leftmost (then longest) exact match.
	     We will go through the outer loop only once.  */
	  beg = start_ptr;
	  end = buflim;
	}

      /* If we've made it to this point, this means DFA has seen
	 a probable match, and we need to run it through Regex. */
      best_match = end;
      best_len = 0;
      for (i = 0; i < pcount; i++)
	{
	  patterns[i].regexbuf.not_eol = 0;
	  if (0 <= (start = re_search (&(patterns[i].regexbuf),
				       buf, end - buf - 1,
				       beg - buf, end - beg - 1,
				       &(patterns[i].regs))))
	    {
	      len = patterns[i].regs.end[0] - start;
	      match = buf + start;
	      if (match > best_match)
		continue;
	      if (start_ptr && !match_words)
		goto assess_pattern_match;
	      if ((!match_lines && !match_words)
		  || (match_lines && len == end - beg - 1))
		{
		  match = beg;
		  len = end - beg;
		  goto assess_pattern_match;
		}
	      /* If -w, check if the match aligns with word boundaries.
		 We do this iteratively because:
		 (a) the line may contain more than one occurence of the
		 pattern, and
		 (b) Several alternatives in the pattern might be valid at a
		 given point, and we may need to consider a shorter one to
		 find a word boundary.  */
	      if (match_words)
		while (match <= best_match)
		  {
		    if ((match == buf || !WCHAR ((unsigned char) match[-1]))
			&& (len == end - beg - 1
			    || !WCHAR ((unsigned char) match[len])))
		      goto assess_pattern_match;
		    if (len > 0)
		      {
			/* Try a shorter length anchored at the same place. */
			--len;
			patterns[i].regexbuf.not_eol = 1;
			len = re_match (&(patterns[i].regexbuf),
					buf, match + len - beg, match - buf,
					&(patterns[i].regs));
		      }
		    if (len <= 0)
		      {
			/* Try looking further on. */
			if (match == end - 1)
			  break;
			match++;
			patterns[i].regexbuf.not_eol = 0;
			start = re_search (&(patterns[i].regexbuf),
					   buf, end - buf - 1,
					   match - buf, end - match - 1,
					   &(patterns[i].regs));
			if (start < 0)
			  break;
			len = patterns[i].regs.end[0] - start;
			match = buf + start;
		      }
		  } /* while (match <= best_match) */
	      continue;
	    assess_pattern_match:
	      if (!start_ptr)
		{
		  /* Good enough for a non-exact match.
		     No need to look at further patterns, if any.  */
		  beg = match;
		  goto success_in_len;
		}
	      if (match < best_match || (match == best_match && len > best_len))
		{
		  /* Best exact match:  leftmost, then longest.  */
		  best_match = match;
		  best_len = len;
		}
	    } /* if re_search >= 0 */
	} /* for Regex patterns.  */
	if (best_match < end)
	  {
	    /* We have found an exact match.  We were just
	       waiting for the best one (leftmost then longest).  */
	    beg = best_match;
	    len = best_len;
	    goto success_in_len;
	  }
    } /* for (beg = end ..) */

 failure:
  ret_val = -1;
  goto out;

 success:
  len = end - beg;
 success_in_len:
  *match_size = len;
  ret_val = beg - buf;
 out:
  return ret_val;
}

Spawn 1 instances, now Total 1
Counter: 2
Batcher Size:1
Preprocess the following candidate with CondTester:
Priority 20000
At location src/dfasearch.c:113
--Src File: src/dfasearch.c
Fragment 0:
if (((err = kwsprep(kwset)) != ((void *)0)) && !(__abst_hole(err, kwset, dm, kwset_exact_matches)))
    error(EXIT_TROUBLE, 0, "%s", err);


CondTester, a patch instance with id 1:
//src_file:src/dfasearch.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); void* memset(void*, int, unsigned long); 
/* dfasearch.c - searching subroutines using dfa and regex for grep.
   Copyright 1992, 1998, 2000, 2007, 2009-2010 Free Software Foundation, Inc.

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 3, or (at your option)
   any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program; if not, write to the Free Software
   Foundation, Inc., 51 Franklin Street - Fifth Floor, Boston, MA
   02110-1301, USA.  */

/* Written August 1992 by Mike Haertel. */

#include <config.h>
#include "search.h"
#include "dfa.h"

/* For -w, we also consider _ to be word constituent.  */
#define WCHAR(C) (ISALNUM(C) || (C) == '_')

/* KWset compiled pattern.  For Ecompile and Gcompile, we compile
   a list of strings, at least one of which is known to occur in
   any string matching the regexp. */
static kwset_t kwset;

/* DFA compiled regexp. */
static struct dfa dfa;

/* The Regex compiled patterns.  */
static struct patterns
{
  /* Regex compiled regexp. */
  struct re_pattern_buffer regexbuf;
  struct re_registers regs; /* This is here on account of a BRAIN-DEAD
			       Q@#%!# library interface in regex.c.  */
} patterns0;

struct patterns *patterns;
size_t pcount;

void
dfaerror (char const *mesg)
{
  error (EXIT_TROUBLE, 0, "%s", mesg);

  /* notreached */
  /* Tell static analyzers that this function does not return.  */
  abort ();
}

/* Number of compiled fixed strings known to exactly match the regexp.
   If kwsexec returns < kwset_exact_matches, then we don't need to
   call the regexp matcher at all. */
static int kwset_exact_matches;

static char const *
kwsincr_case (const char *must)
{
  const char *buf;
  size_t n;

  n = strlen (must);
#ifdef MBS_SUPPORT
  if (match_icase && MB_CUR_MAX > 1)
    buf = mbtolower (must, &n);
  else
#endif
    buf = must;
  return kwsincr (kwset, buf, n);
}

/* If the DFA turns out to have some set of fixed strings one of
   which must occur in the match, then we build a kwset matcher
   to find those strings, and thus quickly filter out impossible
   matches. */
static void
kwsmusts (void)
{
  struct dfamust const *dm;
  char const *err;

  if (dfa.musts)
    {
      kwsinit (&kwset);
      /* First, we compile in the substrings known to be exact
	 matches.  The kwset matcher will return the index
	 of the matching string that it chooses. */
      for (dm = dfa.musts; dm; dm = dm->next)
	{
	  if (!dm->exact)
	    continue;
	  ++kwset_exact_matches;
	  if ((err = kwsincr_case (dm->must)) != NULL)
	    error (EXIT_TROUBLE, 0, "%s", err);
	}
      /* Now, we compile the substrings that will require
	 the use of the regexp matcher.  */
      for (dm = dfa.musts; dm; dm = dm->next)
	{
	  if (dm->exact)
	    continue;
	  if ((err = kwsincr_case (dm->must)) != NULL)
	    error (EXIT_TROUBLE, 0, "%s", err);
	}
      
//Patch 0:
if (((err = kwsprep(kwset)) != ((void *)0)) && !(__is_neg(4, &(err), sizeof (err), &(kwset), sizeof (kwset), &(dm), sizeof (dm), &(kwset_exact_matches), sizeof (kwset_exact_matches))))
    error(EXIT_TROUBLE, 0, "%s", err);

//CodeSeg 1:
    }
}

void
GEAcompile (char const *pattern, size_t size, reg_syntax_t syntax_bits)
{
  const char *err;
  const char *p, *sep;
  size_t total = size;
  char *motif;

  if (match_icase)
    syntax_bits |= RE_ICASE;
  re_set_syntax (syntax_bits);
  dfasyntax (syntax_bits, match_icase, eolbyte);

  /* For GNU regex compiler we have to pass the patterns separately to detect
     errors like "[\nallo\n]\n".  The patterns here are "[", "allo" and "]"
     GNU regex should have raise a syntax error.  The same for backref, where
     the backref should have been local to each pattern.  */
  p = pattern;
  do
    {
      size_t len;
      sep = memchr (p, '\n', total);
      if (sep)
	{
	  len = sep - p;
	  sep++;
	  total -= (len + 1);
	}
      else
	{
	  len = total;
	  total = 0;
	}

      patterns = realloc (patterns, (pcount + 1) * sizeof (*patterns));
      if (patterns == NULL)
	error (EXIT_TROUBLE, errno, _("memory exhausted"));
      patterns[pcount] = patterns0;

      if ((err = re_compile_pattern (p, len,
				    &(patterns[pcount].regexbuf))) != NULL)
	error (EXIT_TROUBLE, 0, "%s", err);
      pcount++;

      p = sep;
    } while (sep && total != 0);

  /* In the match_words and match_lines cases, we use a different pattern
     for the DFA matcher that will quickly throw out cases that won't work.
     Then if DFA succeeds we do some hairy stuff using the regex matcher
     to decide whether the match should really count. */
  if (match_words || match_lines)
    {
      static char const line_beg_no_bk[] = "^(";
      static char const line_end_no_bk[] = ")$";
      static char const word_beg_no_bk[] = "(^|[^[:alnum:]_])(";
      static char const word_end_no_bk[] = ")([^[:alnum:]_]|$)";
      static char const line_beg_bk[] = "^\\(";
      static char const line_end_bk[] = "\\)$";
      static char const word_beg_bk[] = "\\(^\\|[^[:alnum:]_]\\)\\(";
      static char const word_end_bk[] = "\\)\\([^[:alnum:]_]\\|$\\)";
      int bk = !(syntax_bits & RE_NO_BK_PARENS);
      char *n = xmalloc (sizeof word_beg_bk - 1 + size + sizeof word_end_bk);

      strcpy (n, match_lines ? (bk ? line_beg_bk : line_beg_no_bk)
			     : (bk ? word_beg_bk : word_beg_no_bk));
      total = strlen(n);
      memcpy (n + total, pattern, size);
      total += size;
      strcpy (n + total, match_lines ? (bk ? line_end_bk : line_end_no_bk)
				     : (bk ? word_end_bk : word_end_no_bk));
      total += strlen (n + total);
      pattern = motif = n;
      size = total;
    }
  else
    motif = NULL;

  dfacomp (pattern, size, &dfa, 1);
  kwsmusts ();

  free(motif);
}

size_t
EGexecute (char const *buf, size_t size, size_t *match_size,
	   char const *start_ptr)
{
  char const *buflim, *beg, *end, *match, *best_match, *mb_start;
  char eol = eolbyte;
  int backref, start, len, best_len;
  struct kwsmatch kwsm;
  size_t i, ret_val;
#ifdef MBS_SUPPORT
  if (MB_CUR_MAX > 1)
    {
      if (match_icase)
        {
          /* mbtolower adds a NUL byte at the end.  That will provide
	     space for the sentinel byte dfaexec may add.  */
          char *case_buf = mbtolower (buf, &size);
	  if (start_ptr)
	    start_ptr = case_buf + (start_ptr - buf);
          buf = case_buf;
        }
    }
#endif /* MBS_SUPPORT */

  mb_start = buf;
  buflim = buf + size;

  for (beg = end = buf; end < buflim; beg = end)
    {
      if (!start_ptr)
	{
	  /* We don't care about an exact match.  */
	  if (kwset)
	    {
	      /* Find a possible match using the KWset matcher. */
	      size_t offset = kwsexec (kwset, beg, buflim - beg, &kwsm);
	      if (offset == (size_t) -1)
		goto failure;
	      beg += offset;
	      /* Narrow down to the line containing the candidate, and
		 run it through DFA. */
	      if ((end = memchr(beg, eol, buflim - beg)) != NULL)
	        end++;
              else
                end = buflim;
	      match = beg;
	      while (beg > buf && beg[-1] != eol)
		--beg;
	      if (kwsm.index < kwset_exact_matches)
                {
#ifdef MBS_SUPPORT
                  if (mb_start < beg)
                    mb_start = beg;
                  if (MB_CUR_MAX == 1 || !is_mb_middle (&mb_start, match, buflim))
#endif
                    goto success;
                }
	      if (dfaexec (&dfa, beg, (char *) end, 0, NULL, &backref) == NULL)
		continue;
	    }
	  else
	    {
	      /* No good fixed strings; start with DFA. */
	      char const *next_beg = dfaexec (&dfa, beg, (char *) buflim,
					      0, NULL, &backref);
	      if (next_beg == NULL)
		break;
	      /* Narrow down to the line we've found. */
	      beg = next_beg;
	      if ((end = memchr(beg, eol, buflim - beg)) != NULL)
	        end++;
              else
                end = buflim;
	      while (beg > buf && beg[-1] != eol)
		--beg;
	    }
	  /* Successful, no backreferences encountered! */
	  if (!backref)
	    goto success;
	}
      else
	{
	  /* We are looking for the leftmost (then longest) exact match.
	     We will go through the outer loop only once.  */
	  beg = start_ptr;
	  end = buflim;
	}

      /* If we've made it to this point, this means DFA has seen
	 a probable match, and we need to run it through Regex. */
      best_match = end;
      best_len = 0;
      for (i = 0; i < pcount; i++)
	{
	  patterns[i].regexbuf.not_eol = 0;
	  if (0 <= (start = re_search (&(patterns[i].regexbuf),
				       buf, end - buf - 1,
				       beg - buf, end - beg - 1,
				       &(patterns[i].regs))))
	    {
	      len = patterns[i].regs.end[0] - start;
	      match = buf + start;
	      if (match > best_match)
		continue;
	      if (start_ptr && !match_words)
		goto assess_pattern_match;
	      if ((!match_lines && !match_words)
		  || (match_lines && len == end - beg - 1))
		{
		  match = beg;
		  len = end - beg;
		  goto assess_pattern_match;
		}
	      /* If -w, check if the match aligns with word boundaries.
		 We do this iteratively because:
		 (a) the line may contain more than one occurence of the
		 pattern, and
		 (b) Several alternatives in the pattern might be valid at a
		 given point, and we may need to consider a shorter one to
		 find a word boundary.  */
	      if (match_words)
		while (match <= best_match)
		  {
		    if ((match == buf || !WCHAR ((unsigned char) match[-1]))
			&& (len == end - beg - 1
			    || !WCHAR ((unsigned char) match[len])))
		      goto assess_pattern_match;
		    if (len > 0)
		      {
			/* Try a shorter length anchored at the same place. */
			--len;
			patterns[i].regexbuf.not_eol = 1;
			len = re_match (&(patterns[i].regexbuf),
					buf, match + len - beg, match - buf,
					&(patterns[i].regs));
		      }
		    if (len <= 0)
		      {
			/* Try looking further on. */
			if (match == end - 1)
			  break;
			match++;
			patterns[i].regexbuf.not_eol = 0;
			start = re_search (&(patterns[i].regexbuf),
					   buf, end - buf - 1,
					   match - buf, end - match - 1,
					   &(patterns[i].regs));
			if (start < 0)
			  break;
			len = patterns[i].regs.end[0] - start;
			match = buf + start;
		      }
		  } /* while (match <= best_match) */
	      continue;
	    assess_pattern_match:
	      if (!start_ptr)
		{
		  /* Good enough for a non-exact match.
		     No need to look at further patterns, if any.  */
		  beg = match;
		  goto success_in_len;
		}
	      if (match < best_match || (match == best_match && len > best_len))
		{
		  /* Best exact match:  leftmost, then longest.  */
		  best_match = match;
		  best_len = len;
		}
	    } /* if re_search >= 0 */
	} /* for Regex patterns.  */
	if (best_match < end)
	  {
	    /* We have found an exact match.  We were just
	       waiting for the best one (leftmost then longest).  */
	    beg = best_match;
	    len = best_len;
	    goto success_in_len;
	  }
    } /* for (beg = end ..) */

 failure:
  ret_val = -1;
  goto out;

 success:
  len = end - beg;
 success_in_len:
  *match_size = len;
  ret_val = beg - buf;
 out:
  return ret_val;
}

Spawn 1 instances, now Total 2
Counter: 3
Batcher Size:2
Preprocess the following candidate with CondTester:
Priority 20000
At location src/dfasearch.c:157
--Src File: src/dfasearch.c
Fragment 0:
if (((err = rpl_re_compile_pattern(p, len, &(patterns[pcount].regexbuf))) != ((void *)0)) && !(__abst_hole(patterns, pcount, err, p, len, sep, total, match_words, match_lines, syntax_bits, size, pattern, match_icase, eolbyte, motif, patterns[pcount].regexbuf.buffer, patterns[pcount].regexbuf.allocated, patterns[pcount].regexbuf.used, patterns[pcount].regexbuf.syntax, patterns[pcount].regexbuf.fastmap, patterns[pcount].regexbuf.translate, patterns[pcount].regexbuf.re_nsub, patterns[pcount].regexbuf.can_be_null, patterns[pcount].regexbuf.regs_allocated, patterns[pcount].regexbuf.fastmap_accurate, patterns[pcount].regexbuf.no_sub, patterns[pcount].regexbuf.not_bol, patterns[pcount].regexbuf.not_eol, patterns[pcount].regexbuf.newline_anchor)))
    error(EXIT_TROUBLE, 0, "%s", err);


CondTester, a patch instance with id 2:
//src_file:src/dfasearch.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); void* memset(void*, int, unsigned long); 
/* dfasearch.c - searching subroutines using dfa and regex for grep.
   Copyright 1992, 1998, 2000, 2007, 2009-2010 Free Software Foundation, Inc.

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 3, or (at your option)
   any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program; if not, write to the Free Software
   Foundation, Inc., 51 Franklin Street - Fifth Floor, Boston, MA
   02110-1301, USA.  */

/* Written August 1992 by Mike Haertel. */

#include <config.h>
#include "search.h"
#include "dfa.h"

/* For -w, we also consider _ to be word constituent.  */
#define WCHAR(C) (ISALNUM(C) || (C) == '_')

/* KWset compiled pattern.  For Ecompile and Gcompile, we compile
   a list of strings, at least one of which is known to occur in
   any string matching the regexp. */
static kwset_t kwset;

/* DFA compiled regexp. */
static struct dfa dfa;

/* The Regex compiled patterns.  */
static struct patterns
{
  /* Regex compiled regexp. */
  struct re_pattern_buffer regexbuf;
  struct re_registers regs; /* This is here on account of a BRAIN-DEAD
			       Q@#%!# library interface in regex.c.  */
} patterns0;

struct patterns *patterns;
size_t pcount;

void
dfaerror (char const *mesg)
{
  error (EXIT_TROUBLE, 0, "%s", mesg);

  /* notreached */
  /* Tell static analyzers that this function does not return.  */
  abort ();
}

/* Number of compiled fixed strings known to exactly match the regexp.
   If kwsexec returns < kwset_exact_matches, then we don't need to
   call the regexp matcher at all. */
static int kwset_exact_matches;

static char const *
kwsincr_case (const char *must)
{
  const char *buf;
  size_t n;

  n = strlen (must);
#ifdef MBS_SUPPORT
  if (match_icase && MB_CUR_MAX > 1)
    buf = mbtolower (must, &n);
  else
#endif
    buf = must;
  return kwsincr (kwset, buf, n);
}

/* If the DFA turns out to have some set of fixed strings one of
   which must occur in the match, then we build a kwset matcher
   to find those strings, and thus quickly filter out impossible
   matches. */
static void
kwsmusts (void)
{
  struct dfamust const *dm;
  char const *err;

  if (dfa.musts)
    {
      kwsinit (&kwset);
      /* First, we compile in the substrings known to be exact
	 matches.  The kwset matcher will return the index
	 of the matching string that it chooses. */
      for (dm = dfa.musts; dm; dm = dm->next)
	{
	  if (!dm->exact)
	    continue;
	  ++kwset_exact_matches;
	  if ((err = kwsincr_case (dm->must)) != NULL)
	    error (EXIT_TROUBLE, 0, "%s", err);
	}
      /* Now, we compile the substrings that will require
	 the use of the regexp matcher.  */
      for (dm = dfa.musts; dm; dm = dm->next)
	{
	  if (dm->exact)
	    continue;
	  if ((err = kwsincr_case (dm->must)) != NULL)
	    error (EXIT_TROUBLE, 0, "%s", err);
	}
      if ((err = kwsprep (kwset)) != NULL)
	error (EXIT_TROUBLE, 0, "%s", err);
    }
}

void
GEAcompile (char const *pattern, size_t size, reg_syntax_t syntax_bits)
{
  const char *err;
  const char *p, *sep;
  size_t total = size;
  char *motif;

  if (match_icase)
    syntax_bits |= RE_ICASE;
  re_set_syntax (syntax_bits);
  dfasyntax (syntax_bits, match_icase, eolbyte);

  /* For GNU regex compiler we have to pass the patterns separately to detect
     errors like "[\nallo\n]\n".  The patterns here are "[", "allo" and "]"
     GNU regex should have raise a syntax error.  The same for backref, where
     the backref should have been local to each pattern.  */
  p = pattern;
  do
    {
      size_t len;
      sep = memchr (p, '\n', total);
      if (sep)
	{
	  len = sep - p;
	  sep++;
	  total -= (len + 1);
	}
      else
	{
	  len = total;
	  total = 0;
	}

      patterns = realloc (patterns, (pcount + 1) * sizeof (*patterns));
      if (patterns == NULL)
	error (EXIT_TROUBLE, errno, _("memory exhausted"));
      patterns[pcount] = patterns0;

      
//Patch 0:
if (((err = rpl_re_compile_pattern(p, len, &(patterns[pcount].regexbuf))) != ((void *)0)) && !(__is_neg(29, &(patterns), sizeof (patterns), &(pcount), sizeof (pcount), &(err), sizeof (err), &(p), sizeof (p), &(len), sizeof (len), &(sep), sizeof (sep), &(total), sizeof (total), &(match_words), sizeof (match_words), &(match_lines), sizeof (match_lines), &(syntax_bits), sizeof (syntax_bits), &(size), sizeof (size), &(pattern), sizeof (pattern), &(match_icase), sizeof (match_icase), &(eolbyte), sizeof (eolbyte), &(motif), sizeof (motif), &(patterns[pcount].regexbuf.buffer), sizeof (patterns[pcount].regexbuf.buffer), &(patterns[pcount].regexbuf.allocated), sizeof (patterns[pcount].regexbuf.allocated), &(patterns[pcount].regexbuf.used), sizeof (patterns[pcount].regexbuf.used), &(patterns[pcount].regexbuf.syntax), sizeof (patterns[pcount].regexbuf.syntax), &(patterns[pcount].regexbuf.fastmap), sizeof (patterns[pcount].regexbuf.fastmap), &(patterns[pcount].regexbuf.translate), sizeof (patterns[pcount].regexbuf.translate), &(patterns[pcount].regexbuf.re_nsub), sizeof (patterns[pcount].regexbuf.re_nsub), &(patterns[pcount].regexbuf.can_be_null), sizeof (patterns[pcount].regexbuf.can_be_null), &(patterns[pcount].regexbuf.regs_allocated), sizeof (patterns[pcount].regexbuf.regs_allocated), &(patterns[pcount].regexbuf.fastmap_accurate), sizeof (patterns[pcount].regexbuf.fastmap_accurate), &(patterns[pcount].regexbuf.no_sub), sizeof (patterns[pcount].regexbuf.no_sub), &(patterns[pcount].regexbuf.not_bol), sizeof (patterns[pcount].regexbuf.not_bol), &(patterns[pcount].regexbuf.not_eol), sizeof (patterns[pcount].regexbuf.not_eol), &(patterns[pcount].regexbuf.newline_anchor), sizeof (patterns[pcount].regexbuf.newline_anchor))))
    error(EXIT_TROUBLE, 0, "%s", err);

//CodeSeg 1:
      pcount++;

      p = sep;
    } while (sep && total != 0);

  /* In the match_words and match_lines cases, we use a different pattern
     for the DFA matcher that will quickly throw out cases that won't work.
     Then if DFA succeeds we do some hairy stuff using the regex matcher
     to decide whether the match should really count. */
  if (match_words || match_lines)
    {
      static char const line_beg_no_bk[] = "^(";
      static char const line_end_no_bk[] = ")$";
      static char const word_beg_no_bk[] = "(^|[^[:alnum:]_])(";
      static char const word_end_no_bk[] = ")([^[:alnum:]_]|$)";
      static char const line_beg_bk[] = "^\\(";
      static char const line_end_bk[] = "\\)$";
      static char const word_beg_bk[] = "\\(^\\|[^[:alnum:]_]\\)\\(";
      static char const word_end_bk[] = "\\)\\([^[:alnum:]_]\\|$\\)";
      int bk = !(syntax_bits & RE_NO_BK_PARENS);
      char *n = xmalloc (sizeof word_beg_bk - 1 + size + sizeof word_end_bk);

      strcpy (n, match_lines ? (bk ? line_beg_bk : line_beg_no_bk)
			     : (bk ? word_beg_bk : word_beg_no_bk));
      total = strlen(n);
      memcpy (n + total, pattern, size);
      total += size;
      strcpy (n + total, match_lines ? (bk ? line_end_bk : line_end_no_bk)
				     : (bk ? word_end_bk : word_end_no_bk));
      total += strlen (n + total);
      pattern = motif = n;
      size = total;
    }
  else
    motif = NULL;

  dfacomp (pattern, size, &dfa, 1);
  kwsmusts ();

  free(motif);
}

size_t
EGexecute (char const *buf, size_t size, size_t *match_size,
	   char const *start_ptr)
{
  char const *buflim, *beg, *end, *match, *best_match, *mb_start;
  char eol = eolbyte;
  int backref, start, len, best_len;
  struct kwsmatch kwsm;
  size_t i, ret_val;
#ifdef MBS_SUPPORT
  if (MB_CUR_MAX > 1)
    {
      if (match_icase)
        {
          /* mbtolower adds a NUL byte at the end.  That will provide
	     space for the sentinel byte dfaexec may add.  */
          char *case_buf = mbtolower (buf, &size);
	  if (start_ptr)
	    start_ptr = case_buf + (start_ptr - buf);
          buf = case_buf;
        }
    }
#endif /* MBS_SUPPORT */

  mb_start = buf;
  buflim = buf + size;

  for (beg = end = buf; end < buflim; beg = end)
    {
      if (!start_ptr)
	{
	  /* We don't care about an exact match.  */
	  if (kwset)
	    {
	      /* Find a possible match using the KWset matcher. */
	      size_t offset = kwsexec (kwset, beg, buflim - beg, &kwsm);
	      if (offset == (size_t) -1)
		goto failure;
	      beg += offset;
	      /* Narrow down to the line containing the candidate, and
		 run it through DFA. */
	      if ((end = memchr(beg, eol, buflim - beg)) != NULL)
	        end++;
              else
                end = buflim;
	      match = beg;
	      while (beg > buf && beg[-1] != eol)
		--beg;
	      if (kwsm.index < kwset_exact_matches)
                {
#ifdef MBS_SUPPORT
                  if (mb_start < beg)
                    mb_start = beg;
                  if (MB_CUR_MAX == 1 || !is_mb_middle (&mb_start, match, buflim))
#endif
                    goto success;
                }
	      if (dfaexec (&dfa, beg, (char *) end, 0, NULL, &backref) == NULL)
		continue;
	    }
	  else
	    {
	      /* No good fixed strings; start with DFA. */
	      char const *next_beg = dfaexec (&dfa, beg, (char *) buflim,
					      0, NULL, &backref);
	      if (next_beg == NULL)
		break;
	      /* Narrow down to the line we've found. */
	      beg = next_beg;
	      if ((end = memchr(beg, eol, buflim - beg)) != NULL)
	        end++;
              else
                end = buflim;
	      while (beg > buf && beg[-1] != eol)
		--beg;
	    }
	  /* Successful, no backreferences encountered! */
	  if (!backref)
	    goto success;
	}
      else
	{
	  /* We are looking for the leftmost (then longest) exact match.
	     We will go through the outer loop only once.  */
	  beg = start_ptr;
	  end = buflim;
	}

      /* If we've made it to this point, this means DFA has seen
	 a probable match, and we need to run it through Regex. */
      best_match = end;
      best_len = 0;
      for (i = 0; i < pcount; i++)
	{
	  patterns[i].regexbuf.not_eol = 0;
	  if (0 <= (start = re_search (&(patterns[i].regexbuf),
				       buf, end - buf - 1,
				       beg - buf, end - beg - 1,
				       &(patterns[i].regs))))
	    {
	      len = patterns[i].regs.end[0] - start;
	      match = buf + start;
	      if (match > best_match)
		continue;
	      if (start_ptr && !match_words)
		goto assess_pattern_match;
	      if ((!match_lines && !match_words)
		  || (match_lines && len == end - beg - 1))
		{
		  match = beg;
		  len = end - beg;
		  goto assess_pattern_match;
		}
	      /* If -w, check if the match aligns with word boundaries.
		 We do this iteratively because:
		 (a) the line may contain more than one occurence of the
		 pattern, and
		 (b) Several alternatives in the pattern might be valid at a
		 given point, and we may need to consider a shorter one to
		 find a word boundary.  */
	      if (match_words)
		while (match <= best_match)
		  {
		    if ((match == buf || !WCHAR ((unsigned char) match[-1]))
			&& (len == end - beg - 1
			    || !WCHAR ((unsigned char) match[len])))
		      goto assess_pattern_match;
		    if (len > 0)
		      {
			/* Try a shorter length anchored at the same place. */
			--len;
			patterns[i].regexbuf.not_eol = 1;
			len = re_match (&(patterns[i].regexbuf),
					buf, match + len - beg, match - buf,
					&(patterns[i].regs));
		      }
		    if (len <= 0)
		      {
			/* Try looking further on. */
			if (match == end - 1)
			  break;
			match++;
			patterns[i].regexbuf.not_eol = 0;
			start = re_search (&(patterns[i].regexbuf),
					   buf, end - buf - 1,
					   match - buf, end - match - 1,
					   &(patterns[i].regs));
			if (start < 0)
			  break;
			len = patterns[i].regs.end[0] - start;
			match = buf + start;
		      }
		  } /* while (match <= best_match) */
	      continue;
	    assess_pattern_match:
	      if (!start_ptr)
		{
		  /* Good enough for a non-exact match.
		     No need to look at further patterns, if any.  */
		  beg = match;
		  goto success_in_len;
		}
	      if (match < best_match || (match == best_match && len > best_len))
		{
		  /* Best exact match:  leftmost, then longest.  */
		  best_match = match;
		  best_len = len;
		}
	    } /* if re_search >= 0 */
	} /* for Regex patterns.  */
	if (best_match < end)
	  {
	    /* We have found an exact match.  We were just
	       waiting for the best one (leftmost then longest).  */
	    beg = best_match;
	    len = best_len;
	    goto success_in_len;
	  }
    } /* for (beg = end ..) */

 failure:
  ret_val = -1;
  goto out;

 success:
  len = end - beg;
 success_in_len:
  *match_size = len;
  ret_val = beg - buf;
 out:
  return ret_val;
}

Spawn 1 instances, now Total 3
Counter: 4
Batcher Size:3
Preprocess the following candidate with CondTester:
Priority 20000
At location src/dfasearch.c:157
--Src File: src/dfasearch.c
Fragment 0:
if (((err = rpl_re_compile_pattern(p, len, &(patterns[pcount].regexbuf))) != ((void *)0)) || (__abst_hole(patterns, pcount, err, p, len, sep, total, match_words, match_lines, syntax_bits, size, pattern, match_icase, eolbyte, motif, patterns[pcount].regexbuf.buffer, patterns[pcount].regexbuf.allocated, patterns[pcount].regexbuf.used, patterns[pcount].regexbuf.syntax, patterns[pcount].regexbuf.fastmap, patterns[pcount].regexbuf.translate, patterns[pcount].regexbuf.re_nsub, patterns[pcount].regexbuf.can_be_null, patterns[pcount].regexbuf.regs_allocated, patterns[pcount].regexbuf.fastmap_accurate, patterns[pcount].regexbuf.no_sub, patterns[pcount].regexbuf.not_bol, patterns[pcount].regexbuf.not_eol, patterns[pcount].regexbuf.newline_anchor)))
    error(EXIT_TROUBLE, 0, "%s", err);


CondTester, a patch instance with id 3:
//src_file:src/dfasearch.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); void* memset(void*, int, unsigned long); 
/* dfasearch.c - searching subroutines using dfa and regex for grep.
   Copyright 1992, 1998, 2000, 2007, 2009-2010 Free Software Foundation, Inc.

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 3, or (at your option)
   any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program; if not, write to the Free Software
   Foundation, Inc., 51 Franklin Street - Fifth Floor, Boston, MA
   02110-1301, USA.  */

/* Written August 1992 by Mike Haertel. */

#include <config.h>
#include "search.h"
#include "dfa.h"

/* For -w, we also consider _ to be word constituent.  */
#define WCHAR(C) (ISALNUM(C) || (C) == '_')

/* KWset compiled pattern.  For Ecompile and Gcompile, we compile
   a list of strings, at least one of which is known to occur in
   any string matching the regexp. */
static kwset_t kwset;

/* DFA compiled regexp. */
static struct dfa dfa;

/* The Regex compiled patterns.  */
static struct patterns
{
  /* Regex compiled regexp. */
  struct re_pattern_buffer regexbuf;
  struct re_registers regs; /* This is here on account of a BRAIN-DEAD
			       Q@#%!# library interface in regex.c.  */
} patterns0;

struct patterns *patterns;
size_t pcount;

void
dfaerror (char const *mesg)
{
  error (EXIT_TROUBLE, 0, "%s", mesg);

  /* notreached */
  /* Tell static analyzers that this function does not return.  */
  abort ();
}

/* Number of compiled fixed strings known to exactly match the regexp.
   If kwsexec returns < kwset_exact_matches, then we don't need to
   call the regexp matcher at all. */
static int kwset_exact_matches;

static char const *
kwsincr_case (const char *must)
{
  const char *buf;
  size_t n;

  n = strlen (must);
#ifdef MBS_SUPPORT
  if (match_icase && MB_CUR_MAX > 1)
    buf = mbtolower (must, &n);
  else
#endif
    buf = must;
  return kwsincr (kwset, buf, n);
}

/* If the DFA turns out to have some set of fixed strings one of
   which must occur in the match, then we build a kwset matcher
   to find those strings, and thus quickly filter out impossible
   matches. */
static void
kwsmusts (void)
{
  struct dfamust const *dm;
  char const *err;

  if (dfa.musts)
    {
      kwsinit (&kwset);
      /* First, we compile in the substrings known to be exact
	 matches.  The kwset matcher will return the index
	 of the matching string that it chooses. */
      for (dm = dfa.musts; dm; dm = dm->next)
	{
	  if (!dm->exact)
	    continue;
	  ++kwset_exact_matches;
	  if ((err = kwsincr_case (dm->must)) != NULL)
	    error (EXIT_TROUBLE, 0, "%s", err);
	}
      /* Now, we compile the substrings that will require
	 the use of the regexp matcher.  */
      for (dm = dfa.musts; dm; dm = dm->next)
	{
	  if (dm->exact)
	    continue;
	  if ((err = kwsincr_case (dm->must)) != NULL)
	    error (EXIT_TROUBLE, 0, "%s", err);
	}
      if ((err = kwsprep (kwset)) != NULL)
	error (EXIT_TROUBLE, 0, "%s", err);
    }
}

void
GEAcompile (char const *pattern, size_t size, reg_syntax_t syntax_bits)
{
  const char *err;
  const char *p, *sep;
  size_t total = size;
  char *motif;

  if (match_icase)
    syntax_bits |= RE_ICASE;
  re_set_syntax (syntax_bits);
  dfasyntax (syntax_bits, match_icase, eolbyte);

  /* For GNU regex compiler we have to pass the patterns separately to detect
     errors like "[\nallo\n]\n".  The patterns here are "[", "allo" and "]"
     GNU regex should have raise a syntax error.  The same for backref, where
     the backref should have been local to each pattern.  */
  p = pattern;
  do
    {
      size_t len;
      sep = memchr (p, '\n', total);
      if (sep)
	{
	  len = sep - p;
	  sep++;
	  total -= (len + 1);
	}
      else
	{
	  len = total;
	  total = 0;
	}

      patterns = realloc (patterns, (pcount + 1) * sizeof (*patterns));
      if (patterns == NULL)
	error (EXIT_TROUBLE, errno, _("memory exhausted"));
      patterns[pcount] = patterns0;

      
//Patch 0:
if (((err = rpl_re_compile_pattern(p, len, &(patterns[pcount].regexbuf))) != ((void *)0)) || (__is_neg(29, &(patterns), sizeof (patterns), &(pcount), sizeof (pcount), &(err), sizeof (err), &(p), sizeof (p), &(len), sizeof (len), &(sep), sizeof (sep), &(total), sizeof (total), &(match_words), sizeof (match_words), &(match_lines), sizeof (match_lines), &(syntax_bits), sizeof (syntax_bits), &(size), sizeof (size), &(pattern), sizeof (pattern), &(match_icase), sizeof (match_icase), &(eolbyte), sizeof (eolbyte), &(motif), sizeof (motif), &(patterns[pcount].regexbuf.buffer), sizeof (patterns[pcount].regexbuf.buffer), &(patterns[pcount].regexbuf.allocated), sizeof (patterns[pcount].regexbuf.allocated), &(patterns[pcount].regexbuf.used), sizeof (patterns[pcount].regexbuf.used), &(patterns[pcount].regexbuf.syntax), sizeof (patterns[pcount].regexbuf.syntax), &(patterns[pcount].regexbuf.fastmap), sizeof (patterns[pcount].regexbuf.fastmap), &(patterns[pcount].regexbuf.translate), sizeof (patterns[pcount].regexbuf.translate), &(patterns[pcount].regexbuf.re_nsub), sizeof (patterns[pcount].regexbuf.re_nsub), &(patterns[pcount].regexbuf.can_be_null), sizeof (patterns[pcount].regexbuf.can_be_null), &(patterns[pcount].regexbuf.regs_allocated), sizeof (patterns[pcount].regexbuf.regs_allocated), &(patterns[pcount].regexbuf.fastmap_accurate), sizeof (patterns[pcount].regexbuf.fastmap_accurate), &(patterns[pcount].regexbuf.no_sub), sizeof (patterns[pcount].regexbuf.no_sub), &(patterns[pcount].regexbuf.not_bol), sizeof (patterns[pcount].regexbuf.not_bol), &(patterns[pcount].regexbuf.not_eol), sizeof (patterns[pcount].regexbuf.not_eol), &(patterns[pcount].regexbuf.newline_anchor), sizeof (patterns[pcount].regexbuf.newline_anchor))))
    error(EXIT_TROUBLE, 0, "%s", err);

//CodeSeg 1:
      pcount++;

      p = sep;
    } while (sep && total != 0);

  /* In the match_words and match_lines cases, we use a different pattern
     for the DFA matcher that will quickly throw out cases that won't work.
     Then if DFA succeeds we do some hairy stuff using the regex matcher
     to decide whether the match should really count. */
  if (match_words || match_lines)
    {
      static char const line_beg_no_bk[] = "^(";
      static char const line_end_no_bk[] = ")$";
      static char const word_beg_no_bk[] = "(^|[^[:alnum:]_])(";
      static char const word_end_no_bk[] = ")([^[:alnum:]_]|$)";
      static char const line_beg_bk[] = "^\\(";
      static char const line_end_bk[] = "\\)$";
      static char const word_beg_bk[] = "\\(^\\|[^[:alnum:]_]\\)\\(";
      static char const word_end_bk[] = "\\)\\([^[:alnum:]_]\\|$\\)";
      int bk = !(syntax_bits & RE_NO_BK_PARENS);
      char *n = xmalloc (sizeof word_beg_bk - 1 + size + sizeof word_end_bk);

      strcpy (n, match_lines ? (bk ? line_beg_bk : line_beg_no_bk)
			     : (bk ? word_beg_bk : word_beg_no_bk));
      total = strlen(n);
      memcpy (n + total, pattern, size);
      total += size;
      strcpy (n + total, match_lines ? (bk ? line_end_bk : line_end_no_bk)
				     : (bk ? word_end_bk : word_end_no_bk));
      total += strlen (n + total);
      pattern = motif = n;
      size = total;
    }
  else
    motif = NULL;

  dfacomp (pattern, size, &dfa, 1);
  kwsmusts ();

  free(motif);
}

size_t
EGexecute (char const *buf, size_t size, size_t *match_size,
	   char const *start_ptr)
{
  char const *buflim, *beg, *end, *match, *best_match, *mb_start;
  char eol = eolbyte;
  int backref, start, len, best_len;
  struct kwsmatch kwsm;
  size_t i, ret_val;
#ifdef MBS_SUPPORT
  if (MB_CUR_MAX > 1)
    {
      if (match_icase)
        {
          /* mbtolower adds a NUL byte at the end.  That will provide
	     space for the sentinel byte dfaexec may add.  */
          char *case_buf = mbtolower (buf, &size);
	  if (start_ptr)
	    start_ptr = case_buf + (start_ptr - buf);
          buf = case_buf;
        }
    }
#endif /* MBS_SUPPORT */

  mb_start = buf;
  buflim = buf + size;

  for (beg = end = buf; end < buflim; beg = end)
    {
      if (!start_ptr)
	{
	  /* We don't care about an exact match.  */
	  if (kwset)
	    {
	      /* Find a possible match using the KWset matcher. */
	      size_t offset = kwsexec (kwset, beg, buflim - beg, &kwsm);
	      if (offset == (size_t) -1)
		goto failure;
	      beg += offset;
	      /* Narrow down to the line containing the candidate, and
		 run it through DFA. */
	      if ((end = memchr(beg, eol, buflim - beg)) != NULL)
	        end++;
              else
                end = buflim;
	      match = beg;
	      while (beg > buf && beg[-1] != eol)
		--beg;
	      if (kwsm.index < kwset_exact_matches)
                {
#ifdef MBS_SUPPORT
                  if (mb_start < beg)
                    mb_start = beg;
                  if (MB_CUR_MAX == 1 || !is_mb_middle (&mb_start, match, buflim))
#endif
                    goto success;
                }
	      if (dfaexec (&dfa, beg, (char *) end, 0, NULL, &backref) == NULL)
		continue;
	    }
	  else
	    {
	      /* No good fixed strings; start with DFA. */
	      char const *next_beg = dfaexec (&dfa, beg, (char *) buflim,
					      0, NULL, &backref);
	      if (next_beg == NULL)
		break;
	      /* Narrow down to the line we've found. */
	      beg = next_beg;
	      if ((end = memchr(beg, eol, buflim - beg)) != NULL)
	        end++;
              else
                end = buflim;
	      while (beg > buf && beg[-1] != eol)
		--beg;
	    }
	  /* Successful, no backreferences encountered! */
	  if (!backref)
	    goto success;
	}
      else
	{
	  /* We are looking for the leftmost (then longest) exact match.
	     We will go through the outer loop only once.  */
	  beg = start_ptr;
	  end = buflim;
	}

      /* If we've made it to this point, this means DFA has seen
	 a probable match, and we need to run it through Regex. */
      best_match = end;
      best_len = 0;
      for (i = 0; i < pcount; i++)
	{
	  patterns[i].regexbuf.not_eol = 0;
	  if (0 <= (start = re_search (&(patterns[i].regexbuf),
				       buf, end - buf - 1,
				       beg - buf, end - beg - 1,
				       &(patterns[i].regs))))
	    {
	      len = patterns[i].regs.end[0] - start;
	      match = buf + start;
	      if (match > best_match)
		continue;
	      if (start_ptr && !match_words)
		goto assess_pattern_match;
	      if ((!match_lines && !match_words)
		  || (match_lines && len == end - beg - 1))
		{
		  match = beg;
		  len = end - beg;
		  goto assess_pattern_match;
		}
	      /* If -w, check if the match aligns with word boundaries.
		 We do this iteratively because:
		 (a) the line may contain more than one occurence of the
		 pattern, and
		 (b) Several alternatives in the pattern might be valid at a
		 given point, and we may need to consider a shorter one to
		 find a word boundary.  */
	      if (match_words)
		while (match <= best_match)
		  {
		    if ((match == buf || !WCHAR ((unsigned char) match[-1]))
			&& (len == end - beg - 1
			    || !WCHAR ((unsigned char) match[len])))
		      goto assess_pattern_match;
		    if (len > 0)
		      {
			/* Try a shorter length anchored at the same place. */
			--len;
			patterns[i].regexbuf.not_eol = 1;
			len = re_match (&(patterns[i].regexbuf),
					buf, match + len - beg, match - buf,
					&(patterns[i].regs));
		      }
		    if (len <= 0)
		      {
			/* Try looking further on. */
			if (match == end - 1)
			  break;
			match++;
			patterns[i].regexbuf.not_eol = 0;
			start = re_search (&(patterns[i].regexbuf),
					   buf, end - buf - 1,
					   match - buf, end - match - 1,
					   &(patterns[i].regs));
			if (start < 0)
			  break;
			len = patterns[i].regs.end[0] - start;
			match = buf + start;
		      }
		  } /* while (match <= best_match) */
	      continue;
	    assess_pattern_match:
	      if (!start_ptr)
		{
		  /* Good enough for a non-exact match.
		     No need to look at further patterns, if any.  */
		  beg = match;
		  goto success_in_len;
		}
	      if (match < best_match || (match == best_match && len > best_len))
		{
		  /* Best exact match:  leftmost, then longest.  */
		  best_match = match;
		  best_len = len;
		}
	    } /* if re_search >= 0 */
	} /* for Regex patterns.  */
	if (best_match < end)
	  {
	    /* We have found an exact match.  We were just
	       waiting for the best one (leftmost then longest).  */
	    beg = best_match;
	    len = best_len;
	    goto success_in_len;
	  }
    } /* for (beg = end ..) */

 failure:
  ret_val = -1;
  goto out;

 success:
  len = end - beg;
 success_in_len:
  *match_size = len;
  ret_val = beg - buf;
 out:
  return ret_val;
}

Spawn 1 instances, now Total 4
Counter: 5
Batcher Size:4
Preprocess the following candidate with CondTester:
Priority 20000
At location src/dfasearch.c:169
--Src File: src/dfasearch.c
Fragment 0:
if ((match_words || match_lines) && !(__abst_hole(match_words, match_lines, sep, total, p, pcount, syntax_bits, err, size, patterns, pattern, motif, match_icase, eolbyte))) {
    static const char line_beg_no_bk[] = "^(";
    static const char line_end_no_bk[] = ")$";
    static const char word_beg_no_bk[] = "(^|[^[:alnum:]_])(";
    static const char word_end_no_bk[] = ")([^[:alnum:]_]|$)";
    static const char line_beg_bk[] = "^\\(";
    static const char line_end_bk[] = "\\)$";
    static const char word_beg_bk[] = "\\(^\\|[^[:alnum:]_]\\)\\(";
    static const char word_end_bk[] = "\\)\\([^[:alnum:]_]\\|$\\)";
    int bk = !(syntax_bits & (((((((((((((((unsigned long)1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1));
    char *n = xmalloc(sizeof word_beg_bk - 1 + size + sizeof word_end_bk);
    strcpy(n, match_lines ? (bk ? line_beg_bk : line_beg_no_bk) : (bk ? word_beg_bk : word_beg_no_bk));
    total = strlen(n);
    memcpy(n + total, pattern, size);
    total += size;
    strcpy(n + total, match_lines ? (bk ? line_end_bk : line_end_no_bk) : (bk ? word_end_bk : word_end_no_bk));
    total += strlen(n + total);
    pattern = motif = n;
    size = total;
} else
    motif = ((void *)0);


CondTester, a patch instance with id 4:
//src_file:src/dfasearch.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); void* memset(void*, int, unsigned long); 
/* dfasearch.c - searching subroutines using dfa and regex for grep.
   Copyright 1992, 1998, 2000, 2007, 2009-2010 Free Software Foundation, Inc.

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 3, or (at your option)
   any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program; if not, write to the Free Software
   Foundation, Inc., 51 Franklin Street - Fifth Floor, Boston, MA
   02110-1301, USA.  */

/* Written August 1992 by Mike Haertel. */

#include <config.h>
#include "search.h"
#include "dfa.h"

/* For -w, we also consider _ to be word constituent.  */
#define WCHAR(C) (ISALNUM(C) || (C) == '_')

/* KWset compiled pattern.  For Ecompile and Gcompile, we compile
   a list of strings, at least one of which is known to occur in
   any string matching the regexp. */
static kwset_t kwset;

/* DFA compiled regexp. */
static struct dfa dfa;

/* The Regex compiled patterns.  */
static struct patterns
{
  /* Regex compiled regexp. */
  struct re_pattern_buffer regexbuf;
  struct re_registers regs; /* This is here on account of a BRAIN-DEAD
			       Q@#%!# library interface in regex.c.  */
} patterns0;

struct patterns *patterns;
size_t pcount;

void
dfaerror (char const *mesg)
{
  error (EXIT_TROUBLE, 0, "%s", mesg);

  /* notreached */
  /* Tell static analyzers that this function does not return.  */
  abort ();
}

/* Number of compiled fixed strings known to exactly match the regexp.
   If kwsexec returns < kwset_exact_matches, then we don't need to
   call the regexp matcher at all. */
static int kwset_exact_matches;

static char const *
kwsincr_case (const char *must)
{
  const char *buf;
  size_t n;

  n = strlen (must);
#ifdef MBS_SUPPORT
  if (match_icase && MB_CUR_MAX > 1)
    buf = mbtolower (must, &n);
  else
#endif
    buf = must;
  return kwsincr (kwset, buf, n);
}

/* If the DFA turns out to have some set of fixed strings one of
   which must occur in the match, then we build a kwset matcher
   to find those strings, and thus quickly filter out impossible
   matches. */
static void
kwsmusts (void)
{
  struct dfamust const *dm;
  char const *err;

  if (dfa.musts)
    {
      kwsinit (&kwset);
      /* First, we compile in the substrings known to be exact
	 matches.  The kwset matcher will return the index
	 of the matching string that it chooses. */
      for (dm = dfa.musts; dm; dm = dm->next)
	{
	  if (!dm->exact)
	    continue;
	  ++kwset_exact_matches;
	  if ((err = kwsincr_case (dm->must)) != NULL)
	    error (EXIT_TROUBLE, 0, "%s", err);
	}
      /* Now, we compile the substrings that will require
	 the use of the regexp matcher.  */
      for (dm = dfa.musts; dm; dm = dm->next)
	{
	  if (dm->exact)
	    continue;
	  if ((err = kwsincr_case (dm->must)) != NULL)
	    error (EXIT_TROUBLE, 0, "%s", err);
	}
      if ((err = kwsprep (kwset)) != NULL)
	error (EXIT_TROUBLE, 0, "%s", err);
    }
}

void
GEAcompile (char const *pattern, size_t size, reg_syntax_t syntax_bits)
{
  const char *err;
  const char *p, *sep;
  size_t total = size;
  char *motif;

  if (match_icase)
    syntax_bits |= RE_ICASE;
  re_set_syntax (syntax_bits);
  dfasyntax (syntax_bits, match_icase, eolbyte);

  /* For GNU regex compiler we have to pass the patterns separately to detect
     errors like "[\nallo\n]\n".  The patterns here are "[", "allo" and "]"
     GNU regex should have raise a syntax error.  The same for backref, where
     the backref should have been local to each pattern.  */
  p = pattern;
  do
    {
      size_t len;
      sep = memchr (p, '\n', total);
      if (sep)
	{
	  len = sep - p;
	  sep++;
	  total -= (len + 1);
	}
      else
	{
	  len = total;
	  total = 0;
	}

      patterns = realloc (patterns, (pcount + 1) * sizeof (*patterns));
      if (patterns == NULL)
	error (EXIT_TROUBLE, errno, _("memory exhausted"));
      patterns[pcount] = patterns0;

      if ((err = re_compile_pattern (p, len,
				    &(patterns[pcount].regexbuf))) != NULL)
	error (EXIT_TROUBLE, 0, "%s", err);
      pcount++;

      p = sep;
    } while (sep && total != 0);

  /* In the match_words and match_lines cases, we use a different pattern
     for the DFA matcher that will quickly throw out cases that won't work.
     Then if DFA succeeds we do some hairy stuff using the regex matcher
     to decide whether the match should really count. */
  
//Patch 0:
if ((match_words || match_lines) && !(__is_neg(14, &(match_words), sizeof (match_words), &(match_lines), sizeof (match_lines), &(sep), sizeof (sep), &(total), sizeof (total), &(p), sizeof (p), &(pcount), sizeof (pcount), &(syntax_bits), sizeof (syntax_bits), &(err), sizeof (err), &(size), sizeof (size), &(patterns), sizeof (patterns), &(pattern), sizeof (pattern), &(motif), sizeof (motif), &(match_icase), sizeof (match_icase), &(eolbyte), sizeof (eolbyte)))) {
    static const char line_beg_no_bk[] = "^(";
    static const char line_end_no_bk[] = ")$";
    static const char word_beg_no_bk[] = "(^|[^[:alnum:]_])(";
    static const char word_end_no_bk[] = ")([^[:alnum:]_]|$)";
    static const char line_beg_bk[] = "^\\(";
    static const char line_end_bk[] = "\\)$";
    static const char word_beg_bk[] = "\\(^\\|[^[:alnum:]_]\\)\\(";
    static const char word_end_bk[] = "\\)\\([^[:alnum:]_]\\|$\\)";
    int bk = !(syntax_bits & (((((((((((((((unsigned long)1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1));
    char *n = xmalloc(sizeof word_beg_bk - 1 + size + sizeof word_end_bk);
    strcpy(n, match_lines ? (bk ? line_beg_bk : line_beg_no_bk) : (bk ? word_beg_bk : word_beg_no_bk));
    total = strlen(n);
    memcpy(n + total, pattern, size);
    total += size;
    strcpy(n + total, match_lines ? (bk ? line_end_bk : line_end_no_bk) : (bk ? word_end_bk : word_end_no_bk));
    total += strlen(n + total);
    pattern = motif = n;
    size = total;
} else
    motif = ((void *)0);

//CodeSeg 1:

  dfacomp (pattern, size, &dfa, 1);
  kwsmusts ();

  free(motif);
}

size_t
EGexecute (char const *buf, size_t size, size_t *match_size,
	   char const *start_ptr)
{
  char const *buflim, *beg, *end, *match, *best_match, *mb_start;
  char eol = eolbyte;
  int backref, start, len, best_len;
  struct kwsmatch kwsm;
  size_t i, ret_val;
#ifdef MBS_SUPPORT
  if (MB_CUR_MAX > 1)
    {
      if (match_icase)
        {
          /* mbtolower adds a NUL byte at the end.  That will provide
	     space for the sentinel byte dfaexec may add.  */
          char *case_buf = mbtolower (buf, &size);
	  if (start_ptr)
	    start_ptr = case_buf + (start_ptr - buf);
          buf = case_buf;
        }
    }
#endif /* MBS_SUPPORT */

  mb_start = buf;
  buflim = buf + size;

  for (beg = end = buf; end < buflim; beg = end)
    {
      if (!start_ptr)
	{
	  /* We don't care about an exact match.  */
	  if (kwset)
	    {
	      /* Find a possible match using the KWset matcher. */
	      size_t offset = kwsexec (kwset, beg, buflim - beg, &kwsm);
	      if (offset == (size_t) -1)
		goto failure;
	      beg += offset;
	      /* Narrow down to the line containing the candidate, and
		 run it through DFA. */
	      if ((end = memchr(beg, eol, buflim - beg)) != NULL)
	        end++;
              else
                end = buflim;
	      match = beg;
	      while (beg > buf && beg[-1] != eol)
		--beg;
	      if (kwsm.index < kwset_exact_matches)
                {
#ifdef MBS_SUPPORT
                  if (mb_start < beg)
                    mb_start = beg;
                  if (MB_CUR_MAX == 1 || !is_mb_middle (&mb_start, match, buflim))
#endif
                    goto success;
                }
	      if (dfaexec (&dfa, beg, (char *) end, 0, NULL, &backref) == NULL)
		continue;
	    }
	  else
	    {
	      /* No good fixed strings; start with DFA. */
	      char const *next_beg = dfaexec (&dfa, beg, (char *) buflim,
					      0, NULL, &backref);
	      if (next_beg == NULL)
		break;
	      /* Narrow down to the line we've found. */
	      beg = next_beg;
	      if ((end = memchr(beg, eol, buflim - beg)) != NULL)
	        end++;
              else
                end = buflim;
	      while (beg > buf && beg[-1] != eol)
		--beg;
	    }
	  /* Successful, no backreferences encountered! */
	  if (!backref)
	    goto success;
	}
      else
	{
	  /* We are looking for the leftmost (then longest) exact match.
	     We will go through the outer loop only once.  */
	  beg = start_ptr;
	  end = buflim;
	}

      /* If we've made it to this point, this means DFA has seen
	 a probable match, and we need to run it through Regex. */
      best_match = end;
      best_len = 0;
      for (i = 0; i < pcount; i++)
	{
	  patterns[i].regexbuf.not_eol = 0;
	  if (0 <= (start = re_search (&(patterns[i].regexbuf),
				       buf, end - buf - 1,
				       beg - buf, end - beg - 1,
				       &(patterns[i].regs))))
	    {
	      len = patterns[i].regs.end[0] - start;
	      match = buf + start;
	      if (match > best_match)
		continue;
	      if (start_ptr && !match_words)
		goto assess_pattern_match;
	      if ((!match_lines && !match_words)
		  || (match_lines && len == end - beg - 1))
		{
		  match = beg;
		  len = end - beg;
		  goto assess_pattern_match;
		}
	      /* If -w, check if the match aligns with word boundaries.
		 We do this iteratively because:
		 (a) the line may contain more than one occurence of the
		 pattern, and
		 (b) Several alternatives in the pattern might be valid at a
		 given point, and we may need to consider a shorter one to
		 find a word boundary.  */
	      if (match_words)
		while (match <= best_match)
		  {
		    if ((match == buf || !WCHAR ((unsigned char) match[-1]))
			&& (len == end - beg - 1
			    || !WCHAR ((unsigned char) match[len])))
		      goto assess_pattern_match;
		    if (len > 0)
		      {
			/* Try a shorter length anchored at the same place. */
			--len;
			patterns[i].regexbuf.not_eol = 1;
			len = re_match (&(patterns[i].regexbuf),
					buf, match + len - beg, match - buf,
					&(patterns[i].regs));
		      }
		    if (len <= 0)
		      {
			/* Try looking further on. */
			if (match == end - 1)
			  break;
			match++;
			patterns[i].regexbuf.not_eol = 0;
			start = re_search (&(patterns[i].regexbuf),
					   buf, end - buf - 1,
					   match - buf, end - match - 1,
					   &(patterns[i].regs));
			if (start < 0)
			  break;
			len = patterns[i].regs.end[0] - start;
			match = buf + start;
		      }
		  } /* while (match <= best_match) */
	      continue;
	    assess_pattern_match:
	      if (!start_ptr)
		{
		  /* Good enough for a non-exact match.
		     No need to look at further patterns, if any.  */
		  beg = match;
		  goto success_in_len;
		}
	      if (match < best_match || (match == best_match && len > best_len))
		{
		  /* Best exact match:  leftmost, then longest.  */
		  best_match = match;
		  best_len = len;
		}
	    } /* if re_search >= 0 */
	} /* for Regex patterns.  */
	if (best_match < end)
	  {
	    /* We have found an exact match.  We were just
	       waiting for the best one (leftmost then longest).  */
	    beg = best_match;
	    len = best_len;
	    goto success_in_len;
	  }
    } /* for (beg = end ..) */

 failure:
  ret_val = -1;
  goto out;

 success:
  len = end - beg;
 success_in_len:
  *match_size = len;
  ret_val = beg - buf;
 out:
  return ret_val;
}

Spawn 1 instances, now Total 5
Counter: 6
Batcher Size:5
Preprocess the following candidate with CondTester:
Priority 20000
At location src/dfasearch.c:238
--Src File: src/dfasearch.c
Fragment 0:
if ((offset == (size_t)-1) && !(__abst_hole(offset, buflim, beg, kwset, end, eol, start_ptr, buf, match, size, mb_start, kwset_exact_matches, kwsm.index, backref, match_icase, eolbyte, best_match, best_len, i, pcount, patterns, start, len, match_words, match_lines, ret_val, match_size)))
    goto failure;


CondTester, a patch instance with id 5:
//src_file:src/dfasearch.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); void* memset(void*, int, unsigned long); 
/* dfasearch.c - searching subroutines using dfa and regex for grep.
   Copyright 1992, 1998, 2000, 2007, 2009-2010 Free Software Foundation, Inc.

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 3, or (at your option)
   any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program; if not, write to the Free Software
   Foundation, Inc., 51 Franklin Street - Fifth Floor, Boston, MA
   02110-1301, USA.  */

/* Written August 1992 by Mike Haertel. */

#include <config.h>
#include "search.h"
#include "dfa.h"

/* For -w, we also consider _ to be word constituent.  */
#define WCHAR(C) (ISALNUM(C) || (C) == '_')

/* KWset compiled pattern.  For Ecompile and Gcompile, we compile
   a list of strings, at least one of which is known to occur in
   any string matching the regexp. */
static kwset_t kwset;

/* DFA compiled regexp. */
static struct dfa dfa;

/* The Regex compiled patterns.  */
static struct patterns
{
  /* Regex compiled regexp. */
  struct re_pattern_buffer regexbuf;
  struct re_registers regs; /* This is here on account of a BRAIN-DEAD
			       Q@#%!# library interface in regex.c.  */
} patterns0;

struct patterns *patterns;
size_t pcount;

void
dfaerror (char const *mesg)
{
  error (EXIT_TROUBLE, 0, "%s", mesg);

  /* notreached */
  /* Tell static analyzers that this function does not return.  */
  abort ();
}

/* Number of compiled fixed strings known to exactly match the regexp.
   If kwsexec returns < kwset_exact_matches, then we don't need to
   call the regexp matcher at all. */
static int kwset_exact_matches;

static char const *
kwsincr_case (const char *must)
{
  const char *buf;
  size_t n;

  n = strlen (must);
#ifdef MBS_SUPPORT
  if (match_icase && MB_CUR_MAX > 1)
    buf = mbtolower (must, &n);
  else
#endif
    buf = must;
  return kwsincr (kwset, buf, n);
}

/* If the DFA turns out to have some set of fixed strings one of
   which must occur in the match, then we build a kwset matcher
   to find those strings, and thus quickly filter out impossible
   matches. */
static void
kwsmusts (void)
{
  struct dfamust const *dm;
  char const *err;

  if (dfa.musts)
    {
      kwsinit (&kwset);
      /* First, we compile in the substrings known to be exact
	 matches.  The kwset matcher will return the index
	 of the matching string that it chooses. */
      for (dm = dfa.musts; dm; dm = dm->next)
	{
	  if (!dm->exact)
	    continue;
	  ++kwset_exact_matches;
	  if ((err = kwsincr_case (dm->must)) != NULL)
	    error (EXIT_TROUBLE, 0, "%s", err);
	}
      /* Now, we compile the substrings that will require
	 the use of the regexp matcher.  */
      for (dm = dfa.musts; dm; dm = dm->next)
	{
	  if (dm->exact)
	    continue;
	  if ((err = kwsincr_case (dm->must)) != NULL)
	    error (EXIT_TROUBLE, 0, "%s", err);
	}
      if ((err = kwsprep (kwset)) != NULL)
	error (EXIT_TROUBLE, 0, "%s", err);
    }
}

void
GEAcompile (char const *pattern, size_t size, reg_syntax_t syntax_bits)
{
  const char *err;
  const char *p, *sep;
  size_t total = size;
  char *motif;

  if (match_icase)
    syntax_bits |= RE_ICASE;
  re_set_syntax (syntax_bits);
  dfasyntax (syntax_bits, match_icase, eolbyte);

  /* For GNU regex compiler we have to pass the patterns separately to detect
     errors like "[\nallo\n]\n".  The patterns here are "[", "allo" and "]"
     GNU regex should have raise a syntax error.  The same for backref, where
     the backref should have been local to each pattern.  */
  p = pattern;
  do
    {
      size_t len;
      sep = memchr (p, '\n', total);
      if (sep)
	{
	  len = sep - p;
	  sep++;
	  total -= (len + 1);
	}
      else
	{
	  len = total;
	  total = 0;
	}

      patterns = realloc (patterns, (pcount + 1) * sizeof (*patterns));
      if (patterns == NULL)
	error (EXIT_TROUBLE, errno, _("memory exhausted"));
      patterns[pcount] = patterns0;

      if ((err = re_compile_pattern (p, len,
				    &(patterns[pcount].regexbuf))) != NULL)
	error (EXIT_TROUBLE, 0, "%s", err);
      pcount++;

      p = sep;
    } while (sep && total != 0);

  /* In the match_words and match_lines cases, we use a different pattern
     for the DFA matcher that will quickly throw out cases that won't work.
     Then if DFA succeeds we do some hairy stuff using the regex matcher
     to decide whether the match should really count. */
  if (match_words || match_lines)
    {
      static char const line_beg_no_bk[] = "^(";
      static char const line_end_no_bk[] = ")$";
      static char const word_beg_no_bk[] = "(^|[^[:alnum:]_])(";
      static char const word_end_no_bk[] = ")([^[:alnum:]_]|$)";
      static char const line_beg_bk[] = "^\\(";
      static char const line_end_bk[] = "\\)$";
      static char const word_beg_bk[] = "\\(^\\|[^[:alnum:]_]\\)\\(";
      static char const word_end_bk[] = "\\)\\([^[:alnum:]_]\\|$\\)";
      int bk = !(syntax_bits & RE_NO_BK_PARENS);
      char *n = xmalloc (sizeof word_beg_bk - 1 + size + sizeof word_end_bk);

      strcpy (n, match_lines ? (bk ? line_beg_bk : line_beg_no_bk)
			     : (bk ? word_beg_bk : word_beg_no_bk));
      total = strlen(n);
      memcpy (n + total, pattern, size);
      total += size;
      strcpy (n + total, match_lines ? (bk ? line_end_bk : line_end_no_bk)
				     : (bk ? word_end_bk : word_end_no_bk));
      total += strlen (n + total);
      pattern = motif = n;
      size = total;
    }
  else
    motif = NULL;

  dfacomp (pattern, size, &dfa, 1);
  kwsmusts ();

  free(motif);
}

size_t
EGexecute (char const *buf, size_t size, size_t *match_size,
	   char const *start_ptr)
{
  char const *buflim, *beg, *end, *match, *best_match, *mb_start;
  char eol = eolbyte;
  int backref, start, len, best_len;
  struct kwsmatch kwsm;
  size_t i, ret_val;
#ifdef MBS_SUPPORT
  if (MB_CUR_MAX > 1)
    {
      if (match_icase)
        {
          /* mbtolower adds a NUL byte at the end.  That will provide
	     space for the sentinel byte dfaexec may add.  */
          char *case_buf = mbtolower (buf, &size);
	  if (start_ptr)
	    start_ptr = case_buf + (start_ptr - buf);
          buf = case_buf;
        }
    }
#endif /* MBS_SUPPORT */

  mb_start = buf;
  buflim = buf + size;

  for (beg = end = buf; end < buflim; beg = end)
    {
      if (!start_ptr)
	{
	  /* We don't care about an exact match.  */
	  if (kwset)
	    {
	      /* Find a possible match using the KWset matcher. */
	      size_t offset = kwsexec (kwset, beg, buflim - beg, &kwsm);
	      
//Patch 0:
if ((offset == (size_t)-1) && !(__is_neg(27, &(offset), sizeof (offset), &(buflim), sizeof (buflim), &(beg), sizeof (beg), &(kwset), sizeof (kwset), &(end), sizeof (end), &(eol), sizeof (eol), &(start_ptr), sizeof (start_ptr), &(buf), sizeof (buf), &(match), sizeof (match), &(size), sizeof (size), &(mb_start), sizeof (mb_start), &(kwset_exact_matches), sizeof (kwset_exact_matches), &(kwsm.index), sizeof (kwsm.index), &(backref), sizeof (backref), &(match_icase), sizeof (match_icase), &(eolbyte), sizeof (eolbyte), &(best_match), sizeof (best_match), &(best_len), sizeof (best_len), &(i), sizeof (i), &(pcount), sizeof (pcount), &(patterns), sizeof (patterns), &(start), sizeof (start), &(len), sizeof (len), &(match_words), sizeof (match_words), &(match_lines), sizeof (match_lines), &(ret_val), sizeof (ret_val), &(match_size), sizeof (match_size))))
    goto failure;

//CodeSeg 1:
	      beg += offset;
	      /* Narrow down to the line containing the candidate, and
		 run it through DFA. */
	      if ((end = memchr(beg, eol, buflim - beg)) != NULL)
	        end++;
              else
                end = buflim;
	      match = beg;
	      while (beg > buf && beg[-1] != eol)
		--beg;
	      if (kwsm.index < kwset_exact_matches)
                {
#ifdef MBS_SUPPORT
                  if (mb_start < beg)
                    mb_start = beg;
                  if (MB_CUR_MAX == 1 || !is_mb_middle (&mb_start, match, buflim))
#endif
                    goto success;
                }
	      if (dfaexec (&dfa, beg, (char *) end, 0, NULL, &backref) == NULL)
		continue;
	    }
	  else
	    {
	      /* No good fixed strings; start with DFA. */
	      char const *next_beg = dfaexec (&dfa, beg, (char *) buflim,
					      0, NULL, &backref);
	      if (next_beg == NULL)
		break;
	      /* Narrow down to the line we've found. */
	      beg = next_beg;
	      if ((end = memchr(beg, eol, buflim - beg)) != NULL)
	        end++;
              else
                end = buflim;
	      while (beg > buf && beg[-1] != eol)
		--beg;
	    }
	  /* Successful, no backreferences encountered! */
	  if (!backref)
	    goto success;
	}
      else
	{
	  /* We are looking for the leftmost (then longest) exact match.
	     We will go through the outer loop only once.  */
	  beg = start_ptr;
	  end = buflim;
	}

      /* If we've made it to this point, this means DFA has seen
	 a probable match, and we need to run it through Regex. */
      best_match = end;
      best_len = 0;
      for (i = 0; i < pcount; i++)
	{
	  patterns[i].regexbuf.not_eol = 0;
	  if (0 <= (start = re_search (&(patterns[i].regexbuf),
				       buf, end - buf - 1,
				       beg - buf, end - beg - 1,
				       &(patterns[i].regs))))
	    {
	      len = patterns[i].regs.end[0] - start;
	      match = buf + start;
	      if (match > best_match)
		continue;
	      if (start_ptr && !match_words)
		goto assess_pattern_match;
	      if ((!match_lines && !match_words)
		  || (match_lines && len == end - beg - 1))
		{
		  match = beg;
		  len = end - beg;
		  goto assess_pattern_match;
		}
	      /* If -w, check if the match aligns with word boundaries.
		 We do this iteratively because:
		 (a) the line may contain more than one occurence of the
		 pattern, and
		 (b) Several alternatives in the pattern might be valid at a
		 given point, and we may need to consider a shorter one to
		 find a word boundary.  */
	      if (match_words)
		while (match <= best_match)
		  {
		    if ((match == buf || !WCHAR ((unsigned char) match[-1]))
			&& (len == end - beg - 1
			    || !WCHAR ((unsigned char) match[len])))
		      goto assess_pattern_match;
		    if (len > 0)
		      {
			/* Try a shorter length anchored at the same place. */
			--len;
			patterns[i].regexbuf.not_eol = 1;
			len = re_match (&(patterns[i].regexbuf),
					buf, match + len - beg, match - buf,
					&(patterns[i].regs));
		      }
		    if (len <= 0)
		      {
			/* Try looking further on. */
			if (match == end - 1)
			  break;
			match++;
			patterns[i].regexbuf.not_eol = 0;
			start = re_search (&(patterns[i].regexbuf),
					   buf, end - buf - 1,
					   match - buf, end - match - 1,
					   &(patterns[i].regs));
			if (start < 0)
			  break;
			len = patterns[i].regs.end[0] - start;
			match = buf + start;
		      }
		  } /* while (match <= best_match) */
	      continue;
	    assess_pattern_match:
	      if (!start_ptr)
		{
		  /* Good enough for a non-exact match.
		     No need to look at further patterns, if any.  */
		  beg = match;
		  goto success_in_len;
		}
	      if (match < best_match || (match == best_match && len > best_len))
		{
		  /* Best exact match:  leftmost, then longest.  */
		  best_match = match;
		  best_len = len;
		}
	    } /* if re_search >= 0 */
	} /* for Regex patterns.  */
	if (best_match < end)
	  {
	    /* We have found an exact match.  We were just
	       waiting for the best one (leftmost then longest).  */
	    beg = best_match;
	    len = best_len;
	    goto success_in_len;
	  }
    } /* for (beg = end ..) */

 failure:
  ret_val = -1;
  goto out;

 success:
  len = end - beg;
 success_in_len:
  *match_size = len;
  ret_val = beg - buf;
 out:
  return ret_val;
}

Spawn 1 instances, now Total 6
Counter: 7
Batcher Size:6
Preprocess the following candidate with CondTester:
Priority 20000
At location src/dfasearch.c:238
--Src File: src/dfasearch.c
Fragment 0:
if ((offset == (size_t)-1) || (__abst_hole(offset, buflim, beg, kwset, end, eol, start_ptr, buf, match, size, mb_start, kwset_exact_matches, kwsm.index, backref, match_icase, eolbyte, best_match, best_len, i, pcount, patterns, start, len, match_words, match_lines, ret_val, match_size)))
    goto failure;


CondTester, a patch instance with id 6:
//src_file:src/dfasearch.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); void* memset(void*, int, unsigned long); 
/* dfasearch.c - searching subroutines using dfa and regex for grep.
   Copyright 1992, 1998, 2000, 2007, 2009-2010 Free Software Foundation, Inc.

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 3, or (at your option)
   any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program; if not, write to the Free Software
   Foundation, Inc., 51 Franklin Street - Fifth Floor, Boston, MA
   02110-1301, USA.  */

/* Written August 1992 by Mike Haertel. */

#include <config.h>
#include "search.h"
#include "dfa.h"

/* For -w, we also consider _ to be word constituent.  */
#define WCHAR(C) (ISALNUM(C) || (C) == '_')

/* KWset compiled pattern.  For Ecompile and Gcompile, we compile
   a list of strings, at least one of which is known to occur in
   any string matching the regexp. */
static kwset_t kwset;

/* DFA compiled regexp. */
static struct dfa dfa;

/* The Regex compiled patterns.  */
static struct patterns
{
  /* Regex compiled regexp. */
  struct re_pattern_buffer regexbuf;
  struct re_registers regs; /* This is here on account of a BRAIN-DEAD
			       Q@#%!# library interface in regex.c.  */
} patterns0;

struct patterns *patterns;
size_t pcount;

void
dfaerror (char const *mesg)
{
  error (EXIT_TROUBLE, 0, "%s", mesg);

  /* notreached */
  /* Tell static analyzers that this function does not return.  */
  abort ();
}

/* Number of compiled fixed strings known to exactly match the regexp.
   If kwsexec returns < kwset_exact_matches, then we don't need to
   call the regexp matcher at all. */
static int kwset_exact_matches;

static char const *
kwsincr_case (const char *must)
{
  const char *buf;
  size_t n;

  n = strlen (must);
#ifdef MBS_SUPPORT
  if (match_icase && MB_CUR_MAX > 1)
    buf = mbtolower (must, &n);
  else
#endif
    buf = must;
  return kwsincr (kwset, buf, n);
}

/* If the DFA turns out to have some set of fixed strings one of
   which must occur in the match, then we build a kwset matcher
   to find those strings, and thus quickly filter out impossible
   matches. */
static void
kwsmusts (void)
{
  struct dfamust const *dm;
  char const *err;

  if (dfa.musts)
    {
      kwsinit (&kwset);
      /* First, we compile in the substrings known to be exact
	 matches.  The kwset matcher will return the index
	 of the matching string that it chooses. */
      for (dm = dfa.musts; dm; dm = dm->next)
	{
	  if (!dm->exact)
	    continue;
	  ++kwset_exact_matches;
	  if ((err = kwsincr_case (dm->must)) != NULL)
	    error (EXIT_TROUBLE, 0, "%s", err);
	}
      /* Now, we compile the substrings that will require
	 the use of the regexp matcher.  */
      for (dm = dfa.musts; dm; dm = dm->next)
	{
	  if (dm->exact)
	    continue;
	  if ((err = kwsincr_case (dm->must)) != NULL)
	    error (EXIT_TROUBLE, 0, "%s", err);
	}
      if ((err = kwsprep (kwset)) != NULL)
	error (EXIT_TROUBLE, 0, "%s", err);
    }
}

void
GEAcompile (char const *pattern, size_t size, reg_syntax_t syntax_bits)
{
  const char *err;
  const char *p, *sep;
  size_t total = size;
  char *motif;

  if (match_icase)
    syntax_bits |= RE_ICASE;
  re_set_syntax (syntax_bits);
  dfasyntax (syntax_bits, match_icase, eolbyte);

  /* For GNU regex compiler we have to pass the patterns separately to detect
     errors like "[\nallo\n]\n".  The patterns here are "[", "allo" and "]"
     GNU regex should have raise a syntax error.  The same for backref, where
     the backref should have been local to each pattern.  */
  p = pattern;
  do
    {
      size_t len;
      sep = memchr (p, '\n', total);
      if (sep)
	{
	  len = sep - p;
	  sep++;
	  total -= (len + 1);
	}
      else
	{
	  len = total;
	  total = 0;
	}

      patterns = realloc (patterns, (pcount + 1) * sizeof (*patterns));
      if (patterns == NULL)
	error (EXIT_TROUBLE, errno, _("memory exhausted"));
      patterns[pcount] = patterns0;

      if ((err = re_compile_pattern (p, len,
				    &(patterns[pcount].regexbuf))) != NULL)
	error (EXIT_TROUBLE, 0, "%s", err);
      pcount++;

      p = sep;
    } while (sep && total != 0);

  /* In the match_words and match_lines cases, we use a different pattern
     for the DFA matcher that will quickly throw out cases that won't work.
     Then if DFA succeeds we do some hairy stuff using the regex matcher
     to decide whether the match should really count. */
  if (match_words || match_lines)
    {
      static char const line_beg_no_bk[] = "^(";
      static char const line_end_no_bk[] = ")$";
      static char const word_beg_no_bk[] = "(^|[^[:alnum:]_])(";
      static char const word_end_no_bk[] = ")([^[:alnum:]_]|$)";
      static char const line_beg_bk[] = "^\\(";
      static char const line_end_bk[] = "\\)$";
      static char const word_beg_bk[] = "\\(^\\|[^[:alnum:]_]\\)\\(";
      static char const word_end_bk[] = "\\)\\([^[:alnum:]_]\\|$\\)";
      int bk = !(syntax_bits & RE_NO_BK_PARENS);
      char *n = xmalloc (sizeof word_beg_bk - 1 + size + sizeof word_end_bk);

      strcpy (n, match_lines ? (bk ? line_beg_bk : line_beg_no_bk)
			     : (bk ? word_beg_bk : word_beg_no_bk));
      total = strlen(n);
      memcpy (n + total, pattern, size);
      total += size;
      strcpy (n + total, match_lines ? (bk ? line_end_bk : line_end_no_bk)
				     : (bk ? word_end_bk : word_end_no_bk));
      total += strlen (n + total);
      pattern = motif = n;
      size = total;
    }
  else
    motif = NULL;

  dfacomp (pattern, size, &dfa, 1);
  kwsmusts ();

  free(motif);
}

size_t
EGexecute (char const *buf, size_t size, size_t *match_size,
	   char const *start_ptr)
{
  char const *buflim, *beg, *end, *match, *best_match, *mb_start;
  char eol = eolbyte;
  int backref, start, len, best_len;
  struct kwsmatch kwsm;
  size_t i, ret_val;
#ifdef MBS_SUPPORT
  if (MB_CUR_MAX > 1)
    {
      if (match_icase)
        {
          /* mbtolower adds a NUL byte at the end.  That will provide
	     space for the sentinel byte dfaexec may add.  */
          char *case_buf = mbtolower (buf, &size);
	  if (start_ptr)
	    start_ptr = case_buf + (start_ptr - buf);
          buf = case_buf;
        }
    }
#endif /* MBS_SUPPORT */

  mb_start = buf;
  buflim = buf + size;

  for (beg = end = buf; end < buflim; beg = end)
    {
      if (!start_ptr)
	{
	  /* We don't care about an exact match.  */
	  if (kwset)
	    {
	      /* Find a possible match using the KWset matcher. */
	      size_t offset = kwsexec (kwset, beg, buflim - beg, &kwsm);
	      
//Patch 0:
if ((offset == (size_t)-1) || (__is_neg(27, &(offset), sizeof (offset), &(buflim), sizeof (buflim), &(beg), sizeof (beg), &(kwset), sizeof (kwset), &(end), sizeof (end), &(eol), sizeof (eol), &(start_ptr), sizeof (start_ptr), &(buf), sizeof (buf), &(match), sizeof (match), &(size), sizeof (size), &(mb_start), sizeof (mb_start), &(kwset_exact_matches), sizeof (kwset_exact_matches), &(kwsm.index), sizeof (kwsm.index), &(backref), sizeof (backref), &(match_icase), sizeof (match_icase), &(eolbyte), sizeof (eolbyte), &(best_match), sizeof (best_match), &(best_len), sizeof (best_len), &(i), sizeof (i), &(pcount), sizeof (pcount), &(patterns), sizeof (patterns), &(start), sizeof (start), &(len), sizeof (len), &(match_words), sizeof (match_words), &(match_lines), sizeof (match_lines), &(ret_val), sizeof (ret_val), &(match_size), sizeof (match_size))))
    goto failure;

//CodeSeg 1:
	      beg += offset;
	      /* Narrow down to the line containing the candidate, and
		 run it through DFA. */
	      if ((end = memchr(beg, eol, buflim - beg)) != NULL)
	        end++;
              else
                end = buflim;
	      match = beg;
	      while (beg > buf && beg[-1] != eol)
		--beg;
	      if (kwsm.index < kwset_exact_matches)
                {
#ifdef MBS_SUPPORT
                  if (mb_start < beg)
                    mb_start = beg;
                  if (MB_CUR_MAX == 1 || !is_mb_middle (&mb_start, match, buflim))
#endif
                    goto success;
                }
	      if (dfaexec (&dfa, beg, (char *) end, 0, NULL, &backref) == NULL)
		continue;
	    }
	  else
	    {
	      /* No good fixed strings; start with DFA. */
	      char const *next_beg = dfaexec (&dfa, beg, (char *) buflim,
					      0, NULL, &backref);
	      if (next_beg == NULL)
		break;
	      /* Narrow down to the line we've found. */
	      beg = next_beg;
	      if ((end = memchr(beg, eol, buflim - beg)) != NULL)
	        end++;
              else
                end = buflim;
	      while (beg > buf && beg[-1] != eol)
		--beg;
	    }
	  /* Successful, no backreferences encountered! */
	  if (!backref)
	    goto success;
	}
      else
	{
	  /* We are looking for the leftmost (then longest) exact match.
	     We will go through the outer loop only once.  */
	  beg = start_ptr;
	  end = buflim;
	}

      /* If we've made it to this point, this means DFA has seen
	 a probable match, and we need to run it through Regex. */
      best_match = end;
      best_len = 0;
      for (i = 0; i < pcount; i++)
	{
	  patterns[i].regexbuf.not_eol = 0;
	  if (0 <= (start = re_search (&(patterns[i].regexbuf),
				       buf, end - buf - 1,
				       beg - buf, end - beg - 1,
				       &(patterns[i].regs))))
	    {
	      len = patterns[i].regs.end[0] - start;
	      match = buf + start;
	      if (match > best_match)
		continue;
	      if (start_ptr && !match_words)
		goto assess_pattern_match;
	      if ((!match_lines && !match_words)
		  || (match_lines && len == end - beg - 1))
		{
		  match = beg;
		  len = end - beg;
		  goto assess_pattern_match;
		}
	      /* If -w, check if the match aligns with word boundaries.
		 We do this iteratively because:
		 (a) the line may contain more than one occurence of the
		 pattern, and
		 (b) Several alternatives in the pattern might be valid at a
		 given point, and we may need to consider a shorter one to
		 find a word boundary.  */
	      if (match_words)
		while (match <= best_match)
		  {
		    if ((match == buf || !WCHAR ((unsigned char) match[-1]))
			&& (len == end - beg - 1
			    || !WCHAR ((unsigned char) match[len])))
		      goto assess_pattern_match;
		    if (len > 0)
		      {
			/* Try a shorter length anchored at the same place. */
			--len;
			patterns[i].regexbuf.not_eol = 1;
			len = re_match (&(patterns[i].regexbuf),
					buf, match + len - beg, match - buf,
					&(patterns[i].regs));
		      }
		    if (len <= 0)
		      {
			/* Try looking further on. */
			if (match == end - 1)
			  break;
			match++;
			patterns[i].regexbuf.not_eol = 0;
			start = re_search (&(patterns[i].regexbuf),
					   buf, end - buf - 1,
					   match - buf, end - match - 1,
					   &(patterns[i].regs));
			if (start < 0)
			  break;
			len = patterns[i].regs.end[0] - start;
			match = buf + start;
		      }
		  } /* while (match <= best_match) */
	      continue;
	    assess_pattern_match:
	      if (!start_ptr)
		{
		  /* Good enough for a non-exact match.
		     No need to look at further patterns, if any.  */
		  beg = match;
		  goto success_in_len;
		}
	      if (match < best_match || (match == best_match && len > best_len))
		{
		  /* Best exact match:  leftmost, then longest.  */
		  best_match = match;
		  best_len = len;
		}
	    } /* if re_search >= 0 */
	} /* for Regex patterns.  */
	if (best_match < end)
	  {
	    /* We have found an exact match.  We were just
	       waiting for the best one (leftmost then longest).  */
	    beg = best_match;
	    len = best_len;
	    goto success_in_len;
	  }
    } /* for (beg = end ..) */

 failure:
  ret_val = -1;
  goto out;

 success:
  len = end - beg;
 success_in_len:
  *match_size = len;
  ret_val = beg - buf;
 out:
  return ret_val;
}

Spawn 1 instances, now Total 7
Counter: 8
Batcher Size:7
Preprocess the following candidate with CondTester:
Priority 20000
At location src/dfasearch.c:169
--Src File: src/dfasearch.c
Fragment 0:
if ((match_words || match_lines) || (__abst_hole(match_words, match_lines, sep, total, p, pcount, syntax_bits, err, size, patterns, pattern, motif, match_icase, eolbyte))) {
    static const char line_beg_no_bk[] = "^(";
    static const char line_end_no_bk[] = ")$";
    static const char word_beg_no_bk[] = "(^|[^[:alnum:]_])(";
    static const char word_end_no_bk[] = ")([^[:alnum:]_]|$)";
    static const char line_beg_bk[] = "^\\(";
    static const char line_end_bk[] = "\\)$";
    static const char word_beg_bk[] = "\\(^\\|[^[:alnum:]_]\\)\\(";
    static const char word_end_bk[] = "\\)\\([^[:alnum:]_]\\|$\\)";
    int bk = !(syntax_bits & (((((((((((((((unsigned long)1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1));
    char *n = xmalloc(sizeof word_beg_bk - 1 + size + sizeof word_end_bk);
    strcpy(n, match_lines ? (bk ? line_beg_bk : line_beg_no_bk) : (bk ? word_beg_bk : word_beg_no_bk));
    total = strlen(n);
    memcpy(n + total, pattern, size);
    total += size;
    strcpy(n + total, match_lines ? (bk ? line_end_bk : line_end_no_bk) : (bk ? word_end_bk : word_end_no_bk));
    total += strlen(n + total);
    pattern = motif = n;
    size = total;
} else
    motif = ((void *)0);


CondTester, a patch instance with id 7:
//src_file:src/dfasearch.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); void* memset(void*, int, unsigned long); 
/* dfasearch.c - searching subroutines using dfa and regex for grep.
   Copyright 1992, 1998, 2000, 2007, 2009-2010 Free Software Foundation, Inc.

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 3, or (at your option)
   any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program; if not, write to the Free Software
   Foundation, Inc., 51 Franklin Street - Fifth Floor, Boston, MA
   02110-1301, USA.  */

/* Written August 1992 by Mike Haertel. */

#include <config.h>
#include "search.h"
#include "dfa.h"

/* For -w, we also consider _ to be word constituent.  */
#define WCHAR(C) (ISALNUM(C) || (C) == '_')

/* KWset compiled pattern.  For Ecompile and Gcompile, we compile
   a list of strings, at least one of which is known to occur in
   any string matching the regexp. */
static kwset_t kwset;

/* DFA compiled regexp. */
static struct dfa dfa;

/* The Regex compiled patterns.  */
static struct patterns
{
  /* Regex compiled regexp. */
  struct re_pattern_buffer regexbuf;
  struct re_registers regs; /* This is here on account of a BRAIN-DEAD
			       Q@#%!# library interface in regex.c.  */
} patterns0;

struct patterns *patterns;
size_t pcount;

void
dfaerror (char const *mesg)
{
  error (EXIT_TROUBLE, 0, "%s", mesg);

  /* notreached */
  /* Tell static analyzers that this function does not return.  */
  abort ();
}

/* Number of compiled fixed strings known to exactly match the regexp.
   If kwsexec returns < kwset_exact_matches, then we don't need to
   call the regexp matcher at all. */
static int kwset_exact_matches;

static char const *
kwsincr_case (const char *must)
{
  const char *buf;
  size_t n;

  n = strlen (must);
#ifdef MBS_SUPPORT
  if (match_icase && MB_CUR_MAX > 1)
    buf = mbtolower (must, &n);
  else
#endif
    buf = must;
  return kwsincr (kwset, buf, n);
}

/* If the DFA turns out to have some set of fixed strings one of
   which must occur in the match, then we build a kwset matcher
   to find those strings, and thus quickly filter out impossible
   matches. */
static void
kwsmusts (void)
{
  struct dfamust const *dm;
  char const *err;

  if (dfa.musts)
    {
      kwsinit (&kwset);
      /* First, we compile in the substrings known to be exact
	 matches.  The kwset matcher will return the index
	 of the matching string that it chooses. */
      for (dm = dfa.musts; dm; dm = dm->next)
	{
	  if (!dm->exact)
	    continue;
	  ++kwset_exact_matches;
	  if ((err = kwsincr_case (dm->must)) != NULL)
	    error (EXIT_TROUBLE, 0, "%s", err);
	}
      /* Now, we compile the substrings that will require
	 the use of the regexp matcher.  */
      for (dm = dfa.musts; dm; dm = dm->next)
	{
	  if (dm->exact)
	    continue;
	  if ((err = kwsincr_case (dm->must)) != NULL)
	    error (EXIT_TROUBLE, 0, "%s", err);
	}
      if ((err = kwsprep (kwset)) != NULL)
	error (EXIT_TROUBLE, 0, "%s", err);
    }
}

void
GEAcompile (char const *pattern, size_t size, reg_syntax_t syntax_bits)
{
  const char *err;
  const char *p, *sep;
  size_t total = size;
  char *motif;

  if (match_icase)
    syntax_bits |= RE_ICASE;
  re_set_syntax (syntax_bits);
  dfasyntax (syntax_bits, match_icase, eolbyte);

  /* For GNU regex compiler we have to pass the patterns separately to detect
     errors like "[\nallo\n]\n".  The patterns here are "[", "allo" and "]"
     GNU regex should have raise a syntax error.  The same for backref, where
     the backref should have been local to each pattern.  */
  p = pattern;
  do
    {
      size_t len;
      sep = memchr (p, '\n', total);
      if (sep)
	{
	  len = sep - p;
	  sep++;
	  total -= (len + 1);
	}
      else
	{
	  len = total;
	  total = 0;
	}

      patterns = realloc (patterns, (pcount + 1) * sizeof (*patterns));
      if (patterns == NULL)
	error (EXIT_TROUBLE, errno, _("memory exhausted"));
      patterns[pcount] = patterns0;

      if ((err = re_compile_pattern (p, len,
				    &(patterns[pcount].regexbuf))) != NULL)
	error (EXIT_TROUBLE, 0, "%s", err);
      pcount++;

      p = sep;
    } while (sep && total != 0);

  /* In the match_words and match_lines cases, we use a different pattern
     for the DFA matcher that will quickly throw out cases that won't work.
     Then if DFA succeeds we do some hairy stuff using the regex matcher
     to decide whether the match should really count. */
  
//Patch 0:
if ((match_words || match_lines) || (__is_neg(14, &(match_words), sizeof (match_words), &(match_lines), sizeof (match_lines), &(sep), sizeof (sep), &(total), sizeof (total), &(p), sizeof (p), &(pcount), sizeof (pcount), &(syntax_bits), sizeof (syntax_bits), &(err), sizeof (err), &(size), sizeof (size), &(patterns), sizeof (patterns), &(pattern), sizeof (pattern), &(motif), sizeof (motif), &(match_icase), sizeof (match_icase), &(eolbyte), sizeof (eolbyte)))) {
    static const char line_beg_no_bk[] = "^(";
    static const char line_end_no_bk[] = ")$";
    static const char word_beg_no_bk[] = "(^|[^[:alnum:]_])(";
    static const char word_end_no_bk[] = ")([^[:alnum:]_]|$)";
    static const char line_beg_bk[] = "^\\(";
    static const char line_end_bk[] = "\\)$";
    static const char word_beg_bk[] = "\\(^\\|[^[:alnum:]_]\\)\\(";
    static const char word_end_bk[] = "\\)\\([^[:alnum:]_]\\|$\\)";
    int bk = !(syntax_bits & (((((((((((((((unsigned long)1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1));
    char *n = xmalloc(sizeof word_beg_bk - 1 + size + sizeof word_end_bk);
    strcpy(n, match_lines ? (bk ? line_beg_bk : line_beg_no_bk) : (bk ? word_beg_bk : word_beg_no_bk));
    total = strlen(n);
    memcpy(n + total, pattern, size);
    total += size;
    strcpy(n + total, match_lines ? (bk ? line_end_bk : line_end_no_bk) : (bk ? word_end_bk : word_end_no_bk));
    total += strlen(n + total);
    pattern = motif = n;
    size = total;
} else
    motif = ((void *)0);

//CodeSeg 1:

  dfacomp (pattern, size, &dfa, 1);
  kwsmusts ();

  free(motif);
}

size_t
EGexecute (char const *buf, size_t size, size_t *match_size,
	   char const *start_ptr)
{
  char const *buflim, *beg, *end, *match, *best_match, *mb_start;
  char eol = eolbyte;
  int backref, start, len, best_len;
  struct kwsmatch kwsm;
  size_t i, ret_val;
#ifdef MBS_SUPPORT
  if (MB_CUR_MAX > 1)
    {
      if (match_icase)
        {
          /* mbtolower adds a NUL byte at the end.  That will provide
	     space for the sentinel byte dfaexec may add.  */
          char *case_buf = mbtolower (buf, &size);
	  if (start_ptr)
	    start_ptr = case_buf + (start_ptr - buf);
          buf = case_buf;
        }
    }
#endif /* MBS_SUPPORT */

  mb_start = buf;
  buflim = buf + size;

  for (beg = end = buf; end < buflim; beg = end)
    {
      if (!start_ptr)
	{
	  /* We don't care about an exact match.  */
	  if (kwset)
	    {
	      /* Find a possible match using the KWset matcher. */
	      size_t offset = kwsexec (kwset, beg, buflim - beg, &kwsm);
	      if (offset == (size_t) -1)
		goto failure;
	      beg += offset;
	      /* Narrow down to the line containing the candidate, and
		 run it through DFA. */
	      if ((end = memchr(beg, eol, buflim - beg)) != NULL)
	        end++;
              else
                end = buflim;
	      match = beg;
	      while (beg > buf && beg[-1] != eol)
		--beg;
	      if (kwsm.index < kwset_exact_matches)
                {
#ifdef MBS_SUPPORT
                  if (mb_start < beg)
                    mb_start = beg;
                  if (MB_CUR_MAX == 1 || !is_mb_middle (&mb_start, match, buflim))
#endif
                    goto success;
                }
	      if (dfaexec (&dfa, beg, (char *) end, 0, NULL, &backref) == NULL)
		continue;
	    }
	  else
	    {
	      /* No good fixed strings; start with DFA. */
	      char const *next_beg = dfaexec (&dfa, beg, (char *) buflim,
					      0, NULL, &backref);
	      if (next_beg == NULL)
		break;
	      /* Narrow down to the line we've found. */
	      beg = next_beg;
	      if ((end = memchr(beg, eol, buflim - beg)) != NULL)
	        end++;
              else
                end = buflim;
	      while (beg > buf && beg[-1] != eol)
		--beg;
	    }
	  /* Successful, no backreferences encountered! */
	  if (!backref)
	    goto success;
	}
      else
	{
	  /* We are looking for the leftmost (then longest) exact match.
	     We will go through the outer loop only once.  */
	  beg = start_ptr;
	  end = buflim;
	}

      /* If we've made it to this point, this means DFA has seen
	 a probable match, and we need to run it through Regex. */
      best_match = end;
      best_len = 0;
      for (i = 0; i < pcount; i++)
	{
	  patterns[i].regexbuf.not_eol = 0;
	  if (0 <= (start = re_search (&(patterns[i].regexbuf),
				       buf, end - buf - 1,
				       beg - buf, end - beg - 1,
				       &(patterns[i].regs))))
	    {
	      len = patterns[i].regs.end[0] - start;
	      match = buf + start;
	      if (match > best_match)
		continue;
	      if (start_ptr && !match_words)
		goto assess_pattern_match;
	      if ((!match_lines && !match_words)
		  || (match_lines && len == end - beg - 1))
		{
		  match = beg;
		  len = end - beg;
		  goto assess_pattern_match;
		}
	      /* If -w, check if the match aligns with word boundaries.
		 We do this iteratively because:
		 (a) the line may contain more than one occurence of the
		 pattern, and
		 (b) Several alternatives in the pattern might be valid at a
		 given point, and we may need to consider a shorter one to
		 find a word boundary.  */
	      if (match_words)
		while (match <= best_match)
		  {
		    if ((match == buf || !WCHAR ((unsigned char) match[-1]))
			&& (len == end - beg - 1
			    || !WCHAR ((unsigned char) match[len])))
		      goto assess_pattern_match;
		    if (len > 0)
		      {
			/* Try a shorter length anchored at the same place. */
			--len;
			patterns[i].regexbuf.not_eol = 1;
			len = re_match (&(patterns[i].regexbuf),
					buf, match + len - beg, match - buf,
					&(patterns[i].regs));
		      }
		    if (len <= 0)
		      {
			/* Try looking further on. */
			if (match == end - 1)
			  break;
			match++;
			patterns[i].regexbuf.not_eol = 0;
			start = re_search (&(patterns[i].regexbuf),
					   buf, end - buf - 1,
					   match - buf, end - match - 1,
					   &(patterns[i].regs));
			if (start < 0)
			  break;
			len = patterns[i].regs.end[0] - start;
			match = buf + start;
		      }
		  } /* while (match <= best_match) */
	      continue;
	    assess_pattern_match:
	      if (!start_ptr)
		{
		  /* Good enough for a non-exact match.
		     No need to look at further patterns, if any.  */
		  beg = match;
		  goto success_in_len;
		}
	      if (match < best_match || (match == best_match && len > best_len))
		{
		  /* Best exact match:  leftmost, then longest.  */
		  best_match = match;
		  best_len = len;
		}
	    } /* if re_search >= 0 */
	} /* for Regex patterns.  */
	if (best_match < end)
	  {
	    /* We have found an exact match.  We were just
	       waiting for the best one (leftmost then longest).  */
	    beg = best_match;
	    len = best_len;
	    goto success_in_len;
	  }
    } /* for (beg = end ..) */

 failure:
  ret_val = -1;
  goto out;

 success:
  len = end - beg;
 success_in_len:
  *match_size = len;
  ret_val = beg - buf;
 out:
  return ret_val;
}

Spawn 1 instances, now Total 8
Counter: 9
Batcher Size:8
Preprocess the following candidate with CondTester:
Priority 20000
At location src/dfasearch.c:357
--Src File: src/dfasearch.c
Fragment 0:
{
    if ((!start_ptr) && !(__abst_hole(start_ptr, beg, match, buf, start, len, i, patterns, best_match, best_len, end, ret_val, match_size, match_words, match_lines, pcount, buflim, backref, eol, mb_start, kwset_exact_matches, kwset, size, match_icase, eolbyte))) {
        beg = match;
        goto success_in_len;
    }
}


CondTester, a patch instance with id 8:
//src_file:src/dfasearch.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); void* memset(void*, int, unsigned long); 
/* dfasearch.c - searching subroutines using dfa and regex for grep.
   Copyright 1992, 1998, 2000, 2007, 2009-2010 Free Software Foundation, Inc.

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 3, or (at your option)
   any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program; if not, write to the Free Software
   Foundation, Inc., 51 Franklin Street - Fifth Floor, Boston, MA
   02110-1301, USA.  */

/* Written August 1992 by Mike Haertel. */

#include <config.h>
#include "search.h"
#include "dfa.h"

/* For -w, we also consider _ to be word constituent.  */
#define WCHAR(C) (ISALNUM(C) || (C) == '_')

/* KWset compiled pattern.  For Ecompile and Gcompile, we compile
   a list of strings, at least one of which is known to occur in
   any string matching the regexp. */
static kwset_t kwset;

/* DFA compiled regexp. */
static struct dfa dfa;

/* The Regex compiled patterns.  */
static struct patterns
{
  /* Regex compiled regexp. */
  struct re_pattern_buffer regexbuf;
  struct re_registers regs; /* This is here on account of a BRAIN-DEAD
			       Q@#%!# library interface in regex.c.  */
} patterns0;

struct patterns *patterns;
size_t pcount;

void
dfaerror (char const *mesg)
{
  error (EXIT_TROUBLE, 0, "%s", mesg);

  /* notreached */
  /* Tell static analyzers that this function does not return.  */
  abort ();
}

/* Number of compiled fixed strings known to exactly match the regexp.
   If kwsexec returns < kwset_exact_matches, then we don't need to
   call the regexp matcher at all. */
static int kwset_exact_matches;

static char const *
kwsincr_case (const char *must)
{
  const char *buf;
  size_t n;

  n = strlen (must);
#ifdef MBS_SUPPORT
  if (match_icase && MB_CUR_MAX > 1)
    buf = mbtolower (must, &n);
  else
#endif
    buf = must;
  return kwsincr (kwset, buf, n);
}

/* If the DFA turns out to have some set of fixed strings one of
   which must occur in the match, then we build a kwset matcher
   to find those strings, and thus quickly filter out impossible
   matches. */
static void
kwsmusts (void)
{
  struct dfamust const *dm;
  char const *err;

  if (dfa.musts)
    {
      kwsinit (&kwset);
      /* First, we compile in the substrings known to be exact
	 matches.  The kwset matcher will return the index
	 of the matching string that it chooses. */
      for (dm = dfa.musts; dm; dm = dm->next)
	{
	  if (!dm->exact)
	    continue;
	  ++kwset_exact_matches;
	  if ((err = kwsincr_case (dm->must)) != NULL)
	    error (EXIT_TROUBLE, 0, "%s", err);
	}
      /* Now, we compile the substrings that will require
	 the use of the regexp matcher.  */
      for (dm = dfa.musts; dm; dm = dm->next)
	{
	  if (dm->exact)
	    continue;
	  if ((err = kwsincr_case (dm->must)) != NULL)
	    error (EXIT_TROUBLE, 0, "%s", err);
	}
      if ((err = kwsprep (kwset)) != NULL)
	error (EXIT_TROUBLE, 0, "%s", err);
    }
}

void
GEAcompile (char const *pattern, size_t size, reg_syntax_t syntax_bits)
{
  const char *err;
  const char *p, *sep;
  size_t total = size;
  char *motif;

  if (match_icase)
    syntax_bits |= RE_ICASE;
  re_set_syntax (syntax_bits);
  dfasyntax (syntax_bits, match_icase, eolbyte);

  /* For GNU regex compiler we have to pass the patterns separately to detect
     errors like "[\nallo\n]\n".  The patterns here are "[", "allo" and "]"
     GNU regex should have raise a syntax error.  The same for backref, where
     the backref should have been local to each pattern.  */
  p = pattern;
  do
    {
      size_t len;
      sep = memchr (p, '\n', total);
      if (sep)
	{
	  len = sep - p;
	  sep++;
	  total -= (len + 1);
	}
      else
	{
	  len = total;
	  total = 0;
	}

      patterns = realloc (patterns, (pcount + 1) * sizeof (*patterns));
      if (patterns == NULL)
	error (EXIT_TROUBLE, errno, _("memory exhausted"));
      patterns[pcount] = patterns0;

      if ((err = re_compile_pattern (p, len,
				    &(patterns[pcount].regexbuf))) != NULL)
	error (EXIT_TROUBLE, 0, "%s", err);
      pcount++;

      p = sep;
    } while (sep && total != 0);

  /* In the match_words and match_lines cases, we use a different pattern
     for the DFA matcher that will quickly throw out cases that won't work.
     Then if DFA succeeds we do some hairy stuff using the regex matcher
     to decide whether the match should really count. */
  if (match_words || match_lines)
    {
      static char const line_beg_no_bk[] = "^(";
      static char const line_end_no_bk[] = ")$";
      static char const word_beg_no_bk[] = "(^|[^[:alnum:]_])(";
      static char const word_end_no_bk[] = ")([^[:alnum:]_]|$)";
      static char const line_beg_bk[] = "^\\(";
      static char const line_end_bk[] = "\\)$";
      static char const word_beg_bk[] = "\\(^\\|[^[:alnum:]_]\\)\\(";
      static char const word_end_bk[] = "\\)\\([^[:alnum:]_]\\|$\\)";
      int bk = !(syntax_bits & RE_NO_BK_PARENS);
      char *n = xmalloc (sizeof word_beg_bk - 1 + size + sizeof word_end_bk);

      strcpy (n, match_lines ? (bk ? line_beg_bk : line_beg_no_bk)
			     : (bk ? word_beg_bk : word_beg_no_bk));
      total = strlen(n);
      memcpy (n + total, pattern, size);
      total += size;
      strcpy (n + total, match_lines ? (bk ? line_end_bk : line_end_no_bk)
				     : (bk ? word_end_bk : word_end_no_bk));
      total += strlen (n + total);
      pattern = motif = n;
      size = total;
    }
  else
    motif = NULL;

  dfacomp (pattern, size, &dfa, 1);
  kwsmusts ();

  free(motif);
}

size_t
EGexecute (char const *buf, size_t size, size_t *match_size,
	   char const *start_ptr)
{
  char const *buflim, *beg, *end, *match, *best_match, *mb_start;
  char eol = eolbyte;
  int backref, start, len, best_len;
  struct kwsmatch kwsm;
  size_t i, ret_val;
#ifdef MBS_SUPPORT
  if (MB_CUR_MAX > 1)
    {
      if (match_icase)
        {
          /* mbtolower adds a NUL byte at the end.  That will provide
	     space for the sentinel byte dfaexec may add.  */
          char *case_buf = mbtolower (buf, &size);
	  if (start_ptr)
	    start_ptr = case_buf + (start_ptr - buf);
          buf = case_buf;
        }
    }
#endif /* MBS_SUPPORT */

  mb_start = buf;
  buflim = buf + size;

  for (beg = end = buf; end < buflim; beg = end)
    {
      if (!start_ptr)
	{
	  /* We don't care about an exact match.  */
	  if (kwset)
	    {
	      /* Find a possible match using the KWset matcher. */
	      size_t offset = kwsexec (kwset, beg, buflim - beg, &kwsm);
	      if (offset == (size_t) -1)
		goto failure;
	      beg += offset;
	      /* Narrow down to the line containing the candidate, and
		 run it through DFA. */
	      if ((end = memchr(beg, eol, buflim - beg)) != NULL)
	        end++;
              else
                end = buflim;
	      match = beg;
	      while (beg > buf && beg[-1] != eol)
		--beg;
	      if (kwsm.index < kwset_exact_matches)
                {
#ifdef MBS_SUPPORT
                  if (mb_start < beg)
                    mb_start = beg;
                  if (MB_CUR_MAX == 1 || !is_mb_middle (&mb_start, match, buflim))
#endif
                    goto success;
                }
	      if (dfaexec (&dfa, beg, (char *) end, 0, NULL, &backref) == NULL)
		continue;
	    }
	  else
	    {
	      /* No good fixed strings; start with DFA. */
	      char const *next_beg = dfaexec (&dfa, beg, (char *) buflim,
					      0, NULL, &backref);
	      if (next_beg == NULL)
		break;
	      /* Narrow down to the line we've found. */
	      beg = next_beg;
	      if ((end = memchr(beg, eol, buflim - beg)) != NULL)
	        end++;
              else
                end = buflim;
	      while (beg > buf && beg[-1] != eol)
		--beg;
	    }
	  /* Successful, no backreferences encountered! */
	  if (!backref)
	    goto success;
	}
      else
	{
	  /* We are looking for the leftmost (then longest) exact match.
	     We will go through the outer loop only once.  */
	  beg = start_ptr;
	  end = buflim;
	}

      /* If we've made it to this point, this means DFA has seen
	 a probable match, and we need to run it through Regex. */
      best_match = end;
      best_len = 0;
      for (i = 0; i < pcount; i++)
	{
	  patterns[i].regexbuf.not_eol = 0;
	  if (0 <= (start = re_search (&(patterns[i].regexbuf),
				       buf, end - buf - 1,
				       beg - buf, end - beg - 1,
				       &(patterns[i].regs))))
	    {
	      len = patterns[i].regs.end[0] - start;
	      match = buf + start;
	      if (match > best_match)
		continue;
	      if (start_ptr && !match_words)
		goto assess_pattern_match;
	      if ((!match_lines && !match_words)
		  || (match_lines && len == end - beg - 1))
		{
		  match = beg;
		  len = end - beg;
		  goto assess_pattern_match;
		}
	      /* If -w, check if the match aligns with word boundaries.
		 We do this iteratively because:
		 (a) the line may contain more than one occurence of the
		 pattern, and
		 (b) Several alternatives in the pattern might be valid at a
		 given point, and we may need to consider a shorter one to
		 find a word boundary.  */
	      if (match_words)
		while (match <= best_match)
		  {
		    if ((match == buf || !WCHAR ((unsigned char) match[-1]))
			&& (len == end - beg - 1
			    || !WCHAR ((unsigned char) match[len])))
		      goto assess_pattern_match;
		    if (len > 0)
		      {
			/* Try a shorter length anchored at the same place. */
			--len;
			patterns[i].regexbuf.not_eol = 1;
			len = re_match (&(patterns[i].regexbuf),
					buf, match + len - beg, match - buf,
					&(patterns[i].regs));
		      }
		    if (len <= 0)
		      {
			/* Try looking further on. */
			if (match == end - 1)
			  break;
			match++;
			patterns[i].regexbuf.not_eol = 0;
			start = re_search (&(patterns[i].regexbuf),
					   buf, end - buf - 1,
					   match - buf, end - match - 1,
					   &(patterns[i].regs));
			if (start < 0)
			  break;
			len = patterns[i].regs.end[0] - start;
			match = buf + start;
		      }
		  } /* while (match <= best_match) */
	      continue;
	    assess_pattern_match:
	      
//Patch 0:
{
    if ((!start_ptr) && !(__is_neg(25, &(start_ptr), sizeof (start_ptr), &(beg), sizeof (beg), &(match), sizeof (match), &(buf), sizeof (buf), &(start), sizeof (start), &(len), sizeof (len), &(i), sizeof (i), &(patterns), sizeof (patterns), &(best_match), sizeof (best_match), &(best_len), sizeof (best_len), &(end), sizeof (end), &(ret_val), sizeof (ret_val), &(match_size), sizeof (match_size), &(match_words), sizeof (match_words), &(match_lines), sizeof (match_lines), &(pcount), sizeof (pcount), &(buflim), sizeof (buflim), &(backref), sizeof (backref), &(eol), sizeof (eol), &(mb_start), sizeof (mb_start), &(kwset_exact_matches), sizeof (kwset_exact_matches), &(kwset), sizeof (kwset), &(size), sizeof (size), &(match_icase), sizeof (match_icase), &(eolbyte), sizeof (eolbyte)))) {
        beg = match;
        goto success_in_len;
    }
}

//CodeSeg 1:
	      if (match < best_match || (match == best_match && len > best_len))
		{
		  /* Best exact match:  leftmost, then longest.  */
		  best_match = match;
		  best_len = len;
		}
	    } /* if re_search >= 0 */
	} /* for Regex patterns.  */
	if (best_match < end)
	  {
	    /* We have found an exact match.  We were just
	       waiting for the best one (leftmost then longest).  */
	    beg = best_match;
	    len = best_len;
	    goto success_in_len;
	  }
    } /* for (beg = end ..) */

 failure:
  ret_val = -1;
  goto out;

 success:
  len = end - beg;
 success_in_len:
  *match_size = len;
  ret_val = beg - buf;
 out:
  return ret_val;
}

Spawn 1 instances, now Total 9
Counter: 10
Batcher Size:9
Preprocess the following candidate with CondTester:
Priority 20000
At location src/dfasearch.c:297
--Src File: src/dfasearch.c
Fragment 0:
if ((0 <= (start = rpl_re_search(&(patterns[i].regexbuf), buf, end - buf - 1, beg - buf, end - beg - 1, &(patterns[i].regs)))) && !(__abst_hole(i, patterns, buf, beg, end, start, len, patterns[i].regs.end, match, best_match, start_ptr, match_words, pcount, best_len, match_lines, buflim, backref, eol, mb_start, kwset_exact_matches, kwset, size, ret_val, match_icase, match_size, eolbyte, patterns[i].regs.num_regs, patterns[i].regs.start))) {
    len = patterns[i].regs.end[0] - start;
    match = buf + start;
    if (match > best_match)
        continue;
    if (start_ptr && !match_words)
        goto assess_pattern_match;
    if ((!match_lines && !match_words) || (match_lines && len == end - beg - 1)) {
        match = beg;
        len = end - beg;
        goto assess_pattern_match;
    }
    if (match_words)
        while (match <= best_match)
            {
                if ((match == buf || !((1 && ((*__ctype_b_loc())[(int)(((unsigned char)match[-1]))] & (unsigned short)_ISalnum)) || ((unsigned char)match[-1]) == '_')) && (len == end - beg - 1 || !((1 && ((*__ctype_b_loc())[(int)(((unsigned char)match[len]))] & (unsigned short)_ISalnum)) || ((unsigned char)match[len]) == '_')))
                    goto assess_pattern_match;
                if (len > 0) {
                    --len;
                    patterns[i].regexbuf.not_eol = 1;
                    len = rpl_re_match(&(patterns[i].regexbuf), buf, match + len - beg, match - buf, &(patterns[i].regs));
                }
                if (len <= 0) {
                    if (match == end - 1)
                        break;
                    match++;
                    patterns[i].regexbuf.not_eol = 0;
                    start = rpl_re_search(&(patterns[i].regexbuf), buf, end - buf - 1, match - buf, end - match - 1, &(patterns[i].regs));
                    if (start < 0)
                        break;
                    len = patterns[i].regs.end[0] - start;
                    match = buf + start;
                }
            }
    continue;
  assess_pattern_match:
    if (!start_ptr) {
        beg = match;
        goto success_in_len;
    }
    if (match < best_match || (match == best_match && len > best_len)) {
        best_match = match;
        best_len = len;
    }
}


CondTester, a patch instance with id 9:
//src_file:src/dfasearch.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); void* memset(void*, int, unsigned long); 
/* dfasearch.c - searching subroutines using dfa and regex for grep.
   Copyright 1992, 1998, 2000, 2007, 2009-2010 Free Software Foundation, Inc.

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 3, or (at your option)
   any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program; if not, write to the Free Software
   Foundation, Inc., 51 Franklin Street - Fifth Floor, Boston, MA
   02110-1301, USA.  */

/* Written August 1992 by Mike Haertel. */

#include <config.h>
#include "search.h"
#include "dfa.h"

/* For -w, we also consider _ to be word constituent.  */
#define WCHAR(C) (ISALNUM(C) || (C) == '_')

/* KWset compiled pattern.  For Ecompile and Gcompile, we compile
   a list of strings, at least one of which is known to occur in
   any string matching the regexp. */
static kwset_t kwset;

/* DFA compiled regexp. */
static struct dfa dfa;

/* The Regex compiled patterns.  */
static struct patterns
{
  /* Regex compiled regexp. */
  struct re_pattern_buffer regexbuf;
  struct re_registers regs; /* This is here on account of a BRAIN-DEAD
			       Q@#%!# library interface in regex.c.  */
} patterns0;

struct patterns *patterns;
size_t pcount;

void
dfaerror (char const *mesg)
{
  error (EXIT_TROUBLE, 0, "%s", mesg);

  /* notreached */
  /* Tell static analyzers that this function does not return.  */
  abort ();
}

/* Number of compiled fixed strings known to exactly match the regexp.
   If kwsexec returns < kwset_exact_matches, then we don't need to
   call the regexp matcher at all. */
static int kwset_exact_matches;

static char const *
kwsincr_case (const char *must)
{
  const char *buf;
  size_t n;

  n = strlen (must);
#ifdef MBS_SUPPORT
  if (match_icase && MB_CUR_MAX > 1)
    buf = mbtolower (must, &n);
  else
#endif
    buf = must;
  return kwsincr (kwset, buf, n);
}

/* If the DFA turns out to have some set of fixed strings one of
   which must occur in the match, then we build a kwset matcher
   to find those strings, and thus quickly filter out impossible
   matches. */
static void
kwsmusts (void)
{
  struct dfamust const *dm;
  char const *err;

  if (dfa.musts)
    {
      kwsinit (&kwset);
      /* First, we compile in the substrings known to be exact
	 matches.  The kwset matcher will return the index
	 of the matching string that it chooses. */
      for (dm = dfa.musts; dm; dm = dm->next)
	{
	  if (!dm->exact)
	    continue;
	  ++kwset_exact_matches;
	  if ((err = kwsincr_case (dm->must)) != NULL)
	    error (EXIT_TROUBLE, 0, "%s", err);
	}
      /* Now, we compile the substrings that will require
	 the use of the regexp matcher.  */
      for (dm = dfa.musts; dm; dm = dm->next)
	{
	  if (dm->exact)
	    continue;
	  if ((err = kwsincr_case (dm->must)) != NULL)
	    error (EXIT_TROUBLE, 0, "%s", err);
	}
      if ((err = kwsprep (kwset)) != NULL)
	error (EXIT_TROUBLE, 0, "%s", err);
    }
}

void
GEAcompile (char const *pattern, size_t size, reg_syntax_t syntax_bits)
{
  const char *err;
  const char *p, *sep;
  size_t total = size;
  char *motif;

  if (match_icase)
    syntax_bits |= RE_ICASE;
  re_set_syntax (syntax_bits);
  dfasyntax (syntax_bits, match_icase, eolbyte);

  /* For GNU regex compiler we have to pass the patterns separately to detect
     errors like "[\nallo\n]\n".  The patterns here are "[", "allo" and "]"
     GNU regex should have raise a syntax error.  The same for backref, where
     the backref should have been local to each pattern.  */
  p = pattern;
  do
    {
      size_t len;
      sep = memchr (p, '\n', total);
      if (sep)
	{
	  len = sep - p;
	  sep++;
	  total -= (len + 1);
	}
      else
	{
	  len = total;
	  total = 0;
	}

      patterns = realloc (patterns, (pcount + 1) * sizeof (*patterns));
      if (patterns == NULL)
	error (EXIT_TROUBLE, errno, _("memory exhausted"));
      patterns[pcount] = patterns0;

      if ((err = re_compile_pattern (p, len,
				    &(patterns[pcount].regexbuf))) != NULL)
	error (EXIT_TROUBLE, 0, "%s", err);
      pcount++;

      p = sep;
    } while (sep && total != 0);

  /* In the match_words and match_lines cases, we use a different pattern
     for the DFA matcher that will quickly throw out cases that won't work.
     Then if DFA succeeds we do some hairy stuff using the regex matcher
     to decide whether the match should really count. */
  if (match_words || match_lines)
    {
      static char const line_beg_no_bk[] = "^(";
      static char const line_end_no_bk[] = ")$";
      static char const word_beg_no_bk[] = "(^|[^[:alnum:]_])(";
      static char const word_end_no_bk[] = ")([^[:alnum:]_]|$)";
      static char const line_beg_bk[] = "^\\(";
      static char const line_end_bk[] = "\\)$";
      static char const word_beg_bk[] = "\\(^\\|[^[:alnum:]_]\\)\\(";
      static char const word_end_bk[] = "\\)\\([^[:alnum:]_]\\|$\\)";
      int bk = !(syntax_bits & RE_NO_BK_PARENS);
      char *n = xmalloc (sizeof word_beg_bk - 1 + size + sizeof word_end_bk);

      strcpy (n, match_lines ? (bk ? line_beg_bk : line_beg_no_bk)
			     : (bk ? word_beg_bk : word_beg_no_bk));
      total = strlen(n);
      memcpy (n + total, pattern, size);
      total += size;
      strcpy (n + total, match_lines ? (bk ? line_end_bk : line_end_no_bk)
				     : (bk ? word_end_bk : word_end_no_bk));
      total += strlen (n + total);
      pattern = motif = n;
      size = total;
    }
  else
    motif = NULL;

  dfacomp (pattern, size, &dfa, 1);
  kwsmusts ();

  free(motif);
}

size_t
EGexecute (char const *buf, size_t size, size_t *match_size,
	   char const *start_ptr)
{
  char const *buflim, *beg, *end, *match, *best_match, *mb_start;
  char eol = eolbyte;
  int backref, start, len, best_len;
  struct kwsmatch kwsm;
  size_t i, ret_val;
#ifdef MBS_SUPPORT
  if (MB_CUR_MAX > 1)
    {
      if (match_icase)
        {
          /* mbtolower adds a NUL byte at the end.  That will provide
	     space for the sentinel byte dfaexec may add.  */
          char *case_buf = mbtolower (buf, &size);
	  if (start_ptr)
	    start_ptr = case_buf + (start_ptr - buf);
          buf = case_buf;
        }
    }
#endif /* MBS_SUPPORT */

  mb_start = buf;
  buflim = buf + size;

  for (beg = end = buf; end < buflim; beg = end)
    {
      if (!start_ptr)
	{
	  /* We don't care about an exact match.  */
	  if (kwset)
	    {
	      /* Find a possible match using the KWset matcher. */
	      size_t offset = kwsexec (kwset, beg, buflim - beg, &kwsm);
	      if (offset == (size_t) -1)
		goto failure;
	      beg += offset;
	      /* Narrow down to the line containing the candidate, and
		 run it through DFA. */
	      if ((end = memchr(beg, eol, buflim - beg)) != NULL)
	        end++;
              else
                end = buflim;
	      match = beg;
	      while (beg > buf && beg[-1] != eol)
		--beg;
	      if (kwsm.index < kwset_exact_matches)
                {
#ifdef MBS_SUPPORT
                  if (mb_start < beg)
                    mb_start = beg;
                  if (MB_CUR_MAX == 1 || !is_mb_middle (&mb_start, match, buflim))
#endif
                    goto success;
                }
	      if (dfaexec (&dfa, beg, (char *) end, 0, NULL, &backref) == NULL)
		continue;
	    }
	  else
	    {
	      /* No good fixed strings; start with DFA. */
	      char const *next_beg = dfaexec (&dfa, beg, (char *) buflim,
					      0, NULL, &backref);
	      if (next_beg == NULL)
		break;
	      /* Narrow down to the line we've found. */
	      beg = next_beg;
	      if ((end = memchr(beg, eol, buflim - beg)) != NULL)
	        end++;
              else
                end = buflim;
	      while (beg > buf && beg[-1] != eol)
		--beg;
	    }
	  /* Successful, no backreferences encountered! */
	  if (!backref)
	    goto success;
	}
      else
	{
	  /* We are looking for the leftmost (then longest) exact match.
	     We will go through the outer loop only once.  */
	  beg = start_ptr;
	  end = buflim;
	}

      /* If we've made it to this point, this means DFA has seen
	 a probable match, and we need to run it through Regex. */
      best_match = end;
      best_len = 0;
      for (i = 0; i < pcount; i++)
	{
	  patterns[i].regexbuf.not_eol = 0;
	  
//Patch 0:
if ((0 <= (start = rpl_re_search(&(patterns[i].regexbuf), buf, end - buf - 1, beg - buf, end - beg - 1, &(patterns[i].regs)))) && !(__is_neg(28, &(i), sizeof (i), &(patterns), sizeof (patterns), &(buf), sizeof (buf), &(beg), sizeof (beg), &(end), sizeof (end), &(start), sizeof (start), &(len), sizeof (len), &(patterns[i].regs.end), sizeof (patterns[i].regs.end), &(match), sizeof (match), &(best_match), sizeof (best_match), &(start_ptr), sizeof (start_ptr), &(match_words), sizeof (match_words), &(pcount), sizeof (pcount), &(best_len), sizeof (best_len), &(match_lines), sizeof (match_lines), &(buflim), sizeof (buflim), &(backref), sizeof (backref), &(eol), sizeof (eol), &(mb_start), sizeof (mb_start), &(kwset_exact_matches), sizeof (kwset_exact_matches), &(kwset), sizeof (kwset), &(size), sizeof (size), &(ret_val), sizeof (ret_val), &(match_icase), sizeof (match_icase), &(match_size), sizeof (match_size), &(eolbyte), sizeof (eolbyte), &(patterns[i].regs.num_regs), sizeof (patterns[i].regs.num_regs), &(patterns[i].regs.start), sizeof (patterns[i].regs.start)))) {
    len = patterns[i].regs.end[0] - start;
    match = buf + start;
    if (match > best_match)
        continue;
    if (start_ptr && !match_words)
        goto assess_pattern_match;
    if ((!match_lines && !match_words) || (match_lines && len == end - beg - 1)) {
        match = beg;
        len = end - beg;
        goto assess_pattern_match;
    }
    if (match_words)
        while (match <= best_match)
            {
                if ((match == buf || !((1 && ((*__ctype_b_loc())[(int)(((unsigned char)match[-1]))] & (unsigned short)_ISalnum)) || ((unsigned char)match[-1]) == '_')) && (len == end - beg - 1 || !((1 && ((*__ctype_b_loc())[(int)(((unsigned char)match[len]))] & (unsigned short)_ISalnum)) || ((unsigned char)match[len]) == '_')))
                    goto assess_pattern_match;
                if (len > 0) {
                    --len;
                    patterns[i].regexbuf.not_eol = 1;
                    len = rpl_re_match(&(patterns[i].regexbuf), buf, match + len - beg, match - buf, &(patterns[i].regs));
                }
                if (len <= 0) {
                    if (match == end - 1)
                        break;
                    match++;
                    patterns[i].regexbuf.not_eol = 0;
                    start = rpl_re_search(&(patterns[i].regexbuf), buf, end - buf - 1, match - buf, end - match - 1, &(patterns[i].regs));
                    if (start < 0)
                        break;
                    len = patterns[i].regs.end[0] - start;
                    match = buf + start;
                }
            }
    continue;
  assess_pattern_match:
    if (!start_ptr) {
        beg = match;
        goto success_in_len;
    }
    if (match < best_match || (match == best_match && len > best_len)) {
        best_match = match;
        best_len = len;
    }
}

//CodeSeg 1:
	} /* for Regex patterns.  */
	if (best_match < end)
	  {
	    /* We have found an exact match.  We were just
	       waiting for the best one (leftmost then longest).  */
	    beg = best_match;
	    len = best_len;
	    goto success_in_len;
	  }
    } /* for (beg = end ..) */

 failure:
  ret_val = -1;
  goto out;

 success:
  len = end - beg;
 success_in_len:
  *match_size = len;
  ret_val = beg - buf;
 out:
  return ret_val;
}

Spawn 1 instances, now Total 10
Counter: 11
Batcher Size:10
Preprocess the following candidate with CondTester:
Priority 20000
At location src/dfasearch.c:297
--Src File: src/dfasearch.c
Fragment 0:
if ((0 <= (start = rpl_re_search(&(patterns[i].regexbuf), buf, end - buf - 1, beg - buf, end - beg - 1, &(patterns[i].regs)))) || (__abst_hole(i, patterns, buf, beg, end, start, len, patterns[i].regs.end, match, best_match, start_ptr, match_words, pcount, best_len, match_lines, buflim, backref, eol, mb_start, kwset_exact_matches, kwset, size, ret_val, match_icase, match_size, eolbyte, patterns[i].regs.num_regs, patterns[i].regs.start))) {
    len = patterns[i].regs.end[0] - start;
    match = buf + start;
    if (match > best_match)
        continue;
    if (start_ptr && !match_words)
        goto assess_pattern_match;
    if ((!match_lines && !match_words) || (match_lines && len == end - beg - 1)) {
        match = beg;
        len = end - beg;
        goto assess_pattern_match;
    }
    if (match_words)
        while (match <= best_match)
            {
                if ((match == buf || !((1 && ((*__ctype_b_loc())[(int)(((unsigned char)match[-1]))] & (unsigned short)_ISalnum)) || ((unsigned char)match[-1]) == '_')) && (len == end - beg - 1 || !((1 && ((*__ctype_b_loc())[(int)(((unsigned char)match[len]))] & (unsigned short)_ISalnum)) || ((unsigned char)match[len]) == '_')))
                    goto assess_pattern_match;
                if (len > 0) {
                    --len;
                    patterns[i].regexbuf.not_eol = 1;
                    len = rpl_re_match(&(patterns[i].regexbuf), buf, match + len - beg, match - buf, &(patterns[i].regs));
                }
                if (len <= 0) {
                    if (match == end - 1)
                        break;
                    match++;
                    patterns[i].regexbuf.not_eol = 0;
                    start = rpl_re_search(&(patterns[i].regexbuf), buf, end - buf - 1, match - buf, end - match - 1, &(patterns[i].regs));
                    if (start < 0)
                        break;
                    len = patterns[i].regs.end[0] - start;
                    match = buf + start;
                }
            }
    continue;
  assess_pattern_match:
    if (!start_ptr) {
        beg = match;
        goto success_in_len;
    }
    if (match < best_match || (match == best_match && len > best_len)) {
        best_match = match;
        best_len = len;
    }
}


CondTester, a patch instance with id 10:
//src_file:src/dfasearch.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); void* memset(void*, int, unsigned long); 
/* dfasearch.c - searching subroutines using dfa and regex for grep.
   Copyright 1992, 1998, 2000, 2007, 2009-2010 Free Software Foundation, Inc.

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 3, or (at your option)
   any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program; if not, write to the Free Software
   Foundation, Inc., 51 Franklin Street - Fifth Floor, Boston, MA
   02110-1301, USA.  */

/* Written August 1992 by Mike Haertel. */

#include <config.h>
#include "search.h"
#include "dfa.h"

/* For -w, we also consider _ to be word constituent.  */
#define WCHAR(C) (ISALNUM(C) || (C) == '_')

/* KWset compiled pattern.  For Ecompile and Gcompile, we compile
   a list of strings, at least one of which is known to occur in
   any string matching the regexp. */
static kwset_t kwset;

/* DFA compiled regexp. */
static struct dfa dfa;

/* The Regex compiled patterns.  */
static struct patterns
{
  /* Regex compiled regexp. */
  struct re_pattern_buffer regexbuf;
  struct re_registers regs; /* This is here on account of a BRAIN-DEAD
			       Q@#%!# library interface in regex.c.  */
} patterns0;

struct patterns *patterns;
size_t pcount;

void
dfaerror (char const *mesg)
{
  error (EXIT_TROUBLE, 0, "%s", mesg);

  /* notreached */
  /* Tell static analyzers that this function does not return.  */
  abort ();
}

/* Number of compiled fixed strings known to exactly match the regexp.
   If kwsexec returns < kwset_exact_matches, then we don't need to
   call the regexp matcher at all. */
static int kwset_exact_matches;

static char const *
kwsincr_case (const char *must)
{
  const char *buf;
  size_t n;

  n = strlen (must);
#ifdef MBS_SUPPORT
  if (match_icase && MB_CUR_MAX > 1)
    buf = mbtolower (must, &n);
  else
#endif
    buf = must;
  return kwsincr (kwset, buf, n);
}

/* If the DFA turns out to have some set of fixed strings one of
   which must occur in the match, then we build a kwset matcher
   to find those strings, and thus quickly filter out impossible
   matches. */
static void
kwsmusts (void)
{
  struct dfamust const *dm;
  char const *err;

  if (dfa.musts)
    {
      kwsinit (&kwset);
      /* First, we compile in the substrings known to be exact
	 matches.  The kwset matcher will return the index
	 of the matching string that it chooses. */
      for (dm = dfa.musts; dm; dm = dm->next)
	{
	  if (!dm->exact)
	    continue;
	  ++kwset_exact_matches;
	  if ((err = kwsincr_case (dm->must)) != NULL)
	    error (EXIT_TROUBLE, 0, "%s", err);
	}
      /* Now, we compile the substrings that will require
	 the use of the regexp matcher.  */
      for (dm = dfa.musts; dm; dm = dm->next)
	{
	  if (dm->exact)
	    continue;
	  if ((err = kwsincr_case (dm->must)) != NULL)
	    error (EXIT_TROUBLE, 0, "%s", err);
	}
      if ((err = kwsprep (kwset)) != NULL)
	error (EXIT_TROUBLE, 0, "%s", err);
    }
}

void
GEAcompile (char const *pattern, size_t size, reg_syntax_t syntax_bits)
{
  const char *err;
  const char *p, *sep;
  size_t total = size;
  char *motif;

  if (match_icase)
    syntax_bits |= RE_ICASE;
  re_set_syntax (syntax_bits);
  dfasyntax (syntax_bits, match_icase, eolbyte);

  /* For GNU regex compiler we have to pass the patterns separately to detect
     errors like "[\nallo\n]\n".  The patterns here are "[", "allo" and "]"
     GNU regex should have raise a syntax error.  The same for backref, where
     the backref should have been local to each pattern.  */
  p = pattern;
  do
    {
      size_t len;
      sep = memchr (p, '\n', total);
      if (sep)
	{
	  len = sep - p;
	  sep++;
	  total -= (len + 1);
	}
      else
	{
	  len = total;
	  total = 0;
	}

      patterns = realloc (patterns, (pcount + 1) * sizeof (*patterns));
      if (patterns == NULL)
	error (EXIT_TROUBLE, errno, _("memory exhausted"));
      patterns[pcount] = patterns0;

      if ((err = re_compile_pattern (p, len,
				    &(patterns[pcount].regexbuf))) != NULL)
	error (EXIT_TROUBLE, 0, "%s", err);
      pcount++;

      p = sep;
    } while (sep && total != 0);

  /* In the match_words and match_lines cases, we use a different pattern
     for the DFA matcher that will quickly throw out cases that won't work.
     Then if DFA succeeds we do some hairy stuff using the regex matcher
     to decide whether the match should really count. */
  if (match_words || match_lines)
    {
      static char const line_beg_no_bk[] = "^(";
      static char const line_end_no_bk[] = ")$";
      static char const word_beg_no_bk[] = "(^|[^[:alnum:]_])(";
      static char const word_end_no_bk[] = ")([^[:alnum:]_]|$)";
      static char const line_beg_bk[] = "^\\(";
      static char const line_end_bk[] = "\\)$";
      static char const word_beg_bk[] = "\\(^\\|[^[:alnum:]_]\\)\\(";
      static char const word_end_bk[] = "\\)\\([^[:alnum:]_]\\|$\\)";
      int bk = !(syntax_bits & RE_NO_BK_PARENS);
      char *n = xmalloc (sizeof word_beg_bk - 1 + size + sizeof word_end_bk);

      strcpy (n, match_lines ? (bk ? line_beg_bk : line_beg_no_bk)
			     : (bk ? word_beg_bk : word_beg_no_bk));
      total = strlen(n);
      memcpy (n + total, pattern, size);
      total += size;
      strcpy (n + total, match_lines ? (bk ? line_end_bk : line_end_no_bk)
				     : (bk ? word_end_bk : word_end_no_bk));
      total += strlen (n + total);
      pattern = motif = n;
      size = total;
    }
  else
    motif = NULL;

  dfacomp (pattern, size, &dfa, 1);
  kwsmusts ();

  free(motif);
}

size_t
EGexecute (char const *buf, size_t size, size_t *match_size,
	   char const *start_ptr)
{
  char const *buflim, *beg, *end, *match, *best_match, *mb_start;
  char eol = eolbyte;
  int backref, start, len, best_len;
  struct kwsmatch kwsm;
  size_t i, ret_val;
#ifdef MBS_SUPPORT
  if (MB_CUR_MAX > 1)
    {
      if (match_icase)
        {
          /* mbtolower adds a NUL byte at the end.  That will provide
	     space for the sentinel byte dfaexec may add.  */
          char *case_buf = mbtolower (buf, &size);
	  if (start_ptr)
	    start_ptr = case_buf + (start_ptr - buf);
          buf = case_buf;
        }
    }
#endif /* MBS_SUPPORT */

  mb_start = buf;
  buflim = buf + size;

  for (beg = end = buf; end < buflim; beg = end)
    {
      if (!start_ptr)
	{
	  /* We don't care about an exact match.  */
	  if (kwset)
	    {
	      /* Find a possible match using the KWset matcher. */
	      size_t offset = kwsexec (kwset, beg, buflim - beg, &kwsm);
	      if (offset == (size_t) -1)
		goto failure;
	      beg += offset;
	      /* Narrow down to the line containing the candidate, and
		 run it through DFA. */
	      if ((end = memchr(beg, eol, buflim - beg)) != NULL)
	        end++;
              else
                end = buflim;
	      match = beg;
	      while (beg > buf && beg[-1] != eol)
		--beg;
	      if (kwsm.index < kwset_exact_matches)
                {
#ifdef MBS_SUPPORT
                  if (mb_start < beg)
                    mb_start = beg;
                  if (MB_CUR_MAX == 1 || !is_mb_middle (&mb_start, match, buflim))
#endif
                    goto success;
                }
	      if (dfaexec (&dfa, beg, (char *) end, 0, NULL, &backref) == NULL)
		continue;
	    }
	  else
	    {
	      /* No good fixed strings; start with DFA. */
	      char const *next_beg = dfaexec (&dfa, beg, (char *) buflim,
					      0, NULL, &backref);
	      if (next_beg == NULL)
		break;
	      /* Narrow down to the line we've found. */
	      beg = next_beg;
	      if ((end = memchr(beg, eol, buflim - beg)) != NULL)
	        end++;
              else
                end = buflim;
	      while (beg > buf && beg[-1] != eol)
		--beg;
	    }
	  /* Successful, no backreferences encountered! */
	  if (!backref)
	    goto success;
	}
      else
	{
	  /* We are looking for the leftmost (then longest) exact match.
	     We will go through the outer loop only once.  */
	  beg = start_ptr;
	  end = buflim;
	}

      /* If we've made it to this point, this means DFA has seen
	 a probable match, and we need to run it through Regex. */
      best_match = end;
      best_len = 0;
      for (i = 0; i < pcount; i++)
	{
	  patterns[i].regexbuf.not_eol = 0;
	  
//Patch 0:
if ((0 <= (start = rpl_re_search(&(patterns[i].regexbuf), buf, end - buf - 1, beg - buf, end - beg - 1, &(patterns[i].regs)))) || (__is_neg(28, &(i), sizeof (i), &(patterns), sizeof (patterns), &(buf), sizeof (buf), &(beg), sizeof (beg), &(end), sizeof (end), &(start), sizeof (start), &(len), sizeof (len), &(patterns[i].regs.end), sizeof (patterns[i].regs.end), &(match), sizeof (match), &(best_match), sizeof (best_match), &(start_ptr), sizeof (start_ptr), &(match_words), sizeof (match_words), &(pcount), sizeof (pcount), &(best_len), sizeof (best_len), &(match_lines), sizeof (match_lines), &(buflim), sizeof (buflim), &(backref), sizeof (backref), &(eol), sizeof (eol), &(mb_start), sizeof (mb_start), &(kwset_exact_matches), sizeof (kwset_exact_matches), &(kwset), sizeof (kwset), &(size), sizeof (size), &(ret_val), sizeof (ret_val), &(match_icase), sizeof (match_icase), &(match_size), sizeof (match_size), &(eolbyte), sizeof (eolbyte), &(patterns[i].regs.num_regs), sizeof (patterns[i].regs.num_regs), &(patterns[i].regs.start), sizeof (patterns[i].regs.start)))) {
    len = patterns[i].regs.end[0] - start;
    match = buf + start;
    if (match > best_match)
        continue;
    if (start_ptr && !match_words)
        goto assess_pattern_match;
    if ((!match_lines && !match_words) || (match_lines && len == end - beg - 1)) {
        match = beg;
        len = end - beg;
        goto assess_pattern_match;
    }
    if (match_words)
        while (match <= best_match)
            {
                if ((match == buf || !((1 && ((*__ctype_b_loc())[(int)(((unsigned char)match[-1]))] & (unsigned short)_ISalnum)) || ((unsigned char)match[-1]) == '_')) && (len == end - beg - 1 || !((1 && ((*__ctype_b_loc())[(int)(((unsigned char)match[len]))] & (unsigned short)_ISalnum)) || ((unsigned char)match[len]) == '_')))
                    goto assess_pattern_match;
                if (len > 0) {
                    --len;
                    patterns[i].regexbuf.not_eol = 1;
                    len = rpl_re_match(&(patterns[i].regexbuf), buf, match + len - beg, match - buf, &(patterns[i].regs));
                }
                if (len <= 0) {
                    if (match == end - 1)
                        break;
                    match++;
                    patterns[i].regexbuf.not_eol = 0;
                    start = rpl_re_search(&(patterns[i].regexbuf), buf, end - buf - 1, match - buf, end - match - 1, &(patterns[i].regs));
                    if (start < 0)
                        break;
                    len = patterns[i].regs.end[0] - start;
                    match = buf + start;
                }
            }
    continue;
  assess_pattern_match:
    if (!start_ptr) {
        beg = match;
        goto success_in_len;
    }
    if (match < best_match || (match == best_match && len > best_len)) {
        best_match = match;
        best_len = len;
    }
}

//CodeSeg 1:
	} /* for Regex patterns.  */
	if (best_match < end)
	  {
	    /* We have found an exact match.  We were just
	       waiting for the best one (leftmost then longest).  */
	    beg = best_match;
	    len = best_len;
	    goto success_in_len;
	  }
    } /* for (beg = end ..) */

 failure:
  ret_val = -1;
  goto out;

 success:
  len = end - beg;
 success_in_len:
  *match_size = len;
  ret_val = beg - buf;
 out:
  return ret_val;
}

Spawn 1 instances, now Total 11
Counter: 12
Batcher Size:11
Preprocess the following candidate with CondTester:
Priority 20000
At location src/dfasearch.c:325
--Src File: src/dfasearch.c
Fragment 0:
if (((match == buf || !((1 && ((*__ctype_b_loc())[(int)(((unsigned char)match[-1]))] & (unsigned short)_ISalnum)) || ((unsigned char)match[-1]) == '_')) && (len == end - beg - 1 || !((1 && ((*__ctype_b_loc())[(int)(((unsigned char)match[len]))] & (unsigned short)_ISalnum)) || ((unsigned char)match[len]) == '_'))) && !(__abst_hole(match, len, beg, end, buf, best_match, match_words, i, patterns, start, match_lines, start_ptr, pcount, best_len, buflim, backref, eol, ret_val, match_size, mb_start, kwset_exact_matches, kwset, size, match_icase, eolbyte)))
    goto assess_pattern_match;


CondTester, a patch instance with id 11:
//src_file:src/dfasearch.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); void* memset(void*, int, unsigned long); 
/* dfasearch.c - searching subroutines using dfa and regex for grep.
   Copyright 1992, 1998, 2000, 2007, 2009-2010 Free Software Foundation, Inc.

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 3, or (at your option)
   any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program; if not, write to the Free Software
   Foundation, Inc., 51 Franklin Street - Fifth Floor, Boston, MA
   02110-1301, USA.  */

/* Written August 1992 by Mike Haertel. */

#include <config.h>
#include "search.h"
#include "dfa.h"

/* For -w, we also consider _ to be word constituent.  */
#define WCHAR(C) (ISALNUM(C) || (C) == '_')

/* KWset compiled pattern.  For Ecompile and Gcompile, we compile
   a list of strings, at least one of which is known to occur in
   any string matching the regexp. */
static kwset_t kwset;

/* DFA compiled regexp. */
static struct dfa dfa;

/* The Regex compiled patterns.  */
static struct patterns
{
  /* Regex compiled regexp. */
  struct re_pattern_buffer regexbuf;
  struct re_registers regs; /* This is here on account of a BRAIN-DEAD
			       Q@#%!# library interface in regex.c.  */
} patterns0;

struct patterns *patterns;
size_t pcount;

void
dfaerror (char const *mesg)
{
  error (EXIT_TROUBLE, 0, "%s", mesg);

  /* notreached */
  /* Tell static analyzers that this function does not return.  */
  abort ();
}

/* Number of compiled fixed strings known to exactly match the regexp.
   If kwsexec returns < kwset_exact_matches, then we don't need to
   call the regexp matcher at all. */
static int kwset_exact_matches;

static char const *
kwsincr_case (const char *must)
{
  const char *buf;
  size_t n;

  n = strlen (must);
#ifdef MBS_SUPPORT
  if (match_icase && MB_CUR_MAX > 1)
    buf = mbtolower (must, &n);
  else
#endif
    buf = must;
  return kwsincr (kwset, buf, n);
}

/* If the DFA turns out to have some set of fixed strings one of
   which must occur in the match, then we build a kwset matcher
   to find those strings, and thus quickly filter out impossible
   matches. */
static void
kwsmusts (void)
{
  struct dfamust const *dm;
  char const *err;

  if (dfa.musts)
    {
      kwsinit (&kwset);
      /* First, we compile in the substrings known to be exact
	 matches.  The kwset matcher will return the index
	 of the matching string that it chooses. */
      for (dm = dfa.musts; dm; dm = dm->next)
	{
	  if (!dm->exact)
	    continue;
	  ++kwset_exact_matches;
	  if ((err = kwsincr_case (dm->must)) != NULL)
	    error (EXIT_TROUBLE, 0, "%s", err);
	}
      /* Now, we compile the substrings that will require
	 the use of the regexp matcher.  */
      for (dm = dfa.musts; dm; dm = dm->next)
	{
	  if (dm->exact)
	    continue;
	  if ((err = kwsincr_case (dm->must)) != NULL)
	    error (EXIT_TROUBLE, 0, "%s", err);
	}
      if ((err = kwsprep (kwset)) != NULL)
	error (EXIT_TROUBLE, 0, "%s", err);
    }
}

void
GEAcompile (char const *pattern, size_t size, reg_syntax_t syntax_bits)
{
  const char *err;
  const char *p, *sep;
  size_t total = size;
  char *motif;

  if (match_icase)
    syntax_bits |= RE_ICASE;
  re_set_syntax (syntax_bits);
  dfasyntax (syntax_bits, match_icase, eolbyte);

  /* For GNU regex compiler we have to pass the patterns separately to detect
     errors like "[\nallo\n]\n".  The patterns here are "[", "allo" and "]"
     GNU regex should have raise a syntax error.  The same for backref, where
     the backref should have been local to each pattern.  */
  p = pattern;
  do
    {
      size_t len;
      sep = memchr (p, '\n', total);
      if (sep)
	{
	  len = sep - p;
	  sep++;
	  total -= (len + 1);
	}
      else
	{
	  len = total;
	  total = 0;
	}

      patterns = realloc (patterns, (pcount + 1) * sizeof (*patterns));
      if (patterns == NULL)
	error (EXIT_TROUBLE, errno, _("memory exhausted"));
      patterns[pcount] = patterns0;

      if ((err = re_compile_pattern (p, len,
				    &(patterns[pcount].regexbuf))) != NULL)
	error (EXIT_TROUBLE, 0, "%s", err);
      pcount++;

      p = sep;
    } while (sep && total != 0);

  /* In the match_words and match_lines cases, we use a different pattern
     for the DFA matcher that will quickly throw out cases that won't work.
     Then if DFA succeeds we do some hairy stuff using the regex matcher
     to decide whether the match should really count. */
  if (match_words || match_lines)
    {
      static char const line_beg_no_bk[] = "^(";
      static char const line_end_no_bk[] = ")$";
      static char const word_beg_no_bk[] = "(^|[^[:alnum:]_])(";
      static char const word_end_no_bk[] = ")([^[:alnum:]_]|$)";
      static char const line_beg_bk[] = "^\\(";
      static char const line_end_bk[] = "\\)$";
      static char const word_beg_bk[] = "\\(^\\|[^[:alnum:]_]\\)\\(";
      static char const word_end_bk[] = "\\)\\([^[:alnum:]_]\\|$\\)";
      int bk = !(syntax_bits & RE_NO_BK_PARENS);
      char *n = xmalloc (sizeof word_beg_bk - 1 + size + sizeof word_end_bk);

      strcpy (n, match_lines ? (bk ? line_beg_bk : line_beg_no_bk)
			     : (bk ? word_beg_bk : word_beg_no_bk));
      total = strlen(n);
      memcpy (n + total, pattern, size);
      total += size;
      strcpy (n + total, match_lines ? (bk ? line_end_bk : line_end_no_bk)
				     : (bk ? word_end_bk : word_end_no_bk));
      total += strlen (n + total);
      pattern = motif = n;
      size = total;
    }
  else
    motif = NULL;

  dfacomp (pattern, size, &dfa, 1);
  kwsmusts ();

  free(motif);
}

size_t
EGexecute (char const *buf, size_t size, size_t *match_size,
	   char const *start_ptr)
{
  char const *buflim, *beg, *end, *match, *best_match, *mb_start;
  char eol = eolbyte;
  int backref, start, len, best_len;
  struct kwsmatch kwsm;
  size_t i, ret_val;
#ifdef MBS_SUPPORT
  if (MB_CUR_MAX > 1)
    {
      if (match_icase)
        {
          /* mbtolower adds a NUL byte at the end.  That will provide
	     space for the sentinel byte dfaexec may add.  */
          char *case_buf = mbtolower (buf, &size);
	  if (start_ptr)
	    start_ptr = case_buf + (start_ptr - buf);
          buf = case_buf;
        }
    }
#endif /* MBS_SUPPORT */

  mb_start = buf;
  buflim = buf + size;

  for (beg = end = buf; end < buflim; beg = end)
    {
      if (!start_ptr)
	{
	  /* We don't care about an exact match.  */
	  if (kwset)
	    {
	      /* Find a possible match using the KWset matcher. */
	      size_t offset = kwsexec (kwset, beg, buflim - beg, &kwsm);
	      if (offset == (size_t) -1)
		goto failure;
	      beg += offset;
	      /* Narrow down to the line containing the candidate, and
		 run it through DFA. */
	      if ((end = memchr(beg, eol, buflim - beg)) != NULL)
	        end++;
              else
                end = buflim;
	      match = beg;
	      while (beg > buf && beg[-1] != eol)
		--beg;
	      if (kwsm.index < kwset_exact_matches)
                {
#ifdef MBS_SUPPORT
                  if (mb_start < beg)
                    mb_start = beg;
                  if (MB_CUR_MAX == 1 || !is_mb_middle (&mb_start, match, buflim))
#endif
                    goto success;
                }
	      if (dfaexec (&dfa, beg, (char *) end, 0, NULL, &backref) == NULL)
		continue;
	    }
	  else
	    {
	      /* No good fixed strings; start with DFA. */
	      char const *next_beg = dfaexec (&dfa, beg, (char *) buflim,
					      0, NULL, &backref);
	      if (next_beg == NULL)
		break;
	      /* Narrow down to the line we've found. */
	      beg = next_beg;
	      if ((end = memchr(beg, eol, buflim - beg)) != NULL)
	        end++;
              else
                end = buflim;
	      while (beg > buf && beg[-1] != eol)
		--beg;
	    }
	  /* Successful, no backreferences encountered! */
	  if (!backref)
	    goto success;
	}
      else
	{
	  /* We are looking for the leftmost (then longest) exact match.
	     We will go through the outer loop only once.  */
	  beg = start_ptr;
	  end = buflim;
	}

      /* If we've made it to this point, this means DFA has seen
	 a probable match, and we need to run it through Regex. */
      best_match = end;
      best_len = 0;
      for (i = 0; i < pcount; i++)
	{
	  patterns[i].regexbuf.not_eol = 0;
	  if (0 <= (start = re_search (&(patterns[i].regexbuf),
				       buf, end - buf - 1,
				       beg - buf, end - beg - 1,
				       &(patterns[i].regs))))
	    {
	      len = patterns[i].regs.end[0] - start;
	      match = buf + start;
	      if (match > best_match)
		continue;
	      if (start_ptr && !match_words)
		goto assess_pattern_match;
	      if ((!match_lines && !match_words)
		  || (match_lines && len == end - beg - 1))
		{
		  match = beg;
		  len = end - beg;
		  goto assess_pattern_match;
		}
	      /* If -w, check if the match aligns with word boundaries.
		 We do this iteratively because:
		 (a) the line may contain more than one occurence of the
		 pattern, and
		 (b) Several alternatives in the pattern might be valid at a
		 given point, and we may need to consider a shorter one to
		 find a word boundary.  */
	      if (match_words)
		while (match <= best_match)
		  {
		    
//Patch 0:
if (((match == buf || !((1 && ((*__ctype_b_loc())[(int)(((unsigned char)match[-1]))] & (unsigned short)_ISalnum)) || ((unsigned char)match[-1]) == '_')) && (len == end - beg - 1 || !((1 && ((*__ctype_b_loc())[(int)(((unsigned char)match[len]))] & (unsigned short)_ISalnum)) || ((unsigned char)match[len]) == '_'))) && !(__is_neg(25, &(match), sizeof (match), &(len), sizeof (len), &(beg), sizeof (beg), &(end), sizeof (end), &(buf), sizeof (buf), &(best_match), sizeof (best_match), &(match_words), sizeof (match_words), &(i), sizeof (i), &(patterns), sizeof (patterns), &(start), sizeof (start), &(match_lines), sizeof (match_lines), &(start_ptr), sizeof (start_ptr), &(pcount), sizeof (pcount), &(best_len), sizeof (best_len), &(buflim), sizeof (buflim), &(backref), sizeof (backref), &(eol), sizeof (eol), &(ret_val), sizeof (ret_val), &(match_size), sizeof (match_size), &(mb_start), sizeof (mb_start), &(kwset_exact_matches), sizeof (kwset_exact_matches), &(kwset), sizeof (kwset), &(size), sizeof (size), &(match_icase), sizeof (match_icase), &(eolbyte), sizeof (eolbyte))))
    goto assess_pattern_match;

//CodeSeg 1:
		    if (len > 0)
		      {
			/* Try a shorter length anchored at the same place. */
			--len;
			patterns[i].regexbuf.not_eol = 1;
			len = re_match (&(patterns[i].regexbuf),
					buf, match + len - beg, match - buf,
					&(patterns[i].regs));
		      }
		    if (len <= 0)
		      {
			/* Try looking further on. */
			if (match == end - 1)
			  break;
			match++;
			patterns[i].regexbuf.not_eol = 0;
			start = re_search (&(patterns[i].regexbuf),
					   buf, end - buf - 1,
					   match - buf, end - match - 1,
					   &(patterns[i].regs));
			if (start < 0)
			  break;
			len = patterns[i].regs.end[0] - start;
			match = buf + start;
		      }
		  } /* while (match <= best_match) */
	      continue;
	    assess_pattern_match:
	      if (!start_ptr)
		{
		  /* Good enough for a non-exact match.
		     No need to look at further patterns, if any.  */
		  beg = match;
		  goto success_in_len;
		}
	      if (match < best_match || (match == best_match && len > best_len))
		{
		  /* Best exact match:  leftmost, then longest.  */
		  best_match = match;
		  best_len = len;
		}
	    } /* if re_search >= 0 */
	} /* for Regex patterns.  */
	if (best_match < end)
	  {
	    /* We have found an exact match.  We were just
	       waiting for the best one (leftmost then longest).  */
	    beg = best_match;
	    len = best_len;
	    goto success_in_len;
	  }
    } /* for (beg = end ..) */

 failure:
  ret_val = -1;
  goto out;

 success:
  len = end - beg;
 success_in_len:
  *match_size = len;
  ret_val = beg - buf;
 out:
  return ret_val;
}

Spawn 1 instances, now Total 12
Counter: 13
Batcher Size:12
Preprocess the following candidate with CondTester:
Priority 20000
At location src/dfasearch.c:325
--Src File: src/dfasearch.c
Fragment 0:
if (((match == buf || !((1 && ((*__ctype_b_loc())[(int)(((unsigned char)match[-1]))] & (unsigned short)_ISalnum)) || ((unsigned char)match[-1]) == '_')) && (len == end - beg - 1 || !((1 && ((*__ctype_b_loc())[(int)(((unsigned char)match[len]))] & (unsigned short)_ISalnum)) || ((unsigned char)match[len]) == '_'))) || (__abst_hole(match, len, beg, end, buf, best_match, match_words, i, patterns, start, match_lines, start_ptr, pcount, best_len, buflim, backref, eol, ret_val, match_size, mb_start, kwset_exact_matches, kwset, size, match_icase, eolbyte)))
    goto assess_pattern_match;


CondTester, a patch instance with id 12:
//src_file:src/dfasearch.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); void* memset(void*, int, unsigned long); 
/* dfasearch.c - searching subroutines using dfa and regex for grep.
   Copyright 1992, 1998, 2000, 2007, 2009-2010 Free Software Foundation, Inc.

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 3, or (at your option)
   any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program; if not, write to the Free Software
   Foundation, Inc., 51 Franklin Street - Fifth Floor, Boston, MA
   02110-1301, USA.  */

/* Written August 1992 by Mike Haertel. */

#include <config.h>
#include "search.h"
#include "dfa.h"

/* For -w, we also consider _ to be word constituent.  */
#define WCHAR(C) (ISALNUM(C) || (C) == '_')

/* KWset compiled pattern.  For Ecompile and Gcompile, we compile
   a list of strings, at least one of which is known to occur in
   any string matching the regexp. */
static kwset_t kwset;

/* DFA compiled regexp. */
static struct dfa dfa;

/* The Regex compiled patterns.  */
static struct patterns
{
  /* Regex compiled regexp. */
  struct re_pattern_buffer regexbuf;
  struct re_registers regs; /* This is here on account of a BRAIN-DEAD
			       Q@#%!# library interface in regex.c.  */
} patterns0;

struct patterns *patterns;
size_t pcount;

void
dfaerror (char const *mesg)
{
  error (EXIT_TROUBLE, 0, "%s", mesg);

  /* notreached */
  /* Tell static analyzers that this function does not return.  */
  abort ();
}

/* Number of compiled fixed strings known to exactly match the regexp.
   If kwsexec returns < kwset_exact_matches, then we don't need to
   call the regexp matcher at all. */
static int kwset_exact_matches;

static char const *
kwsincr_case (const char *must)
{
  const char *buf;
  size_t n;

  n = strlen (must);
#ifdef MBS_SUPPORT
  if (match_icase && MB_CUR_MAX > 1)
    buf = mbtolower (must, &n);
  else
#endif
    buf = must;
  return kwsincr (kwset, buf, n);
}

/* If the DFA turns out to have some set of fixed strings one of
   which must occur in the match, then we build a kwset matcher
   to find those strings, and thus quickly filter out impossible
   matches. */
static void
kwsmusts (void)
{
  struct dfamust const *dm;
  char const *err;

  if (dfa.musts)
    {
      kwsinit (&kwset);
      /* First, we compile in the substrings known to be exact
	 matches.  The kwset matcher will return the index
	 of the matching string that it chooses. */
      for (dm = dfa.musts; dm; dm = dm->next)
	{
	  if (!dm->exact)
	    continue;
	  ++kwset_exact_matches;
	  if ((err = kwsincr_case (dm->must)) != NULL)
	    error (EXIT_TROUBLE, 0, "%s", err);
	}
      /* Now, we compile the substrings that will require
	 the use of the regexp matcher.  */
      for (dm = dfa.musts; dm; dm = dm->next)
	{
	  if (dm->exact)
	    continue;
	  if ((err = kwsincr_case (dm->must)) != NULL)
	    error (EXIT_TROUBLE, 0, "%s", err);
	}
      if ((err = kwsprep (kwset)) != NULL)
	error (EXIT_TROUBLE, 0, "%s", err);
    }
}

void
GEAcompile (char const *pattern, size_t size, reg_syntax_t syntax_bits)
{
  const char *err;
  const char *p, *sep;
  size_t total = size;
  char *motif;

  if (match_icase)
    syntax_bits |= RE_ICASE;
  re_set_syntax (syntax_bits);
  dfasyntax (syntax_bits, match_icase, eolbyte);

  /* For GNU regex compiler we have to pass the patterns separately to detect
     errors like "[\nallo\n]\n".  The patterns here are "[", "allo" and "]"
     GNU regex should have raise a syntax error.  The same for backref, where
     the backref should have been local to each pattern.  */
  p = pattern;
  do
    {
      size_t len;
      sep = memchr (p, '\n', total);
      if (sep)
	{
	  len = sep - p;
	  sep++;
	  total -= (len + 1);
	}
      else
	{
	  len = total;
	  total = 0;
	}

      patterns = realloc (patterns, (pcount + 1) * sizeof (*patterns));
      if (patterns == NULL)
	error (EXIT_TROUBLE, errno, _("memory exhausted"));
      patterns[pcount] = patterns0;

      if ((err = re_compile_pattern (p, len,
				    &(patterns[pcount].regexbuf))) != NULL)
	error (EXIT_TROUBLE, 0, "%s", err);
      pcount++;

      p = sep;
    } while (sep && total != 0);

  /* In the match_words and match_lines cases, we use a different pattern
     for the DFA matcher that will quickly throw out cases that won't work.
     Then if DFA succeeds we do some hairy stuff using the regex matcher
     to decide whether the match should really count. */
  if (match_words || match_lines)
    {
      static char const line_beg_no_bk[] = "^(";
      static char const line_end_no_bk[] = ")$";
      static char const word_beg_no_bk[] = "(^|[^[:alnum:]_])(";
      static char const word_end_no_bk[] = ")([^[:alnum:]_]|$)";
      static char const line_beg_bk[] = "^\\(";
      static char const line_end_bk[] = "\\)$";
      static char const word_beg_bk[] = "\\(^\\|[^[:alnum:]_]\\)\\(";
      static char const word_end_bk[] = "\\)\\([^[:alnum:]_]\\|$\\)";
      int bk = !(syntax_bits & RE_NO_BK_PARENS);
      char *n = xmalloc (sizeof word_beg_bk - 1 + size + sizeof word_end_bk);

      strcpy (n, match_lines ? (bk ? line_beg_bk : line_beg_no_bk)
			     : (bk ? word_beg_bk : word_beg_no_bk));
      total = strlen(n);
      memcpy (n + total, pattern, size);
      total += size;
      strcpy (n + total, match_lines ? (bk ? line_end_bk : line_end_no_bk)
				     : (bk ? word_end_bk : word_end_no_bk));
      total += strlen (n + total);
      pattern = motif = n;
      size = total;
    }
  else
    motif = NULL;

  dfacomp (pattern, size, &dfa, 1);
  kwsmusts ();

  free(motif);
}

size_t
EGexecute (char const *buf, size_t size, size_t *match_size,
	   char const *start_ptr)
{
  char const *buflim, *beg, *end, *match, *best_match, *mb_start;
  char eol = eolbyte;
  int backref, start, len, best_len;
  struct kwsmatch kwsm;
  size_t i, ret_val;
#ifdef MBS_SUPPORT
  if (MB_CUR_MAX > 1)
    {
      if (match_icase)
        {
          /* mbtolower adds a NUL byte at the end.  That will provide
	     space for the sentinel byte dfaexec may add.  */
          char *case_buf = mbtolower (buf, &size);
	  if (start_ptr)
	    start_ptr = case_buf + (start_ptr - buf);
          buf = case_buf;
        }
    }
#endif /* MBS_SUPPORT */

  mb_start = buf;
  buflim = buf + size;

  for (beg = end = buf; end < buflim; beg = end)
    {
      if (!start_ptr)
	{
	  /* We don't care about an exact match.  */
	  if (kwset)
	    {
	      /* Find a possible match using the KWset matcher. */
	      size_t offset = kwsexec (kwset, beg, buflim - beg, &kwsm);
	      if (offset == (size_t) -1)
		goto failure;
	      beg += offset;
	      /* Narrow down to the line containing the candidate, and
		 run it through DFA. */
	      if ((end = memchr(beg, eol, buflim - beg)) != NULL)
	        end++;
              else
                end = buflim;
	      match = beg;
	      while (beg > buf && beg[-1] != eol)
		--beg;
	      if (kwsm.index < kwset_exact_matches)
                {
#ifdef MBS_SUPPORT
                  if (mb_start < beg)
                    mb_start = beg;
                  if (MB_CUR_MAX == 1 || !is_mb_middle (&mb_start, match, buflim))
#endif
                    goto success;
                }
	      if (dfaexec (&dfa, beg, (char *) end, 0, NULL, &backref) == NULL)
		continue;
	    }
	  else
	    {
	      /* No good fixed strings; start with DFA. */
	      char const *next_beg = dfaexec (&dfa, beg, (char *) buflim,
					      0, NULL, &backref);
	      if (next_beg == NULL)
		break;
	      /* Narrow down to the line we've found. */
	      beg = next_beg;
	      if ((end = memchr(beg, eol, buflim - beg)) != NULL)
	        end++;
              else
                end = buflim;
	      while (beg > buf && beg[-1] != eol)
		--beg;
	    }
	  /* Successful, no backreferences encountered! */
	  if (!backref)
	    goto success;
	}
      else
	{
	  /* We are looking for the leftmost (then longest) exact match.
	     We will go through the outer loop only once.  */
	  beg = start_ptr;
	  end = buflim;
	}

      /* If we've made it to this point, this means DFA has seen
	 a probable match, and we need to run it through Regex. */
      best_match = end;
      best_len = 0;
      for (i = 0; i < pcount; i++)
	{
	  patterns[i].regexbuf.not_eol = 0;
	  if (0 <= (start = re_search (&(patterns[i].regexbuf),
				       buf, end - buf - 1,
				       beg - buf, end - beg - 1,
				       &(patterns[i].regs))))
	    {
	      len = patterns[i].regs.end[0] - start;
	      match = buf + start;
	      if (match > best_match)
		continue;
	      if (start_ptr && !match_words)
		goto assess_pattern_match;
	      if ((!match_lines && !match_words)
		  || (match_lines && len == end - beg - 1))
		{
		  match = beg;
		  len = end - beg;
		  goto assess_pattern_match;
		}
	      /* If -w, check if the match aligns with word boundaries.
		 We do this iteratively because:
		 (a) the line may contain more than one occurence of the
		 pattern, and
		 (b) Several alternatives in the pattern might be valid at a
		 given point, and we may need to consider a shorter one to
		 find a word boundary.  */
	      if (match_words)
		while (match <= best_match)
		  {
		    
//Patch 0:
if (((match == buf || !((1 && ((*__ctype_b_loc())[(int)(((unsigned char)match[-1]))] & (unsigned short)_ISalnum)) || ((unsigned char)match[-1]) == '_')) && (len == end - beg - 1 || !((1 && ((*__ctype_b_loc())[(int)(((unsigned char)match[len]))] & (unsigned short)_ISalnum)) || ((unsigned char)match[len]) == '_'))) || (__is_neg(25, &(match), sizeof (match), &(len), sizeof (len), &(beg), sizeof (beg), &(end), sizeof (end), &(buf), sizeof (buf), &(best_match), sizeof (best_match), &(match_words), sizeof (match_words), &(i), sizeof (i), &(patterns), sizeof (patterns), &(start), sizeof (start), &(match_lines), sizeof (match_lines), &(start_ptr), sizeof (start_ptr), &(pcount), sizeof (pcount), &(best_len), sizeof (best_len), &(buflim), sizeof (buflim), &(backref), sizeof (backref), &(eol), sizeof (eol), &(ret_val), sizeof (ret_val), &(match_size), sizeof (match_size), &(mb_start), sizeof (mb_start), &(kwset_exact_matches), sizeof (kwset_exact_matches), &(kwset), sizeof (kwset), &(size), sizeof (size), &(match_icase), sizeof (match_icase), &(eolbyte), sizeof (eolbyte))))
    goto assess_pattern_match;

//CodeSeg 1:
		    if (len > 0)
		      {
			/* Try a shorter length anchored at the same place. */
			--len;
			patterns[i].regexbuf.not_eol = 1;
			len = re_match (&(patterns[i].regexbuf),
					buf, match + len - beg, match - buf,
					&(patterns[i].regs));
		      }
		    if (len <= 0)
		      {
			/* Try looking further on. */
			if (match == end - 1)
			  break;
			match++;
			patterns[i].regexbuf.not_eol = 0;
			start = re_search (&(patterns[i].regexbuf),
					   buf, end - buf - 1,
					   match - buf, end - match - 1,
					   &(patterns[i].regs));
			if (start < 0)
			  break;
			len = patterns[i].regs.end[0] - start;
			match = buf + start;
		      }
		  } /* while (match <= best_match) */
	      continue;
	    assess_pattern_match:
	      if (!start_ptr)
		{
		  /* Good enough for a non-exact match.
		     No need to look at further patterns, if any.  */
		  beg = match;
		  goto success_in_len;
		}
	      if (match < best_match || (match == best_match && len > best_len))
		{
		  /* Best exact match:  leftmost, then longest.  */
		  best_match = match;
		  best_len = len;
		}
	    } /* if re_search >= 0 */
	} /* for Regex patterns.  */
	if (best_match < end)
	  {
	    /* We have found an exact match.  We were just
	       waiting for the best one (leftmost then longest).  */
	    beg = best_match;
	    len = best_len;
	    goto success_in_len;
	  }
    } /* for (beg = end ..) */

 failure:
  ret_val = -1;
  goto out;

 success:
  len = end - beg;
 success_in_len:
  *match_size = len;
  ret_val = beg - buf;
 out:
  return ret_val;
}

Spawn 1 instances, now Total 13
Counter: 14
Batcher Size:13
Preprocess the following candidate with CondTester:
Priority 20000
At location src/dfasearch.c:325
--Src File: src/dfasearch.c
Fragment 0:
if ((((match == buf || !((1 && ((*__ctype_b_loc())[(int)(((unsigned char)match[-1]))] & (unsigned short)_ISalnum)) || ((unsigned char)match[-1]) == '_'))) || (__abst_hole(match, len, beg, end, buf, best_match, match_words, i, patterns, start, match_lines, start_ptr, pcount, best_len, buflim, backref, eol, ret_val, match_size, mb_start, kwset_exact_matches, kwset, size, match_icase, eolbyte))) && (len == end - beg - 1 || !((1 && ((*__ctype_b_loc())[(int)(((unsigned char)match[len]))] & (unsigned short)_ISalnum)) || ((unsigned char)match[len]) == '_')))
    goto assess_pattern_match;


CondTester, a patch instance with id 13:
//src_file:src/dfasearch.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); void* memset(void*, int, unsigned long); 
/* dfasearch.c - searching subroutines using dfa and regex for grep.
   Copyright 1992, 1998, 2000, 2007, 2009-2010 Free Software Foundation, Inc.

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 3, or (at your option)
   any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program; if not, write to the Free Software
   Foundation, Inc., 51 Franklin Street - Fifth Floor, Boston, MA
   02110-1301, USA.  */

/* Written August 1992 by Mike Haertel. */

#include <config.h>
#include "search.h"
#include "dfa.h"

/* For -w, we also consider _ to be word constituent.  */
#define WCHAR(C) (ISALNUM(C) || (C) == '_')

/* KWset compiled pattern.  For Ecompile and Gcompile, we compile
   a list of strings, at least one of which is known to occur in
   any string matching the regexp. */
static kwset_t kwset;

/* DFA compiled regexp. */
static struct dfa dfa;

/* The Regex compiled patterns.  */
static struct patterns
{
  /* Regex compiled regexp. */
  struct re_pattern_buffer regexbuf;
  struct re_registers regs; /* This is here on account of a BRAIN-DEAD
			       Q@#%!# library interface in regex.c.  */
} patterns0;

struct patterns *patterns;
size_t pcount;

void
dfaerror (char const *mesg)
{
  error (EXIT_TROUBLE, 0, "%s", mesg);

  /* notreached */
  /* Tell static analyzers that this function does not return.  */
  abort ();
}

/* Number of compiled fixed strings known to exactly match the regexp.
   If kwsexec returns < kwset_exact_matches, then we don't need to
   call the regexp matcher at all. */
static int kwset_exact_matches;

static char const *
kwsincr_case (const char *must)
{
  const char *buf;
  size_t n;

  n = strlen (must);
#ifdef MBS_SUPPORT
  if (match_icase && MB_CUR_MAX > 1)
    buf = mbtolower (must, &n);
  else
#endif
    buf = must;
  return kwsincr (kwset, buf, n);
}

/* If the DFA turns out to have some set of fixed strings one of
   which must occur in the match, then we build a kwset matcher
   to find those strings, and thus quickly filter out impossible
   matches. */
static void
kwsmusts (void)
{
  struct dfamust const *dm;
  char const *err;

  if (dfa.musts)
    {
      kwsinit (&kwset);
      /* First, we compile in the substrings known to be exact
	 matches.  The kwset matcher will return the index
	 of the matching string that it chooses. */
      for (dm = dfa.musts; dm; dm = dm->next)
	{
	  if (!dm->exact)
	    continue;
	  ++kwset_exact_matches;
	  if ((err = kwsincr_case (dm->must)) != NULL)
	    error (EXIT_TROUBLE, 0, "%s", err);
	}
      /* Now, we compile the substrings that will require
	 the use of the regexp matcher.  */
      for (dm = dfa.musts; dm; dm = dm->next)
	{
	  if (dm->exact)
	    continue;
	  if ((err = kwsincr_case (dm->must)) != NULL)
	    error (EXIT_TROUBLE, 0, "%s", err);
	}
      if ((err = kwsprep (kwset)) != NULL)
	error (EXIT_TROUBLE, 0, "%s", err);
    }
}

void
GEAcompile (char const *pattern, size_t size, reg_syntax_t syntax_bits)
{
  const char *err;
  const char *p, *sep;
  size_t total = size;
  char *motif;

  if (match_icase)
    syntax_bits |= RE_ICASE;
  re_set_syntax (syntax_bits);
  dfasyntax (syntax_bits, match_icase, eolbyte);

  /* For GNU regex compiler we have to pass the patterns separately to detect
     errors like "[\nallo\n]\n".  The patterns here are "[", "allo" and "]"
     GNU regex should have raise a syntax error.  The same for backref, where
     the backref should have been local to each pattern.  */
  p = pattern;
  do
    {
      size_t len;
      sep = memchr (p, '\n', total);
      if (sep)
	{
	  len = sep - p;
	  sep++;
	  total -= (len + 1);
	}
      else
	{
	  len = total;
	  total = 0;
	}

      patterns = realloc (patterns, (pcount + 1) * sizeof (*patterns));
      if (patterns == NULL)
	error (EXIT_TROUBLE, errno, _("memory exhausted"));
      patterns[pcount] = patterns0;

      if ((err = re_compile_pattern (p, len,
				    &(patterns[pcount].regexbuf))) != NULL)
	error (EXIT_TROUBLE, 0, "%s", err);
      pcount++;

      p = sep;
    } while (sep && total != 0);

  /* In the match_words and match_lines cases, we use a different pattern
     for the DFA matcher that will quickly throw out cases that won't work.
     Then if DFA succeeds we do some hairy stuff using the regex matcher
     to decide whether the match should really count. */
  if (match_words || match_lines)
    {
      static char const line_beg_no_bk[] = "^(";
      static char const line_end_no_bk[] = ")$";
      static char const word_beg_no_bk[] = "(^|[^[:alnum:]_])(";
      static char const word_end_no_bk[] = ")([^[:alnum:]_]|$)";
      static char const line_beg_bk[] = "^\\(";
      static char const line_end_bk[] = "\\)$";
      static char const word_beg_bk[] = "\\(^\\|[^[:alnum:]_]\\)\\(";
      static char const word_end_bk[] = "\\)\\([^[:alnum:]_]\\|$\\)";
      int bk = !(syntax_bits & RE_NO_BK_PARENS);
      char *n = xmalloc (sizeof word_beg_bk - 1 + size + sizeof word_end_bk);

      strcpy (n, match_lines ? (bk ? line_beg_bk : line_beg_no_bk)
			     : (bk ? word_beg_bk : word_beg_no_bk));
      total = strlen(n);
      memcpy (n + total, pattern, size);
      total += size;
      strcpy (n + total, match_lines ? (bk ? line_end_bk : line_end_no_bk)
				     : (bk ? word_end_bk : word_end_no_bk));
      total += strlen (n + total);
      pattern = motif = n;
      size = total;
    }
  else
    motif = NULL;

  dfacomp (pattern, size, &dfa, 1);
  kwsmusts ();

  free(motif);
}

size_t
EGexecute (char const *buf, size_t size, size_t *match_size,
	   char const *start_ptr)
{
  char const *buflim, *beg, *end, *match, *best_match, *mb_start;
  char eol = eolbyte;
  int backref, start, len, best_len;
  struct kwsmatch kwsm;
  size_t i, ret_val;
#ifdef MBS_SUPPORT
  if (MB_CUR_MAX > 1)
    {
      if (match_icase)
        {
          /* mbtolower adds a NUL byte at the end.  That will provide
	     space for the sentinel byte dfaexec may add.  */
          char *case_buf = mbtolower (buf, &size);
	  if (start_ptr)
	    start_ptr = case_buf + (start_ptr - buf);
          buf = case_buf;
        }
    }
#endif /* MBS_SUPPORT */

  mb_start = buf;
  buflim = buf + size;

  for (beg = end = buf; end < buflim; beg = end)
    {
      if (!start_ptr)
	{
	  /* We don't care about an exact match.  */
	  if (kwset)
	    {
	      /* Find a possible match using the KWset matcher. */
	      size_t offset = kwsexec (kwset, beg, buflim - beg, &kwsm);
	      if (offset == (size_t) -1)
		goto failure;
	      beg += offset;
	      /* Narrow down to the line containing the candidate, and
		 run it through DFA. */
	      if ((end = memchr(beg, eol, buflim - beg)) != NULL)
	        end++;
              else
                end = buflim;
	      match = beg;
	      while (beg > buf && beg[-1] != eol)
		--beg;
	      if (kwsm.index < kwset_exact_matches)
                {
#ifdef MBS_SUPPORT
                  if (mb_start < beg)
                    mb_start = beg;
                  if (MB_CUR_MAX == 1 || !is_mb_middle (&mb_start, match, buflim))
#endif
                    goto success;
                }
	      if (dfaexec (&dfa, beg, (char *) end, 0, NULL, &backref) == NULL)
		continue;
	    }
	  else
	    {
	      /* No good fixed strings; start with DFA. */
	      char const *next_beg = dfaexec (&dfa, beg, (char *) buflim,
					      0, NULL, &backref);
	      if (next_beg == NULL)
		break;
	      /* Narrow down to the line we've found. */
	      beg = next_beg;
	      if ((end = memchr(beg, eol, buflim - beg)) != NULL)
	        end++;
              else
                end = buflim;
	      while (beg > buf && beg[-1] != eol)
		--beg;
	    }
	  /* Successful, no backreferences encountered! */
	  if (!backref)
	    goto success;
	}
      else
	{
	  /* We are looking for the leftmost (then longest) exact match.
	     We will go through the outer loop only once.  */
	  beg = start_ptr;
	  end = buflim;
	}

      /* If we've made it to this point, this means DFA has seen
	 a probable match, and we need to run it through Regex. */
      best_match = end;
      best_len = 0;
      for (i = 0; i < pcount; i++)
	{
	  patterns[i].regexbuf.not_eol = 0;
	  if (0 <= (start = re_search (&(patterns[i].regexbuf),
				       buf, end - buf - 1,
				       beg - buf, end - beg - 1,
				       &(patterns[i].regs))))
	    {
	      len = patterns[i].regs.end[0] - start;
	      match = buf + start;
	      if (match > best_match)
		continue;
	      if (start_ptr && !match_words)
		goto assess_pattern_match;
	      if ((!match_lines && !match_words)
		  || (match_lines && len == end - beg - 1))
		{
		  match = beg;
		  len = end - beg;
		  goto assess_pattern_match;
		}
	      /* If -w, check if the match aligns with word boundaries.
		 We do this iteratively because:
		 (a) the line may contain more than one occurence of the
		 pattern, and
		 (b) Several alternatives in the pattern might be valid at a
		 given point, and we may need to consider a shorter one to
		 find a word boundary.  */
	      if (match_words)
		while (match <= best_match)
		  {
		    
//Patch 0:
if ((((match == buf || !((1 && ((*__ctype_b_loc())[(int)(((unsigned char)match[-1]))] & (unsigned short)_ISalnum)) || ((unsigned char)match[-1]) == '_'))) || (__is_neg(25, &(match), sizeof (match), &(len), sizeof (len), &(beg), sizeof (beg), &(end), sizeof (end), &(buf), sizeof (buf), &(best_match), sizeof (best_match), &(match_words), sizeof (match_words), &(i), sizeof (i), &(patterns), sizeof (patterns), &(start), sizeof (start), &(match_lines), sizeof (match_lines), &(start_ptr), sizeof (start_ptr), &(pcount), sizeof (pcount), &(best_len), sizeof (best_len), &(buflim), sizeof (buflim), &(backref), sizeof (backref), &(eol), sizeof (eol), &(ret_val), sizeof (ret_val), &(match_size), sizeof (match_size), &(mb_start), sizeof (mb_start), &(kwset_exact_matches), sizeof (kwset_exact_matches), &(kwset), sizeof (kwset), &(size), sizeof (size), &(match_icase), sizeof (match_icase), &(eolbyte), sizeof (eolbyte)))) && (len == end - beg - 1 || !((1 && ((*__ctype_b_loc())[(int)(((unsigned char)match[len]))] & (unsigned short)_ISalnum)) || ((unsigned char)match[len]) == '_')))
    goto assess_pattern_match;

//CodeSeg 1:
		    if (len > 0)
		      {
			/* Try a shorter length anchored at the same place. */
			--len;
			patterns[i].regexbuf.not_eol = 1;
			len = re_match (&(patterns[i].regexbuf),
					buf, match + len - beg, match - buf,
					&(patterns[i].regs));
		      }
		    if (len <= 0)
		      {
			/* Try looking further on. */
			if (match == end - 1)
			  break;
			match++;
			patterns[i].regexbuf.not_eol = 0;
			start = re_search (&(patterns[i].regexbuf),
					   buf, end - buf - 1,
					   match - buf, end - match - 1,
					   &(patterns[i].regs));
			if (start < 0)
			  break;
			len = patterns[i].regs.end[0] - start;
			match = buf + start;
		      }
		  } /* while (match <= best_match) */
	      continue;
	    assess_pattern_match:
	      if (!start_ptr)
		{
		  /* Good enough for a non-exact match.
		     No need to look at further patterns, if any.  */
		  beg = match;
		  goto success_in_len;
		}
	      if (match < best_match || (match == best_match && len > best_len))
		{
		  /* Best exact match:  leftmost, then longest.  */
		  best_match = match;
		  best_len = len;
		}
	    } /* if re_search >= 0 */
	} /* for Regex patterns.  */
	if (best_match < end)
	  {
	    /* We have found an exact match.  We were just
	       waiting for the best one (leftmost then longest).  */
	    beg = best_match;
	    len = best_len;
	    goto success_in_len;
	  }
    } /* for (beg = end ..) */

 failure:
  ret_val = -1;
  goto out;

 success:
  len = end - beg;
 success_in_len:
  *match_size = len;
  ret_val = beg - buf;
 out:
  return ret_val;
}

Spawn 1 instances, now Total 14
Counter: 15
Batcher Size:14
Preprocess the following candidate with CondTester:
Priority 20000
At location src/dfasearch.c:322
--Src File: src/dfasearch.c
Fragment 0:
if ((match_words) && !(__abst_hole(match_words, match, best_match, buf, beg, end, len, i, patterns, match_lines, start_ptr, start, pcount, best_len, buflim, backref, eol, ret_val, match_size, mb_start, kwset_exact_matches, kwset, size, match_icase, eolbyte)))
    while (match <= best_match)
        {
            if ((match == buf || !((1 && ((*__ctype_b_loc())[(int)(((unsigned char)match[-1]))] & (unsigned short)_ISalnum)) || ((unsigned char)match[-1]) == '_')) && (len == end - beg - 1 || !((1 && ((*__ctype_b_loc())[(int)(((unsigned char)match[len]))] & (unsigned short)_ISalnum)) || ((unsigned char)match[len]) == '_')))
                goto assess_pattern_match;
            if (len > 0) {
                --len;
                patterns[i].regexbuf.not_eol = 1;
                len = rpl_re_match(&(patterns[i].regexbuf), buf, match + len - beg, match - buf, &(patterns[i].regs));
            }
            if (len <= 0) {
                if (match == end - 1)
                    break;
                match++;
                patterns[i].regexbuf.not_eol = 0;
                start = rpl_re_search(&(patterns[i].regexbuf), buf, end - buf - 1, match - buf, end - match - 1, &(patterns[i].regs));
                if (start < 0)
                    break;
                len = patterns[i].regs.end[0] - start;
                match = buf + start;
            }
        }


CondTester, a patch instance with id 14:
//src_file:src/dfasearch.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); void* memset(void*, int, unsigned long); 
/* dfasearch.c - searching subroutines using dfa and regex for grep.
   Copyright 1992, 1998, 2000, 2007, 2009-2010 Free Software Foundation, Inc.

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 3, or (at your option)
   any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program; if not, write to the Free Software
   Foundation, Inc., 51 Franklin Street - Fifth Floor, Boston, MA
   02110-1301, USA.  */

/* Written August 1992 by Mike Haertel. */

#include <config.h>
#include "search.h"
#include "dfa.h"

/* For -w, we also consider _ to be word constituent.  */
#define WCHAR(C) (ISALNUM(C) || (C) == '_')

/* KWset compiled pattern.  For Ecompile and Gcompile, we compile
   a list of strings, at least one of which is known to occur in
   any string matching the regexp. */
static kwset_t kwset;

/* DFA compiled regexp. */
static struct dfa dfa;

/* The Regex compiled patterns.  */
static struct patterns
{
  /* Regex compiled regexp. */
  struct re_pattern_buffer regexbuf;
  struct re_registers regs; /* This is here on account of a BRAIN-DEAD
			       Q@#%!# library interface in regex.c.  */
} patterns0;

struct patterns *patterns;
size_t pcount;

void
dfaerror (char const *mesg)
{
  error (EXIT_TROUBLE, 0, "%s", mesg);

  /* notreached */
  /* Tell static analyzers that this function does not return.  */
  abort ();
}

/* Number of compiled fixed strings known to exactly match the regexp.
   If kwsexec returns < kwset_exact_matches, then we don't need to
   call the regexp matcher at all. */
static int kwset_exact_matches;

static char const *
kwsincr_case (const char *must)
{
  const char *buf;
  size_t n;

  n = strlen (must);
#ifdef MBS_SUPPORT
  if (match_icase && MB_CUR_MAX > 1)
    buf = mbtolower (must, &n);
  else
#endif
    buf = must;
  return kwsincr (kwset, buf, n);
}

/* If the DFA turns out to have some set of fixed strings one of
   which must occur in the match, then we build a kwset matcher
   to find those strings, and thus quickly filter out impossible
   matches. */
static void
kwsmusts (void)
{
  struct dfamust const *dm;
  char const *err;

  if (dfa.musts)
    {
      kwsinit (&kwset);
      /* First, we compile in the substrings known to be exact
	 matches.  The kwset matcher will return the index
	 of the matching string that it chooses. */
      for (dm = dfa.musts; dm; dm = dm->next)
	{
	  if (!dm->exact)
	    continue;
	  ++kwset_exact_matches;
	  if ((err = kwsincr_case (dm->must)) != NULL)
	    error (EXIT_TROUBLE, 0, "%s", err);
	}
      /* Now, we compile the substrings that will require
	 the use of the regexp matcher.  */
      for (dm = dfa.musts; dm; dm = dm->next)
	{
	  if (dm->exact)
	    continue;
	  if ((err = kwsincr_case (dm->must)) != NULL)
	    error (EXIT_TROUBLE, 0, "%s", err);
	}
      if ((err = kwsprep (kwset)) != NULL)
	error (EXIT_TROUBLE, 0, "%s", err);
    }
}

void
GEAcompile (char const *pattern, size_t size, reg_syntax_t syntax_bits)
{
  const char *err;
  const char *p, *sep;
  size_t total = size;
  char *motif;

  if (match_icase)
    syntax_bits |= RE_ICASE;
  re_set_syntax (syntax_bits);
  dfasyntax (syntax_bits, match_icase, eolbyte);

  /* For GNU regex compiler we have to pass the patterns separately to detect
     errors like "[\nallo\n]\n".  The patterns here are "[", "allo" and "]"
     GNU regex should have raise a syntax error.  The same for backref, where
     the backref should have been local to each pattern.  */
  p = pattern;
  do
    {
      size_t len;
      sep = memchr (p, '\n', total);
      if (sep)
	{
	  len = sep - p;
	  sep++;
	  total -= (len + 1);
	}
      else
	{
	  len = total;
	  total = 0;
	}

      patterns = realloc (patterns, (pcount + 1) * sizeof (*patterns));
      if (patterns == NULL)
	error (EXIT_TROUBLE, errno, _("memory exhausted"));
      patterns[pcount] = patterns0;

      if ((err = re_compile_pattern (p, len,
				    &(patterns[pcount].regexbuf))) != NULL)
	error (EXIT_TROUBLE, 0, "%s", err);
      pcount++;

      p = sep;
    } while (sep && total != 0);

  /* In the match_words and match_lines cases, we use a different pattern
     for the DFA matcher that will quickly throw out cases that won't work.
     Then if DFA succeeds we do some hairy stuff using the regex matcher
     to decide whether the match should really count. */
  if (match_words || match_lines)
    {
      static char const line_beg_no_bk[] = "^(";
      static char const line_end_no_bk[] = ")$";
      static char const word_beg_no_bk[] = "(^|[^[:alnum:]_])(";
      static char const word_end_no_bk[] = ")([^[:alnum:]_]|$)";
      static char const line_beg_bk[] = "^\\(";
      static char const line_end_bk[] = "\\)$";
      static char const word_beg_bk[] = "\\(^\\|[^[:alnum:]_]\\)\\(";
      static char const word_end_bk[] = "\\)\\([^[:alnum:]_]\\|$\\)";
      int bk = !(syntax_bits & RE_NO_BK_PARENS);
      char *n = xmalloc (sizeof word_beg_bk - 1 + size + sizeof word_end_bk);

      strcpy (n, match_lines ? (bk ? line_beg_bk : line_beg_no_bk)
			     : (bk ? word_beg_bk : word_beg_no_bk));
      total = strlen(n);
      memcpy (n + total, pattern, size);
      total += size;
      strcpy (n + total, match_lines ? (bk ? line_end_bk : line_end_no_bk)
				     : (bk ? word_end_bk : word_end_no_bk));
      total += strlen (n + total);
      pattern = motif = n;
      size = total;
    }
  else
    motif = NULL;

  dfacomp (pattern, size, &dfa, 1);
  kwsmusts ();

  free(motif);
}

size_t
EGexecute (char const *buf, size_t size, size_t *match_size,
	   char const *start_ptr)
{
  char const *buflim, *beg, *end, *match, *best_match, *mb_start;
  char eol = eolbyte;
  int backref, start, len, best_len;
  struct kwsmatch kwsm;
  size_t i, ret_val;
#ifdef MBS_SUPPORT
  if (MB_CUR_MAX > 1)
    {
      if (match_icase)
        {
          /* mbtolower adds a NUL byte at the end.  That will provide
	     space for the sentinel byte dfaexec may add.  */
          char *case_buf = mbtolower (buf, &size);
	  if (start_ptr)
	    start_ptr = case_buf + (start_ptr - buf);
          buf = case_buf;
        }
    }
#endif /* MBS_SUPPORT */

  mb_start = buf;
  buflim = buf + size;

  for (beg = end = buf; end < buflim; beg = end)
    {
      if (!start_ptr)
	{
	  /* We don't care about an exact match.  */
	  if (kwset)
	    {
	      /* Find a possible match using the KWset matcher. */
	      size_t offset = kwsexec (kwset, beg, buflim - beg, &kwsm);
	      if (offset == (size_t) -1)
		goto failure;
	      beg += offset;
	      /* Narrow down to the line containing the candidate, and
		 run it through DFA. */
	      if ((end = memchr(beg, eol, buflim - beg)) != NULL)
	        end++;
              else
                end = buflim;
	      match = beg;
	      while (beg > buf && beg[-1] != eol)
		--beg;
	      if (kwsm.index < kwset_exact_matches)
                {
#ifdef MBS_SUPPORT
                  if (mb_start < beg)
                    mb_start = beg;
                  if (MB_CUR_MAX == 1 || !is_mb_middle (&mb_start, match, buflim))
#endif
                    goto success;
                }
	      if (dfaexec (&dfa, beg, (char *) end, 0, NULL, &backref) == NULL)
		continue;
	    }
	  else
	    {
	      /* No good fixed strings; start with DFA. */
	      char const *next_beg = dfaexec (&dfa, beg, (char *) buflim,
					      0, NULL, &backref);
	      if (next_beg == NULL)
		break;
	      /* Narrow down to the line we've found. */
	      beg = next_beg;
	      if ((end = memchr(beg, eol, buflim - beg)) != NULL)
	        end++;
              else
                end = buflim;
	      while (beg > buf && beg[-1] != eol)
		--beg;
	    }
	  /* Successful, no backreferences encountered! */
	  if (!backref)
	    goto success;
	}
      else
	{
	  /* We are looking for the leftmost (then longest) exact match.
	     We will go through the outer loop only once.  */
	  beg = start_ptr;
	  end = buflim;
	}

      /* If we've made it to this point, this means DFA has seen
	 a probable match, and we need to run it through Regex. */
      best_match = end;
      best_len = 0;
      for (i = 0; i < pcount; i++)
	{
	  patterns[i].regexbuf.not_eol = 0;
	  if (0 <= (start = re_search (&(patterns[i].regexbuf),
				       buf, end - buf - 1,
				       beg - buf, end - beg - 1,
				       &(patterns[i].regs))))
	    {
	      len = patterns[i].regs.end[0] - start;
	      match = buf + start;
	      if (match > best_match)
		continue;
	      if (start_ptr && !match_words)
		goto assess_pattern_match;
	      if ((!match_lines && !match_words)
		  || (match_lines && len == end - beg - 1))
		{
		  match = beg;
		  len = end - beg;
		  goto assess_pattern_match;
		}
	      /* If -w, check if the match aligns with word boundaries.
		 We do this iteratively because:
		 (a) the line may contain more than one occurence of the
		 pattern, and
		 (b) Several alternatives in the pattern might be valid at a
		 given point, and we may need to consider a shorter one to
		 find a word boundary.  */
	      
//Patch 0:
if ((match_words) && !(__is_neg(25, &(match_words), sizeof (match_words), &(match), sizeof (match), &(best_match), sizeof (best_match), &(buf), sizeof (buf), &(beg), sizeof (beg), &(end), sizeof (end), &(len), sizeof (len), &(i), sizeof (i), &(patterns), sizeof (patterns), &(match_lines), sizeof (match_lines), &(start_ptr), sizeof (start_ptr), &(start), sizeof (start), &(pcount), sizeof (pcount), &(best_len), sizeof (best_len), &(buflim), sizeof (buflim), &(backref), sizeof (backref), &(eol), sizeof (eol), &(ret_val), sizeof (ret_val), &(match_size), sizeof (match_size), &(mb_start), sizeof (mb_start), &(kwset_exact_matches), sizeof (kwset_exact_matches), &(kwset), sizeof (kwset), &(size), sizeof (size), &(match_icase), sizeof (match_icase), &(eolbyte), sizeof (eolbyte))))
    while (match <= best_match)
        {
            if ((match == buf || !((1 && ((*__ctype_b_loc())[(int)(((unsigned char)match[-1]))] & (unsigned short)_ISalnum)) || ((unsigned char)match[-1]) == '_')) && (len == end - beg - 1 || !((1 && ((*__ctype_b_loc())[(int)(((unsigned char)match[len]))] & (unsigned short)_ISalnum)) || ((unsigned char)match[len]) == '_')))
                goto assess_pattern_match;
            if (len > 0) {
                --len;
                patterns[i].regexbuf.not_eol = 1;
                len = rpl_re_match(&(patterns[i].regexbuf), buf, match + len - beg, match - buf, &(patterns[i].regs));
            }
            if (len <= 0) {
                if (match == end - 1)
                    break;
                match++;
                patterns[i].regexbuf.not_eol = 0;
                start = rpl_re_search(&(patterns[i].regexbuf), buf, end - buf - 1, match - buf, end - match - 1, &(patterns[i].regs));
                if (start < 0)
                    break;
                len = patterns[i].regs.end[0] - start;
                match = buf + start;
            }
        }

//CodeSeg 1:
	      continue;
	    assess_pattern_match:
	      if (!start_ptr)
		{
		  /* Good enough for a non-exact match.
		     No need to look at further patterns, if any.  */
		  beg = match;
		  goto success_in_len;
		}
	      if (match < best_match || (match == best_match && len > best_len))
		{
		  /* Best exact match:  leftmost, then longest.  */
		  best_match = match;
		  best_len = len;
		}
	    } /* if re_search >= 0 */
	} /* for Regex patterns.  */
	if (best_match < end)
	  {
	    /* We have found an exact match.  We were just
	       waiting for the best one (leftmost then longest).  */
	    beg = best_match;
	    len = best_len;
	    goto success_in_len;
	  }
    } /* for (beg = end ..) */

 failure:
  ret_val = -1;
  goto out;

 success:
  len = end - beg;
 success_in_len:
  *match_size = len;
  ret_val = beg - buf;
 out:
  return ret_val;
}

Spawn 1 instances, now Total 15
Counter: 16
Batcher Size:15
Preprocess the following candidate with CondTester:
Priority 20000
At location src/dfasearch.c:322
--Src File: src/dfasearch.c
Fragment 0:
if ((match_words) || (__abst_hole(match_words, match, best_match, buf, beg, end, len, i, patterns, match_lines, start_ptr, start, pcount, best_len, buflim, backref, eol, ret_val, match_size, mb_start, kwset_exact_matches, kwset, size, match_icase, eolbyte)))
    while (match <= best_match)
        {
            if ((match == buf || !((1 && ((*__ctype_b_loc())[(int)(((unsigned char)match[-1]))] & (unsigned short)_ISalnum)) || ((unsigned char)match[-1]) == '_')) && (len == end - beg - 1 || !((1 && ((*__ctype_b_loc())[(int)(((unsigned char)match[len]))] & (unsigned short)_ISalnum)) || ((unsigned char)match[len]) == '_')))
                goto assess_pattern_match;
            if (len > 0) {
                --len;
                patterns[i].regexbuf.not_eol = 1;
                len = rpl_re_match(&(patterns[i].regexbuf), buf, match + len - beg, match - buf, &(patterns[i].regs));
            }
            if (len <= 0) {
                if (match == end - 1)
                    break;
                match++;
                patterns[i].regexbuf.not_eol = 0;
                start = rpl_re_search(&(patterns[i].regexbuf), buf, end - buf - 1, match - buf, end - match - 1, &(patterns[i].regs));
                if (start < 0)
                    break;
                len = patterns[i].regs.end[0] - start;
                match = buf + start;
            }
        }


CondTester, a patch instance with id 15:
//src_file:src/dfasearch.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); void* memset(void*, int, unsigned long); 
/* dfasearch.c - searching subroutines using dfa and regex for grep.
   Copyright 1992, 1998, 2000, 2007, 2009-2010 Free Software Foundation, Inc.

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 3, or (at your option)
   any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program; if not, write to the Free Software
   Foundation, Inc., 51 Franklin Street - Fifth Floor, Boston, MA
   02110-1301, USA.  */

/* Written August 1992 by Mike Haertel. */

#include <config.h>
#include "search.h"
#include "dfa.h"

/* For -w, we also consider _ to be word constituent.  */
#define WCHAR(C) (ISALNUM(C) || (C) == '_')

/* KWset compiled pattern.  For Ecompile and Gcompile, we compile
   a list of strings, at least one of which is known to occur in
   any string matching the regexp. */
static kwset_t kwset;

/* DFA compiled regexp. */
static struct dfa dfa;

/* The Regex compiled patterns.  */
static struct patterns
{
  /* Regex compiled regexp. */
  struct re_pattern_buffer regexbuf;
  struct re_registers regs; /* This is here on account of a BRAIN-DEAD
			       Q@#%!# library interface in regex.c.  */
} patterns0;

struct patterns *patterns;
size_t pcount;

void
dfaerror (char const *mesg)
{
  error (EXIT_TROUBLE, 0, "%s", mesg);

  /* notreached */
  /* Tell static analyzers that this function does not return.  */
  abort ();
}

/* Number of compiled fixed strings known to exactly match the regexp.
   If kwsexec returns < kwset_exact_matches, then we don't need to
   call the regexp matcher at all. */
static int kwset_exact_matches;

static char const *
kwsincr_case (const char *must)
{
  const char *buf;
  size_t n;

  n = strlen (must);
#ifdef MBS_SUPPORT
  if (match_icase && MB_CUR_MAX > 1)
    buf = mbtolower (must, &n);
  else
#endif
    buf = must;
  return kwsincr (kwset, buf, n);
}

/* If the DFA turns out to have some set of fixed strings one of
   which must occur in the match, then we build a kwset matcher
   to find those strings, and thus quickly filter out impossible
   matches. */
static void
kwsmusts (void)
{
  struct dfamust const *dm;
  char const *err;

  if (dfa.musts)
    {
      kwsinit (&kwset);
      /* First, we compile in the substrings known to be exact
	 matches.  The kwset matcher will return the index
	 of the matching string that it chooses. */
      for (dm = dfa.musts; dm; dm = dm->next)
	{
	  if (!dm->exact)
	    continue;
	  ++kwset_exact_matches;
	  if ((err = kwsincr_case (dm->must)) != NULL)
	    error (EXIT_TROUBLE, 0, "%s", err);
	}
      /* Now, we compile the substrings that will require
	 the use of the regexp matcher.  */
      for (dm = dfa.musts; dm; dm = dm->next)
	{
	  if (dm->exact)
	    continue;
	  if ((err = kwsincr_case (dm->must)) != NULL)
	    error (EXIT_TROUBLE, 0, "%s", err);
	}
      if ((err = kwsprep (kwset)) != NULL)
	error (EXIT_TROUBLE, 0, "%s", err);
    }
}

void
GEAcompile (char const *pattern, size_t size, reg_syntax_t syntax_bits)
{
  const char *err;
  const char *p, *sep;
  size_t total = size;
  char *motif;

  if (match_icase)
    syntax_bits |= RE_ICASE;
  re_set_syntax (syntax_bits);
  dfasyntax (syntax_bits, match_icase, eolbyte);

  /* For GNU regex compiler we have to pass the patterns separately to detect
     errors like "[\nallo\n]\n".  The patterns here are "[", "allo" and "]"
     GNU regex should have raise a syntax error.  The same for backref, where
     the backref should have been local to each pattern.  */
  p = pattern;
  do
    {
      size_t len;
      sep = memchr (p, '\n', total);
      if (sep)
	{
	  len = sep - p;
	  sep++;
	  total -= (len + 1);
	}
      else
	{
	  len = total;
	  total = 0;
	}

      patterns = realloc (patterns, (pcount + 1) * sizeof (*patterns));
      if (patterns == NULL)
	error (EXIT_TROUBLE, errno, _("memory exhausted"));
      patterns[pcount] = patterns0;

      if ((err = re_compile_pattern (p, len,
				    &(patterns[pcount].regexbuf))) != NULL)
	error (EXIT_TROUBLE, 0, "%s", err);
      pcount++;

      p = sep;
    } while (sep && total != 0);

  /* In the match_words and match_lines cases, we use a different pattern
     for the DFA matcher that will quickly throw out cases that won't work.
     Then if DFA succeeds we do some hairy stuff using the regex matcher
     to decide whether the match should really count. */
  if (match_words || match_lines)
    {
      static char const line_beg_no_bk[] = "^(";
      static char const line_end_no_bk[] = ")$";
      static char const word_beg_no_bk[] = "(^|[^[:alnum:]_])(";
      static char const word_end_no_bk[] = ")([^[:alnum:]_]|$)";
      static char const line_beg_bk[] = "^\\(";
      static char const line_end_bk[] = "\\)$";
      static char const word_beg_bk[] = "\\(^\\|[^[:alnum:]_]\\)\\(";
      static char const word_end_bk[] = "\\)\\([^[:alnum:]_]\\|$\\)";
      int bk = !(syntax_bits & RE_NO_BK_PARENS);
      char *n = xmalloc (sizeof word_beg_bk - 1 + size + sizeof word_end_bk);

      strcpy (n, match_lines ? (bk ? line_beg_bk : line_beg_no_bk)
			     : (bk ? word_beg_bk : word_beg_no_bk));
      total = strlen(n);
      memcpy (n + total, pattern, size);
      total += size;
      strcpy (n + total, match_lines ? (bk ? line_end_bk : line_end_no_bk)
				     : (bk ? word_end_bk : word_end_no_bk));
      total += strlen (n + total);
      pattern = motif = n;
      size = total;
    }
  else
    motif = NULL;

  dfacomp (pattern, size, &dfa, 1);
  kwsmusts ();

  free(motif);
}

size_t
EGexecute (char const *buf, size_t size, size_t *match_size,
	   char const *start_ptr)
{
  char const *buflim, *beg, *end, *match, *best_match, *mb_start;
  char eol = eolbyte;
  int backref, start, len, best_len;
  struct kwsmatch kwsm;
  size_t i, ret_val;
#ifdef MBS_SUPPORT
  if (MB_CUR_MAX > 1)
    {
      if (match_icase)
        {
          /* mbtolower adds a NUL byte at the end.  That will provide
	     space for the sentinel byte dfaexec may add.  */
          char *case_buf = mbtolower (buf, &size);
	  if (start_ptr)
	    start_ptr = case_buf + (start_ptr - buf);
          buf = case_buf;
        }
    }
#endif /* MBS_SUPPORT */

  mb_start = buf;
  buflim = buf + size;

  for (beg = end = buf; end < buflim; beg = end)
    {
      if (!start_ptr)
	{
	  /* We don't care about an exact match.  */
	  if (kwset)
	    {
	      /* Find a possible match using the KWset matcher. */
	      size_t offset = kwsexec (kwset, beg, buflim - beg, &kwsm);
	      if (offset == (size_t) -1)
		goto failure;
	      beg += offset;
	      /* Narrow down to the line containing the candidate, and
		 run it through DFA. */
	      if ((end = memchr(beg, eol, buflim - beg)) != NULL)
	        end++;
              else
                end = buflim;
	      match = beg;
	      while (beg > buf && beg[-1] != eol)
		--beg;
	      if (kwsm.index < kwset_exact_matches)
                {
#ifdef MBS_SUPPORT
                  if (mb_start < beg)
                    mb_start = beg;
                  if (MB_CUR_MAX == 1 || !is_mb_middle (&mb_start, match, buflim))
#endif
                    goto success;
                }
	      if (dfaexec (&dfa, beg, (char *) end, 0, NULL, &backref) == NULL)
		continue;
	    }
	  else
	    {
	      /* No good fixed strings; start with DFA. */
	      char const *next_beg = dfaexec (&dfa, beg, (char *) buflim,
					      0, NULL, &backref);
	      if (next_beg == NULL)
		break;
	      /* Narrow down to the line we've found. */
	      beg = next_beg;
	      if ((end = memchr(beg, eol, buflim - beg)) != NULL)
	        end++;
              else
                end = buflim;
	      while (beg > buf && beg[-1] != eol)
		--beg;
	    }
	  /* Successful, no backreferences encountered! */
	  if (!backref)
	    goto success;
	}
      else
	{
	  /* We are looking for the leftmost (then longest) exact match.
	     We will go through the outer loop only once.  */
	  beg = start_ptr;
	  end = buflim;
	}

      /* If we've made it to this point, this means DFA has seen
	 a probable match, and we need to run it through Regex. */
      best_match = end;
      best_len = 0;
      for (i = 0; i < pcount; i++)
	{
	  patterns[i].regexbuf.not_eol = 0;
	  if (0 <= (start = re_search (&(patterns[i].regexbuf),
				       buf, end - buf - 1,
				       beg - buf, end - beg - 1,
				       &(patterns[i].regs))))
	    {
	      len = patterns[i].regs.end[0] - start;
	      match = buf + start;
	      if (match > best_match)
		continue;
	      if (start_ptr && !match_words)
		goto assess_pattern_match;
	      if ((!match_lines && !match_words)
		  || (match_lines && len == end - beg - 1))
		{
		  match = beg;
		  len = end - beg;
		  goto assess_pattern_match;
		}
	      /* If -w, check if the match aligns with word boundaries.
		 We do this iteratively because:
		 (a) the line may contain more than one occurence of the
		 pattern, and
		 (b) Several alternatives in the pattern might be valid at a
		 given point, and we may need to consider a shorter one to
		 find a word boundary.  */
	      
//Patch 0:
if ((match_words) || (__is_neg(25, &(match_words), sizeof (match_words), &(match), sizeof (match), &(best_match), sizeof (best_match), &(buf), sizeof (buf), &(beg), sizeof (beg), &(end), sizeof (end), &(len), sizeof (len), &(i), sizeof (i), &(patterns), sizeof (patterns), &(match_lines), sizeof (match_lines), &(start_ptr), sizeof (start_ptr), &(start), sizeof (start), &(pcount), sizeof (pcount), &(best_len), sizeof (best_len), &(buflim), sizeof (buflim), &(backref), sizeof (backref), &(eol), sizeof (eol), &(ret_val), sizeof (ret_val), &(match_size), sizeof (match_size), &(mb_start), sizeof (mb_start), &(kwset_exact_matches), sizeof (kwset_exact_matches), &(kwset), sizeof (kwset), &(size), sizeof (size), &(match_icase), sizeof (match_icase), &(eolbyte), sizeof (eolbyte))))
    while (match <= best_match)
        {
            if ((match == buf || !((1 && ((*__ctype_b_loc())[(int)(((unsigned char)match[-1]))] & (unsigned short)_ISalnum)) || ((unsigned char)match[-1]) == '_')) && (len == end - beg - 1 || !((1 && ((*__ctype_b_loc())[(int)(((unsigned char)match[len]))] & (unsigned short)_ISalnum)) || ((unsigned char)match[len]) == '_')))
                goto assess_pattern_match;
            if (len > 0) {
                --len;
                patterns[i].regexbuf.not_eol = 1;
                len = rpl_re_match(&(patterns[i].regexbuf), buf, match + len - beg, match - buf, &(patterns[i].regs));
            }
            if (len <= 0) {
                if (match == end - 1)
                    break;
                match++;
                patterns[i].regexbuf.not_eol = 0;
                start = rpl_re_search(&(patterns[i].regexbuf), buf, end - buf - 1, match - buf, end - match - 1, &(patterns[i].regs));
                if (start < 0)
                    break;
                len = patterns[i].regs.end[0] - start;
                match = buf + start;
            }
        }

//CodeSeg 1:
	      continue;
	    assess_pattern_match:
	      if (!start_ptr)
		{
		  /* Good enough for a non-exact match.
		     No need to look at further patterns, if any.  */
		  beg = match;
		  goto success_in_len;
		}
	      if (match < best_match || (match == best_match && len > best_len))
		{
		  /* Best exact match:  leftmost, then longest.  */
		  best_match = match;
		  best_len = len;
		}
	    } /* if re_search >= 0 */
	} /* for Regex patterns.  */
	if (best_match < end)
	  {
	    /* We have found an exact match.  We were just
	       waiting for the best one (leftmost then longest).  */
	    beg = best_match;
	    len = best_len;
	    goto success_in_len;
	  }
    } /* for (beg = end ..) */

 failure:
  ret_val = -1;
  goto out;

 success:
  len = end - beg;
 success_in_len:
  *match_size = len;
  ret_val = beg - buf;
 out:
  return ret_val;
}

Spawn 1 instances, now Total 16
Counter: 17
Batcher Size:16
Preprocess the following candidate with CondTester:
Priority 20000
At location src/dfasearch.c:113
--Src File: src/dfasearch.c
Fragment 0:
if (((err = kwsprep(kwset)) != ((void *)0)) || (__abst_hole(err, kwset, dm, kwset_exact_matches)))
    error(EXIT_TROUBLE, 0, "%s", err);


CondTester, a patch instance with id 16:
//src_file:src/dfasearch.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); void* memset(void*, int, unsigned long); 
/* dfasearch.c - searching subroutines using dfa and regex for grep.
   Copyright 1992, 1998, 2000, 2007, 2009-2010 Free Software Foundation, Inc.

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 3, or (at your option)
   any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program; if not, write to the Free Software
   Foundation, Inc., 51 Franklin Street - Fifth Floor, Boston, MA
   02110-1301, USA.  */

/* Written August 1992 by Mike Haertel. */

#include <config.h>
#include "search.h"
#include "dfa.h"

/* For -w, we also consider _ to be word constituent.  */
#define WCHAR(C) (ISALNUM(C) || (C) == '_')

/* KWset compiled pattern.  For Ecompile and Gcompile, we compile
   a list of strings, at least one of which is known to occur in
   any string matching the regexp. */
static kwset_t kwset;

/* DFA compiled regexp. */
static struct dfa dfa;

/* The Regex compiled patterns.  */
static struct patterns
{
  /* Regex compiled regexp. */
  struct re_pattern_buffer regexbuf;
  struct re_registers regs; /* This is here on account of a BRAIN-DEAD
			       Q@#%!# library interface in regex.c.  */
} patterns0;

struct patterns *patterns;
size_t pcount;

void
dfaerror (char const *mesg)
{
  error (EXIT_TROUBLE, 0, "%s", mesg);

  /* notreached */
  /* Tell static analyzers that this function does not return.  */
  abort ();
}

/* Number of compiled fixed strings known to exactly match the regexp.
   If kwsexec returns < kwset_exact_matches, then we don't need to
   call the regexp matcher at all. */
static int kwset_exact_matches;

static char const *
kwsincr_case (const char *must)
{
  const char *buf;
  size_t n;

  n = strlen (must);
#ifdef MBS_SUPPORT
  if (match_icase && MB_CUR_MAX > 1)
    buf = mbtolower (must, &n);
  else
#endif
    buf = must;
  return kwsincr (kwset, buf, n);
}

/* If the DFA turns out to have some set of fixed strings one of
   which must occur in the match, then we build a kwset matcher
   to find those strings, and thus quickly filter out impossible
   matches. */
static void
kwsmusts (void)
{
  struct dfamust const *dm;
  char const *err;

  if (dfa.musts)
    {
      kwsinit (&kwset);
      /* First, we compile in the substrings known to be exact
	 matches.  The kwset matcher will return the index
	 of the matching string that it chooses. */
      for (dm = dfa.musts; dm; dm = dm->next)
	{
	  if (!dm->exact)
	    continue;
	  ++kwset_exact_matches;
	  if ((err = kwsincr_case (dm->must)) != NULL)
	    error (EXIT_TROUBLE, 0, "%s", err);
	}
      /* Now, we compile the substrings that will require
	 the use of the regexp matcher.  */
      for (dm = dfa.musts; dm; dm = dm->next)
	{
	  if (dm->exact)
	    continue;
	  if ((err = kwsincr_case (dm->must)) != NULL)
	    error (EXIT_TROUBLE, 0, "%s", err);
	}
      
//Patch 0:
if (((err = kwsprep(kwset)) != ((void *)0)) || (__is_neg(4, &(err), sizeof (err), &(kwset), sizeof (kwset), &(dm), sizeof (dm), &(kwset_exact_matches), sizeof (kwset_exact_matches))))
    error(EXIT_TROUBLE, 0, "%s", err);

//CodeSeg 1:
    }
}

void
GEAcompile (char const *pattern, size_t size, reg_syntax_t syntax_bits)
{
  const char *err;
  const char *p, *sep;
  size_t total = size;
  char *motif;

  if (match_icase)
    syntax_bits |= RE_ICASE;
  re_set_syntax (syntax_bits);
  dfasyntax (syntax_bits, match_icase, eolbyte);

  /* For GNU regex compiler we have to pass the patterns separately to detect
     errors like "[\nallo\n]\n".  The patterns here are "[", "allo" and "]"
     GNU regex should have raise a syntax error.  The same for backref, where
     the backref should have been local to each pattern.  */
  p = pattern;
  do
    {
      size_t len;
      sep = memchr (p, '\n', total);
      if (sep)
	{
	  len = sep - p;
	  sep++;
	  total -= (len + 1);
	}
      else
	{
	  len = total;
	  total = 0;
	}

      patterns = realloc (patterns, (pcount + 1) * sizeof (*patterns));
      if (patterns == NULL)
	error (EXIT_TROUBLE, errno, _("memory exhausted"));
      patterns[pcount] = patterns0;

      if ((err = re_compile_pattern (p, len,
				    &(patterns[pcount].regexbuf))) != NULL)
	error (EXIT_TROUBLE, 0, "%s", err);
      pcount++;

      p = sep;
    } while (sep && total != 0);

  /* In the match_words and match_lines cases, we use a different pattern
     for the DFA matcher that will quickly throw out cases that won't work.
     Then if DFA succeeds we do some hairy stuff using the regex matcher
     to decide whether the match should really count. */
  if (match_words || match_lines)
    {
      static char const line_beg_no_bk[] = "^(";
      static char const line_end_no_bk[] = ")$";
      static char const word_beg_no_bk[] = "(^|[^[:alnum:]_])(";
      static char const word_end_no_bk[] = ")([^[:alnum:]_]|$)";
      static char const line_beg_bk[] = "^\\(";
      static char const line_end_bk[] = "\\)$";
      static char const word_beg_bk[] = "\\(^\\|[^[:alnum:]_]\\)\\(";
      static char const word_end_bk[] = "\\)\\([^[:alnum:]_]\\|$\\)";
      int bk = !(syntax_bits & RE_NO_BK_PARENS);
      char *n = xmalloc (sizeof word_beg_bk - 1 + size + sizeof word_end_bk);

      strcpy (n, match_lines ? (bk ? line_beg_bk : line_beg_no_bk)
			     : (bk ? word_beg_bk : word_beg_no_bk));
      total = strlen(n);
      memcpy (n + total, pattern, size);
      total += size;
      strcpy (n + total, match_lines ? (bk ? line_end_bk : line_end_no_bk)
				     : (bk ? word_end_bk : word_end_no_bk));
      total += strlen (n + total);
      pattern = motif = n;
      size = total;
    }
  else
    motif = NULL;

  dfacomp (pattern, size, &dfa, 1);
  kwsmusts ();

  free(motif);
}

size_t
EGexecute (char const *buf, size_t size, size_t *match_size,
	   char const *start_ptr)
{
  char const *buflim, *beg, *end, *match, *best_match, *mb_start;
  char eol = eolbyte;
  int backref, start, len, best_len;
  struct kwsmatch kwsm;
  size_t i, ret_val;
#ifdef MBS_SUPPORT
  if (MB_CUR_MAX > 1)
    {
      if (match_icase)
        {
          /* mbtolower adds a NUL byte at the end.  That will provide
	     space for the sentinel byte dfaexec may add.  */
          char *case_buf = mbtolower (buf, &size);
	  if (start_ptr)
	    start_ptr = case_buf + (start_ptr - buf);
          buf = case_buf;
        }
    }
#endif /* MBS_SUPPORT */

  mb_start = buf;
  buflim = buf + size;

  for (beg = end = buf; end < buflim; beg = end)
    {
      if (!start_ptr)
	{
	  /* We don't care about an exact match.  */
	  if (kwset)
	    {
	      /* Find a possible match using the KWset matcher. */
	      size_t offset = kwsexec (kwset, beg, buflim - beg, &kwsm);
	      if (offset == (size_t) -1)
		goto failure;
	      beg += offset;
	      /* Narrow down to the line containing the candidate, and
		 run it through DFA. */
	      if ((end = memchr(beg, eol, buflim - beg)) != NULL)
	        end++;
              else
                end = buflim;
	      match = beg;
	      while (beg > buf && beg[-1] != eol)
		--beg;
	      if (kwsm.index < kwset_exact_matches)
                {
#ifdef MBS_SUPPORT
                  if (mb_start < beg)
                    mb_start = beg;
                  if (MB_CUR_MAX == 1 || !is_mb_middle (&mb_start, match, buflim))
#endif
                    goto success;
                }
	      if (dfaexec (&dfa, beg, (char *) end, 0, NULL, &backref) == NULL)
		continue;
	    }
	  else
	    {
	      /* No good fixed strings; start with DFA. */
	      char const *next_beg = dfaexec (&dfa, beg, (char *) buflim,
					      0, NULL, &backref);
	      if (next_beg == NULL)
		break;
	      /* Narrow down to the line we've found. */
	      beg = next_beg;
	      if ((end = memchr(beg, eol, buflim - beg)) != NULL)
	        end++;
              else
                end = buflim;
	      while (beg > buf && beg[-1] != eol)
		--beg;
	    }
	  /* Successful, no backreferences encountered! */
	  if (!backref)
	    goto success;
	}
      else
	{
	  /* We are looking for the leftmost (then longest) exact match.
	     We will go through the outer loop only once.  */
	  beg = start_ptr;
	  end = buflim;
	}

      /* If we've made it to this point, this means DFA has seen
	 a probable match, and we need to run it through Regex. */
      best_match = end;
      best_len = 0;
      for (i = 0; i < pcount; i++)
	{
	  patterns[i].regexbuf.not_eol = 0;
	  if (0 <= (start = re_search (&(patterns[i].regexbuf),
				       buf, end - buf - 1,
				       beg - buf, end - beg - 1,
				       &(patterns[i].regs))))
	    {
	      len = patterns[i].regs.end[0] - start;
	      match = buf + start;
	      if (match > best_match)
		continue;
	      if (start_ptr && !match_words)
		goto assess_pattern_match;
	      if ((!match_lines && !match_words)
		  || (match_lines && len == end - beg - 1))
		{
		  match = beg;
		  len = end - beg;
		  goto assess_pattern_match;
		}
	      /* If -w, check if the match aligns with word boundaries.
		 We do this iteratively because:
		 (a) the line may contain more than one occurence of the
		 pattern, and
		 (b) Several alternatives in the pattern might be valid at a
		 given point, and we may need to consider a shorter one to
		 find a word boundary.  */
	      if (match_words)
		while (match <= best_match)
		  {
		    if ((match == buf || !WCHAR ((unsigned char) match[-1]))
			&& (len == end - beg - 1
			    || !WCHAR ((unsigned char) match[len])))
		      goto assess_pattern_match;
		    if (len > 0)
		      {
			/* Try a shorter length anchored at the same place. */
			--len;
			patterns[i].regexbuf.not_eol = 1;
			len = re_match (&(patterns[i].regexbuf),
					buf, match + len - beg, match - buf,
					&(patterns[i].regs));
		      }
		    if (len <= 0)
		      {
			/* Try looking further on. */
			if (match == end - 1)
			  break;
			match++;
			patterns[i].regexbuf.not_eol = 0;
			start = re_search (&(patterns[i].regexbuf),
					   buf, end - buf - 1,
					   match - buf, end - match - 1,
					   &(patterns[i].regs));
			if (start < 0)
			  break;
			len = patterns[i].regs.end[0] - start;
			match = buf + start;
		      }
		  } /* while (match <= best_match) */
	      continue;
	    assess_pattern_match:
	      if (!start_ptr)
		{
		  /* Good enough for a non-exact match.
		     No need to look at further patterns, if any.  */
		  beg = match;
		  goto success_in_len;
		}
	      if (match < best_match || (match == best_match && len > best_len))
		{
		  /* Best exact match:  leftmost, then longest.  */
		  best_match = match;
		  best_len = len;
		}
	    } /* if re_search >= 0 */
	} /* for Regex patterns.  */
	if (best_match < end)
	  {
	    /* We have found an exact match.  We were just
	       waiting for the best one (leftmost then longest).  */
	    beg = best_match;
	    len = best_len;
	    goto success_in_len;
	  }
    } /* for (beg = end ..) */

 failure:
  ret_val = -1;
  goto out;

 success:
  len = end - beg;
 success_in_len:
  *match_size = len;
  ret_val = beg - buf;
 out:
  return ret_val;
}

Spawn 1 instances, now Total 17
Counter: 18
Batcher Size:17
Preprocess the following candidate with CondTester:
Priority 20000
At location src/dfasearch.c:90
--Src File: src/dfasearch.c
Fragment 0:
if ((dfa.musts) && !(__abst_hole(dfa.musts, dfa.musts, kwset, dm, kwset_exact_matches, err, dfa.charclasses, dfa.cindex, dfa.calloc, dfa.tokens, dfa.tindex, dfa.talloc, dfa.depth, dfa.nleaves, dfa.nregexps, dfa.mb_cur_max, dfa.nmultibyte_prop, dfa.multibyte_prop, dfa.mbcsets, dfa.nmbcsets, dfa.mbcsets_alloc, dfa.states, dfa.sindex, dfa.salloc, dfa.follows, dfa.searchflag, dfa.tralloc, dfa.trcount, dfa.trans, dfa.realtrans, dfa.fails, dfa.success, dfa.newlines, dfa.charclasses, dfa.cindex, dfa.calloc, dfa.tokens, dfa.tindex, dfa.talloc, dfa.depth, dfa.nleaves, dfa.nregexps, dfa.mb_cur_max, dfa.nmultibyte_prop, dfa.multibyte_prop, dfa.mbcsets, dfa.nmbcsets, dfa.mbcsets_alloc, dfa.states, dfa.sindex, dfa.salloc, dfa.follows, dfa.searchflag, dfa.tralloc, dfa.trcount, dfa.trans, dfa.realtrans, dfa.fails, dfa.success, dfa.newlines))) {
    kwsinit(&kwset);
    for (dm = dfa.musts; dm; dm = dm->next) {
        if (!dm->exact)
            continue;
        ++kwset_exact_matches;
        if ((err = kwsincr_case(dm->must)) != ((void *)0))
            error(EXIT_TROUBLE, 0, "%s", err);
    }
    for (dm = dfa.musts; dm; dm = dm->next) {
        if (dm->exact)
            continue;
        if ((err = kwsincr_case(dm->must)) != ((void *)0))
            error(EXIT_TROUBLE, 0, "%s", err);
    }
    if ((err = kwsprep(kwset)) != ((void *)0))
        error(EXIT_TROUBLE, 0, "%s", err);
}


CondTester, a patch instance with id 17:
//src_file:src/dfasearch.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); void* memset(void*, int, unsigned long); 
/* dfasearch.c - searching subroutines using dfa and regex for grep.
   Copyright 1992, 1998, 2000, 2007, 2009-2010 Free Software Foundation, Inc.

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 3, or (at your option)
   any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program; if not, write to the Free Software
   Foundation, Inc., 51 Franklin Street - Fifth Floor, Boston, MA
   02110-1301, USA.  */

/* Written August 1992 by Mike Haertel. */

#include <config.h>
#include "search.h"
#include "dfa.h"

/* For -w, we also consider _ to be word constituent.  */
#define WCHAR(C) (ISALNUM(C) || (C) == '_')

/* KWset compiled pattern.  For Ecompile and Gcompile, we compile
   a list of strings, at least one of which is known to occur in
   any string matching the regexp. */
static kwset_t kwset;

/* DFA compiled regexp. */
static struct dfa dfa;

/* The Regex compiled patterns.  */
static struct patterns
{
  /* Regex compiled regexp. */
  struct re_pattern_buffer regexbuf;
  struct re_registers regs; /* This is here on account of a BRAIN-DEAD
			       Q@#%!# library interface in regex.c.  */
} patterns0;

struct patterns *patterns;
size_t pcount;

void
dfaerror (char const *mesg)
{
  error (EXIT_TROUBLE, 0, "%s", mesg);

  /* notreached */
  /* Tell static analyzers that this function does not return.  */
  abort ();
}

/* Number of compiled fixed strings known to exactly match the regexp.
   If kwsexec returns < kwset_exact_matches, then we don't need to
   call the regexp matcher at all. */
static int kwset_exact_matches;

static char const *
kwsincr_case (const char *must)
{
  const char *buf;
  size_t n;

  n = strlen (must);
#ifdef MBS_SUPPORT
  if (match_icase && MB_CUR_MAX > 1)
    buf = mbtolower (must, &n);
  else
#endif
    buf = must;
  return kwsincr (kwset, buf, n);
}

/* If the DFA turns out to have some set of fixed strings one of
   which must occur in the match, then we build a kwset matcher
   to find those strings, and thus quickly filter out impossible
   matches. */
static void
kwsmusts (void)
{
  struct dfamust const *dm;
  char const *err;

  
//Patch 0:
if ((dfa.musts) && !(__is_neg(60, &(dfa.musts), sizeof (dfa.musts), &(dfa.musts), sizeof (dfa.musts), &(kwset), sizeof (kwset), &(dm), sizeof (dm), &(kwset_exact_matches), sizeof (kwset_exact_matches), &(err), sizeof (err), &(dfa.charclasses), sizeof (dfa.charclasses), &(dfa.cindex), sizeof (dfa.cindex), &(dfa.calloc), sizeof (dfa.calloc), &(dfa.tokens), sizeof (dfa.tokens), &(dfa.tindex), sizeof (dfa.tindex), &(dfa.talloc), sizeof (dfa.talloc), &(dfa.depth), sizeof (dfa.depth), &(dfa.nleaves), sizeof (dfa.nleaves), &(dfa.nregexps), sizeof (dfa.nregexps), &(dfa.mb_cur_max), sizeof (dfa.mb_cur_max), &(dfa.nmultibyte_prop), sizeof (dfa.nmultibyte_prop), &(dfa.multibyte_prop), sizeof (dfa.multibyte_prop), &(dfa.mbcsets), sizeof (dfa.mbcsets), &(dfa.nmbcsets), sizeof (dfa.nmbcsets), &(dfa.mbcsets_alloc), sizeof (dfa.mbcsets_alloc), &(dfa.states), sizeof (dfa.states), &(dfa.sindex), sizeof (dfa.sindex), &(dfa.salloc), sizeof (dfa.salloc), &(dfa.follows), sizeof (dfa.follows), &(dfa.searchflag), sizeof (dfa.searchflag), &(dfa.tralloc), sizeof (dfa.tralloc), &(dfa.trcount), sizeof (dfa.trcount), &(dfa.trans), sizeof (dfa.trans), &(dfa.realtrans), sizeof (dfa.realtrans), &(dfa.fails), sizeof (dfa.fails), &(dfa.success), sizeof (dfa.success), &(dfa.newlines), sizeof (dfa.newlines), &(dfa.charclasses), sizeof (dfa.charclasses), &(dfa.cindex), sizeof (dfa.cindex), &(dfa.calloc), sizeof (dfa.calloc), &(dfa.tokens), sizeof (dfa.tokens), &(dfa.tindex), sizeof (dfa.tindex), &(dfa.talloc), sizeof (dfa.talloc), &(dfa.depth), sizeof (dfa.depth), &(dfa.nleaves), sizeof (dfa.nleaves), &(dfa.nregexps), sizeof (dfa.nregexps), &(dfa.mb_cur_max), sizeof (dfa.mb_cur_max), &(dfa.nmultibyte_prop), sizeof (dfa.nmultibyte_prop), &(dfa.multibyte_prop), sizeof (dfa.multibyte_prop), &(dfa.mbcsets), sizeof (dfa.mbcsets), &(dfa.nmbcsets), sizeof (dfa.nmbcsets), &(dfa.mbcsets_alloc), sizeof (dfa.mbcsets_alloc), &(dfa.states), sizeof (dfa.states), &(dfa.sindex), sizeof (dfa.sindex), &(dfa.salloc), sizeof (dfa.salloc), &(dfa.follows), sizeof (dfa.follows), &(dfa.searchflag), sizeof (dfa.searchflag), &(dfa.tralloc), sizeof (dfa.tralloc), &(dfa.trcount), sizeof (dfa.trcount), &(dfa.trans), sizeof (dfa.trans), &(dfa.realtrans), sizeof (dfa.realtrans), &(dfa.fails), sizeof (dfa.fails), &(dfa.success), sizeof (dfa.success), &(dfa.newlines), sizeof (dfa.newlines)))) {
    kwsinit(&kwset);
    for (dm = dfa.musts; dm; dm = dm->next) {
        if (!dm->exact)
            continue;
        ++kwset_exact_matches;
        if ((err = kwsincr_case(dm->must)) != ((void *)0))
            error(EXIT_TROUBLE, 0, "%s", err);
    }
    for (dm = dfa.musts; dm; dm = dm->next) {
        if (dm->exact)
            continue;
        if ((err = kwsincr_case(dm->must)) != ((void *)0))
            error(EXIT_TROUBLE, 0, "%s", err);
    }
    if ((err = kwsprep(kwset)) != ((void *)0))
        error(EXIT_TROUBLE, 0, "%s", err);
}

//CodeSeg 1:
}

void
GEAcompile (char const *pattern, size_t size, reg_syntax_t syntax_bits)
{
  const char *err;
  const char *p, *sep;
  size_t total = size;
  char *motif;

  if (match_icase)
    syntax_bits |= RE_ICASE;
  re_set_syntax (syntax_bits);
  dfasyntax (syntax_bits, match_icase, eolbyte);

  /* For GNU regex compiler we have to pass the patterns separately to detect
     errors like "[\nallo\n]\n".  The patterns here are "[", "allo" and "]"
     GNU regex should have raise a syntax error.  The same for backref, where
     the backref should have been local to each pattern.  */
  p = pattern;
  do
    {
      size_t len;
      sep = memchr (p, '\n', total);
      if (sep)
	{
	  len = sep - p;
	  sep++;
	  total -= (len + 1);
	}
      else
	{
	  len = total;
	  total = 0;
	}

      patterns = realloc (patterns, (pcount + 1) * sizeof (*patterns));
      if (patterns == NULL)
	error (EXIT_TROUBLE, errno, _("memory exhausted"));
      patterns[pcount] = patterns0;

      if ((err = re_compile_pattern (p, len,
				    &(patterns[pcount].regexbuf))) != NULL)
	error (EXIT_TROUBLE, 0, "%s", err);
      pcount++;

      p = sep;
    } while (sep && total != 0);

  /* In the match_words and match_lines cases, we use a different pattern
     for the DFA matcher that will quickly throw out cases that won't work.
     Then if DFA succeeds we do some hairy stuff using the regex matcher
     to decide whether the match should really count. */
  if (match_words || match_lines)
    {
      static char const line_beg_no_bk[] = "^(";
      static char const line_end_no_bk[] = ")$";
      static char const word_beg_no_bk[] = "(^|[^[:alnum:]_])(";
      static char const word_end_no_bk[] = ")([^[:alnum:]_]|$)";
      static char const line_beg_bk[] = "^\\(";
      static char const line_end_bk[] = "\\)$";
      static char const word_beg_bk[] = "\\(^\\|[^[:alnum:]_]\\)\\(";
      static char const word_end_bk[] = "\\)\\([^[:alnum:]_]\\|$\\)";
      int bk = !(syntax_bits & RE_NO_BK_PARENS);
      char *n = xmalloc (sizeof word_beg_bk - 1 + size + sizeof word_end_bk);

      strcpy (n, match_lines ? (bk ? line_beg_bk : line_beg_no_bk)
			     : (bk ? word_beg_bk : word_beg_no_bk));
      total = strlen(n);
      memcpy (n + total, pattern, size);
      total += size;
      strcpy (n + total, match_lines ? (bk ? line_end_bk : line_end_no_bk)
				     : (bk ? word_end_bk : word_end_no_bk));
      total += strlen (n + total);
      pattern = motif = n;
      size = total;
    }
  else
    motif = NULL;

  dfacomp (pattern, size, &dfa, 1);
  kwsmusts ();

  free(motif);
}

size_t
EGexecute (char const *buf, size_t size, size_t *match_size,
	   char const *start_ptr)
{
  char const *buflim, *beg, *end, *match, *best_match, *mb_start;
  char eol = eolbyte;
  int backref, start, len, best_len;
  struct kwsmatch kwsm;
  size_t i, ret_val;
#ifdef MBS_SUPPORT
  if (MB_CUR_MAX > 1)
    {
      if (match_icase)
        {
          /* mbtolower adds a NUL byte at the end.  That will provide
	     space for the sentinel byte dfaexec may add.  */
          char *case_buf = mbtolower (buf, &size);
	  if (start_ptr)
	    start_ptr = case_buf + (start_ptr - buf);
          buf = case_buf;
        }
    }
#endif /* MBS_SUPPORT */

  mb_start = buf;
  buflim = buf + size;

  for (beg = end = buf; end < buflim; beg = end)
    {
      if (!start_ptr)
	{
	  /* We don't care about an exact match.  */
	  if (kwset)
	    {
	      /* Find a possible match using the KWset matcher. */
	      size_t offset = kwsexec (kwset, beg, buflim - beg, &kwsm);
	      if (offset == (size_t) -1)
		goto failure;
	      beg += offset;
	      /* Narrow down to the line containing the candidate, and
		 run it through DFA. */
	      if ((end = memchr(beg, eol, buflim - beg)) != NULL)
	        end++;
              else
                end = buflim;
	      match = beg;
	      while (beg > buf && beg[-1] != eol)
		--beg;
	      if (kwsm.index < kwset_exact_matches)
                {
#ifdef MBS_SUPPORT
                  if (mb_start < beg)
                    mb_start = beg;
                  if (MB_CUR_MAX == 1 || !is_mb_middle (&mb_start, match, buflim))
#endif
                    goto success;
                }
	      if (dfaexec (&dfa, beg, (char *) end, 0, NULL, &backref) == NULL)
		continue;
	    }
	  else
	    {
	      /* No good fixed strings; start with DFA. */
	      char const *next_beg = dfaexec (&dfa, beg, (char *) buflim,
					      0, NULL, &backref);
	      if (next_beg == NULL)
		break;
	      /* Narrow down to the line we've found. */
	      beg = next_beg;
	      if ((end = memchr(beg, eol, buflim - beg)) != NULL)
	        end++;
              else
                end = buflim;
	      while (beg > buf && beg[-1] != eol)
		--beg;
	    }
	  /* Successful, no backreferences encountered! */
	  if (!backref)
	    goto success;
	}
      else
	{
	  /* We are looking for the leftmost (then longest) exact match.
	     We will go through the outer loop only once.  */
	  beg = start_ptr;
	  end = buflim;
	}

      /* If we've made it to this point, this means DFA has seen
	 a probable match, and we need to run it through Regex. */
      best_match = end;
      best_len = 0;
      for (i = 0; i < pcount; i++)
	{
	  patterns[i].regexbuf.not_eol = 0;
	  if (0 <= (start = re_search (&(patterns[i].regexbuf),
				       buf, end - buf - 1,
				       beg - buf, end - beg - 1,
				       &(patterns[i].regs))))
	    {
	      len = patterns[i].regs.end[0] - start;
	      match = buf + start;
	      if (match > best_match)
		continue;
	      if (start_ptr && !match_words)
		goto assess_pattern_match;
	      if ((!match_lines && !match_words)
		  || (match_lines && len == end - beg - 1))
		{
		  match = beg;
		  len = end - beg;
		  goto assess_pattern_match;
		}
	      /* If -w, check if the match aligns with word boundaries.
		 We do this iteratively because:
		 (a) the line may contain more than one occurence of the
		 pattern, and
		 (b) Several alternatives in the pattern might be valid at a
		 given point, and we may need to consider a shorter one to
		 find a word boundary.  */
	      if (match_words)
		while (match <= best_match)
		  {
		    if ((match == buf || !WCHAR ((unsigned char) match[-1]))
			&& (len == end - beg - 1
			    || !WCHAR ((unsigned char) match[len])))
		      goto assess_pattern_match;
		    if (len > 0)
		      {
			/* Try a shorter length anchored at the same place. */
			--len;
			patterns[i].regexbuf.not_eol = 1;
			len = re_match (&(patterns[i].regexbuf),
					buf, match + len - beg, match - buf,
					&(patterns[i].regs));
		      }
		    if (len <= 0)
		      {
			/* Try looking further on. */
			if (match == end - 1)
			  break;
			match++;
			patterns[i].regexbuf.not_eol = 0;
			start = re_search (&(patterns[i].regexbuf),
					   buf, end - buf - 1,
					   match - buf, end - match - 1,
					   &(patterns[i].regs));
			if (start < 0)
			  break;
			len = patterns[i].regs.end[0] - start;
			match = buf + start;
		      }
		  } /* while (match <= best_match) */
	      continue;
	    assess_pattern_match:
	      if (!start_ptr)
		{
		  /* Good enough for a non-exact match.
		     No need to look at further patterns, if any.  */
		  beg = match;
		  goto success_in_len;
		}
	      if (match < best_match || (match == best_match && len > best_len))
		{
		  /* Best exact match:  leftmost, then longest.  */
		  best_match = match;
		  best_len = len;
		}
	    } /* if re_search >= 0 */
	} /* for Regex patterns.  */
	if (best_match < end)
	  {
	    /* We have found an exact match.  We were just
	       waiting for the best one (leftmost then longest).  */
	    beg = best_match;
	    len = best_len;
	    goto success_in_len;
	  }
    } /* for (beg = end ..) */

 failure:
  ret_val = -1;
  goto out;

 success:
  len = end - beg;
 success_in_len:
  *match_size = len;
  ret_val = beg - buf;
 out:
  return ret_val;
}

Spawn 1 instances, now Total 18
Counter: 19
Batcher Size:18
Preprocess the following candidate with CondTester:
Priority 20000
At location src/dfasearch.c:153
--Src File: src/dfasearch.c
Fragment 0:
if ((patterns == ((void *)0)) && !(__abst_hole(patterns, pcount, err, p, total, len, sep, match_words, match_lines, pattern, syntax_bits, match_icase, eolbyte, size, motif)))
    error(EXIT_TROUBLE, (*__errno_location()), dcgettext(((void *)0), "memory exhausted", 5));


CondTester, a patch instance with id 18:
//src_file:src/dfasearch.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); void* memset(void*, int, unsigned long); 
/* dfasearch.c - searching subroutines using dfa and regex for grep.
   Copyright 1992, 1998, 2000, 2007, 2009-2010 Free Software Foundation, Inc.

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 3, or (at your option)
   any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program; if not, write to the Free Software
   Foundation, Inc., 51 Franklin Street - Fifth Floor, Boston, MA
   02110-1301, USA.  */

/* Written August 1992 by Mike Haertel. */

#include <config.h>
#include "search.h"
#include "dfa.h"

/* For -w, we also consider _ to be word constituent.  */
#define WCHAR(C) (ISALNUM(C) || (C) == '_')

/* KWset compiled pattern.  For Ecompile and Gcompile, we compile
   a list of strings, at least one of which is known to occur in
   any string matching the regexp. */
static kwset_t kwset;

/* DFA compiled regexp. */
static struct dfa dfa;

/* The Regex compiled patterns.  */
static struct patterns
{
  /* Regex compiled regexp. */
  struct re_pattern_buffer regexbuf;
  struct re_registers regs; /* This is here on account of a BRAIN-DEAD
			       Q@#%!# library interface in regex.c.  */
} patterns0;

struct patterns *patterns;
size_t pcount;

void
dfaerror (char const *mesg)
{
  error (EXIT_TROUBLE, 0, "%s", mesg);

  /* notreached */
  /* Tell static analyzers that this function does not return.  */
  abort ();
}

/* Number of compiled fixed strings known to exactly match the regexp.
   If kwsexec returns < kwset_exact_matches, then we don't need to
   call the regexp matcher at all. */
static int kwset_exact_matches;

static char const *
kwsincr_case (const char *must)
{
  const char *buf;
  size_t n;

  n = strlen (must);
#ifdef MBS_SUPPORT
  if (match_icase && MB_CUR_MAX > 1)
    buf = mbtolower (must, &n);
  else
#endif
    buf = must;
  return kwsincr (kwset, buf, n);
}

/* If the DFA turns out to have some set of fixed strings one of
   which must occur in the match, then we build a kwset matcher
   to find those strings, and thus quickly filter out impossible
   matches. */
static void
kwsmusts (void)
{
  struct dfamust const *dm;
  char const *err;

  if (dfa.musts)
    {
      kwsinit (&kwset);
      /* First, we compile in the substrings known to be exact
	 matches.  The kwset matcher will return the index
	 of the matching string that it chooses. */
      for (dm = dfa.musts; dm; dm = dm->next)
	{
	  if (!dm->exact)
	    continue;
	  ++kwset_exact_matches;
	  if ((err = kwsincr_case (dm->must)) != NULL)
	    error (EXIT_TROUBLE, 0, "%s", err);
	}
      /* Now, we compile the substrings that will require
	 the use of the regexp matcher.  */
      for (dm = dfa.musts; dm; dm = dm->next)
	{
	  if (dm->exact)
	    continue;
	  if ((err = kwsincr_case (dm->must)) != NULL)
	    error (EXIT_TROUBLE, 0, "%s", err);
	}
      if ((err = kwsprep (kwset)) != NULL)
	error (EXIT_TROUBLE, 0, "%s", err);
    }
}

void
GEAcompile (char const *pattern, size_t size, reg_syntax_t syntax_bits)
{
  const char *err;
  const char *p, *sep;
  size_t total = size;
  char *motif;

  if (match_icase)
    syntax_bits |= RE_ICASE;
  re_set_syntax (syntax_bits);
  dfasyntax (syntax_bits, match_icase, eolbyte);

  /* For GNU regex compiler we have to pass the patterns separately to detect
     errors like "[\nallo\n]\n".  The patterns here are "[", "allo" and "]"
     GNU regex should have raise a syntax error.  The same for backref, where
     the backref should have been local to each pattern.  */
  p = pattern;
  do
    {
      size_t len;
      sep = memchr (p, '\n', total);
      if (sep)
	{
	  len = sep - p;
	  sep++;
	  total -= (len + 1);
	}
      else
	{
	  len = total;
	  total = 0;
	}

      patterns = realloc (patterns, (pcount + 1) * sizeof (*patterns));
      
//Patch 0:
if ((patterns == ((void *)0)) && !(__is_neg(15, &(patterns), sizeof (patterns), &(pcount), sizeof (pcount), &(err), sizeof (err), &(p), sizeof (p), &(total), sizeof (total), &(len), sizeof (len), &(sep), sizeof (sep), &(match_words), sizeof (match_words), &(match_lines), sizeof (match_lines), &(pattern), sizeof (pattern), &(syntax_bits), sizeof (syntax_bits), &(match_icase), sizeof (match_icase), &(eolbyte), sizeof (eolbyte), &(size), sizeof (size), &(motif), sizeof (motif))))
    error(EXIT_TROUBLE, (*__errno_location()), dcgettext(((void *)0), "memory exhausted", 5));

//CodeSeg 1:
      patterns[pcount] = patterns0;

      if ((err = re_compile_pattern (p, len,
				    &(patterns[pcount].regexbuf))) != NULL)
	error (EXIT_TROUBLE, 0, "%s", err);
      pcount++;

      p = sep;
    } while (sep && total != 0);

  /* In the match_words and match_lines cases, we use a different pattern
     for the DFA matcher that will quickly throw out cases that won't work.
     Then if DFA succeeds we do some hairy stuff using the regex matcher
     to decide whether the match should really count. */
  if (match_words || match_lines)
    {
      static char const line_beg_no_bk[] = "^(";
      static char const line_end_no_bk[] = ")$";
      static char const word_beg_no_bk[] = "(^|[^[:alnum:]_])(";
      static char const word_end_no_bk[] = ")([^[:alnum:]_]|$)";
      static char const line_beg_bk[] = "^\\(";
      static char const line_end_bk[] = "\\)$";
      static char const word_beg_bk[] = "\\(^\\|[^[:alnum:]_]\\)\\(";
      static char const word_end_bk[] = "\\)\\([^[:alnum:]_]\\|$\\)";
      int bk = !(syntax_bits & RE_NO_BK_PARENS);
      char *n = xmalloc (sizeof word_beg_bk - 1 + size + sizeof word_end_bk);

      strcpy (n, match_lines ? (bk ? line_beg_bk : line_beg_no_bk)
			     : (bk ? word_beg_bk : word_beg_no_bk));
      total = strlen(n);
      memcpy (n + total, pattern, size);
      total += size;
      strcpy (n + total, match_lines ? (bk ? line_end_bk : line_end_no_bk)
				     : (bk ? word_end_bk : word_end_no_bk));
      total += strlen (n + total);
      pattern = motif = n;
      size = total;
    }
  else
    motif = NULL;

  dfacomp (pattern, size, &dfa, 1);
  kwsmusts ();

  free(motif);
}

size_t
EGexecute (char const *buf, size_t size, size_t *match_size,
	   char const *start_ptr)
{
  char const *buflim, *beg, *end, *match, *best_match, *mb_start;
  char eol = eolbyte;
  int backref, start, len, best_len;
  struct kwsmatch kwsm;
  size_t i, ret_val;
#ifdef MBS_SUPPORT
  if (MB_CUR_MAX > 1)
    {
      if (match_icase)
        {
          /* mbtolower adds a NUL byte at the end.  That will provide
	     space for the sentinel byte dfaexec may add.  */
          char *case_buf = mbtolower (buf, &size);
	  if (start_ptr)
	    start_ptr = case_buf + (start_ptr - buf);
          buf = case_buf;
        }
    }
#endif /* MBS_SUPPORT */

  mb_start = buf;
  buflim = buf + size;

  for (beg = end = buf; end < buflim; beg = end)
    {
      if (!start_ptr)
	{
	  /* We don't care about an exact match.  */
	  if (kwset)
	    {
	      /* Find a possible match using the KWset matcher. */
	      size_t offset = kwsexec (kwset, beg, buflim - beg, &kwsm);
	      if (offset == (size_t) -1)
		goto failure;
	      beg += offset;
	      /* Narrow down to the line containing the candidate, and
		 run it through DFA. */
	      if ((end = memchr(beg, eol, buflim - beg)) != NULL)
	        end++;
              else
                end = buflim;
	      match = beg;
	      while (beg > buf && beg[-1] != eol)
		--beg;
	      if (kwsm.index < kwset_exact_matches)
                {
#ifdef MBS_SUPPORT
                  if (mb_start < beg)
                    mb_start = beg;
                  if (MB_CUR_MAX == 1 || !is_mb_middle (&mb_start, match, buflim))
#endif
                    goto success;
                }
	      if (dfaexec (&dfa, beg, (char *) end, 0, NULL, &backref) == NULL)
		continue;
	    }
	  else
	    {
	      /* No good fixed strings; start with DFA. */
	      char const *next_beg = dfaexec (&dfa, beg, (char *) buflim,
					      0, NULL, &backref);
	      if (next_beg == NULL)
		break;
	      /* Narrow down to the line we've found. */
	      beg = next_beg;
	      if ((end = memchr(beg, eol, buflim - beg)) != NULL)
	        end++;
              else
                end = buflim;
	      while (beg > buf && beg[-1] != eol)
		--beg;
	    }
	  /* Successful, no backreferences encountered! */
	  if (!backref)
	    goto success;
	}
      else
	{
	  /* We are looking for the leftmost (then longest) exact match.
	     We will go through the outer loop only once.  */
	  beg = start_ptr;
	  end = buflim;
	}

      /* If we've made it to this point, this means DFA has seen
	 a probable match, and we need to run it through Regex. */
      best_match = end;
      best_len = 0;
      for (i = 0; i < pcount; i++)
	{
	  patterns[i].regexbuf.not_eol = 0;
	  if (0 <= (start = re_search (&(patterns[i].regexbuf),
				       buf, end - buf - 1,
				       beg - buf, end - beg - 1,
				       &(patterns[i].regs))))
	    {
	      len = patterns[i].regs.end[0] - start;
	      match = buf + start;
	      if (match > best_match)
		continue;
	      if (start_ptr && !match_words)
		goto assess_pattern_match;
	      if ((!match_lines && !match_words)
		  || (match_lines && len == end - beg - 1))
		{
		  match = beg;
		  len = end - beg;
		  goto assess_pattern_match;
		}
	      /* If -w, check if the match aligns with word boundaries.
		 We do this iteratively because:
		 (a) the line may contain more than one occurence of the
		 pattern, and
		 (b) Several alternatives in the pattern might be valid at a
		 given point, and we may need to consider a shorter one to
		 find a word boundary.  */
	      if (match_words)
		while (match <= best_match)
		  {
		    if ((match == buf || !WCHAR ((unsigned char) match[-1]))
			&& (len == end - beg - 1
			    || !WCHAR ((unsigned char) match[len])))
		      goto assess_pattern_match;
		    if (len > 0)
		      {
			/* Try a shorter length anchored at the same place. */
			--len;
			patterns[i].regexbuf.not_eol = 1;
			len = re_match (&(patterns[i].regexbuf),
					buf, match + len - beg, match - buf,
					&(patterns[i].regs));
		      }
		    if (len <= 0)
		      {
			/* Try looking further on. */
			if (match == end - 1)
			  break;
			match++;
			patterns[i].regexbuf.not_eol = 0;
			start = re_search (&(patterns[i].regexbuf),
					   buf, end - buf - 1,
					   match - buf, end - match - 1,
					   &(patterns[i].regs));
			if (start < 0)
			  break;
			len = patterns[i].regs.end[0] - start;
			match = buf + start;
		      }
		  } /* while (match <= best_match) */
	      continue;
	    assess_pattern_match:
	      if (!start_ptr)
		{
		  /* Good enough for a non-exact match.
		     No need to look at further patterns, if any.  */
		  beg = match;
		  goto success_in_len;
		}
	      if (match < best_match || (match == best_match && len > best_len))
		{
		  /* Best exact match:  leftmost, then longest.  */
		  best_match = match;
		  best_len = len;
		}
	    } /* if re_search >= 0 */
	} /* for Regex patterns.  */
	if (best_match < end)
	  {
	    /* We have found an exact match.  We were just
	       waiting for the best one (leftmost then longest).  */
	    beg = best_match;
	    len = best_len;
	    goto success_in_len;
	  }
    } /* for (beg = end ..) */

 failure:
  ret_val = -1;
  goto out;

 success:
  len = end - beg;
 success_in_len:
  *match_size = len;
  ret_val = beg - buf;
 out:
  return ret_val;
}

Spawn 1 instances, now Total 19
Counter: 20
Batcher Size:19
Preprocess the following candidate with CondTester:
Priority 20000
At location src/dfasearch.c:308
--Src File: src/dfasearch.c
Fragment 0:
if (((!match_lines && !match_words) || (match_lines && len == end - beg - 1)) && !(__abst_hole(beg, end, len, match_lines, match_words, match, start_ptr, best_match, buf, start, i, patterns, pcount, best_len, buflim, backref, eol, mb_start, kwset_exact_matches, kwset, ret_val, match_size, size, match_icase, eolbyte))) {
    match = beg;
    len = end - beg;
    goto assess_pattern_match;
}


CondTester, a patch instance with id 19:
//src_file:src/dfasearch.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); void* memset(void*, int, unsigned long); 
/* dfasearch.c - searching subroutines using dfa and regex for grep.
   Copyright 1992, 1998, 2000, 2007, 2009-2010 Free Software Foundation, Inc.

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 3, or (at your option)
   any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program; if not, write to the Free Software
   Foundation, Inc., 51 Franklin Street - Fifth Floor, Boston, MA
   02110-1301, USA.  */

/* Written August 1992 by Mike Haertel. */

#include <config.h>
#include "search.h"
#include "dfa.h"

/* For -w, we also consider _ to be word constituent.  */
#define WCHAR(C) (ISALNUM(C) || (C) == '_')

/* KWset compiled pattern.  For Ecompile and Gcompile, we compile
   a list of strings, at least one of which is known to occur in
   any string matching the regexp. */
static kwset_t kwset;

/* DFA compiled regexp. */
static struct dfa dfa;

/* The Regex compiled patterns.  */
static struct patterns
{
  /* Regex compiled regexp. */
  struct re_pattern_buffer regexbuf;
  struct re_registers regs; /* This is here on account of a BRAIN-DEAD
			       Q@#%!# library interface in regex.c.  */
} patterns0;

struct patterns *patterns;
size_t pcount;

void
dfaerror (char const *mesg)
{
  error (EXIT_TROUBLE, 0, "%s", mesg);

  /* notreached */
  /* Tell static analyzers that this function does not return.  */
  abort ();
}

/* Number of compiled fixed strings known to exactly match the regexp.
   If kwsexec returns < kwset_exact_matches, then we don't need to
   call the regexp matcher at all. */
static int kwset_exact_matches;

static char const *
kwsincr_case (const char *must)
{
  const char *buf;
  size_t n;

  n = strlen (must);
#ifdef MBS_SUPPORT
  if (match_icase && MB_CUR_MAX > 1)
    buf = mbtolower (must, &n);
  else
#endif
    buf = must;
  return kwsincr (kwset, buf, n);
}

/* If the DFA turns out to have some set of fixed strings one of
   which must occur in the match, then we build a kwset matcher
   to find those strings, and thus quickly filter out impossible
   matches. */
static void
kwsmusts (void)
{
  struct dfamust const *dm;
  char const *err;

  if (dfa.musts)
    {
      kwsinit (&kwset);
      /* First, we compile in the substrings known to be exact
	 matches.  The kwset matcher will return the index
	 of the matching string that it chooses. */
      for (dm = dfa.musts; dm; dm = dm->next)
	{
	  if (!dm->exact)
	    continue;
	  ++kwset_exact_matches;
	  if ((err = kwsincr_case (dm->must)) != NULL)
	    error (EXIT_TROUBLE, 0, "%s", err);
	}
      /* Now, we compile the substrings that will require
	 the use of the regexp matcher.  */
      for (dm = dfa.musts; dm; dm = dm->next)
	{
	  if (dm->exact)
	    continue;
	  if ((err = kwsincr_case (dm->must)) != NULL)
	    error (EXIT_TROUBLE, 0, "%s", err);
	}
      if ((err = kwsprep (kwset)) != NULL)
	error (EXIT_TROUBLE, 0, "%s", err);
    }
}

void
GEAcompile (char const *pattern, size_t size, reg_syntax_t syntax_bits)
{
  const char *err;
  const char *p, *sep;
  size_t total = size;
  char *motif;

  if (match_icase)
    syntax_bits |= RE_ICASE;
  re_set_syntax (syntax_bits);
  dfasyntax (syntax_bits, match_icase, eolbyte);

  /* For GNU regex compiler we have to pass the patterns separately to detect
     errors like "[\nallo\n]\n".  The patterns here are "[", "allo" and "]"
     GNU regex should have raise a syntax error.  The same for backref, where
     the backref should have been local to each pattern.  */
  p = pattern;
  do
    {
      size_t len;
      sep = memchr (p, '\n', total);
      if (sep)
	{
	  len = sep - p;
	  sep++;
	  total -= (len + 1);
	}
      else
	{
	  len = total;
	  total = 0;
	}

      patterns = realloc (patterns, (pcount + 1) * sizeof (*patterns));
      if (patterns == NULL)
	error (EXIT_TROUBLE, errno, _("memory exhausted"));
      patterns[pcount] = patterns0;

      if ((err = re_compile_pattern (p, len,
				    &(patterns[pcount].regexbuf))) != NULL)
	error (EXIT_TROUBLE, 0, "%s", err);
      pcount++;

      p = sep;
    } while (sep && total != 0);

  /* In the match_words and match_lines cases, we use a different pattern
     for the DFA matcher that will quickly throw out cases that won't work.
     Then if DFA succeeds we do some hairy stuff using the regex matcher
     to decide whether the match should really count. */
  if (match_words || match_lines)
    {
      static char const line_beg_no_bk[] = "^(";
      static char const line_end_no_bk[] = ")$";
      static char const word_beg_no_bk[] = "(^|[^[:alnum:]_])(";
      static char const word_end_no_bk[] = ")([^[:alnum:]_]|$)";
      static char const line_beg_bk[] = "^\\(";
      static char const line_end_bk[] = "\\)$";
      static char const word_beg_bk[] = "\\(^\\|[^[:alnum:]_]\\)\\(";
      static char const word_end_bk[] = "\\)\\([^[:alnum:]_]\\|$\\)";
      int bk = !(syntax_bits & RE_NO_BK_PARENS);
      char *n = xmalloc (sizeof word_beg_bk - 1 + size + sizeof word_end_bk);

      strcpy (n, match_lines ? (bk ? line_beg_bk : line_beg_no_bk)
			     : (bk ? word_beg_bk : word_beg_no_bk));
      total = strlen(n);
      memcpy (n + total, pattern, size);
      total += size;
      strcpy (n + total, match_lines ? (bk ? line_end_bk : line_end_no_bk)
				     : (bk ? word_end_bk : word_end_no_bk));
      total += strlen (n + total);
      pattern = motif = n;
      size = total;
    }
  else
    motif = NULL;

  dfacomp (pattern, size, &dfa, 1);
  kwsmusts ();

  free(motif);
}

size_t
EGexecute (char const *buf, size_t size, size_t *match_size,
	   char const *start_ptr)
{
  char const *buflim, *beg, *end, *match, *best_match, *mb_start;
  char eol = eolbyte;
  int backref, start, len, best_len;
  struct kwsmatch kwsm;
  size_t i, ret_val;
#ifdef MBS_SUPPORT
  if (MB_CUR_MAX > 1)
    {
      if (match_icase)
        {
          /* mbtolower adds a NUL byte at the end.  That will provide
	     space for the sentinel byte dfaexec may add.  */
          char *case_buf = mbtolower (buf, &size);
	  if (start_ptr)
	    start_ptr = case_buf + (start_ptr - buf);
          buf = case_buf;
        }
    }
#endif /* MBS_SUPPORT */

  mb_start = buf;
  buflim = buf + size;

  for (beg = end = buf; end < buflim; beg = end)
    {
      if (!start_ptr)
	{
	  /* We don't care about an exact match.  */
	  if (kwset)
	    {
	      /* Find a possible match using the KWset matcher. */
	      size_t offset = kwsexec (kwset, beg, buflim - beg, &kwsm);
	      if (offset == (size_t) -1)
		goto failure;
	      beg += offset;
	      /* Narrow down to the line containing the candidate, and
		 run it through DFA. */
	      if ((end = memchr(beg, eol, buflim - beg)) != NULL)
	        end++;
              else
                end = buflim;
	      match = beg;
	      while (beg > buf && beg[-1] != eol)
		--beg;
	      if (kwsm.index < kwset_exact_matches)
                {
#ifdef MBS_SUPPORT
                  if (mb_start < beg)
                    mb_start = beg;
                  if (MB_CUR_MAX == 1 || !is_mb_middle (&mb_start, match, buflim))
#endif
                    goto success;
                }
	      if (dfaexec (&dfa, beg, (char *) end, 0, NULL, &backref) == NULL)
		continue;
	    }
	  else
	    {
	      /* No good fixed strings; start with DFA. */
	      char const *next_beg = dfaexec (&dfa, beg, (char *) buflim,
					      0, NULL, &backref);
	      if (next_beg == NULL)
		break;
	      /* Narrow down to the line we've found. */
	      beg = next_beg;
	      if ((end = memchr(beg, eol, buflim - beg)) != NULL)
	        end++;
              else
                end = buflim;
	      while (beg > buf && beg[-1] != eol)
		--beg;
	    }
	  /* Successful, no backreferences encountered! */
	  if (!backref)
	    goto success;
	}
      else
	{
	  /* We are looking for the leftmost (then longest) exact match.
	     We will go through the outer loop only once.  */
	  beg = start_ptr;
	  end = buflim;
	}

      /* If we've made it to this point, this means DFA has seen
	 a probable match, and we need to run it through Regex. */
      best_match = end;
      best_len = 0;
      for (i = 0; i < pcount; i++)
	{
	  patterns[i].regexbuf.not_eol = 0;
	  if (0 <= (start = re_search (&(patterns[i].regexbuf),
				       buf, end - buf - 1,
				       beg - buf, end - beg - 1,
				       &(patterns[i].regs))))
	    {
	      len = patterns[i].regs.end[0] - start;
	      match = buf + start;
	      if (match > best_match)
		continue;
	      if (start_ptr && !match_words)
		goto assess_pattern_match;
	      
//Patch 0:
if (((!match_lines && !match_words) || (match_lines && len == end - beg - 1)) && !(__is_neg(25, &(beg), sizeof (beg), &(end), sizeof (end), &(len), sizeof (len), &(match_lines), sizeof (match_lines), &(match_words), sizeof (match_words), &(match), sizeof (match), &(start_ptr), sizeof (start_ptr), &(best_match), sizeof (best_match), &(buf), sizeof (buf), &(start), sizeof (start), &(i), sizeof (i), &(patterns), sizeof (patterns), &(pcount), sizeof (pcount), &(best_len), sizeof (best_len), &(buflim), sizeof (buflim), &(backref), sizeof (backref), &(eol), sizeof (eol), &(mb_start), sizeof (mb_start), &(kwset_exact_matches), sizeof (kwset_exact_matches), &(kwset), sizeof (kwset), &(ret_val), sizeof (ret_val), &(match_size), sizeof (match_size), &(size), sizeof (size), &(match_icase), sizeof (match_icase), &(eolbyte), sizeof (eolbyte)))) {
    match = beg;
    len = end - beg;
    goto assess_pattern_match;
}

//CodeSeg 1:
	      /* If -w, check if the match aligns with word boundaries.
		 We do this iteratively because:
		 (a) the line may contain more than one occurence of the
		 pattern, and
		 (b) Several alternatives in the pattern might be valid at a
		 given point, and we may need to consider a shorter one to
		 find a word boundary.  */
	      if (match_words)
		while (match <= best_match)
		  {
		    if ((match == buf || !WCHAR ((unsigned char) match[-1]))
			&& (len == end - beg - 1
			    || !WCHAR ((unsigned char) match[len])))
		      goto assess_pattern_match;
		    if (len > 0)
		      {
			/* Try a shorter length anchored at the same place. */
			--len;
			patterns[i].regexbuf.not_eol = 1;
			len = re_match (&(patterns[i].regexbuf),
					buf, match + len - beg, match - buf,
					&(patterns[i].regs));
		      }
		    if (len <= 0)
		      {
			/* Try looking further on. */
			if (match == end - 1)
			  break;
			match++;
			patterns[i].regexbuf.not_eol = 0;
			start = re_search (&(patterns[i].regexbuf),
					   buf, end - buf - 1,
					   match - buf, end - match - 1,
					   &(patterns[i].regs));
			if (start < 0)
			  break;
			len = patterns[i].regs.end[0] - start;
			match = buf + start;
		      }
		  } /* while (match <= best_match) */
	      continue;
	    assess_pattern_match:
	      if (!start_ptr)
		{
		  /* Good enough for a non-exact match.
		     No need to look at further patterns, if any.  */
		  beg = match;
		  goto success_in_len;
		}
	      if (match < best_match || (match == best_match && len > best_len))
		{
		  /* Best exact match:  leftmost, then longest.  */
		  best_match = match;
		  best_len = len;
		}
	    } /* if re_search >= 0 */
	} /* for Regex patterns.  */
	if (best_match < end)
	  {
	    /* We have found an exact match.  We were just
	       waiting for the best one (leftmost then longest).  */
	    beg = best_match;
	    len = best_len;
	    goto success_in_len;
	  }
    } /* for (beg = end ..) */

 failure:
  ret_val = -1;
  goto out;

 success:
  len = end - beg;
 success_in_len:
  *match_size = len;
  ret_val = beg - buf;
 out:
  return ret_val;
}

Spawn 1 instances, now Total 20
Counter: 21
Batcher Size:20
Preprocess the following candidate with CondTester:
Priority 20000
At location src/dfasearch.c:308
--Src File: src/dfasearch.c
Fragment 0:
if (((!match_lines && !match_words) || (match_lines && len == end - beg - 1)) || (__abst_hole(beg, end, len, match_lines, match_words, match, start_ptr, best_match, buf, start, i, patterns, pcount, best_len, buflim, backref, eol, mb_start, kwset_exact_matches, kwset, ret_val, match_size, size, match_icase, eolbyte))) {
    match = beg;
    len = end - beg;
    goto assess_pattern_match;
}


CondTester, a patch instance with id 20:
//src_file:src/dfasearch.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); void* memset(void*, int, unsigned long); 
/* dfasearch.c - searching subroutines using dfa and regex for grep.
   Copyright 1992, 1998, 2000, 2007, 2009-2010 Free Software Foundation, Inc.

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 3, or (at your option)
   any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program; if not, write to the Free Software
   Foundation, Inc., 51 Franklin Street - Fifth Floor, Boston, MA
   02110-1301, USA.  */

/* Written August 1992 by Mike Haertel. */

#include <config.h>
#include "search.h"
#include "dfa.h"

/* For -w, we also consider _ to be word constituent.  */
#define WCHAR(C) (ISALNUM(C) || (C) == '_')

/* KWset compiled pattern.  For Ecompile and Gcompile, we compile
   a list of strings, at least one of which is known to occur in
   any string matching the regexp. */
static kwset_t kwset;

/* DFA compiled regexp. */
static struct dfa dfa;

/* The Regex compiled patterns.  */
static struct patterns
{
  /* Regex compiled regexp. */
  struct re_pattern_buffer regexbuf;
  struct re_registers regs; /* This is here on account of a BRAIN-DEAD
			       Q@#%!# library interface in regex.c.  */
} patterns0;

struct patterns *patterns;
size_t pcount;

void
dfaerror (char const *mesg)
{
  error (EXIT_TROUBLE, 0, "%s", mesg);

  /* notreached */
  /* Tell static analyzers that this function does not return.  */
  abort ();
}

/* Number of compiled fixed strings known to exactly match the regexp.
   If kwsexec returns < kwset_exact_matches, then we don't need to
   call the regexp matcher at all. */
static int kwset_exact_matches;

static char const *
kwsincr_case (const char *must)
{
  const char *buf;
  size_t n;

  n = strlen (must);
#ifdef MBS_SUPPORT
  if (match_icase && MB_CUR_MAX > 1)
    buf = mbtolower (must, &n);
  else
#endif
    buf = must;
  return kwsincr (kwset, buf, n);
}

/* If the DFA turns out to have some set of fixed strings one of
   which must occur in the match, then we build a kwset matcher
   to find those strings, and thus quickly filter out impossible
   matches. */
static void
kwsmusts (void)
{
  struct dfamust const *dm;
  char const *err;

  if (dfa.musts)
    {
      kwsinit (&kwset);
      /* First, we compile in the substrings known to be exact
	 matches.  The kwset matcher will return the index
	 of the matching string that it chooses. */
      for (dm = dfa.musts; dm; dm = dm->next)
	{
	  if (!dm->exact)
	    continue;
	  ++kwset_exact_matches;
	  if ((err = kwsincr_case (dm->must)) != NULL)
	    error (EXIT_TROUBLE, 0, "%s", err);
	}
      /* Now, we compile the substrings that will require
	 the use of the regexp matcher.  */
      for (dm = dfa.musts; dm; dm = dm->next)
	{
	  if (dm->exact)
	    continue;
	  if ((err = kwsincr_case (dm->must)) != NULL)
	    error (EXIT_TROUBLE, 0, "%s", err);
	}
      if ((err = kwsprep (kwset)) != NULL)
	error (EXIT_TROUBLE, 0, "%s", err);
    }
}

void
GEAcompile (char const *pattern, size_t size, reg_syntax_t syntax_bits)
{
  const char *err;
  const char *p, *sep;
  size_t total = size;
  char *motif;

  if (match_icase)
    syntax_bits |= RE_ICASE;
  re_set_syntax (syntax_bits);
  dfasyntax (syntax_bits, match_icase, eolbyte);

  /* For GNU regex compiler we have to pass the patterns separately to detect
     errors like "[\nallo\n]\n".  The patterns here are "[", "allo" and "]"
     GNU regex should have raise a syntax error.  The same for backref, where
     the backref should have been local to each pattern.  */
  p = pattern;
  do
    {
      size_t len;
      sep = memchr (p, '\n', total);
      if (sep)
	{
	  len = sep - p;
	  sep++;
	  total -= (len + 1);
	}
      else
	{
	  len = total;
	  total = 0;
	}

      patterns = realloc (patterns, (pcount + 1) * sizeof (*patterns));
      if (patterns == NULL)
	error (EXIT_TROUBLE, errno, _("memory exhausted"));
      patterns[pcount] = patterns0;

      if ((err = re_compile_pattern (p, len,
				    &(patterns[pcount].regexbuf))) != NULL)
	error (EXIT_TROUBLE, 0, "%s", err);
      pcount++;

      p = sep;
    } while (sep && total != 0);

  /* In the match_words and match_lines cases, we use a different pattern
     for the DFA matcher that will quickly throw out cases that won't work.
     Then if DFA succeeds we do some hairy stuff using the regex matcher
     to decide whether the match should really count. */
  if (match_words || match_lines)
    {
      static char const line_beg_no_bk[] = "^(";
      static char const line_end_no_bk[] = ")$";
      static char const word_beg_no_bk[] = "(^|[^[:alnum:]_])(";
      static char const word_end_no_bk[] = ")([^[:alnum:]_]|$)";
      static char const line_beg_bk[] = "^\\(";
      static char const line_end_bk[] = "\\)$";
      static char const word_beg_bk[] = "\\(^\\|[^[:alnum:]_]\\)\\(";
      static char const word_end_bk[] = "\\)\\([^[:alnum:]_]\\|$\\)";
      int bk = !(syntax_bits & RE_NO_BK_PARENS);
      char *n = xmalloc (sizeof word_beg_bk - 1 + size + sizeof word_end_bk);

      strcpy (n, match_lines ? (bk ? line_beg_bk : line_beg_no_bk)
			     : (bk ? word_beg_bk : word_beg_no_bk));
      total = strlen(n);
      memcpy (n + total, pattern, size);
      total += size;
      strcpy (n + total, match_lines ? (bk ? line_end_bk : line_end_no_bk)
				     : (bk ? word_end_bk : word_end_no_bk));
      total += strlen (n + total);
      pattern = motif = n;
      size = total;
    }
  else
    motif = NULL;

  dfacomp (pattern, size, &dfa, 1);
  kwsmusts ();

  free(motif);
}

size_t
EGexecute (char const *buf, size_t size, size_t *match_size,
	   char const *start_ptr)
{
  char const *buflim, *beg, *end, *match, *best_match, *mb_start;
  char eol = eolbyte;
  int backref, start, len, best_len;
  struct kwsmatch kwsm;
  size_t i, ret_val;
#ifdef MBS_SUPPORT
  if (MB_CUR_MAX > 1)
    {
      if (match_icase)
        {
          /* mbtolower adds a NUL byte at the end.  That will provide
	     space for the sentinel byte dfaexec may add.  */
          char *case_buf = mbtolower (buf, &size);
	  if (start_ptr)
	    start_ptr = case_buf + (start_ptr - buf);
          buf = case_buf;
        }
    }
#endif /* MBS_SUPPORT */

  mb_start = buf;
  buflim = buf + size;

  for (beg = end = buf; end < buflim; beg = end)
    {
      if (!start_ptr)
	{
	  /* We don't care about an exact match.  */
	  if (kwset)
	    {
	      /* Find a possible match using the KWset matcher. */
	      size_t offset = kwsexec (kwset, beg, buflim - beg, &kwsm);
	      if (offset == (size_t) -1)
		goto failure;
	      beg += offset;
	      /* Narrow down to the line containing the candidate, and
		 run it through DFA. */
	      if ((end = memchr(beg, eol, buflim - beg)) != NULL)
	        end++;
              else
                end = buflim;
	      match = beg;
	      while (beg > buf && beg[-1] != eol)
		--beg;
	      if (kwsm.index < kwset_exact_matches)
                {
#ifdef MBS_SUPPORT
                  if (mb_start < beg)
                    mb_start = beg;
                  if (MB_CUR_MAX == 1 || !is_mb_middle (&mb_start, match, buflim))
#endif
                    goto success;
                }
	      if (dfaexec (&dfa, beg, (char *) end, 0, NULL, &backref) == NULL)
		continue;
	    }
	  else
	    {
	      /* No good fixed strings; start with DFA. */
	      char const *next_beg = dfaexec (&dfa, beg, (char *) buflim,
					      0, NULL, &backref);
	      if (next_beg == NULL)
		break;
	      /* Narrow down to the line we've found. */
	      beg = next_beg;
	      if ((end = memchr(beg, eol, buflim - beg)) != NULL)
	        end++;
              else
                end = buflim;
	      while (beg > buf && beg[-1] != eol)
		--beg;
	    }
	  /* Successful, no backreferences encountered! */
	  if (!backref)
	    goto success;
	}
      else
	{
	  /* We are looking for the leftmost (then longest) exact match.
	     We will go through the outer loop only once.  */
	  beg = start_ptr;
	  end = buflim;
	}

      /* If we've made it to this point, this means DFA has seen
	 a probable match, and we need to run it through Regex. */
      best_match = end;
      best_len = 0;
      for (i = 0; i < pcount; i++)
	{
	  patterns[i].regexbuf.not_eol = 0;
	  if (0 <= (start = re_search (&(patterns[i].regexbuf),
				       buf, end - buf - 1,
				       beg - buf, end - beg - 1,
				       &(patterns[i].regs))))
	    {
	      len = patterns[i].regs.end[0] - start;
	      match = buf + start;
	      if (match > best_match)
		continue;
	      if (start_ptr && !match_words)
		goto assess_pattern_match;
	      
//Patch 0:
if (((!match_lines && !match_words) || (match_lines && len == end - beg - 1)) || (__is_neg(25, &(beg), sizeof (beg), &(end), sizeof (end), &(len), sizeof (len), &(match_lines), sizeof (match_lines), &(match_words), sizeof (match_words), &(match), sizeof (match), &(start_ptr), sizeof (start_ptr), &(best_match), sizeof (best_match), &(buf), sizeof (buf), &(start), sizeof (start), &(i), sizeof (i), &(patterns), sizeof (patterns), &(pcount), sizeof (pcount), &(best_len), sizeof (best_len), &(buflim), sizeof (buflim), &(backref), sizeof (backref), &(eol), sizeof (eol), &(mb_start), sizeof (mb_start), &(kwset_exact_matches), sizeof (kwset_exact_matches), &(kwset), sizeof (kwset), &(ret_val), sizeof (ret_val), &(match_size), sizeof (match_size), &(size), sizeof (size), &(match_icase), sizeof (match_icase), &(eolbyte), sizeof (eolbyte)))) {
    match = beg;
    len = end - beg;
    goto assess_pattern_match;
}

//CodeSeg 1:
	      /* If -w, check if the match aligns with word boundaries.
		 We do this iteratively because:
		 (a) the line may contain more than one occurence of the
		 pattern, and
		 (b) Several alternatives in the pattern might be valid at a
		 given point, and we may need to consider a shorter one to
		 find a word boundary.  */
	      if (match_words)
		while (match <= best_match)
		  {
		    if ((match == buf || !WCHAR ((unsigned char) match[-1]))
			&& (len == end - beg - 1
			    || !WCHAR ((unsigned char) match[len])))
		      goto assess_pattern_match;
		    if (len > 0)
		      {
			/* Try a shorter length anchored at the same place. */
			--len;
			patterns[i].regexbuf.not_eol = 1;
			len = re_match (&(patterns[i].regexbuf),
					buf, match + len - beg, match - buf,
					&(patterns[i].regs));
		      }
		    if (len <= 0)
		      {
			/* Try looking further on. */
			if (match == end - 1)
			  break;
			match++;
			patterns[i].regexbuf.not_eol = 0;
			start = re_search (&(patterns[i].regexbuf),
					   buf, end - buf - 1,
					   match - buf, end - match - 1,
					   &(patterns[i].regs));
			if (start < 0)
			  break;
			len = patterns[i].regs.end[0] - start;
			match = buf + start;
		      }
		  } /* while (match <= best_match) */
	      continue;
	    assess_pattern_match:
	      if (!start_ptr)
		{
		  /* Good enough for a non-exact match.
		     No need to look at further patterns, if any.  */
		  beg = match;
		  goto success_in_len;
		}
	      if (match < best_match || (match == best_match && len > best_len))
		{
		  /* Best exact match:  leftmost, then longest.  */
		  best_match = match;
		  best_len = len;
		}
	    } /* if re_search >= 0 */
	} /* for Regex patterns.  */
	if (best_match < end)
	  {
	    /* We have found an exact match.  We were just
	       waiting for the best one (leftmost then longest).  */
	    beg = best_match;
	    len = best_len;
	    goto success_in_len;
	  }
    } /* for (beg = end ..) */

 failure:
  ret_val = -1;
  goto out;

 success:
  len = end - beg;
 success_in_len:
  *match_size = len;
  ret_val = beg - buf;
 out:
  return ret_val;
}

Spawn 1 instances, now Total 21
Counter: 22
Batcher Size:21
Preprocess the following candidate with CondTester:
Priority 20000
At location src/dfasearch.c:153
--Src File: src/dfasearch.c
Fragment 0:
if ((patterns == ((void *)0)) || (__abst_hole(patterns, pcount, err, p, total, len, sep, match_words, match_lines, pattern, syntax_bits, match_icase, eolbyte, size, motif)))
    error(EXIT_TROUBLE, (*__errno_location()), dcgettext(((void *)0), "memory exhausted", 5));


CondTester, a patch instance with id 21:
//src_file:src/dfasearch.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); void* memset(void*, int, unsigned long); 
/* dfasearch.c - searching subroutines using dfa and regex for grep.
   Copyright 1992, 1998, 2000, 2007, 2009-2010 Free Software Foundation, Inc.

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 3, or (at your option)
   any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program; if not, write to the Free Software
   Foundation, Inc., 51 Franklin Street - Fifth Floor, Boston, MA
   02110-1301, USA.  */

/* Written August 1992 by Mike Haertel. */

#include <config.h>
#include "search.h"
#include "dfa.h"

/* For -w, we also consider _ to be word constituent.  */
#define WCHAR(C) (ISALNUM(C) || (C) == '_')

/* KWset compiled pattern.  For Ecompile and Gcompile, we compile
   a list of strings, at least one of which is known to occur in
   any string matching the regexp. */
static kwset_t kwset;

/* DFA compiled regexp. */
static struct dfa dfa;

/* The Regex compiled patterns.  */
static struct patterns
{
  /* Regex compiled regexp. */
  struct re_pattern_buffer regexbuf;
  struct re_registers regs; /* This is here on account of a BRAIN-DEAD
			       Q@#%!# library interface in regex.c.  */
} patterns0;

struct patterns *patterns;
size_t pcount;

void
dfaerror (char const *mesg)
{
  error (EXIT_TROUBLE, 0, "%s", mesg);

  /* notreached */
  /* Tell static analyzers that this function does not return.  */
  abort ();
}

/* Number of compiled fixed strings known to exactly match the regexp.
   If kwsexec returns < kwset_exact_matches, then we don't need to
   call the regexp matcher at all. */
static int kwset_exact_matches;

static char const *
kwsincr_case (const char *must)
{
  const char *buf;
  size_t n;

  n = strlen (must);
#ifdef MBS_SUPPORT
  if (match_icase && MB_CUR_MAX > 1)
    buf = mbtolower (must, &n);
  else
#endif
    buf = must;
  return kwsincr (kwset, buf, n);
}

/* If the DFA turns out to have some set of fixed strings one of
   which must occur in the match, then we build a kwset matcher
   to find those strings, and thus quickly filter out impossible
   matches. */
static void
kwsmusts (void)
{
  struct dfamust const *dm;
  char const *err;

  if (dfa.musts)
    {
      kwsinit (&kwset);
      /* First, we compile in the substrings known to be exact
	 matches.  The kwset matcher will return the index
	 of the matching string that it chooses. */
      for (dm = dfa.musts; dm; dm = dm->next)
	{
	  if (!dm->exact)
	    continue;
	  ++kwset_exact_matches;
	  if ((err = kwsincr_case (dm->must)) != NULL)
	    error (EXIT_TROUBLE, 0, "%s", err);
	}
      /* Now, we compile the substrings that will require
	 the use of the regexp matcher.  */
      for (dm = dfa.musts; dm; dm = dm->next)
	{
	  if (dm->exact)
	    continue;
	  if ((err = kwsincr_case (dm->must)) != NULL)
	    error (EXIT_TROUBLE, 0, "%s", err);
	}
      if ((err = kwsprep (kwset)) != NULL)
	error (EXIT_TROUBLE, 0, "%s", err);
    }
}

void
GEAcompile (char const *pattern, size_t size, reg_syntax_t syntax_bits)
{
  const char *err;
  const char *p, *sep;
  size_t total = size;
  char *motif;

  if (match_icase)
    syntax_bits |= RE_ICASE;
  re_set_syntax (syntax_bits);
  dfasyntax (syntax_bits, match_icase, eolbyte);

  /* For GNU regex compiler we have to pass the patterns separately to detect
     errors like "[\nallo\n]\n".  The patterns here are "[", "allo" and "]"
     GNU regex should have raise a syntax error.  The same for backref, where
     the backref should have been local to each pattern.  */
  p = pattern;
  do
    {
      size_t len;
      sep = memchr (p, '\n', total);
      if (sep)
	{
	  len = sep - p;
	  sep++;
	  total -= (len + 1);
	}
      else
	{
	  len = total;
	  total = 0;
	}

      patterns = realloc (patterns, (pcount + 1) * sizeof (*patterns));
      
//Patch 0:
if ((patterns == ((void *)0)) || (__is_neg(15, &(patterns), sizeof (patterns), &(pcount), sizeof (pcount), &(err), sizeof (err), &(p), sizeof (p), &(total), sizeof (total), &(len), sizeof (len), &(sep), sizeof (sep), &(match_words), sizeof (match_words), &(match_lines), sizeof (match_lines), &(pattern), sizeof (pattern), &(syntax_bits), sizeof (syntax_bits), &(match_icase), sizeof (match_icase), &(eolbyte), sizeof (eolbyte), &(size), sizeof (size), &(motif), sizeof (motif))))
    error(EXIT_TROUBLE, (*__errno_location()), dcgettext(((void *)0), "memory exhausted", 5));

//CodeSeg 1:
      patterns[pcount] = patterns0;

      if ((err = re_compile_pattern (p, len,
				    &(patterns[pcount].regexbuf))) != NULL)
	error (EXIT_TROUBLE, 0, "%s", err);
      pcount++;

      p = sep;
    } while (sep && total != 0);

  /* In the match_words and match_lines cases, we use a different pattern
     for the DFA matcher that will quickly throw out cases that won't work.
     Then if DFA succeeds we do some hairy stuff using the regex matcher
     to decide whether the match should really count. */
  if (match_words || match_lines)
    {
      static char const line_beg_no_bk[] = "^(";
      static char const line_end_no_bk[] = ")$";
      static char const word_beg_no_bk[] = "(^|[^[:alnum:]_])(";
      static char const word_end_no_bk[] = ")([^[:alnum:]_]|$)";
      static char const line_beg_bk[] = "^\\(";
      static char const line_end_bk[] = "\\)$";
      static char const word_beg_bk[] = "\\(^\\|[^[:alnum:]_]\\)\\(";
      static char const word_end_bk[] = "\\)\\([^[:alnum:]_]\\|$\\)";
      int bk = !(syntax_bits & RE_NO_BK_PARENS);
      char *n = xmalloc (sizeof word_beg_bk - 1 + size + sizeof word_end_bk);

      strcpy (n, match_lines ? (bk ? line_beg_bk : line_beg_no_bk)
			     : (bk ? word_beg_bk : word_beg_no_bk));
      total = strlen(n);
      memcpy (n + total, pattern, size);
      total += size;
      strcpy (n + total, match_lines ? (bk ? line_end_bk : line_end_no_bk)
				     : (bk ? word_end_bk : word_end_no_bk));
      total += strlen (n + total);
      pattern = motif = n;
      size = total;
    }
  else
    motif = NULL;

  dfacomp (pattern, size, &dfa, 1);
  kwsmusts ();

  free(motif);
}

size_t
EGexecute (char const *buf, size_t size, size_t *match_size,
	   char const *start_ptr)
{
  char const *buflim, *beg, *end, *match, *best_match, *mb_start;
  char eol = eolbyte;
  int backref, start, len, best_len;
  struct kwsmatch kwsm;
  size_t i, ret_val;
#ifdef MBS_SUPPORT
  if (MB_CUR_MAX > 1)
    {
      if (match_icase)
        {
          /* mbtolower adds a NUL byte at the end.  That will provide
	     space for the sentinel byte dfaexec may add.  */
          char *case_buf = mbtolower (buf, &size);
	  if (start_ptr)
	    start_ptr = case_buf + (start_ptr - buf);
          buf = case_buf;
        }
    }
#endif /* MBS_SUPPORT */

  mb_start = buf;
  buflim = buf + size;

  for (beg = end = buf; end < buflim; beg = end)
    {
      if (!start_ptr)
	{
	  /* We don't care about an exact match.  */
	  if (kwset)
	    {
	      /* Find a possible match using the KWset matcher. */
	      size_t offset = kwsexec (kwset, beg, buflim - beg, &kwsm);
	      if (offset == (size_t) -1)
		goto failure;
	      beg += offset;
	      /* Narrow down to the line containing the candidate, and
		 run it through DFA. */
	      if ((end = memchr(beg, eol, buflim - beg)) != NULL)
	        end++;
              else
                end = buflim;
	      match = beg;
	      while (beg > buf && beg[-1] != eol)
		--beg;
	      if (kwsm.index < kwset_exact_matches)
                {
#ifdef MBS_SUPPORT
                  if (mb_start < beg)
                    mb_start = beg;
                  if (MB_CUR_MAX == 1 || !is_mb_middle (&mb_start, match, buflim))
#endif
                    goto success;
                }
	      if (dfaexec (&dfa, beg, (char *) end, 0, NULL, &backref) == NULL)
		continue;
	    }
	  else
	    {
	      /* No good fixed strings; start with DFA. */
	      char const *next_beg = dfaexec (&dfa, beg, (char *) buflim,
					      0, NULL, &backref);
	      if (next_beg == NULL)
		break;
	      /* Narrow down to the line we've found. */
	      beg = next_beg;
	      if ((end = memchr(beg, eol, buflim - beg)) != NULL)
	        end++;
              else
                end = buflim;
	      while (beg > buf && beg[-1] != eol)
		--beg;
	    }
	  /* Successful, no backreferences encountered! */
	  if (!backref)
	    goto success;
	}
      else
	{
	  /* We are looking for the leftmost (then longest) exact match.
	     We will go through the outer loop only once.  */
	  beg = start_ptr;
	  end = buflim;
	}

      /* If we've made it to this point, this means DFA has seen
	 a probable match, and we need to run it through Regex. */
      best_match = end;
      best_len = 0;
      for (i = 0; i < pcount; i++)
	{
	  patterns[i].regexbuf.not_eol = 0;
	  if (0 <= (start = re_search (&(patterns[i].regexbuf),
				       buf, end - buf - 1,
				       beg - buf, end - beg - 1,
				       &(patterns[i].regs))))
	    {
	      len = patterns[i].regs.end[0] - start;
	      match = buf + start;
	      if (match > best_match)
		continue;
	      if (start_ptr && !match_words)
		goto assess_pattern_match;
	      if ((!match_lines && !match_words)
		  || (match_lines && len == end - beg - 1))
		{
		  match = beg;
		  len = end - beg;
		  goto assess_pattern_match;
		}
	      /* If -w, check if the match aligns with word boundaries.
		 We do this iteratively because:
		 (a) the line may contain more than one occurence of the
		 pattern, and
		 (b) Several alternatives in the pattern might be valid at a
		 given point, and we may need to consider a shorter one to
		 find a word boundary.  */
	      if (match_words)
		while (match <= best_match)
		  {
		    if ((match == buf || !WCHAR ((unsigned char) match[-1]))
			&& (len == end - beg - 1
			    || !WCHAR ((unsigned char) match[len])))
		      goto assess_pattern_match;
		    if (len > 0)
		      {
			/* Try a shorter length anchored at the same place. */
			--len;
			patterns[i].regexbuf.not_eol = 1;
			len = re_match (&(patterns[i].regexbuf),
					buf, match + len - beg, match - buf,
					&(patterns[i].regs));
		      }
		    if (len <= 0)
		      {
			/* Try looking further on. */
			if (match == end - 1)
			  break;
			match++;
			patterns[i].regexbuf.not_eol = 0;
			start = re_search (&(patterns[i].regexbuf),
					   buf, end - buf - 1,
					   match - buf, end - match - 1,
					   &(patterns[i].regs));
			if (start < 0)
			  break;
			len = patterns[i].regs.end[0] - start;
			match = buf + start;
		      }
		  } /* while (match <= best_match) */
	      continue;
	    assess_pattern_match:
	      if (!start_ptr)
		{
		  /* Good enough for a non-exact match.
		     No need to look at further patterns, if any.  */
		  beg = match;
		  goto success_in_len;
		}
	      if (match < best_match || (match == best_match && len > best_len))
		{
		  /* Best exact match:  leftmost, then longest.  */
		  best_match = match;
		  best_len = len;
		}
	    } /* if re_search >= 0 */
	} /* for Regex patterns.  */
	if (best_match < end)
	  {
	    /* We have found an exact match.  We were just
	       waiting for the best one (leftmost then longest).  */
	    beg = best_match;
	    len = best_len;
	    goto success_in_len;
	  }
    } /* for (beg = end ..) */

 failure:
  ret_val = -1;
  goto out;

 success:
  len = end - beg;
 success_in_len:
  *match_size = len;
  ret_val = beg - buf;
 out:
  return ret_val;
}

Spawn 1 instances, now Total 22
Counter: 23
Batcher Size:22
Preprocess the following candidate with CondTester:
Priority 20000
At location src/dfasearch.c:306
--Src File: src/dfasearch.c
Fragment 0:
if ((start_ptr && !match_words) && !(__abst_hole(start_ptr, match_words, match, best_match, match_lines, buf, beg, end, start, len, i, patterns, pcount, best_len, buflim, backref, eol, mb_start, kwset_exact_matches, kwset, ret_val, size, match_size, match_icase, eolbyte)))
    goto assess_pattern_match;


CondTester, a patch instance with id 22:
//src_file:src/dfasearch.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); void* memset(void*, int, unsigned long); 
/* dfasearch.c - searching subroutines using dfa and regex for grep.
   Copyright 1992, 1998, 2000, 2007, 2009-2010 Free Software Foundation, Inc.

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 3, or (at your option)
   any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program; if not, write to the Free Software
   Foundation, Inc., 51 Franklin Street - Fifth Floor, Boston, MA
   02110-1301, USA.  */

/* Written August 1992 by Mike Haertel. */

#include <config.h>
#include "search.h"
#include "dfa.h"

/* For -w, we also consider _ to be word constituent.  */
#define WCHAR(C) (ISALNUM(C) || (C) == '_')

/* KWset compiled pattern.  For Ecompile and Gcompile, we compile
   a list of strings, at least one of which is known to occur in
   any string matching the regexp. */
static kwset_t kwset;

/* DFA compiled regexp. */
static struct dfa dfa;

/* The Regex compiled patterns.  */
static struct patterns
{
  /* Regex compiled regexp. */
  struct re_pattern_buffer regexbuf;
  struct re_registers regs; /* This is here on account of a BRAIN-DEAD
			       Q@#%!# library interface in regex.c.  */
} patterns0;

struct patterns *patterns;
size_t pcount;

void
dfaerror (char const *mesg)
{
  error (EXIT_TROUBLE, 0, "%s", mesg);

  /* notreached */
  /* Tell static analyzers that this function does not return.  */
  abort ();
}

/* Number of compiled fixed strings known to exactly match the regexp.
   If kwsexec returns < kwset_exact_matches, then we don't need to
   call the regexp matcher at all. */
static int kwset_exact_matches;

static char const *
kwsincr_case (const char *must)
{
  const char *buf;
  size_t n;

  n = strlen (must);
#ifdef MBS_SUPPORT
  if (match_icase && MB_CUR_MAX > 1)
    buf = mbtolower (must, &n);
  else
#endif
    buf = must;
  return kwsincr (kwset, buf, n);
}

/* If the DFA turns out to have some set of fixed strings one of
   which must occur in the match, then we build a kwset matcher
   to find those strings, and thus quickly filter out impossible
   matches. */
static void
kwsmusts (void)
{
  struct dfamust const *dm;
  char const *err;

  if (dfa.musts)
    {
      kwsinit (&kwset);
      /* First, we compile in the substrings known to be exact
	 matches.  The kwset matcher will return the index
	 of the matching string that it chooses. */
      for (dm = dfa.musts; dm; dm = dm->next)
	{
	  if (!dm->exact)
	    continue;
	  ++kwset_exact_matches;
	  if ((err = kwsincr_case (dm->must)) != NULL)
	    error (EXIT_TROUBLE, 0, "%s", err);
	}
      /* Now, we compile the substrings that will require
	 the use of the regexp matcher.  */
      for (dm = dfa.musts; dm; dm = dm->next)
	{
	  if (dm->exact)
	    continue;
	  if ((err = kwsincr_case (dm->must)) != NULL)
	    error (EXIT_TROUBLE, 0, "%s", err);
	}
      if ((err = kwsprep (kwset)) != NULL)
	error (EXIT_TROUBLE, 0, "%s", err);
    }
}

void
GEAcompile (char const *pattern, size_t size, reg_syntax_t syntax_bits)
{
  const char *err;
  const char *p, *sep;
  size_t total = size;
  char *motif;

  if (match_icase)
    syntax_bits |= RE_ICASE;
  re_set_syntax (syntax_bits);
  dfasyntax (syntax_bits, match_icase, eolbyte);

  /* For GNU regex compiler we have to pass the patterns separately to detect
     errors like "[\nallo\n]\n".  The patterns here are "[", "allo" and "]"
     GNU regex should have raise a syntax error.  The same for backref, where
     the backref should have been local to each pattern.  */
  p = pattern;
  do
    {
      size_t len;
      sep = memchr (p, '\n', total);
      if (sep)
	{
	  len = sep - p;
	  sep++;
	  total -= (len + 1);
	}
      else
	{
	  len = total;
	  total = 0;
	}

      patterns = realloc (patterns, (pcount + 1) * sizeof (*patterns));
      if (patterns == NULL)
	error (EXIT_TROUBLE, errno, _("memory exhausted"));
      patterns[pcount] = patterns0;

      if ((err = re_compile_pattern (p, len,
				    &(patterns[pcount].regexbuf))) != NULL)
	error (EXIT_TROUBLE, 0, "%s", err);
      pcount++;

      p = sep;
    } while (sep && total != 0);

  /* In the match_words and match_lines cases, we use a different pattern
     for the DFA matcher that will quickly throw out cases that won't work.
     Then if DFA succeeds we do some hairy stuff using the regex matcher
     to decide whether the match should really count. */
  if (match_words || match_lines)
    {
      static char const line_beg_no_bk[] = "^(";
      static char const line_end_no_bk[] = ")$";
      static char const word_beg_no_bk[] = "(^|[^[:alnum:]_])(";
      static char const word_end_no_bk[] = ")([^[:alnum:]_]|$)";
      static char const line_beg_bk[] = "^\\(";
      static char const line_end_bk[] = "\\)$";
      static char const word_beg_bk[] = "\\(^\\|[^[:alnum:]_]\\)\\(";
      static char const word_end_bk[] = "\\)\\([^[:alnum:]_]\\|$\\)";
      int bk = !(syntax_bits & RE_NO_BK_PARENS);
      char *n = xmalloc (sizeof word_beg_bk - 1 + size + sizeof word_end_bk);

      strcpy (n, match_lines ? (bk ? line_beg_bk : line_beg_no_bk)
			     : (bk ? word_beg_bk : word_beg_no_bk));
      total = strlen(n);
      memcpy (n + total, pattern, size);
      total += size;
      strcpy (n + total, match_lines ? (bk ? line_end_bk : line_end_no_bk)
				     : (bk ? word_end_bk : word_end_no_bk));
      total += strlen (n + total);
      pattern = motif = n;
      size = total;
    }
  else
    motif = NULL;

  dfacomp (pattern, size, &dfa, 1);
  kwsmusts ();

  free(motif);
}

size_t
EGexecute (char const *buf, size_t size, size_t *match_size,
	   char const *start_ptr)
{
  char const *buflim, *beg, *end, *match, *best_match, *mb_start;
  char eol = eolbyte;
  int backref, start, len, best_len;
  struct kwsmatch kwsm;
  size_t i, ret_val;
#ifdef MBS_SUPPORT
  if (MB_CUR_MAX > 1)
    {
      if (match_icase)
        {
          /* mbtolower adds a NUL byte at the end.  That will provide
	     space for the sentinel byte dfaexec may add.  */
          char *case_buf = mbtolower (buf, &size);
	  if (start_ptr)
	    start_ptr = case_buf + (start_ptr - buf);
          buf = case_buf;
        }
    }
#endif /* MBS_SUPPORT */

  mb_start = buf;
  buflim = buf + size;

  for (beg = end = buf; end < buflim; beg = end)
    {
      if (!start_ptr)
	{
	  /* We don't care about an exact match.  */
	  if (kwset)
	    {
	      /* Find a possible match using the KWset matcher. */
	      size_t offset = kwsexec (kwset, beg, buflim - beg, &kwsm);
	      if (offset == (size_t) -1)
		goto failure;
	      beg += offset;
	      /* Narrow down to the line containing the candidate, and
		 run it through DFA. */
	      if ((end = memchr(beg, eol, buflim - beg)) != NULL)
	        end++;
              else
                end = buflim;
	      match = beg;
	      while (beg > buf && beg[-1] != eol)
		--beg;
	      if (kwsm.index < kwset_exact_matches)
                {
#ifdef MBS_SUPPORT
                  if (mb_start < beg)
                    mb_start = beg;
                  if (MB_CUR_MAX == 1 || !is_mb_middle (&mb_start, match, buflim))
#endif
                    goto success;
                }
	      if (dfaexec (&dfa, beg, (char *) end, 0, NULL, &backref) == NULL)
		continue;
	    }
	  else
	    {
	      /* No good fixed strings; start with DFA. */
	      char const *next_beg = dfaexec (&dfa, beg, (char *) buflim,
					      0, NULL, &backref);
	      if (next_beg == NULL)
		break;
	      /* Narrow down to the line we've found. */
	      beg = next_beg;
	      if ((end = memchr(beg, eol, buflim - beg)) != NULL)
	        end++;
              else
                end = buflim;
	      while (beg > buf && beg[-1] != eol)
		--beg;
	    }
	  /* Successful, no backreferences encountered! */
	  if (!backref)
	    goto success;
	}
      else
	{
	  /* We are looking for the leftmost (then longest) exact match.
	     We will go through the outer loop only once.  */
	  beg = start_ptr;
	  end = buflim;
	}

      /* If we've made it to this point, this means DFA has seen
	 a probable match, and we need to run it through Regex. */
      best_match = end;
      best_len = 0;
      for (i = 0; i < pcount; i++)
	{
	  patterns[i].regexbuf.not_eol = 0;
	  if (0 <= (start = re_search (&(patterns[i].regexbuf),
				       buf, end - buf - 1,
				       beg - buf, end - beg - 1,
				       &(patterns[i].regs))))
	    {
	      len = patterns[i].regs.end[0] - start;
	      match = buf + start;
	      if (match > best_match)
		continue;
	      
//Patch 0:
if ((start_ptr && !match_words) && !(__is_neg(25, &(start_ptr), sizeof (start_ptr), &(match_words), sizeof (match_words), &(match), sizeof (match), &(best_match), sizeof (best_match), &(match_lines), sizeof (match_lines), &(buf), sizeof (buf), &(beg), sizeof (beg), &(end), sizeof (end), &(start), sizeof (start), &(len), sizeof (len), &(i), sizeof (i), &(patterns), sizeof (patterns), &(pcount), sizeof (pcount), &(best_len), sizeof (best_len), &(buflim), sizeof (buflim), &(backref), sizeof (backref), &(eol), sizeof (eol), &(mb_start), sizeof (mb_start), &(kwset_exact_matches), sizeof (kwset_exact_matches), &(kwset), sizeof (kwset), &(ret_val), sizeof (ret_val), &(size), sizeof (size), &(match_size), sizeof (match_size), &(match_icase), sizeof (match_icase), &(eolbyte), sizeof (eolbyte))))
    goto assess_pattern_match;

//CodeSeg 1:
	      if ((!match_lines && !match_words)
		  || (match_lines && len == end - beg - 1))
		{
		  match = beg;
		  len = end - beg;
		  goto assess_pattern_match;
		}
	      /* If -w, check if the match aligns with word boundaries.
		 We do this iteratively because:
		 (a) the line may contain more than one occurence of the
		 pattern, and
		 (b) Several alternatives in the pattern might be valid at a
		 given point, and we may need to consider a shorter one to
		 find a word boundary.  */
	      if (match_words)
		while (match <= best_match)
		  {
		    if ((match == buf || !WCHAR ((unsigned char) match[-1]))
			&& (len == end - beg - 1
			    || !WCHAR ((unsigned char) match[len])))
		      goto assess_pattern_match;
		    if (len > 0)
		      {
			/* Try a shorter length anchored at the same place. */
			--len;
			patterns[i].regexbuf.not_eol = 1;
			len = re_match (&(patterns[i].regexbuf),
					buf, match + len - beg, match - buf,
					&(patterns[i].regs));
		      }
		    if (len <= 0)
		      {
			/* Try looking further on. */
			if (match == end - 1)
			  break;
			match++;
			patterns[i].regexbuf.not_eol = 0;
			start = re_search (&(patterns[i].regexbuf),
					   buf, end - buf - 1,
					   match - buf, end - match - 1,
					   &(patterns[i].regs));
			if (start < 0)
			  break;
			len = patterns[i].regs.end[0] - start;
			match = buf + start;
		      }
		  } /* while (match <= best_match) */
	      continue;
	    assess_pattern_match:
	      if (!start_ptr)
		{
		  /* Good enough for a non-exact match.
		     No need to look at further patterns, if any.  */
		  beg = match;
		  goto success_in_len;
		}
	      if (match < best_match || (match == best_match && len > best_len))
		{
		  /* Best exact match:  leftmost, then longest.  */
		  best_match = match;
		  best_len = len;
		}
	    } /* if re_search >= 0 */
	} /* for Regex patterns.  */
	if (best_match < end)
	  {
	    /* We have found an exact match.  We were just
	       waiting for the best one (leftmost then longest).  */
	    beg = best_match;
	    len = best_len;
	    goto success_in_len;
	  }
    } /* for (beg = end ..) */

 failure:
  ret_val = -1;
  goto out;

 success:
  len = end - beg;
 success_in_len:
  *match_size = len;
  ret_val = beg - buf;
 out:
  return ret_val;
}

Spawn 1 instances, now Total 23
Counter: 24
Batcher Size:23
Preprocess the following candidate with CondTester:
Priority 20000
At location src/dfasearch.c:306
--Src File: src/dfasearch.c
Fragment 0:
if ((start_ptr && !match_words) || (__abst_hole(start_ptr, match_words, match, best_match, match_lines, buf, beg, end, start, len, i, patterns, pcount, best_len, buflim, backref, eol, mb_start, kwset_exact_matches, kwset, ret_val, size, match_size, match_icase, eolbyte)))
    goto assess_pattern_match;


CondTester, a patch instance with id 23:
//src_file:src/dfasearch.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); void* memset(void*, int, unsigned long); 
/* dfasearch.c - searching subroutines using dfa and regex for grep.
   Copyright 1992, 1998, 2000, 2007, 2009-2010 Free Software Foundation, Inc.

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 3, or (at your option)
   any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program; if not, write to the Free Software
   Foundation, Inc., 51 Franklin Street - Fifth Floor, Boston, MA
   02110-1301, USA.  */

/* Written August 1992 by Mike Haertel. */

#include <config.h>
#include "search.h"
#include "dfa.h"

/* For -w, we also consider _ to be word constituent.  */
#define WCHAR(C) (ISALNUM(C) || (C) == '_')

/* KWset compiled pattern.  For Ecompile and Gcompile, we compile
   a list of strings, at least one of which is known to occur in
   any string matching the regexp. */
static kwset_t kwset;

/* DFA compiled regexp. */
static struct dfa dfa;

/* The Regex compiled patterns.  */
static struct patterns
{
  /* Regex compiled regexp. */
  struct re_pattern_buffer regexbuf;
  struct re_registers regs; /* This is here on account of a BRAIN-DEAD
			       Q@#%!# library interface in regex.c.  */
} patterns0;

struct patterns *patterns;
size_t pcount;

void
dfaerror (char const *mesg)
{
  error (EXIT_TROUBLE, 0, "%s", mesg);

  /* notreached */
  /* Tell static analyzers that this function does not return.  */
  abort ();
}

/* Number of compiled fixed strings known to exactly match the regexp.
   If kwsexec returns < kwset_exact_matches, then we don't need to
   call the regexp matcher at all. */
static int kwset_exact_matches;

static char const *
kwsincr_case (const char *must)
{
  const char *buf;
  size_t n;

  n = strlen (must);
#ifdef MBS_SUPPORT
  if (match_icase && MB_CUR_MAX > 1)
    buf = mbtolower (must, &n);
  else
#endif
    buf = must;
  return kwsincr (kwset, buf, n);
}

/* If the DFA turns out to have some set of fixed strings one of
   which must occur in the match, then we build a kwset matcher
   to find those strings, and thus quickly filter out impossible
   matches. */
static void
kwsmusts (void)
{
  struct dfamust const *dm;
  char const *err;

  if (dfa.musts)
    {
      kwsinit (&kwset);
      /* First, we compile in the substrings known to be exact
	 matches.  The kwset matcher will return the index
	 of the matching string that it chooses. */
      for (dm = dfa.musts; dm; dm = dm->next)
	{
	  if (!dm->exact)
	    continue;
	  ++kwset_exact_matches;
	  if ((err = kwsincr_case (dm->must)) != NULL)
	    error (EXIT_TROUBLE, 0, "%s", err);
	}
      /* Now, we compile the substrings that will require
	 the use of the regexp matcher.  */
      for (dm = dfa.musts; dm; dm = dm->next)
	{
	  if (dm->exact)
	    continue;
	  if ((err = kwsincr_case (dm->must)) != NULL)
	    error (EXIT_TROUBLE, 0, "%s", err);
	}
      if ((err = kwsprep (kwset)) != NULL)
	error (EXIT_TROUBLE, 0, "%s", err);
    }
}

void
GEAcompile (char const *pattern, size_t size, reg_syntax_t syntax_bits)
{
  const char *err;
  const char *p, *sep;
  size_t total = size;
  char *motif;

  if (match_icase)
    syntax_bits |= RE_ICASE;
  re_set_syntax (syntax_bits);
  dfasyntax (syntax_bits, match_icase, eolbyte);

  /* For GNU regex compiler we have to pass the patterns separately to detect
     errors like "[\nallo\n]\n".  The patterns here are "[", "allo" and "]"
     GNU regex should have raise a syntax error.  The same for backref, where
     the backref should have been local to each pattern.  */
  p = pattern;
  do
    {
      size_t len;
      sep = memchr (p, '\n', total);
      if (sep)
	{
	  len = sep - p;
	  sep++;
	  total -= (len + 1);
	}
      else
	{
	  len = total;
	  total = 0;
	}

      patterns = realloc (patterns, (pcount + 1) * sizeof (*patterns));
      if (patterns == NULL)
	error (EXIT_TROUBLE, errno, _("memory exhausted"));
      patterns[pcount] = patterns0;

      if ((err = re_compile_pattern (p, len,
				    &(patterns[pcount].regexbuf))) != NULL)
	error (EXIT_TROUBLE, 0, "%s", err);
      pcount++;

      p = sep;
    } while (sep && total != 0);

  /* In the match_words and match_lines cases, we use a different pattern
     for the DFA matcher that will quickly throw out cases that won't work.
     Then if DFA succeeds we do some hairy stuff using the regex matcher
     to decide whether the match should really count. */
  if (match_words || match_lines)
    {
      static char const line_beg_no_bk[] = "^(";
      static char const line_end_no_bk[] = ")$";
      static char const word_beg_no_bk[] = "(^|[^[:alnum:]_])(";
      static char const word_end_no_bk[] = ")([^[:alnum:]_]|$)";
      static char const line_beg_bk[] = "^\\(";
      static char const line_end_bk[] = "\\)$";
      static char const word_beg_bk[] = "\\(^\\|[^[:alnum:]_]\\)\\(";
      static char const word_end_bk[] = "\\)\\([^[:alnum:]_]\\|$\\)";
      int bk = !(syntax_bits & RE_NO_BK_PARENS);
      char *n = xmalloc (sizeof word_beg_bk - 1 + size + sizeof word_end_bk);

      strcpy (n, match_lines ? (bk ? line_beg_bk : line_beg_no_bk)
			     : (bk ? word_beg_bk : word_beg_no_bk));
      total = strlen(n);
      memcpy (n + total, pattern, size);
      total += size;
      strcpy (n + total, match_lines ? (bk ? line_end_bk : line_end_no_bk)
				     : (bk ? word_end_bk : word_end_no_bk));
      total += strlen (n + total);
      pattern = motif = n;
      size = total;
    }
  else
    motif = NULL;

  dfacomp (pattern, size, &dfa, 1);
  kwsmusts ();

  free(motif);
}

size_t
EGexecute (char const *buf, size_t size, size_t *match_size,
	   char const *start_ptr)
{
  char const *buflim, *beg, *end, *match, *best_match, *mb_start;
  char eol = eolbyte;
  int backref, start, len, best_len;
  struct kwsmatch kwsm;
  size_t i, ret_val;
#ifdef MBS_SUPPORT
  if (MB_CUR_MAX > 1)
    {
      if (match_icase)
        {
          /* mbtolower adds a NUL byte at the end.  That will provide
	     space for the sentinel byte dfaexec may add.  */
          char *case_buf = mbtolower (buf, &size);
	  if (start_ptr)
	    start_ptr = case_buf + (start_ptr - buf);
          buf = case_buf;
        }
    }
#endif /* MBS_SUPPORT */

  mb_start = buf;
  buflim = buf + size;

  for (beg = end = buf; end < buflim; beg = end)
    {
      if (!start_ptr)
	{
	  /* We don't care about an exact match.  */
	  if (kwset)
	    {
	      /* Find a possible match using the KWset matcher. */
	      size_t offset = kwsexec (kwset, beg, buflim - beg, &kwsm);
	      if (offset == (size_t) -1)
		goto failure;
	      beg += offset;
	      /* Narrow down to the line containing the candidate, and
		 run it through DFA. */
	      if ((end = memchr(beg, eol, buflim - beg)) != NULL)
	        end++;
              else
                end = buflim;
	      match = beg;
	      while (beg > buf && beg[-1] != eol)
		--beg;
	      if (kwsm.index < kwset_exact_matches)
                {
#ifdef MBS_SUPPORT
                  if (mb_start < beg)
                    mb_start = beg;
                  if (MB_CUR_MAX == 1 || !is_mb_middle (&mb_start, match, buflim))
#endif
                    goto success;
                }
	      if (dfaexec (&dfa, beg, (char *) end, 0, NULL, &backref) == NULL)
		continue;
	    }
	  else
	    {
	      /* No good fixed strings; start with DFA. */
	      char const *next_beg = dfaexec (&dfa, beg, (char *) buflim,
					      0, NULL, &backref);
	      if (next_beg == NULL)
		break;
	      /* Narrow down to the line we've found. */
	      beg = next_beg;
	      if ((end = memchr(beg, eol, buflim - beg)) != NULL)
	        end++;
              else
                end = buflim;
	      while (beg > buf && beg[-1] != eol)
		--beg;
	    }
	  /* Successful, no backreferences encountered! */
	  if (!backref)
	    goto success;
	}
      else
	{
	  /* We are looking for the leftmost (then longest) exact match.
	     We will go through the outer loop only once.  */
	  beg = start_ptr;
	  end = buflim;
	}

      /* If we've made it to this point, this means DFA has seen
	 a probable match, and we need to run it through Regex. */
      best_match = end;
      best_len = 0;
      for (i = 0; i < pcount; i++)
	{
	  patterns[i].regexbuf.not_eol = 0;
	  if (0 <= (start = re_search (&(patterns[i].regexbuf),
				       buf, end - buf - 1,
				       beg - buf, end - beg - 1,
				       &(patterns[i].regs))))
	    {
	      len = patterns[i].regs.end[0] - start;
	      match = buf + start;
	      if (match > best_match)
		continue;
	      
//Patch 0:
if ((start_ptr && !match_words) || (__is_neg(25, &(start_ptr), sizeof (start_ptr), &(match_words), sizeof (match_words), &(match), sizeof (match), &(best_match), sizeof (best_match), &(match_lines), sizeof (match_lines), &(buf), sizeof (buf), &(beg), sizeof (beg), &(end), sizeof (end), &(start), sizeof (start), &(len), sizeof (len), &(i), sizeof (i), &(patterns), sizeof (patterns), &(pcount), sizeof (pcount), &(best_len), sizeof (best_len), &(buflim), sizeof (buflim), &(backref), sizeof (backref), &(eol), sizeof (eol), &(mb_start), sizeof (mb_start), &(kwset_exact_matches), sizeof (kwset_exact_matches), &(kwset), sizeof (kwset), &(ret_val), sizeof (ret_val), &(size), sizeof (size), &(match_size), sizeof (match_size), &(match_icase), sizeof (match_icase), &(eolbyte), sizeof (eolbyte))))
    goto assess_pattern_match;

//CodeSeg 1:
	      if ((!match_lines && !match_words)
		  || (match_lines && len == end - beg - 1))
		{
		  match = beg;
		  len = end - beg;
		  goto assess_pattern_match;
		}
	      /* If -w, check if the match aligns with word boundaries.
		 We do this iteratively because:
		 (a) the line may contain more than one occurence of the
		 pattern, and
		 (b) Several alternatives in the pattern might be valid at a
		 given point, and we may need to consider a shorter one to
		 find a word boundary.  */
	      if (match_words)
		while (match <= best_match)
		  {
		    if ((match == buf || !WCHAR ((unsigned char) match[-1]))
			&& (len == end - beg - 1
			    || !WCHAR ((unsigned char) match[len])))
		      goto assess_pattern_match;
		    if (len > 0)
		      {
			/* Try a shorter length anchored at the same place. */
			--len;
			patterns[i].regexbuf.not_eol = 1;
			len = re_match (&(patterns[i].regexbuf),
					buf, match + len - beg, match - buf,
					&(patterns[i].regs));
		      }
		    if (len <= 0)
		      {
			/* Try looking further on. */
			if (match == end - 1)
			  break;
			match++;
			patterns[i].regexbuf.not_eol = 0;
			start = re_search (&(patterns[i].regexbuf),
					   buf, end - buf - 1,
					   match - buf, end - match - 1,
					   &(patterns[i].regs));
			if (start < 0)
			  break;
			len = patterns[i].regs.end[0] - start;
			match = buf + start;
		      }
		  } /* while (match <= best_match) */
	      continue;
	    assess_pattern_match:
	      if (!start_ptr)
		{
		  /* Good enough for a non-exact match.
		     No need to look at further patterns, if any.  */
		  beg = match;
		  goto success_in_len;
		}
	      if (match < best_match || (match == best_match && len > best_len))
		{
		  /* Best exact match:  leftmost, then longest.  */
		  best_match = match;
		  best_len = len;
		}
	    } /* if re_search >= 0 */
	} /* for Regex patterns.  */
	if (best_match < end)
	  {
	    /* We have found an exact match.  We were just
	       waiting for the best one (leftmost then longest).  */
	    beg = best_match;
	    len = best_len;
	    goto success_in_len;
	  }
    } /* for (beg = end ..) */

 failure:
  ret_val = -1;
  goto out;

 success:
  len = end - beg;
 success_in_len:
  *match_size = len;
  ret_val = beg - buf;
 out:
  return ret_val;
}

Spawn 1 instances, now Total 24
Counter: 25
Batcher Size:24
Preprocess the following candidate with CondTester:
Priority 20000
At location src/dfasearch.c:306
--Src File: src/dfasearch.c
Fragment 0:
if (((start_ptr) || (__abst_hole(start_ptr, match_words, match, best_match, match_lines, buf, beg, end, start, len, i, patterns, pcount, best_len, buflim, backref, eol, mb_start, kwset_exact_matches, kwset, ret_val, size, match_size, match_icase, eolbyte))) && !match_words)
    goto assess_pattern_match;


CondTester, a patch instance with id 24:
//src_file:src/dfasearch.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); void* memset(void*, int, unsigned long); 
/* dfasearch.c - searching subroutines using dfa and regex for grep.
   Copyright 1992, 1998, 2000, 2007, 2009-2010 Free Software Foundation, Inc.

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 3, or (at your option)
   any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program; if not, write to the Free Software
   Foundation, Inc., 51 Franklin Street - Fifth Floor, Boston, MA
   02110-1301, USA.  */

/* Written August 1992 by Mike Haertel. */

#include <config.h>
#include "search.h"
#include "dfa.h"

/* For -w, we also consider _ to be word constituent.  */
#define WCHAR(C) (ISALNUM(C) || (C) == '_')

/* KWset compiled pattern.  For Ecompile and Gcompile, we compile
   a list of strings, at least one of which is known to occur in
   any string matching the regexp. */
static kwset_t kwset;

/* DFA compiled regexp. */
static struct dfa dfa;

/* The Regex compiled patterns.  */
static struct patterns
{
  /* Regex compiled regexp. */
  struct re_pattern_buffer regexbuf;
  struct re_registers regs; /* This is here on account of a BRAIN-DEAD
			       Q@#%!# library interface in regex.c.  */
} patterns0;

struct patterns *patterns;
size_t pcount;

void
dfaerror (char const *mesg)
{
  error (EXIT_TROUBLE, 0, "%s", mesg);

  /* notreached */
  /* Tell static analyzers that this function does not return.  */
  abort ();
}

/* Number of compiled fixed strings known to exactly match the regexp.
   If kwsexec returns < kwset_exact_matches, then we don't need to
   call the regexp matcher at all. */
static int kwset_exact_matches;

static char const *
kwsincr_case (const char *must)
{
  const char *buf;
  size_t n;

  n = strlen (must);
#ifdef MBS_SUPPORT
  if (match_icase && MB_CUR_MAX > 1)
    buf = mbtolower (must, &n);
  else
#endif
    buf = must;
  return kwsincr (kwset, buf, n);
}

/* If the DFA turns out to have some set of fixed strings one of
   which must occur in the match, then we build a kwset matcher
   to find those strings, and thus quickly filter out impossible
   matches. */
static void
kwsmusts (void)
{
  struct dfamust const *dm;
  char const *err;

  if (dfa.musts)
    {
      kwsinit (&kwset);
      /* First, we compile in the substrings known to be exact
	 matches.  The kwset matcher will return the index
	 of the matching string that it chooses. */
      for (dm = dfa.musts; dm; dm = dm->next)
	{
	  if (!dm->exact)
	    continue;
	  ++kwset_exact_matches;
	  if ((err = kwsincr_case (dm->must)) != NULL)
	    error (EXIT_TROUBLE, 0, "%s", err);
	}
      /* Now, we compile the substrings that will require
	 the use of the regexp matcher.  */
      for (dm = dfa.musts; dm; dm = dm->next)
	{
	  if (dm->exact)
	    continue;
	  if ((err = kwsincr_case (dm->must)) != NULL)
	    error (EXIT_TROUBLE, 0, "%s", err);
	}
      if ((err = kwsprep (kwset)) != NULL)
	error (EXIT_TROUBLE, 0, "%s", err);
    }
}

void
GEAcompile (char const *pattern, size_t size, reg_syntax_t syntax_bits)
{
  const char *err;
  const char *p, *sep;
  size_t total = size;
  char *motif;

  if (match_icase)
    syntax_bits |= RE_ICASE;
  re_set_syntax (syntax_bits);
  dfasyntax (syntax_bits, match_icase, eolbyte);

  /* For GNU regex compiler we have to pass the patterns separately to detect
     errors like "[\nallo\n]\n".  The patterns here are "[", "allo" and "]"
     GNU regex should have raise a syntax error.  The same for backref, where
     the backref should have been local to each pattern.  */
  p = pattern;
  do
    {
      size_t len;
      sep = memchr (p, '\n', total);
      if (sep)
	{
	  len = sep - p;
	  sep++;
	  total -= (len + 1);
	}
      else
	{
	  len = total;
	  total = 0;
	}

      patterns = realloc (patterns, (pcount + 1) * sizeof (*patterns));
      if (patterns == NULL)
	error (EXIT_TROUBLE, errno, _("memory exhausted"));
      patterns[pcount] = patterns0;

      if ((err = re_compile_pattern (p, len,
				    &(patterns[pcount].regexbuf))) != NULL)
	error (EXIT_TROUBLE, 0, "%s", err);
      pcount++;

      p = sep;
    } while (sep && total != 0);

  /* In the match_words and match_lines cases, we use a different pattern
     for the DFA matcher that will quickly throw out cases that won't work.
     Then if DFA succeeds we do some hairy stuff using the regex matcher
     to decide whether the match should really count. */
  if (match_words || match_lines)
    {
      static char const line_beg_no_bk[] = "^(";
      static char const line_end_no_bk[] = ")$";
      static char const word_beg_no_bk[] = "(^|[^[:alnum:]_])(";
      static char const word_end_no_bk[] = ")([^[:alnum:]_]|$)";
      static char const line_beg_bk[] = "^\\(";
      static char const line_end_bk[] = "\\)$";
      static char const word_beg_bk[] = "\\(^\\|[^[:alnum:]_]\\)\\(";
      static char const word_end_bk[] = "\\)\\([^[:alnum:]_]\\|$\\)";
      int bk = !(syntax_bits & RE_NO_BK_PARENS);
      char *n = xmalloc (sizeof word_beg_bk - 1 + size + sizeof word_end_bk);

      strcpy (n, match_lines ? (bk ? line_beg_bk : line_beg_no_bk)
			     : (bk ? word_beg_bk : word_beg_no_bk));
      total = strlen(n);
      memcpy (n + total, pattern, size);
      total += size;
      strcpy (n + total, match_lines ? (bk ? line_end_bk : line_end_no_bk)
				     : (bk ? word_end_bk : word_end_no_bk));
      total += strlen (n + total);
      pattern = motif = n;
      size = total;
    }
  else
    motif = NULL;

  dfacomp (pattern, size, &dfa, 1);
  kwsmusts ();

  free(motif);
}

size_t
EGexecute (char const *buf, size_t size, size_t *match_size,
	   char const *start_ptr)
{
  char const *buflim, *beg, *end, *match, *best_match, *mb_start;
  char eol = eolbyte;
  int backref, start, len, best_len;
  struct kwsmatch kwsm;
  size_t i, ret_val;
#ifdef MBS_SUPPORT
  if (MB_CUR_MAX > 1)
    {
      if (match_icase)
        {
          /* mbtolower adds a NUL byte at the end.  That will provide
	     space for the sentinel byte dfaexec may add.  */
          char *case_buf = mbtolower (buf, &size);
	  if (start_ptr)
	    start_ptr = case_buf + (start_ptr - buf);
          buf = case_buf;
        }
    }
#endif /* MBS_SUPPORT */

  mb_start = buf;
  buflim = buf + size;

  for (beg = end = buf; end < buflim; beg = end)
    {
      if (!start_ptr)
	{
	  /* We don't care about an exact match.  */
	  if (kwset)
	    {
	      /* Find a possible match using the KWset matcher. */
	      size_t offset = kwsexec (kwset, beg, buflim - beg, &kwsm);
	      if (offset == (size_t) -1)
		goto failure;
	      beg += offset;
	      /* Narrow down to the line containing the candidate, and
		 run it through DFA. */
	      if ((end = memchr(beg, eol, buflim - beg)) != NULL)
	        end++;
              else
                end = buflim;
	      match = beg;
	      while (beg > buf && beg[-1] != eol)
		--beg;
	      if (kwsm.index < kwset_exact_matches)
                {
#ifdef MBS_SUPPORT
                  if (mb_start < beg)
                    mb_start = beg;
                  if (MB_CUR_MAX == 1 || !is_mb_middle (&mb_start, match, buflim))
#endif
                    goto success;
                }
	      if (dfaexec (&dfa, beg, (char *) end, 0, NULL, &backref) == NULL)
		continue;
	    }
	  else
	    {
	      /* No good fixed strings; start with DFA. */
	      char const *next_beg = dfaexec (&dfa, beg, (char *) buflim,
					      0, NULL, &backref);
	      if (next_beg == NULL)
		break;
	      /* Narrow down to the line we've found. */
	      beg = next_beg;
	      if ((end = memchr(beg, eol, buflim - beg)) != NULL)
	        end++;
              else
                end = buflim;
	      while (beg > buf && beg[-1] != eol)
		--beg;
	    }
	  /* Successful, no backreferences encountered! */
	  if (!backref)
	    goto success;
	}
      else
	{
	  /* We are looking for the leftmost (then longest) exact match.
	     We will go through the outer loop only once.  */
	  beg = start_ptr;
	  end = buflim;
	}

      /* If we've made it to this point, this means DFA has seen
	 a probable match, and we need to run it through Regex. */
      best_match = end;
      best_len = 0;
      for (i = 0; i < pcount; i++)
	{
	  patterns[i].regexbuf.not_eol = 0;
	  if (0 <= (start = re_search (&(patterns[i].regexbuf),
				       buf, end - buf - 1,
				       beg - buf, end - beg - 1,
				       &(patterns[i].regs))))
	    {
	      len = patterns[i].regs.end[0] - start;
	      match = buf + start;
	      if (match > best_match)
		continue;
	      
//Patch 0:
if (((start_ptr) || (__is_neg(25, &(start_ptr), sizeof (start_ptr), &(match_words), sizeof (match_words), &(match), sizeof (match), &(best_match), sizeof (best_match), &(match_lines), sizeof (match_lines), &(buf), sizeof (buf), &(beg), sizeof (beg), &(end), sizeof (end), &(start), sizeof (start), &(len), sizeof (len), &(i), sizeof (i), &(patterns), sizeof (patterns), &(pcount), sizeof (pcount), &(best_len), sizeof (best_len), &(buflim), sizeof (buflim), &(backref), sizeof (backref), &(eol), sizeof (eol), &(mb_start), sizeof (mb_start), &(kwset_exact_matches), sizeof (kwset_exact_matches), &(kwset), sizeof (kwset), &(ret_val), sizeof (ret_val), &(size), sizeof (size), &(match_size), sizeof (match_size), &(match_icase), sizeof (match_icase), &(eolbyte), sizeof (eolbyte)))) && !match_words)
    goto assess_pattern_match;

//CodeSeg 1:
	      if ((!match_lines && !match_words)
		  || (match_lines && len == end - beg - 1))
		{
		  match = beg;
		  len = end - beg;
		  goto assess_pattern_match;
		}
	      /* If -w, check if the match aligns with word boundaries.
		 We do this iteratively because:
		 (a) the line may contain more than one occurence of the
		 pattern, and
		 (b) Several alternatives in the pattern might be valid at a
		 given point, and we may need to consider a shorter one to
		 find a word boundary.  */
	      if (match_words)
		while (match <= best_match)
		  {
		    if ((match == buf || !WCHAR ((unsigned char) match[-1]))
			&& (len == end - beg - 1
			    || !WCHAR ((unsigned char) match[len])))
		      goto assess_pattern_match;
		    if (len > 0)
		      {
			/* Try a shorter length anchored at the same place. */
			--len;
			patterns[i].regexbuf.not_eol = 1;
			len = re_match (&(patterns[i].regexbuf),
					buf, match + len - beg, match - buf,
					&(patterns[i].regs));
		      }
		    if (len <= 0)
		      {
			/* Try looking further on. */
			if (match == end - 1)
			  break;
			match++;
			patterns[i].regexbuf.not_eol = 0;
			start = re_search (&(patterns[i].regexbuf),
					   buf, end - buf - 1,
					   match - buf, end - match - 1,
					   &(patterns[i].regs));
			if (start < 0)
			  break;
			len = patterns[i].regs.end[0] - start;
			match = buf + start;
		      }
		  } /* while (match <= best_match) */
	      continue;
	    assess_pattern_match:
	      if (!start_ptr)
		{
		  /* Good enough for a non-exact match.
		     No need to look at further patterns, if any.  */
		  beg = match;
		  goto success_in_len;
		}
	      if (match < best_match || (match == best_match && len > best_len))
		{
		  /* Best exact match:  leftmost, then longest.  */
		  best_match = match;
		  best_len = len;
		}
	    } /* if re_search >= 0 */
	} /* for Regex patterns.  */
	if (best_match < end)
	  {
	    /* We have found an exact match.  We were just
	       waiting for the best one (leftmost then longest).  */
	    beg = best_match;
	    len = best_len;
	    goto success_in_len;
	  }
    } /* for (beg = end ..) */

 failure:
  ret_val = -1;
  goto out;

 success:
  len = end - beg;
 success_in_len:
  *match_size = len;
  ret_val = beg - buf;
 out:
  return ret_val;
}

Spawn 1 instances, now Total 25
Counter: 26
Batcher Size:25
Preprocess the following candidate with CondTester:
Priority 20000
At location src/dfasearch.c:90
--Src File: src/dfasearch.c
Fragment 0:
if ((dfa.musts) || (__abst_hole(dfa.musts, dfa.musts, kwset, dm, kwset_exact_matches, err, dfa.charclasses, dfa.cindex, dfa.calloc, dfa.tokens, dfa.tindex, dfa.talloc, dfa.depth, dfa.nleaves, dfa.nregexps, dfa.mb_cur_max, dfa.nmultibyte_prop, dfa.multibyte_prop, dfa.mbcsets, dfa.nmbcsets, dfa.mbcsets_alloc, dfa.states, dfa.sindex, dfa.salloc, dfa.follows, dfa.searchflag, dfa.tralloc, dfa.trcount, dfa.trans, dfa.realtrans, dfa.fails, dfa.success, dfa.newlines, dfa.charclasses, dfa.cindex, dfa.calloc, dfa.tokens, dfa.tindex, dfa.talloc, dfa.depth, dfa.nleaves, dfa.nregexps, dfa.mb_cur_max, dfa.nmultibyte_prop, dfa.multibyte_prop, dfa.mbcsets, dfa.nmbcsets, dfa.mbcsets_alloc, dfa.states, dfa.sindex, dfa.salloc, dfa.follows, dfa.searchflag, dfa.tralloc, dfa.trcount, dfa.trans, dfa.realtrans, dfa.fails, dfa.success, dfa.newlines))) {
    kwsinit(&kwset);
    for (dm = dfa.musts; dm; dm = dm->next) {
        if (!dm->exact)
            continue;
        ++kwset_exact_matches;
        if ((err = kwsincr_case(dm->must)) != ((void *)0))
            error(EXIT_TROUBLE, 0, "%s", err);
    }
    for (dm = dfa.musts; dm; dm = dm->next) {
        if (dm->exact)
            continue;
        if ((err = kwsincr_case(dm->must)) != ((void *)0))
            error(EXIT_TROUBLE, 0, "%s", err);
    }
    if ((err = kwsprep(kwset)) != ((void *)0))
        error(EXIT_TROUBLE, 0, "%s", err);
}


CondTester, a patch instance with id 25:
//src_file:src/dfasearch.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); void* memset(void*, int, unsigned long); 
/* dfasearch.c - searching subroutines using dfa and regex for grep.
   Copyright 1992, 1998, 2000, 2007, 2009-2010 Free Software Foundation, Inc.

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 3, or (at your option)
   any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program; if not, write to the Free Software
   Foundation, Inc., 51 Franklin Street - Fifth Floor, Boston, MA
   02110-1301, USA.  */

/* Written August 1992 by Mike Haertel. */

#include <config.h>
#include "search.h"
#include "dfa.h"

/* For -w, we also consider _ to be word constituent.  */
#define WCHAR(C) (ISALNUM(C) || (C) == '_')

/* KWset compiled pattern.  For Ecompile and Gcompile, we compile
   a list of strings, at least one of which is known to occur in
   any string matching the regexp. */
static kwset_t kwset;

/* DFA compiled regexp. */
static struct dfa dfa;

/* The Regex compiled patterns.  */
static struct patterns
{
  /* Regex compiled regexp. */
  struct re_pattern_buffer regexbuf;
  struct re_registers regs; /* This is here on account of a BRAIN-DEAD
			       Q@#%!# library interface in regex.c.  */
} patterns0;

struct patterns *patterns;
size_t pcount;

void
dfaerror (char const *mesg)
{
  error (EXIT_TROUBLE, 0, "%s", mesg);

  /* notreached */
  /* Tell static analyzers that this function does not return.  */
  abort ();
}

/* Number of compiled fixed strings known to exactly match the regexp.
   If kwsexec returns < kwset_exact_matches, then we don't need to
   call the regexp matcher at all. */
static int kwset_exact_matches;

static char const *
kwsincr_case (const char *must)
{
  const char *buf;
  size_t n;

  n = strlen (must);
#ifdef MBS_SUPPORT
  if (match_icase && MB_CUR_MAX > 1)
    buf = mbtolower (must, &n);
  else
#endif
    buf = must;
  return kwsincr (kwset, buf, n);
}

/* If the DFA turns out to have some set of fixed strings one of
   which must occur in the match, then we build a kwset matcher
   to find those strings, and thus quickly filter out impossible
   matches. */
static void
kwsmusts (void)
{
  struct dfamust const *dm;
  char const *err;

  
//Patch 0:
if ((dfa.musts) || (__is_neg(60, &(dfa.musts), sizeof (dfa.musts), &(dfa.musts), sizeof (dfa.musts), &(kwset), sizeof (kwset), &(dm), sizeof (dm), &(kwset_exact_matches), sizeof (kwset_exact_matches), &(err), sizeof (err), &(dfa.charclasses), sizeof (dfa.charclasses), &(dfa.cindex), sizeof (dfa.cindex), &(dfa.calloc), sizeof (dfa.calloc), &(dfa.tokens), sizeof (dfa.tokens), &(dfa.tindex), sizeof (dfa.tindex), &(dfa.talloc), sizeof (dfa.talloc), &(dfa.depth), sizeof (dfa.depth), &(dfa.nleaves), sizeof (dfa.nleaves), &(dfa.nregexps), sizeof (dfa.nregexps), &(dfa.mb_cur_max), sizeof (dfa.mb_cur_max), &(dfa.nmultibyte_prop), sizeof (dfa.nmultibyte_prop), &(dfa.multibyte_prop), sizeof (dfa.multibyte_prop), &(dfa.mbcsets), sizeof (dfa.mbcsets), &(dfa.nmbcsets), sizeof (dfa.nmbcsets), &(dfa.mbcsets_alloc), sizeof (dfa.mbcsets_alloc), &(dfa.states), sizeof (dfa.states), &(dfa.sindex), sizeof (dfa.sindex), &(dfa.salloc), sizeof (dfa.salloc), &(dfa.follows), sizeof (dfa.follows), &(dfa.searchflag), sizeof (dfa.searchflag), &(dfa.tralloc), sizeof (dfa.tralloc), &(dfa.trcount), sizeof (dfa.trcount), &(dfa.trans), sizeof (dfa.trans), &(dfa.realtrans), sizeof (dfa.realtrans), &(dfa.fails), sizeof (dfa.fails), &(dfa.success), sizeof (dfa.success), &(dfa.newlines), sizeof (dfa.newlines), &(dfa.charclasses), sizeof (dfa.charclasses), &(dfa.cindex), sizeof (dfa.cindex), &(dfa.calloc), sizeof (dfa.calloc), &(dfa.tokens), sizeof (dfa.tokens), &(dfa.tindex), sizeof (dfa.tindex), &(dfa.talloc), sizeof (dfa.talloc), &(dfa.depth), sizeof (dfa.depth), &(dfa.nleaves), sizeof (dfa.nleaves), &(dfa.nregexps), sizeof (dfa.nregexps), &(dfa.mb_cur_max), sizeof (dfa.mb_cur_max), &(dfa.nmultibyte_prop), sizeof (dfa.nmultibyte_prop), &(dfa.multibyte_prop), sizeof (dfa.multibyte_prop), &(dfa.mbcsets), sizeof (dfa.mbcsets), &(dfa.nmbcsets), sizeof (dfa.nmbcsets), &(dfa.mbcsets_alloc), sizeof (dfa.mbcsets_alloc), &(dfa.states), sizeof (dfa.states), &(dfa.sindex), sizeof (dfa.sindex), &(dfa.salloc), sizeof (dfa.salloc), &(dfa.follows), sizeof (dfa.follows), &(dfa.searchflag), sizeof (dfa.searchflag), &(dfa.tralloc), sizeof (dfa.tralloc), &(dfa.trcount), sizeof (dfa.trcount), &(dfa.trans), sizeof (dfa.trans), &(dfa.realtrans), sizeof (dfa.realtrans), &(dfa.fails), sizeof (dfa.fails), &(dfa.success), sizeof (dfa.success), &(dfa.newlines), sizeof (dfa.newlines)))) {
    kwsinit(&kwset);
    for (dm = dfa.musts; dm; dm = dm->next) {
        if (!dm->exact)
            continue;
        ++kwset_exact_matches;
        if ((err = kwsincr_case(dm->must)) != ((void *)0))
            error(EXIT_TROUBLE, 0, "%s", err);
    }
    for (dm = dfa.musts; dm; dm = dm->next) {
        if (dm->exact)
            continue;
        if ((err = kwsincr_case(dm->must)) != ((void *)0))
            error(EXIT_TROUBLE, 0, "%s", err);
    }
    if ((err = kwsprep(kwset)) != ((void *)0))
        error(EXIT_TROUBLE, 0, "%s", err);
}

//CodeSeg 1:
}

void
GEAcompile (char const *pattern, size_t size, reg_syntax_t syntax_bits)
{
  const char *err;
  const char *p, *sep;
  size_t total = size;
  char *motif;

  if (match_icase)
    syntax_bits |= RE_ICASE;
  re_set_syntax (syntax_bits);
  dfasyntax (syntax_bits, match_icase, eolbyte);

  /* For GNU regex compiler we have to pass the patterns separately to detect
     errors like "[\nallo\n]\n".  The patterns here are "[", "allo" and "]"
     GNU regex should have raise a syntax error.  The same for backref, where
     the backref should have been local to each pattern.  */
  p = pattern;
  do
    {
      size_t len;
      sep = memchr (p, '\n', total);
      if (sep)
	{
	  len = sep - p;
	  sep++;
	  total -= (len + 1);
	}
      else
	{
	  len = total;
	  total = 0;
	}

      patterns = realloc (patterns, (pcount + 1) * sizeof (*patterns));
      if (patterns == NULL)
	error (EXIT_TROUBLE, errno, _("memory exhausted"));
      patterns[pcount] = patterns0;

      if ((err = re_compile_pattern (p, len,
				    &(patterns[pcount].regexbuf))) != NULL)
	error (EXIT_TROUBLE, 0, "%s", err);
      pcount++;

      p = sep;
    } while (sep && total != 0);

  /* In the match_words and match_lines cases, we use a different pattern
     for the DFA matcher that will quickly throw out cases that won't work.
     Then if DFA succeeds we do some hairy stuff using the regex matcher
     to decide whether the match should really count. */
  if (match_words || match_lines)
    {
      static char const line_beg_no_bk[] = "^(";
      static char const line_end_no_bk[] = ")$";
      static char const word_beg_no_bk[] = "(^|[^[:alnum:]_])(";
      static char const word_end_no_bk[] = ")([^[:alnum:]_]|$)";
      static char const line_beg_bk[] = "^\\(";
      static char const line_end_bk[] = "\\)$";
      static char const word_beg_bk[] = "\\(^\\|[^[:alnum:]_]\\)\\(";
      static char const word_end_bk[] = "\\)\\([^[:alnum:]_]\\|$\\)";
      int bk = !(syntax_bits & RE_NO_BK_PARENS);
      char *n = xmalloc (sizeof word_beg_bk - 1 + size + sizeof word_end_bk);

      strcpy (n, match_lines ? (bk ? line_beg_bk : line_beg_no_bk)
			     : (bk ? word_beg_bk : word_beg_no_bk));
      total = strlen(n);
      memcpy (n + total, pattern, size);
      total += size;
      strcpy (n + total, match_lines ? (bk ? line_end_bk : line_end_no_bk)
				     : (bk ? word_end_bk : word_end_no_bk));
      total += strlen (n + total);
      pattern = motif = n;
      size = total;
    }
  else
    motif = NULL;

  dfacomp (pattern, size, &dfa, 1);
  kwsmusts ();

  free(motif);
}

size_t
EGexecute (char const *buf, size_t size, size_t *match_size,
	   char const *start_ptr)
{
  char const *buflim, *beg, *end, *match, *best_match, *mb_start;
  char eol = eolbyte;
  int backref, start, len, best_len;
  struct kwsmatch kwsm;
  size_t i, ret_val;
#ifdef MBS_SUPPORT
  if (MB_CUR_MAX > 1)
    {
      if (match_icase)
        {
          /* mbtolower adds a NUL byte at the end.  That will provide
	     space for the sentinel byte dfaexec may add.  */
          char *case_buf = mbtolower (buf, &size);
	  if (start_ptr)
	    start_ptr = case_buf + (start_ptr - buf);
          buf = case_buf;
        }
    }
#endif /* MBS_SUPPORT */

  mb_start = buf;
  buflim = buf + size;

  for (beg = end = buf; end < buflim; beg = end)
    {
      if (!start_ptr)
	{
	  /* We don't care about an exact match.  */
	  if (kwset)
	    {
	      /* Find a possible match using the KWset matcher. */
	      size_t offset = kwsexec (kwset, beg, buflim - beg, &kwsm);
	      if (offset == (size_t) -1)
		goto failure;
	      beg += offset;
	      /* Narrow down to the line containing the candidate, and
		 run it through DFA. */
	      if ((end = memchr(beg, eol, buflim - beg)) != NULL)
	        end++;
              else
                end = buflim;
	      match = beg;
	      while (beg > buf && beg[-1] != eol)
		--beg;
	      if (kwsm.index < kwset_exact_matches)
                {
#ifdef MBS_SUPPORT
                  if (mb_start < beg)
                    mb_start = beg;
                  if (MB_CUR_MAX == 1 || !is_mb_middle (&mb_start, match, buflim))
#endif
                    goto success;
                }
	      if (dfaexec (&dfa, beg, (char *) end, 0, NULL, &backref) == NULL)
		continue;
	    }
	  else
	    {
	      /* No good fixed strings; start with DFA. */
	      char const *next_beg = dfaexec (&dfa, beg, (char *) buflim,
					      0, NULL, &backref);
	      if (next_beg == NULL)
		break;
	      /* Narrow down to the line we've found. */
	      beg = next_beg;
	      if ((end = memchr(beg, eol, buflim - beg)) != NULL)
	        end++;
              else
                end = buflim;
	      while (beg > buf && beg[-1] != eol)
		--beg;
	    }
	  /* Successful, no backreferences encountered! */
	  if (!backref)
	    goto success;
	}
      else
	{
	  /* We are looking for the leftmost (then longest) exact match.
	     We will go through the outer loop only once.  */
	  beg = start_ptr;
	  end = buflim;
	}

      /* If we've made it to this point, this means DFA has seen
	 a probable match, and we need to run it through Regex. */
      best_match = end;
      best_len = 0;
      for (i = 0; i < pcount; i++)
	{
	  patterns[i].regexbuf.not_eol = 0;
	  if (0 <= (start = re_search (&(patterns[i].regexbuf),
				       buf, end - buf - 1,
				       beg - buf, end - beg - 1,
				       &(patterns[i].regs))))
	    {
	      len = patterns[i].regs.end[0] - start;
	      match = buf + start;
	      if (match > best_match)
		continue;
	      if (start_ptr && !match_words)
		goto assess_pattern_match;
	      if ((!match_lines && !match_words)
		  || (match_lines && len == end - beg - 1))
		{
		  match = beg;
		  len = end - beg;
		  goto assess_pattern_match;
		}
	      /* If -w, check if the match aligns with word boundaries.
		 We do this iteratively because:
		 (a) the line may contain more than one occurence of the
		 pattern, and
		 (b) Several alternatives in the pattern might be valid at a
		 given point, and we may need to consider a shorter one to
		 find a word boundary.  */
	      if (match_words)
		while (match <= best_match)
		  {
		    if ((match == buf || !WCHAR ((unsigned char) match[-1]))
			&& (len == end - beg - 1
			    || !WCHAR ((unsigned char) match[len])))
		      goto assess_pattern_match;
		    if (len > 0)
		      {
			/* Try a shorter length anchored at the same place. */
			--len;
			patterns[i].regexbuf.not_eol = 1;
			len = re_match (&(patterns[i].regexbuf),
					buf, match + len - beg, match - buf,
					&(patterns[i].regs));
		      }
		    if (len <= 0)
		      {
			/* Try looking further on. */
			if (match == end - 1)
			  break;
			match++;
			patterns[i].regexbuf.not_eol = 0;
			start = re_search (&(patterns[i].regexbuf),
					   buf, end - buf - 1,
					   match - buf, end - match - 1,
					   &(patterns[i].regs));
			if (start < 0)
			  break;
			len = patterns[i].regs.end[0] - start;
			match = buf + start;
		      }
		  } /* while (match <= best_match) */
	      continue;
	    assess_pattern_match:
	      if (!start_ptr)
		{
		  /* Good enough for a non-exact match.
		     No need to look at further patterns, if any.  */
		  beg = match;
		  goto success_in_len;
		}
	      if (match < best_match || (match == best_match && len > best_len))
		{
		  /* Best exact match:  leftmost, then longest.  */
		  best_match = match;
		  best_len = len;
		}
	    } /* if re_search >= 0 */
	} /* for Regex patterns.  */
	if (best_match < end)
	  {
	    /* We have found an exact match.  We were just
	       waiting for the best one (leftmost then longest).  */
	    beg = best_match;
	    len = best_len;
	    goto success_in_len;
	  }
    } /* for (beg = end ..) */

 failure:
  ret_val = -1;
  goto out;

 success:
  len = end - beg;
 success_in_len:
  *match_size = len;
  ret_val = beg - buf;
 out:
  return ret_val;
}

Spawn 1 instances, now Total 26
Counter: 27
Batcher Size:26
Preprocess the following candidate with CondTester:
Priority 20000
At location src/dfasearch.c:304
--Src File: src/dfasearch.c
Fragment 0:
if ((match > best_match) && !(__abst_hole(match, best_match, buf, start, start_ptr, len, i, match_words, patterns, match_lines, beg, end, pcount, best_len, buflim, backref, eol, mb_start, kwset_exact_matches, kwset, size, ret_val, match_size, match_icase, eolbyte)))
    continue;


CondTester, a patch instance with id 26:
//src_file:src/dfasearch.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); void* memset(void*, int, unsigned long); 
/* dfasearch.c - searching subroutines using dfa and regex for grep.
   Copyright 1992, 1998, 2000, 2007, 2009-2010 Free Software Foundation, Inc.

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 3, or (at your option)
   any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program; if not, write to the Free Software
   Foundation, Inc., 51 Franklin Street - Fifth Floor, Boston, MA
   02110-1301, USA.  */

/* Written August 1992 by Mike Haertel. */

#include <config.h>
#include "search.h"
#include "dfa.h"

/* For -w, we also consider _ to be word constituent.  */
#define WCHAR(C) (ISALNUM(C) || (C) == '_')

/* KWset compiled pattern.  For Ecompile and Gcompile, we compile
   a list of strings, at least one of which is known to occur in
   any string matching the regexp. */
static kwset_t kwset;

/* DFA compiled regexp. */
static struct dfa dfa;

/* The Regex compiled patterns.  */
static struct patterns
{
  /* Regex compiled regexp. */
  struct re_pattern_buffer regexbuf;
  struct re_registers regs; /* This is here on account of a BRAIN-DEAD
			       Q@#%!# library interface in regex.c.  */
} patterns0;

struct patterns *patterns;
size_t pcount;

void
dfaerror (char const *mesg)
{
  error (EXIT_TROUBLE, 0, "%s", mesg);

  /* notreached */
  /* Tell static analyzers that this function does not return.  */
  abort ();
}

/* Number of compiled fixed strings known to exactly match the regexp.
   If kwsexec returns < kwset_exact_matches, then we don't need to
   call the regexp matcher at all. */
static int kwset_exact_matches;

static char const *
kwsincr_case (const char *must)
{
  const char *buf;
  size_t n;

  n = strlen (must);
#ifdef MBS_SUPPORT
  if (match_icase && MB_CUR_MAX > 1)
    buf = mbtolower (must, &n);
  else
#endif
    buf = must;
  return kwsincr (kwset, buf, n);
}

/* If the DFA turns out to have some set of fixed strings one of
   which must occur in the match, then we build a kwset matcher
   to find those strings, and thus quickly filter out impossible
   matches. */
static void
kwsmusts (void)
{
  struct dfamust const *dm;
  char const *err;

  if (dfa.musts)
    {
      kwsinit (&kwset);
      /* First, we compile in the substrings known to be exact
	 matches.  The kwset matcher will return the index
	 of the matching string that it chooses. */
      for (dm = dfa.musts; dm; dm = dm->next)
	{
	  if (!dm->exact)
	    continue;
	  ++kwset_exact_matches;
	  if ((err = kwsincr_case (dm->must)) != NULL)
	    error (EXIT_TROUBLE, 0, "%s", err);
	}
      /* Now, we compile the substrings that will require
	 the use of the regexp matcher.  */
      for (dm = dfa.musts; dm; dm = dm->next)
	{
	  if (dm->exact)
	    continue;
	  if ((err = kwsincr_case (dm->must)) != NULL)
	    error (EXIT_TROUBLE, 0, "%s", err);
	}
      if ((err = kwsprep (kwset)) != NULL)
	error (EXIT_TROUBLE, 0, "%s", err);
    }
}

void
GEAcompile (char const *pattern, size_t size, reg_syntax_t syntax_bits)
{
  const char *err;
  const char *p, *sep;
  size_t total = size;
  char *motif;

  if (match_icase)
    syntax_bits |= RE_ICASE;
  re_set_syntax (syntax_bits);
  dfasyntax (syntax_bits, match_icase, eolbyte);

  /* For GNU regex compiler we have to pass the patterns separately to detect
     errors like "[\nallo\n]\n".  The patterns here are "[", "allo" and "]"
     GNU regex should have raise a syntax error.  The same for backref, where
     the backref should have been local to each pattern.  */
  p = pattern;
  do
    {
      size_t len;
      sep = memchr (p, '\n', total);
      if (sep)
	{
	  len = sep - p;
	  sep++;
	  total -= (len + 1);
	}
      else
	{
	  len = total;
	  total = 0;
	}

      patterns = realloc (patterns, (pcount + 1) * sizeof (*patterns));
      if (patterns == NULL)
	error (EXIT_TROUBLE, errno, _("memory exhausted"));
      patterns[pcount] = patterns0;

      if ((err = re_compile_pattern (p, len,
				    &(patterns[pcount].regexbuf))) != NULL)
	error (EXIT_TROUBLE, 0, "%s", err);
      pcount++;

      p = sep;
    } while (sep && total != 0);

  /* In the match_words and match_lines cases, we use a different pattern
     for the DFA matcher that will quickly throw out cases that won't work.
     Then if DFA succeeds we do some hairy stuff using the regex matcher
     to decide whether the match should really count. */
  if (match_words || match_lines)
    {
      static char const line_beg_no_bk[] = "^(";
      static char const line_end_no_bk[] = ")$";
      static char const word_beg_no_bk[] = "(^|[^[:alnum:]_])(";
      static char const word_end_no_bk[] = ")([^[:alnum:]_]|$)";
      static char const line_beg_bk[] = "^\\(";
      static char const line_end_bk[] = "\\)$";
      static char const word_beg_bk[] = "\\(^\\|[^[:alnum:]_]\\)\\(";
      static char const word_end_bk[] = "\\)\\([^[:alnum:]_]\\|$\\)";
      int bk = !(syntax_bits & RE_NO_BK_PARENS);
      char *n = xmalloc (sizeof word_beg_bk - 1 + size + sizeof word_end_bk);

      strcpy (n, match_lines ? (bk ? line_beg_bk : line_beg_no_bk)
			     : (bk ? word_beg_bk : word_beg_no_bk));
      total = strlen(n);
      memcpy (n + total, pattern, size);
      total += size;
      strcpy (n + total, match_lines ? (bk ? line_end_bk : line_end_no_bk)
				     : (bk ? word_end_bk : word_end_no_bk));
      total += strlen (n + total);
      pattern = motif = n;
      size = total;
    }
  else
    motif = NULL;

  dfacomp (pattern, size, &dfa, 1);
  kwsmusts ();

  free(motif);
}

size_t
EGexecute (char const *buf, size_t size, size_t *match_size,
	   char const *start_ptr)
{
  char const *buflim, *beg, *end, *match, *best_match, *mb_start;
  char eol = eolbyte;
  int backref, start, len, best_len;
  struct kwsmatch kwsm;
  size_t i, ret_val;
#ifdef MBS_SUPPORT
  if (MB_CUR_MAX > 1)
    {
      if (match_icase)
        {
          /* mbtolower adds a NUL byte at the end.  That will provide
	     space for the sentinel byte dfaexec may add.  */
          char *case_buf = mbtolower (buf, &size);
	  if (start_ptr)
	    start_ptr = case_buf + (start_ptr - buf);
          buf = case_buf;
        }
    }
#endif /* MBS_SUPPORT */

  mb_start = buf;
  buflim = buf + size;

  for (beg = end = buf; end < buflim; beg = end)
    {
      if (!start_ptr)
	{
	  /* We don't care about an exact match.  */
	  if (kwset)
	    {
	      /* Find a possible match using the KWset matcher. */
	      size_t offset = kwsexec (kwset, beg, buflim - beg, &kwsm);
	      if (offset == (size_t) -1)
		goto failure;
	      beg += offset;
	      /* Narrow down to the line containing the candidate, and
		 run it through DFA. */
	      if ((end = memchr(beg, eol, buflim - beg)) != NULL)
	        end++;
              else
                end = buflim;
	      match = beg;
	      while (beg > buf && beg[-1] != eol)
		--beg;
	      if (kwsm.index < kwset_exact_matches)
                {
#ifdef MBS_SUPPORT
                  if (mb_start < beg)
                    mb_start = beg;
                  if (MB_CUR_MAX == 1 || !is_mb_middle (&mb_start, match, buflim))
#endif
                    goto success;
                }
	      if (dfaexec (&dfa, beg, (char *) end, 0, NULL, &backref) == NULL)
		continue;
	    }
	  else
	    {
	      /* No good fixed strings; start with DFA. */
	      char const *next_beg = dfaexec (&dfa, beg, (char *) buflim,
					      0, NULL, &backref);
	      if (next_beg == NULL)
		break;
	      /* Narrow down to the line we've found. */
	      beg = next_beg;
	      if ((end = memchr(beg, eol, buflim - beg)) != NULL)
	        end++;
              else
                end = buflim;
	      while (beg > buf && beg[-1] != eol)
		--beg;
	    }
	  /* Successful, no backreferences encountered! */
	  if (!backref)
	    goto success;
	}
      else
	{
	  /* We are looking for the leftmost (then longest) exact match.
	     We will go through the outer loop only once.  */
	  beg = start_ptr;
	  end = buflim;
	}

      /* If we've made it to this point, this means DFA has seen
	 a probable match, and we need to run it through Regex. */
      best_match = end;
      best_len = 0;
      for (i = 0; i < pcount; i++)
	{
	  patterns[i].regexbuf.not_eol = 0;
	  if (0 <= (start = re_search (&(patterns[i].regexbuf),
				       buf, end - buf - 1,
				       beg - buf, end - beg - 1,
				       &(patterns[i].regs))))
	    {
	      len = patterns[i].regs.end[0] - start;
	      match = buf + start;
	      
//Patch 0:
if ((match > best_match) && !(__is_neg(25, &(match), sizeof (match), &(best_match), sizeof (best_match), &(buf), sizeof (buf), &(start), sizeof (start), &(start_ptr), sizeof (start_ptr), &(len), sizeof (len), &(i), sizeof (i), &(match_words), sizeof (match_words), &(patterns), sizeof (patterns), &(match_lines), sizeof (match_lines), &(beg), sizeof (beg), &(end), sizeof (end), &(pcount), sizeof (pcount), &(best_len), sizeof (best_len), &(buflim), sizeof (buflim), &(backref), sizeof (backref), &(eol), sizeof (eol), &(mb_start), sizeof (mb_start), &(kwset_exact_matches), sizeof (kwset_exact_matches), &(kwset), sizeof (kwset), &(size), sizeof (size), &(ret_val), sizeof (ret_val), &(match_size), sizeof (match_size), &(match_icase), sizeof (match_icase), &(eolbyte), sizeof (eolbyte))))
    continue;

//CodeSeg 1:
	      if (start_ptr && !match_words)
		goto assess_pattern_match;
	      if ((!match_lines && !match_words)
		  || (match_lines && len == end - beg - 1))
		{
		  match = beg;
		  len = end - beg;
		  goto assess_pattern_match;
		}
	      /* If -w, check if the match aligns with word boundaries.
		 We do this iteratively because:
		 (a) the line may contain more than one occurence of the
		 pattern, and
		 (b) Several alternatives in the pattern might be valid at a
		 given point, and we may need to consider a shorter one to
		 find a word boundary.  */
	      if (match_words)
		while (match <= best_match)
		  {
		    if ((match == buf || !WCHAR ((unsigned char) match[-1]))
			&& (len == end - beg - 1
			    || !WCHAR ((unsigned char) match[len])))
		      goto assess_pattern_match;
		    if (len > 0)
		      {
			/* Try a shorter length anchored at the same place. */
			--len;
			patterns[i].regexbuf.not_eol = 1;
			len = re_match (&(patterns[i].regexbuf),
					buf, match + len - beg, match - buf,
					&(patterns[i].regs));
		      }
		    if (len <= 0)
		      {
			/* Try looking further on. */
			if (match == end - 1)
			  break;
			match++;
			patterns[i].regexbuf.not_eol = 0;
			start = re_search (&(patterns[i].regexbuf),
					   buf, end - buf - 1,
					   match - buf, end - match - 1,
					   &(patterns[i].regs));
			if (start < 0)
			  break;
			len = patterns[i].regs.end[0] - start;
			match = buf + start;
		      }
		  } /* while (match <= best_match) */
	      continue;
	    assess_pattern_match:
	      if (!start_ptr)
		{
		  /* Good enough for a non-exact match.
		     No need to look at further patterns, if any.  */
		  beg = match;
		  goto success_in_len;
		}
	      if (match < best_match || (match == best_match && len > best_len))
		{
		  /* Best exact match:  leftmost, then longest.  */
		  best_match = match;
		  best_len = len;
		}
	    } /* if re_search >= 0 */
	} /* for Regex patterns.  */
	if (best_match < end)
	  {
	    /* We have found an exact match.  We were just
	       waiting for the best one (leftmost then longest).  */
	    beg = best_match;
	    len = best_len;
	    goto success_in_len;
	  }
    } /* for (beg = end ..) */

 failure:
  ret_val = -1;
  goto out;

 success:
  len = end - beg;
 success_in_len:
  *match_size = len;
  ret_val = beg - buf;
 out:
  return ret_val;
}

Spawn 1 instances, now Total 27
Counter: 28
Batcher Size:27
Preprocess the following candidate with CondTester:
Priority 20000
At location src/dfasearch.c:304
--Src File: src/dfasearch.c
Fragment 0:
if ((match > best_match) || (__abst_hole(match, best_match, buf, start, start_ptr, len, i, match_words, patterns, match_lines, beg, end, pcount, best_len, buflim, backref, eol, mb_start, kwset_exact_matches, kwset, size, ret_val, match_size, match_icase, eolbyte)))
    continue;


CondTester, a patch instance with id 27:
//src_file:src/dfasearch.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); void* memset(void*, int, unsigned long); 
/* dfasearch.c - searching subroutines using dfa and regex for grep.
   Copyright 1992, 1998, 2000, 2007, 2009-2010 Free Software Foundation, Inc.

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 3, or (at your option)
   any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program; if not, write to the Free Software
   Foundation, Inc., 51 Franklin Street - Fifth Floor, Boston, MA
   02110-1301, USA.  */

/* Written August 1992 by Mike Haertel. */

#include <config.h>
#include "search.h"
#include "dfa.h"

/* For -w, we also consider _ to be word constituent.  */
#define WCHAR(C) (ISALNUM(C) || (C) == '_')

/* KWset compiled pattern.  For Ecompile and Gcompile, we compile
   a list of strings, at least one of which is known to occur in
   any string matching the regexp. */
static kwset_t kwset;

/* DFA compiled regexp. */
static struct dfa dfa;

/* The Regex compiled patterns.  */
static struct patterns
{
  /* Regex compiled regexp. */
  struct re_pattern_buffer regexbuf;
  struct re_registers regs; /* This is here on account of a BRAIN-DEAD
			       Q@#%!# library interface in regex.c.  */
} patterns0;

struct patterns *patterns;
size_t pcount;

void
dfaerror (char const *mesg)
{
  error (EXIT_TROUBLE, 0, "%s", mesg);

  /* notreached */
  /* Tell static analyzers that this function does not return.  */
  abort ();
}

/* Number of compiled fixed strings known to exactly match the regexp.
   If kwsexec returns < kwset_exact_matches, then we don't need to
   call the regexp matcher at all. */
static int kwset_exact_matches;

static char const *
kwsincr_case (const char *must)
{
  const char *buf;
  size_t n;

  n = strlen (must);
#ifdef MBS_SUPPORT
  if (match_icase && MB_CUR_MAX > 1)
    buf = mbtolower (must, &n);
  else
#endif
    buf = must;
  return kwsincr (kwset, buf, n);
}

/* If the DFA turns out to have some set of fixed strings one of
   which must occur in the match, then we build a kwset matcher
   to find those strings, and thus quickly filter out impossible
   matches. */
static void
kwsmusts (void)
{
  struct dfamust const *dm;
  char const *err;

  if (dfa.musts)
    {
      kwsinit (&kwset);
      /* First, we compile in the substrings known to be exact
	 matches.  The kwset matcher will return the index
	 of the matching string that it chooses. */
      for (dm = dfa.musts; dm; dm = dm->next)
	{
	  if (!dm->exact)
	    continue;
	  ++kwset_exact_matches;
	  if ((err = kwsincr_case (dm->must)) != NULL)
	    error (EXIT_TROUBLE, 0, "%s", err);
	}
      /* Now, we compile the substrings that will require
	 the use of the regexp matcher.  */
      for (dm = dfa.musts; dm; dm = dm->next)
	{
	  if (dm->exact)
	    continue;
	  if ((err = kwsincr_case (dm->must)) != NULL)
	    error (EXIT_TROUBLE, 0, "%s", err);
	}
      if ((err = kwsprep (kwset)) != NULL)
	error (EXIT_TROUBLE, 0, "%s", err);
    }
}

void
GEAcompile (char const *pattern, size_t size, reg_syntax_t syntax_bits)
{
  const char *err;
  const char *p, *sep;
  size_t total = size;
  char *motif;

  if (match_icase)
    syntax_bits |= RE_ICASE;
  re_set_syntax (syntax_bits);
  dfasyntax (syntax_bits, match_icase, eolbyte);

  /* For GNU regex compiler we have to pass the patterns separately to detect
     errors like "[\nallo\n]\n".  The patterns here are "[", "allo" and "]"
     GNU regex should have raise a syntax error.  The same for backref, where
     the backref should have been local to each pattern.  */
  p = pattern;
  do
    {
      size_t len;
      sep = memchr (p, '\n', total);
      if (sep)
	{
	  len = sep - p;
	  sep++;
	  total -= (len + 1);
	}
      else
	{
	  len = total;
	  total = 0;
	}

      patterns = realloc (patterns, (pcount + 1) * sizeof (*patterns));
      if (patterns == NULL)
	error (EXIT_TROUBLE, errno, _("memory exhausted"));
      patterns[pcount] = patterns0;

      if ((err = re_compile_pattern (p, len,
				    &(patterns[pcount].regexbuf))) != NULL)
	error (EXIT_TROUBLE, 0, "%s", err);
      pcount++;

      p = sep;
    } while (sep && total != 0);

  /* In the match_words and match_lines cases, we use a different pattern
     for the DFA matcher that will quickly throw out cases that won't work.
     Then if DFA succeeds we do some hairy stuff using the regex matcher
     to decide whether the match should really count. */
  if (match_words || match_lines)
    {
      static char const line_beg_no_bk[] = "^(";
      static char const line_end_no_bk[] = ")$";
      static char const word_beg_no_bk[] = "(^|[^[:alnum:]_])(";
      static char const word_end_no_bk[] = ")([^[:alnum:]_]|$)";
      static char const line_beg_bk[] = "^\\(";
      static char const line_end_bk[] = "\\)$";
      static char const word_beg_bk[] = "\\(^\\|[^[:alnum:]_]\\)\\(";
      static char const word_end_bk[] = "\\)\\([^[:alnum:]_]\\|$\\)";
      int bk = !(syntax_bits & RE_NO_BK_PARENS);
      char *n = xmalloc (sizeof word_beg_bk - 1 + size + sizeof word_end_bk);

      strcpy (n, match_lines ? (bk ? line_beg_bk : line_beg_no_bk)
			     : (bk ? word_beg_bk : word_beg_no_bk));
      total = strlen(n);
      memcpy (n + total, pattern, size);
      total += size;
      strcpy (n + total, match_lines ? (bk ? line_end_bk : line_end_no_bk)
				     : (bk ? word_end_bk : word_end_no_bk));
      total += strlen (n + total);
      pattern = motif = n;
      size = total;
    }
  else
    motif = NULL;

  dfacomp (pattern, size, &dfa, 1);
  kwsmusts ();

  free(motif);
}

size_t
EGexecute (char const *buf, size_t size, size_t *match_size,
	   char const *start_ptr)
{
  char const *buflim, *beg, *end, *match, *best_match, *mb_start;
  char eol = eolbyte;
  int backref, start, len, best_len;
  struct kwsmatch kwsm;
  size_t i, ret_val;
#ifdef MBS_SUPPORT
  if (MB_CUR_MAX > 1)
    {
      if (match_icase)
        {
          /* mbtolower adds a NUL byte at the end.  That will provide
	     space for the sentinel byte dfaexec may add.  */
          char *case_buf = mbtolower (buf, &size);
	  if (start_ptr)
	    start_ptr = case_buf + (start_ptr - buf);
          buf = case_buf;
        }
    }
#endif /* MBS_SUPPORT */

  mb_start = buf;
  buflim = buf + size;

  for (beg = end = buf; end < buflim; beg = end)
    {
      if (!start_ptr)
	{
	  /* We don't care about an exact match.  */
	  if (kwset)
	    {
	      /* Find a possible match using the KWset matcher. */
	      size_t offset = kwsexec (kwset, beg, buflim - beg, &kwsm);
	      if (offset == (size_t) -1)
		goto failure;
	      beg += offset;
	      /* Narrow down to the line containing the candidate, and
		 run it through DFA. */
	      if ((end = memchr(beg, eol, buflim - beg)) != NULL)
	        end++;
              else
                end = buflim;
	      match = beg;
	      while (beg > buf && beg[-1] != eol)
		--beg;
	      if (kwsm.index < kwset_exact_matches)
                {
#ifdef MBS_SUPPORT
                  if (mb_start < beg)
                    mb_start = beg;
                  if (MB_CUR_MAX == 1 || !is_mb_middle (&mb_start, match, buflim))
#endif
                    goto success;
                }
	      if (dfaexec (&dfa, beg, (char *) end, 0, NULL, &backref) == NULL)
		continue;
	    }
	  else
	    {
	      /* No good fixed strings; start with DFA. */
	      char const *next_beg = dfaexec (&dfa, beg, (char *) buflim,
					      0, NULL, &backref);
	      if (next_beg == NULL)
		break;
	      /* Narrow down to the line we've found. */
	      beg = next_beg;
	      if ((end = memchr(beg, eol, buflim - beg)) != NULL)
	        end++;
              else
                end = buflim;
	      while (beg > buf && beg[-1] != eol)
		--beg;
	    }
	  /* Successful, no backreferences encountered! */
	  if (!backref)
	    goto success;
	}
      else
	{
	  /* We are looking for the leftmost (then longest) exact match.
	     We will go through the outer loop only once.  */
	  beg = start_ptr;
	  end = buflim;
	}

      /* If we've made it to this point, this means DFA has seen
	 a probable match, and we need to run it through Regex. */
      best_match = end;
      best_len = 0;
      for (i = 0; i < pcount; i++)
	{
	  patterns[i].regexbuf.not_eol = 0;
	  if (0 <= (start = re_search (&(patterns[i].regexbuf),
				       buf, end - buf - 1,
				       beg - buf, end - beg - 1,
				       &(patterns[i].regs))))
	    {
	      len = patterns[i].regs.end[0] - start;
	      match = buf + start;
	      
//Patch 0:
if ((match > best_match) || (__is_neg(25, &(match), sizeof (match), &(best_match), sizeof (best_match), &(buf), sizeof (buf), &(start), sizeof (start), &(start_ptr), sizeof (start_ptr), &(len), sizeof (len), &(i), sizeof (i), &(match_words), sizeof (match_words), &(patterns), sizeof (patterns), &(match_lines), sizeof (match_lines), &(beg), sizeof (beg), &(end), sizeof (end), &(pcount), sizeof (pcount), &(best_len), sizeof (best_len), &(buflim), sizeof (buflim), &(backref), sizeof (backref), &(eol), sizeof (eol), &(mb_start), sizeof (mb_start), &(kwset_exact_matches), sizeof (kwset_exact_matches), &(kwset), sizeof (kwset), &(size), sizeof (size), &(ret_val), sizeof (ret_val), &(match_size), sizeof (match_size), &(match_icase), sizeof (match_icase), &(eolbyte), sizeof (eolbyte))))
    continue;

//CodeSeg 1:
	      if (start_ptr && !match_words)
		goto assess_pattern_match;
	      if ((!match_lines && !match_words)
		  || (match_lines && len == end - beg - 1))
		{
		  match = beg;
		  len = end - beg;
		  goto assess_pattern_match;
		}
	      /* If -w, check if the match aligns with word boundaries.
		 We do this iteratively because:
		 (a) the line may contain more than one occurence of the
		 pattern, and
		 (b) Several alternatives in the pattern might be valid at a
		 given point, and we may need to consider a shorter one to
		 find a word boundary.  */
	      if (match_words)
		while (match <= best_match)
		  {
		    if ((match == buf || !WCHAR ((unsigned char) match[-1]))
			&& (len == end - beg - 1
			    || !WCHAR ((unsigned char) match[len])))
		      goto assess_pattern_match;
		    if (len > 0)
		      {
			/* Try a shorter length anchored at the same place. */
			--len;
			patterns[i].regexbuf.not_eol = 1;
			len = re_match (&(patterns[i].regexbuf),
					buf, match + len - beg, match - buf,
					&(patterns[i].regs));
		      }
		    if (len <= 0)
		      {
			/* Try looking further on. */
			if (match == end - 1)
			  break;
			match++;
			patterns[i].regexbuf.not_eol = 0;
			start = re_search (&(patterns[i].regexbuf),
					   buf, end - buf - 1,
					   match - buf, end - match - 1,
					   &(patterns[i].regs));
			if (start < 0)
			  break;
			len = patterns[i].regs.end[0] - start;
			match = buf + start;
		      }
		  } /* while (match <= best_match) */
	      continue;
	    assess_pattern_match:
	      if (!start_ptr)
		{
		  /* Good enough for a non-exact match.
		     No need to look at further patterns, if any.  */
		  beg = match;
		  goto success_in_len;
		}
	      if (match < best_match || (match == best_match && len > best_len))
		{
		  /* Best exact match:  leftmost, then longest.  */
		  best_match = match;
		  best_len = len;
		}
	    } /* if re_search >= 0 */
	} /* for Regex patterns.  */
	if (best_match < end)
	  {
	    /* We have found an exact match.  We were just
	       waiting for the best one (leftmost then longest).  */
	    beg = best_match;
	    len = best_len;
	    goto success_in_len;
	  }
    } /* for (beg = end ..) */

 failure:
  ret_val = -1;
  goto out;

 success:
  len = end - beg;
 success_in_len:
  *match_size = len;
  ret_val = beg - buf;
 out:
  return ret_val;
}

Spawn 1 instances, now Total 28
Counter: 29
Batcher Size:28
Preprocess the following candidate with CondTester:
Priority 20000
At location src/dfasearch.c:72
--Src File: src/dfasearch.c
Fragment 0:
if ((match_icase && (__ctype_get_mb_cur_max()) > 1) || (__abst_hole(match_icase, must, buf, n, kwset)))
    buf = mbtolower(must, &n);
else
    buf = must;


CondTester, a patch instance with id 28:
//src_file:src/dfasearch.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); void* memset(void*, int, unsigned long); 
/* dfasearch.c - searching subroutines using dfa and regex for grep.
   Copyright 1992, 1998, 2000, 2007, 2009-2010 Free Software Foundation, Inc.

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 3, or (at your option)
   any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program; if not, write to the Free Software
   Foundation, Inc., 51 Franklin Street - Fifth Floor, Boston, MA
   02110-1301, USA.  */

/* Written August 1992 by Mike Haertel. */

#include <config.h>
#include "search.h"
#include "dfa.h"

/* For -w, we also consider _ to be word constituent.  */
#define WCHAR(C) (ISALNUM(C) || (C) == '_')

/* KWset compiled pattern.  For Ecompile and Gcompile, we compile
   a list of strings, at least one of which is known to occur in
   any string matching the regexp. */
static kwset_t kwset;

/* DFA compiled regexp. */
static struct dfa dfa;

/* The Regex compiled patterns.  */
static struct patterns
{
  /* Regex compiled regexp. */
  struct re_pattern_buffer regexbuf;
  struct re_registers regs; /* This is here on account of a BRAIN-DEAD
			       Q@#%!# library interface in regex.c.  */
} patterns0;

struct patterns *patterns;
size_t pcount;

void
dfaerror (char const *mesg)
{
  error (EXIT_TROUBLE, 0, "%s", mesg);

  /* notreached */
  /* Tell static analyzers that this function does not return.  */
  abort ();
}

/* Number of compiled fixed strings known to exactly match the regexp.
   If kwsexec returns < kwset_exact_matches, then we don't need to
   call the regexp matcher at all. */
static int kwset_exact_matches;

static char const *
kwsincr_case (const char *must)
{
  const char *buf;
  size_t n;

  n = strlen (must);
#ifdef MBS_SUPPORT
  
//Patch 0:
if ((match_icase && (__ctype_get_mb_cur_max()) > 1) || (__is_neg(5, &(match_icase), sizeof (match_icase), &(must), sizeof (must), &(buf), sizeof (buf), &(n), sizeof (n), &(kwset), sizeof (kwset))))
    buf = mbtolower(must, &n);
else
    buf = must;

//CodeSeg 1:
  return kwsincr (kwset, buf, n);
}

/* If the DFA turns out to have some set of fixed strings one of
   which must occur in the match, then we build a kwset matcher
   to find those strings, and thus quickly filter out impossible
   matches. */
static void
kwsmusts (void)
{
  struct dfamust const *dm;
  char const *err;

  if (dfa.musts)
    {
      kwsinit (&kwset);
      /* First, we compile in the substrings known to be exact
	 matches.  The kwset matcher will return the index
	 of the matching string that it chooses. */
      for (dm = dfa.musts; dm; dm = dm->next)
	{
	  if (!dm->exact)
	    continue;
	  ++kwset_exact_matches;
	  if ((err = kwsincr_case (dm->must)) != NULL)
	    error (EXIT_TROUBLE, 0, "%s", err);
	}
      /* Now, we compile the substrings that will require
	 the use of the regexp matcher.  */
      for (dm = dfa.musts; dm; dm = dm->next)
	{
	  if (dm->exact)
	    continue;
	  if ((err = kwsincr_case (dm->must)) != NULL)
	    error (EXIT_TROUBLE, 0, "%s", err);
	}
      if ((err = kwsprep (kwset)) != NULL)
	error (EXIT_TROUBLE, 0, "%s", err);
    }
}

void
GEAcompile (char const *pattern, size_t size, reg_syntax_t syntax_bits)
{
  const char *err;
  const char *p, *sep;
  size_t total = size;
  char *motif;

  if (match_icase)
    syntax_bits |= RE_ICASE;
  re_set_syntax (syntax_bits);
  dfasyntax (syntax_bits, match_icase, eolbyte);

  /* For GNU regex compiler we have to pass the patterns separately to detect
     errors like "[\nallo\n]\n".  The patterns here are "[", "allo" and "]"
     GNU regex should have raise a syntax error.  The same for backref, where
     the backref should have been local to each pattern.  */
  p = pattern;
  do
    {
      size_t len;
      sep = memchr (p, '\n', total);
      if (sep)
	{
	  len = sep - p;
	  sep++;
	  total -= (len + 1);
	}
      else
	{
	  len = total;
	  total = 0;
	}

      patterns = realloc (patterns, (pcount + 1) * sizeof (*patterns));
      if (patterns == NULL)
	error (EXIT_TROUBLE, errno, _("memory exhausted"));
      patterns[pcount] = patterns0;

      if ((err = re_compile_pattern (p, len,
				    &(patterns[pcount].regexbuf))) != NULL)
	error (EXIT_TROUBLE, 0, "%s", err);
      pcount++;

      p = sep;
    } while (sep && total != 0);

  /* In the match_words and match_lines cases, we use a different pattern
     for the DFA matcher that will quickly throw out cases that won't work.
     Then if DFA succeeds we do some hairy stuff using the regex matcher
     to decide whether the match should really count. */
  if (match_words || match_lines)
    {
      static char const line_beg_no_bk[] = "^(";
      static char const line_end_no_bk[] = ")$";
      static char const word_beg_no_bk[] = "(^|[^[:alnum:]_])(";
      static char const word_end_no_bk[] = ")([^[:alnum:]_]|$)";
      static char const line_beg_bk[] = "^\\(";
      static char const line_end_bk[] = "\\)$";
      static char const word_beg_bk[] = "\\(^\\|[^[:alnum:]_]\\)\\(";
      static char const word_end_bk[] = "\\)\\([^[:alnum:]_]\\|$\\)";
      int bk = !(syntax_bits & RE_NO_BK_PARENS);
      char *n = xmalloc (sizeof word_beg_bk - 1 + size + sizeof word_end_bk);

      strcpy (n, match_lines ? (bk ? line_beg_bk : line_beg_no_bk)
			     : (bk ? word_beg_bk : word_beg_no_bk));
      total = strlen(n);
      memcpy (n + total, pattern, size);
      total += size;
      strcpy (n + total, match_lines ? (bk ? line_end_bk : line_end_no_bk)
				     : (bk ? word_end_bk : word_end_no_bk));
      total += strlen (n + total);
      pattern = motif = n;
      size = total;
    }
  else
    motif = NULL;

  dfacomp (pattern, size, &dfa, 1);
  kwsmusts ();

  free(motif);
}

size_t
EGexecute (char const *buf, size_t size, size_t *match_size,
	   char const *start_ptr)
{
  char const *buflim, *beg, *end, *match, *best_match, *mb_start;
  char eol = eolbyte;
  int backref, start, len, best_len;
  struct kwsmatch kwsm;
  size_t i, ret_val;
#ifdef MBS_SUPPORT
  if (MB_CUR_MAX > 1)
    {
      if (match_icase)
        {
          /* mbtolower adds a NUL byte at the end.  That will provide
	     space for the sentinel byte dfaexec may add.  */
          char *case_buf = mbtolower (buf, &size);
	  if (start_ptr)
	    start_ptr = case_buf + (start_ptr - buf);
          buf = case_buf;
        }
    }
#endif /* MBS_SUPPORT */

  mb_start = buf;
  buflim = buf + size;

  for (beg = end = buf; end < buflim; beg = end)
    {
      if (!start_ptr)
	{
	  /* We don't care about an exact match.  */
	  if (kwset)
	    {
	      /* Find a possible match using the KWset matcher. */
	      size_t offset = kwsexec (kwset, beg, buflim - beg, &kwsm);
	      if (offset == (size_t) -1)
		goto failure;
	      beg += offset;
	      /* Narrow down to the line containing the candidate, and
		 run it through DFA. */
	      if ((end = memchr(beg, eol, buflim - beg)) != NULL)
	        end++;
              else
                end = buflim;
	      match = beg;
	      while (beg > buf && beg[-1] != eol)
		--beg;
	      if (kwsm.index < kwset_exact_matches)
                {
#ifdef MBS_SUPPORT
                  if (mb_start < beg)
                    mb_start = beg;
                  if (MB_CUR_MAX == 1 || !is_mb_middle (&mb_start, match, buflim))
#endif
                    goto success;
                }
	      if (dfaexec (&dfa, beg, (char *) end, 0, NULL, &backref) == NULL)
		continue;
	    }
	  else
	    {
	      /* No good fixed strings; start with DFA. */
	      char const *next_beg = dfaexec (&dfa, beg, (char *) buflim,
					      0, NULL, &backref);
	      if (next_beg == NULL)
		break;
	      /* Narrow down to the line we've found. */
	      beg = next_beg;
	      if ((end = memchr(beg, eol, buflim - beg)) != NULL)
	        end++;
              else
                end = buflim;
	      while (beg > buf && beg[-1] != eol)
		--beg;
	    }
	  /* Successful, no backreferences encountered! */
	  if (!backref)
	    goto success;
	}
      else
	{
	  /* We are looking for the leftmost (then longest) exact match.
	     We will go through the outer loop only once.  */
	  beg = start_ptr;
	  end = buflim;
	}

      /* If we've made it to this point, this means DFA has seen
	 a probable match, and we need to run it through Regex. */
      best_match = end;
      best_len = 0;
      for (i = 0; i < pcount; i++)
	{
	  patterns[i].regexbuf.not_eol = 0;
	  if (0 <= (start = re_search (&(patterns[i].regexbuf),
				       buf, end - buf - 1,
				       beg - buf, end - beg - 1,
				       &(patterns[i].regs))))
	    {
	      len = patterns[i].regs.end[0] - start;
	      match = buf + start;
	      if (match > best_match)
		continue;
	      if (start_ptr && !match_words)
		goto assess_pattern_match;
	      if ((!match_lines && !match_words)
		  || (match_lines && len == end - beg - 1))
		{
		  match = beg;
		  len = end - beg;
		  goto assess_pattern_match;
		}
	      /* If -w, check if the match aligns with word boundaries.
		 We do this iteratively because:
		 (a) the line may contain more than one occurence of the
		 pattern, and
		 (b) Several alternatives in the pattern might be valid at a
		 given point, and we may need to consider a shorter one to
		 find a word boundary.  */
	      if (match_words)
		while (match <= best_match)
		  {
		    if ((match == buf || !WCHAR ((unsigned char) match[-1]))
			&& (len == end - beg - 1
			    || !WCHAR ((unsigned char) match[len])))
		      goto assess_pattern_match;
		    if (len > 0)
		      {
			/* Try a shorter length anchored at the same place. */
			--len;
			patterns[i].regexbuf.not_eol = 1;
			len = re_match (&(patterns[i].regexbuf),
					buf, match + len - beg, match - buf,
					&(patterns[i].regs));
		      }
		    if (len <= 0)
		      {
			/* Try looking further on. */
			if (match == end - 1)
			  break;
			match++;
			patterns[i].regexbuf.not_eol = 0;
			start = re_search (&(patterns[i].regexbuf),
					   buf, end - buf - 1,
					   match - buf, end - match - 1,
					   &(patterns[i].regs));
			if (start < 0)
			  break;
			len = patterns[i].regs.end[0] - start;
			match = buf + start;
		      }
		  } /* while (match <= best_match) */
	      continue;
	    assess_pattern_match:
	      if (!start_ptr)
		{
		  /* Good enough for a non-exact match.
		     No need to look at further patterns, if any.  */
		  beg = match;
		  goto success_in_len;
		}
	      if (match < best_match || (match == best_match && len > best_len))
		{
		  /* Best exact match:  leftmost, then longest.  */
		  best_match = match;
		  best_len = len;
		}
	    } /* if re_search >= 0 */
	} /* for Regex patterns.  */
	if (best_match < end)
	  {
	    /* We have found an exact match.  We were just
	       waiting for the best one (leftmost then longest).  */
	    beg = best_match;
	    len = best_len;
	    goto success_in_len;
	  }
    } /* for (beg = end ..) */

 failure:
  ret_val = -1;
  goto out;

 success:
  len = end - beg;
 success_in_len:
  *match_size = len;
  ret_val = beg - buf;
 out:
  return ret_val;
}

Spawn 1 instances, now Total 29
Counter: 30
Batcher Size:29
Preprocess the following candidate with CondTester:
Priority 20000
At location src/dfasearch.c:108
--Src File: src/dfasearch.c
Fragment 0:
if ((dm->exact) && !(__abst_hole(dm, dm->exact, err, dm->must, dm->next, kwset, kwset_exact_matches)))
    continue;


CondTester, a patch instance with id 29:
//src_file:src/dfasearch.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); void* memset(void*, int, unsigned long); 
/* dfasearch.c - searching subroutines using dfa and regex for grep.
   Copyright 1992, 1998, 2000, 2007, 2009-2010 Free Software Foundation, Inc.

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 3, or (at your option)
   any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program; if not, write to the Free Software
   Foundation, Inc., 51 Franklin Street - Fifth Floor, Boston, MA
   02110-1301, USA.  */

/* Written August 1992 by Mike Haertel. */

#include <config.h>
#include "search.h"
#include "dfa.h"

/* For -w, we also consider _ to be word constituent.  */
#define WCHAR(C) (ISALNUM(C) || (C) == '_')

/* KWset compiled pattern.  For Ecompile and Gcompile, we compile
   a list of strings, at least one of which is known to occur in
   any string matching the regexp. */
static kwset_t kwset;

/* DFA compiled regexp. */
static struct dfa dfa;

/* The Regex compiled patterns.  */
static struct patterns
{
  /* Regex compiled regexp. */
  struct re_pattern_buffer regexbuf;
  struct re_registers regs; /* This is here on account of a BRAIN-DEAD
			       Q@#%!# library interface in regex.c.  */
} patterns0;

struct patterns *patterns;
size_t pcount;

void
dfaerror (char const *mesg)
{
  error (EXIT_TROUBLE, 0, "%s", mesg);

  /* notreached */
  /* Tell static analyzers that this function does not return.  */
  abort ();
}

/* Number of compiled fixed strings known to exactly match the regexp.
   If kwsexec returns < kwset_exact_matches, then we don't need to
   call the regexp matcher at all. */
static int kwset_exact_matches;

static char const *
kwsincr_case (const char *must)
{
  const char *buf;
  size_t n;

  n = strlen (must);
#ifdef MBS_SUPPORT
  if (match_icase && MB_CUR_MAX > 1)
    buf = mbtolower (must, &n);
  else
#endif
    buf = must;
  return kwsincr (kwset, buf, n);
}

/* If the DFA turns out to have some set of fixed strings one of
   which must occur in the match, then we build a kwset matcher
   to find those strings, and thus quickly filter out impossible
   matches. */
static void
kwsmusts (void)
{
  struct dfamust const *dm;
  char const *err;

  if (dfa.musts)
    {
      kwsinit (&kwset);
      /* First, we compile in the substrings known to be exact
	 matches.  The kwset matcher will return the index
	 of the matching string that it chooses. */
      for (dm = dfa.musts; dm; dm = dm->next)
	{
	  if (!dm->exact)
	    continue;
	  ++kwset_exact_matches;
	  if ((err = kwsincr_case (dm->must)) != NULL)
	    error (EXIT_TROUBLE, 0, "%s", err);
	}
      /* Now, we compile the substrings that will require
	 the use of the regexp matcher.  */
      for (dm = dfa.musts; dm; dm = dm->next)
	{
	  
//Patch 0:
if ((dm->exact) && !(__is_neg(7, &(dm), sizeof (dm), &(dm->exact), sizeof (dm->exact), &(err), sizeof (err), &(dm->must), sizeof (dm->must), &(dm->next), sizeof (dm->next), &(kwset), sizeof (kwset), &(kwset_exact_matches), sizeof (kwset_exact_matches))))
    continue;

//CodeSeg 1:
	  if ((err = kwsincr_case (dm->must)) != NULL)
	    error (EXIT_TROUBLE, 0, "%s", err);
	}
      if ((err = kwsprep (kwset)) != NULL)
	error (EXIT_TROUBLE, 0, "%s", err);
    }
}

void
GEAcompile (char const *pattern, size_t size, reg_syntax_t syntax_bits)
{
  const char *err;
  const char *p, *sep;
  size_t total = size;
  char *motif;

  if (match_icase)
    syntax_bits |= RE_ICASE;
  re_set_syntax (syntax_bits);
  dfasyntax (syntax_bits, match_icase, eolbyte);

  /* For GNU regex compiler we have to pass the patterns separately to detect
     errors like "[\nallo\n]\n".  The patterns here are "[", "allo" and "]"
     GNU regex should have raise a syntax error.  The same for backref, where
     the backref should have been local to each pattern.  */
  p = pattern;
  do
    {
      size_t len;
      sep = memchr (p, '\n', total);
      if (sep)
	{
	  len = sep - p;
	  sep++;
	  total -= (len + 1);
	}
      else
	{
	  len = total;
	  total = 0;
	}

      patterns = realloc (patterns, (pcount + 1) * sizeof (*patterns));
      if (patterns == NULL)
	error (EXIT_TROUBLE, errno, _("memory exhausted"));
      patterns[pcount] = patterns0;

      if ((err = re_compile_pattern (p, len,
				    &(patterns[pcount].regexbuf))) != NULL)
	error (EXIT_TROUBLE, 0, "%s", err);
      pcount++;

      p = sep;
    } while (sep && total != 0);

  /* In the match_words and match_lines cases, we use a different pattern
     for the DFA matcher that will quickly throw out cases that won't work.
     Then if DFA succeeds we do some hairy stuff using the regex matcher
     to decide whether the match should really count. */
  if (match_words || match_lines)
    {
      static char const line_beg_no_bk[] = "^(";
      static char const line_end_no_bk[] = ")$";
      static char const word_beg_no_bk[] = "(^|[^[:alnum:]_])(";
      static char const word_end_no_bk[] = ")([^[:alnum:]_]|$)";
      static char const line_beg_bk[] = "^\\(";
      static char const line_end_bk[] = "\\)$";
      static char const word_beg_bk[] = "\\(^\\|[^[:alnum:]_]\\)\\(";
      static char const word_end_bk[] = "\\)\\([^[:alnum:]_]\\|$\\)";
      int bk = !(syntax_bits & RE_NO_BK_PARENS);
      char *n = xmalloc (sizeof word_beg_bk - 1 + size + sizeof word_end_bk);

      strcpy (n, match_lines ? (bk ? line_beg_bk : line_beg_no_bk)
			     : (bk ? word_beg_bk : word_beg_no_bk));
      total = strlen(n);
      memcpy (n + total, pattern, size);
      total += size;
      strcpy (n + total, match_lines ? (bk ? line_end_bk : line_end_no_bk)
				     : (bk ? word_end_bk : word_end_no_bk));
      total += strlen (n + total);
      pattern = motif = n;
      size = total;
    }
  else
    motif = NULL;

  dfacomp (pattern, size, &dfa, 1);
  kwsmusts ();

  free(motif);
}

size_t
EGexecute (char const *buf, size_t size, size_t *match_size,
	   char const *start_ptr)
{
  char const *buflim, *beg, *end, *match, *best_match, *mb_start;
  char eol = eolbyte;
  int backref, start, len, best_len;
  struct kwsmatch kwsm;
  size_t i, ret_val;
#ifdef MBS_SUPPORT
  if (MB_CUR_MAX > 1)
    {
      if (match_icase)
        {
          /* mbtolower adds a NUL byte at the end.  That will provide
	     space for the sentinel byte dfaexec may add.  */
          char *case_buf = mbtolower (buf, &size);
	  if (start_ptr)
	    start_ptr = case_buf + (start_ptr - buf);
          buf = case_buf;
        }
    }
#endif /* MBS_SUPPORT */

  mb_start = buf;
  buflim = buf + size;

  for (beg = end = buf; end < buflim; beg = end)
    {
      if (!start_ptr)
	{
	  /* We don't care about an exact match.  */
	  if (kwset)
	    {
	      /* Find a possible match using the KWset matcher. */
	      size_t offset = kwsexec (kwset, beg, buflim - beg, &kwsm);
	      if (offset == (size_t) -1)
		goto failure;
	      beg += offset;
	      /* Narrow down to the line containing the candidate, and
		 run it through DFA. */
	      if ((end = memchr(beg, eol, buflim - beg)) != NULL)
	        end++;
              else
                end = buflim;
	      match = beg;
	      while (beg > buf && beg[-1] != eol)
		--beg;
	      if (kwsm.index < kwset_exact_matches)
                {
#ifdef MBS_SUPPORT
                  if (mb_start < beg)
                    mb_start = beg;
                  if (MB_CUR_MAX == 1 || !is_mb_middle (&mb_start, match, buflim))
#endif
                    goto success;
                }
	      if (dfaexec (&dfa, beg, (char *) end, 0, NULL, &backref) == NULL)
		continue;
	    }
	  else
	    {
	      /* No good fixed strings; start with DFA. */
	      char const *next_beg = dfaexec (&dfa, beg, (char *) buflim,
					      0, NULL, &backref);
	      if (next_beg == NULL)
		break;
	      /* Narrow down to the line we've found. */
	      beg = next_beg;
	      if ((end = memchr(beg, eol, buflim - beg)) != NULL)
	        end++;
              else
                end = buflim;
	      while (beg > buf && beg[-1] != eol)
		--beg;
	    }
	  /* Successful, no backreferences encountered! */
	  if (!backref)
	    goto success;
	}
      else
	{
	  /* We are looking for the leftmost (then longest) exact match.
	     We will go through the outer loop only once.  */
	  beg = start_ptr;
	  end = buflim;
	}

      /* If we've made it to this point, this means DFA has seen
	 a probable match, and we need to run it through Regex. */
      best_match = end;
      best_len = 0;
      for (i = 0; i < pcount; i++)
	{
	  patterns[i].regexbuf.not_eol = 0;
	  if (0 <= (start = re_search (&(patterns[i].regexbuf),
				       buf, end - buf - 1,
				       beg - buf, end - beg - 1,
				       &(patterns[i].regs))))
	    {
	      len = patterns[i].regs.end[0] - start;
	      match = buf + start;
	      if (match > best_match)
		continue;
	      if (start_ptr && !match_words)
		goto assess_pattern_match;
	      if ((!match_lines && !match_words)
		  || (match_lines && len == end - beg - 1))
		{
		  match = beg;
		  len = end - beg;
		  goto assess_pattern_match;
		}
	      /* If -w, check if the match aligns with word boundaries.
		 We do this iteratively because:
		 (a) the line may contain more than one occurence of the
		 pattern, and
		 (b) Several alternatives in the pattern might be valid at a
		 given point, and we may need to consider a shorter one to
		 find a word boundary.  */
	      if (match_words)
		while (match <= best_match)
		  {
		    if ((match == buf || !WCHAR ((unsigned char) match[-1]))
			&& (len == end - beg - 1
			    || !WCHAR ((unsigned char) match[len])))
		      goto assess_pattern_match;
		    if (len > 0)
		      {
			/* Try a shorter length anchored at the same place. */
			--len;
			patterns[i].regexbuf.not_eol = 1;
			len = re_match (&(patterns[i].regexbuf),
					buf, match + len - beg, match - buf,
					&(patterns[i].regs));
		      }
		    if (len <= 0)
		      {
			/* Try looking further on. */
			if (match == end - 1)
			  break;
			match++;
			patterns[i].regexbuf.not_eol = 0;
			start = re_search (&(patterns[i].regexbuf),
					   buf, end - buf - 1,
					   match - buf, end - match - 1,
					   &(patterns[i].regs));
			if (start < 0)
			  break;
			len = patterns[i].regs.end[0] - start;
			match = buf + start;
		      }
		  } /* while (match <= best_match) */
	      continue;
	    assess_pattern_match:
	      if (!start_ptr)
		{
		  /* Good enough for a non-exact match.
		     No need to look at further patterns, if any.  */
		  beg = match;
		  goto success_in_len;
		}
	      if (match < best_match || (match == best_match && len > best_len))
		{
		  /* Best exact match:  leftmost, then longest.  */
		  best_match = match;
		  best_len = len;
		}
	    } /* if re_search >= 0 */
	} /* for Regex patterns.  */
	if (best_match < end)
	  {
	    /* We have found an exact match.  We were just
	       waiting for the best one (leftmost then longest).  */
	    beg = best_match;
	    len = best_len;
	    goto success_in_len;
	  }
    } /* for (beg = end ..) */

 failure:
  ret_val = -1;
  goto out;

 success:
  len = end - beg;
 success_in_len:
  *match_size = len;
  ret_val = beg - buf;
 out:
  return ret_val;
}

Spawn 1 instances, now Total 30
Counter: 31
Batcher Size:30
Preprocess the following candidate with CondTester:
Priority 20000
At location src/dfasearch.c:110
--Src File: src/dfasearch.c
Fragment 0:
if (((err = kwsincr_case(dm->must)) != ((void *)0)) && !(__abst_hole(dm, err, dm->must, dm->exact, kwset, dm->next, kwset_exact_matches)))
    error(EXIT_TROUBLE, 0, "%s", err);


CondTester, a patch instance with id 30:
//src_file:src/dfasearch.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); void* memset(void*, int, unsigned long); 
/* dfasearch.c - searching subroutines using dfa and regex for grep.
   Copyright 1992, 1998, 2000, 2007, 2009-2010 Free Software Foundation, Inc.

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 3, or (at your option)
   any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program; if not, write to the Free Software
   Foundation, Inc., 51 Franklin Street - Fifth Floor, Boston, MA
   02110-1301, USA.  */

/* Written August 1992 by Mike Haertel. */

#include <config.h>
#include "search.h"
#include "dfa.h"

/* For -w, we also consider _ to be word constituent.  */
#define WCHAR(C) (ISALNUM(C) || (C) == '_')

/* KWset compiled pattern.  For Ecompile and Gcompile, we compile
   a list of strings, at least one of which is known to occur in
   any string matching the regexp. */
static kwset_t kwset;

/* DFA compiled regexp. */
static struct dfa dfa;

/* The Regex compiled patterns.  */
static struct patterns
{
  /* Regex compiled regexp. */
  struct re_pattern_buffer regexbuf;
  struct re_registers regs; /* This is here on account of a BRAIN-DEAD
			       Q@#%!# library interface in regex.c.  */
} patterns0;

struct patterns *patterns;
size_t pcount;

void
dfaerror (char const *mesg)
{
  error (EXIT_TROUBLE, 0, "%s", mesg);

  /* notreached */
  /* Tell static analyzers that this function does not return.  */
  abort ();
}

/* Number of compiled fixed strings known to exactly match the regexp.
   If kwsexec returns < kwset_exact_matches, then we don't need to
   call the regexp matcher at all. */
static int kwset_exact_matches;

static char const *
kwsincr_case (const char *must)
{
  const char *buf;
  size_t n;

  n = strlen (must);
#ifdef MBS_SUPPORT
  if (match_icase && MB_CUR_MAX > 1)
    buf = mbtolower (must, &n);
  else
#endif
    buf = must;
  return kwsincr (kwset, buf, n);
}

/* If the DFA turns out to have some set of fixed strings one of
   which must occur in the match, then we build a kwset matcher
   to find those strings, and thus quickly filter out impossible
   matches. */
static void
kwsmusts (void)
{
  struct dfamust const *dm;
  char const *err;

  if (dfa.musts)
    {
      kwsinit (&kwset);
      /* First, we compile in the substrings known to be exact
	 matches.  The kwset matcher will return the index
	 of the matching string that it chooses. */
      for (dm = dfa.musts; dm; dm = dm->next)
	{
	  if (!dm->exact)
	    continue;
	  ++kwset_exact_matches;
	  if ((err = kwsincr_case (dm->must)) != NULL)
	    error (EXIT_TROUBLE, 0, "%s", err);
	}
      /* Now, we compile the substrings that will require
	 the use of the regexp matcher.  */
      for (dm = dfa.musts; dm; dm = dm->next)
	{
	  if (dm->exact)
	    continue;
	  
//Patch 0:
if (((err = kwsincr_case(dm->must)) != ((void *)0)) && !(__is_neg(7, &(dm), sizeof (dm), &(err), sizeof (err), &(dm->must), sizeof (dm->must), &(dm->exact), sizeof (dm->exact), &(kwset), sizeof (kwset), &(dm->next), sizeof (dm->next), &(kwset_exact_matches), sizeof (kwset_exact_matches))))
    error(EXIT_TROUBLE, 0, "%s", err);

//CodeSeg 1:
	}
      if ((err = kwsprep (kwset)) != NULL)
	error (EXIT_TROUBLE, 0, "%s", err);
    }
}

void
GEAcompile (char const *pattern, size_t size, reg_syntax_t syntax_bits)
{
  const char *err;
  const char *p, *sep;
  size_t total = size;
  char *motif;

  if (match_icase)
    syntax_bits |= RE_ICASE;
  re_set_syntax (syntax_bits);
  dfasyntax (syntax_bits, match_icase, eolbyte);

  /* For GNU regex compiler we have to pass the patterns separately to detect
     errors like "[\nallo\n]\n".  The patterns here are "[", "allo" and "]"
     GNU regex should have raise a syntax error.  The same for backref, where
     the backref should have been local to each pattern.  */
  p = pattern;
  do
    {
      size_t len;
      sep = memchr (p, '\n', total);
      if (sep)
	{
	  len = sep - p;
	  sep++;
	  total -= (len + 1);
	}
      else
	{
	  len = total;
	  total = 0;
	}

      patterns = realloc (patterns, (pcount + 1) * sizeof (*patterns));
      if (patterns == NULL)
	error (EXIT_TROUBLE, errno, _("memory exhausted"));
      patterns[pcount] = patterns0;

      if ((err = re_compile_pattern (p, len,
				    &(patterns[pcount].regexbuf))) != NULL)
	error (EXIT_TROUBLE, 0, "%s", err);
      pcount++;

      p = sep;
    } while (sep && total != 0);

  /* In the match_words and match_lines cases, we use a different pattern
     for the DFA matcher that will quickly throw out cases that won't work.
     Then if DFA succeeds we do some hairy stuff using the regex matcher
     to decide whether the match should really count. */
  if (match_words || match_lines)
    {
      static char const line_beg_no_bk[] = "^(";
      static char const line_end_no_bk[] = ")$";
      static char const word_beg_no_bk[] = "(^|[^[:alnum:]_])(";
      static char const word_end_no_bk[] = ")([^[:alnum:]_]|$)";
      static char const line_beg_bk[] = "^\\(";
      static char const line_end_bk[] = "\\)$";
      static char const word_beg_bk[] = "\\(^\\|[^[:alnum:]_]\\)\\(";
      static char const word_end_bk[] = "\\)\\([^[:alnum:]_]\\|$\\)";
      int bk = !(syntax_bits & RE_NO_BK_PARENS);
      char *n = xmalloc (sizeof word_beg_bk - 1 + size + sizeof word_end_bk);

      strcpy (n, match_lines ? (bk ? line_beg_bk : line_beg_no_bk)
			     : (bk ? word_beg_bk : word_beg_no_bk));
      total = strlen(n);
      memcpy (n + total, pattern, size);
      total += size;
      strcpy (n + total, match_lines ? (bk ? line_end_bk : line_end_no_bk)
				     : (bk ? word_end_bk : word_end_no_bk));
      total += strlen (n + total);
      pattern = motif = n;
      size = total;
    }
  else
    motif = NULL;

  dfacomp (pattern, size, &dfa, 1);
  kwsmusts ();

  free(motif);
}

size_t
EGexecute (char const *buf, size_t size, size_t *match_size,
	   char const *start_ptr)
{
  char const *buflim, *beg, *end, *match, *best_match, *mb_start;
  char eol = eolbyte;
  int backref, start, len, best_len;
  struct kwsmatch kwsm;
  size_t i, ret_val;
#ifdef MBS_SUPPORT
  if (MB_CUR_MAX > 1)
    {
      if (match_icase)
        {
          /* mbtolower adds a NUL byte at the end.  That will provide
	     space for the sentinel byte dfaexec may add.  */
          char *case_buf = mbtolower (buf, &size);
	  if (start_ptr)
	    start_ptr = case_buf + (start_ptr - buf);
          buf = case_buf;
        }
    }
#endif /* MBS_SUPPORT */

  mb_start = buf;
  buflim = buf + size;

  for (beg = end = buf; end < buflim; beg = end)
    {
      if (!start_ptr)
	{
	  /* We don't care about an exact match.  */
	  if (kwset)
	    {
	      /* Find a possible match using the KWset matcher. */
	      size_t offset = kwsexec (kwset, beg, buflim - beg, &kwsm);
	      if (offset == (size_t) -1)
		goto failure;
	      beg += offset;
	      /* Narrow down to the line containing the candidate, and
		 run it through DFA. */
	      if ((end = memchr(beg, eol, buflim - beg)) != NULL)
	        end++;
              else
                end = buflim;
	      match = beg;
	      while (beg > buf && beg[-1] != eol)
		--beg;
	      if (kwsm.index < kwset_exact_matches)
                {
#ifdef MBS_SUPPORT
                  if (mb_start < beg)
                    mb_start = beg;
                  if (MB_CUR_MAX == 1 || !is_mb_middle (&mb_start, match, buflim))
#endif
                    goto success;
                }
	      if (dfaexec (&dfa, beg, (char *) end, 0, NULL, &backref) == NULL)
		continue;
	    }
	  else
	    {
	      /* No good fixed strings; start with DFA. */
	      char const *next_beg = dfaexec (&dfa, beg, (char *) buflim,
					      0, NULL, &backref);
	      if (next_beg == NULL)
		break;
	      /* Narrow down to the line we've found. */
	      beg = next_beg;
	      if ((end = memchr(beg, eol, buflim - beg)) != NULL)
	        end++;
              else
                end = buflim;
	      while (beg > buf && beg[-1] != eol)
		--beg;
	    }
	  /* Successful, no backreferences encountered! */
	  if (!backref)
	    goto success;
	}
      else
	{
	  /* We are looking for the leftmost (then longest) exact match.
	     We will go through the outer loop only once.  */
	  beg = start_ptr;
	  end = buflim;
	}

      /* If we've made it to this point, this means DFA has seen
	 a probable match, and we need to run it through Regex. */
      best_match = end;
      best_len = 0;
      for (i = 0; i < pcount; i++)
	{
	  patterns[i].regexbuf.not_eol = 0;
	  if (0 <= (start = re_search (&(patterns[i].regexbuf),
				       buf, end - buf - 1,
				       beg - buf, end - beg - 1,
				       &(patterns[i].regs))))
	    {
	      len = patterns[i].regs.end[0] - start;
	      match = buf + start;
	      if (match > best_match)
		continue;
	      if (start_ptr && !match_words)
		goto assess_pattern_match;
	      if ((!match_lines && !match_words)
		  || (match_lines && len == end - beg - 1))
		{
		  match = beg;
		  len = end - beg;
		  goto assess_pattern_match;
		}
	      /* If -w, check if the match aligns with word boundaries.
		 We do this iteratively because:
		 (a) the line may contain more than one occurence of the
		 pattern, and
		 (b) Several alternatives in the pattern might be valid at a
		 given point, and we may need to consider a shorter one to
		 find a word boundary.  */
	      if (match_words)
		while (match <= best_match)
		  {
		    if ((match == buf || !WCHAR ((unsigned char) match[-1]))
			&& (len == end - beg - 1
			    || !WCHAR ((unsigned char) match[len])))
		      goto assess_pattern_match;
		    if (len > 0)
		      {
			/* Try a shorter length anchored at the same place. */
			--len;
			patterns[i].regexbuf.not_eol = 1;
			len = re_match (&(patterns[i].regexbuf),
					buf, match + len - beg, match - buf,
					&(patterns[i].regs));
		      }
		    if (len <= 0)
		      {
			/* Try looking further on. */
			if (match == end - 1)
			  break;
			match++;
			patterns[i].regexbuf.not_eol = 0;
			start = re_search (&(patterns[i].regexbuf),
					   buf, end - buf - 1,
					   match - buf, end - match - 1,
					   &(patterns[i].regs));
			if (start < 0)
			  break;
			len = patterns[i].regs.end[0] - start;
			match = buf + start;
		      }
		  } /* while (match <= best_match) */
	      continue;
	    assess_pattern_match:
	      if (!start_ptr)
		{
		  /* Good enough for a non-exact match.
		     No need to look at further patterns, if any.  */
		  beg = match;
		  goto success_in_len;
		}
	      if (match < best_match || (match == best_match && len > best_len))
		{
		  /* Best exact match:  leftmost, then longest.  */
		  best_match = match;
		  best_len = len;
		}
	    } /* if re_search >= 0 */
	} /* for Regex patterns.  */
	if (best_match < end)
	  {
	    /* We have found an exact match.  We were just
	       waiting for the best one (leftmost then longest).  */
	    beg = best_match;
	    len = best_len;
	    goto success_in_len;
	  }
    } /* for (beg = end ..) */

 failure:
  ret_val = -1;
  goto out;

 success:
  len = end - beg;
 success_in_len:
  *match_size = len;
  ret_val = beg - buf;
 out:
  return ret_val;
}

Spawn 1 instances, now Total 31
Counter: 32
Batcher Size:31
Preprocess the following candidate with CondTester:
Priority 20000
At location src/dfasearch.c:110
--Src File: src/dfasearch.c
Fragment 0:
if (((err = kwsincr_case(dm->must)) != ((void *)0)) || (__abst_hole(dm, err, dm->must, dm->exact, kwset, dm->next, kwset_exact_matches)))
    error(EXIT_TROUBLE, 0, "%s", err);


CondTester, a patch instance with id 31:
//src_file:src/dfasearch.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); void* memset(void*, int, unsigned long); 
/* dfasearch.c - searching subroutines using dfa and regex for grep.
   Copyright 1992, 1998, 2000, 2007, 2009-2010 Free Software Foundation, Inc.

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 3, or (at your option)
   any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program; if not, write to the Free Software
   Foundation, Inc., 51 Franklin Street - Fifth Floor, Boston, MA
   02110-1301, USA.  */

/* Written August 1992 by Mike Haertel. */

#include <config.h>
#include "search.h"
#include "dfa.h"

/* For -w, we also consider _ to be word constituent.  */
#define WCHAR(C) (ISALNUM(C) || (C) == '_')

/* KWset compiled pattern.  For Ecompile and Gcompile, we compile
   a list of strings, at least one of which is known to occur in
   any string matching the regexp. */
static kwset_t kwset;

/* DFA compiled regexp. */
static struct dfa dfa;

/* The Regex compiled patterns.  */
static struct patterns
{
  /* Regex compiled regexp. */
  struct re_pattern_buffer regexbuf;
  struct re_registers regs; /* This is here on account of a BRAIN-DEAD
			       Q@#%!# library interface in regex.c.  */
} patterns0;

struct patterns *patterns;
size_t pcount;

void
dfaerror (char const *mesg)
{
  error (EXIT_TROUBLE, 0, "%s", mesg);

  /* notreached */
  /* Tell static analyzers that this function does not return.  */
  abort ();
}

/* Number of compiled fixed strings known to exactly match the regexp.
   If kwsexec returns < kwset_exact_matches, then we don't need to
   call the regexp matcher at all. */
static int kwset_exact_matches;

static char const *
kwsincr_case (const char *must)
{
  const char *buf;
  size_t n;

  n = strlen (must);
#ifdef MBS_SUPPORT
  if (match_icase && MB_CUR_MAX > 1)
    buf = mbtolower (must, &n);
  else
#endif
    buf = must;
  return kwsincr (kwset, buf, n);
}

/* If the DFA turns out to have some set of fixed strings one of
   which must occur in the match, then we build a kwset matcher
   to find those strings, and thus quickly filter out impossible
   matches. */
static void
kwsmusts (void)
{
  struct dfamust const *dm;
  char const *err;

  if (dfa.musts)
    {
      kwsinit (&kwset);
      /* First, we compile in the substrings known to be exact
	 matches.  The kwset matcher will return the index
	 of the matching string that it chooses. */
      for (dm = dfa.musts; dm; dm = dm->next)
	{
	  if (!dm->exact)
	    continue;
	  ++kwset_exact_matches;
	  if ((err = kwsincr_case (dm->must)) != NULL)
	    error (EXIT_TROUBLE, 0, "%s", err);
	}
      /* Now, we compile the substrings that will require
	 the use of the regexp matcher.  */
      for (dm = dfa.musts; dm; dm = dm->next)
	{
	  if (dm->exact)
	    continue;
	  
//Patch 0:
if (((err = kwsincr_case(dm->must)) != ((void *)0)) || (__is_neg(7, &(dm), sizeof (dm), &(err), sizeof (err), &(dm->must), sizeof (dm->must), &(dm->exact), sizeof (dm->exact), &(kwset), sizeof (kwset), &(dm->next), sizeof (dm->next), &(kwset_exact_matches), sizeof (kwset_exact_matches))))
    error(EXIT_TROUBLE, 0, "%s", err);

//CodeSeg 1:
	}
      if ((err = kwsprep (kwset)) != NULL)
	error (EXIT_TROUBLE, 0, "%s", err);
    }
}

void
GEAcompile (char const *pattern, size_t size, reg_syntax_t syntax_bits)
{
  const char *err;
  const char *p, *sep;
  size_t total = size;
  char *motif;

  if (match_icase)
    syntax_bits |= RE_ICASE;
  re_set_syntax (syntax_bits);
  dfasyntax (syntax_bits, match_icase, eolbyte);

  /* For GNU regex compiler we have to pass the patterns separately to detect
     errors like "[\nallo\n]\n".  The patterns here are "[", "allo" and "]"
     GNU regex should have raise a syntax error.  The same for backref, where
     the backref should have been local to each pattern.  */
  p = pattern;
  do
    {
      size_t len;
      sep = memchr (p, '\n', total);
      if (sep)
	{
	  len = sep - p;
	  sep++;
	  total -= (len + 1);
	}
      else
	{
	  len = total;
	  total = 0;
	}

      patterns = realloc (patterns, (pcount + 1) * sizeof (*patterns));
      if (patterns == NULL)
	error (EXIT_TROUBLE, errno, _("memory exhausted"));
      patterns[pcount] = patterns0;

      if ((err = re_compile_pattern (p, len,
				    &(patterns[pcount].regexbuf))) != NULL)
	error (EXIT_TROUBLE, 0, "%s", err);
      pcount++;

      p = sep;
    } while (sep && total != 0);

  /* In the match_words and match_lines cases, we use a different pattern
     for the DFA matcher that will quickly throw out cases that won't work.
     Then if DFA succeeds we do some hairy stuff using the regex matcher
     to decide whether the match should really count. */
  if (match_words || match_lines)
    {
      static char const line_beg_no_bk[] = "^(";
      static char const line_end_no_bk[] = ")$";
      static char const word_beg_no_bk[] = "(^|[^[:alnum:]_])(";
      static char const word_end_no_bk[] = ")([^[:alnum:]_]|$)";
      static char const line_beg_bk[] = "^\\(";
      static char const line_end_bk[] = "\\)$";
      static char const word_beg_bk[] = "\\(^\\|[^[:alnum:]_]\\)\\(";
      static char const word_end_bk[] = "\\)\\([^[:alnum:]_]\\|$\\)";
      int bk = !(syntax_bits & RE_NO_BK_PARENS);
      char *n = xmalloc (sizeof word_beg_bk - 1 + size + sizeof word_end_bk);

      strcpy (n, match_lines ? (bk ? line_beg_bk : line_beg_no_bk)
			     : (bk ? word_beg_bk : word_beg_no_bk));
      total = strlen(n);
      memcpy (n + total, pattern, size);
      total += size;
      strcpy (n + total, match_lines ? (bk ? line_end_bk : line_end_no_bk)
				     : (bk ? word_end_bk : word_end_no_bk));
      total += strlen (n + total);
      pattern = motif = n;
      size = total;
    }
  else
    motif = NULL;

  dfacomp (pattern, size, &dfa, 1);
  kwsmusts ();

  free(motif);
}

size_t
EGexecute (char const *buf, size_t size, size_t *match_size,
	   char const *start_ptr)
{
  char const *buflim, *beg, *end, *match, *best_match, *mb_start;
  char eol = eolbyte;
  int backref, start, len, best_len;
  struct kwsmatch kwsm;
  size_t i, ret_val;
#ifdef MBS_SUPPORT
  if (MB_CUR_MAX > 1)
    {
      if (match_icase)
        {
          /* mbtolower adds a NUL byte at the end.  That will provide
	     space for the sentinel byte dfaexec may add.  */
          char *case_buf = mbtolower (buf, &size);
	  if (start_ptr)
	    start_ptr = case_buf + (start_ptr - buf);
          buf = case_buf;
        }
    }
#endif /* MBS_SUPPORT */

  mb_start = buf;
  buflim = buf + size;

  for (beg = end = buf; end < buflim; beg = end)
    {
      if (!start_ptr)
	{
	  /* We don't care about an exact match.  */
	  if (kwset)
	    {
	      /* Find a possible match using the KWset matcher. */
	      size_t offset = kwsexec (kwset, beg, buflim - beg, &kwsm);
	      if (offset == (size_t) -1)
		goto failure;
	      beg += offset;
	      /* Narrow down to the line containing the candidate, and
		 run it through DFA. */
	      if ((end = memchr(beg, eol, buflim - beg)) != NULL)
	        end++;
              else
                end = buflim;
	      match = beg;
	      while (beg > buf && beg[-1] != eol)
		--beg;
	      if (kwsm.index < kwset_exact_matches)
                {
#ifdef MBS_SUPPORT
                  if (mb_start < beg)
                    mb_start = beg;
                  if (MB_CUR_MAX == 1 || !is_mb_middle (&mb_start, match, buflim))
#endif
                    goto success;
                }
	      if (dfaexec (&dfa, beg, (char *) end, 0, NULL, &backref) == NULL)
		continue;
	    }
	  else
	    {
	      /* No good fixed strings; start with DFA. */
	      char const *next_beg = dfaexec (&dfa, beg, (char *) buflim,
					      0, NULL, &backref);
	      if (next_beg == NULL)
		break;
	      /* Narrow down to the line we've found. */
	      beg = next_beg;
	      if ((end = memchr(beg, eol, buflim - beg)) != NULL)
	        end++;
              else
                end = buflim;
	      while (beg > buf && beg[-1] != eol)
		--beg;
	    }
	  /* Successful, no backreferences encountered! */
	  if (!backref)
	    goto success;
	}
      else
	{
	  /* We are looking for the leftmost (then longest) exact match.
	     We will go through the outer loop only once.  */
	  beg = start_ptr;
	  end = buflim;
	}

      /* If we've made it to this point, this means DFA has seen
	 a probable match, and we need to run it through Regex. */
      best_match = end;
      best_len = 0;
      for (i = 0; i < pcount; i++)
	{
	  patterns[i].regexbuf.not_eol = 0;
	  if (0 <= (start = re_search (&(patterns[i].regexbuf),
				       buf, end - buf - 1,
				       beg - buf, end - beg - 1,
				       &(patterns[i].regs))))
	    {
	      len = patterns[i].regs.end[0] - start;
	      match = buf + start;
	      if (match > best_match)
		continue;
	      if (start_ptr && !match_words)
		goto assess_pattern_match;
	      if ((!match_lines && !match_words)
		  || (match_lines && len == end - beg - 1))
		{
		  match = beg;
		  len = end - beg;
		  goto assess_pattern_match;
		}
	      /* If -w, check if the match aligns with word boundaries.
		 We do this iteratively because:
		 (a) the line may contain more than one occurence of the
		 pattern, and
		 (b) Several alternatives in the pattern might be valid at a
		 given point, and we may need to consider a shorter one to
		 find a word boundary.  */
	      if (match_words)
		while (match <= best_match)
		  {
		    if ((match == buf || !WCHAR ((unsigned char) match[-1]))
			&& (len == end - beg - 1
			    || !WCHAR ((unsigned char) match[len])))
		      goto assess_pattern_match;
		    if (len > 0)
		      {
			/* Try a shorter length anchored at the same place. */
			--len;
			patterns[i].regexbuf.not_eol = 1;
			len = re_match (&(patterns[i].regexbuf),
					buf, match + len - beg, match - buf,
					&(patterns[i].regs));
		      }
		    if (len <= 0)
		      {
			/* Try looking further on. */
			if (match == end - 1)
			  break;
			match++;
			patterns[i].regexbuf.not_eol = 0;
			start = re_search (&(patterns[i].regexbuf),
					   buf, end - buf - 1,
					   match - buf, end - match - 1,
					   &(patterns[i].regs));
			if (start < 0)
			  break;
			len = patterns[i].regs.end[0] - start;
			match = buf + start;
		      }
		  } /* while (match <= best_match) */
	      continue;
	    assess_pattern_match:
	      if (!start_ptr)
		{
		  /* Good enough for a non-exact match.
		     No need to look at further patterns, if any.  */
		  beg = match;
		  goto success_in_len;
		}
	      if (match < best_match || (match == best_match && len > best_len))
		{
		  /* Best exact match:  leftmost, then longest.  */
		  best_match = match;
		  best_len = len;
		}
	    } /* if re_search >= 0 */
	} /* for Regex patterns.  */
	if (best_match < end)
	  {
	    /* We have found an exact match.  We were just
	       waiting for the best one (leftmost then longest).  */
	    beg = best_match;
	    len = best_len;
	    goto success_in_len;
	  }
    } /* for (beg = end ..) */

 failure:
  ret_val = -1;
  goto out;

 success:
  len = end - beg;
 success_in_len:
  *match_size = len;
  ret_val = beg - buf;
 out:
  return ret_val;
}

Spawn 1 instances, now Total 32
Counter: 33
Batcher Size:32
Preprocess the following candidate with CondTester:
Priority 20000
At location src/dfasearch.c:140
--Src File: src/dfasearch.c
Fragment 0:
if ((sep) && !(__abst_hole(sep, p, total, len, pattern, syntax_bits, match_icase, eolbyte, patterns, pcount, size, err, match_words, match_lines, motif))) {
    len = sep - p;
    sep++;
    total -= (len + 1);
} else {
    len = total;
    total = 0;
}


CondTester, a patch instance with id 32:
//src_file:src/dfasearch.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); void* memset(void*, int, unsigned long); 
/* dfasearch.c - searching subroutines using dfa and regex for grep.
   Copyright 1992, 1998, 2000, 2007, 2009-2010 Free Software Foundation, Inc.

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 3, or (at your option)
   any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program; if not, write to the Free Software
   Foundation, Inc., 51 Franklin Street - Fifth Floor, Boston, MA
   02110-1301, USA.  */

/* Written August 1992 by Mike Haertel. */

#include <config.h>
#include "search.h"
#include "dfa.h"

/* For -w, we also consider _ to be word constituent.  */
#define WCHAR(C) (ISALNUM(C) || (C) == '_')

/* KWset compiled pattern.  For Ecompile and Gcompile, we compile
   a list of strings, at least one of which is known to occur in
   any string matching the regexp. */
static kwset_t kwset;

/* DFA compiled regexp. */
static struct dfa dfa;

/* The Regex compiled patterns.  */
static struct patterns
{
  /* Regex compiled regexp. */
  struct re_pattern_buffer regexbuf;
  struct re_registers regs; /* This is here on account of a BRAIN-DEAD
			       Q@#%!# library interface in regex.c.  */
} patterns0;

struct patterns *patterns;
size_t pcount;

void
dfaerror (char const *mesg)
{
  error (EXIT_TROUBLE, 0, "%s", mesg);

  /* notreached */
  /* Tell static analyzers that this function does not return.  */
  abort ();
}

/* Number of compiled fixed strings known to exactly match the regexp.
   If kwsexec returns < kwset_exact_matches, then we don't need to
   call the regexp matcher at all. */
static int kwset_exact_matches;

static char const *
kwsincr_case (const char *must)
{
  const char *buf;
  size_t n;

  n = strlen (must);
#ifdef MBS_SUPPORT
  if (match_icase && MB_CUR_MAX > 1)
    buf = mbtolower (must, &n);
  else
#endif
    buf = must;
  return kwsincr (kwset, buf, n);
}

/* If the DFA turns out to have some set of fixed strings one of
   which must occur in the match, then we build a kwset matcher
   to find those strings, and thus quickly filter out impossible
   matches. */
static void
kwsmusts (void)
{
  struct dfamust const *dm;
  char const *err;

  if (dfa.musts)
    {
      kwsinit (&kwset);
      /* First, we compile in the substrings known to be exact
	 matches.  The kwset matcher will return the index
	 of the matching string that it chooses. */
      for (dm = dfa.musts; dm; dm = dm->next)
	{
	  if (!dm->exact)
	    continue;
	  ++kwset_exact_matches;
	  if ((err = kwsincr_case (dm->must)) != NULL)
	    error (EXIT_TROUBLE, 0, "%s", err);
	}
      /* Now, we compile the substrings that will require
	 the use of the regexp matcher.  */
      for (dm = dfa.musts; dm; dm = dm->next)
	{
	  if (dm->exact)
	    continue;
	  if ((err = kwsincr_case (dm->must)) != NULL)
	    error (EXIT_TROUBLE, 0, "%s", err);
	}
      if ((err = kwsprep (kwset)) != NULL)
	error (EXIT_TROUBLE, 0, "%s", err);
    }
}

void
GEAcompile (char const *pattern, size_t size, reg_syntax_t syntax_bits)
{
  const char *err;
  const char *p, *sep;
  size_t total = size;
  char *motif;

  if (match_icase)
    syntax_bits |= RE_ICASE;
  re_set_syntax (syntax_bits);
  dfasyntax (syntax_bits, match_icase, eolbyte);

  /* For GNU regex compiler we have to pass the patterns separately to detect
     errors like "[\nallo\n]\n".  The patterns here are "[", "allo" and "]"
     GNU regex should have raise a syntax error.  The same for backref, where
     the backref should have been local to each pattern.  */
  p = pattern;
  do
    {
      size_t len;
      sep = memchr (p, '\n', total);
      
//Patch 0:
if ((sep) && !(__is_neg(15, &(sep), sizeof (sep), &(p), sizeof (p), &(total), sizeof (total), &(len), sizeof (len), &(pattern), sizeof (pattern), &(syntax_bits), sizeof (syntax_bits), &(match_icase), sizeof (match_icase), &(eolbyte), sizeof (eolbyte), &(patterns), sizeof (patterns), &(pcount), sizeof (pcount), &(size), sizeof (size), &(err), sizeof (err), &(match_words), sizeof (match_words), &(match_lines), sizeof (match_lines), &(motif), sizeof (motif)))) {
    len = sep - p;
    sep++;
    total -= (len + 1);
} else {
    len = total;
    total = 0;
}

//CodeSeg 1:

      patterns = realloc (patterns, (pcount + 1) * sizeof (*patterns));
      if (patterns == NULL)
	error (EXIT_TROUBLE, errno, _("memory exhausted"));
      patterns[pcount] = patterns0;

      if ((err = re_compile_pattern (p, len,
				    &(patterns[pcount].regexbuf))) != NULL)
	error (EXIT_TROUBLE, 0, "%s", err);
      pcount++;

      p = sep;
    } while (sep && total != 0);

  /* In the match_words and match_lines cases, we use a different pattern
     for the DFA matcher that will quickly throw out cases that won't work.
     Then if DFA succeeds we do some hairy stuff using the regex matcher
     to decide whether the match should really count. */
  if (match_words || match_lines)
    {
      static char const line_beg_no_bk[] = "^(";
      static char const line_end_no_bk[] = ")$";
      static char const word_beg_no_bk[] = "(^|[^[:alnum:]_])(";
      static char const word_end_no_bk[] = ")([^[:alnum:]_]|$)";
      static char const line_beg_bk[] = "^\\(";
      static char const line_end_bk[] = "\\)$";
      static char const word_beg_bk[] = "\\(^\\|[^[:alnum:]_]\\)\\(";
      static char const word_end_bk[] = "\\)\\([^[:alnum:]_]\\|$\\)";
      int bk = !(syntax_bits & RE_NO_BK_PARENS);
      char *n = xmalloc (sizeof word_beg_bk - 1 + size + sizeof word_end_bk);

      strcpy (n, match_lines ? (bk ? line_beg_bk : line_beg_no_bk)
			     : (bk ? word_beg_bk : word_beg_no_bk));
      total = strlen(n);
      memcpy (n + total, pattern, size);
      total += size;
      strcpy (n + total, match_lines ? (bk ? line_end_bk : line_end_no_bk)
				     : (bk ? word_end_bk : word_end_no_bk));
      total += strlen (n + total);
      pattern = motif = n;
      size = total;
    }
  else
    motif = NULL;

  dfacomp (pattern, size, &dfa, 1);
  kwsmusts ();

  free(motif);
}

size_t
EGexecute (char const *buf, size_t size, size_t *match_size,
	   char const *start_ptr)
{
  char const *buflim, *beg, *end, *match, *best_match, *mb_start;
  char eol = eolbyte;
  int backref, start, len, best_len;
  struct kwsmatch kwsm;
  size_t i, ret_val;
#ifdef MBS_SUPPORT
  if (MB_CUR_MAX > 1)
    {
      if (match_icase)
        {
          /* mbtolower adds a NUL byte at the end.  That will provide
	     space for the sentinel byte dfaexec may add.  */
          char *case_buf = mbtolower (buf, &size);
	  if (start_ptr)
	    start_ptr = case_buf + (start_ptr - buf);
          buf = case_buf;
        }
    }
#endif /* MBS_SUPPORT */

  mb_start = buf;
  buflim = buf + size;

  for (beg = end = buf; end < buflim; beg = end)
    {
      if (!start_ptr)
	{
	  /* We don't care about an exact match.  */
	  if (kwset)
	    {
	      /* Find a possible match using the KWset matcher. */
	      size_t offset = kwsexec (kwset, beg, buflim - beg, &kwsm);
	      if (offset == (size_t) -1)
		goto failure;
	      beg += offset;
	      /* Narrow down to the line containing the candidate, and
		 run it through DFA. */
	      if ((end = memchr(beg, eol, buflim - beg)) != NULL)
	        end++;
              else
                end = buflim;
	      match = beg;
	      while (beg > buf && beg[-1] != eol)
		--beg;
	      if (kwsm.index < kwset_exact_matches)
                {
#ifdef MBS_SUPPORT
                  if (mb_start < beg)
                    mb_start = beg;
                  if (MB_CUR_MAX == 1 || !is_mb_middle (&mb_start, match, buflim))
#endif
                    goto success;
                }
	      if (dfaexec (&dfa, beg, (char *) end, 0, NULL, &backref) == NULL)
		continue;
	    }
	  else
	    {
	      /* No good fixed strings; start with DFA. */
	      char const *next_beg = dfaexec (&dfa, beg, (char *) buflim,
					      0, NULL, &backref);
	      if (next_beg == NULL)
		break;
	      /* Narrow down to the line we've found. */
	      beg = next_beg;
	      if ((end = memchr(beg, eol, buflim - beg)) != NULL)
	        end++;
              else
                end = buflim;
	      while (beg > buf && beg[-1] != eol)
		--beg;
	    }
	  /* Successful, no backreferences encountered! */
	  if (!backref)
	    goto success;
	}
      else
	{
	  /* We are looking for the leftmost (then longest) exact match.
	     We will go through the outer loop only once.  */
	  beg = start_ptr;
	  end = buflim;
	}

      /* If we've made it to this point, this means DFA has seen
	 a probable match, and we need to run it through Regex. */
      best_match = end;
      best_len = 0;
      for (i = 0; i < pcount; i++)
	{
	  patterns[i].regexbuf.not_eol = 0;
	  if (0 <= (start = re_search (&(patterns[i].regexbuf),
				       buf, end - buf - 1,
				       beg - buf, end - beg - 1,
				       &(patterns[i].regs))))
	    {
	      len = patterns[i].regs.end[0] - start;
	      match = buf + start;
	      if (match > best_match)
		continue;
	      if (start_ptr && !match_words)
		goto assess_pattern_match;
	      if ((!match_lines && !match_words)
		  || (match_lines && len == end - beg - 1))
		{
		  match = beg;
		  len = end - beg;
		  goto assess_pattern_match;
		}
	      /* If -w, check if the match aligns with word boundaries.
		 We do this iteratively because:
		 (a) the line may contain more than one occurence of the
		 pattern, and
		 (b) Several alternatives in the pattern might be valid at a
		 given point, and we may need to consider a shorter one to
		 find a word boundary.  */
	      if (match_words)
		while (match <= best_match)
		  {
		    if ((match == buf || !WCHAR ((unsigned char) match[-1]))
			&& (len == end - beg - 1
			    || !WCHAR ((unsigned char) match[len])))
		      goto assess_pattern_match;
		    if (len > 0)
		      {
			/* Try a shorter length anchored at the same place. */
			--len;
			patterns[i].regexbuf.not_eol = 1;
			len = re_match (&(patterns[i].regexbuf),
					buf, match + len - beg, match - buf,
					&(patterns[i].regs));
		      }
		    if (len <= 0)
		      {
			/* Try looking further on. */
			if (match == end - 1)
			  break;
			match++;
			patterns[i].regexbuf.not_eol = 0;
			start = re_search (&(patterns[i].regexbuf),
					   buf, end - buf - 1,
					   match - buf, end - match - 1,
					   &(patterns[i].regs));
			if (start < 0)
			  break;
			len = patterns[i].regs.end[0] - start;
			match = buf + start;
		      }
		  } /* while (match <= best_match) */
	      continue;
	    assess_pattern_match:
	      if (!start_ptr)
		{
		  /* Good enough for a non-exact match.
		     No need to look at further patterns, if any.  */
		  beg = match;
		  goto success_in_len;
		}
	      if (match < best_match || (match == best_match && len > best_len))
		{
		  /* Best exact match:  leftmost, then longest.  */
		  best_match = match;
		  best_len = len;
		}
	    } /* if re_search >= 0 */
	} /* for Regex patterns.  */
	if (best_match < end)
	  {
	    /* We have found an exact match.  We were just
	       waiting for the best one (leftmost then longest).  */
	    beg = best_match;
	    len = best_len;
	    goto success_in_len;
	  }
    } /* for (beg = end ..) */

 failure:
  ret_val = -1;
  goto out;

 success:
  len = end - beg;
 success_in_len:
  *match_size = len;
  ret_val = beg - buf;
 out:
  return ret_val;
}

Spawn 1 instances, now Total 33
Counter: 34
Batcher Size:33
Preprocess the following candidate with CondTester:
Priority 20000
At location src/dfasearch.c:140
--Src File: src/dfasearch.c
Fragment 0:
if ((sep) || (__abst_hole(sep, p, total, len, pattern, syntax_bits, match_icase, eolbyte, patterns, pcount, size, err, match_words, match_lines, motif))) {
    len = sep - p;
    sep++;
    total -= (len + 1);
} else {
    len = total;
    total = 0;
}


CondTester, a patch instance with id 33:
//src_file:src/dfasearch.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); void* memset(void*, int, unsigned long); 
/* dfasearch.c - searching subroutines using dfa and regex for grep.
   Copyright 1992, 1998, 2000, 2007, 2009-2010 Free Software Foundation, Inc.

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 3, or (at your option)
   any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program; if not, write to the Free Software
   Foundation, Inc., 51 Franklin Street - Fifth Floor, Boston, MA
   02110-1301, USA.  */

/* Written August 1992 by Mike Haertel. */

#include <config.h>
#include "search.h"
#include "dfa.h"

/* For -w, we also consider _ to be word constituent.  */
#define WCHAR(C) (ISALNUM(C) || (C) == '_')

/* KWset compiled pattern.  For Ecompile and Gcompile, we compile
   a list of strings, at least one of which is known to occur in
   any string matching the regexp. */
static kwset_t kwset;

/* DFA compiled regexp. */
static struct dfa dfa;

/* The Regex compiled patterns.  */
static struct patterns
{
  /* Regex compiled regexp. */
  struct re_pattern_buffer regexbuf;
  struct re_registers regs; /* This is here on account of a BRAIN-DEAD
			       Q@#%!# library interface in regex.c.  */
} patterns0;

struct patterns *patterns;
size_t pcount;

void
dfaerror (char const *mesg)
{
  error (EXIT_TROUBLE, 0, "%s", mesg);

  /* notreached */
  /* Tell static analyzers that this function does not return.  */
  abort ();
}

/* Number of compiled fixed strings known to exactly match the regexp.
   If kwsexec returns < kwset_exact_matches, then we don't need to
   call the regexp matcher at all. */
static int kwset_exact_matches;

static char const *
kwsincr_case (const char *must)
{
  const char *buf;
  size_t n;

  n = strlen (must);
#ifdef MBS_SUPPORT
  if (match_icase && MB_CUR_MAX > 1)
    buf = mbtolower (must, &n);
  else
#endif
    buf = must;
  return kwsincr (kwset, buf, n);
}

/* If the DFA turns out to have some set of fixed strings one of
   which must occur in the match, then we build a kwset matcher
   to find those strings, and thus quickly filter out impossible
   matches. */
static void
kwsmusts (void)
{
  struct dfamust const *dm;
  char const *err;

  if (dfa.musts)
    {
      kwsinit (&kwset);
      /* First, we compile in the substrings known to be exact
	 matches.  The kwset matcher will return the index
	 of the matching string that it chooses. */
      for (dm = dfa.musts; dm; dm = dm->next)
	{
	  if (!dm->exact)
	    continue;
	  ++kwset_exact_matches;
	  if ((err = kwsincr_case (dm->must)) != NULL)
	    error (EXIT_TROUBLE, 0, "%s", err);
	}
      /* Now, we compile the substrings that will require
	 the use of the regexp matcher.  */
      for (dm = dfa.musts; dm; dm = dm->next)
	{
	  if (dm->exact)
	    continue;
	  if ((err = kwsincr_case (dm->must)) != NULL)
	    error (EXIT_TROUBLE, 0, "%s", err);
	}
      if ((err = kwsprep (kwset)) != NULL)
	error (EXIT_TROUBLE, 0, "%s", err);
    }
}

void
GEAcompile (char const *pattern, size_t size, reg_syntax_t syntax_bits)
{
  const char *err;
  const char *p, *sep;
  size_t total = size;
  char *motif;

  if (match_icase)
    syntax_bits |= RE_ICASE;
  re_set_syntax (syntax_bits);
  dfasyntax (syntax_bits, match_icase, eolbyte);

  /* For GNU regex compiler we have to pass the patterns separately to detect
     errors like "[\nallo\n]\n".  The patterns here are "[", "allo" and "]"
     GNU regex should have raise a syntax error.  The same for backref, where
     the backref should have been local to each pattern.  */
  p = pattern;
  do
    {
      size_t len;
      sep = memchr (p, '\n', total);
      
//Patch 0:
if ((sep) || (__is_neg(15, &(sep), sizeof (sep), &(p), sizeof (p), &(total), sizeof (total), &(len), sizeof (len), &(pattern), sizeof (pattern), &(syntax_bits), sizeof (syntax_bits), &(match_icase), sizeof (match_icase), &(eolbyte), sizeof (eolbyte), &(patterns), sizeof (patterns), &(pcount), sizeof (pcount), &(size), sizeof (size), &(err), sizeof (err), &(match_words), sizeof (match_words), &(match_lines), sizeof (match_lines), &(motif), sizeof (motif)))) {
    len = sep - p;
    sep++;
    total -= (len + 1);
} else {
    len = total;
    total = 0;
}

//CodeSeg 1:

      patterns = realloc (patterns, (pcount + 1) * sizeof (*patterns));
      if (patterns == NULL)
	error (EXIT_TROUBLE, errno, _("memory exhausted"));
      patterns[pcount] = patterns0;

      if ((err = re_compile_pattern (p, len,
				    &(patterns[pcount].regexbuf))) != NULL)
	error (EXIT_TROUBLE, 0, "%s", err);
      pcount++;

      p = sep;
    } while (sep && total != 0);

  /* In the match_words and match_lines cases, we use a different pattern
     for the DFA matcher that will quickly throw out cases that won't work.
     Then if DFA succeeds we do some hairy stuff using the regex matcher
     to decide whether the match should really count. */
  if (match_words || match_lines)
    {
      static char const line_beg_no_bk[] = "^(";
      static char const line_end_no_bk[] = ")$";
      static char const word_beg_no_bk[] = "(^|[^[:alnum:]_])(";
      static char const word_end_no_bk[] = ")([^[:alnum:]_]|$)";
      static char const line_beg_bk[] = "^\\(";
      static char const line_end_bk[] = "\\)$";
      static char const word_beg_bk[] = "\\(^\\|[^[:alnum:]_]\\)\\(";
      static char const word_end_bk[] = "\\)\\([^[:alnum:]_]\\|$\\)";
      int bk = !(syntax_bits & RE_NO_BK_PARENS);
      char *n = xmalloc (sizeof word_beg_bk - 1 + size + sizeof word_end_bk);

      strcpy (n, match_lines ? (bk ? line_beg_bk : line_beg_no_bk)
			     : (bk ? word_beg_bk : word_beg_no_bk));
      total = strlen(n);
      memcpy (n + total, pattern, size);
      total += size;
      strcpy (n + total, match_lines ? (bk ? line_end_bk : line_end_no_bk)
				     : (bk ? word_end_bk : word_end_no_bk));
      total += strlen (n + total);
      pattern = motif = n;
      size = total;
    }
  else
    motif = NULL;

  dfacomp (pattern, size, &dfa, 1);
  kwsmusts ();

  free(motif);
}

size_t
EGexecute (char const *buf, size_t size, size_t *match_size,
	   char const *start_ptr)
{
  char const *buflim, *beg, *end, *match, *best_match, *mb_start;
  char eol = eolbyte;
  int backref, start, len, best_len;
  struct kwsmatch kwsm;
  size_t i, ret_val;
#ifdef MBS_SUPPORT
  if (MB_CUR_MAX > 1)
    {
      if (match_icase)
        {
          /* mbtolower adds a NUL byte at the end.  That will provide
	     space for the sentinel byte dfaexec may add.  */
          char *case_buf = mbtolower (buf, &size);
	  if (start_ptr)
	    start_ptr = case_buf + (start_ptr - buf);
          buf = case_buf;
        }
    }
#endif /* MBS_SUPPORT */

  mb_start = buf;
  buflim = buf + size;

  for (beg = end = buf; end < buflim; beg = end)
    {
      if (!start_ptr)
	{
	  /* We don't care about an exact match.  */
	  if (kwset)
	    {
	      /* Find a possible match using the KWset matcher. */
	      size_t offset = kwsexec (kwset, beg, buflim - beg, &kwsm);
	      if (offset == (size_t) -1)
		goto failure;
	      beg += offset;
	      /* Narrow down to the line containing the candidate, and
		 run it through DFA. */
	      if ((end = memchr(beg, eol, buflim - beg)) != NULL)
	        end++;
              else
                end = buflim;
	      match = beg;
	      while (beg > buf && beg[-1] != eol)
		--beg;
	      if (kwsm.index < kwset_exact_matches)
                {
#ifdef MBS_SUPPORT
                  if (mb_start < beg)
                    mb_start = beg;
                  if (MB_CUR_MAX == 1 || !is_mb_middle (&mb_start, match, buflim))
#endif
                    goto success;
                }
	      if (dfaexec (&dfa, beg, (char *) end, 0, NULL, &backref) == NULL)
		continue;
	    }
	  else
	    {
	      /* No good fixed strings; start with DFA. */
	      char const *next_beg = dfaexec (&dfa, beg, (char *) buflim,
					      0, NULL, &backref);
	      if (next_beg == NULL)
		break;
	      /* Narrow down to the line we've found. */
	      beg = next_beg;
	      if ((end = memchr(beg, eol, buflim - beg)) != NULL)
	        end++;
              else
                end = buflim;
	      while (beg > buf && beg[-1] != eol)
		--beg;
	    }
	  /* Successful, no backreferences encountered! */
	  if (!backref)
	    goto success;
	}
      else
	{
	  /* We are looking for the leftmost (then longest) exact match.
	     We will go through the outer loop only once.  */
	  beg = start_ptr;
	  end = buflim;
	}

      /* If we've made it to this point, this means DFA has seen
	 a probable match, and we need to run it through Regex. */
      best_match = end;
      best_len = 0;
      for (i = 0; i < pcount; i++)
	{
	  patterns[i].regexbuf.not_eol = 0;
	  if (0 <= (start = re_search (&(patterns[i].regexbuf),
				       buf, end - buf - 1,
				       beg - buf, end - beg - 1,
				       &(patterns[i].regs))))
	    {
	      len = patterns[i].regs.end[0] - start;
	      match = buf + start;
	      if (match > best_match)
		continue;
	      if (start_ptr && !match_words)
		goto assess_pattern_match;
	      if ((!match_lines && !match_words)
		  || (match_lines && len == end - beg - 1))
		{
		  match = beg;
		  len = end - beg;
		  goto assess_pattern_match;
		}
	      /* If -w, check if the match aligns with word boundaries.
		 We do this iteratively because:
		 (a) the line may contain more than one occurence of the
		 pattern, and
		 (b) Several alternatives in the pattern might be valid at a
		 given point, and we may need to consider a shorter one to
		 find a word boundary.  */
	      if (match_words)
		while (match <= best_match)
		  {
		    if ((match == buf || !WCHAR ((unsigned char) match[-1]))
			&& (len == end - beg - 1
			    || !WCHAR ((unsigned char) match[len])))
		      goto assess_pattern_match;
		    if (len > 0)
		      {
			/* Try a shorter length anchored at the same place. */
			--len;
			patterns[i].regexbuf.not_eol = 1;
			len = re_match (&(patterns[i].regexbuf),
					buf, match + len - beg, match - buf,
					&(patterns[i].regs));
		      }
		    if (len <= 0)
		      {
			/* Try looking further on. */
			if (match == end - 1)
			  break;
			match++;
			patterns[i].regexbuf.not_eol = 0;
			start = re_search (&(patterns[i].regexbuf),
					   buf, end - buf - 1,
					   match - buf, end - match - 1,
					   &(patterns[i].regs));
			if (start < 0)
			  break;
			len = patterns[i].regs.end[0] - start;
			match = buf + start;
		      }
		  } /* while (match <= best_match) */
	      continue;
	    assess_pattern_match:
	      if (!start_ptr)
		{
		  /* Good enough for a non-exact match.
		     No need to look at further patterns, if any.  */
		  beg = match;
		  goto success_in_len;
		}
	      if (match < best_match || (match == best_match && len > best_len))
		{
		  /* Best exact match:  leftmost, then longest.  */
		  best_match = match;
		  best_len = len;
		}
	    } /* if re_search >= 0 */
	} /* for Regex patterns.  */
	if (best_match < end)
	  {
	    /* We have found an exact match.  We were just
	       waiting for the best one (leftmost then longest).  */
	    beg = best_match;
	    len = best_len;
	    goto success_in_len;
	  }
    } /* for (beg = end ..) */

 failure:
  ret_val = -1;
  goto out;

 success:
  len = end - beg;
 success_in_len:
  *match_size = len;
  ret_val = beg - buf;
 out:
  return ret_val;
}

Spawn 1 instances, now Total 34
Counter: 35
Batcher Size:34
Preprocess the following candidate with CondTester:
Priority 20000
At location src/dfasearch.c:108
--Src File: src/dfasearch.c
Fragment 0:
if ((dm->exact) || (__abst_hole(dm, dm->exact, err, dm->must, dm->next, kwset, kwset_exact_matches)))
    continue;


CondTester, a patch instance with id 34:
//src_file:src/dfasearch.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); void* memset(void*, int, unsigned long); 
/* dfasearch.c - searching subroutines using dfa and regex for grep.
   Copyright 1992, 1998, 2000, 2007, 2009-2010 Free Software Foundation, Inc.

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 3, or (at your option)
   any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program; if not, write to the Free Software
   Foundation, Inc., 51 Franklin Street - Fifth Floor, Boston, MA
   02110-1301, USA.  */

/* Written August 1992 by Mike Haertel. */

#include <config.h>
#include "search.h"
#include "dfa.h"

/* For -w, we also consider _ to be word constituent.  */
#define WCHAR(C) (ISALNUM(C) || (C) == '_')

/* KWset compiled pattern.  For Ecompile and Gcompile, we compile
   a list of strings, at least one of which is known to occur in
   any string matching the regexp. */
static kwset_t kwset;

/* DFA compiled regexp. */
static struct dfa dfa;

/* The Regex compiled patterns.  */
static struct patterns
{
  /* Regex compiled regexp. */
  struct re_pattern_buffer regexbuf;
  struct re_registers regs; /* This is here on account of a BRAIN-DEAD
			       Q@#%!# library interface in regex.c.  */
} patterns0;

struct patterns *patterns;
size_t pcount;

void
dfaerror (char const *mesg)
{
  error (EXIT_TROUBLE, 0, "%s", mesg);

  /* notreached */
  /* Tell static analyzers that this function does not return.  */
  abort ();
}

/* Number of compiled fixed strings known to exactly match the regexp.
   If kwsexec returns < kwset_exact_matches, then we don't need to
   call the regexp matcher at all. */
static int kwset_exact_matches;

static char const *
kwsincr_case (const char *must)
{
  const char *buf;
  size_t n;

  n = strlen (must);
#ifdef MBS_SUPPORT
  if (match_icase && MB_CUR_MAX > 1)
    buf = mbtolower (must, &n);
  else
#endif
    buf = must;
  return kwsincr (kwset, buf, n);
}

/* If the DFA turns out to have some set of fixed strings one of
   which must occur in the match, then we build a kwset matcher
   to find those strings, and thus quickly filter out impossible
   matches. */
static void
kwsmusts (void)
{
  struct dfamust const *dm;
  char const *err;

  if (dfa.musts)
    {
      kwsinit (&kwset);
      /* First, we compile in the substrings known to be exact
	 matches.  The kwset matcher will return the index
	 of the matching string that it chooses. */
      for (dm = dfa.musts; dm; dm = dm->next)
	{
	  if (!dm->exact)
	    continue;
	  ++kwset_exact_matches;
	  if ((err = kwsincr_case (dm->must)) != NULL)
	    error (EXIT_TROUBLE, 0, "%s", err);
	}
      /* Now, we compile the substrings that will require
	 the use of the regexp matcher.  */
      for (dm = dfa.musts; dm; dm = dm->next)
	{
	  
//Patch 0:
if ((dm->exact) || (__is_neg(7, &(dm), sizeof (dm), &(dm->exact), sizeof (dm->exact), &(err), sizeof (err), &(dm->must), sizeof (dm->must), &(dm->next), sizeof (dm->next), &(kwset), sizeof (kwset), &(kwset_exact_matches), sizeof (kwset_exact_matches))))
    continue;

//CodeSeg 1:
	  if ((err = kwsincr_case (dm->must)) != NULL)
	    error (EXIT_TROUBLE, 0, "%s", err);
	}
      if ((err = kwsprep (kwset)) != NULL)
	error (EXIT_TROUBLE, 0, "%s", err);
    }
}

void
GEAcompile (char const *pattern, size_t size, reg_syntax_t syntax_bits)
{
  const char *err;
  const char *p, *sep;
  size_t total = size;
  char *motif;

  if (match_icase)
    syntax_bits |= RE_ICASE;
  re_set_syntax (syntax_bits);
  dfasyntax (syntax_bits, match_icase, eolbyte);

  /* For GNU regex compiler we have to pass the patterns separately to detect
     errors like "[\nallo\n]\n".  The patterns here are "[", "allo" and "]"
     GNU regex should have raise a syntax error.  The same for backref, where
     the backref should have been local to each pattern.  */
  p = pattern;
  do
    {
      size_t len;
      sep = memchr (p, '\n', total);
      if (sep)
	{
	  len = sep - p;
	  sep++;
	  total -= (len + 1);
	}
      else
	{
	  len = total;
	  total = 0;
	}

      patterns = realloc (patterns, (pcount + 1) * sizeof (*patterns));
      if (patterns == NULL)
	error (EXIT_TROUBLE, errno, _("memory exhausted"));
      patterns[pcount] = patterns0;

      if ((err = re_compile_pattern (p, len,
				    &(patterns[pcount].regexbuf))) != NULL)
	error (EXIT_TROUBLE, 0, "%s", err);
      pcount++;

      p = sep;
    } while (sep && total != 0);

  /* In the match_words and match_lines cases, we use a different pattern
     for the DFA matcher that will quickly throw out cases that won't work.
     Then if DFA succeeds we do some hairy stuff using the regex matcher
     to decide whether the match should really count. */
  if (match_words || match_lines)
    {
      static char const line_beg_no_bk[] = "^(";
      static char const line_end_no_bk[] = ")$";
      static char const word_beg_no_bk[] = "(^|[^[:alnum:]_])(";
      static char const word_end_no_bk[] = ")([^[:alnum:]_]|$)";
      static char const line_beg_bk[] = "^\\(";
      static char const line_end_bk[] = "\\)$";
      static char const word_beg_bk[] = "\\(^\\|[^[:alnum:]_]\\)\\(";
      static char const word_end_bk[] = "\\)\\([^[:alnum:]_]\\|$\\)";
      int bk = !(syntax_bits & RE_NO_BK_PARENS);
      char *n = xmalloc (sizeof word_beg_bk - 1 + size + sizeof word_end_bk);

      strcpy (n, match_lines ? (bk ? line_beg_bk : line_beg_no_bk)
			     : (bk ? word_beg_bk : word_beg_no_bk));
      total = strlen(n);
      memcpy (n + total, pattern, size);
      total += size;
      strcpy (n + total, match_lines ? (bk ? line_end_bk : line_end_no_bk)
				     : (bk ? word_end_bk : word_end_no_bk));
      total += strlen (n + total);
      pattern = motif = n;
      size = total;
    }
  else
    motif = NULL;

  dfacomp (pattern, size, &dfa, 1);
  kwsmusts ();

  free(motif);
}

size_t
EGexecute (char const *buf, size_t size, size_t *match_size,
	   char const *start_ptr)
{
  char const *buflim, *beg, *end, *match, *best_match, *mb_start;
  char eol = eolbyte;
  int backref, start, len, best_len;
  struct kwsmatch kwsm;
  size_t i, ret_val;
#ifdef MBS_SUPPORT
  if (MB_CUR_MAX > 1)
    {
      if (match_icase)
        {
          /* mbtolower adds a NUL byte at the end.  That will provide
	     space for the sentinel byte dfaexec may add.  */
          char *case_buf = mbtolower (buf, &size);
	  if (start_ptr)
	    start_ptr = case_buf + (start_ptr - buf);
          buf = case_buf;
        }
    }
#endif /* MBS_SUPPORT */

  mb_start = buf;
  buflim = buf + size;

  for (beg = end = buf; end < buflim; beg = end)
    {
      if (!start_ptr)
	{
	  /* We don't care about an exact match.  */
	  if (kwset)
	    {
	      /* Find a possible match using the KWset matcher. */
	      size_t offset = kwsexec (kwset, beg, buflim - beg, &kwsm);
	      if (offset == (size_t) -1)
		goto failure;
	      beg += offset;
	      /* Narrow down to the line containing the candidate, and
		 run it through DFA. */
	      if ((end = memchr(beg, eol, buflim - beg)) != NULL)
	        end++;
              else
                end = buflim;
	      match = beg;
	      while (beg > buf && beg[-1] != eol)
		--beg;
	      if (kwsm.index < kwset_exact_matches)
                {
#ifdef MBS_SUPPORT
                  if (mb_start < beg)
                    mb_start = beg;
                  if (MB_CUR_MAX == 1 || !is_mb_middle (&mb_start, match, buflim))
#endif
                    goto success;
                }
	      if (dfaexec (&dfa, beg, (char *) end, 0, NULL, &backref) == NULL)
		continue;
	    }
	  else
	    {
	      /* No good fixed strings; start with DFA. */
	      char const *next_beg = dfaexec (&dfa, beg, (char *) buflim,
					      0, NULL, &backref);
	      if (next_beg == NULL)
		break;
	      /* Narrow down to the line we've found. */
	      beg = next_beg;
	      if ((end = memchr(beg, eol, buflim - beg)) != NULL)
	        end++;
              else
                end = buflim;
	      while (beg > buf && beg[-1] != eol)
		--beg;
	    }
	  /* Successful, no backreferences encountered! */
	  if (!backref)
	    goto success;
	}
      else
	{
	  /* We are looking for the leftmost (then longest) exact match.
	     We will go through the outer loop only once.  */
	  beg = start_ptr;
	  end = buflim;
	}

      /* If we've made it to this point, this means DFA has seen
	 a probable match, and we need to run it through Regex. */
      best_match = end;
      best_len = 0;
      for (i = 0; i < pcount; i++)
	{
	  patterns[i].regexbuf.not_eol = 0;
	  if (0 <= (start = re_search (&(patterns[i].regexbuf),
				       buf, end - buf - 1,
				       beg - buf, end - beg - 1,
				       &(patterns[i].regs))))
	    {
	      len = patterns[i].regs.end[0] - start;
	      match = buf + start;
	      if (match > best_match)
		continue;
	      if (start_ptr && !match_words)
		goto assess_pattern_match;
	      if ((!match_lines && !match_words)
		  || (match_lines && len == end - beg - 1))
		{
		  match = beg;
		  len = end - beg;
		  goto assess_pattern_match;
		}
	      /* If -w, check if the match aligns with word boundaries.
		 We do this iteratively because:
		 (a) the line may contain more than one occurence of the
		 pattern, and
		 (b) Several alternatives in the pattern might be valid at a
		 given point, and we may need to consider a shorter one to
		 find a word boundary.  */
	      if (match_words)
		while (match <= best_match)
		  {
		    if ((match == buf || !WCHAR ((unsigned char) match[-1]))
			&& (len == end - beg - 1
			    || !WCHAR ((unsigned char) match[len])))
		      goto assess_pattern_match;
		    if (len > 0)
		      {
			/* Try a shorter length anchored at the same place. */
			--len;
			patterns[i].regexbuf.not_eol = 1;
			len = re_match (&(patterns[i].regexbuf),
					buf, match + len - beg, match - buf,
					&(patterns[i].regs));
		      }
		    if (len <= 0)
		      {
			/* Try looking further on. */
			if (match == end - 1)
			  break;
			match++;
			patterns[i].regexbuf.not_eol = 0;
			start = re_search (&(patterns[i].regexbuf),
					   buf, end - buf - 1,
					   match - buf, end - match - 1,
					   &(patterns[i].regs));
			if (start < 0)
			  break;
			len = patterns[i].regs.end[0] - start;
			match = buf + start;
		      }
		  } /* while (match <= best_match) */
	      continue;
	    assess_pattern_match:
	      if (!start_ptr)
		{
		  /* Good enough for a non-exact match.
		     No need to look at further patterns, if any.  */
		  beg = match;
		  goto success_in_len;
		}
	      if (match < best_match || (match == best_match && len > best_len))
		{
		  /* Best exact match:  leftmost, then longest.  */
		  best_match = match;
		  best_len = len;
		}
	    } /* if re_search >= 0 */
	} /* for Regex patterns.  */
	if (best_match < end)
	  {
	    /* We have found an exact match.  We were just
	       waiting for the best one (leftmost then longest).  */
	    beg = best_match;
	    len = best_len;
	    goto success_in_len;
	  }
    } /* for (beg = end ..) */

 failure:
  ret_val = -1;
  goto out;

 success:
  len = end - beg;
 success_in_len:
  *match_size = len;
  ret_val = beg - buf;
 out:
  return ret_val;
}

Spawn 1 instances, now Total 35
Counter: 36
Batcher Size:35
Preprocess the following candidate with CondTester:
Priority 20000
At location src/dfasearch.c:126
--Src File: src/dfasearch.c
Fragment 0:
if ((match_icase) || (__abst_hole(match_icase, syntax_bits, size, eolbyte, pattern, p, sep, total, patterns, pcount, err, match_words, match_lines, motif)))
    syntax_bits |= ((((((((((((((((((((((((unsigned long)1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1);


CondTester, a patch instance with id 35:
//src_file:src/dfasearch.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); void* memset(void*, int, unsigned long); 
/* dfasearch.c - searching subroutines using dfa and regex for grep.
   Copyright 1992, 1998, 2000, 2007, 2009-2010 Free Software Foundation, Inc.

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 3, or (at your option)
   any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program; if not, write to the Free Software
   Foundation, Inc., 51 Franklin Street - Fifth Floor, Boston, MA
   02110-1301, USA.  */

/* Written August 1992 by Mike Haertel. */

#include <config.h>
#include "search.h"
#include "dfa.h"

/* For -w, we also consider _ to be word constituent.  */
#define WCHAR(C) (ISALNUM(C) || (C) == '_')

/* KWset compiled pattern.  For Ecompile and Gcompile, we compile
   a list of strings, at least one of which is known to occur in
   any string matching the regexp. */
static kwset_t kwset;

/* DFA compiled regexp. */
static struct dfa dfa;

/* The Regex compiled patterns.  */
static struct patterns
{
  /* Regex compiled regexp. */
  struct re_pattern_buffer regexbuf;
  struct re_registers regs; /* This is here on account of a BRAIN-DEAD
			       Q@#%!# library interface in regex.c.  */
} patterns0;

struct patterns *patterns;
size_t pcount;

void
dfaerror (char const *mesg)
{
  error (EXIT_TROUBLE, 0, "%s", mesg);

  /* notreached */
  /* Tell static analyzers that this function does not return.  */
  abort ();
}

/* Number of compiled fixed strings known to exactly match the regexp.
   If kwsexec returns < kwset_exact_matches, then we don't need to
   call the regexp matcher at all. */
static int kwset_exact_matches;

static char const *
kwsincr_case (const char *must)
{
  const char *buf;
  size_t n;

  n = strlen (must);
#ifdef MBS_SUPPORT
  if (match_icase && MB_CUR_MAX > 1)
    buf = mbtolower (must, &n);
  else
#endif
    buf = must;
  return kwsincr (kwset, buf, n);
}

/* If the DFA turns out to have some set of fixed strings one of
   which must occur in the match, then we build a kwset matcher
   to find those strings, and thus quickly filter out impossible
   matches. */
static void
kwsmusts (void)
{
  struct dfamust const *dm;
  char const *err;

  if (dfa.musts)
    {
      kwsinit (&kwset);
      /* First, we compile in the substrings known to be exact
	 matches.  The kwset matcher will return the index
	 of the matching string that it chooses. */
      for (dm = dfa.musts; dm; dm = dm->next)
	{
	  if (!dm->exact)
	    continue;
	  ++kwset_exact_matches;
	  if ((err = kwsincr_case (dm->must)) != NULL)
	    error (EXIT_TROUBLE, 0, "%s", err);
	}
      /* Now, we compile the substrings that will require
	 the use of the regexp matcher.  */
      for (dm = dfa.musts; dm; dm = dm->next)
	{
	  if (dm->exact)
	    continue;
	  if ((err = kwsincr_case (dm->must)) != NULL)
	    error (EXIT_TROUBLE, 0, "%s", err);
	}
      if ((err = kwsprep (kwset)) != NULL)
	error (EXIT_TROUBLE, 0, "%s", err);
    }
}

void
GEAcompile (char const *pattern, size_t size, reg_syntax_t syntax_bits)
{
  const char *err;
  const char *p, *sep;
  size_t total = size;
  char *motif;

  
//Patch 0:
if ((match_icase) || (__is_neg(14, &(match_icase), sizeof (match_icase), &(syntax_bits), sizeof (syntax_bits), &(size), sizeof (size), &(eolbyte), sizeof (eolbyte), &(pattern), sizeof (pattern), &(p), sizeof (p), &(sep), sizeof (sep), &(total), sizeof (total), &(patterns), sizeof (patterns), &(pcount), sizeof (pcount), &(err), sizeof (err), &(match_words), sizeof (match_words), &(match_lines), sizeof (match_lines), &(motif), sizeof (motif))))
    syntax_bits |= ((((((((((((((((((((((((unsigned long)1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1);

//CodeSeg 1:
  re_set_syntax (syntax_bits);
  dfasyntax (syntax_bits, match_icase, eolbyte);

  /* For GNU regex compiler we have to pass the patterns separately to detect
     errors like "[\nallo\n]\n".  The patterns here are "[", "allo" and "]"
     GNU regex should have raise a syntax error.  The same for backref, where
     the backref should have been local to each pattern.  */
  p = pattern;
  do
    {
      size_t len;
      sep = memchr (p, '\n', total);
      if (sep)
	{
	  len = sep - p;
	  sep++;
	  total -= (len + 1);
	}
      else
	{
	  len = total;
	  total = 0;
	}

      patterns = realloc (patterns, (pcount + 1) * sizeof (*patterns));
      if (patterns == NULL)
	error (EXIT_TROUBLE, errno, _("memory exhausted"));
      patterns[pcount] = patterns0;

      if ((err = re_compile_pattern (p, len,
				    &(patterns[pcount].regexbuf))) != NULL)
	error (EXIT_TROUBLE, 0, "%s", err);
      pcount++;

      p = sep;
    } while (sep && total != 0);

  /* In the match_words and match_lines cases, we use a different pattern
     for the DFA matcher that will quickly throw out cases that won't work.
     Then if DFA succeeds we do some hairy stuff using the regex matcher
     to decide whether the match should really count. */
  if (match_words || match_lines)
    {
      static char const line_beg_no_bk[] = "^(";
      static char const line_end_no_bk[] = ")$";
      static char const word_beg_no_bk[] = "(^|[^[:alnum:]_])(";
      static char const word_end_no_bk[] = ")([^[:alnum:]_]|$)";
      static char const line_beg_bk[] = "^\\(";
      static char const line_end_bk[] = "\\)$";
      static char const word_beg_bk[] = "\\(^\\|[^[:alnum:]_]\\)\\(";
      static char const word_end_bk[] = "\\)\\([^[:alnum:]_]\\|$\\)";
      int bk = !(syntax_bits & RE_NO_BK_PARENS);
      char *n = xmalloc (sizeof word_beg_bk - 1 + size + sizeof word_end_bk);

      strcpy (n, match_lines ? (bk ? line_beg_bk : line_beg_no_bk)
			     : (bk ? word_beg_bk : word_beg_no_bk));
      total = strlen(n);
      memcpy (n + total, pattern, size);
      total += size;
      strcpy (n + total, match_lines ? (bk ? line_end_bk : line_end_no_bk)
				     : (bk ? word_end_bk : word_end_no_bk));
      total += strlen (n + total);
      pattern = motif = n;
      size = total;
    }
  else
    motif = NULL;

  dfacomp (pattern, size, &dfa, 1);
  kwsmusts ();

  free(motif);
}

size_t
EGexecute (char const *buf, size_t size, size_t *match_size,
	   char const *start_ptr)
{
  char const *buflim, *beg, *end, *match, *best_match, *mb_start;
  char eol = eolbyte;
  int backref, start, len, best_len;
  struct kwsmatch kwsm;
  size_t i, ret_val;
#ifdef MBS_SUPPORT
  if (MB_CUR_MAX > 1)
    {
      if (match_icase)
        {
          /* mbtolower adds a NUL byte at the end.  That will provide
	     space for the sentinel byte dfaexec may add.  */
          char *case_buf = mbtolower (buf, &size);
	  if (start_ptr)
	    start_ptr = case_buf + (start_ptr - buf);
          buf = case_buf;
        }
    }
#endif /* MBS_SUPPORT */

  mb_start = buf;
  buflim = buf + size;

  for (beg = end = buf; end < buflim; beg = end)
    {
      if (!start_ptr)
	{
	  /* We don't care about an exact match.  */
	  if (kwset)
	    {
	      /* Find a possible match using the KWset matcher. */
	      size_t offset = kwsexec (kwset, beg, buflim - beg, &kwsm);
	      if (offset == (size_t) -1)
		goto failure;
	      beg += offset;
	      /* Narrow down to the line containing the candidate, and
		 run it through DFA. */
	      if ((end = memchr(beg, eol, buflim - beg)) != NULL)
	        end++;
              else
                end = buflim;
	      match = beg;
	      while (beg > buf && beg[-1] != eol)
		--beg;
	      if (kwsm.index < kwset_exact_matches)
                {
#ifdef MBS_SUPPORT
                  if (mb_start < beg)
                    mb_start = beg;
                  if (MB_CUR_MAX == 1 || !is_mb_middle (&mb_start, match, buflim))
#endif
                    goto success;
                }
	      if (dfaexec (&dfa, beg, (char *) end, 0, NULL, &backref) == NULL)
		continue;
	    }
	  else
	    {
	      /* No good fixed strings; start with DFA. */
	      char const *next_beg = dfaexec (&dfa, beg, (char *) buflim,
					      0, NULL, &backref);
	      if (next_beg == NULL)
		break;
	      /* Narrow down to the line we've found. */
	      beg = next_beg;
	      if ((end = memchr(beg, eol, buflim - beg)) != NULL)
	        end++;
              else
                end = buflim;
	      while (beg > buf && beg[-1] != eol)
		--beg;
	    }
	  /* Successful, no backreferences encountered! */
	  if (!backref)
	    goto success;
	}
      else
	{
	  /* We are looking for the leftmost (then longest) exact match.
	     We will go through the outer loop only once.  */
	  beg = start_ptr;
	  end = buflim;
	}

      /* If we've made it to this point, this means DFA has seen
	 a probable match, and we need to run it through Regex. */
      best_match = end;
      best_len = 0;
      for (i = 0; i < pcount; i++)
	{
	  patterns[i].regexbuf.not_eol = 0;
	  if (0 <= (start = re_search (&(patterns[i].regexbuf),
				       buf, end - buf - 1,
				       beg - buf, end - beg - 1,
				       &(patterns[i].regs))))
	    {
	      len = patterns[i].regs.end[0] - start;
	      match = buf + start;
	      if (match > best_match)
		continue;
	      if (start_ptr && !match_words)
		goto assess_pattern_match;
	      if ((!match_lines && !match_words)
		  || (match_lines && len == end - beg - 1))
		{
		  match = beg;
		  len = end - beg;
		  goto assess_pattern_match;
		}
	      /* If -w, check if the match aligns with word boundaries.
		 We do this iteratively because:
		 (a) the line may contain more than one occurence of the
		 pattern, and
		 (b) Several alternatives in the pattern might be valid at a
		 given point, and we may need to consider a shorter one to
		 find a word boundary.  */
	      if (match_words)
		while (match <= best_match)
		  {
		    if ((match == buf || !WCHAR ((unsigned char) match[-1]))
			&& (len == end - beg - 1
			    || !WCHAR ((unsigned char) match[len])))
		      goto assess_pattern_match;
		    if (len > 0)
		      {
			/* Try a shorter length anchored at the same place. */
			--len;
			patterns[i].regexbuf.not_eol = 1;
			len = re_match (&(patterns[i].regexbuf),
					buf, match + len - beg, match - buf,
					&(patterns[i].regs));
		      }
		    if (len <= 0)
		      {
			/* Try looking further on. */
			if (match == end - 1)
			  break;
			match++;
			patterns[i].regexbuf.not_eol = 0;
			start = re_search (&(patterns[i].regexbuf),
					   buf, end - buf - 1,
					   match - buf, end - match - 1,
					   &(patterns[i].regs));
			if (start < 0)
			  break;
			len = patterns[i].regs.end[0] - start;
			match = buf + start;
		      }
		  } /* while (match <= best_match) */
	      continue;
	    assess_pattern_match:
	      if (!start_ptr)
		{
		  /* Good enough for a non-exact match.
		     No need to look at further patterns, if any.  */
		  beg = match;
		  goto success_in_len;
		}
	      if (match < best_match || (match == best_match && len > best_len))
		{
		  /* Best exact match:  leftmost, then longest.  */
		  best_match = match;
		  best_len = len;
		}
	    } /* if re_search >= 0 */
	} /* for Regex patterns.  */
	if (best_match < end)
	  {
	    /* We have found an exact match.  We were just
	       waiting for the best one (leftmost then longest).  */
	    beg = best_match;
	    len = best_len;
	    goto success_in_len;
	  }
    } /* for (beg = end ..) */

 failure:
  ret_val = -1;
  goto out;

 success:
  len = end - beg;
 success_in_len:
  *match_size = len;
  ret_val = beg - buf;
 out:
  return ret_val;
}

Spawn 1 instances, now Total 36
Counter: 37
Batcher Size:36
Preprocess the following candidate with CondTester:
Priority 20000
At location src/dfasearch.c:214
--Src File: src/dfasearch.c
Fragment 0:
if ((match_icase) && !(__abst_hole(match_icase, buf, size, start_ptr, eolbyte, mb_start, buflim, beg, end, kwset, eol, match, kwset_exact_matches, backref, best_match, best_len, i, pcount, patterns, start, len, match_words, match_lines, ret_val, match_size))) {
    char *case_buf = mbtolower(buf, &size);
    if (start_ptr)
        start_ptr = case_buf + (start_ptr - buf);
    buf = case_buf;
}


CondTester, a patch instance with id 36:
//src_file:src/dfasearch.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); void* memset(void*, int, unsigned long); 
/* dfasearch.c - searching subroutines using dfa and regex for grep.
   Copyright 1992, 1998, 2000, 2007, 2009-2010 Free Software Foundation, Inc.

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 3, or (at your option)
   any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program; if not, write to the Free Software
   Foundation, Inc., 51 Franklin Street - Fifth Floor, Boston, MA
   02110-1301, USA.  */

/* Written August 1992 by Mike Haertel. */

#include <config.h>
#include "search.h"
#include "dfa.h"

/* For -w, we also consider _ to be word constituent.  */
#define WCHAR(C) (ISALNUM(C) || (C) == '_')

/* KWset compiled pattern.  For Ecompile and Gcompile, we compile
   a list of strings, at least one of which is known to occur in
   any string matching the regexp. */
static kwset_t kwset;

/* DFA compiled regexp. */
static struct dfa dfa;

/* The Regex compiled patterns.  */
static struct patterns
{
  /* Regex compiled regexp. */
  struct re_pattern_buffer regexbuf;
  struct re_registers regs; /* This is here on account of a BRAIN-DEAD
			       Q@#%!# library interface in regex.c.  */
} patterns0;

struct patterns *patterns;
size_t pcount;

void
dfaerror (char const *mesg)
{
  error (EXIT_TROUBLE, 0, "%s", mesg);

  /* notreached */
  /* Tell static analyzers that this function does not return.  */
  abort ();
}

/* Number of compiled fixed strings known to exactly match the regexp.
   If kwsexec returns < kwset_exact_matches, then we don't need to
   call the regexp matcher at all. */
static int kwset_exact_matches;

static char const *
kwsincr_case (const char *must)
{
  const char *buf;
  size_t n;

  n = strlen (must);
#ifdef MBS_SUPPORT
  if (match_icase && MB_CUR_MAX > 1)
    buf = mbtolower (must, &n);
  else
#endif
    buf = must;
  return kwsincr (kwset, buf, n);
}

/* If the DFA turns out to have some set of fixed strings one of
   which must occur in the match, then we build a kwset matcher
   to find those strings, and thus quickly filter out impossible
   matches. */
static void
kwsmusts (void)
{
  struct dfamust const *dm;
  char const *err;

  if (dfa.musts)
    {
      kwsinit (&kwset);
      /* First, we compile in the substrings known to be exact
	 matches.  The kwset matcher will return the index
	 of the matching string that it chooses. */
      for (dm = dfa.musts; dm; dm = dm->next)
	{
	  if (!dm->exact)
	    continue;
	  ++kwset_exact_matches;
	  if ((err = kwsincr_case (dm->must)) != NULL)
	    error (EXIT_TROUBLE, 0, "%s", err);
	}
      /* Now, we compile the substrings that will require
	 the use of the regexp matcher.  */
      for (dm = dfa.musts; dm; dm = dm->next)
	{
	  if (dm->exact)
	    continue;
	  if ((err = kwsincr_case (dm->must)) != NULL)
	    error (EXIT_TROUBLE, 0, "%s", err);
	}
      if ((err = kwsprep (kwset)) != NULL)
	error (EXIT_TROUBLE, 0, "%s", err);
    }
}

void
GEAcompile (char const *pattern, size_t size, reg_syntax_t syntax_bits)
{
  const char *err;
  const char *p, *sep;
  size_t total = size;
  char *motif;

  if (match_icase)
    syntax_bits |= RE_ICASE;
  re_set_syntax (syntax_bits);
  dfasyntax (syntax_bits, match_icase, eolbyte);

  /* For GNU regex compiler we have to pass the patterns separately to detect
     errors like "[\nallo\n]\n".  The patterns here are "[", "allo" and "]"
     GNU regex should have raise a syntax error.  The same for backref, where
     the backref should have been local to each pattern.  */
  p = pattern;
  do
    {
      size_t len;
      sep = memchr (p, '\n', total);
      if (sep)
	{
	  len = sep - p;
	  sep++;
	  total -= (len + 1);
	}
      else
	{
	  len = total;
	  total = 0;
	}

      patterns = realloc (patterns, (pcount + 1) * sizeof (*patterns));
      if (patterns == NULL)
	error (EXIT_TROUBLE, errno, _("memory exhausted"));
      patterns[pcount] = patterns0;

      if ((err = re_compile_pattern (p, len,
				    &(patterns[pcount].regexbuf))) != NULL)
	error (EXIT_TROUBLE, 0, "%s", err);
      pcount++;

      p = sep;
    } while (sep && total != 0);

  /* In the match_words and match_lines cases, we use a different pattern
     for the DFA matcher that will quickly throw out cases that won't work.
     Then if DFA succeeds we do some hairy stuff using the regex matcher
     to decide whether the match should really count. */
  if (match_words || match_lines)
    {
      static char const line_beg_no_bk[] = "^(";
      static char const line_end_no_bk[] = ")$";
      static char const word_beg_no_bk[] = "(^|[^[:alnum:]_])(";
      static char const word_end_no_bk[] = ")([^[:alnum:]_]|$)";
      static char const line_beg_bk[] = "^\\(";
      static char const line_end_bk[] = "\\)$";
      static char const word_beg_bk[] = "\\(^\\|[^[:alnum:]_]\\)\\(";
      static char const word_end_bk[] = "\\)\\([^[:alnum:]_]\\|$\\)";
      int bk = !(syntax_bits & RE_NO_BK_PARENS);
      char *n = xmalloc (sizeof word_beg_bk - 1 + size + sizeof word_end_bk);

      strcpy (n, match_lines ? (bk ? line_beg_bk : line_beg_no_bk)
			     : (bk ? word_beg_bk : word_beg_no_bk));
      total = strlen(n);
      memcpy (n + total, pattern, size);
      total += size;
      strcpy (n + total, match_lines ? (bk ? line_end_bk : line_end_no_bk)
				     : (bk ? word_end_bk : word_end_no_bk));
      total += strlen (n + total);
      pattern = motif = n;
      size = total;
    }
  else
    motif = NULL;

  dfacomp (pattern, size, &dfa, 1);
  kwsmusts ();

  free(motif);
}

size_t
EGexecute (char const *buf, size_t size, size_t *match_size,
	   char const *start_ptr)
{
  char const *buflim, *beg, *end, *match, *best_match, *mb_start;
  char eol = eolbyte;
  int backref, start, len, best_len;
  struct kwsmatch kwsm;
  size_t i, ret_val;
#ifdef MBS_SUPPORT
  if (MB_CUR_MAX > 1)
    {
      
//Patch 0:
if ((match_icase) && !(__is_neg(25, &(match_icase), sizeof (match_icase), &(buf), sizeof (buf), &(size), sizeof (size), &(start_ptr), sizeof (start_ptr), &(eolbyte), sizeof (eolbyte), &(mb_start), sizeof (mb_start), &(buflim), sizeof (buflim), &(beg), sizeof (beg), &(end), sizeof (end), &(kwset), sizeof (kwset), &(eol), sizeof (eol), &(match), sizeof (match), &(kwset_exact_matches), sizeof (kwset_exact_matches), &(backref), sizeof (backref), &(best_match), sizeof (best_match), &(best_len), sizeof (best_len), &(i), sizeof (i), &(pcount), sizeof (pcount), &(patterns), sizeof (patterns), &(start), sizeof (start), &(len), sizeof (len), &(match_words), sizeof (match_words), &(match_lines), sizeof (match_lines), &(ret_val), sizeof (ret_val), &(match_size), sizeof (match_size)))) {
    char *case_buf = mbtolower(buf, &size);
    if (start_ptr)
        start_ptr = case_buf + (start_ptr - buf);
    buf = case_buf;
}

//CodeSeg 1:
    }
#endif /* MBS_SUPPORT */

  mb_start = buf;
  buflim = buf + size;

  for (beg = end = buf; end < buflim; beg = end)
    {
      if (!start_ptr)
	{
	  /* We don't care about an exact match.  */
	  if (kwset)
	    {
	      /* Find a possible match using the KWset matcher. */
	      size_t offset = kwsexec (kwset, beg, buflim - beg, &kwsm);
	      if (offset == (size_t) -1)
		goto failure;
	      beg += offset;
	      /* Narrow down to the line containing the candidate, and
		 run it through DFA. */
	      if ((end = memchr(beg, eol, buflim - beg)) != NULL)
	        end++;
              else
                end = buflim;
	      match = beg;
	      while (beg > buf && beg[-1] != eol)
		--beg;
	      if (kwsm.index < kwset_exact_matches)
                {
#ifdef MBS_SUPPORT
                  if (mb_start < beg)
                    mb_start = beg;
                  if (MB_CUR_MAX == 1 || !is_mb_middle (&mb_start, match, buflim))
#endif
                    goto success;
                }
	      if (dfaexec (&dfa, beg, (char *) end, 0, NULL, &backref) == NULL)
		continue;
	    }
	  else
	    {
	      /* No good fixed strings; start with DFA. */
	      char const *next_beg = dfaexec (&dfa, beg, (char *) buflim,
					      0, NULL, &backref);
	      if (next_beg == NULL)
		break;
	      /* Narrow down to the line we've found. */
	      beg = next_beg;
	      if ((end = memchr(beg, eol, buflim - beg)) != NULL)
	        end++;
              else
                end = buflim;
	      while (beg > buf && beg[-1] != eol)
		--beg;
	    }
	  /* Successful, no backreferences encountered! */
	  if (!backref)
	    goto success;
	}
      else
	{
	  /* We are looking for the leftmost (then longest) exact match.
	     We will go through the outer loop only once.  */
	  beg = start_ptr;
	  end = buflim;
	}

      /* If we've made it to this point, this means DFA has seen
	 a probable match, and we need to run it through Regex. */
      best_match = end;
      best_len = 0;
      for (i = 0; i < pcount; i++)
	{
	  patterns[i].regexbuf.not_eol = 0;
	  if (0 <= (start = re_search (&(patterns[i].regexbuf),
				       buf, end - buf - 1,
				       beg - buf, end - beg - 1,
				       &(patterns[i].regs))))
	    {
	      len = patterns[i].regs.end[0] - start;
	      match = buf + start;
	      if (match > best_match)
		continue;
	      if (start_ptr && !match_words)
		goto assess_pattern_match;
	      if ((!match_lines && !match_words)
		  || (match_lines && len == end - beg - 1))
		{
		  match = beg;
		  len = end - beg;
		  goto assess_pattern_match;
		}
	      /* If -w, check if the match aligns with word boundaries.
		 We do this iteratively because:
		 (a) the line may contain more than one occurence of the
		 pattern, and
		 (b) Several alternatives in the pattern might be valid at a
		 given point, and we may need to consider a shorter one to
		 find a word boundary.  */
	      if (match_words)
		while (match <= best_match)
		  {
		    if ((match == buf || !WCHAR ((unsigned char) match[-1]))
			&& (len == end - beg - 1
			    || !WCHAR ((unsigned char) match[len])))
		      goto assess_pattern_match;
		    if (len > 0)
		      {
			/* Try a shorter length anchored at the same place. */
			--len;
			patterns[i].regexbuf.not_eol = 1;
			len = re_match (&(patterns[i].regexbuf),
					buf, match + len - beg, match - buf,
					&(patterns[i].regs));
		      }
		    if (len <= 0)
		      {
			/* Try looking further on. */
			if (match == end - 1)
			  break;
			match++;
			patterns[i].regexbuf.not_eol = 0;
			start = re_search (&(patterns[i].regexbuf),
					   buf, end - buf - 1,
					   match - buf, end - match - 1,
					   &(patterns[i].regs));
			if (start < 0)
			  break;
			len = patterns[i].regs.end[0] - start;
			match = buf + start;
		      }
		  } /* while (match <= best_match) */
	      continue;
	    assess_pattern_match:
	      if (!start_ptr)
		{
		  /* Good enough for a non-exact match.
		     No need to look at further patterns, if any.  */
		  beg = match;
		  goto success_in_len;
		}
	      if (match < best_match || (match == best_match && len > best_len))
		{
		  /* Best exact match:  leftmost, then longest.  */
		  best_match = match;
		  best_len = len;
		}
	    } /* if re_search >= 0 */
	} /* for Regex patterns.  */
	if (best_match < end)
	  {
	    /* We have found an exact match.  We were just
	       waiting for the best one (leftmost then longest).  */
	    beg = best_match;
	    len = best_len;
	    goto success_in_len;
	  }
    } /* for (beg = end ..) */

 failure:
  ret_val = -1;
  goto out;

 success:
  len = end - beg;
 success_in_len:
  *match_size = len;
  ret_val = beg - buf;
 out:
  return ret_val;
}

Spawn 1 instances, now Total 37
Counter: 38
Batcher Size:37
Preprocess the following candidate with CondTester:
Priority 20000
At location src/dfasearch.c:214
--Src File: src/dfasearch.c
Fragment 0:
if ((match_icase) || (__abst_hole(match_icase, buf, size, start_ptr, eolbyte, mb_start, buflim, beg, end, kwset, eol, match, kwset_exact_matches, backref, best_match, best_len, i, pcount, patterns, start, len, match_words, match_lines, ret_val, match_size))) {
    char *case_buf = mbtolower(buf, &size);
    if (start_ptr)
        start_ptr = case_buf + (start_ptr - buf);
    buf = case_buf;
}


CondTester, a patch instance with id 37:
//src_file:src/dfasearch.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); void* memset(void*, int, unsigned long); 
/* dfasearch.c - searching subroutines using dfa and regex for grep.
   Copyright 1992, 1998, 2000, 2007, 2009-2010 Free Software Foundation, Inc.

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 3, or (at your option)
   any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program; if not, write to the Free Software
   Foundation, Inc., 51 Franklin Street - Fifth Floor, Boston, MA
   02110-1301, USA.  */

/* Written August 1992 by Mike Haertel. */

#include <config.h>
#include "search.h"
#include "dfa.h"

/* For -w, we also consider _ to be word constituent.  */
#define WCHAR(C) (ISALNUM(C) || (C) == '_')

/* KWset compiled pattern.  For Ecompile and Gcompile, we compile
   a list of strings, at least one of which is known to occur in
   any string matching the regexp. */
static kwset_t kwset;

/* DFA compiled regexp. */
static struct dfa dfa;

/* The Regex compiled patterns.  */
static struct patterns
{
  /* Regex compiled regexp. */
  struct re_pattern_buffer regexbuf;
  struct re_registers regs; /* This is here on account of a BRAIN-DEAD
			       Q@#%!# library interface in regex.c.  */
} patterns0;

struct patterns *patterns;
size_t pcount;

void
dfaerror (char const *mesg)
{
  error (EXIT_TROUBLE, 0, "%s", mesg);

  /* notreached */
  /* Tell static analyzers that this function does not return.  */
  abort ();
}

/* Number of compiled fixed strings known to exactly match the regexp.
   If kwsexec returns < kwset_exact_matches, then we don't need to
   call the regexp matcher at all. */
static int kwset_exact_matches;

static char const *
kwsincr_case (const char *must)
{
  const char *buf;
  size_t n;

  n = strlen (must);
#ifdef MBS_SUPPORT
  if (match_icase && MB_CUR_MAX > 1)
    buf = mbtolower (must, &n);
  else
#endif
    buf = must;
  return kwsincr (kwset, buf, n);
}

/* If the DFA turns out to have some set of fixed strings one of
   which must occur in the match, then we build a kwset matcher
   to find those strings, and thus quickly filter out impossible
   matches. */
static void
kwsmusts (void)
{
  struct dfamust const *dm;
  char const *err;

  if (dfa.musts)
    {
      kwsinit (&kwset);
      /* First, we compile in the substrings known to be exact
	 matches.  The kwset matcher will return the index
	 of the matching string that it chooses. */
      for (dm = dfa.musts; dm; dm = dm->next)
	{
	  if (!dm->exact)
	    continue;
	  ++kwset_exact_matches;
	  if ((err = kwsincr_case (dm->must)) != NULL)
	    error (EXIT_TROUBLE, 0, "%s", err);
	}
      /* Now, we compile the substrings that will require
	 the use of the regexp matcher.  */
      for (dm = dfa.musts; dm; dm = dm->next)
	{
	  if (dm->exact)
	    continue;
	  if ((err = kwsincr_case (dm->must)) != NULL)
	    error (EXIT_TROUBLE, 0, "%s", err);
	}
      if ((err = kwsprep (kwset)) != NULL)
	error (EXIT_TROUBLE, 0, "%s", err);
    }
}

void
GEAcompile (char const *pattern, size_t size, reg_syntax_t syntax_bits)
{
  const char *err;
  const char *p, *sep;
  size_t total = size;
  char *motif;

  if (match_icase)
    syntax_bits |= RE_ICASE;
  re_set_syntax (syntax_bits);
  dfasyntax (syntax_bits, match_icase, eolbyte);

  /* For GNU regex compiler we have to pass the patterns separately to detect
     errors like "[\nallo\n]\n".  The patterns here are "[", "allo" and "]"
     GNU regex should have raise a syntax error.  The same for backref, where
     the backref should have been local to each pattern.  */
  p = pattern;
  do
    {
      size_t len;
      sep = memchr (p, '\n', total);
      if (sep)
	{
	  len = sep - p;
	  sep++;
	  total -= (len + 1);
	}
      else
	{
	  len = total;
	  total = 0;
	}

      patterns = realloc (patterns, (pcount + 1) * sizeof (*patterns));
      if (patterns == NULL)
	error (EXIT_TROUBLE, errno, _("memory exhausted"));
      patterns[pcount] = patterns0;

      if ((err = re_compile_pattern (p, len,
				    &(patterns[pcount].regexbuf))) != NULL)
	error (EXIT_TROUBLE, 0, "%s", err);
      pcount++;

      p = sep;
    } while (sep && total != 0);

  /* In the match_words and match_lines cases, we use a different pattern
     for the DFA matcher that will quickly throw out cases that won't work.
     Then if DFA succeeds we do some hairy stuff using the regex matcher
     to decide whether the match should really count. */
  if (match_words || match_lines)
    {
      static char const line_beg_no_bk[] = "^(";
      static char const line_end_no_bk[] = ")$";
      static char const word_beg_no_bk[] = "(^|[^[:alnum:]_])(";
      static char const word_end_no_bk[] = ")([^[:alnum:]_]|$)";
      static char const line_beg_bk[] = "^\\(";
      static char const line_end_bk[] = "\\)$";
      static char const word_beg_bk[] = "\\(^\\|[^[:alnum:]_]\\)\\(";
      static char const word_end_bk[] = "\\)\\([^[:alnum:]_]\\|$\\)";
      int bk = !(syntax_bits & RE_NO_BK_PARENS);
      char *n = xmalloc (sizeof word_beg_bk - 1 + size + sizeof word_end_bk);

      strcpy (n, match_lines ? (bk ? line_beg_bk : line_beg_no_bk)
			     : (bk ? word_beg_bk : word_beg_no_bk));
      total = strlen(n);
      memcpy (n + total, pattern, size);
      total += size;
      strcpy (n + total, match_lines ? (bk ? line_end_bk : line_end_no_bk)
				     : (bk ? word_end_bk : word_end_no_bk));
      total += strlen (n + total);
      pattern = motif = n;
      size = total;
    }
  else
    motif = NULL;

  dfacomp (pattern, size, &dfa, 1);
  kwsmusts ();

  free(motif);
}

size_t
EGexecute (char const *buf, size_t size, size_t *match_size,
	   char const *start_ptr)
{
  char const *buflim, *beg, *end, *match, *best_match, *mb_start;
  char eol = eolbyte;
  int backref, start, len, best_len;
  struct kwsmatch kwsm;
  size_t i, ret_val;
#ifdef MBS_SUPPORT
  if (MB_CUR_MAX > 1)
    {
      
//Patch 0:
if ((match_icase) || (__is_neg(25, &(match_icase), sizeof (match_icase), &(buf), sizeof (buf), &(size), sizeof (size), &(start_ptr), sizeof (start_ptr), &(eolbyte), sizeof (eolbyte), &(mb_start), sizeof (mb_start), &(buflim), sizeof (buflim), &(beg), sizeof (beg), &(end), sizeof (end), &(kwset), sizeof (kwset), &(eol), sizeof (eol), &(match), sizeof (match), &(kwset_exact_matches), sizeof (kwset_exact_matches), &(backref), sizeof (backref), &(best_match), sizeof (best_match), &(best_len), sizeof (best_len), &(i), sizeof (i), &(pcount), sizeof (pcount), &(patterns), sizeof (patterns), &(start), sizeof (start), &(len), sizeof (len), &(match_words), sizeof (match_words), &(match_lines), sizeof (match_lines), &(ret_val), sizeof (ret_val), &(match_size), sizeof (match_size)))) {
    char *case_buf = mbtolower(buf, &size);
    if (start_ptr)
        start_ptr = case_buf + (start_ptr - buf);
    buf = case_buf;
}

//CodeSeg 1:
    }
#endif /* MBS_SUPPORT */

  mb_start = buf;
  buflim = buf + size;

  for (beg = end = buf; end < buflim; beg = end)
    {
      if (!start_ptr)
	{
	  /* We don't care about an exact match.  */
	  if (kwset)
	    {
	      /* Find a possible match using the KWset matcher. */
	      size_t offset = kwsexec (kwset, beg, buflim - beg, &kwsm);
	      if (offset == (size_t) -1)
		goto failure;
	      beg += offset;
	      /* Narrow down to the line containing the candidate, and
		 run it through DFA. */
	      if ((end = memchr(beg, eol, buflim - beg)) != NULL)
	        end++;
              else
                end = buflim;
	      match = beg;
	      while (beg > buf && beg[-1] != eol)
		--beg;
	      if (kwsm.index < kwset_exact_matches)
                {
#ifdef MBS_SUPPORT
                  if (mb_start < beg)
                    mb_start = beg;
                  if (MB_CUR_MAX == 1 || !is_mb_middle (&mb_start, match, buflim))
#endif
                    goto success;
                }
	      if (dfaexec (&dfa, beg, (char *) end, 0, NULL, &backref) == NULL)
		continue;
	    }
	  else
	    {
	      /* No good fixed strings; start with DFA. */
	      char const *next_beg = dfaexec (&dfa, beg, (char *) buflim,
					      0, NULL, &backref);
	      if (next_beg == NULL)
		break;
	      /* Narrow down to the line we've found. */
	      beg = next_beg;
	      if ((end = memchr(beg, eol, buflim - beg)) != NULL)
	        end++;
              else
                end = buflim;
	      while (beg > buf && beg[-1] != eol)
		--beg;
	    }
	  /* Successful, no backreferences encountered! */
	  if (!backref)
	    goto success;
	}
      else
	{
	  /* We are looking for the leftmost (then longest) exact match.
	     We will go through the outer loop only once.  */
	  beg = start_ptr;
	  end = buflim;
	}

      /* If we've made it to this point, this means DFA has seen
	 a probable match, and we need to run it through Regex. */
      best_match = end;
      best_len = 0;
      for (i = 0; i < pcount; i++)
	{
	  patterns[i].regexbuf.not_eol = 0;
	  if (0 <= (start = re_search (&(patterns[i].regexbuf),
				       buf, end - buf - 1,
				       beg - buf, end - beg - 1,
				       &(patterns[i].regs))))
	    {
	      len = patterns[i].regs.end[0] - start;
	      match = buf + start;
	      if (match > best_match)
		continue;
	      if (start_ptr && !match_words)
		goto assess_pattern_match;
	      if ((!match_lines && !match_words)
		  || (match_lines && len == end - beg - 1))
		{
		  match = beg;
		  len = end - beg;
		  goto assess_pattern_match;
		}
	      /* If -w, check if the match aligns with word boundaries.
		 We do this iteratively because:
		 (a) the line may contain more than one occurence of the
		 pattern, and
		 (b) Several alternatives in the pattern might be valid at a
		 given point, and we may need to consider a shorter one to
		 find a word boundary.  */
	      if (match_words)
		while (match <= best_match)
		  {
		    if ((match == buf || !WCHAR ((unsigned char) match[-1]))
			&& (len == end - beg - 1
			    || !WCHAR ((unsigned char) match[len])))
		      goto assess_pattern_match;
		    if (len > 0)
		      {
			/* Try a shorter length anchored at the same place. */
			--len;
			patterns[i].regexbuf.not_eol = 1;
			len = re_match (&(patterns[i].regexbuf),
					buf, match + len - beg, match - buf,
					&(patterns[i].regs));
		      }
		    if (len <= 0)
		      {
			/* Try looking further on. */
			if (match == end - 1)
			  break;
			match++;
			patterns[i].regexbuf.not_eol = 0;
			start = re_search (&(patterns[i].regexbuf),
					   buf, end - buf - 1,
					   match - buf, end - match - 1,
					   &(patterns[i].regs));
			if (start < 0)
			  break;
			len = patterns[i].regs.end[0] - start;
			match = buf + start;
		      }
		  } /* while (match <= best_match) */
	      continue;
	    assess_pattern_match:
	      if (!start_ptr)
		{
		  /* Good enough for a non-exact match.
		     No need to look at further patterns, if any.  */
		  beg = match;
		  goto success_in_len;
		}
	      if (match < best_match || (match == best_match && len > best_len))
		{
		  /* Best exact match:  leftmost, then longest.  */
		  best_match = match;
		  best_len = len;
		}
	    } /* if re_search >= 0 */
	} /* for Regex patterns.  */
	if (best_match < end)
	  {
	    /* We have found an exact match.  We were just
	       waiting for the best one (leftmost then longest).  */
	    beg = best_match;
	    len = best_len;
	    goto success_in_len;
	  }
    } /* for (beg = end ..) */

 failure:
  ret_val = -1;
  goto out;

 success:
  len = end - beg;
 success_in_len:
  *match_size = len;
  ret_val = beg - buf;
 out:
  return ret_val;
}

Spawn 1 instances, now Total 38
Counter: 39
Batcher Size:38
Preprocess the following candidate with CondTester:
Priority 20000
At location src/dfasearch.c:212
--Src File: src/dfasearch.c
Fragment 0:
if (((__ctype_get_mb_cur_max()) > 1) && !(__abst_hole(match_icase, eolbyte, buf, size, start_ptr, mb_start, buflim, beg, end, kwset, eol, match, kwset_exact_matches, backref, best_match, best_len, i, pcount, patterns, start, len, match_words, match_lines, ret_val, match_size))) {
    if (match_icase) {
        char *case_buf = mbtolower(buf, &size);
        if (start_ptr)
            start_ptr = case_buf + (start_ptr - buf);
        buf = case_buf;
    }
}


CondTester, a patch instance with id 38:
//src_file:src/dfasearch.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); void* memset(void*, int, unsigned long); 
/* dfasearch.c - searching subroutines using dfa and regex for grep.
   Copyright 1992, 1998, 2000, 2007, 2009-2010 Free Software Foundation, Inc.

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 3, or (at your option)
   any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program; if not, write to the Free Software
   Foundation, Inc., 51 Franklin Street - Fifth Floor, Boston, MA
   02110-1301, USA.  */

/* Written August 1992 by Mike Haertel. */

#include <config.h>
#include "search.h"
#include "dfa.h"

/* For -w, we also consider _ to be word constituent.  */
#define WCHAR(C) (ISALNUM(C) || (C) == '_')

/* KWset compiled pattern.  For Ecompile and Gcompile, we compile
   a list of strings, at least one of which is known to occur in
   any string matching the regexp. */
static kwset_t kwset;

/* DFA compiled regexp. */
static struct dfa dfa;

/* The Regex compiled patterns.  */
static struct patterns
{
  /* Regex compiled regexp. */
  struct re_pattern_buffer regexbuf;
  struct re_registers regs; /* This is here on account of a BRAIN-DEAD
			       Q@#%!# library interface in regex.c.  */
} patterns0;

struct patterns *patterns;
size_t pcount;

void
dfaerror (char const *mesg)
{
  error (EXIT_TROUBLE, 0, "%s", mesg);

  /* notreached */
  /* Tell static analyzers that this function does not return.  */
  abort ();
}

/* Number of compiled fixed strings known to exactly match the regexp.
   If kwsexec returns < kwset_exact_matches, then we don't need to
   call the regexp matcher at all. */
static int kwset_exact_matches;

static char const *
kwsincr_case (const char *must)
{
  const char *buf;
  size_t n;

  n = strlen (must);
#ifdef MBS_SUPPORT
  if (match_icase && MB_CUR_MAX > 1)
    buf = mbtolower (must, &n);
  else
#endif
    buf = must;
  return kwsincr (kwset, buf, n);
}

/* If the DFA turns out to have some set of fixed strings one of
   which must occur in the match, then we build a kwset matcher
   to find those strings, and thus quickly filter out impossible
   matches. */
static void
kwsmusts (void)
{
  struct dfamust const *dm;
  char const *err;

  if (dfa.musts)
    {
      kwsinit (&kwset);
      /* First, we compile in the substrings known to be exact
	 matches.  The kwset matcher will return the index
	 of the matching string that it chooses. */
      for (dm = dfa.musts; dm; dm = dm->next)
	{
	  if (!dm->exact)
	    continue;
	  ++kwset_exact_matches;
	  if ((err = kwsincr_case (dm->must)) != NULL)
	    error (EXIT_TROUBLE, 0, "%s", err);
	}
      /* Now, we compile the substrings that will require
	 the use of the regexp matcher.  */
      for (dm = dfa.musts; dm; dm = dm->next)
	{
	  if (dm->exact)
	    continue;
	  if ((err = kwsincr_case (dm->must)) != NULL)
	    error (EXIT_TROUBLE, 0, "%s", err);
	}
      if ((err = kwsprep (kwset)) != NULL)
	error (EXIT_TROUBLE, 0, "%s", err);
    }
}

void
GEAcompile (char const *pattern, size_t size, reg_syntax_t syntax_bits)
{
  const char *err;
  const char *p, *sep;
  size_t total = size;
  char *motif;

  if (match_icase)
    syntax_bits |= RE_ICASE;
  re_set_syntax (syntax_bits);
  dfasyntax (syntax_bits, match_icase, eolbyte);

  /* For GNU regex compiler we have to pass the patterns separately to detect
     errors like "[\nallo\n]\n".  The patterns here are "[", "allo" and "]"
     GNU regex should have raise a syntax error.  The same for backref, where
     the backref should have been local to each pattern.  */
  p = pattern;
  do
    {
      size_t len;
      sep = memchr (p, '\n', total);
      if (sep)
	{
	  len = sep - p;
	  sep++;
	  total -= (len + 1);
	}
      else
	{
	  len = total;
	  total = 0;
	}

      patterns = realloc (patterns, (pcount + 1) * sizeof (*patterns));
      if (patterns == NULL)
	error (EXIT_TROUBLE, errno, _("memory exhausted"));
      patterns[pcount] = patterns0;

      if ((err = re_compile_pattern (p, len,
				    &(patterns[pcount].regexbuf))) != NULL)
	error (EXIT_TROUBLE, 0, "%s", err);
      pcount++;

      p = sep;
    } while (sep && total != 0);

  /* In the match_words and match_lines cases, we use a different pattern
     for the DFA matcher that will quickly throw out cases that won't work.
     Then if DFA succeeds we do some hairy stuff using the regex matcher
     to decide whether the match should really count. */
  if (match_words || match_lines)
    {
      static char const line_beg_no_bk[] = "^(";
      static char const line_end_no_bk[] = ")$";
      static char const word_beg_no_bk[] = "(^|[^[:alnum:]_])(";
      static char const word_end_no_bk[] = ")([^[:alnum:]_]|$)";
      static char const line_beg_bk[] = "^\\(";
      static char const line_end_bk[] = "\\)$";
      static char const word_beg_bk[] = "\\(^\\|[^[:alnum:]_]\\)\\(";
      static char const word_end_bk[] = "\\)\\([^[:alnum:]_]\\|$\\)";
      int bk = !(syntax_bits & RE_NO_BK_PARENS);
      char *n = xmalloc (sizeof word_beg_bk - 1 + size + sizeof word_end_bk);

      strcpy (n, match_lines ? (bk ? line_beg_bk : line_beg_no_bk)
			     : (bk ? word_beg_bk : word_beg_no_bk));
      total = strlen(n);
      memcpy (n + total, pattern, size);
      total += size;
      strcpy (n + total, match_lines ? (bk ? line_end_bk : line_end_no_bk)
				     : (bk ? word_end_bk : word_end_no_bk));
      total += strlen (n + total);
      pattern = motif = n;
      size = total;
    }
  else
    motif = NULL;

  dfacomp (pattern, size, &dfa, 1);
  kwsmusts ();

  free(motif);
}

size_t
EGexecute (char const *buf, size_t size, size_t *match_size,
	   char const *start_ptr)
{
  char const *buflim, *beg, *end, *match, *best_match, *mb_start;
  char eol = eolbyte;
  int backref, start, len, best_len;
  struct kwsmatch kwsm;
  size_t i, ret_val;
#ifdef MBS_SUPPORT
  
//Patch 0:
if (((__ctype_get_mb_cur_max()) > 1) && !(__is_neg(25, &(match_icase), sizeof (match_icase), &(eolbyte), sizeof (eolbyte), &(buf), sizeof (buf), &(size), sizeof (size), &(start_ptr), sizeof (start_ptr), &(mb_start), sizeof (mb_start), &(buflim), sizeof (buflim), &(beg), sizeof (beg), &(end), sizeof (end), &(kwset), sizeof (kwset), &(eol), sizeof (eol), &(match), sizeof (match), &(kwset_exact_matches), sizeof (kwset_exact_matches), &(backref), sizeof (backref), &(best_match), sizeof (best_match), &(best_len), sizeof (best_len), &(i), sizeof (i), &(pcount), sizeof (pcount), &(patterns), sizeof (patterns), &(start), sizeof (start), &(len), sizeof (len), &(match_words), sizeof (match_words), &(match_lines), sizeof (match_lines), &(ret_val), sizeof (ret_val), &(match_size), sizeof (match_size)))) {
    if (match_icase) {
        char *case_buf = mbtolower(buf, &size);
        if (start_ptr)
            start_ptr = case_buf + (start_ptr - buf);
        buf = case_buf;
    }
}

//CodeSeg 1:
#endif /* MBS_SUPPORT */

  mb_start = buf;
  buflim = buf + size;

  for (beg = end = buf; end < buflim; beg = end)
    {
      if (!start_ptr)
	{
	  /* We don't care about an exact match.  */
	  if (kwset)
	    {
	      /* Find a possible match using the KWset matcher. */
	      size_t offset = kwsexec (kwset, beg, buflim - beg, &kwsm);
	      if (offset == (size_t) -1)
		goto failure;
	      beg += offset;
	      /* Narrow down to the line containing the candidate, and
		 run it through DFA. */
	      if ((end = memchr(beg, eol, buflim - beg)) != NULL)
	        end++;
              else
                end = buflim;
	      match = beg;
	      while (beg > buf && beg[-1] != eol)
		--beg;
	      if (kwsm.index < kwset_exact_matches)
                {
#ifdef MBS_SUPPORT
                  if (mb_start < beg)
                    mb_start = beg;
                  if (MB_CUR_MAX == 1 || !is_mb_middle (&mb_start, match, buflim))
#endif
                    goto success;
                }
	      if (dfaexec (&dfa, beg, (char *) end, 0, NULL, &backref) == NULL)
		continue;
	    }
	  else
	    {
	      /* No good fixed strings; start with DFA. */
	      char const *next_beg = dfaexec (&dfa, beg, (char *) buflim,
					      0, NULL, &backref);
	      if (next_beg == NULL)
		break;
	      /* Narrow down to the line we've found. */
	      beg = next_beg;
	      if ((end = memchr(beg, eol, buflim - beg)) != NULL)
	        end++;
              else
                end = buflim;
	      while (beg > buf && beg[-1] != eol)
		--beg;
	    }
	  /* Successful, no backreferences encountered! */
	  if (!backref)
	    goto success;
	}
      else
	{
	  /* We are looking for the leftmost (then longest) exact match.
	     We will go through the outer loop only once.  */
	  beg = start_ptr;
	  end = buflim;
	}

      /* If we've made it to this point, this means DFA has seen
	 a probable match, and we need to run it through Regex. */
      best_match = end;
      best_len = 0;
      for (i = 0; i < pcount; i++)
	{
	  patterns[i].regexbuf.not_eol = 0;
	  if (0 <= (start = re_search (&(patterns[i].regexbuf),
				       buf, end - buf - 1,
				       beg - buf, end - beg - 1,
				       &(patterns[i].regs))))
	    {
	      len = patterns[i].regs.end[0] - start;
	      match = buf + start;
	      if (match > best_match)
		continue;
	      if (start_ptr && !match_words)
		goto assess_pattern_match;
	      if ((!match_lines && !match_words)
		  || (match_lines && len == end - beg - 1))
		{
		  match = beg;
		  len = end - beg;
		  goto assess_pattern_match;
		}
	      /* If -w, check if the match aligns with word boundaries.
		 We do this iteratively because:
		 (a) the line may contain more than one occurence of the
		 pattern, and
		 (b) Several alternatives in the pattern might be valid at a
		 given point, and we may need to consider a shorter one to
		 find a word boundary.  */
	      if (match_words)
		while (match <= best_match)
		  {
		    if ((match == buf || !WCHAR ((unsigned char) match[-1]))
			&& (len == end - beg - 1
			    || !WCHAR ((unsigned char) match[len])))
		      goto assess_pattern_match;
		    if (len > 0)
		      {
			/* Try a shorter length anchored at the same place. */
			--len;
			patterns[i].regexbuf.not_eol = 1;
			len = re_match (&(patterns[i].regexbuf),
					buf, match + len - beg, match - buf,
					&(patterns[i].regs));
		      }
		    if (len <= 0)
		      {
			/* Try looking further on. */
			if (match == end - 1)
			  break;
			match++;
			patterns[i].regexbuf.not_eol = 0;
			start = re_search (&(patterns[i].regexbuf),
					   buf, end - buf - 1,
					   match - buf, end - match - 1,
					   &(patterns[i].regs));
			if (start < 0)
			  break;
			len = patterns[i].regs.end[0] - start;
			match = buf + start;
		      }
		  } /* while (match <= best_match) */
	      continue;
	    assess_pattern_match:
	      if (!start_ptr)
		{
		  /* Good enough for a non-exact match.
		     No need to look at further patterns, if any.  */
		  beg = match;
		  goto success_in_len;
		}
	      if (match < best_match || (match == best_match && len > best_len))
		{
		  /* Best exact match:  leftmost, then longest.  */
		  best_match = match;
		  best_len = len;
		}
	    } /* if re_search >= 0 */
	} /* for Regex patterns.  */
	if (best_match < end)
	  {
	    /* We have found an exact match.  We were just
	       waiting for the best one (leftmost then longest).  */
	    beg = best_match;
	    len = best_len;
	    goto success_in_len;
	  }
    } /* for (beg = end ..) */

 failure:
  ret_val = -1;
  goto out;

 success:
  len = end - beg;
 success_in_len:
  *match_size = len;
  ret_val = beg - buf;
 out:
  return ret_val;
}

Spawn 1 instances, now Total 39
Counter: 40
Batcher Size:39
Preprocess the following candidate with CondTester:
Priority 20000
At location src/dfasearch.c:212
--Src File: src/dfasearch.c
Fragment 0:
if (((__ctype_get_mb_cur_max()) > 1) || (__abst_hole(match_icase, eolbyte, buf, size, start_ptr, mb_start, buflim, beg, end, kwset, eol, match, kwset_exact_matches, backref, best_match, best_len, i, pcount, patterns, start, len, match_words, match_lines, ret_val, match_size))) {
    if (match_icase) {
        char *case_buf = mbtolower(buf, &size);
        if (start_ptr)
            start_ptr = case_buf + (start_ptr - buf);
        buf = case_buf;
    }
}


CondTester, a patch instance with id 39:
//src_file:src/dfasearch.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); void* memset(void*, int, unsigned long); 
/* dfasearch.c - searching subroutines using dfa and regex for grep.
   Copyright 1992, 1998, 2000, 2007, 2009-2010 Free Software Foundation, Inc.

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 3, or (at your option)
   any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program; if not, write to the Free Software
   Foundation, Inc., 51 Franklin Street - Fifth Floor, Boston, MA
   02110-1301, USA.  */

/* Written August 1992 by Mike Haertel. */

#include <config.h>
#include "search.h"
#include "dfa.h"

/* For -w, we also consider _ to be word constituent.  */
#define WCHAR(C) (ISALNUM(C) || (C) == '_')

/* KWset compiled pattern.  For Ecompile and Gcompile, we compile
   a list of strings, at least one of which is known to occur in
   any string matching the regexp. */
static kwset_t kwset;

/* DFA compiled regexp. */
static struct dfa dfa;

/* The Regex compiled patterns.  */
static struct patterns
{
  /* Regex compiled regexp. */
  struct re_pattern_buffer regexbuf;
  struct re_registers regs; /* This is here on account of a BRAIN-DEAD
			       Q@#%!# library interface in regex.c.  */
} patterns0;

struct patterns *patterns;
size_t pcount;

void
dfaerror (char const *mesg)
{
  error (EXIT_TROUBLE, 0, "%s", mesg);

  /* notreached */
  /* Tell static analyzers that this function does not return.  */
  abort ();
}

/* Number of compiled fixed strings known to exactly match the regexp.
   If kwsexec returns < kwset_exact_matches, then we don't need to
   call the regexp matcher at all. */
static int kwset_exact_matches;

static char const *
kwsincr_case (const char *must)
{
  const char *buf;
  size_t n;

  n = strlen (must);
#ifdef MBS_SUPPORT
  if (match_icase && MB_CUR_MAX > 1)
    buf = mbtolower (must, &n);
  else
#endif
    buf = must;
  return kwsincr (kwset, buf, n);
}

/* If the DFA turns out to have some set of fixed strings one of
   which must occur in the match, then we build a kwset matcher
   to find those strings, and thus quickly filter out impossible
   matches. */
static void
kwsmusts (void)
{
  struct dfamust const *dm;
  char const *err;

  if (dfa.musts)
    {
      kwsinit (&kwset);
      /* First, we compile in the substrings known to be exact
	 matches.  The kwset matcher will return the index
	 of the matching string that it chooses. */
      for (dm = dfa.musts; dm; dm = dm->next)
	{
	  if (!dm->exact)
	    continue;
	  ++kwset_exact_matches;
	  if ((err = kwsincr_case (dm->must)) != NULL)
	    error (EXIT_TROUBLE, 0, "%s", err);
	}
      /* Now, we compile the substrings that will require
	 the use of the regexp matcher.  */
      for (dm = dfa.musts; dm; dm = dm->next)
	{
	  if (dm->exact)
	    continue;
	  if ((err = kwsincr_case (dm->must)) != NULL)
	    error (EXIT_TROUBLE, 0, "%s", err);
	}
      if ((err = kwsprep (kwset)) != NULL)
	error (EXIT_TROUBLE, 0, "%s", err);
    }
}

void
GEAcompile (char const *pattern, size_t size, reg_syntax_t syntax_bits)
{
  const char *err;
  const char *p, *sep;
  size_t total = size;
  char *motif;

  if (match_icase)
    syntax_bits |= RE_ICASE;
  re_set_syntax (syntax_bits);
  dfasyntax (syntax_bits, match_icase, eolbyte);

  /* For GNU regex compiler we have to pass the patterns separately to detect
     errors like "[\nallo\n]\n".  The patterns here are "[", "allo" and "]"
     GNU regex should have raise a syntax error.  The same for backref, where
     the backref should have been local to each pattern.  */
  p = pattern;
  do
    {
      size_t len;
      sep = memchr (p, '\n', total);
      if (sep)
	{
	  len = sep - p;
	  sep++;
	  total -= (len + 1);
	}
      else
	{
	  len = total;
	  total = 0;
	}

      patterns = realloc (patterns, (pcount + 1) * sizeof (*patterns));
      if (patterns == NULL)
	error (EXIT_TROUBLE, errno, _("memory exhausted"));
      patterns[pcount] = patterns0;

      if ((err = re_compile_pattern (p, len,
				    &(patterns[pcount].regexbuf))) != NULL)
	error (EXIT_TROUBLE, 0, "%s", err);
      pcount++;

      p = sep;
    } while (sep && total != 0);

  /* In the match_words and match_lines cases, we use a different pattern
     for the DFA matcher that will quickly throw out cases that won't work.
     Then if DFA succeeds we do some hairy stuff using the regex matcher
     to decide whether the match should really count. */
  if (match_words || match_lines)
    {
      static char const line_beg_no_bk[] = "^(";
      static char const line_end_no_bk[] = ")$";
      static char const word_beg_no_bk[] = "(^|[^[:alnum:]_])(";
      static char const word_end_no_bk[] = ")([^[:alnum:]_]|$)";
      static char const line_beg_bk[] = "^\\(";
      static char const line_end_bk[] = "\\)$";
      static char const word_beg_bk[] = "\\(^\\|[^[:alnum:]_]\\)\\(";
      static char const word_end_bk[] = "\\)\\([^[:alnum:]_]\\|$\\)";
      int bk = !(syntax_bits & RE_NO_BK_PARENS);
      char *n = xmalloc (sizeof word_beg_bk - 1 + size + sizeof word_end_bk);

      strcpy (n, match_lines ? (bk ? line_beg_bk : line_beg_no_bk)
			     : (bk ? word_beg_bk : word_beg_no_bk));
      total = strlen(n);
      memcpy (n + total, pattern, size);
      total += size;
      strcpy (n + total, match_lines ? (bk ? line_end_bk : line_end_no_bk)
				     : (bk ? word_end_bk : word_end_no_bk));
      total += strlen (n + total);
      pattern = motif = n;
      size = total;
    }
  else
    motif = NULL;

  dfacomp (pattern, size, &dfa, 1);
  kwsmusts ();

  free(motif);
}

size_t
EGexecute (char const *buf, size_t size, size_t *match_size,
	   char const *start_ptr)
{
  char const *buflim, *beg, *end, *match, *best_match, *mb_start;
  char eol = eolbyte;
  int backref, start, len, best_len;
  struct kwsmatch kwsm;
  size_t i, ret_val;
#ifdef MBS_SUPPORT
  
//Patch 0:
if (((__ctype_get_mb_cur_max()) > 1) || (__is_neg(25, &(match_icase), sizeof (match_icase), &(eolbyte), sizeof (eolbyte), &(buf), sizeof (buf), &(size), sizeof (size), &(start_ptr), sizeof (start_ptr), &(mb_start), sizeof (mb_start), &(buflim), sizeof (buflim), &(beg), sizeof (beg), &(end), sizeof (end), &(kwset), sizeof (kwset), &(eol), sizeof (eol), &(match), sizeof (match), &(kwset_exact_matches), sizeof (kwset_exact_matches), &(backref), sizeof (backref), &(best_match), sizeof (best_match), &(best_len), sizeof (best_len), &(i), sizeof (i), &(pcount), sizeof (pcount), &(patterns), sizeof (patterns), &(start), sizeof (start), &(len), sizeof (len), &(match_words), sizeof (match_words), &(match_lines), sizeof (match_lines), &(ret_val), sizeof (ret_val), &(match_size), sizeof (match_size)))) {
    if (match_icase) {
        char *case_buf = mbtolower(buf, &size);
        if (start_ptr)
            start_ptr = case_buf + (start_ptr - buf);
        buf = case_buf;
    }
}

//CodeSeg 1:
#endif /* MBS_SUPPORT */

  mb_start = buf;
  buflim = buf + size;

  for (beg = end = buf; end < buflim; beg = end)
    {
      if (!start_ptr)
	{
	  /* We don't care about an exact match.  */
	  if (kwset)
	    {
	      /* Find a possible match using the KWset matcher. */
	      size_t offset = kwsexec (kwset, beg, buflim - beg, &kwsm);
	      if (offset == (size_t) -1)
		goto failure;
	      beg += offset;
	      /* Narrow down to the line containing the candidate, and
		 run it through DFA. */
	      if ((end = memchr(beg, eol, buflim - beg)) != NULL)
	        end++;
              else
                end = buflim;
	      match = beg;
	      while (beg > buf && beg[-1] != eol)
		--beg;
	      if (kwsm.index < kwset_exact_matches)
                {
#ifdef MBS_SUPPORT
                  if (mb_start < beg)
                    mb_start = beg;
                  if (MB_CUR_MAX == 1 || !is_mb_middle (&mb_start, match, buflim))
#endif
                    goto success;
                }
	      if (dfaexec (&dfa, beg, (char *) end, 0, NULL, &backref) == NULL)
		continue;
	    }
	  else
	    {
	      /* No good fixed strings; start with DFA. */
	      char const *next_beg = dfaexec (&dfa, beg, (char *) buflim,
					      0, NULL, &backref);
	      if (next_beg == NULL)
		break;
	      /* Narrow down to the line we've found. */
	      beg = next_beg;
	      if ((end = memchr(beg, eol, buflim - beg)) != NULL)
	        end++;
              else
                end = buflim;
	      while (beg > buf && beg[-1] != eol)
		--beg;
	    }
	  /* Successful, no backreferences encountered! */
	  if (!backref)
	    goto success;
	}
      else
	{
	  /* We are looking for the leftmost (then longest) exact match.
	     We will go through the outer loop only once.  */
	  beg = start_ptr;
	  end = buflim;
	}

      /* If we've made it to this point, this means DFA has seen
	 a probable match, and we need to run it through Regex. */
      best_match = end;
      best_len = 0;
      for (i = 0; i < pcount; i++)
	{
	  patterns[i].regexbuf.not_eol = 0;
	  if (0 <= (start = re_search (&(patterns[i].regexbuf),
				       buf, end - buf - 1,
				       beg - buf, end - beg - 1,
				       &(patterns[i].regs))))
	    {
	      len = patterns[i].regs.end[0] - start;
	      match = buf + start;
	      if (match > best_match)
		continue;
	      if (start_ptr && !match_words)
		goto assess_pattern_match;
	      if ((!match_lines && !match_words)
		  || (match_lines && len == end - beg - 1))
		{
		  match = beg;
		  len = end - beg;
		  goto assess_pattern_match;
		}
	      /* If -w, check if the match aligns with word boundaries.
		 We do this iteratively because:
		 (a) the line may contain more than one occurence of the
		 pattern, and
		 (b) Several alternatives in the pattern might be valid at a
		 given point, and we may need to consider a shorter one to
		 find a word boundary.  */
	      if (match_words)
		while (match <= best_match)
		  {
		    if ((match == buf || !WCHAR ((unsigned char) match[-1]))
			&& (len == end - beg - 1
			    || !WCHAR ((unsigned char) match[len])))
		      goto assess_pattern_match;
		    if (len > 0)
		      {
			/* Try a shorter length anchored at the same place. */
			--len;
			patterns[i].regexbuf.not_eol = 1;
			len = re_match (&(patterns[i].regexbuf),
					buf, match + len - beg, match - buf,
					&(patterns[i].regs));
		      }
		    if (len <= 0)
		      {
			/* Try looking further on. */
			if (match == end - 1)
			  break;
			match++;
			patterns[i].regexbuf.not_eol = 0;
			start = re_search (&(patterns[i].regexbuf),
					   buf, end - buf - 1,
					   match - buf, end - match - 1,
					   &(patterns[i].regs));
			if (start < 0)
			  break;
			len = patterns[i].regs.end[0] - start;
			match = buf + start;
		      }
		  } /* while (match <= best_match) */
	      continue;
	    assess_pattern_match:
	      if (!start_ptr)
		{
		  /* Good enough for a non-exact match.
		     No need to look at further patterns, if any.  */
		  beg = match;
		  goto success_in_len;
		}
	      if (match < best_match || (match == best_match && len > best_len))
		{
		  /* Best exact match:  leftmost, then longest.  */
		  best_match = match;
		  best_len = len;
		}
	    } /* if re_search >= 0 */
	} /* for Regex patterns.  */
	if (best_match < end)
	  {
	    /* We have found an exact match.  We were just
	       waiting for the best one (leftmost then longest).  */
	    beg = best_match;
	    len = best_len;
	    goto success_in_len;
	  }
    } /* for (beg = end ..) */

 failure:
  ret_val = -1;
  goto out;

 success:
  len = end - beg;
 success_in_len:
  *match_size = len;
  ret_val = beg - buf;
 out:
  return ret_val;
}

Spawn 1 instances, now Total 40
Counter: 41
Batcher Size:40
Preprocess the following candidate with CondTester:
Priority 20000
At location src/dfasearch.c:72
--Src File: src/dfasearch.c
Fragment 0:
if (((match_icase) || (__abst_hole(match_icase, must, buf, n, kwset))) && (__ctype_get_mb_cur_max()) > 1)
    buf = mbtolower(must, &n);
else
    buf = must;


CondTester, a patch instance with id 40:
//src_file:src/dfasearch.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); void* memset(void*, int, unsigned long); 
/* dfasearch.c - searching subroutines using dfa and regex for grep.
   Copyright 1992, 1998, 2000, 2007, 2009-2010 Free Software Foundation, Inc.

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 3, or (at your option)
   any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program; if not, write to the Free Software
   Foundation, Inc., 51 Franklin Street - Fifth Floor, Boston, MA
   02110-1301, USA.  */

/* Written August 1992 by Mike Haertel. */

#include <config.h>
#include "search.h"
#include "dfa.h"

/* For -w, we also consider _ to be word constituent.  */
#define WCHAR(C) (ISALNUM(C) || (C) == '_')

/* KWset compiled pattern.  For Ecompile and Gcompile, we compile
   a list of strings, at least one of which is known to occur in
   any string matching the regexp. */
static kwset_t kwset;

/* DFA compiled regexp. */
static struct dfa dfa;

/* The Regex compiled patterns.  */
static struct patterns
{
  /* Regex compiled regexp. */
  struct re_pattern_buffer regexbuf;
  struct re_registers regs; /* This is here on account of a BRAIN-DEAD
			       Q@#%!# library interface in regex.c.  */
} patterns0;

struct patterns *patterns;
size_t pcount;

void
dfaerror (char const *mesg)
{
  error (EXIT_TROUBLE, 0, "%s", mesg);

  /* notreached */
  /* Tell static analyzers that this function does not return.  */
  abort ();
}

/* Number of compiled fixed strings known to exactly match the regexp.
   If kwsexec returns < kwset_exact_matches, then we don't need to
   call the regexp matcher at all. */
static int kwset_exact_matches;

static char const *
kwsincr_case (const char *must)
{
  const char *buf;
  size_t n;

  n = strlen (must);
#ifdef MBS_SUPPORT
  
//Patch 0:
if (((match_icase) || (__is_neg(5, &(match_icase), sizeof (match_icase), &(must), sizeof (must), &(buf), sizeof (buf), &(n), sizeof (n), &(kwset), sizeof (kwset)))) && (__ctype_get_mb_cur_max()) > 1)
    buf = mbtolower(must, &n);
else
    buf = must;

//CodeSeg 1:
  return kwsincr (kwset, buf, n);
}

/* If the DFA turns out to have some set of fixed strings one of
   which must occur in the match, then we build a kwset matcher
   to find those strings, and thus quickly filter out impossible
   matches. */
static void
kwsmusts (void)
{
  struct dfamust const *dm;
  char const *err;

  if (dfa.musts)
    {
      kwsinit (&kwset);
      /* First, we compile in the substrings known to be exact
	 matches.  The kwset matcher will return the index
	 of the matching string that it chooses. */
      for (dm = dfa.musts; dm; dm = dm->next)
	{
	  if (!dm->exact)
	    continue;
	  ++kwset_exact_matches;
	  if ((err = kwsincr_case (dm->must)) != NULL)
	    error (EXIT_TROUBLE, 0, "%s", err);
	}
      /* Now, we compile the substrings that will require
	 the use of the regexp matcher.  */
      for (dm = dfa.musts; dm; dm = dm->next)
	{
	  if (dm->exact)
	    continue;
	  if ((err = kwsincr_case (dm->must)) != NULL)
	    error (EXIT_TROUBLE, 0, "%s", err);
	}
      if ((err = kwsprep (kwset)) != NULL)
	error (EXIT_TROUBLE, 0, "%s", err);
    }
}

void
GEAcompile (char const *pattern, size_t size, reg_syntax_t syntax_bits)
{
  const char *err;
  const char *p, *sep;
  size_t total = size;
  char *motif;

  if (match_icase)
    syntax_bits |= RE_ICASE;
  re_set_syntax (syntax_bits);
  dfasyntax (syntax_bits, match_icase, eolbyte);

  /* For GNU regex compiler we have to pass the patterns separately to detect
     errors like "[\nallo\n]\n".  The patterns here are "[", "allo" and "]"
     GNU regex should have raise a syntax error.  The same for backref, where
     the backref should have been local to each pattern.  */
  p = pattern;
  do
    {
      size_t len;
      sep = memchr (p, '\n', total);
      if (sep)
	{
	  len = sep - p;
	  sep++;
	  total -= (len + 1);
	}
      else
	{
	  len = total;
	  total = 0;
	}

      patterns = realloc (patterns, (pcount + 1) * sizeof (*patterns));
      if (patterns == NULL)
	error (EXIT_TROUBLE, errno, _("memory exhausted"));
      patterns[pcount] = patterns0;

      if ((err = re_compile_pattern (p, len,
				    &(patterns[pcount].regexbuf))) != NULL)
	error (EXIT_TROUBLE, 0, "%s", err);
      pcount++;

      p = sep;
    } while (sep && total != 0);

  /* In the match_words and match_lines cases, we use a different pattern
     for the DFA matcher that will quickly throw out cases that won't work.
     Then if DFA succeeds we do some hairy stuff using the regex matcher
     to decide whether the match should really count. */
  if (match_words || match_lines)
    {
      static char const line_beg_no_bk[] = "^(";
      static char const line_end_no_bk[] = ")$";
      static char const word_beg_no_bk[] = "(^|[^[:alnum:]_])(";
      static char const word_end_no_bk[] = ")([^[:alnum:]_]|$)";
      static char const line_beg_bk[] = "^\\(";
      static char const line_end_bk[] = "\\)$";
      static char const word_beg_bk[] = "\\(^\\|[^[:alnum:]_]\\)\\(";
      static char const word_end_bk[] = "\\)\\([^[:alnum:]_]\\|$\\)";
      int bk = !(syntax_bits & RE_NO_BK_PARENS);
      char *n = xmalloc (sizeof word_beg_bk - 1 + size + sizeof word_end_bk);

      strcpy (n, match_lines ? (bk ? line_beg_bk : line_beg_no_bk)
			     : (bk ? word_beg_bk : word_beg_no_bk));
      total = strlen(n);
      memcpy (n + total, pattern, size);
      total += size;
      strcpy (n + total, match_lines ? (bk ? line_end_bk : line_end_no_bk)
				     : (bk ? word_end_bk : word_end_no_bk));
      total += strlen (n + total);
      pattern = motif = n;
      size = total;
    }
  else
    motif = NULL;

  dfacomp (pattern, size, &dfa, 1);
  kwsmusts ();

  free(motif);
}

size_t
EGexecute (char const *buf, size_t size, size_t *match_size,
	   char const *start_ptr)
{
  char const *buflim, *beg, *end, *match, *best_match, *mb_start;
  char eol = eolbyte;
  int backref, start, len, best_len;
  struct kwsmatch kwsm;
  size_t i, ret_val;
#ifdef MBS_SUPPORT
  if (MB_CUR_MAX > 1)
    {
      if (match_icase)
        {
          /* mbtolower adds a NUL byte at the end.  That will provide
	     space for the sentinel byte dfaexec may add.  */
          char *case_buf = mbtolower (buf, &size);
	  if (start_ptr)
	    start_ptr = case_buf + (start_ptr - buf);
          buf = case_buf;
        }
    }
#endif /* MBS_SUPPORT */

  mb_start = buf;
  buflim = buf + size;

  for (beg = end = buf; end < buflim; beg = end)
    {
      if (!start_ptr)
	{
	  /* We don't care about an exact match.  */
	  if (kwset)
	    {
	      /* Find a possible match using the KWset matcher. */
	      size_t offset = kwsexec (kwset, beg, buflim - beg, &kwsm);
	      if (offset == (size_t) -1)
		goto failure;
	      beg += offset;
	      /* Narrow down to the line containing the candidate, and
		 run it through DFA. */
	      if ((end = memchr(beg, eol, buflim - beg)) != NULL)
	        end++;
              else
                end = buflim;
	      match = beg;
	      while (beg > buf && beg[-1] != eol)
		--beg;
	      if (kwsm.index < kwset_exact_matches)
                {
#ifdef MBS_SUPPORT
                  if (mb_start < beg)
                    mb_start = beg;
                  if (MB_CUR_MAX == 1 || !is_mb_middle (&mb_start, match, buflim))
#endif
                    goto success;
                }
	      if (dfaexec (&dfa, beg, (char *) end, 0, NULL, &backref) == NULL)
		continue;
	    }
	  else
	    {
	      /* No good fixed strings; start with DFA. */
	      char const *next_beg = dfaexec (&dfa, beg, (char *) buflim,
					      0, NULL, &backref);
	      if (next_beg == NULL)
		break;
	      /* Narrow down to the line we've found. */
	      beg = next_beg;
	      if ((end = memchr(beg, eol, buflim - beg)) != NULL)
	        end++;
              else
                end = buflim;
	      while (beg > buf && beg[-1] != eol)
		--beg;
	    }
	  /* Successful, no backreferences encountered! */
	  if (!backref)
	    goto success;
	}
      else
	{
	  /* We are looking for the leftmost (then longest) exact match.
	     We will go through the outer loop only once.  */
	  beg = start_ptr;
	  end = buflim;
	}

      /* If we've made it to this point, this means DFA has seen
	 a probable match, and we need to run it through Regex. */
      best_match = end;
      best_len = 0;
      for (i = 0; i < pcount; i++)
	{
	  patterns[i].regexbuf.not_eol = 0;
	  if (0 <= (start = re_search (&(patterns[i].regexbuf),
				       buf, end - buf - 1,
				       beg - buf, end - beg - 1,
				       &(patterns[i].regs))))
	    {
	      len = patterns[i].regs.end[0] - start;
	      match = buf + start;
	      if (match > best_match)
		continue;
	      if (start_ptr && !match_words)
		goto assess_pattern_match;
	      if ((!match_lines && !match_words)
		  || (match_lines && len == end - beg - 1))
		{
		  match = beg;
		  len = end - beg;
		  goto assess_pattern_match;
		}
	      /* If -w, check if the match aligns with word boundaries.
		 We do this iteratively because:
		 (a) the line may contain more than one occurence of the
		 pattern, and
		 (b) Several alternatives in the pattern might be valid at a
		 given point, and we may need to consider a shorter one to
		 find a word boundary.  */
	      if (match_words)
		while (match <= best_match)
		  {
		    if ((match == buf || !WCHAR ((unsigned char) match[-1]))
			&& (len == end - beg - 1
			    || !WCHAR ((unsigned char) match[len])))
		      goto assess_pattern_match;
		    if (len > 0)
		      {
			/* Try a shorter length anchored at the same place. */
			--len;
			patterns[i].regexbuf.not_eol = 1;
			len = re_match (&(patterns[i].regexbuf),
					buf, match + len - beg, match - buf,
					&(patterns[i].regs));
		      }
		    if (len <= 0)
		      {
			/* Try looking further on. */
			if (match == end - 1)
			  break;
			match++;
			patterns[i].regexbuf.not_eol = 0;
			start = re_search (&(patterns[i].regexbuf),
					   buf, end - buf - 1,
					   match - buf, end - match - 1,
					   &(patterns[i].regs));
			if (start < 0)
			  break;
			len = patterns[i].regs.end[0] - start;
			match = buf + start;
		      }
		  } /* while (match <= best_match) */
	      continue;
	    assess_pattern_match:
	      if (!start_ptr)
		{
		  /* Good enough for a non-exact match.
		     No need to look at further patterns, if any.  */
		  beg = match;
		  goto success_in_len;
		}
	      if (match < best_match || (match == best_match && len > best_len))
		{
		  /* Best exact match:  leftmost, then longest.  */
		  best_match = match;
		  best_len = len;
		}
	    } /* if re_search >= 0 */
	} /* for Regex patterns.  */
	if (best_match < end)
	  {
	    /* We have found an exact match.  We were just
	       waiting for the best one (leftmost then longest).  */
	    beg = best_match;
	    len = best_len;
	    goto success_in_len;
	  }
    } /* for (beg = end ..) */

 failure:
  ret_val = -1;
  goto out;

 success:
  len = end - beg;
 success_in_len:
  *match_size = len;
  ret_val = beg - buf;
 out:
  return ret_val;
}

Spawn 1 instances, now Total 41
Counter: 42
Batcher Size:41
Preprocess the following candidate with CondTester:
Priority 20000
At location src/dfasearch.c:98
--Src File: src/dfasearch.c
Fragment 0:
if ((!dm->exact) && !(__abst_hole(dm, dm->exact, kwset_exact_matches, dm->next, err, dm->must, kwset)))
    continue;


CondTester, a patch instance with id 41:
//src_file:src/dfasearch.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); void* memset(void*, int, unsigned long); 
/* dfasearch.c - searching subroutines using dfa and regex for grep.
   Copyright 1992, 1998, 2000, 2007, 2009-2010 Free Software Foundation, Inc.

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 3, or (at your option)
   any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program; if not, write to the Free Software
   Foundation, Inc., 51 Franklin Street - Fifth Floor, Boston, MA
   02110-1301, USA.  */

/* Written August 1992 by Mike Haertel. */

#include <config.h>
#include "search.h"
#include "dfa.h"

/* For -w, we also consider _ to be word constituent.  */
#define WCHAR(C) (ISALNUM(C) || (C) == '_')

/* KWset compiled pattern.  For Ecompile and Gcompile, we compile
   a list of strings, at least one of which is known to occur in
   any string matching the regexp. */
static kwset_t kwset;

/* DFA compiled regexp. */
static struct dfa dfa;

/* The Regex compiled patterns.  */
static struct patterns
{
  /* Regex compiled regexp. */
  struct re_pattern_buffer regexbuf;
  struct re_registers regs; /* This is here on account of a BRAIN-DEAD
			       Q@#%!# library interface in regex.c.  */
} patterns0;

struct patterns *patterns;
size_t pcount;

void
dfaerror (char const *mesg)
{
  error (EXIT_TROUBLE, 0, "%s", mesg);

  /* notreached */
  /* Tell static analyzers that this function does not return.  */
  abort ();
}

/* Number of compiled fixed strings known to exactly match the regexp.
   If kwsexec returns < kwset_exact_matches, then we don't need to
   call the regexp matcher at all. */
static int kwset_exact_matches;

static char const *
kwsincr_case (const char *must)
{
  const char *buf;
  size_t n;

  n = strlen (must);
#ifdef MBS_SUPPORT
  if (match_icase && MB_CUR_MAX > 1)
    buf = mbtolower (must, &n);
  else
#endif
    buf = must;
  return kwsincr (kwset, buf, n);
}

/* If the DFA turns out to have some set of fixed strings one of
   which must occur in the match, then we build a kwset matcher
   to find those strings, and thus quickly filter out impossible
   matches. */
static void
kwsmusts (void)
{
  struct dfamust const *dm;
  char const *err;

  if (dfa.musts)
    {
      kwsinit (&kwset);
      /* First, we compile in the substrings known to be exact
	 matches.  The kwset matcher will return the index
	 of the matching string that it chooses. */
      for (dm = dfa.musts; dm; dm = dm->next)
	{
	  
//Patch 0:
if ((!dm->exact) && !(__is_neg(7, &(dm), sizeof (dm), &(dm->exact), sizeof (dm->exact), &(kwset_exact_matches), sizeof (kwset_exact_matches), &(dm->next), sizeof (dm->next), &(err), sizeof (err), &(dm->must), sizeof (dm->must), &(kwset), sizeof (kwset))))
    continue;

//CodeSeg 1:
	  ++kwset_exact_matches;
	  if ((err = kwsincr_case (dm->must)) != NULL)
	    error (EXIT_TROUBLE, 0, "%s", err);
	}
      /* Now, we compile the substrings that will require
	 the use of the regexp matcher.  */
      for (dm = dfa.musts; dm; dm = dm->next)
	{
	  if (dm->exact)
	    continue;
	  if ((err = kwsincr_case (dm->must)) != NULL)
	    error (EXIT_TROUBLE, 0, "%s", err);
	}
      if ((err = kwsprep (kwset)) != NULL)
	error (EXIT_TROUBLE, 0, "%s", err);
    }
}

void
GEAcompile (char const *pattern, size_t size, reg_syntax_t syntax_bits)
{
  const char *err;
  const char *p, *sep;
  size_t total = size;
  char *motif;

  if (match_icase)
    syntax_bits |= RE_ICASE;
  re_set_syntax (syntax_bits);
  dfasyntax (syntax_bits, match_icase, eolbyte);

  /* For GNU regex compiler we have to pass the patterns separately to detect
     errors like "[\nallo\n]\n".  The patterns here are "[", "allo" and "]"
     GNU regex should have raise a syntax error.  The same for backref, where
     the backref should have been local to each pattern.  */
  p = pattern;
  do
    {
      size_t len;
      sep = memchr (p, '\n', total);
      if (sep)
	{
	  len = sep - p;
	  sep++;
	  total -= (len + 1);
	}
      else
	{
	  len = total;
	  total = 0;
	}

      patterns = realloc (patterns, (pcount + 1) * sizeof (*patterns));
      if (patterns == NULL)
	error (EXIT_TROUBLE, errno, _("memory exhausted"));
      patterns[pcount] = patterns0;

      if ((err = re_compile_pattern (p, len,
				    &(patterns[pcount].regexbuf))) != NULL)
	error (EXIT_TROUBLE, 0, "%s", err);
      pcount++;

      p = sep;
    } while (sep && total != 0);

  /* In the match_words and match_lines cases, we use a different pattern
     for the DFA matcher that will quickly throw out cases that won't work.
     Then if DFA succeeds we do some hairy stuff using the regex matcher
     to decide whether the match should really count. */
  if (match_words || match_lines)
    {
      static char const line_beg_no_bk[] = "^(";
      static char const line_end_no_bk[] = ")$";
      static char const word_beg_no_bk[] = "(^|[^[:alnum:]_])(";
      static char const word_end_no_bk[] = ")([^[:alnum:]_]|$)";
      static char const line_beg_bk[] = "^\\(";
      static char const line_end_bk[] = "\\)$";
      static char const word_beg_bk[] = "\\(^\\|[^[:alnum:]_]\\)\\(";
      static char const word_end_bk[] = "\\)\\([^[:alnum:]_]\\|$\\)";
      int bk = !(syntax_bits & RE_NO_BK_PARENS);
      char *n = xmalloc (sizeof word_beg_bk - 1 + size + sizeof word_end_bk);

      strcpy (n, match_lines ? (bk ? line_beg_bk : line_beg_no_bk)
			     : (bk ? word_beg_bk : word_beg_no_bk));
      total = strlen(n);
      memcpy (n + total, pattern, size);
      total += size;
      strcpy (n + total, match_lines ? (bk ? line_end_bk : line_end_no_bk)
				     : (bk ? word_end_bk : word_end_no_bk));
      total += strlen (n + total);
      pattern = motif = n;
      size = total;
    }
  else
    motif = NULL;

  dfacomp (pattern, size, &dfa, 1);
  kwsmusts ();

  free(motif);
}

size_t
EGexecute (char const *buf, size_t size, size_t *match_size,
	   char const *start_ptr)
{
  char const *buflim, *beg, *end, *match, *best_match, *mb_start;
  char eol = eolbyte;
  int backref, start, len, best_len;
  struct kwsmatch kwsm;
  size_t i, ret_val;
#ifdef MBS_SUPPORT
  if (MB_CUR_MAX > 1)
    {
      if (match_icase)
        {
          /* mbtolower adds a NUL byte at the end.  That will provide
	     space for the sentinel byte dfaexec may add.  */
          char *case_buf = mbtolower (buf, &size);
	  if (start_ptr)
	    start_ptr = case_buf + (start_ptr - buf);
          buf = case_buf;
        }
    }
#endif /* MBS_SUPPORT */

  mb_start = buf;
  buflim = buf + size;

  for (beg = end = buf; end < buflim; beg = end)
    {
      if (!start_ptr)
	{
	  /* We don't care about an exact match.  */
	  if (kwset)
	    {
	      /* Find a possible match using the KWset matcher. */
	      size_t offset = kwsexec (kwset, beg, buflim - beg, &kwsm);
	      if (offset == (size_t) -1)
		goto failure;
	      beg += offset;
	      /* Narrow down to the line containing the candidate, and
		 run it through DFA. */
	      if ((end = memchr(beg, eol, buflim - beg)) != NULL)
	        end++;
              else
                end = buflim;
	      match = beg;
	      while (beg > buf && beg[-1] != eol)
		--beg;
	      if (kwsm.index < kwset_exact_matches)
                {
#ifdef MBS_SUPPORT
                  if (mb_start < beg)
                    mb_start = beg;
                  if (MB_CUR_MAX == 1 || !is_mb_middle (&mb_start, match, buflim))
#endif
                    goto success;
                }
	      if (dfaexec (&dfa, beg, (char *) end, 0, NULL, &backref) == NULL)
		continue;
	    }
	  else
	    {
	      /* No good fixed strings; start with DFA. */
	      char const *next_beg = dfaexec (&dfa, beg, (char *) buflim,
					      0, NULL, &backref);
	      if (next_beg == NULL)
		break;
	      /* Narrow down to the line we've found. */
	      beg = next_beg;
	      if ((end = memchr(beg, eol, buflim - beg)) != NULL)
	        end++;
              else
                end = buflim;
	      while (beg > buf && beg[-1] != eol)
		--beg;
	    }
	  /* Successful, no backreferences encountered! */
	  if (!backref)
	    goto success;
	}
      else
	{
	  /* We are looking for the leftmost (then longest) exact match.
	     We will go through the outer loop only once.  */
	  beg = start_ptr;
	  end = buflim;
	}

      /* If we've made it to this point, this means DFA has seen
	 a probable match, and we need to run it through Regex. */
      best_match = end;
      best_len = 0;
      for (i = 0; i < pcount; i++)
	{
	  patterns[i].regexbuf.not_eol = 0;
	  if (0 <= (start = re_search (&(patterns[i].regexbuf),
				       buf, end - buf - 1,
				       beg - buf, end - beg - 1,
				       &(patterns[i].regs))))
	    {
	      len = patterns[i].regs.end[0] - start;
	      match = buf + start;
	      if (match > best_match)
		continue;
	      if (start_ptr && !match_words)
		goto assess_pattern_match;
	      if ((!match_lines && !match_words)
		  || (match_lines && len == end - beg - 1))
		{
		  match = beg;
		  len = end - beg;
		  goto assess_pattern_match;
		}
	      /* If -w, check if the match aligns with word boundaries.
		 We do this iteratively because:
		 (a) the line may contain more than one occurence of the
		 pattern, and
		 (b) Several alternatives in the pattern might be valid at a
		 given point, and we may need to consider a shorter one to
		 find a word boundary.  */
	      if (match_words)
		while (match <= best_match)
		  {
		    if ((match == buf || !WCHAR ((unsigned char) match[-1]))
			&& (len == end - beg - 1
			    || !WCHAR ((unsigned char) match[len])))
		      goto assess_pattern_match;
		    if (len > 0)
		      {
			/* Try a shorter length anchored at the same place. */
			--len;
			patterns[i].regexbuf.not_eol = 1;
			len = re_match (&(patterns[i].regexbuf),
					buf, match + len - beg, match - buf,
					&(patterns[i].regs));
		      }
		    if (len <= 0)
		      {
			/* Try looking further on. */
			if (match == end - 1)
			  break;
			match++;
			patterns[i].regexbuf.not_eol = 0;
			start = re_search (&(patterns[i].regexbuf),
					   buf, end - buf - 1,
					   match - buf, end - match - 1,
					   &(patterns[i].regs));
			if (start < 0)
			  break;
			len = patterns[i].regs.end[0] - start;
			match = buf + start;
		      }
		  } /* while (match <= best_match) */
	      continue;
	    assess_pattern_match:
	      if (!start_ptr)
		{
		  /* Good enough for a non-exact match.
		     No need to look at further patterns, if any.  */
		  beg = match;
		  goto success_in_len;
		}
	      if (match < best_match || (match == best_match && len > best_len))
		{
		  /* Best exact match:  leftmost, then longest.  */
		  best_match = match;
		  best_len = len;
		}
	    } /* if re_search >= 0 */
	} /* for Regex patterns.  */
	if (best_match < end)
	  {
	    /* We have found an exact match.  We were just
	       waiting for the best one (leftmost then longest).  */
	    beg = best_match;
	    len = best_len;
	    goto success_in_len;
	  }
    } /* for (beg = end ..) */

 failure:
  ret_val = -1;
  goto out;

 success:
  len = end - beg;
 success_in_len:
  *match_size = len;
  ret_val = beg - buf;
 out:
  return ret_val;
}

Spawn 1 instances, now Total 42
Counter: 43
Batcher Size:42
Preprocess the following candidate with CondTester:
Priority 20000
At location src/dfasearch.c:126
--Src File: src/dfasearch.c
Fragment 0:
if ((match_icase) && !(__abst_hole(match_icase, syntax_bits, size, eolbyte, pattern, p, sep, total, patterns, pcount, err, match_words, match_lines, motif)))
    syntax_bits |= ((((((((((((((((((((((((unsigned long)1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1);


CondTester, a patch instance with id 42:
//src_file:src/dfasearch.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); void* memset(void*, int, unsigned long); 
/* dfasearch.c - searching subroutines using dfa and regex for grep.
   Copyright 1992, 1998, 2000, 2007, 2009-2010 Free Software Foundation, Inc.

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 3, or (at your option)
   any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program; if not, write to the Free Software
   Foundation, Inc., 51 Franklin Street - Fifth Floor, Boston, MA
   02110-1301, USA.  */

/* Written August 1992 by Mike Haertel. */

#include <config.h>
#include "search.h"
#include "dfa.h"

/* For -w, we also consider _ to be word constituent.  */
#define WCHAR(C) (ISALNUM(C) || (C) == '_')

/* KWset compiled pattern.  For Ecompile and Gcompile, we compile
   a list of strings, at least one of which is known to occur in
   any string matching the regexp. */
static kwset_t kwset;

/* DFA compiled regexp. */
static struct dfa dfa;

/* The Regex compiled patterns.  */
static struct patterns
{
  /* Regex compiled regexp. */
  struct re_pattern_buffer regexbuf;
  struct re_registers regs; /* This is here on account of a BRAIN-DEAD
			       Q@#%!# library interface in regex.c.  */
} patterns0;

struct patterns *patterns;
size_t pcount;

void
dfaerror (char const *mesg)
{
  error (EXIT_TROUBLE, 0, "%s", mesg);

  /* notreached */
  /* Tell static analyzers that this function does not return.  */
  abort ();
}

/* Number of compiled fixed strings known to exactly match the regexp.
   If kwsexec returns < kwset_exact_matches, then we don't need to
   call the regexp matcher at all. */
static int kwset_exact_matches;

static char const *
kwsincr_case (const char *must)
{
  const char *buf;
  size_t n;

  n = strlen (must);
#ifdef MBS_SUPPORT
  if (match_icase && MB_CUR_MAX > 1)
    buf = mbtolower (must, &n);
  else
#endif
    buf = must;
  return kwsincr (kwset, buf, n);
}

/* If the DFA turns out to have some set of fixed strings one of
   which must occur in the match, then we build a kwset matcher
   to find those strings, and thus quickly filter out impossible
   matches. */
static void
kwsmusts (void)
{
  struct dfamust const *dm;
  char const *err;

  if (dfa.musts)
    {
      kwsinit (&kwset);
      /* First, we compile in the substrings known to be exact
	 matches.  The kwset matcher will return the index
	 of the matching string that it chooses. */
      for (dm = dfa.musts; dm; dm = dm->next)
	{
	  if (!dm->exact)
	    continue;
	  ++kwset_exact_matches;
	  if ((err = kwsincr_case (dm->must)) != NULL)
	    error (EXIT_TROUBLE, 0, "%s", err);
	}
      /* Now, we compile the substrings that will require
	 the use of the regexp matcher.  */
      for (dm = dfa.musts; dm; dm = dm->next)
	{
	  if (dm->exact)
	    continue;
	  if ((err = kwsincr_case (dm->must)) != NULL)
	    error (EXIT_TROUBLE, 0, "%s", err);
	}
      if ((err = kwsprep (kwset)) != NULL)
	error (EXIT_TROUBLE, 0, "%s", err);
    }
}

void
GEAcompile (char const *pattern, size_t size, reg_syntax_t syntax_bits)
{
  const char *err;
  const char *p, *sep;
  size_t total = size;
  char *motif;

  
//Patch 0:
if ((match_icase) && !(__is_neg(14, &(match_icase), sizeof (match_icase), &(syntax_bits), sizeof (syntax_bits), &(size), sizeof (size), &(eolbyte), sizeof (eolbyte), &(pattern), sizeof (pattern), &(p), sizeof (p), &(sep), sizeof (sep), &(total), sizeof (total), &(patterns), sizeof (patterns), &(pcount), sizeof (pcount), &(err), sizeof (err), &(match_words), sizeof (match_words), &(match_lines), sizeof (match_lines), &(motif), sizeof (motif))))
    syntax_bits |= ((((((((((((((((((((((((unsigned long)1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1);

//CodeSeg 1:
  re_set_syntax (syntax_bits);
  dfasyntax (syntax_bits, match_icase, eolbyte);

  /* For GNU regex compiler we have to pass the patterns separately to detect
     errors like "[\nallo\n]\n".  The patterns here are "[", "allo" and "]"
     GNU regex should have raise a syntax error.  The same for backref, where
     the backref should have been local to each pattern.  */
  p = pattern;
  do
    {
      size_t len;
      sep = memchr (p, '\n', total);
      if (sep)
	{
	  len = sep - p;
	  sep++;
	  total -= (len + 1);
	}
      else
	{
	  len = total;
	  total = 0;
	}

      patterns = realloc (patterns, (pcount + 1) * sizeof (*patterns));
      if (patterns == NULL)
	error (EXIT_TROUBLE, errno, _("memory exhausted"));
      patterns[pcount] = patterns0;

      if ((err = re_compile_pattern (p, len,
				    &(patterns[pcount].regexbuf))) != NULL)
	error (EXIT_TROUBLE, 0, "%s", err);
      pcount++;

      p = sep;
    } while (sep && total != 0);

  /* In the match_words and match_lines cases, we use a different pattern
     for the DFA matcher that will quickly throw out cases that won't work.
     Then if DFA succeeds we do some hairy stuff using the regex matcher
     to decide whether the match should really count. */
  if (match_words || match_lines)
    {
      static char const line_beg_no_bk[] = "^(";
      static char const line_end_no_bk[] = ")$";
      static char const word_beg_no_bk[] = "(^|[^[:alnum:]_])(";
      static char const word_end_no_bk[] = ")([^[:alnum:]_]|$)";
      static char const line_beg_bk[] = "^\\(";
      static char const line_end_bk[] = "\\)$";
      static char const word_beg_bk[] = "\\(^\\|[^[:alnum:]_]\\)\\(";
      static char const word_end_bk[] = "\\)\\([^[:alnum:]_]\\|$\\)";
      int bk = !(syntax_bits & RE_NO_BK_PARENS);
      char *n = xmalloc (sizeof word_beg_bk - 1 + size + sizeof word_end_bk);

      strcpy (n, match_lines ? (bk ? line_beg_bk : line_beg_no_bk)
			     : (bk ? word_beg_bk : word_beg_no_bk));
      total = strlen(n);
      memcpy (n + total, pattern, size);
      total += size;
      strcpy (n + total, match_lines ? (bk ? line_end_bk : line_end_no_bk)
				     : (bk ? word_end_bk : word_end_no_bk));
      total += strlen (n + total);
      pattern = motif = n;
      size = total;
    }
  else
    motif = NULL;

  dfacomp (pattern, size, &dfa, 1);
  kwsmusts ();

  free(motif);
}

size_t
EGexecute (char const *buf, size_t size, size_t *match_size,
	   char const *start_ptr)
{
  char const *buflim, *beg, *end, *match, *best_match, *mb_start;
  char eol = eolbyte;
  int backref, start, len, best_len;
  struct kwsmatch kwsm;
  size_t i, ret_val;
#ifdef MBS_SUPPORT
  if (MB_CUR_MAX > 1)
    {
      if (match_icase)
        {
          /* mbtolower adds a NUL byte at the end.  That will provide
	     space for the sentinel byte dfaexec may add.  */
          char *case_buf = mbtolower (buf, &size);
	  if (start_ptr)
	    start_ptr = case_buf + (start_ptr - buf);
          buf = case_buf;
        }
    }
#endif /* MBS_SUPPORT */

  mb_start = buf;
  buflim = buf + size;

  for (beg = end = buf; end < buflim; beg = end)
    {
      if (!start_ptr)
	{
	  /* We don't care about an exact match.  */
	  if (kwset)
	    {
	      /* Find a possible match using the KWset matcher. */
	      size_t offset = kwsexec (kwset, beg, buflim - beg, &kwsm);
	      if (offset == (size_t) -1)
		goto failure;
	      beg += offset;
	      /* Narrow down to the line containing the candidate, and
		 run it through DFA. */
	      if ((end = memchr(beg, eol, buflim - beg)) != NULL)
	        end++;
              else
                end = buflim;
	      match = beg;
	      while (beg > buf && beg[-1] != eol)
		--beg;
	      if (kwsm.index < kwset_exact_matches)
                {
#ifdef MBS_SUPPORT
                  if (mb_start < beg)
                    mb_start = beg;
                  if (MB_CUR_MAX == 1 || !is_mb_middle (&mb_start, match, buflim))
#endif
                    goto success;
                }
	      if (dfaexec (&dfa, beg, (char *) end, 0, NULL, &backref) == NULL)
		continue;
	    }
	  else
	    {
	      /* No good fixed strings; start with DFA. */
	      char const *next_beg = dfaexec (&dfa, beg, (char *) buflim,
					      0, NULL, &backref);
	      if (next_beg == NULL)
		break;
	      /* Narrow down to the line we've found. */
	      beg = next_beg;
	      if ((end = memchr(beg, eol, buflim - beg)) != NULL)
	        end++;
              else
                end = buflim;
	      while (beg > buf && beg[-1] != eol)
		--beg;
	    }
	  /* Successful, no backreferences encountered! */
	  if (!backref)
	    goto success;
	}
      else
	{
	  /* We are looking for the leftmost (then longest) exact match.
	     We will go through the outer loop only once.  */
	  beg = start_ptr;
	  end = buflim;
	}

      /* If we've made it to this point, this means DFA has seen
	 a probable match, and we need to run it through Regex. */
      best_match = end;
      best_len = 0;
      for (i = 0; i < pcount; i++)
	{
	  patterns[i].regexbuf.not_eol = 0;
	  if (0 <= (start = re_search (&(patterns[i].regexbuf),
				       buf, end - buf - 1,
				       beg - buf, end - beg - 1,
				       &(patterns[i].regs))))
	    {
	      len = patterns[i].regs.end[0] - start;
	      match = buf + start;
	      if (match > best_match)
		continue;
	      if (start_ptr && !match_words)
		goto assess_pattern_match;
	      if ((!match_lines && !match_words)
		  || (match_lines && len == end - beg - 1))
		{
		  match = beg;
		  len = end - beg;
		  goto assess_pattern_match;
		}
	      /* If -w, check if the match aligns with word boundaries.
		 We do this iteratively because:
		 (a) the line may contain more than one occurence of the
		 pattern, and
		 (b) Several alternatives in the pattern might be valid at a
		 given point, and we may need to consider a shorter one to
		 find a word boundary.  */
	      if (match_words)
		while (match <= best_match)
		  {
		    if ((match == buf || !WCHAR ((unsigned char) match[-1]))
			&& (len == end - beg - 1
			    || !WCHAR ((unsigned char) match[len])))
		      goto assess_pattern_match;
		    if (len > 0)
		      {
			/* Try a shorter length anchored at the same place. */
			--len;
			patterns[i].regexbuf.not_eol = 1;
			len = re_match (&(patterns[i].regexbuf),
					buf, match + len - beg, match - buf,
					&(patterns[i].regs));
		      }
		    if (len <= 0)
		      {
			/* Try looking further on. */
			if (match == end - 1)
			  break;
			match++;
			patterns[i].regexbuf.not_eol = 0;
			start = re_search (&(patterns[i].regexbuf),
					   buf, end - buf - 1,
					   match - buf, end - match - 1,
					   &(patterns[i].regs));
			if (start < 0)
			  break;
			len = patterns[i].regs.end[0] - start;
			match = buf + start;
		      }
		  } /* while (match <= best_match) */
	      continue;
	    assess_pattern_match:
	      if (!start_ptr)
		{
		  /* Good enough for a non-exact match.
		     No need to look at further patterns, if any.  */
		  beg = match;
		  goto success_in_len;
		}
	      if (match < best_match || (match == best_match && len > best_len))
		{
		  /* Best exact match:  leftmost, then longest.  */
		  best_match = match;
		  best_len = len;
		}
	    } /* if re_search >= 0 */
	} /* for Regex patterns.  */
	if (best_match < end)
	  {
	    /* We have found an exact match.  We were just
	       waiting for the best one (leftmost then longest).  */
	    beg = best_match;
	    len = best_len;
	    goto success_in_len;
	  }
    } /* for (beg = end ..) */

 failure:
  ret_val = -1;
  goto out;

 success:
  len = end - beg;
 success_in_len:
  *match_size = len;
  ret_val = beg - buf;
 out:
  return ret_val;
}

Spawn 1 instances, now Total 43
Counter: 44
Batcher Size:43
Preprocess the following candidate with CondTester:
Priority 20000
At location src/dfasearch.c:279
--Src File: src/dfasearch.c
Fragment 0:
if ((!backref) && !(__abst_hole(backref, beg, buf, eol, buflim, end, start_ptr, best_match, best_len, i, pcount, patterns, start, len, match, mb_start, match_words, match_lines, kwset_exact_matches, kwset, size, match_icase, eolbyte, ret_val, match_size)))
    goto success;


CondTester, a patch instance with id 43:
//src_file:src/dfasearch.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); void* memset(void*, int, unsigned long); 
/* dfasearch.c - searching subroutines using dfa and regex for grep.
   Copyright 1992, 1998, 2000, 2007, 2009-2010 Free Software Foundation, Inc.

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 3, or (at your option)
   any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program; if not, write to the Free Software
   Foundation, Inc., 51 Franklin Street - Fifth Floor, Boston, MA
   02110-1301, USA.  */

/* Written August 1992 by Mike Haertel. */

#include <config.h>
#include "search.h"
#include "dfa.h"

/* For -w, we also consider _ to be word constituent.  */
#define WCHAR(C) (ISALNUM(C) || (C) == '_')

/* KWset compiled pattern.  For Ecompile and Gcompile, we compile
   a list of strings, at least one of which is known to occur in
   any string matching the regexp. */
static kwset_t kwset;

/* DFA compiled regexp. */
static struct dfa dfa;

/* The Regex compiled patterns.  */
static struct patterns
{
  /* Regex compiled regexp. */
  struct re_pattern_buffer regexbuf;
  struct re_registers regs; /* This is here on account of a BRAIN-DEAD
			       Q@#%!# library interface in regex.c.  */
} patterns0;

struct patterns *patterns;
size_t pcount;

void
dfaerror (char const *mesg)
{
  error (EXIT_TROUBLE, 0, "%s", mesg);

  /* notreached */
  /* Tell static analyzers that this function does not return.  */
  abort ();
}

/* Number of compiled fixed strings known to exactly match the regexp.
   If kwsexec returns < kwset_exact_matches, then we don't need to
   call the regexp matcher at all. */
static int kwset_exact_matches;

static char const *
kwsincr_case (const char *must)
{
  const char *buf;
  size_t n;

  n = strlen (must);
#ifdef MBS_SUPPORT
  if (match_icase && MB_CUR_MAX > 1)
    buf = mbtolower (must, &n);
  else
#endif
    buf = must;
  return kwsincr (kwset, buf, n);
}

/* If the DFA turns out to have some set of fixed strings one of
   which must occur in the match, then we build a kwset matcher
   to find those strings, and thus quickly filter out impossible
   matches. */
static void
kwsmusts (void)
{
  struct dfamust const *dm;
  char const *err;

  if (dfa.musts)
    {
      kwsinit (&kwset);
      /* First, we compile in the substrings known to be exact
	 matches.  The kwset matcher will return the index
	 of the matching string that it chooses. */
      for (dm = dfa.musts; dm; dm = dm->next)
	{
	  if (!dm->exact)
	    continue;
	  ++kwset_exact_matches;
	  if ((err = kwsincr_case (dm->must)) != NULL)
	    error (EXIT_TROUBLE, 0, "%s", err);
	}
      /* Now, we compile the substrings that will require
	 the use of the regexp matcher.  */
      for (dm = dfa.musts; dm; dm = dm->next)
	{
	  if (dm->exact)
	    continue;
	  if ((err = kwsincr_case (dm->must)) != NULL)
	    error (EXIT_TROUBLE, 0, "%s", err);
	}
      if ((err = kwsprep (kwset)) != NULL)
	error (EXIT_TROUBLE, 0, "%s", err);
    }
}

void
GEAcompile (char const *pattern, size_t size, reg_syntax_t syntax_bits)
{
  const char *err;
  const char *p, *sep;
  size_t total = size;
  char *motif;

  if (match_icase)
    syntax_bits |= RE_ICASE;
  re_set_syntax (syntax_bits);
  dfasyntax (syntax_bits, match_icase, eolbyte);

  /* For GNU regex compiler we have to pass the patterns separately to detect
     errors like "[\nallo\n]\n".  The patterns here are "[", "allo" and "]"
     GNU regex should have raise a syntax error.  The same for backref, where
     the backref should have been local to each pattern.  */
  p = pattern;
  do
    {
      size_t len;
      sep = memchr (p, '\n', total);
      if (sep)
	{
	  len = sep - p;
	  sep++;
	  total -= (len + 1);
	}
      else
	{
	  len = total;
	  total = 0;
	}

      patterns = realloc (patterns, (pcount + 1) * sizeof (*patterns));
      if (patterns == NULL)
	error (EXIT_TROUBLE, errno, _("memory exhausted"));
      patterns[pcount] = patterns0;

      if ((err = re_compile_pattern (p, len,
				    &(patterns[pcount].regexbuf))) != NULL)
	error (EXIT_TROUBLE, 0, "%s", err);
      pcount++;

      p = sep;
    } while (sep && total != 0);

  /* In the match_words and match_lines cases, we use a different pattern
     for the DFA matcher that will quickly throw out cases that won't work.
     Then if DFA succeeds we do some hairy stuff using the regex matcher
     to decide whether the match should really count. */
  if (match_words || match_lines)
    {
      static char const line_beg_no_bk[] = "^(";
      static char const line_end_no_bk[] = ")$";
      static char const word_beg_no_bk[] = "(^|[^[:alnum:]_])(";
      static char const word_end_no_bk[] = ")([^[:alnum:]_]|$)";
      static char const line_beg_bk[] = "^\\(";
      static char const line_end_bk[] = "\\)$";
      static char const word_beg_bk[] = "\\(^\\|[^[:alnum:]_]\\)\\(";
      static char const word_end_bk[] = "\\)\\([^[:alnum:]_]\\|$\\)";
      int bk = !(syntax_bits & RE_NO_BK_PARENS);
      char *n = xmalloc (sizeof word_beg_bk - 1 + size + sizeof word_end_bk);

      strcpy (n, match_lines ? (bk ? line_beg_bk : line_beg_no_bk)
			     : (bk ? word_beg_bk : word_beg_no_bk));
      total = strlen(n);
      memcpy (n + total, pattern, size);
      total += size;
      strcpy (n + total, match_lines ? (bk ? line_end_bk : line_end_no_bk)
				     : (bk ? word_end_bk : word_end_no_bk));
      total += strlen (n + total);
      pattern = motif = n;
      size = total;
    }
  else
    motif = NULL;

  dfacomp (pattern, size, &dfa, 1);
  kwsmusts ();

  free(motif);
}

size_t
EGexecute (char const *buf, size_t size, size_t *match_size,
	   char const *start_ptr)
{
  char const *buflim, *beg, *end, *match, *best_match, *mb_start;
  char eol = eolbyte;
  int backref, start, len, best_len;
  struct kwsmatch kwsm;
  size_t i, ret_val;
#ifdef MBS_SUPPORT
  if (MB_CUR_MAX > 1)
    {
      if (match_icase)
        {
          /* mbtolower adds a NUL byte at the end.  That will provide
	     space for the sentinel byte dfaexec may add.  */
          char *case_buf = mbtolower (buf, &size);
	  if (start_ptr)
	    start_ptr = case_buf + (start_ptr - buf);
          buf = case_buf;
        }
    }
#endif /* MBS_SUPPORT */

  mb_start = buf;
  buflim = buf + size;

  for (beg = end = buf; end < buflim; beg = end)
    {
      if (!start_ptr)
	{
	  /* We don't care about an exact match.  */
	  if (kwset)
	    {
	      /* Find a possible match using the KWset matcher. */
	      size_t offset = kwsexec (kwset, beg, buflim - beg, &kwsm);
	      if (offset == (size_t) -1)
		goto failure;
	      beg += offset;
	      /* Narrow down to the line containing the candidate, and
		 run it through DFA. */
	      if ((end = memchr(beg, eol, buflim - beg)) != NULL)
	        end++;
              else
                end = buflim;
	      match = beg;
	      while (beg > buf && beg[-1] != eol)
		--beg;
	      if (kwsm.index < kwset_exact_matches)
                {
#ifdef MBS_SUPPORT
                  if (mb_start < beg)
                    mb_start = beg;
                  if (MB_CUR_MAX == 1 || !is_mb_middle (&mb_start, match, buflim))
#endif
                    goto success;
                }
	      if (dfaexec (&dfa, beg, (char *) end, 0, NULL, &backref) == NULL)
		continue;
	    }
	  else
	    {
	      /* No good fixed strings; start with DFA. */
	      char const *next_beg = dfaexec (&dfa, beg, (char *) buflim,
					      0, NULL, &backref);
	      if (next_beg == NULL)
		break;
	      /* Narrow down to the line we've found. */
	      beg = next_beg;
	      if ((end = memchr(beg, eol, buflim - beg)) != NULL)
	        end++;
              else
                end = buflim;
	      while (beg > buf && beg[-1] != eol)
		--beg;
	    }
	  /* Successful, no backreferences encountered! */
	  
//Patch 0:
if ((!backref) && !(__is_neg(25, &(backref), sizeof (backref), &(beg), sizeof (beg), &(buf), sizeof (buf), &(eol), sizeof (eol), &(buflim), sizeof (buflim), &(end), sizeof (end), &(start_ptr), sizeof (start_ptr), &(best_match), sizeof (best_match), &(best_len), sizeof (best_len), &(i), sizeof (i), &(pcount), sizeof (pcount), &(patterns), sizeof (patterns), &(start), sizeof (start), &(len), sizeof (len), &(match), sizeof (match), &(mb_start), sizeof (mb_start), &(match_words), sizeof (match_words), &(match_lines), sizeof (match_lines), &(kwset_exact_matches), sizeof (kwset_exact_matches), &(kwset), sizeof (kwset), &(size), sizeof (size), &(match_icase), sizeof (match_icase), &(eolbyte), sizeof (eolbyte), &(ret_val), sizeof (ret_val), &(match_size), sizeof (match_size))))
    goto success;

//CodeSeg 1:
	}
      else
	{
	  /* We are looking for the leftmost (then longest) exact match.
	     We will go through the outer loop only once.  */
	  beg = start_ptr;
	  end = buflim;
	}

      /* If we've made it to this point, this means DFA has seen
	 a probable match, and we need to run it through Regex. */
      best_match = end;
      best_len = 0;
      for (i = 0; i < pcount; i++)
	{
	  patterns[i].regexbuf.not_eol = 0;
	  if (0 <= (start = re_search (&(patterns[i].regexbuf),
				       buf, end - buf - 1,
				       beg - buf, end - beg - 1,
				       &(patterns[i].regs))))
	    {
	      len = patterns[i].regs.end[0] - start;
	      match = buf + start;
	      if (match > best_match)
		continue;
	      if (start_ptr && !match_words)
		goto assess_pattern_match;
	      if ((!match_lines && !match_words)
		  || (match_lines && len == end - beg - 1))
		{
		  match = beg;
		  len = end - beg;
		  goto assess_pattern_match;
		}
	      /* If -w, check if the match aligns with word boundaries.
		 We do this iteratively because:
		 (a) the line may contain more than one occurence of the
		 pattern, and
		 (b) Several alternatives in the pattern might be valid at a
		 given point, and we may need to consider a shorter one to
		 find a word boundary.  */
	      if (match_words)
		while (match <= best_match)
		  {
		    if ((match == buf || !WCHAR ((unsigned char) match[-1]))
			&& (len == end - beg - 1
			    || !WCHAR ((unsigned char) match[len])))
		      goto assess_pattern_match;
		    if (len > 0)
		      {
			/* Try a shorter length anchored at the same place. */
			--len;
			patterns[i].regexbuf.not_eol = 1;
			len = re_match (&(patterns[i].regexbuf),
					buf, match + len - beg, match - buf,
					&(patterns[i].regs));
		      }
		    if (len <= 0)
		      {
			/* Try looking further on. */
			if (match == end - 1)
			  break;
			match++;
			patterns[i].regexbuf.not_eol = 0;
			start = re_search (&(patterns[i].regexbuf),
					   buf, end - buf - 1,
					   match - buf, end - match - 1,
					   &(patterns[i].regs));
			if (start < 0)
			  break;
			len = patterns[i].regs.end[0] - start;
			match = buf + start;
		      }
		  } /* while (match <= best_match) */
	      continue;
	    assess_pattern_match:
	      if (!start_ptr)
		{
		  /* Good enough for a non-exact match.
		     No need to look at further patterns, if any.  */
		  beg = match;
		  goto success_in_len;
		}
	      if (match < best_match || (match == best_match && len > best_len))
		{
		  /* Best exact match:  leftmost, then longest.  */
		  best_match = match;
		  best_len = len;
		}
	    } /* if re_search >= 0 */
	} /* for Regex patterns.  */
	if (best_match < end)
	  {
	    /* We have found an exact match.  We were just
	       waiting for the best one (leftmost then longest).  */
	    beg = best_match;
	    len = best_len;
	    goto success_in_len;
	  }
    } /* for (beg = end ..) */

 failure:
  ret_val = -1;
  goto out;

 success:
  len = end - beg;
 success_in_len:
  *match_size = len;
  ret_val = beg - buf;
 out:
  return ret_val;
}

Spawn 1 instances, now Total 44
Counter: 45
Batcher Size:44
Preprocess the following candidate with CondTester:
Priority 20000
At location src/dfasearch.c:279
--Src File: src/dfasearch.c
Fragment 0:
if ((!backref) || (__abst_hole(backref, beg, buf, eol, buflim, end, start_ptr, best_match, best_len, i, pcount, patterns, start, len, match, mb_start, match_words, match_lines, kwset_exact_matches, kwset, size, match_icase, eolbyte, ret_val, match_size)))
    goto success;


CondTester, a patch instance with id 44:
//src_file:src/dfasearch.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); void* memset(void*, int, unsigned long); 
/* dfasearch.c - searching subroutines using dfa and regex for grep.
   Copyright 1992, 1998, 2000, 2007, 2009-2010 Free Software Foundation, Inc.

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 3, or (at your option)
   any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program; if not, write to the Free Software
   Foundation, Inc., 51 Franklin Street - Fifth Floor, Boston, MA
   02110-1301, USA.  */

/* Written August 1992 by Mike Haertel. */

#include <config.h>
#include "search.h"
#include "dfa.h"

/* For -w, we also consider _ to be word constituent.  */
#define WCHAR(C) (ISALNUM(C) || (C) == '_')

/* KWset compiled pattern.  For Ecompile and Gcompile, we compile
   a list of strings, at least one of which is known to occur in
   any string matching the regexp. */
static kwset_t kwset;

/* DFA compiled regexp. */
static struct dfa dfa;

/* The Regex compiled patterns.  */
static struct patterns
{
  /* Regex compiled regexp. */
  struct re_pattern_buffer regexbuf;
  struct re_registers regs; /* This is here on account of a BRAIN-DEAD
			       Q@#%!# library interface in regex.c.  */
} patterns0;

struct patterns *patterns;
size_t pcount;

void
dfaerror (char const *mesg)
{
  error (EXIT_TROUBLE, 0, "%s", mesg);

  /* notreached */
  /* Tell static analyzers that this function does not return.  */
  abort ();
}

/* Number of compiled fixed strings known to exactly match the regexp.
   If kwsexec returns < kwset_exact_matches, then we don't need to
   call the regexp matcher at all. */
static int kwset_exact_matches;

static char const *
kwsincr_case (const char *must)
{
  const char *buf;
  size_t n;

  n = strlen (must);
#ifdef MBS_SUPPORT
  if (match_icase && MB_CUR_MAX > 1)
    buf = mbtolower (must, &n);
  else
#endif
    buf = must;
  return kwsincr (kwset, buf, n);
}

/* If the DFA turns out to have some set of fixed strings one of
   which must occur in the match, then we build a kwset matcher
   to find those strings, and thus quickly filter out impossible
   matches. */
static void
kwsmusts (void)
{
  struct dfamust const *dm;
  char const *err;

  if (dfa.musts)
    {
      kwsinit (&kwset);
      /* First, we compile in the substrings known to be exact
	 matches.  The kwset matcher will return the index
	 of the matching string that it chooses. */
      for (dm = dfa.musts; dm; dm = dm->next)
	{
	  if (!dm->exact)
	    continue;
	  ++kwset_exact_matches;
	  if ((err = kwsincr_case (dm->must)) != NULL)
	    error (EXIT_TROUBLE, 0, "%s", err);
	}
      /* Now, we compile the substrings that will require
	 the use of the regexp matcher.  */
      for (dm = dfa.musts; dm; dm = dm->next)
	{
	  if (dm->exact)
	    continue;
	  if ((err = kwsincr_case (dm->must)) != NULL)
	    error (EXIT_TROUBLE, 0, "%s", err);
	}
      if ((err = kwsprep (kwset)) != NULL)
	error (EXIT_TROUBLE, 0, "%s", err);
    }
}

void
GEAcompile (char const *pattern, size_t size, reg_syntax_t syntax_bits)
{
  const char *err;
  const char *p, *sep;
  size_t total = size;
  char *motif;

  if (match_icase)
    syntax_bits |= RE_ICASE;
  re_set_syntax (syntax_bits);
  dfasyntax (syntax_bits, match_icase, eolbyte);

  /* For GNU regex compiler we have to pass the patterns separately to detect
     errors like "[\nallo\n]\n".  The patterns here are "[", "allo" and "]"
     GNU regex should have raise a syntax error.  The same for backref, where
     the backref should have been local to each pattern.  */
  p = pattern;
  do
    {
      size_t len;
      sep = memchr (p, '\n', total);
      if (sep)
	{
	  len = sep - p;
	  sep++;
	  total -= (len + 1);
	}
      else
	{
	  len = total;
	  total = 0;
	}

      patterns = realloc (patterns, (pcount + 1) * sizeof (*patterns));
      if (patterns == NULL)
	error (EXIT_TROUBLE, errno, _("memory exhausted"));
      patterns[pcount] = patterns0;

      if ((err = re_compile_pattern (p, len,
				    &(patterns[pcount].regexbuf))) != NULL)
	error (EXIT_TROUBLE, 0, "%s", err);
      pcount++;

      p = sep;
    } while (sep && total != 0);

  /* In the match_words and match_lines cases, we use a different pattern
     for the DFA matcher that will quickly throw out cases that won't work.
     Then if DFA succeeds we do some hairy stuff using the regex matcher
     to decide whether the match should really count. */
  if (match_words || match_lines)
    {
      static char const line_beg_no_bk[] = "^(";
      static char const line_end_no_bk[] = ")$";
      static char const word_beg_no_bk[] = "(^|[^[:alnum:]_])(";
      static char const word_end_no_bk[] = ")([^[:alnum:]_]|$)";
      static char const line_beg_bk[] = "^\\(";
      static char const line_end_bk[] = "\\)$";
      static char const word_beg_bk[] = "\\(^\\|[^[:alnum:]_]\\)\\(";
      static char const word_end_bk[] = "\\)\\([^[:alnum:]_]\\|$\\)";
      int bk = !(syntax_bits & RE_NO_BK_PARENS);
      char *n = xmalloc (sizeof word_beg_bk - 1 + size + sizeof word_end_bk);

      strcpy (n, match_lines ? (bk ? line_beg_bk : line_beg_no_bk)
			     : (bk ? word_beg_bk : word_beg_no_bk));
      total = strlen(n);
      memcpy (n + total, pattern, size);
      total += size;
      strcpy (n + total, match_lines ? (bk ? line_end_bk : line_end_no_bk)
				     : (bk ? word_end_bk : word_end_no_bk));
      total += strlen (n + total);
      pattern = motif = n;
      size = total;
    }
  else
    motif = NULL;

  dfacomp (pattern, size, &dfa, 1);
  kwsmusts ();

  free(motif);
}

size_t
EGexecute (char const *buf, size_t size, size_t *match_size,
	   char const *start_ptr)
{
  char const *buflim, *beg, *end, *match, *best_match, *mb_start;
  char eol = eolbyte;
  int backref, start, len, best_len;
  struct kwsmatch kwsm;
  size_t i, ret_val;
#ifdef MBS_SUPPORT
  if (MB_CUR_MAX > 1)
    {
      if (match_icase)
        {
          /* mbtolower adds a NUL byte at the end.  That will provide
	     space for the sentinel byte dfaexec may add.  */
          char *case_buf = mbtolower (buf, &size);
	  if (start_ptr)
	    start_ptr = case_buf + (start_ptr - buf);
          buf = case_buf;
        }
    }
#endif /* MBS_SUPPORT */

  mb_start = buf;
  buflim = buf + size;

  for (beg = end = buf; end < buflim; beg = end)
    {
      if (!start_ptr)
	{
	  /* We don't care about an exact match.  */
	  if (kwset)
	    {
	      /* Find a possible match using the KWset matcher. */
	      size_t offset = kwsexec (kwset, beg, buflim - beg, &kwsm);
	      if (offset == (size_t) -1)
		goto failure;
	      beg += offset;
	      /* Narrow down to the line containing the candidate, and
		 run it through DFA. */
	      if ((end = memchr(beg, eol, buflim - beg)) != NULL)
	        end++;
              else
                end = buflim;
	      match = beg;
	      while (beg > buf && beg[-1] != eol)
		--beg;
	      if (kwsm.index < kwset_exact_matches)
                {
#ifdef MBS_SUPPORT
                  if (mb_start < beg)
                    mb_start = beg;
                  if (MB_CUR_MAX == 1 || !is_mb_middle (&mb_start, match, buflim))
#endif
                    goto success;
                }
	      if (dfaexec (&dfa, beg, (char *) end, 0, NULL, &backref) == NULL)
		continue;
	    }
	  else
	    {
	      /* No good fixed strings; start with DFA. */
	      char const *next_beg = dfaexec (&dfa, beg, (char *) buflim,
					      0, NULL, &backref);
	      if (next_beg == NULL)
		break;
	      /* Narrow down to the line we've found. */
	      beg = next_beg;
	      if ((end = memchr(beg, eol, buflim - beg)) != NULL)
	        end++;
              else
                end = buflim;
	      while (beg > buf && beg[-1] != eol)
		--beg;
	    }
	  /* Successful, no backreferences encountered! */
	  
//Patch 0:
if ((!backref) || (__is_neg(25, &(backref), sizeof (backref), &(beg), sizeof (beg), &(buf), sizeof (buf), &(eol), sizeof (eol), &(buflim), sizeof (buflim), &(end), sizeof (end), &(start_ptr), sizeof (start_ptr), &(best_match), sizeof (best_match), &(best_len), sizeof (best_len), &(i), sizeof (i), &(pcount), sizeof (pcount), &(patterns), sizeof (patterns), &(start), sizeof (start), &(len), sizeof (len), &(match), sizeof (match), &(mb_start), sizeof (mb_start), &(match_words), sizeof (match_words), &(match_lines), sizeof (match_lines), &(kwset_exact_matches), sizeof (kwset_exact_matches), &(kwset), sizeof (kwset), &(size), sizeof (size), &(match_icase), sizeof (match_icase), &(eolbyte), sizeof (eolbyte), &(ret_val), sizeof (ret_val), &(match_size), sizeof (match_size))))
    goto success;

//CodeSeg 1:
	}
      else
	{
	  /* We are looking for the leftmost (then longest) exact match.
	     We will go through the outer loop only once.  */
	  beg = start_ptr;
	  end = buflim;
	}

      /* If we've made it to this point, this means DFA has seen
	 a probable match, and we need to run it through Regex. */
      best_match = end;
      best_len = 0;
      for (i = 0; i < pcount; i++)
	{
	  patterns[i].regexbuf.not_eol = 0;
	  if (0 <= (start = re_search (&(patterns[i].regexbuf),
				       buf, end - buf - 1,
				       beg - buf, end - beg - 1,
				       &(patterns[i].regs))))
	    {
	      len = patterns[i].regs.end[0] - start;
	      match = buf + start;
	      if (match > best_match)
		continue;
	      if (start_ptr && !match_words)
		goto assess_pattern_match;
	      if ((!match_lines && !match_words)
		  || (match_lines && len == end - beg - 1))
		{
		  match = beg;
		  len = end - beg;
		  goto assess_pattern_match;
		}
	      /* If -w, check if the match aligns with word boundaries.
		 We do this iteratively because:
		 (a) the line may contain more than one occurence of the
		 pattern, and
		 (b) Several alternatives in the pattern might be valid at a
		 given point, and we may need to consider a shorter one to
		 find a word boundary.  */
	      if (match_words)
		while (match <= best_match)
		  {
		    if ((match == buf || !WCHAR ((unsigned char) match[-1]))
			&& (len == end - beg - 1
			    || !WCHAR ((unsigned char) match[len])))
		      goto assess_pattern_match;
		    if (len > 0)
		      {
			/* Try a shorter length anchored at the same place. */
			--len;
			patterns[i].regexbuf.not_eol = 1;
			len = re_match (&(patterns[i].regexbuf),
					buf, match + len - beg, match - buf,
					&(patterns[i].regs));
		      }
		    if (len <= 0)
		      {
			/* Try looking further on. */
			if (match == end - 1)
			  break;
			match++;
			patterns[i].regexbuf.not_eol = 0;
			start = re_search (&(patterns[i].regexbuf),
					   buf, end - buf - 1,
					   match - buf, end - match - 1,
					   &(patterns[i].regs));
			if (start < 0)
			  break;
			len = patterns[i].regs.end[0] - start;
			match = buf + start;
		      }
		  } /* while (match <= best_match) */
	      continue;
	    assess_pattern_match:
	      if (!start_ptr)
		{
		  /* Good enough for a non-exact match.
		     No need to look at further patterns, if any.  */
		  beg = match;
		  goto success_in_len;
		}
	      if (match < best_match || (match == best_match && len > best_len))
		{
		  /* Best exact match:  leftmost, then longest.  */
		  best_match = match;
		  best_len = len;
		}
	    } /* if re_search >= 0 */
	} /* for Regex patterns.  */
	if (best_match < end)
	  {
	    /* We have found an exact match.  We were just
	       waiting for the best one (leftmost then longest).  */
	    beg = best_match;
	    len = best_len;
	    goto success_in_len;
	  }
    } /* for (beg = end ..) */

 failure:
  ret_val = -1;
  goto out;

 success:
  len = end - beg;
 success_in_len:
  *match_size = len;
  ret_val = beg - buf;
 out:
  return ret_val;
}

Spawn 1 instances, now Total 45
Counter: 46
Batcher Size:45
Preprocess the following candidate with CondTester:
Priority 20000
At location src/dfasearch.c:231
--Src File: src/dfasearch.c
Fragment 0:
if ((!start_ptr) && !(__abst_hole(start_ptr, buf, buflim, beg, end, kwset, size, mb_start, eol, match, match_icase, kwset_exact_matches, eolbyte, backref, best_match, best_len, i, pcount, patterns, start, len, match_words, match_lines, ret_val, match_size))) {
    if (kwset) {
        size_t offset = kwsexec(kwset, beg, buflim - beg, &kwsm);
        if (offset == (size_t)-1)
            goto failure;
        beg += offset;
        if ((end = memchr(beg, eol, buflim - beg)) != ((void *)0))
            end++;
        else
            end = buflim;
        match = beg;
        while (beg > buf && beg[-1] != eol)
            --beg;
        if (kwsm.index < kwset_exact_matches) {
            if (mb_start < beg)
                mb_start = beg;
            if ((__ctype_get_mb_cur_max()) == 1 || !is_mb_middle(&mb_start, match, buflim))
                goto success;
        }
        if (dfaexec(&dfa, beg, (char *)end, 0, ((void *)0), &backref) == ((void *)0))
            continue;
    } else {
        const char *next_beg = dfaexec(&dfa, beg, (char *)buflim, 0, ((void *)0), &backref);
        if (next_beg == ((void *)0))
            break;
        beg = next_beg;
        if ((end = memchr(beg, eol, buflim - beg)) != ((void *)0))
            end++;
        else
            end = buflim;
        while (beg > buf && beg[-1] != eol)
            --beg;
    }
    if (!backref)
        goto success;
} else {
    beg = start_ptr;
    end = buflim;
}


CondTester, a patch instance with id 45:
//src_file:src/dfasearch.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); void* memset(void*, int, unsigned long); 
/* dfasearch.c - searching subroutines using dfa and regex for grep.
   Copyright 1992, 1998, 2000, 2007, 2009-2010 Free Software Foundation, Inc.

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 3, or (at your option)
   any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program; if not, write to the Free Software
   Foundation, Inc., 51 Franklin Street - Fifth Floor, Boston, MA
   02110-1301, USA.  */

/* Written August 1992 by Mike Haertel. */

#include <config.h>
#include "search.h"
#include "dfa.h"

/* For -w, we also consider _ to be word constituent.  */
#define WCHAR(C) (ISALNUM(C) || (C) == '_')

/* KWset compiled pattern.  For Ecompile and Gcompile, we compile
   a list of strings, at least one of which is known to occur in
   any string matching the regexp. */
static kwset_t kwset;

/* DFA compiled regexp. */
static struct dfa dfa;

/* The Regex compiled patterns.  */
static struct patterns
{
  /* Regex compiled regexp. */
  struct re_pattern_buffer regexbuf;
  struct re_registers regs; /* This is here on account of a BRAIN-DEAD
			       Q@#%!# library interface in regex.c.  */
} patterns0;

struct patterns *patterns;
size_t pcount;

void
dfaerror (char const *mesg)
{
  error (EXIT_TROUBLE, 0, "%s", mesg);

  /* notreached */
  /* Tell static analyzers that this function does not return.  */
  abort ();
}

/* Number of compiled fixed strings known to exactly match the regexp.
   If kwsexec returns < kwset_exact_matches, then we don't need to
   call the regexp matcher at all. */
static int kwset_exact_matches;

static char const *
kwsincr_case (const char *must)
{
  const char *buf;
  size_t n;

  n = strlen (must);
#ifdef MBS_SUPPORT
  if (match_icase && MB_CUR_MAX > 1)
    buf = mbtolower (must, &n);
  else
#endif
    buf = must;
  return kwsincr (kwset, buf, n);
}

/* If the DFA turns out to have some set of fixed strings one of
   which must occur in the match, then we build a kwset matcher
   to find those strings, and thus quickly filter out impossible
   matches. */
static void
kwsmusts (void)
{
  struct dfamust const *dm;
  char const *err;

  if (dfa.musts)
    {
      kwsinit (&kwset);
      /* First, we compile in the substrings known to be exact
	 matches.  The kwset matcher will return the index
	 of the matching string that it chooses. */
      for (dm = dfa.musts; dm; dm = dm->next)
	{
	  if (!dm->exact)
	    continue;
	  ++kwset_exact_matches;
	  if ((err = kwsincr_case (dm->must)) != NULL)
	    error (EXIT_TROUBLE, 0, "%s", err);
	}
      /* Now, we compile the substrings that will require
	 the use of the regexp matcher.  */
      for (dm = dfa.musts; dm; dm = dm->next)
	{
	  if (dm->exact)
	    continue;
	  if ((err = kwsincr_case (dm->must)) != NULL)
	    error (EXIT_TROUBLE, 0, "%s", err);
	}
      if ((err = kwsprep (kwset)) != NULL)
	error (EXIT_TROUBLE, 0, "%s", err);
    }
}

void
GEAcompile (char const *pattern, size_t size, reg_syntax_t syntax_bits)
{
  const char *err;
  const char *p, *sep;
  size_t total = size;
  char *motif;

  if (match_icase)
    syntax_bits |= RE_ICASE;
  re_set_syntax (syntax_bits);
  dfasyntax (syntax_bits, match_icase, eolbyte);

  /* For GNU regex compiler we have to pass the patterns separately to detect
     errors like "[\nallo\n]\n".  The patterns here are "[", "allo" and "]"
     GNU regex should have raise a syntax error.  The same for backref, where
     the backref should have been local to each pattern.  */
  p = pattern;
  do
    {
      size_t len;
      sep = memchr (p, '\n', total);
      if (sep)
	{
	  len = sep - p;
	  sep++;
	  total -= (len + 1);
	}
      else
	{
	  len = total;
	  total = 0;
	}

      patterns = realloc (patterns, (pcount + 1) * sizeof (*patterns));
      if (patterns == NULL)
	error (EXIT_TROUBLE, errno, _("memory exhausted"));
      patterns[pcount] = patterns0;

      if ((err = re_compile_pattern (p, len,
				    &(patterns[pcount].regexbuf))) != NULL)
	error (EXIT_TROUBLE, 0, "%s", err);
      pcount++;

      p = sep;
    } while (sep && total != 0);

  /* In the match_words and match_lines cases, we use a different pattern
     for the DFA matcher that will quickly throw out cases that won't work.
     Then if DFA succeeds we do some hairy stuff using the regex matcher
     to decide whether the match should really count. */
  if (match_words || match_lines)
    {
      static char const line_beg_no_bk[] = "^(";
      static char const line_end_no_bk[] = ")$";
      static char const word_beg_no_bk[] = "(^|[^[:alnum:]_])(";
      static char const word_end_no_bk[] = ")([^[:alnum:]_]|$)";
      static char const line_beg_bk[] = "^\\(";
      static char const line_end_bk[] = "\\)$";
      static char const word_beg_bk[] = "\\(^\\|[^[:alnum:]_]\\)\\(";
      static char const word_end_bk[] = "\\)\\([^[:alnum:]_]\\|$\\)";
      int bk = !(syntax_bits & RE_NO_BK_PARENS);
      char *n = xmalloc (sizeof word_beg_bk - 1 + size + sizeof word_end_bk);

      strcpy (n, match_lines ? (bk ? line_beg_bk : line_beg_no_bk)
			     : (bk ? word_beg_bk : word_beg_no_bk));
      total = strlen(n);
      memcpy (n + total, pattern, size);
      total += size;
      strcpy (n + total, match_lines ? (bk ? line_end_bk : line_end_no_bk)
				     : (bk ? word_end_bk : word_end_no_bk));
      total += strlen (n + total);
      pattern = motif = n;
      size = total;
    }
  else
    motif = NULL;

  dfacomp (pattern, size, &dfa, 1);
  kwsmusts ();

  free(motif);
}

size_t
EGexecute (char const *buf, size_t size, size_t *match_size,
	   char const *start_ptr)
{
  char const *buflim, *beg, *end, *match, *best_match, *mb_start;
  char eol = eolbyte;
  int backref, start, len, best_len;
  struct kwsmatch kwsm;
  size_t i, ret_val;
#ifdef MBS_SUPPORT
  if (MB_CUR_MAX > 1)
    {
      if (match_icase)
        {
          /* mbtolower adds a NUL byte at the end.  That will provide
	     space for the sentinel byte dfaexec may add.  */
          char *case_buf = mbtolower (buf, &size);
	  if (start_ptr)
	    start_ptr = case_buf + (start_ptr - buf);
          buf = case_buf;
        }
    }
#endif /* MBS_SUPPORT */

  mb_start = buf;
  buflim = buf + size;

  for (beg = end = buf; end < buflim; beg = end)
    {
      
//Patch 0:
if ((!start_ptr) && !(__is_neg(25, &(start_ptr), sizeof (start_ptr), &(buf), sizeof (buf), &(buflim), sizeof (buflim), &(beg), sizeof (beg), &(end), sizeof (end), &(kwset), sizeof (kwset), &(size), sizeof (size), &(mb_start), sizeof (mb_start), &(eol), sizeof (eol), &(match), sizeof (match), &(match_icase), sizeof (match_icase), &(kwset_exact_matches), sizeof (kwset_exact_matches), &(eolbyte), sizeof (eolbyte), &(backref), sizeof (backref), &(best_match), sizeof (best_match), &(best_len), sizeof (best_len), &(i), sizeof (i), &(pcount), sizeof (pcount), &(patterns), sizeof (patterns), &(start), sizeof (start), &(len), sizeof (len), &(match_words), sizeof (match_words), &(match_lines), sizeof (match_lines), &(ret_val), sizeof (ret_val), &(match_size), sizeof (match_size)))) {
    if (kwset) {
        size_t offset = kwsexec(kwset, beg, buflim - beg, &kwsm);
        if (offset == (size_t)-1)
            goto failure;
        beg += offset;
        if ((end = memchr(beg, eol, buflim - beg)) != ((void *)0))
            end++;
        else
            end = buflim;
        match = beg;
        while (beg > buf && beg[-1] != eol)
            --beg;
        if (kwsm.index < kwset_exact_matches) {
            if (mb_start < beg)
                mb_start = beg;
            if ((__ctype_get_mb_cur_max()) == 1 || !is_mb_middle(&mb_start, match, buflim))
                goto success;
        }
        if (dfaexec(&dfa, beg, (char *)end, 0, ((void *)0), &backref) == ((void *)0))
            continue;
    } else {
        const char *next_beg = dfaexec(&dfa, beg, (char *)buflim, 0, ((void *)0), &backref);
        if (next_beg == ((void *)0))
            break;
        beg = next_beg;
        if ((end = memchr(beg, eol, buflim - beg)) != ((void *)0))
            end++;
        else
            end = buflim;
        while (beg > buf && beg[-1] != eol)
            --beg;
    }
    if (!backref)
        goto success;
} else {
    beg = start_ptr;
    end = buflim;
}

//CodeSeg 1:

      /* If we've made it to this point, this means DFA has seen
	 a probable match, and we need to run it through Regex. */
      best_match = end;
      best_len = 0;
      for (i = 0; i < pcount; i++)
	{
	  patterns[i].regexbuf.not_eol = 0;
	  if (0 <= (start = re_search (&(patterns[i].regexbuf),
				       buf, end - buf - 1,
				       beg - buf, end - beg - 1,
				       &(patterns[i].regs))))
	    {
	      len = patterns[i].regs.end[0] - start;
	      match = buf + start;
	      if (match > best_match)
		continue;
	      if (start_ptr && !match_words)
		goto assess_pattern_match;
	      if ((!match_lines && !match_words)
		  || (match_lines && len == end - beg - 1))
		{
		  match = beg;
		  len = end - beg;
		  goto assess_pattern_match;
		}
	      /* If -w, check if the match aligns with word boundaries.
		 We do this iteratively because:
		 (a) the line may contain more than one occurence of the
		 pattern, and
		 (b) Several alternatives in the pattern might be valid at a
		 given point, and we may need to consider a shorter one to
		 find a word boundary.  */
	      if (match_words)
		while (match <= best_match)
		  {
		    if ((match == buf || !WCHAR ((unsigned char) match[-1]))
			&& (len == end - beg - 1
			    || !WCHAR ((unsigned char) match[len])))
		      goto assess_pattern_match;
		    if (len > 0)
		      {
			/* Try a shorter length anchored at the same place. */
			--len;
			patterns[i].regexbuf.not_eol = 1;
			len = re_match (&(patterns[i].regexbuf),
					buf, match + len - beg, match - buf,
					&(patterns[i].regs));
		      }
		    if (len <= 0)
		      {
			/* Try looking further on. */
			if (match == end - 1)
			  break;
			match++;
			patterns[i].regexbuf.not_eol = 0;
			start = re_search (&(patterns[i].regexbuf),
					   buf, end - buf - 1,
					   match - buf, end - match - 1,
					   &(patterns[i].regs));
			if (start < 0)
			  break;
			len = patterns[i].regs.end[0] - start;
			match = buf + start;
		      }
		  } /* while (match <= best_match) */
	      continue;
	    assess_pattern_match:
	      if (!start_ptr)
		{
		  /* Good enough for a non-exact match.
		     No need to look at further patterns, if any.  */
		  beg = match;
		  goto success_in_len;
		}
	      if (match < best_match || (match == best_match && len > best_len))
		{
		  /* Best exact match:  leftmost, then longest.  */
		  best_match = match;
		  best_len = len;
		}
	    } /* if re_search >= 0 */
	} /* for Regex patterns.  */
	if (best_match < end)
	  {
	    /* We have found an exact match.  We were just
	       waiting for the best one (leftmost then longest).  */
	    beg = best_match;
	    len = best_len;
	    goto success_in_len;
	  }
    } /* for (beg = end ..) */

 failure:
  ret_val = -1;
  goto out;

 success:
  len = end - beg;
 success_in_len:
  *match_size = len;
  ret_val = beg - buf;
 out:
  return ret_val;
}

Spawn 1 instances, now Total 46
Counter: 47
Batcher Size:46
Preprocess the following candidate with CondTester:
Priority 20000
At location src/dfasearch.c:231
--Src File: src/dfasearch.c
Fragment 0:
if ((!start_ptr) || (__abst_hole(start_ptr, buf, buflim, beg, end, kwset, size, mb_start, eol, match, match_icase, kwset_exact_matches, eolbyte, backref, best_match, best_len, i, pcount, patterns, start, len, match_words, match_lines, ret_val, match_size))) {
    if (kwset) {
        size_t offset = kwsexec(kwset, beg, buflim - beg, &kwsm);
        if (offset == (size_t)-1)
            goto failure;
        beg += offset;
        if ((end = memchr(beg, eol, buflim - beg)) != ((void *)0))
            end++;
        else
            end = buflim;
        match = beg;
        while (beg > buf && beg[-1] != eol)
            --beg;
        if (kwsm.index < kwset_exact_matches) {
            if (mb_start < beg)
                mb_start = beg;
            if ((__ctype_get_mb_cur_max()) == 1 || !is_mb_middle(&mb_start, match, buflim))
                goto success;
        }
        if (dfaexec(&dfa, beg, (char *)end, 0, ((void *)0), &backref) == ((void *)0))
            continue;
    } else {
        const char *next_beg = dfaexec(&dfa, beg, (char *)buflim, 0, ((void *)0), &backref);
        if (next_beg == ((void *)0))
            break;
        beg = next_beg;
        if ((end = memchr(beg, eol, buflim - beg)) != ((void *)0))
            end++;
        else
            end = buflim;
        while (beg > buf && beg[-1] != eol)
            --beg;
    }
    if (!backref)
        goto success;
} else {
    beg = start_ptr;
    end = buflim;
}


CondTester, a patch instance with id 46:
//src_file:src/dfasearch.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); void* memset(void*, int, unsigned long); 
/* dfasearch.c - searching subroutines using dfa and regex for grep.
   Copyright 1992, 1998, 2000, 2007, 2009-2010 Free Software Foundation, Inc.

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 3, or (at your option)
   any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program; if not, write to the Free Software
   Foundation, Inc., 51 Franklin Street - Fifth Floor, Boston, MA
   02110-1301, USA.  */

/* Written August 1992 by Mike Haertel. */

#include <config.h>
#include "search.h"
#include "dfa.h"

/* For -w, we also consider _ to be word constituent.  */
#define WCHAR(C) (ISALNUM(C) || (C) == '_')

/* KWset compiled pattern.  For Ecompile and Gcompile, we compile
   a list of strings, at least one of which is known to occur in
   any string matching the regexp. */
static kwset_t kwset;

/* DFA compiled regexp. */
static struct dfa dfa;

/* The Regex compiled patterns.  */
static struct patterns
{
  /* Regex compiled regexp. */
  struct re_pattern_buffer regexbuf;
  struct re_registers regs; /* This is here on account of a BRAIN-DEAD
			       Q@#%!# library interface in regex.c.  */
} patterns0;

struct patterns *patterns;
size_t pcount;

void
dfaerror (char const *mesg)
{
  error (EXIT_TROUBLE, 0, "%s", mesg);

  /* notreached */
  /* Tell static analyzers that this function does not return.  */
  abort ();
}

/* Number of compiled fixed strings known to exactly match the regexp.
   If kwsexec returns < kwset_exact_matches, then we don't need to
   call the regexp matcher at all. */
static int kwset_exact_matches;

static char const *
kwsincr_case (const char *must)
{
  const char *buf;
  size_t n;

  n = strlen (must);
#ifdef MBS_SUPPORT
  if (match_icase && MB_CUR_MAX > 1)
    buf = mbtolower (must, &n);
  else
#endif
    buf = must;
  return kwsincr (kwset, buf, n);
}

/* If the DFA turns out to have some set of fixed strings one of
   which must occur in the match, then we build a kwset matcher
   to find those strings, and thus quickly filter out impossible
   matches. */
static void
kwsmusts (void)
{
  struct dfamust const *dm;
  char const *err;

  if (dfa.musts)
    {
      kwsinit (&kwset);
      /* First, we compile in the substrings known to be exact
	 matches.  The kwset matcher will return the index
	 of the matching string that it chooses. */
      for (dm = dfa.musts; dm; dm = dm->next)
	{
	  if (!dm->exact)
	    continue;
	  ++kwset_exact_matches;
	  if ((err = kwsincr_case (dm->must)) != NULL)
	    error (EXIT_TROUBLE, 0, "%s", err);
	}
      /* Now, we compile the substrings that will require
	 the use of the regexp matcher.  */
      for (dm = dfa.musts; dm; dm = dm->next)
	{
	  if (dm->exact)
	    continue;
	  if ((err = kwsincr_case (dm->must)) != NULL)
	    error (EXIT_TROUBLE, 0, "%s", err);
	}
      if ((err = kwsprep (kwset)) != NULL)
	error (EXIT_TROUBLE, 0, "%s", err);
    }
}

void
GEAcompile (char const *pattern, size_t size, reg_syntax_t syntax_bits)
{
  const char *err;
  const char *p, *sep;
  size_t total = size;
  char *motif;

  if (match_icase)
    syntax_bits |= RE_ICASE;
  re_set_syntax (syntax_bits);
  dfasyntax (syntax_bits, match_icase, eolbyte);

  /* For GNU regex compiler we have to pass the patterns separately to detect
     errors like "[\nallo\n]\n".  The patterns here are "[", "allo" and "]"
     GNU regex should have raise a syntax error.  The same for backref, where
     the backref should have been local to each pattern.  */
  p = pattern;
  do
    {
      size_t len;
      sep = memchr (p, '\n', total);
      if (sep)
	{
	  len = sep - p;
	  sep++;
	  total -= (len + 1);
	}
      else
	{
	  len = total;
	  total = 0;
	}

      patterns = realloc (patterns, (pcount + 1) * sizeof (*patterns));
      if (patterns == NULL)
	error (EXIT_TROUBLE, errno, _("memory exhausted"));
      patterns[pcount] = patterns0;

      if ((err = re_compile_pattern (p, len,
				    &(patterns[pcount].regexbuf))) != NULL)
	error (EXIT_TROUBLE, 0, "%s", err);
      pcount++;

      p = sep;
    } while (sep && total != 0);

  /* In the match_words and match_lines cases, we use a different pattern
     for the DFA matcher that will quickly throw out cases that won't work.
     Then if DFA succeeds we do some hairy stuff using the regex matcher
     to decide whether the match should really count. */
  if (match_words || match_lines)
    {
      static char const line_beg_no_bk[] = "^(";
      static char const line_end_no_bk[] = ")$";
      static char const word_beg_no_bk[] = "(^|[^[:alnum:]_])(";
      static char const word_end_no_bk[] = ")([^[:alnum:]_]|$)";
      static char const line_beg_bk[] = "^\\(";
      static char const line_end_bk[] = "\\)$";
      static char const word_beg_bk[] = "\\(^\\|[^[:alnum:]_]\\)\\(";
      static char const word_end_bk[] = "\\)\\([^[:alnum:]_]\\|$\\)";
      int bk = !(syntax_bits & RE_NO_BK_PARENS);
      char *n = xmalloc (sizeof word_beg_bk - 1 + size + sizeof word_end_bk);

      strcpy (n, match_lines ? (bk ? line_beg_bk : line_beg_no_bk)
			     : (bk ? word_beg_bk : word_beg_no_bk));
      total = strlen(n);
      memcpy (n + total, pattern, size);
      total += size;
      strcpy (n + total, match_lines ? (bk ? line_end_bk : line_end_no_bk)
				     : (bk ? word_end_bk : word_end_no_bk));
      total += strlen (n + total);
      pattern = motif = n;
      size = total;
    }
  else
    motif = NULL;

  dfacomp (pattern, size, &dfa, 1);
  kwsmusts ();

  free(motif);
}

size_t
EGexecute (char const *buf, size_t size, size_t *match_size,
	   char const *start_ptr)
{
  char const *buflim, *beg, *end, *match, *best_match, *mb_start;
  char eol = eolbyte;
  int backref, start, len, best_len;
  struct kwsmatch kwsm;
  size_t i, ret_val;
#ifdef MBS_SUPPORT
  if (MB_CUR_MAX > 1)
    {
      if (match_icase)
        {
          /* mbtolower adds a NUL byte at the end.  That will provide
	     space for the sentinel byte dfaexec may add.  */
          char *case_buf = mbtolower (buf, &size);
	  if (start_ptr)
	    start_ptr = case_buf + (start_ptr - buf);
          buf = case_buf;
        }
    }
#endif /* MBS_SUPPORT */

  mb_start = buf;
  buflim = buf + size;

  for (beg = end = buf; end < buflim; beg = end)
    {
      
//Patch 0:
if ((!start_ptr) || (__is_neg(25, &(start_ptr), sizeof (start_ptr), &(buf), sizeof (buf), &(buflim), sizeof (buflim), &(beg), sizeof (beg), &(end), sizeof (end), &(kwset), sizeof (kwset), &(size), sizeof (size), &(mb_start), sizeof (mb_start), &(eol), sizeof (eol), &(match), sizeof (match), &(match_icase), sizeof (match_icase), &(kwset_exact_matches), sizeof (kwset_exact_matches), &(eolbyte), sizeof (eolbyte), &(backref), sizeof (backref), &(best_match), sizeof (best_match), &(best_len), sizeof (best_len), &(i), sizeof (i), &(pcount), sizeof (pcount), &(patterns), sizeof (patterns), &(start), sizeof (start), &(len), sizeof (len), &(match_words), sizeof (match_words), &(match_lines), sizeof (match_lines), &(ret_val), sizeof (ret_val), &(match_size), sizeof (match_size)))) {
    if (kwset) {
        size_t offset = kwsexec(kwset, beg, buflim - beg, &kwsm);
        if (offset == (size_t)-1)
            goto failure;
        beg += offset;
        if ((end = memchr(beg, eol, buflim - beg)) != ((void *)0))
            end++;
        else
            end = buflim;
        match = beg;
        while (beg > buf && beg[-1] != eol)
            --beg;
        if (kwsm.index < kwset_exact_matches) {
            if (mb_start < beg)
                mb_start = beg;
            if ((__ctype_get_mb_cur_max()) == 1 || !is_mb_middle(&mb_start, match, buflim))
                goto success;
        }
        if (dfaexec(&dfa, beg, (char *)end, 0, ((void *)0), &backref) == ((void *)0))
            continue;
    } else {
        const char *next_beg = dfaexec(&dfa, beg, (char *)buflim, 0, ((void *)0), &backref);
        if (next_beg == ((void *)0))
            break;
        beg = next_beg;
        if ((end = memchr(beg, eol, buflim - beg)) != ((void *)0))
            end++;
        else
            end = buflim;
        while (beg > buf && beg[-1] != eol)
            --beg;
    }
    if (!backref)
        goto success;
} else {
    beg = start_ptr;
    end = buflim;
}

//CodeSeg 1:

      /* If we've made it to this point, this means DFA has seen
	 a probable match, and we need to run it through Regex. */
      best_match = end;
      best_len = 0;
      for (i = 0; i < pcount; i++)
	{
	  patterns[i].regexbuf.not_eol = 0;
	  if (0 <= (start = re_search (&(patterns[i].regexbuf),
				       buf, end - buf - 1,
				       beg - buf, end - beg - 1,
				       &(patterns[i].regs))))
	    {
	      len = patterns[i].regs.end[0] - start;
	      match = buf + start;
	      if (match > best_match)
		continue;
	      if (start_ptr && !match_words)
		goto assess_pattern_match;
	      if ((!match_lines && !match_words)
		  || (match_lines && len == end - beg - 1))
		{
		  match = beg;
		  len = end - beg;
		  goto assess_pattern_match;
		}
	      /* If -w, check if the match aligns with word boundaries.
		 We do this iteratively because:
		 (a) the line may contain more than one occurence of the
		 pattern, and
		 (b) Several alternatives in the pattern might be valid at a
		 given point, and we may need to consider a shorter one to
		 find a word boundary.  */
	      if (match_words)
		while (match <= best_match)
		  {
		    if ((match == buf || !WCHAR ((unsigned char) match[-1]))
			&& (len == end - beg - 1
			    || !WCHAR ((unsigned char) match[len])))
		      goto assess_pattern_match;
		    if (len > 0)
		      {
			/* Try a shorter length anchored at the same place. */
			--len;
			patterns[i].regexbuf.not_eol = 1;
			len = re_match (&(patterns[i].regexbuf),
					buf, match + len - beg, match - buf,
					&(patterns[i].regs));
		      }
		    if (len <= 0)
		      {
			/* Try looking further on. */
			if (match == end - 1)
			  break;
			match++;
			patterns[i].regexbuf.not_eol = 0;
			start = re_search (&(patterns[i].regexbuf),
					   buf, end - buf - 1,
					   match - buf, end - match - 1,
					   &(patterns[i].regs));
			if (start < 0)
			  break;
			len = patterns[i].regs.end[0] - start;
			match = buf + start;
		      }
		  } /* while (match <= best_match) */
	      continue;
	    assess_pattern_match:
	      if (!start_ptr)
		{
		  /* Good enough for a non-exact match.
		     No need to look at further patterns, if any.  */
		  beg = match;
		  goto success_in_len;
		}
	      if (match < best_match || (match == best_match && len > best_len))
		{
		  /* Best exact match:  leftmost, then longest.  */
		  best_match = match;
		  best_len = len;
		}
	    } /* if re_search >= 0 */
	} /* for Regex patterns.  */
	if (best_match < end)
	  {
	    /* We have found an exact match.  We were just
	       waiting for the best one (leftmost then longest).  */
	    beg = best_match;
	    len = best_len;
	    goto success_in_len;
	  }
    } /* for (beg = end ..) */

 failure:
  ret_val = -1;
  goto out;

 success:
  len = end - beg;
 success_in_len:
  *match_size = len;
  ret_val = beg - buf;
 out:
  return ret_val;
}

Spawn 1 instances, now Total 47
Counter: 48
Batcher Size:47
Preprocess the following candidate with CondTester:
Priority 20000
At location src/dfasearch.c:259
--Src File: src/dfasearch.c
Fragment 0:
if ((dfaexec(&dfa, beg, (char *)end, 0, ((void *)0), &backref) == ((void *)0)) && !(__abst_hole(beg, end, backref, buflim, match, mb_start, kwset_exact_matches, buf, eol, offset, kwset, start_ptr, size, best_match, best_len, i, pcount, patterns, start, len, match_icase, match_words, match_lines, eolbyte, ret_val, match_size, dfa.charclasses, dfa.cindex, dfa.calloc, dfa.tokens, dfa.tindex, dfa.talloc, dfa.depth, dfa.nleaves, dfa.nregexps, dfa.mb_cur_max, dfa.nmultibyte_prop, dfa.multibyte_prop, dfa.mbcsets, dfa.nmbcsets, dfa.mbcsets_alloc, dfa.states, dfa.sindex, dfa.salloc, dfa.follows, dfa.searchflag, dfa.tralloc, dfa.trcount, dfa.trans, dfa.realtrans, dfa.fails, dfa.success, dfa.newlines, dfa.musts)))
    continue;


CondTester, a patch instance with id 47:
//src_file:src/dfasearch.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); void* memset(void*, int, unsigned long); 
/* dfasearch.c - searching subroutines using dfa and regex for grep.
   Copyright 1992, 1998, 2000, 2007, 2009-2010 Free Software Foundation, Inc.

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 3, or (at your option)
   any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program; if not, write to the Free Software
   Foundation, Inc., 51 Franklin Street - Fifth Floor, Boston, MA
   02110-1301, USA.  */

/* Written August 1992 by Mike Haertel. */

#include <config.h>
#include "search.h"
#include "dfa.h"

/* For -w, we also consider _ to be word constituent.  */
#define WCHAR(C) (ISALNUM(C) || (C) == '_')

/* KWset compiled pattern.  For Ecompile and Gcompile, we compile
   a list of strings, at least one of which is known to occur in
   any string matching the regexp. */
static kwset_t kwset;

/* DFA compiled regexp. */
static struct dfa dfa;

/* The Regex compiled patterns.  */
static struct patterns
{
  /* Regex compiled regexp. */
  struct re_pattern_buffer regexbuf;
  struct re_registers regs; /* This is here on account of a BRAIN-DEAD
			       Q@#%!# library interface in regex.c.  */
} patterns0;

struct patterns *patterns;
size_t pcount;

void
dfaerror (char const *mesg)
{
  error (EXIT_TROUBLE, 0, "%s", mesg);

  /* notreached */
  /* Tell static analyzers that this function does not return.  */
  abort ();
}

/* Number of compiled fixed strings known to exactly match the regexp.
   If kwsexec returns < kwset_exact_matches, then we don't need to
   call the regexp matcher at all. */
static int kwset_exact_matches;

static char const *
kwsincr_case (const char *must)
{
  const char *buf;
  size_t n;

  n = strlen (must);
#ifdef MBS_SUPPORT
  if (match_icase && MB_CUR_MAX > 1)
    buf = mbtolower (must, &n);
  else
#endif
    buf = must;
  return kwsincr (kwset, buf, n);
}

/* If the DFA turns out to have some set of fixed strings one of
   which must occur in the match, then we build a kwset matcher
   to find those strings, and thus quickly filter out impossible
   matches. */
static void
kwsmusts (void)
{
  struct dfamust const *dm;
  char const *err;

  if (dfa.musts)
    {
      kwsinit (&kwset);
      /* First, we compile in the substrings known to be exact
	 matches.  The kwset matcher will return the index
	 of the matching string that it chooses. */
      for (dm = dfa.musts; dm; dm = dm->next)
	{
	  if (!dm->exact)
	    continue;
	  ++kwset_exact_matches;
	  if ((err = kwsincr_case (dm->must)) != NULL)
	    error (EXIT_TROUBLE, 0, "%s", err);
	}
      /* Now, we compile the substrings that will require
	 the use of the regexp matcher.  */
      for (dm = dfa.musts; dm; dm = dm->next)
	{
	  if (dm->exact)
	    continue;
	  if ((err = kwsincr_case (dm->must)) != NULL)
	    error (EXIT_TROUBLE, 0, "%s", err);
	}
      if ((err = kwsprep (kwset)) != NULL)
	error (EXIT_TROUBLE, 0, "%s", err);
    }
}

void
GEAcompile (char const *pattern, size_t size, reg_syntax_t syntax_bits)
{
  const char *err;
  const char *p, *sep;
  size_t total = size;
  char *motif;

  if (match_icase)
    syntax_bits |= RE_ICASE;
  re_set_syntax (syntax_bits);
  dfasyntax (syntax_bits, match_icase, eolbyte);

  /* For GNU regex compiler we have to pass the patterns separately to detect
     errors like "[\nallo\n]\n".  The patterns here are "[", "allo" and "]"
     GNU regex should have raise a syntax error.  The same for backref, where
     the backref should have been local to each pattern.  */
  p = pattern;
  do
    {
      size_t len;
      sep = memchr (p, '\n', total);
      if (sep)
	{
	  len = sep - p;
	  sep++;
	  total -= (len + 1);
	}
      else
	{
	  len = total;
	  total = 0;
	}

      patterns = realloc (patterns, (pcount + 1) * sizeof (*patterns));
      if (patterns == NULL)
	error (EXIT_TROUBLE, errno, _("memory exhausted"));
      patterns[pcount] = patterns0;

      if ((err = re_compile_pattern (p, len,
				    &(patterns[pcount].regexbuf))) != NULL)
	error (EXIT_TROUBLE, 0, "%s", err);
      pcount++;

      p = sep;
    } while (sep && total != 0);

  /* In the match_words and match_lines cases, we use a different pattern
     for the DFA matcher that will quickly throw out cases that won't work.
     Then if DFA succeeds we do some hairy stuff using the regex matcher
     to decide whether the match should really count. */
  if (match_words || match_lines)
    {
      static char const line_beg_no_bk[] = "^(";
      static char const line_end_no_bk[] = ")$";
      static char const word_beg_no_bk[] = "(^|[^[:alnum:]_])(";
      static char const word_end_no_bk[] = ")([^[:alnum:]_]|$)";
      static char const line_beg_bk[] = "^\\(";
      static char const line_end_bk[] = "\\)$";
      static char const word_beg_bk[] = "\\(^\\|[^[:alnum:]_]\\)\\(";
      static char const word_end_bk[] = "\\)\\([^[:alnum:]_]\\|$\\)";
      int bk = !(syntax_bits & RE_NO_BK_PARENS);
      char *n = xmalloc (sizeof word_beg_bk - 1 + size + sizeof word_end_bk);

      strcpy (n, match_lines ? (bk ? line_beg_bk : line_beg_no_bk)
			     : (bk ? word_beg_bk : word_beg_no_bk));
      total = strlen(n);
      memcpy (n + total, pattern, size);
      total += size;
      strcpy (n + total, match_lines ? (bk ? line_end_bk : line_end_no_bk)
				     : (bk ? word_end_bk : word_end_no_bk));
      total += strlen (n + total);
      pattern = motif = n;
      size = total;
    }
  else
    motif = NULL;

  dfacomp (pattern, size, &dfa, 1);
  kwsmusts ();

  free(motif);
}

size_t
EGexecute (char const *buf, size_t size, size_t *match_size,
	   char const *start_ptr)
{
  char const *buflim, *beg, *end, *match, *best_match, *mb_start;
  char eol = eolbyte;
  int backref, start, len, best_len;
  struct kwsmatch kwsm;
  size_t i, ret_val;
#ifdef MBS_SUPPORT
  if (MB_CUR_MAX > 1)
    {
      if (match_icase)
        {
          /* mbtolower adds a NUL byte at the end.  That will provide
	     space for the sentinel byte dfaexec may add.  */
          char *case_buf = mbtolower (buf, &size);
	  if (start_ptr)
	    start_ptr = case_buf + (start_ptr - buf);
          buf = case_buf;
        }
    }
#endif /* MBS_SUPPORT */

  mb_start = buf;
  buflim = buf + size;

  for (beg = end = buf; end < buflim; beg = end)
    {
      if (!start_ptr)
	{
	  /* We don't care about an exact match.  */
	  if (kwset)
	    {
	      /* Find a possible match using the KWset matcher. */
	      size_t offset = kwsexec (kwset, beg, buflim - beg, &kwsm);
	      if (offset == (size_t) -1)
		goto failure;
	      beg += offset;
	      /* Narrow down to the line containing the candidate, and
		 run it through DFA. */
	      if ((end = memchr(beg, eol, buflim - beg)) != NULL)
	        end++;
              else
                end = buflim;
	      match = beg;
	      while (beg > buf && beg[-1] != eol)
		--beg;
	      if (kwsm.index < kwset_exact_matches)
                {
#ifdef MBS_SUPPORT
                  if (mb_start < beg)
                    mb_start = beg;
                  if (MB_CUR_MAX == 1 || !is_mb_middle (&mb_start, match, buflim))
#endif
                    goto success;
                }
	      
//Patch 0:
if ((dfaexec(&dfa, beg, (char *)end, 0, ((void *)0), &backref) == ((void *)0)) && !(__is_neg(54, &(beg), sizeof (beg), &(end), sizeof (end), &(backref), sizeof (backref), &(buflim), sizeof (buflim), &(match), sizeof (match), &(mb_start), sizeof (mb_start), &(kwset_exact_matches), sizeof (kwset_exact_matches), &(buf), sizeof (buf), &(eol), sizeof (eol), &(offset), sizeof (offset), &(kwset), sizeof (kwset), &(start_ptr), sizeof (start_ptr), &(size), sizeof (size), &(best_match), sizeof (best_match), &(best_len), sizeof (best_len), &(i), sizeof (i), &(pcount), sizeof (pcount), &(patterns), sizeof (patterns), &(start), sizeof (start), &(len), sizeof (len), &(match_icase), sizeof (match_icase), &(match_words), sizeof (match_words), &(match_lines), sizeof (match_lines), &(eolbyte), sizeof (eolbyte), &(ret_val), sizeof (ret_val), &(match_size), sizeof (match_size), &(dfa.charclasses), sizeof (dfa.charclasses), &(dfa.cindex), sizeof (dfa.cindex), &(dfa.calloc), sizeof (dfa.calloc), &(dfa.tokens), sizeof (dfa.tokens), &(dfa.tindex), sizeof (dfa.tindex), &(dfa.talloc), sizeof (dfa.talloc), &(dfa.depth), sizeof (dfa.depth), &(dfa.nleaves), sizeof (dfa.nleaves), &(dfa.nregexps), sizeof (dfa.nregexps), &(dfa.mb_cur_max), sizeof (dfa.mb_cur_max), &(dfa.nmultibyte_prop), sizeof (dfa.nmultibyte_prop), &(dfa.multibyte_prop), sizeof (dfa.multibyte_prop), &(dfa.mbcsets), sizeof (dfa.mbcsets), &(dfa.nmbcsets), sizeof (dfa.nmbcsets), &(dfa.mbcsets_alloc), sizeof (dfa.mbcsets_alloc), &(dfa.states), sizeof (dfa.states), &(dfa.sindex), sizeof (dfa.sindex), &(dfa.salloc), sizeof (dfa.salloc), &(dfa.follows), sizeof (dfa.follows), &(dfa.searchflag), sizeof (dfa.searchflag), &(dfa.tralloc), sizeof (dfa.tralloc), &(dfa.trcount), sizeof (dfa.trcount), &(dfa.trans), sizeof (dfa.trans), &(dfa.realtrans), sizeof (dfa.realtrans), &(dfa.fails), sizeof (dfa.fails), &(dfa.success), sizeof (dfa.success), &(dfa.newlines), sizeof (dfa.newlines), &(dfa.musts), sizeof (dfa.musts))))
    continue;

//CodeSeg 1:
	    }
	  else
	    {
	      /* No good fixed strings; start with DFA. */
	      char const *next_beg = dfaexec (&dfa, beg, (char *) buflim,
					      0, NULL, &backref);
	      if (next_beg == NULL)
		break;
	      /* Narrow down to the line we've found. */
	      beg = next_beg;
	      if ((end = memchr(beg, eol, buflim - beg)) != NULL)
	        end++;
              else
                end = buflim;
	      while (beg > buf && beg[-1] != eol)
		--beg;
	    }
	  /* Successful, no backreferences encountered! */
	  if (!backref)
	    goto success;
	}
      else
	{
	  /* We are looking for the leftmost (then longest) exact match.
	     We will go through the outer loop only once.  */
	  beg = start_ptr;
	  end = buflim;
	}

      /* If we've made it to this point, this means DFA has seen
	 a probable match, and we need to run it through Regex. */
      best_match = end;
      best_len = 0;
      for (i = 0; i < pcount; i++)
	{
	  patterns[i].regexbuf.not_eol = 0;
	  if (0 <= (start = re_search (&(patterns[i].regexbuf),
				       buf, end - buf - 1,
				       beg - buf, end - beg - 1,
				       &(patterns[i].regs))))
	    {
	      len = patterns[i].regs.end[0] - start;
	      match = buf + start;
	      if (match > best_match)
		continue;
	      if (start_ptr && !match_words)
		goto assess_pattern_match;
	      if ((!match_lines && !match_words)
		  || (match_lines && len == end - beg - 1))
		{
		  match = beg;
		  len = end - beg;
		  goto assess_pattern_match;
		}
	      /* If -w, check if the match aligns with word boundaries.
		 We do this iteratively because:
		 (a) the line may contain more than one occurence of the
		 pattern, and
		 (b) Several alternatives in the pattern might be valid at a
		 given point, and we may need to consider a shorter one to
		 find a word boundary.  */
	      if (match_words)
		while (match <= best_match)
		  {
		    if ((match == buf || !WCHAR ((unsigned char) match[-1]))
			&& (len == end - beg - 1
			    || !WCHAR ((unsigned char) match[len])))
		      goto assess_pattern_match;
		    if (len > 0)
		      {
			/* Try a shorter length anchored at the same place. */
			--len;
			patterns[i].regexbuf.not_eol = 1;
			len = re_match (&(patterns[i].regexbuf),
					buf, match + len - beg, match - buf,
					&(patterns[i].regs));
		      }
		    if (len <= 0)
		      {
			/* Try looking further on. */
			if (match == end - 1)
			  break;
			match++;
			patterns[i].regexbuf.not_eol = 0;
			start = re_search (&(patterns[i].regexbuf),
					   buf, end - buf - 1,
					   match - buf, end - match - 1,
					   &(patterns[i].regs));
			if (start < 0)
			  break;
			len = patterns[i].regs.end[0] - start;
			match = buf + start;
		      }
		  } /* while (match <= best_match) */
	      continue;
	    assess_pattern_match:
	      if (!start_ptr)
		{
		  /* Good enough for a non-exact match.
		     No need to look at further patterns, if any.  */
		  beg = match;
		  goto success_in_len;
		}
	      if (match < best_match || (match == best_match && len > best_len))
		{
		  /* Best exact match:  leftmost, then longest.  */
		  best_match = match;
		  best_len = len;
		}
	    } /* if re_search >= 0 */
	} /* for Regex patterns.  */
	if (best_match < end)
	  {
	    /* We have found an exact match.  We were just
	       waiting for the best one (leftmost then longest).  */
	    beg = best_match;
	    len = best_len;
	    goto success_in_len;
	  }
    } /* for (beg = end ..) */

 failure:
  ret_val = -1;
  goto out;

 success:
  len = end - beg;
 success_in_len:
  *match_size = len;
  ret_val = beg - buf;
 out:
  return ret_val;
}

Spawn 1 instances, now Total 48
Counter: 49
Batcher Size:48
Preprocess the following candidate with CondTester:
Priority 20000
At location src/dfasearch.c:259
--Src File: src/dfasearch.c
Fragment 0:
if ((dfaexec(&dfa, beg, (char *)end, 0, ((void *)0), &backref) == ((void *)0)) || (__abst_hole(beg, end, backref, buflim, match, mb_start, kwset_exact_matches, buf, eol, offset, kwset, start_ptr, size, best_match, best_len, i, pcount, patterns, start, len, match_icase, match_words, match_lines, eolbyte, ret_val, match_size, dfa.charclasses, dfa.cindex, dfa.calloc, dfa.tokens, dfa.tindex, dfa.talloc, dfa.depth, dfa.nleaves, dfa.nregexps, dfa.mb_cur_max, dfa.nmultibyte_prop, dfa.multibyte_prop, dfa.mbcsets, dfa.nmbcsets, dfa.mbcsets_alloc, dfa.states, dfa.sindex, dfa.salloc, dfa.follows, dfa.searchflag, dfa.tralloc, dfa.trcount, dfa.trans, dfa.realtrans, dfa.fails, dfa.success, dfa.newlines, dfa.musts)))
    continue;


CondTester, a patch instance with id 48:
//src_file:src/dfasearch.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); void* memset(void*, int, unsigned long); 
/* dfasearch.c - searching subroutines using dfa and regex for grep.
   Copyright 1992, 1998, 2000, 2007, 2009-2010 Free Software Foundation, Inc.

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 3, or (at your option)
   any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program; if not, write to the Free Software
   Foundation, Inc., 51 Franklin Street - Fifth Floor, Boston, MA
   02110-1301, USA.  */

/* Written August 1992 by Mike Haertel. */

#include <config.h>
#include "search.h"
#include "dfa.h"

/* For -w, we also consider _ to be word constituent.  */
#define WCHAR(C) (ISALNUM(C) || (C) == '_')

/* KWset compiled pattern.  For Ecompile and Gcompile, we compile
   a list of strings, at least one of which is known to occur in
   any string matching the regexp. */
static kwset_t kwset;

/* DFA compiled regexp. */
static struct dfa dfa;

/* The Regex compiled patterns.  */
static struct patterns
{
  /* Regex compiled regexp. */
  struct re_pattern_buffer regexbuf;
  struct re_registers regs; /* This is here on account of a BRAIN-DEAD
			       Q@#%!# library interface in regex.c.  */
} patterns0;

struct patterns *patterns;
size_t pcount;

void
dfaerror (char const *mesg)
{
  error (EXIT_TROUBLE, 0, "%s", mesg);

  /* notreached */
  /* Tell static analyzers that this function does not return.  */
  abort ();
}

/* Number of compiled fixed strings known to exactly match the regexp.
   If kwsexec returns < kwset_exact_matches, then we don't need to
   call the regexp matcher at all. */
static int kwset_exact_matches;

static char const *
kwsincr_case (const char *must)
{
  const char *buf;
  size_t n;

  n = strlen (must);
#ifdef MBS_SUPPORT
  if (match_icase && MB_CUR_MAX > 1)
    buf = mbtolower (must, &n);
  else
#endif
    buf = must;
  return kwsincr (kwset, buf, n);
}

/* If the DFA turns out to have some set of fixed strings one of
   which must occur in the match, then we build a kwset matcher
   to find those strings, and thus quickly filter out impossible
   matches. */
static void
kwsmusts (void)
{
  struct dfamust const *dm;
  char const *err;

  if (dfa.musts)
    {
      kwsinit (&kwset);
      /* First, we compile in the substrings known to be exact
	 matches.  The kwset matcher will return the index
	 of the matching string that it chooses. */
      for (dm = dfa.musts; dm; dm = dm->next)
	{
	  if (!dm->exact)
	    continue;
	  ++kwset_exact_matches;
	  if ((err = kwsincr_case (dm->must)) != NULL)
	    error (EXIT_TROUBLE, 0, "%s", err);
	}
      /* Now, we compile the substrings that will require
	 the use of the regexp matcher.  */
      for (dm = dfa.musts; dm; dm = dm->next)
	{
	  if (dm->exact)
	    continue;
	  if ((err = kwsincr_case (dm->must)) != NULL)
	    error (EXIT_TROUBLE, 0, "%s", err);
	}
      if ((err = kwsprep (kwset)) != NULL)
	error (EXIT_TROUBLE, 0, "%s", err);
    }
}

void
GEAcompile (char const *pattern, size_t size, reg_syntax_t syntax_bits)
{
  const char *err;
  const char *p, *sep;
  size_t total = size;
  char *motif;

  if (match_icase)
    syntax_bits |= RE_ICASE;
  re_set_syntax (syntax_bits);
  dfasyntax (syntax_bits, match_icase, eolbyte);

  /* For GNU regex compiler we have to pass the patterns separately to detect
     errors like "[\nallo\n]\n".  The patterns here are "[", "allo" and "]"
     GNU regex should have raise a syntax error.  The same for backref, where
     the backref should have been local to each pattern.  */
  p = pattern;
  do
    {
      size_t len;
      sep = memchr (p, '\n', total);
      if (sep)
	{
	  len = sep - p;
	  sep++;
	  total -= (len + 1);
	}
      else
	{
	  len = total;
	  total = 0;
	}

      patterns = realloc (patterns, (pcount + 1) * sizeof (*patterns));
      if (patterns == NULL)
	error (EXIT_TROUBLE, errno, _("memory exhausted"));
      patterns[pcount] = patterns0;

      if ((err = re_compile_pattern (p, len,
				    &(patterns[pcount].regexbuf))) != NULL)
	error (EXIT_TROUBLE, 0, "%s", err);
      pcount++;

      p = sep;
    } while (sep && total != 0);

  /* In the match_words and match_lines cases, we use a different pattern
     for the DFA matcher that will quickly throw out cases that won't work.
     Then if DFA succeeds we do some hairy stuff using the regex matcher
     to decide whether the match should really count. */
  if (match_words || match_lines)
    {
      static char const line_beg_no_bk[] = "^(";
      static char const line_end_no_bk[] = ")$";
      static char const word_beg_no_bk[] = "(^|[^[:alnum:]_])(";
      static char const word_end_no_bk[] = ")([^[:alnum:]_]|$)";
      static char const line_beg_bk[] = "^\\(";
      static char const line_end_bk[] = "\\)$";
      static char const word_beg_bk[] = "\\(^\\|[^[:alnum:]_]\\)\\(";
      static char const word_end_bk[] = "\\)\\([^[:alnum:]_]\\|$\\)";
      int bk = !(syntax_bits & RE_NO_BK_PARENS);
      char *n = xmalloc (sizeof word_beg_bk - 1 + size + sizeof word_end_bk);

      strcpy (n, match_lines ? (bk ? line_beg_bk : line_beg_no_bk)
			     : (bk ? word_beg_bk : word_beg_no_bk));
      total = strlen(n);
      memcpy (n + total, pattern, size);
      total += size;
      strcpy (n + total, match_lines ? (bk ? line_end_bk : line_end_no_bk)
				     : (bk ? word_end_bk : word_end_no_bk));
      total += strlen (n + total);
      pattern = motif = n;
      size = total;
    }
  else
    motif = NULL;

  dfacomp (pattern, size, &dfa, 1);
  kwsmusts ();

  free(motif);
}

size_t
EGexecute (char const *buf, size_t size, size_t *match_size,
	   char const *start_ptr)
{
  char const *buflim, *beg, *end, *match, *best_match, *mb_start;
  char eol = eolbyte;
  int backref, start, len, best_len;
  struct kwsmatch kwsm;
  size_t i, ret_val;
#ifdef MBS_SUPPORT
  if (MB_CUR_MAX > 1)
    {
      if (match_icase)
        {
          /* mbtolower adds a NUL byte at the end.  That will provide
	     space for the sentinel byte dfaexec may add.  */
          char *case_buf = mbtolower (buf, &size);
	  if (start_ptr)
	    start_ptr = case_buf + (start_ptr - buf);
          buf = case_buf;
        }
    }
#endif /* MBS_SUPPORT */

  mb_start = buf;
  buflim = buf + size;

  for (beg = end = buf; end < buflim; beg = end)
    {
      if (!start_ptr)
	{
	  /* We don't care about an exact match.  */
	  if (kwset)
	    {
	      /* Find a possible match using the KWset matcher. */
	      size_t offset = kwsexec (kwset, beg, buflim - beg, &kwsm);
	      if (offset == (size_t) -1)
		goto failure;
	      beg += offset;
	      /* Narrow down to the line containing the candidate, and
		 run it through DFA. */
	      if ((end = memchr(beg, eol, buflim - beg)) != NULL)
	        end++;
              else
                end = buflim;
	      match = beg;
	      while (beg > buf && beg[-1] != eol)
		--beg;
	      if (kwsm.index < kwset_exact_matches)
                {
#ifdef MBS_SUPPORT
                  if (mb_start < beg)
                    mb_start = beg;
                  if (MB_CUR_MAX == 1 || !is_mb_middle (&mb_start, match, buflim))
#endif
                    goto success;
                }
	      
//Patch 0:
if ((dfaexec(&dfa, beg, (char *)end, 0, ((void *)0), &backref) == ((void *)0)) || (__is_neg(54, &(beg), sizeof (beg), &(end), sizeof (end), &(backref), sizeof (backref), &(buflim), sizeof (buflim), &(match), sizeof (match), &(mb_start), sizeof (mb_start), &(kwset_exact_matches), sizeof (kwset_exact_matches), &(buf), sizeof (buf), &(eol), sizeof (eol), &(offset), sizeof (offset), &(kwset), sizeof (kwset), &(start_ptr), sizeof (start_ptr), &(size), sizeof (size), &(best_match), sizeof (best_match), &(best_len), sizeof (best_len), &(i), sizeof (i), &(pcount), sizeof (pcount), &(patterns), sizeof (patterns), &(start), sizeof (start), &(len), sizeof (len), &(match_icase), sizeof (match_icase), &(match_words), sizeof (match_words), &(match_lines), sizeof (match_lines), &(eolbyte), sizeof (eolbyte), &(ret_val), sizeof (ret_val), &(match_size), sizeof (match_size), &(dfa.charclasses), sizeof (dfa.charclasses), &(dfa.cindex), sizeof (dfa.cindex), &(dfa.calloc), sizeof (dfa.calloc), &(dfa.tokens), sizeof (dfa.tokens), &(dfa.tindex), sizeof (dfa.tindex), &(dfa.talloc), sizeof (dfa.talloc), &(dfa.depth), sizeof (dfa.depth), &(dfa.nleaves), sizeof (dfa.nleaves), &(dfa.nregexps), sizeof (dfa.nregexps), &(dfa.mb_cur_max), sizeof (dfa.mb_cur_max), &(dfa.nmultibyte_prop), sizeof (dfa.nmultibyte_prop), &(dfa.multibyte_prop), sizeof (dfa.multibyte_prop), &(dfa.mbcsets), sizeof (dfa.mbcsets), &(dfa.nmbcsets), sizeof (dfa.nmbcsets), &(dfa.mbcsets_alloc), sizeof (dfa.mbcsets_alloc), &(dfa.states), sizeof (dfa.states), &(dfa.sindex), sizeof (dfa.sindex), &(dfa.salloc), sizeof (dfa.salloc), &(dfa.follows), sizeof (dfa.follows), &(dfa.searchflag), sizeof (dfa.searchflag), &(dfa.tralloc), sizeof (dfa.tralloc), &(dfa.trcount), sizeof (dfa.trcount), &(dfa.trans), sizeof (dfa.trans), &(dfa.realtrans), sizeof (dfa.realtrans), &(dfa.fails), sizeof (dfa.fails), &(dfa.success), sizeof (dfa.success), &(dfa.newlines), sizeof (dfa.newlines), &(dfa.musts), sizeof (dfa.musts))))
    continue;

//CodeSeg 1:
	    }
	  else
	    {
	      /* No good fixed strings; start with DFA. */
	      char const *next_beg = dfaexec (&dfa, beg, (char *) buflim,
					      0, NULL, &backref);
	      if (next_beg == NULL)
		break;
	      /* Narrow down to the line we've found. */
	      beg = next_beg;
	      if ((end = memchr(beg, eol, buflim - beg)) != NULL)
	        end++;
              else
                end = buflim;
	      while (beg > buf && beg[-1] != eol)
		--beg;
	    }
	  /* Successful, no backreferences encountered! */
	  if (!backref)
	    goto success;
	}
      else
	{
	  /* We are looking for the leftmost (then longest) exact match.
	     We will go through the outer loop only once.  */
	  beg = start_ptr;
	  end = buflim;
	}

      /* If we've made it to this point, this means DFA has seen
	 a probable match, and we need to run it through Regex. */
      best_match = end;
      best_len = 0;
      for (i = 0; i < pcount; i++)
	{
	  patterns[i].regexbuf.not_eol = 0;
	  if (0 <= (start = re_search (&(patterns[i].regexbuf),
				       buf, end - buf - 1,
				       beg - buf, end - beg - 1,
				       &(patterns[i].regs))))
	    {
	      len = patterns[i].regs.end[0] - start;
	      match = buf + start;
	      if (match > best_match)
		continue;
	      if (start_ptr && !match_words)
		goto assess_pattern_match;
	      if ((!match_lines && !match_words)
		  || (match_lines && len == end - beg - 1))
		{
		  match = beg;
		  len = end - beg;
		  goto assess_pattern_match;
		}
	      /* If -w, check if the match aligns with word boundaries.
		 We do this iteratively because:
		 (a) the line may contain more than one occurence of the
		 pattern, and
		 (b) Several alternatives in the pattern might be valid at a
		 given point, and we may need to consider a shorter one to
		 find a word boundary.  */
	      if (match_words)
		while (match <= best_match)
		  {
		    if ((match == buf || !WCHAR ((unsigned char) match[-1]))
			&& (len == end - beg - 1
			    || !WCHAR ((unsigned char) match[len])))
		      goto assess_pattern_match;
		    if (len > 0)
		      {
			/* Try a shorter length anchored at the same place. */
			--len;
			patterns[i].regexbuf.not_eol = 1;
			len = re_match (&(patterns[i].regexbuf),
					buf, match + len - beg, match - buf,
					&(patterns[i].regs));
		      }
		    if (len <= 0)
		      {
			/* Try looking further on. */
			if (match == end - 1)
			  break;
			match++;
			patterns[i].regexbuf.not_eol = 0;
			start = re_search (&(patterns[i].regexbuf),
					   buf, end - buf - 1,
					   match - buf, end - match - 1,
					   &(patterns[i].regs));
			if (start < 0)
			  break;
			len = patterns[i].regs.end[0] - start;
			match = buf + start;
		      }
		  } /* while (match <= best_match) */
	      continue;
	    assess_pattern_match:
	      if (!start_ptr)
		{
		  /* Good enough for a non-exact match.
		     No need to look at further patterns, if any.  */
		  beg = match;
		  goto success_in_len;
		}
	      if (match < best_match || (match == best_match && len > best_len))
		{
		  /* Best exact match:  leftmost, then longest.  */
		  best_match = match;
		  best_len = len;
		}
	    } /* if re_search >= 0 */
	} /* for Regex patterns.  */
	if (best_match < end)
	  {
	    /* We have found an exact match.  We were just
	       waiting for the best one (leftmost then longest).  */
	    beg = best_match;
	    len = best_len;
	    goto success_in_len;
	  }
    } /* for (beg = end ..) */

 failure:
  ret_val = -1;
  goto out;

 success:
  len = end - beg;
 success_in_len:
  *match_size = len;
  ret_val = beg - buf;
 out:
  return ret_val;
}

Spawn 1 instances, now Total 49
Counter: 50
Batcher Size:49
Preprocess the following candidate with CondTester:
Priority 20000
At location src/dfasearch.c:234
--Src File: src/dfasearch.c
Fragment 0:
if ((kwset) && !(__abst_hole(kwset, start_ptr, buflim, beg, buf, end, size, mb_start, eol, match, kwset_exact_matches, match_icase, backref, eolbyte, best_match, best_len, i, pcount, patterns, start, len, match_words, match_lines, ret_val, match_size))) {
    size_t offset = kwsexec(kwset, beg, buflim - beg, &kwsm);
    if (offset == (size_t)-1)
        goto failure;
    beg += offset;
    if ((end = memchr(beg, eol, buflim - beg)) != ((void *)0))
        end++;
    else
        end = buflim;
    match = beg;
    while (beg > buf && beg[-1] != eol)
        --beg;
    if (kwsm.index < kwset_exact_matches) {
        if (mb_start < beg)
            mb_start = beg;
        if ((__ctype_get_mb_cur_max()) == 1 || !is_mb_middle(&mb_start, match, buflim))
            goto success;
    }
    if (dfaexec(&dfa, beg, (char *)end, 0, ((void *)0), &backref) == ((void *)0))
        continue;
} else {
    const char *next_beg = dfaexec(&dfa, beg, (char *)buflim, 0, ((void *)0), &backref);
    if (next_beg == ((void *)0))
        break;
    beg = next_beg;
    if ((end = memchr(beg, eol, buflim - beg)) != ((void *)0))
        end++;
    else
        end = buflim;
    while (beg > buf && beg[-1] != eol)
        --beg;
}


CondTester, a patch instance with id 49:
//src_file:src/dfasearch.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); void* memset(void*, int, unsigned long); 
/* dfasearch.c - searching subroutines using dfa and regex for grep.
   Copyright 1992, 1998, 2000, 2007, 2009-2010 Free Software Foundation, Inc.

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 3, or (at your option)
   any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program; if not, write to the Free Software
   Foundation, Inc., 51 Franklin Street - Fifth Floor, Boston, MA
   02110-1301, USA.  */

/* Written August 1992 by Mike Haertel. */

#include <config.h>
#include "search.h"
#include "dfa.h"

/* For -w, we also consider _ to be word constituent.  */
#define WCHAR(C) (ISALNUM(C) || (C) == '_')

/* KWset compiled pattern.  For Ecompile and Gcompile, we compile
   a list of strings, at least one of which is known to occur in
   any string matching the regexp. */
static kwset_t kwset;

/* DFA compiled regexp. */
static struct dfa dfa;

/* The Regex compiled patterns.  */
static struct patterns
{
  /* Regex compiled regexp. */
  struct re_pattern_buffer regexbuf;
  struct re_registers regs; /* This is here on account of a BRAIN-DEAD
			       Q@#%!# library interface in regex.c.  */
} patterns0;

struct patterns *patterns;
size_t pcount;

void
dfaerror (char const *mesg)
{
  error (EXIT_TROUBLE, 0, "%s", mesg);

  /* notreached */
  /* Tell static analyzers that this function does not return.  */
  abort ();
}

/* Number of compiled fixed strings known to exactly match the regexp.
   If kwsexec returns < kwset_exact_matches, then we don't need to
   call the regexp matcher at all. */
static int kwset_exact_matches;

static char const *
kwsincr_case (const char *must)
{
  const char *buf;
  size_t n;

  n = strlen (must);
#ifdef MBS_SUPPORT
  if (match_icase && MB_CUR_MAX > 1)
    buf = mbtolower (must, &n);
  else
#endif
    buf = must;
  return kwsincr (kwset, buf, n);
}

/* If the DFA turns out to have some set of fixed strings one of
   which must occur in the match, then we build a kwset matcher
   to find those strings, and thus quickly filter out impossible
   matches. */
static void
kwsmusts (void)
{
  struct dfamust const *dm;
  char const *err;

  if (dfa.musts)
    {
      kwsinit (&kwset);
      /* First, we compile in the substrings known to be exact
	 matches.  The kwset matcher will return the index
	 of the matching string that it chooses. */
      for (dm = dfa.musts; dm; dm = dm->next)
	{
	  if (!dm->exact)
	    continue;
	  ++kwset_exact_matches;
	  if ((err = kwsincr_case (dm->must)) != NULL)
	    error (EXIT_TROUBLE, 0, "%s", err);
	}
      /* Now, we compile the substrings that will require
	 the use of the regexp matcher.  */
      for (dm = dfa.musts; dm; dm = dm->next)
	{
	  if (dm->exact)
	    continue;
	  if ((err = kwsincr_case (dm->must)) != NULL)
	    error (EXIT_TROUBLE, 0, "%s", err);
	}
      if ((err = kwsprep (kwset)) != NULL)
	error (EXIT_TROUBLE, 0, "%s", err);
    }
}

void
GEAcompile (char const *pattern, size_t size, reg_syntax_t syntax_bits)
{
  const char *err;
  const char *p, *sep;
  size_t total = size;
  char *motif;

  if (match_icase)
    syntax_bits |= RE_ICASE;
  re_set_syntax (syntax_bits);
  dfasyntax (syntax_bits, match_icase, eolbyte);

  /* For GNU regex compiler we have to pass the patterns separately to detect
     errors like "[\nallo\n]\n".  The patterns here are "[", "allo" and "]"
     GNU regex should have raise a syntax error.  The same for backref, where
     the backref should have been local to each pattern.  */
  p = pattern;
  do
    {
      size_t len;
      sep = memchr (p, '\n', total);
      if (sep)
	{
	  len = sep - p;
	  sep++;
	  total -= (len + 1);
	}
      else
	{
	  len = total;
	  total = 0;
	}

      patterns = realloc (patterns, (pcount + 1) * sizeof (*patterns));
      if (patterns == NULL)
	error (EXIT_TROUBLE, errno, _("memory exhausted"));
      patterns[pcount] = patterns0;

      if ((err = re_compile_pattern (p, len,
				    &(patterns[pcount].regexbuf))) != NULL)
	error (EXIT_TROUBLE, 0, "%s", err);
      pcount++;

      p = sep;
    } while (sep && total != 0);

  /* In the match_words and match_lines cases, we use a different pattern
     for the DFA matcher that will quickly throw out cases that won't work.
     Then if DFA succeeds we do some hairy stuff using the regex matcher
     to decide whether the match should really count. */
  if (match_words || match_lines)
    {
      static char const line_beg_no_bk[] = "^(";
      static char const line_end_no_bk[] = ")$";
      static char const word_beg_no_bk[] = "(^|[^[:alnum:]_])(";
      static char const word_end_no_bk[] = ")([^[:alnum:]_]|$)";
      static char const line_beg_bk[] = "^\\(";
      static char const line_end_bk[] = "\\)$";
      static char const word_beg_bk[] = "\\(^\\|[^[:alnum:]_]\\)\\(";
      static char const word_end_bk[] = "\\)\\([^[:alnum:]_]\\|$\\)";
      int bk = !(syntax_bits & RE_NO_BK_PARENS);
      char *n = xmalloc (sizeof word_beg_bk - 1 + size + sizeof word_end_bk);

      strcpy (n, match_lines ? (bk ? line_beg_bk : line_beg_no_bk)
			     : (bk ? word_beg_bk : word_beg_no_bk));
      total = strlen(n);
      memcpy (n + total, pattern, size);
      total += size;
      strcpy (n + total, match_lines ? (bk ? line_end_bk : line_end_no_bk)
				     : (bk ? word_end_bk : word_end_no_bk));
      total += strlen (n + total);
      pattern = motif = n;
      size = total;
    }
  else
    motif = NULL;

  dfacomp (pattern, size, &dfa, 1);
  kwsmusts ();

  free(motif);
}

size_t
EGexecute (char const *buf, size_t size, size_t *match_size,
	   char const *start_ptr)
{
  char const *buflim, *beg, *end, *match, *best_match, *mb_start;
  char eol = eolbyte;
  int backref, start, len, best_len;
  struct kwsmatch kwsm;
  size_t i, ret_val;
#ifdef MBS_SUPPORT
  if (MB_CUR_MAX > 1)
    {
      if (match_icase)
        {
          /* mbtolower adds a NUL byte at the end.  That will provide
	     space for the sentinel byte dfaexec may add.  */
          char *case_buf = mbtolower (buf, &size);
	  if (start_ptr)
	    start_ptr = case_buf + (start_ptr - buf);
          buf = case_buf;
        }
    }
#endif /* MBS_SUPPORT */

  mb_start = buf;
  buflim = buf + size;

  for (beg = end = buf; end < buflim; beg = end)
    {
      if (!start_ptr)
	{
	  /* We don't care about an exact match.  */
	  
//Patch 0:
if ((kwset) && !(__is_neg(25, &(kwset), sizeof (kwset), &(start_ptr), sizeof (start_ptr), &(buflim), sizeof (buflim), &(beg), sizeof (beg), &(buf), sizeof (buf), &(end), sizeof (end), &(size), sizeof (size), &(mb_start), sizeof (mb_start), &(eol), sizeof (eol), &(match), sizeof (match), &(kwset_exact_matches), sizeof (kwset_exact_matches), &(match_icase), sizeof (match_icase), &(backref), sizeof (backref), &(eolbyte), sizeof (eolbyte), &(best_match), sizeof (best_match), &(best_len), sizeof (best_len), &(i), sizeof (i), &(pcount), sizeof (pcount), &(patterns), sizeof (patterns), &(start), sizeof (start), &(len), sizeof (len), &(match_words), sizeof (match_words), &(match_lines), sizeof (match_lines), &(ret_val), sizeof (ret_val), &(match_size), sizeof (match_size)))) {
    size_t offset = kwsexec(kwset, beg, buflim - beg, &kwsm);
    if (offset == (size_t)-1)
        goto failure;
    beg += offset;
    if ((end = memchr(beg, eol, buflim - beg)) != ((void *)0))
        end++;
    else
        end = buflim;
    match = beg;
    while (beg > buf && beg[-1] != eol)
        --beg;
    if (kwsm.index < kwset_exact_matches) {
        if (mb_start < beg)
            mb_start = beg;
        if ((__ctype_get_mb_cur_max()) == 1 || !is_mb_middle(&mb_start, match, buflim))
            goto success;
    }
    if (dfaexec(&dfa, beg, (char *)end, 0, ((void *)0), &backref) == ((void *)0))
        continue;
} else {
    const char *next_beg = dfaexec(&dfa, beg, (char *)buflim, 0, ((void *)0), &backref);
    if (next_beg == ((void *)0))
        break;
    beg = next_beg;
    if ((end = memchr(beg, eol, buflim - beg)) != ((void *)0))
        end++;
    else
        end = buflim;
    while (beg > buf && beg[-1] != eol)
        --beg;
}

//CodeSeg 1:
	  /* Successful, no backreferences encountered! */
	  if (!backref)
	    goto success;
	}
      else
	{
	  /* We are looking for the leftmost (then longest) exact match.
	     We will go through the outer loop only once.  */
	  beg = start_ptr;
	  end = buflim;
	}

      /* If we've made it to this point, this means DFA has seen
	 a probable match, and we need to run it through Regex. */
      best_match = end;
      best_len = 0;
      for (i = 0; i < pcount; i++)
	{
	  patterns[i].regexbuf.not_eol = 0;
	  if (0 <= (start = re_search (&(patterns[i].regexbuf),
				       buf, end - buf - 1,
				       beg - buf, end - beg - 1,
				       &(patterns[i].regs))))
	    {
	      len = patterns[i].regs.end[0] - start;
	      match = buf + start;
	      if (match > best_match)
		continue;
	      if (start_ptr && !match_words)
		goto assess_pattern_match;
	      if ((!match_lines && !match_words)
		  || (match_lines && len == end - beg - 1))
		{
		  match = beg;
		  len = end - beg;
		  goto assess_pattern_match;
		}
	      /* If -w, check if the match aligns with word boundaries.
		 We do this iteratively because:
		 (a) the line may contain more than one occurence of the
		 pattern, and
		 (b) Several alternatives in the pattern might be valid at a
		 given point, and we may need to consider a shorter one to
		 find a word boundary.  */
	      if (match_words)
		while (match <= best_match)
		  {
		    if ((match == buf || !WCHAR ((unsigned char) match[-1]))
			&& (len == end - beg - 1
			    || !WCHAR ((unsigned char) match[len])))
		      goto assess_pattern_match;
		    if (len > 0)
		      {
			/* Try a shorter length anchored at the same place. */
			--len;
			patterns[i].regexbuf.not_eol = 1;
			len = re_match (&(patterns[i].regexbuf),
					buf, match + len - beg, match - buf,
					&(patterns[i].regs));
		      }
		    if (len <= 0)
		      {
			/* Try looking further on. */
			if (match == end - 1)
			  break;
			match++;
			patterns[i].regexbuf.not_eol = 0;
			start = re_search (&(patterns[i].regexbuf),
					   buf, end - buf - 1,
					   match - buf, end - match - 1,
					   &(patterns[i].regs));
			if (start < 0)
			  break;
			len = patterns[i].regs.end[0] - start;
			match = buf + start;
		      }
		  } /* while (match <= best_match) */
	      continue;
	    assess_pattern_match:
	      if (!start_ptr)
		{
		  /* Good enough for a non-exact match.
		     No need to look at further patterns, if any.  */
		  beg = match;
		  goto success_in_len;
		}
	      if (match < best_match || (match == best_match && len > best_len))
		{
		  /* Best exact match:  leftmost, then longest.  */
		  best_match = match;
		  best_len = len;
		}
	    } /* if re_search >= 0 */
	} /* for Regex patterns.  */
	if (best_match < end)
	  {
	    /* We have found an exact match.  We were just
	       waiting for the best one (leftmost then longest).  */
	    beg = best_match;
	    len = best_len;
	    goto success_in_len;
	  }
    } /* for (beg = end ..) */

 failure:
  ret_val = -1;
  goto out;

 success:
  len = end - beg;
 success_in_len:
  *match_size = len;
  ret_val = beg - buf;
 out:
  return ret_val;
}

Spawn 1 instances, now Total 50
Counter: 51
Batcher Size:50
Preprocess the following candidate with CondTester:
Priority 20000
At location src/dfasearch.c:234
--Src File: src/dfasearch.c
Fragment 0:
if ((kwset) || (__abst_hole(kwset, start_ptr, buflim, beg, buf, end, size, mb_start, eol, match, kwset_exact_matches, match_icase, backref, eolbyte, best_match, best_len, i, pcount, patterns, start, len, match_words, match_lines, ret_val, match_size))) {
    size_t offset = kwsexec(kwset, beg, buflim - beg, &kwsm);
    if (offset == (size_t)-1)
        goto failure;
    beg += offset;
    if ((end = memchr(beg, eol, buflim - beg)) != ((void *)0))
        end++;
    else
        end = buflim;
    match = beg;
    while (beg > buf && beg[-1] != eol)
        --beg;
    if (kwsm.index < kwset_exact_matches) {
        if (mb_start < beg)
            mb_start = beg;
        if ((__ctype_get_mb_cur_max()) == 1 || !is_mb_middle(&mb_start, match, buflim))
            goto success;
    }
    if (dfaexec(&dfa, beg, (char *)end, 0, ((void *)0), &backref) == ((void *)0))
        continue;
} else {
    const char *next_beg = dfaexec(&dfa, beg, (char *)buflim, 0, ((void *)0), &backref);
    if (next_beg == ((void *)0))
        break;
    beg = next_beg;
    if ((end = memchr(beg, eol, buflim - beg)) != ((void *)0))
        end++;
    else
        end = buflim;
    while (beg > buf && beg[-1] != eol)
        --beg;
}


CondTester, a patch instance with id 50:
//src_file:src/dfasearch.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); void* memset(void*, int, unsigned long); 
/* dfasearch.c - searching subroutines using dfa and regex for grep.
   Copyright 1992, 1998, 2000, 2007, 2009-2010 Free Software Foundation, Inc.

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 3, or (at your option)
   any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program; if not, write to the Free Software
   Foundation, Inc., 51 Franklin Street - Fifth Floor, Boston, MA
   02110-1301, USA.  */

/* Written August 1992 by Mike Haertel. */

#include <config.h>
#include "search.h"
#include "dfa.h"

/* For -w, we also consider _ to be word constituent.  */
#define WCHAR(C) (ISALNUM(C) || (C) == '_')

/* KWset compiled pattern.  For Ecompile and Gcompile, we compile
   a list of strings, at least one of which is known to occur in
   any string matching the regexp. */
static kwset_t kwset;

/* DFA compiled regexp. */
static struct dfa dfa;

/* The Regex compiled patterns.  */
static struct patterns
{
  /* Regex compiled regexp. */
  struct re_pattern_buffer regexbuf;
  struct re_registers regs; /* This is here on account of a BRAIN-DEAD
			       Q@#%!# library interface in regex.c.  */
} patterns0;

struct patterns *patterns;
size_t pcount;

void
dfaerror (char const *mesg)
{
  error (EXIT_TROUBLE, 0, "%s", mesg);

  /* notreached */
  /* Tell static analyzers that this function does not return.  */
  abort ();
}

/* Number of compiled fixed strings known to exactly match the regexp.
   If kwsexec returns < kwset_exact_matches, then we don't need to
   call the regexp matcher at all. */
static int kwset_exact_matches;

static char const *
kwsincr_case (const char *must)
{
  const char *buf;
  size_t n;

  n = strlen (must);
#ifdef MBS_SUPPORT
  if (match_icase && MB_CUR_MAX > 1)
    buf = mbtolower (must, &n);
  else
#endif
    buf = must;
  return kwsincr (kwset, buf, n);
}

/* If the DFA turns out to have some set of fixed strings one of
   which must occur in the match, then we build a kwset matcher
   to find those strings, and thus quickly filter out impossible
   matches. */
static void
kwsmusts (void)
{
  struct dfamust const *dm;
  char const *err;

  if (dfa.musts)
    {
      kwsinit (&kwset);
      /* First, we compile in the substrings known to be exact
	 matches.  The kwset matcher will return the index
	 of the matching string that it chooses. */
      for (dm = dfa.musts; dm; dm = dm->next)
	{
	  if (!dm->exact)
	    continue;
	  ++kwset_exact_matches;
	  if ((err = kwsincr_case (dm->must)) != NULL)
	    error (EXIT_TROUBLE, 0, "%s", err);
	}
      /* Now, we compile the substrings that will require
	 the use of the regexp matcher.  */
      for (dm = dfa.musts; dm; dm = dm->next)
	{
	  if (dm->exact)
	    continue;
	  if ((err = kwsincr_case (dm->must)) != NULL)
	    error (EXIT_TROUBLE, 0, "%s", err);
	}
      if ((err = kwsprep (kwset)) != NULL)
	error (EXIT_TROUBLE, 0, "%s", err);
    }
}

void
GEAcompile (char const *pattern, size_t size, reg_syntax_t syntax_bits)
{
  const char *err;
  const char *p, *sep;
  size_t total = size;
  char *motif;

  if (match_icase)
    syntax_bits |= RE_ICASE;
  re_set_syntax (syntax_bits);
  dfasyntax (syntax_bits, match_icase, eolbyte);

  /* For GNU regex compiler we have to pass the patterns separately to detect
     errors like "[\nallo\n]\n".  The patterns here are "[", "allo" and "]"
     GNU regex should have raise a syntax error.  The same for backref, where
     the backref should have been local to each pattern.  */
  p = pattern;
  do
    {
      size_t len;
      sep = memchr (p, '\n', total);
      if (sep)
	{
	  len = sep - p;
	  sep++;
	  total -= (len + 1);
	}
      else
	{
	  len = total;
	  total = 0;
	}

      patterns = realloc (patterns, (pcount + 1) * sizeof (*patterns));
      if (patterns == NULL)
	error (EXIT_TROUBLE, errno, _("memory exhausted"));
      patterns[pcount] = patterns0;

      if ((err = re_compile_pattern (p, len,
				    &(patterns[pcount].regexbuf))) != NULL)
	error (EXIT_TROUBLE, 0, "%s", err);
      pcount++;

      p = sep;
    } while (sep && total != 0);

  /* In the match_words and match_lines cases, we use a different pattern
     for the DFA matcher that will quickly throw out cases that won't work.
     Then if DFA succeeds we do some hairy stuff using the regex matcher
     to decide whether the match should really count. */
  if (match_words || match_lines)
    {
      static char const line_beg_no_bk[] = "^(";
      static char const line_end_no_bk[] = ")$";
      static char const word_beg_no_bk[] = "(^|[^[:alnum:]_])(";
      static char const word_end_no_bk[] = ")([^[:alnum:]_]|$)";
      static char const line_beg_bk[] = "^\\(";
      static char const line_end_bk[] = "\\)$";
      static char const word_beg_bk[] = "\\(^\\|[^[:alnum:]_]\\)\\(";
      static char const word_end_bk[] = "\\)\\([^[:alnum:]_]\\|$\\)";
      int bk = !(syntax_bits & RE_NO_BK_PARENS);
      char *n = xmalloc (sizeof word_beg_bk - 1 + size + sizeof word_end_bk);

      strcpy (n, match_lines ? (bk ? line_beg_bk : line_beg_no_bk)
			     : (bk ? word_beg_bk : word_beg_no_bk));
      total = strlen(n);
      memcpy (n + total, pattern, size);
      total += size;
      strcpy (n + total, match_lines ? (bk ? line_end_bk : line_end_no_bk)
				     : (bk ? word_end_bk : word_end_no_bk));
      total += strlen (n + total);
      pattern = motif = n;
      size = total;
    }
  else
    motif = NULL;

  dfacomp (pattern, size, &dfa, 1);
  kwsmusts ();

  free(motif);
}

size_t
EGexecute (char const *buf, size_t size, size_t *match_size,
	   char const *start_ptr)
{
  char const *buflim, *beg, *end, *match, *best_match, *mb_start;
  char eol = eolbyte;
  int backref, start, len, best_len;
  struct kwsmatch kwsm;
  size_t i, ret_val;
#ifdef MBS_SUPPORT
  if (MB_CUR_MAX > 1)
    {
      if (match_icase)
        {
          /* mbtolower adds a NUL byte at the end.  That will provide
	     space for the sentinel byte dfaexec may add.  */
          char *case_buf = mbtolower (buf, &size);
	  if (start_ptr)
	    start_ptr = case_buf + (start_ptr - buf);
          buf = case_buf;
        }
    }
#endif /* MBS_SUPPORT */

  mb_start = buf;
  buflim = buf + size;

  for (beg = end = buf; end < buflim; beg = end)
    {
      if (!start_ptr)
	{
	  /* We don't care about an exact match.  */
	  
//Patch 0:
if ((kwset) || (__is_neg(25, &(kwset), sizeof (kwset), &(start_ptr), sizeof (start_ptr), &(buflim), sizeof (buflim), &(beg), sizeof (beg), &(buf), sizeof (buf), &(end), sizeof (end), &(size), sizeof (size), &(mb_start), sizeof (mb_start), &(eol), sizeof (eol), &(match), sizeof (match), &(kwset_exact_matches), sizeof (kwset_exact_matches), &(match_icase), sizeof (match_icase), &(backref), sizeof (backref), &(eolbyte), sizeof (eolbyte), &(best_match), sizeof (best_match), &(best_len), sizeof (best_len), &(i), sizeof (i), &(pcount), sizeof (pcount), &(patterns), sizeof (patterns), &(start), sizeof (start), &(len), sizeof (len), &(match_words), sizeof (match_words), &(match_lines), sizeof (match_lines), &(ret_val), sizeof (ret_val), &(match_size), sizeof (match_size)))) {
    size_t offset = kwsexec(kwset, beg, buflim - beg, &kwsm);
    if (offset == (size_t)-1)
        goto failure;
    beg += offset;
    if ((end = memchr(beg, eol, buflim - beg)) != ((void *)0))
        end++;
    else
        end = buflim;
    match = beg;
    while (beg > buf && beg[-1] != eol)
        --beg;
    if (kwsm.index < kwset_exact_matches) {
        if (mb_start < beg)
            mb_start = beg;
        if ((__ctype_get_mb_cur_max()) == 1 || !is_mb_middle(&mb_start, match, buflim))
            goto success;
    }
    if (dfaexec(&dfa, beg, (char *)end, 0, ((void *)0), &backref) == ((void *)0))
        continue;
} else {
    const char *next_beg = dfaexec(&dfa, beg, (char *)buflim, 0, ((void *)0), &backref);
    if (next_beg == ((void *)0))
        break;
    beg = next_beg;
    if ((end = memchr(beg, eol, buflim - beg)) != ((void *)0))
        end++;
    else
        end = buflim;
    while (beg > buf && beg[-1] != eol)
        --beg;
}

//CodeSeg 1:
	  /* Successful, no backreferences encountered! */
	  if (!backref)
	    goto success;
	}
      else
	{
	  /* We are looking for the leftmost (then longest) exact match.
	     We will go through the outer loop only once.  */
	  beg = start_ptr;
	  end = buflim;
	}

      /* If we've made it to this point, this means DFA has seen
	 a probable match, and we need to run it through Regex. */
      best_match = end;
      best_len = 0;
      for (i = 0; i < pcount; i++)
	{
	  patterns[i].regexbuf.not_eol = 0;
	  if (0 <= (start = re_search (&(patterns[i].regexbuf),
				       buf, end - buf - 1,
				       beg - buf, end - beg - 1,
				       &(patterns[i].regs))))
	    {
	      len = patterns[i].regs.end[0] - start;
	      match = buf + start;
	      if (match > best_match)
		continue;
	      if (start_ptr && !match_words)
		goto assess_pattern_match;
	      if ((!match_lines && !match_words)
		  || (match_lines && len == end - beg - 1))
		{
		  match = beg;
		  len = end - beg;
		  goto assess_pattern_match;
		}
	      /* If -w, check if the match aligns with word boundaries.
		 We do this iteratively because:
		 (a) the line may contain more than one occurence of the
		 pattern, and
		 (b) Several alternatives in the pattern might be valid at a
		 given point, and we may need to consider a shorter one to
		 find a word boundary.  */
	      if (match_words)
		while (match <= best_match)
		  {
		    if ((match == buf || !WCHAR ((unsigned char) match[-1]))
			&& (len == end - beg - 1
			    || !WCHAR ((unsigned char) match[len])))
		      goto assess_pattern_match;
		    if (len > 0)
		      {
			/* Try a shorter length anchored at the same place. */
			--len;
			patterns[i].regexbuf.not_eol = 1;
			len = re_match (&(patterns[i].regexbuf),
					buf, match + len - beg, match - buf,
					&(patterns[i].regs));
		      }
		    if (len <= 0)
		      {
			/* Try looking further on. */
			if (match == end - 1)
			  break;
			match++;
			patterns[i].regexbuf.not_eol = 0;
			start = re_search (&(patterns[i].regexbuf),
					   buf, end - buf - 1,
					   match - buf, end - match - 1,
					   &(patterns[i].regs));
			if (start < 0)
			  break;
			len = patterns[i].regs.end[0] - start;
			match = buf + start;
		      }
		  } /* while (match <= best_match) */
	      continue;
	    assess_pattern_match:
	      if (!start_ptr)
		{
		  /* Good enough for a non-exact match.
		     No need to look at further patterns, if any.  */
		  beg = match;
		  goto success_in_len;
		}
	      if (match < best_match || (match == best_match && len > best_len))
		{
		  /* Best exact match:  leftmost, then longest.  */
		  best_match = match;
		  best_len = len;
		}
	    } /* if re_search >= 0 */
	} /* for Regex patterns.  */
	if (best_match < end)
	  {
	    /* We have found an exact match.  We were just
	       waiting for the best one (leftmost then longest).  */
	    beg = best_match;
	    len = best_len;
	    goto success_in_len;
	  }
    } /* for (beg = end ..) */

 failure:
  ret_val = -1;
  goto out;

 success:
  len = end - beg;
 success_in_len:
  *match_size = len;
  ret_val = beg - buf;
 out:
  return ret_val;
}

Spawn 1 instances, now Total 51
Counter: 52
Batcher Size:51
Preprocess the following candidate with CondTester:
Priority 20000
At location src/dfasearch.c:98
--Src File: src/dfasearch.c
Fragment 0:
if ((!dm->exact) || (__abst_hole(dm, dm->exact, kwset_exact_matches, dm->next, err, dm->must, kwset)))
    continue;


CondTester, a patch instance with id 51:
//src_file:src/dfasearch.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); void* memset(void*, int, unsigned long); 
/* dfasearch.c - searching subroutines using dfa and regex for grep.
   Copyright 1992, 1998, 2000, 2007, 2009-2010 Free Software Foundation, Inc.

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 3, or (at your option)
   any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program; if not, write to the Free Software
   Foundation, Inc., 51 Franklin Street - Fifth Floor, Boston, MA
   02110-1301, USA.  */

/* Written August 1992 by Mike Haertel. */

#include <config.h>
#include "search.h"
#include "dfa.h"

/* For -w, we also consider _ to be word constituent.  */
#define WCHAR(C) (ISALNUM(C) || (C) == '_')

/* KWset compiled pattern.  For Ecompile and Gcompile, we compile
   a list of strings, at least one of which is known to occur in
   any string matching the regexp. */
static kwset_t kwset;

/* DFA compiled regexp. */
static struct dfa dfa;

/* The Regex compiled patterns.  */
static struct patterns
{
  /* Regex compiled regexp. */
  struct re_pattern_buffer regexbuf;
  struct re_registers regs; /* This is here on account of a BRAIN-DEAD
			       Q@#%!# library interface in regex.c.  */
} patterns0;

struct patterns *patterns;
size_t pcount;

void
dfaerror (char const *mesg)
{
  error (EXIT_TROUBLE, 0, "%s", mesg);

  /* notreached */
  /* Tell static analyzers that this function does not return.  */
  abort ();
}

/* Number of compiled fixed strings known to exactly match the regexp.
   If kwsexec returns < kwset_exact_matches, then we don't need to
   call the regexp matcher at all. */
static int kwset_exact_matches;

static char const *
kwsincr_case (const char *must)
{
  const char *buf;
  size_t n;

  n = strlen (must);
#ifdef MBS_SUPPORT
  if (match_icase && MB_CUR_MAX > 1)
    buf = mbtolower (must, &n);
  else
#endif
    buf = must;
  return kwsincr (kwset, buf, n);
}

/* If the DFA turns out to have some set of fixed strings one of
   which must occur in the match, then we build a kwset matcher
   to find those strings, and thus quickly filter out impossible
   matches. */
static void
kwsmusts (void)
{
  struct dfamust const *dm;
  char const *err;

  if (dfa.musts)
    {
      kwsinit (&kwset);
      /* First, we compile in the substrings known to be exact
	 matches.  The kwset matcher will return the index
	 of the matching string that it chooses. */
      for (dm = dfa.musts; dm; dm = dm->next)
	{
	  
//Patch 0:
if ((!dm->exact) || (__is_neg(7, &(dm), sizeof (dm), &(dm->exact), sizeof (dm->exact), &(kwset_exact_matches), sizeof (kwset_exact_matches), &(dm->next), sizeof (dm->next), &(err), sizeof (err), &(dm->must), sizeof (dm->must), &(kwset), sizeof (kwset))))
    continue;

//CodeSeg 1:
	  ++kwset_exact_matches;
	  if ((err = kwsincr_case (dm->must)) != NULL)
	    error (EXIT_TROUBLE, 0, "%s", err);
	}
      /* Now, we compile the substrings that will require
	 the use of the regexp matcher.  */
      for (dm = dfa.musts; dm; dm = dm->next)
	{
	  if (dm->exact)
	    continue;
	  if ((err = kwsincr_case (dm->must)) != NULL)
	    error (EXIT_TROUBLE, 0, "%s", err);
	}
      if ((err = kwsprep (kwset)) != NULL)
	error (EXIT_TROUBLE, 0, "%s", err);
    }
}

void
GEAcompile (char const *pattern, size_t size, reg_syntax_t syntax_bits)
{
  const char *err;
  const char *p, *sep;
  size_t total = size;
  char *motif;

  if (match_icase)
    syntax_bits |= RE_ICASE;
  re_set_syntax (syntax_bits);
  dfasyntax (syntax_bits, match_icase, eolbyte);

  /* For GNU regex compiler we have to pass the patterns separately to detect
     errors like "[\nallo\n]\n".  The patterns here are "[", "allo" and "]"
     GNU regex should have raise a syntax error.  The same for backref, where
     the backref should have been local to each pattern.  */
  p = pattern;
  do
    {
      size_t len;
      sep = memchr (p, '\n', total);
      if (sep)
	{
	  len = sep - p;
	  sep++;
	  total -= (len + 1);
	}
      else
	{
	  len = total;
	  total = 0;
	}

      patterns = realloc (patterns, (pcount + 1) * sizeof (*patterns));
      if (patterns == NULL)
	error (EXIT_TROUBLE, errno, _("memory exhausted"));
      patterns[pcount] = patterns0;

      if ((err = re_compile_pattern (p, len,
				    &(patterns[pcount].regexbuf))) != NULL)
	error (EXIT_TROUBLE, 0, "%s", err);
      pcount++;

      p = sep;
    } while (sep && total != 0);

  /* In the match_words and match_lines cases, we use a different pattern
     for the DFA matcher that will quickly throw out cases that won't work.
     Then if DFA succeeds we do some hairy stuff using the regex matcher
     to decide whether the match should really count. */
  if (match_words || match_lines)
    {
      static char const line_beg_no_bk[] = "^(";
      static char const line_end_no_bk[] = ")$";
      static char const word_beg_no_bk[] = "(^|[^[:alnum:]_])(";
      static char const word_end_no_bk[] = ")([^[:alnum:]_]|$)";
      static char const line_beg_bk[] = "^\\(";
      static char const line_end_bk[] = "\\)$";
      static char const word_beg_bk[] = "\\(^\\|[^[:alnum:]_]\\)\\(";
      static char const word_end_bk[] = "\\)\\([^[:alnum:]_]\\|$\\)";
      int bk = !(syntax_bits & RE_NO_BK_PARENS);
      char *n = xmalloc (sizeof word_beg_bk - 1 + size + sizeof word_end_bk);

      strcpy (n, match_lines ? (bk ? line_beg_bk : line_beg_no_bk)
			     : (bk ? word_beg_bk : word_beg_no_bk));
      total = strlen(n);
      memcpy (n + total, pattern, size);
      total += size;
      strcpy (n + total, match_lines ? (bk ? line_end_bk : line_end_no_bk)
				     : (bk ? word_end_bk : word_end_no_bk));
      total += strlen (n + total);
      pattern = motif = n;
      size = total;
    }
  else
    motif = NULL;

  dfacomp (pattern, size, &dfa, 1);
  kwsmusts ();

  free(motif);
}

size_t
EGexecute (char const *buf, size_t size, size_t *match_size,
	   char const *start_ptr)
{
  char const *buflim, *beg, *end, *match, *best_match, *mb_start;
  char eol = eolbyte;
  int backref, start, len, best_len;
  struct kwsmatch kwsm;
  size_t i, ret_val;
#ifdef MBS_SUPPORT
  if (MB_CUR_MAX > 1)
    {
      if (match_icase)
        {
          /* mbtolower adds a NUL byte at the end.  That will provide
	     space for the sentinel byte dfaexec may add.  */
          char *case_buf = mbtolower (buf, &size);
	  if (start_ptr)
	    start_ptr = case_buf + (start_ptr - buf);
          buf = case_buf;
        }
    }
#endif /* MBS_SUPPORT */

  mb_start = buf;
  buflim = buf + size;

  for (beg = end = buf; end < buflim; beg = end)
    {
      if (!start_ptr)
	{
	  /* We don't care about an exact match.  */
	  if (kwset)
	    {
	      /* Find a possible match using the KWset matcher. */
	      size_t offset = kwsexec (kwset, beg, buflim - beg, &kwsm);
	      if (offset == (size_t) -1)
		goto failure;
	      beg += offset;
	      /* Narrow down to the line containing the candidate, and
		 run it through DFA. */
	      if ((end = memchr(beg, eol, buflim - beg)) != NULL)
	        end++;
              else
                end = buflim;
	      match = beg;
	      while (beg > buf && beg[-1] != eol)
		--beg;
	      if (kwsm.index < kwset_exact_matches)
                {
#ifdef MBS_SUPPORT
                  if (mb_start < beg)
                    mb_start = beg;
                  if (MB_CUR_MAX == 1 || !is_mb_middle (&mb_start, match, buflim))
#endif
                    goto success;
                }
	      if (dfaexec (&dfa, beg, (char *) end, 0, NULL, &backref) == NULL)
		continue;
	    }
	  else
	    {
	      /* No good fixed strings; start with DFA. */
	      char const *next_beg = dfaexec (&dfa, beg, (char *) buflim,
					      0, NULL, &backref);
	      if (next_beg == NULL)
		break;
	      /* Narrow down to the line we've found. */
	      beg = next_beg;
	      if ((end = memchr(beg, eol, buflim - beg)) != NULL)
	        end++;
              else
                end = buflim;
	      while (beg > buf && beg[-1] != eol)
		--beg;
	    }
	  /* Successful, no backreferences encountered! */
	  if (!backref)
	    goto success;
	}
      else
	{
	  /* We are looking for the leftmost (then longest) exact match.
	     We will go through the outer loop only once.  */
	  beg = start_ptr;
	  end = buflim;
	}

      /* If we've made it to this point, this means DFA has seen
	 a probable match, and we need to run it through Regex. */
      best_match = end;
      best_len = 0;
      for (i = 0; i < pcount; i++)
	{
	  patterns[i].regexbuf.not_eol = 0;
	  if (0 <= (start = re_search (&(patterns[i].regexbuf),
				       buf, end - buf - 1,
				       beg - buf, end - beg - 1,
				       &(patterns[i].regs))))
	    {
	      len = patterns[i].regs.end[0] - start;
	      match = buf + start;
	      if (match > best_match)
		continue;
	      if (start_ptr && !match_words)
		goto assess_pattern_match;
	      if ((!match_lines && !match_words)
		  || (match_lines && len == end - beg - 1))
		{
		  match = beg;
		  len = end - beg;
		  goto assess_pattern_match;
		}
	      /* If -w, check if the match aligns with word boundaries.
		 We do this iteratively because:
		 (a) the line may contain more than one occurence of the
		 pattern, and
		 (b) Several alternatives in the pattern might be valid at a
		 given point, and we may need to consider a shorter one to
		 find a word boundary.  */
	      if (match_words)
		while (match <= best_match)
		  {
		    if ((match == buf || !WCHAR ((unsigned char) match[-1]))
			&& (len == end - beg - 1
			    || !WCHAR ((unsigned char) match[len])))
		      goto assess_pattern_match;
		    if (len > 0)
		      {
			/* Try a shorter length anchored at the same place. */
			--len;
			patterns[i].regexbuf.not_eol = 1;
			len = re_match (&(patterns[i].regexbuf),
					buf, match + len - beg, match - buf,
					&(patterns[i].regs));
		      }
		    if (len <= 0)
		      {
			/* Try looking further on. */
			if (match == end - 1)
			  break;
			match++;
			patterns[i].regexbuf.not_eol = 0;
			start = re_search (&(patterns[i].regexbuf),
					   buf, end - buf - 1,
					   match - buf, end - match - 1,
					   &(patterns[i].regs));
			if (start < 0)
			  break;
			len = patterns[i].regs.end[0] - start;
			match = buf + start;
		      }
		  } /* while (match <= best_match) */
	      continue;
	    assess_pattern_match:
	      if (!start_ptr)
		{
		  /* Good enough for a non-exact match.
		     No need to look at further patterns, if any.  */
		  beg = match;
		  goto success_in_len;
		}
	      if (match < best_match || (match == best_match && len > best_len))
		{
		  /* Best exact match:  leftmost, then longest.  */
		  best_match = match;
		  best_len = len;
		}
	    } /* if re_search >= 0 */
	} /* for Regex patterns.  */
	if (best_match < end)
	  {
	    /* We have found an exact match.  We were just
	       waiting for the best one (leftmost then longest).  */
	    beg = best_match;
	    len = best_len;
	    goto success_in_len;
	  }
    } /* for (beg = end ..) */

 failure:
  ret_val = -1;
  goto out;

 success:
  len = end - beg;
 success_in_len:
  *match_size = len;
  ret_val = beg - buf;
 out:
  return ret_val;
}

Spawn 1 instances, now Total 52
Counter: 53
Batcher Size:52
Preprocess the following candidate with CondTester:
Priority 20000
At location src/dfasearch.c:250
--Src File: src/dfasearch.c
Fragment 0:
if ((kwsm.index < kwset_exact_matches) && !(__abst_hole(kwset_exact_matches, kwsm.index, beg, buf, eol, match, mb_start, buflim, end, backref, offset, kwset, start_ptr, size, match_icase, best_match, best_len, eolbyte, i, pcount, patterns, start, len, match_words, match_lines, ret_val, match_size))) {
    if (mb_start < beg)
        mb_start = beg;
    if ((__ctype_get_mb_cur_max()) == 1 || !is_mb_middle(&mb_start, match, buflim))
        goto success;
}


CondTester, a patch instance with id 52:
//src_file:src/dfasearch.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); void* memset(void*, int, unsigned long); 
/* dfasearch.c - searching subroutines using dfa and regex for grep.
   Copyright 1992, 1998, 2000, 2007, 2009-2010 Free Software Foundation, Inc.

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 3, or (at your option)
   any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program; if not, write to the Free Software
   Foundation, Inc., 51 Franklin Street - Fifth Floor, Boston, MA
   02110-1301, USA.  */

/* Written August 1992 by Mike Haertel. */

#include <config.h>
#include "search.h"
#include "dfa.h"

/* For -w, we also consider _ to be word constituent.  */
#define WCHAR(C) (ISALNUM(C) || (C) == '_')

/* KWset compiled pattern.  For Ecompile and Gcompile, we compile
   a list of strings, at least one of which is known to occur in
   any string matching the regexp. */
static kwset_t kwset;

/* DFA compiled regexp. */
static struct dfa dfa;

/* The Regex compiled patterns.  */
static struct patterns
{
  /* Regex compiled regexp. */
  struct re_pattern_buffer regexbuf;
  struct re_registers regs; /* This is here on account of a BRAIN-DEAD
			       Q@#%!# library interface in regex.c.  */
} patterns0;

struct patterns *patterns;
size_t pcount;

void
dfaerror (char const *mesg)
{
  error (EXIT_TROUBLE, 0, "%s", mesg);

  /* notreached */
  /* Tell static analyzers that this function does not return.  */
  abort ();
}

/* Number of compiled fixed strings known to exactly match the regexp.
   If kwsexec returns < kwset_exact_matches, then we don't need to
   call the regexp matcher at all. */
static int kwset_exact_matches;

static char const *
kwsincr_case (const char *must)
{
  const char *buf;
  size_t n;

  n = strlen (must);
#ifdef MBS_SUPPORT
  if (match_icase && MB_CUR_MAX > 1)
    buf = mbtolower (must, &n);
  else
#endif
    buf = must;
  return kwsincr (kwset, buf, n);
}

/* If the DFA turns out to have some set of fixed strings one of
   which must occur in the match, then we build a kwset matcher
   to find those strings, and thus quickly filter out impossible
   matches. */
static void
kwsmusts (void)
{
  struct dfamust const *dm;
  char const *err;

  if (dfa.musts)
    {
      kwsinit (&kwset);
      /* First, we compile in the substrings known to be exact
	 matches.  The kwset matcher will return the index
	 of the matching string that it chooses. */
      for (dm = dfa.musts; dm; dm = dm->next)
	{
	  if (!dm->exact)
	    continue;
	  ++kwset_exact_matches;
	  if ((err = kwsincr_case (dm->must)) != NULL)
	    error (EXIT_TROUBLE, 0, "%s", err);
	}
      /* Now, we compile the substrings that will require
	 the use of the regexp matcher.  */
      for (dm = dfa.musts; dm; dm = dm->next)
	{
	  if (dm->exact)
	    continue;
	  if ((err = kwsincr_case (dm->must)) != NULL)
	    error (EXIT_TROUBLE, 0, "%s", err);
	}
      if ((err = kwsprep (kwset)) != NULL)
	error (EXIT_TROUBLE, 0, "%s", err);
    }
}

void
GEAcompile (char const *pattern, size_t size, reg_syntax_t syntax_bits)
{
  const char *err;
  const char *p, *sep;
  size_t total = size;
  char *motif;

  if (match_icase)
    syntax_bits |= RE_ICASE;
  re_set_syntax (syntax_bits);
  dfasyntax (syntax_bits, match_icase, eolbyte);

  /* For GNU regex compiler we have to pass the patterns separately to detect
     errors like "[\nallo\n]\n".  The patterns here are "[", "allo" and "]"
     GNU regex should have raise a syntax error.  The same for backref, where
     the backref should have been local to each pattern.  */
  p = pattern;
  do
    {
      size_t len;
      sep = memchr (p, '\n', total);
      if (sep)
	{
	  len = sep - p;
	  sep++;
	  total -= (len + 1);
	}
      else
	{
	  len = total;
	  total = 0;
	}

      patterns = realloc (patterns, (pcount + 1) * sizeof (*patterns));
      if (patterns == NULL)
	error (EXIT_TROUBLE, errno, _("memory exhausted"));
      patterns[pcount] = patterns0;

      if ((err = re_compile_pattern (p, len,
				    &(patterns[pcount].regexbuf))) != NULL)
	error (EXIT_TROUBLE, 0, "%s", err);
      pcount++;

      p = sep;
    } while (sep && total != 0);

  /* In the match_words and match_lines cases, we use a different pattern
     for the DFA matcher that will quickly throw out cases that won't work.
     Then if DFA succeeds we do some hairy stuff using the regex matcher
     to decide whether the match should really count. */
  if (match_words || match_lines)
    {
      static char const line_beg_no_bk[] = "^(";
      static char const line_end_no_bk[] = ")$";
      static char const word_beg_no_bk[] = "(^|[^[:alnum:]_])(";
      static char const word_end_no_bk[] = ")([^[:alnum:]_]|$)";
      static char const line_beg_bk[] = "^\\(";
      static char const line_end_bk[] = "\\)$";
      static char const word_beg_bk[] = "\\(^\\|[^[:alnum:]_]\\)\\(";
      static char const word_end_bk[] = "\\)\\([^[:alnum:]_]\\|$\\)";
      int bk = !(syntax_bits & RE_NO_BK_PARENS);
      char *n = xmalloc (sizeof word_beg_bk - 1 + size + sizeof word_end_bk);

      strcpy (n, match_lines ? (bk ? line_beg_bk : line_beg_no_bk)
			     : (bk ? word_beg_bk : word_beg_no_bk));
      total = strlen(n);
      memcpy (n + total, pattern, size);
      total += size;
      strcpy (n + total, match_lines ? (bk ? line_end_bk : line_end_no_bk)
				     : (bk ? word_end_bk : word_end_no_bk));
      total += strlen (n + total);
      pattern = motif = n;
      size = total;
    }
  else
    motif = NULL;

  dfacomp (pattern, size, &dfa, 1);
  kwsmusts ();

  free(motif);
}

size_t
EGexecute (char const *buf, size_t size, size_t *match_size,
	   char const *start_ptr)
{
  char const *buflim, *beg, *end, *match, *best_match, *mb_start;
  char eol = eolbyte;
  int backref, start, len, best_len;
  struct kwsmatch kwsm;
  size_t i, ret_val;
#ifdef MBS_SUPPORT
  if (MB_CUR_MAX > 1)
    {
      if (match_icase)
        {
          /* mbtolower adds a NUL byte at the end.  That will provide
	     space for the sentinel byte dfaexec may add.  */
          char *case_buf = mbtolower (buf, &size);
	  if (start_ptr)
	    start_ptr = case_buf + (start_ptr - buf);
          buf = case_buf;
        }
    }
#endif /* MBS_SUPPORT */

  mb_start = buf;
  buflim = buf + size;

  for (beg = end = buf; end < buflim; beg = end)
    {
      if (!start_ptr)
	{
	  /* We don't care about an exact match.  */
	  if (kwset)
	    {
	      /* Find a possible match using the KWset matcher. */
	      size_t offset = kwsexec (kwset, beg, buflim - beg, &kwsm);
	      if (offset == (size_t) -1)
		goto failure;
	      beg += offset;
	      /* Narrow down to the line containing the candidate, and
		 run it through DFA. */
	      if ((end = memchr(beg, eol, buflim - beg)) != NULL)
	        end++;
              else
                end = buflim;
	      match = beg;
	      while (beg > buf && beg[-1] != eol)
		--beg;
	      
//Patch 0:
if ((kwsm.index < kwset_exact_matches) && !(__is_neg(27, &(kwset_exact_matches), sizeof (kwset_exact_matches), &(kwsm.index), sizeof (kwsm.index), &(beg), sizeof (beg), &(buf), sizeof (buf), &(eol), sizeof (eol), &(match), sizeof (match), &(mb_start), sizeof (mb_start), &(buflim), sizeof (buflim), &(end), sizeof (end), &(backref), sizeof (backref), &(offset), sizeof (offset), &(kwset), sizeof (kwset), &(start_ptr), sizeof (start_ptr), &(size), sizeof (size), &(match_icase), sizeof (match_icase), &(best_match), sizeof (best_match), &(best_len), sizeof (best_len), &(eolbyte), sizeof (eolbyte), &(i), sizeof (i), &(pcount), sizeof (pcount), &(patterns), sizeof (patterns), &(start), sizeof (start), &(len), sizeof (len), &(match_words), sizeof (match_words), &(match_lines), sizeof (match_lines), &(ret_val), sizeof (ret_val), &(match_size), sizeof (match_size)))) {
    if (mb_start < beg)
        mb_start = beg;
    if ((__ctype_get_mb_cur_max()) == 1 || !is_mb_middle(&mb_start, match, buflim))
        goto success;
}

//CodeSeg 1:
	      if (dfaexec (&dfa, beg, (char *) end, 0, NULL, &backref) == NULL)
		continue;
	    }
	  else
	    {
	      /* No good fixed strings; start with DFA. */
	      char const *next_beg = dfaexec (&dfa, beg, (char *) buflim,
					      0, NULL, &backref);
	      if (next_beg == NULL)
		break;
	      /* Narrow down to the line we've found. */
	      beg = next_beg;
	      if ((end = memchr(beg, eol, buflim - beg)) != NULL)
	        end++;
              else
                end = buflim;
	      while (beg > buf && beg[-1] != eol)
		--beg;
	    }
	  /* Successful, no backreferences encountered! */
	  if (!backref)
	    goto success;
	}
      else
	{
	  /* We are looking for the leftmost (then longest) exact match.
	     We will go through the outer loop only once.  */
	  beg = start_ptr;
	  end = buflim;
	}

      /* If we've made it to this point, this means DFA has seen
	 a probable match, and we need to run it through Regex. */
      best_match = end;
      best_len = 0;
      for (i = 0; i < pcount; i++)
	{
	  patterns[i].regexbuf.not_eol = 0;
	  if (0 <= (start = re_search (&(patterns[i].regexbuf),
				       buf, end - buf - 1,
				       beg - buf, end - beg - 1,
				       &(patterns[i].regs))))
	    {
	      len = patterns[i].regs.end[0] - start;
	      match = buf + start;
	      if (match > best_match)
		continue;
	      if (start_ptr && !match_words)
		goto assess_pattern_match;
	      if ((!match_lines && !match_words)
		  || (match_lines && len == end - beg - 1))
		{
		  match = beg;
		  len = end - beg;
		  goto assess_pattern_match;
		}
	      /* If -w, check if the match aligns with word boundaries.
		 We do this iteratively because:
		 (a) the line may contain more than one occurence of the
		 pattern, and
		 (b) Several alternatives in the pattern might be valid at a
		 given point, and we may need to consider a shorter one to
		 find a word boundary.  */
	      if (match_words)
		while (match <= best_match)
		  {
		    if ((match == buf || !WCHAR ((unsigned char) match[-1]))
			&& (len == end - beg - 1
			    || !WCHAR ((unsigned char) match[len])))
		      goto assess_pattern_match;
		    if (len > 0)
		      {
			/* Try a shorter length anchored at the same place. */
			--len;
			patterns[i].regexbuf.not_eol = 1;
			len = re_match (&(patterns[i].regexbuf),
					buf, match + len - beg, match - buf,
					&(patterns[i].regs));
		      }
		    if (len <= 0)
		      {
			/* Try looking further on. */
			if (match == end - 1)
			  break;
			match++;
			patterns[i].regexbuf.not_eol = 0;
			start = re_search (&(patterns[i].regexbuf),
					   buf, end - buf - 1,
					   match - buf, end - match - 1,
					   &(patterns[i].regs));
			if (start < 0)
			  break;
			len = patterns[i].regs.end[0] - start;
			match = buf + start;
		      }
		  } /* while (match <= best_match) */
	      continue;
	    assess_pattern_match:
	      if (!start_ptr)
		{
		  /* Good enough for a non-exact match.
		     No need to look at further patterns, if any.  */
		  beg = match;
		  goto success_in_len;
		}
	      if (match < best_match || (match == best_match && len > best_len))
		{
		  /* Best exact match:  leftmost, then longest.  */
		  best_match = match;
		  best_len = len;
		}
	    } /* if re_search >= 0 */
	} /* for Regex patterns.  */
	if (best_match < end)
	  {
	    /* We have found an exact match.  We were just
	       waiting for the best one (leftmost then longest).  */
	    beg = best_match;
	    len = best_len;
	    goto success_in_len;
	  }
    } /* for (beg = end ..) */

 failure:
  ret_val = -1;
  goto out;

 success:
  len = end - beg;
 success_in_len:
  *match_size = len;
  ret_val = beg - buf;
 out:
  return ret_val;
}

Spawn 1 instances, now Total 53
Counter: 54
Batcher Size:53
Preprocess the following candidate with CondTester:
Priority 20000
At location src/dfasearch.c:250
--Src File: src/dfasearch.c
Fragment 0:
if ((kwsm.index < kwset_exact_matches) || (__abst_hole(kwset_exact_matches, kwsm.index, beg, buf, eol, match, mb_start, buflim, end, backref, offset, kwset, start_ptr, size, match_icase, best_match, best_len, eolbyte, i, pcount, patterns, start, len, match_words, match_lines, ret_val, match_size))) {
    if (mb_start < beg)
        mb_start = beg;
    if ((__ctype_get_mb_cur_max()) == 1 || !is_mb_middle(&mb_start, match, buflim))
        goto success;
}


CondTester, a patch instance with id 53:
//src_file:src/dfasearch.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); void* memset(void*, int, unsigned long); 
/* dfasearch.c - searching subroutines using dfa and regex for grep.
   Copyright 1992, 1998, 2000, 2007, 2009-2010 Free Software Foundation, Inc.

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 3, or (at your option)
   any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program; if not, write to the Free Software
   Foundation, Inc., 51 Franklin Street - Fifth Floor, Boston, MA
   02110-1301, USA.  */

/* Written August 1992 by Mike Haertel. */

#include <config.h>
#include "search.h"
#include "dfa.h"

/* For -w, we also consider _ to be word constituent.  */
#define WCHAR(C) (ISALNUM(C) || (C) == '_')

/* KWset compiled pattern.  For Ecompile and Gcompile, we compile
   a list of strings, at least one of which is known to occur in
   any string matching the regexp. */
static kwset_t kwset;

/* DFA compiled regexp. */
static struct dfa dfa;

/* The Regex compiled patterns.  */
static struct patterns
{
  /* Regex compiled regexp. */
  struct re_pattern_buffer regexbuf;
  struct re_registers regs; /* This is here on account of a BRAIN-DEAD
			       Q@#%!# library interface in regex.c.  */
} patterns0;

struct patterns *patterns;
size_t pcount;

void
dfaerror (char const *mesg)
{
  error (EXIT_TROUBLE, 0, "%s", mesg);

  /* notreached */
  /* Tell static analyzers that this function does not return.  */
  abort ();
}

/* Number of compiled fixed strings known to exactly match the regexp.
   If kwsexec returns < kwset_exact_matches, then we don't need to
   call the regexp matcher at all. */
static int kwset_exact_matches;

static char const *
kwsincr_case (const char *must)
{
  const char *buf;
  size_t n;

  n = strlen (must);
#ifdef MBS_SUPPORT
  if (match_icase && MB_CUR_MAX > 1)
    buf = mbtolower (must, &n);
  else
#endif
    buf = must;
  return kwsincr (kwset, buf, n);
}

/* If the DFA turns out to have some set of fixed strings one of
   which must occur in the match, then we build a kwset matcher
   to find those strings, and thus quickly filter out impossible
   matches. */
static void
kwsmusts (void)
{
  struct dfamust const *dm;
  char const *err;

  if (dfa.musts)
    {
      kwsinit (&kwset);
      /* First, we compile in the substrings known to be exact
	 matches.  The kwset matcher will return the index
	 of the matching string that it chooses. */
      for (dm = dfa.musts; dm; dm = dm->next)
	{
	  if (!dm->exact)
	    continue;
	  ++kwset_exact_matches;
	  if ((err = kwsincr_case (dm->must)) != NULL)
	    error (EXIT_TROUBLE, 0, "%s", err);
	}
      /* Now, we compile the substrings that will require
	 the use of the regexp matcher.  */
      for (dm = dfa.musts; dm; dm = dm->next)
	{
	  if (dm->exact)
	    continue;
	  if ((err = kwsincr_case (dm->must)) != NULL)
	    error (EXIT_TROUBLE, 0, "%s", err);
	}
      if ((err = kwsprep (kwset)) != NULL)
	error (EXIT_TROUBLE, 0, "%s", err);
    }
}

void
GEAcompile (char const *pattern, size_t size, reg_syntax_t syntax_bits)
{
  const char *err;
  const char *p, *sep;
  size_t total = size;
  char *motif;

  if (match_icase)
    syntax_bits |= RE_ICASE;
  re_set_syntax (syntax_bits);
  dfasyntax (syntax_bits, match_icase, eolbyte);

  /* For GNU regex compiler we have to pass the patterns separately to detect
     errors like "[\nallo\n]\n".  The patterns here are "[", "allo" and "]"
     GNU regex should have raise a syntax error.  The same for backref, where
     the backref should have been local to each pattern.  */
  p = pattern;
  do
    {
      size_t len;
      sep = memchr (p, '\n', total);
      if (sep)
	{
	  len = sep - p;
	  sep++;
	  total -= (len + 1);
	}
      else
	{
	  len = total;
	  total = 0;
	}

      patterns = realloc (patterns, (pcount + 1) * sizeof (*patterns));
      if (patterns == NULL)
	error (EXIT_TROUBLE, errno, _("memory exhausted"));
      patterns[pcount] = patterns0;

      if ((err = re_compile_pattern (p, len,
				    &(patterns[pcount].regexbuf))) != NULL)
	error (EXIT_TROUBLE, 0, "%s", err);
      pcount++;

      p = sep;
    } while (sep && total != 0);

  /* In the match_words and match_lines cases, we use a different pattern
     for the DFA matcher that will quickly throw out cases that won't work.
     Then if DFA succeeds we do some hairy stuff using the regex matcher
     to decide whether the match should really count. */
  if (match_words || match_lines)
    {
      static char const line_beg_no_bk[] = "^(";
      static char const line_end_no_bk[] = ")$";
      static char const word_beg_no_bk[] = "(^|[^[:alnum:]_])(";
      static char const word_end_no_bk[] = ")([^[:alnum:]_]|$)";
      static char const line_beg_bk[] = "^\\(";
      static char const line_end_bk[] = "\\)$";
      static char const word_beg_bk[] = "\\(^\\|[^[:alnum:]_]\\)\\(";
      static char const word_end_bk[] = "\\)\\([^[:alnum:]_]\\|$\\)";
      int bk = !(syntax_bits & RE_NO_BK_PARENS);
      char *n = xmalloc (sizeof word_beg_bk - 1 + size + sizeof word_end_bk);

      strcpy (n, match_lines ? (bk ? line_beg_bk : line_beg_no_bk)
			     : (bk ? word_beg_bk : word_beg_no_bk));
      total = strlen(n);
      memcpy (n + total, pattern, size);
      total += size;
      strcpy (n + total, match_lines ? (bk ? line_end_bk : line_end_no_bk)
				     : (bk ? word_end_bk : word_end_no_bk));
      total += strlen (n + total);
      pattern = motif = n;
      size = total;
    }
  else
    motif = NULL;

  dfacomp (pattern, size, &dfa, 1);
  kwsmusts ();

  free(motif);
}

size_t
EGexecute (char const *buf, size_t size, size_t *match_size,
	   char const *start_ptr)
{
  char const *buflim, *beg, *end, *match, *best_match, *mb_start;
  char eol = eolbyte;
  int backref, start, len, best_len;
  struct kwsmatch kwsm;
  size_t i, ret_val;
#ifdef MBS_SUPPORT
  if (MB_CUR_MAX > 1)
    {
      if (match_icase)
        {
          /* mbtolower adds a NUL byte at the end.  That will provide
	     space for the sentinel byte dfaexec may add.  */
          char *case_buf = mbtolower (buf, &size);
	  if (start_ptr)
	    start_ptr = case_buf + (start_ptr - buf);
          buf = case_buf;
        }
    }
#endif /* MBS_SUPPORT */

  mb_start = buf;
  buflim = buf + size;

  for (beg = end = buf; end < buflim; beg = end)
    {
      if (!start_ptr)
	{
	  /* We don't care about an exact match.  */
	  if (kwset)
	    {
	      /* Find a possible match using the KWset matcher. */
	      size_t offset = kwsexec (kwset, beg, buflim - beg, &kwsm);
	      if (offset == (size_t) -1)
		goto failure;
	      beg += offset;
	      /* Narrow down to the line containing the candidate, and
		 run it through DFA. */
	      if ((end = memchr(beg, eol, buflim - beg)) != NULL)
	        end++;
              else
                end = buflim;
	      match = beg;
	      while (beg > buf && beg[-1] != eol)
		--beg;
	      
//Patch 0:
if ((kwsm.index < kwset_exact_matches) || (__is_neg(27, &(kwset_exact_matches), sizeof (kwset_exact_matches), &(kwsm.index), sizeof (kwsm.index), &(beg), sizeof (beg), &(buf), sizeof (buf), &(eol), sizeof (eol), &(match), sizeof (match), &(mb_start), sizeof (mb_start), &(buflim), sizeof (buflim), &(end), sizeof (end), &(backref), sizeof (backref), &(offset), sizeof (offset), &(kwset), sizeof (kwset), &(start_ptr), sizeof (start_ptr), &(size), sizeof (size), &(match_icase), sizeof (match_icase), &(best_match), sizeof (best_match), &(best_len), sizeof (best_len), &(eolbyte), sizeof (eolbyte), &(i), sizeof (i), &(pcount), sizeof (pcount), &(patterns), sizeof (patterns), &(start), sizeof (start), &(len), sizeof (len), &(match_words), sizeof (match_words), &(match_lines), sizeof (match_lines), &(ret_val), sizeof (ret_val), &(match_size), sizeof (match_size)))) {
    if (mb_start < beg)
        mb_start = beg;
    if ((__ctype_get_mb_cur_max()) == 1 || !is_mb_middle(&mb_start, match, buflim))
        goto success;
}

//CodeSeg 1:
	      if (dfaexec (&dfa, beg, (char *) end, 0, NULL, &backref) == NULL)
		continue;
	    }
	  else
	    {
	      /* No good fixed strings; start with DFA. */
	      char const *next_beg = dfaexec (&dfa, beg, (char *) buflim,
					      0, NULL, &backref);
	      if (next_beg == NULL)
		break;
	      /* Narrow down to the line we've found. */
	      beg = next_beg;
	      if ((end = memchr(beg, eol, buflim - beg)) != NULL)
	        end++;
              else
                end = buflim;
	      while (beg > buf && beg[-1] != eol)
		--beg;
	    }
	  /* Successful, no backreferences encountered! */
	  if (!backref)
	    goto success;
	}
      else
	{
	  /* We are looking for the leftmost (then longest) exact match.
	     We will go through the outer loop only once.  */
	  beg = start_ptr;
	  end = buflim;
	}

      /* If we've made it to this point, this means DFA has seen
	 a probable match, and we need to run it through Regex. */
      best_match = end;
      best_len = 0;
      for (i = 0; i < pcount; i++)
	{
	  patterns[i].regexbuf.not_eol = 0;
	  if (0 <= (start = re_search (&(patterns[i].regexbuf),
				       buf, end - buf - 1,
				       beg - buf, end - beg - 1,
				       &(patterns[i].regs))))
	    {
	      len = patterns[i].regs.end[0] - start;
	      match = buf + start;
	      if (match > best_match)
		continue;
	      if (start_ptr && !match_words)
		goto assess_pattern_match;
	      if ((!match_lines && !match_words)
		  || (match_lines && len == end - beg - 1))
		{
		  match = beg;
		  len = end - beg;
		  goto assess_pattern_match;
		}
	      /* If -w, check if the match aligns with word boundaries.
		 We do this iteratively because:
		 (a) the line may contain more than one occurence of the
		 pattern, and
		 (b) Several alternatives in the pattern might be valid at a
		 given point, and we may need to consider a shorter one to
		 find a word boundary.  */
	      if (match_words)
		while (match <= best_match)
		  {
		    if ((match == buf || !WCHAR ((unsigned char) match[-1]))
			&& (len == end - beg - 1
			    || !WCHAR ((unsigned char) match[len])))
		      goto assess_pattern_match;
		    if (len > 0)
		      {
			/* Try a shorter length anchored at the same place. */
			--len;
			patterns[i].regexbuf.not_eol = 1;
			len = re_match (&(patterns[i].regexbuf),
					buf, match + len - beg, match - buf,
					&(patterns[i].regs));
		      }
		    if (len <= 0)
		      {
			/* Try looking further on. */
			if (match == end - 1)
			  break;
			match++;
			patterns[i].regexbuf.not_eol = 0;
			start = re_search (&(patterns[i].regexbuf),
					   buf, end - buf - 1,
					   match - buf, end - match - 1,
					   &(patterns[i].regs));
			if (start < 0)
			  break;
			len = patterns[i].regs.end[0] - start;
			match = buf + start;
		      }
		  } /* while (match <= best_match) */
	      continue;
	    assess_pattern_match:
	      if (!start_ptr)
		{
		  /* Good enough for a non-exact match.
		     No need to look at further patterns, if any.  */
		  beg = match;
		  goto success_in_len;
		}
	      if (match < best_match || (match == best_match && len > best_len))
		{
		  /* Best exact match:  leftmost, then longest.  */
		  best_match = match;
		  best_len = len;
		}
	    } /* if re_search >= 0 */
	} /* for Regex patterns.  */
	if (best_match < end)
	  {
	    /* We have found an exact match.  We were just
	       waiting for the best one (leftmost then longest).  */
	    beg = best_match;
	    len = best_len;
	    goto success_in_len;
	  }
    } /* for (beg = end ..) */

 failure:
  ret_val = -1;
  goto out;

 success:
  len = end - beg;
 success_in_len:
  *match_size = len;
  ret_val = beg - buf;
 out:
  return ret_val;
}

Spawn 1 instances, now Total 54
Counter: 55
Batcher Size:54
Preprocess the following candidate with CondTester:
Priority 20000
At location src/dfasearch.c:243
--Src File: src/dfasearch.c
Fragment 0:
if (((end = memchr(beg, eol, buflim - beg)) != ((void *)0)) && !(__abst_hole(buflim, beg, end, eol, offset, match, buf, kwset, kwset_exact_matches, mb_start, start_ptr, size, backref, match_icase, eolbyte, best_match, best_len, i, pcount, patterns, start, len, match_words, match_lines, ret_val, match_size)))
    end++;
else
    end = buflim;


CondTester, a patch instance with id 54:
//src_file:src/dfasearch.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); void* memset(void*, int, unsigned long); 
/* dfasearch.c - searching subroutines using dfa and regex for grep.
   Copyright 1992, 1998, 2000, 2007, 2009-2010 Free Software Foundation, Inc.

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 3, or (at your option)
   any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program; if not, write to the Free Software
   Foundation, Inc., 51 Franklin Street - Fifth Floor, Boston, MA
   02110-1301, USA.  */

/* Written August 1992 by Mike Haertel. */

#include <config.h>
#include "search.h"
#include "dfa.h"

/* For -w, we also consider _ to be word constituent.  */
#define WCHAR(C) (ISALNUM(C) || (C) == '_')

/* KWset compiled pattern.  For Ecompile and Gcompile, we compile
   a list of strings, at least one of which is known to occur in
   any string matching the regexp. */
static kwset_t kwset;

/* DFA compiled regexp. */
static struct dfa dfa;

/* The Regex compiled patterns.  */
static struct patterns
{
  /* Regex compiled regexp. */
  struct re_pattern_buffer regexbuf;
  struct re_registers regs; /* This is here on account of a BRAIN-DEAD
			       Q@#%!# library interface in regex.c.  */
} patterns0;

struct patterns *patterns;
size_t pcount;

void
dfaerror (char const *mesg)
{
  error (EXIT_TROUBLE, 0, "%s", mesg);

  /* notreached */
  /* Tell static analyzers that this function does not return.  */
  abort ();
}

/* Number of compiled fixed strings known to exactly match the regexp.
   If kwsexec returns < kwset_exact_matches, then we don't need to
   call the regexp matcher at all. */
static int kwset_exact_matches;

static char const *
kwsincr_case (const char *must)
{
  const char *buf;
  size_t n;

  n = strlen (must);
#ifdef MBS_SUPPORT
  if (match_icase && MB_CUR_MAX > 1)
    buf = mbtolower (must, &n);
  else
#endif
    buf = must;
  return kwsincr (kwset, buf, n);
}

/* If the DFA turns out to have some set of fixed strings one of
   which must occur in the match, then we build a kwset matcher
   to find those strings, and thus quickly filter out impossible
   matches. */
static void
kwsmusts (void)
{
  struct dfamust const *dm;
  char const *err;

  if (dfa.musts)
    {
      kwsinit (&kwset);
      /* First, we compile in the substrings known to be exact
	 matches.  The kwset matcher will return the index
	 of the matching string that it chooses. */
      for (dm = dfa.musts; dm; dm = dm->next)
	{
	  if (!dm->exact)
	    continue;
	  ++kwset_exact_matches;
	  if ((err = kwsincr_case (dm->must)) != NULL)
	    error (EXIT_TROUBLE, 0, "%s", err);
	}
      /* Now, we compile the substrings that will require
	 the use of the regexp matcher.  */
      for (dm = dfa.musts; dm; dm = dm->next)
	{
	  if (dm->exact)
	    continue;
	  if ((err = kwsincr_case (dm->must)) != NULL)
	    error (EXIT_TROUBLE, 0, "%s", err);
	}
      if ((err = kwsprep (kwset)) != NULL)
	error (EXIT_TROUBLE, 0, "%s", err);
    }
}

void
GEAcompile (char const *pattern, size_t size, reg_syntax_t syntax_bits)
{
  const char *err;
  const char *p, *sep;
  size_t total = size;
  char *motif;

  if (match_icase)
    syntax_bits |= RE_ICASE;
  re_set_syntax (syntax_bits);
  dfasyntax (syntax_bits, match_icase, eolbyte);

  /* For GNU regex compiler we have to pass the patterns separately to detect
     errors like "[\nallo\n]\n".  The patterns here are "[", "allo" and "]"
     GNU regex should have raise a syntax error.  The same for backref, where
     the backref should have been local to each pattern.  */
  p = pattern;
  do
    {
      size_t len;
      sep = memchr (p, '\n', total);
      if (sep)
	{
	  len = sep - p;
	  sep++;
	  total -= (len + 1);
	}
      else
	{
	  len = total;
	  total = 0;
	}

      patterns = realloc (patterns, (pcount + 1) * sizeof (*patterns));
      if (patterns == NULL)
	error (EXIT_TROUBLE, errno, _("memory exhausted"));
      patterns[pcount] = patterns0;

      if ((err = re_compile_pattern (p, len,
				    &(patterns[pcount].regexbuf))) != NULL)
	error (EXIT_TROUBLE, 0, "%s", err);
      pcount++;

      p = sep;
    } while (sep && total != 0);

  /* In the match_words and match_lines cases, we use a different pattern
     for the DFA matcher that will quickly throw out cases that won't work.
     Then if DFA succeeds we do some hairy stuff using the regex matcher
     to decide whether the match should really count. */
  if (match_words || match_lines)
    {
      static char const line_beg_no_bk[] = "^(";
      static char const line_end_no_bk[] = ")$";
      static char const word_beg_no_bk[] = "(^|[^[:alnum:]_])(";
      static char const word_end_no_bk[] = ")([^[:alnum:]_]|$)";
      static char const line_beg_bk[] = "^\\(";
      static char const line_end_bk[] = "\\)$";
      static char const word_beg_bk[] = "\\(^\\|[^[:alnum:]_]\\)\\(";
      static char const word_end_bk[] = "\\)\\([^[:alnum:]_]\\|$\\)";
      int bk = !(syntax_bits & RE_NO_BK_PARENS);
      char *n = xmalloc (sizeof word_beg_bk - 1 + size + sizeof word_end_bk);

      strcpy (n, match_lines ? (bk ? line_beg_bk : line_beg_no_bk)
			     : (bk ? word_beg_bk : word_beg_no_bk));
      total = strlen(n);
      memcpy (n + total, pattern, size);
      total += size;
      strcpy (n + total, match_lines ? (bk ? line_end_bk : line_end_no_bk)
				     : (bk ? word_end_bk : word_end_no_bk));
      total += strlen (n + total);
      pattern = motif = n;
      size = total;
    }
  else
    motif = NULL;

  dfacomp (pattern, size, &dfa, 1);
  kwsmusts ();

  free(motif);
}

size_t
EGexecute (char const *buf, size_t size, size_t *match_size,
	   char const *start_ptr)
{
  char const *buflim, *beg, *end, *match, *best_match, *mb_start;
  char eol = eolbyte;
  int backref, start, len, best_len;
  struct kwsmatch kwsm;
  size_t i, ret_val;
#ifdef MBS_SUPPORT
  if (MB_CUR_MAX > 1)
    {
      if (match_icase)
        {
          /* mbtolower adds a NUL byte at the end.  That will provide
	     space for the sentinel byte dfaexec may add.  */
          char *case_buf = mbtolower (buf, &size);
	  if (start_ptr)
	    start_ptr = case_buf + (start_ptr - buf);
          buf = case_buf;
        }
    }
#endif /* MBS_SUPPORT */

  mb_start = buf;
  buflim = buf + size;

  for (beg = end = buf; end < buflim; beg = end)
    {
      if (!start_ptr)
	{
	  /* We don't care about an exact match.  */
	  if (kwset)
	    {
	      /* Find a possible match using the KWset matcher. */
	      size_t offset = kwsexec (kwset, beg, buflim - beg, &kwsm);
	      if (offset == (size_t) -1)
		goto failure;
	      beg += offset;
	      /* Narrow down to the line containing the candidate, and
		 run it through DFA. */
	      
//Patch 0:
if (((end = memchr(beg, eol, buflim - beg)) != ((void *)0)) && !(__is_neg(26, &(buflim), sizeof (buflim), &(beg), sizeof (beg), &(end), sizeof (end), &(eol), sizeof (eol), &(offset), sizeof (offset), &(match), sizeof (match), &(buf), sizeof (buf), &(kwset), sizeof (kwset), &(kwset_exact_matches), sizeof (kwset_exact_matches), &(mb_start), sizeof (mb_start), &(start_ptr), sizeof (start_ptr), &(size), sizeof (size), &(backref), sizeof (backref), &(match_icase), sizeof (match_icase), &(eolbyte), sizeof (eolbyte), &(best_match), sizeof (best_match), &(best_len), sizeof (best_len), &(i), sizeof (i), &(pcount), sizeof (pcount), &(patterns), sizeof (patterns), &(start), sizeof (start), &(len), sizeof (len), &(match_words), sizeof (match_words), &(match_lines), sizeof (match_lines), &(ret_val), sizeof (ret_val), &(match_size), sizeof (match_size))))
    end++;
else
    end = buflim;

//CodeSeg 1:
	      match = beg;
	      while (beg > buf && beg[-1] != eol)
		--beg;
	      if (kwsm.index < kwset_exact_matches)
                {
#ifdef MBS_SUPPORT
                  if (mb_start < beg)
                    mb_start = beg;
                  if (MB_CUR_MAX == 1 || !is_mb_middle (&mb_start, match, buflim))
#endif
                    goto success;
                }
	      if (dfaexec (&dfa, beg, (char *) end, 0, NULL, &backref) == NULL)
		continue;
	    }
	  else
	    {
	      /* No good fixed strings; start with DFA. */
	      char const *next_beg = dfaexec (&dfa, beg, (char *) buflim,
					      0, NULL, &backref);
	      if (next_beg == NULL)
		break;
	      /* Narrow down to the line we've found. */
	      beg = next_beg;
	      if ((end = memchr(beg, eol, buflim - beg)) != NULL)
	        end++;
              else
                end = buflim;
	      while (beg > buf && beg[-1] != eol)
		--beg;
	    }
	  /* Successful, no backreferences encountered! */
	  if (!backref)
	    goto success;
	}
      else
	{
	  /* We are looking for the leftmost (then longest) exact match.
	     We will go through the outer loop only once.  */
	  beg = start_ptr;
	  end = buflim;
	}

      /* If we've made it to this point, this means DFA has seen
	 a probable match, and we need to run it through Regex. */
      best_match = end;
      best_len = 0;
      for (i = 0; i < pcount; i++)
	{
	  patterns[i].regexbuf.not_eol = 0;
	  if (0 <= (start = re_search (&(patterns[i].regexbuf),
				       buf, end - buf - 1,
				       beg - buf, end - beg - 1,
				       &(patterns[i].regs))))
	    {
	      len = patterns[i].regs.end[0] - start;
	      match = buf + start;
	      if (match > best_match)
		continue;
	      if (start_ptr && !match_words)
		goto assess_pattern_match;
	      if ((!match_lines && !match_words)
		  || (match_lines && len == end - beg - 1))
		{
		  match = beg;
		  len = end - beg;
		  goto assess_pattern_match;
		}
	      /* If -w, check if the match aligns with word boundaries.
		 We do this iteratively because:
		 (a) the line may contain more than one occurence of the
		 pattern, and
		 (b) Several alternatives in the pattern might be valid at a
		 given point, and we may need to consider a shorter one to
		 find a word boundary.  */
	      if (match_words)
		while (match <= best_match)
		  {
		    if ((match == buf || !WCHAR ((unsigned char) match[-1]))
			&& (len == end - beg - 1
			    || !WCHAR ((unsigned char) match[len])))
		      goto assess_pattern_match;
		    if (len > 0)
		      {
			/* Try a shorter length anchored at the same place. */
			--len;
			patterns[i].regexbuf.not_eol = 1;
			len = re_match (&(patterns[i].regexbuf),
					buf, match + len - beg, match - buf,
					&(patterns[i].regs));
		      }
		    if (len <= 0)
		      {
			/* Try looking further on. */
			if (match == end - 1)
			  break;
			match++;
			patterns[i].regexbuf.not_eol = 0;
			start = re_search (&(patterns[i].regexbuf),
					   buf, end - buf - 1,
					   match - buf, end - match - 1,
					   &(patterns[i].regs));
			if (start < 0)
			  break;
			len = patterns[i].regs.end[0] - start;
			match = buf + start;
		      }
		  } /* while (match <= best_match) */
	      continue;
	    assess_pattern_match:
	      if (!start_ptr)
		{
		  /* Good enough for a non-exact match.
		     No need to look at further patterns, if any.  */
		  beg = match;
		  goto success_in_len;
		}
	      if (match < best_match || (match == best_match && len > best_len))
		{
		  /* Best exact match:  leftmost, then longest.  */
		  best_match = match;
		  best_len = len;
		}
	    } /* if re_search >= 0 */
	} /* for Regex patterns.  */
	if (best_match < end)
	  {
	    /* We have found an exact match.  We were just
	       waiting for the best one (leftmost then longest).  */
	    beg = best_match;
	    len = best_len;
	    goto success_in_len;
	  }
    } /* for (beg = end ..) */

 failure:
  ret_val = -1;
  goto out;

 success:
  len = end - beg;
 success_in_len:
  *match_size = len;
  ret_val = beg - buf;
 out:
  return ret_val;
}

Spawn 1 instances, now Total 55
Counter: 56
Batcher Size:55
Preprocess the following candidate with CondTester:
Priority 20000
At location src/dfasearch.c:243
--Src File: src/dfasearch.c
Fragment 0:
if (((end = memchr(beg, eol, buflim - beg)) != ((void *)0)) || (__abst_hole(buflim, beg, end, eol, offset, match, buf, kwset, kwset_exact_matches, mb_start, start_ptr, size, backref, match_icase, eolbyte, best_match, best_len, i, pcount, patterns, start, len, match_words, match_lines, ret_val, match_size)))
    end++;
else
    end = buflim;


CondTester, a patch instance with id 55:
//src_file:src/dfasearch.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); void* memset(void*, int, unsigned long); 
/* dfasearch.c - searching subroutines using dfa and regex for grep.
   Copyright 1992, 1998, 2000, 2007, 2009-2010 Free Software Foundation, Inc.

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 3, or (at your option)
   any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program; if not, write to the Free Software
   Foundation, Inc., 51 Franklin Street - Fifth Floor, Boston, MA
   02110-1301, USA.  */

/* Written August 1992 by Mike Haertel. */

#include <config.h>
#include "search.h"
#include "dfa.h"

/* For -w, we also consider _ to be word constituent.  */
#define WCHAR(C) (ISALNUM(C) || (C) == '_')

/* KWset compiled pattern.  For Ecompile and Gcompile, we compile
   a list of strings, at least one of which is known to occur in
   any string matching the regexp. */
static kwset_t kwset;

/* DFA compiled regexp. */
static struct dfa dfa;

/* The Regex compiled patterns.  */
static struct patterns
{
  /* Regex compiled regexp. */
  struct re_pattern_buffer regexbuf;
  struct re_registers regs; /* This is here on account of a BRAIN-DEAD
			       Q@#%!# library interface in regex.c.  */
} patterns0;

struct patterns *patterns;
size_t pcount;

void
dfaerror (char const *mesg)
{
  error (EXIT_TROUBLE, 0, "%s", mesg);

  /* notreached */
  /* Tell static analyzers that this function does not return.  */
  abort ();
}

/* Number of compiled fixed strings known to exactly match the regexp.
   If kwsexec returns < kwset_exact_matches, then we don't need to
   call the regexp matcher at all. */
static int kwset_exact_matches;

static char const *
kwsincr_case (const char *must)
{
  const char *buf;
  size_t n;

  n = strlen (must);
#ifdef MBS_SUPPORT
  if (match_icase && MB_CUR_MAX > 1)
    buf = mbtolower (must, &n);
  else
#endif
    buf = must;
  return kwsincr (kwset, buf, n);
}

/* If the DFA turns out to have some set of fixed strings one of
   which must occur in the match, then we build a kwset matcher
   to find those strings, and thus quickly filter out impossible
   matches. */
static void
kwsmusts (void)
{
  struct dfamust const *dm;
  char const *err;

  if (dfa.musts)
    {
      kwsinit (&kwset);
      /* First, we compile in the substrings known to be exact
	 matches.  The kwset matcher will return the index
	 of the matching string that it chooses. */
      for (dm = dfa.musts; dm; dm = dm->next)
	{
	  if (!dm->exact)
	    continue;
	  ++kwset_exact_matches;
	  if ((err = kwsincr_case (dm->must)) != NULL)
	    error (EXIT_TROUBLE, 0, "%s", err);
	}
      /* Now, we compile the substrings that will require
	 the use of the regexp matcher.  */
      for (dm = dfa.musts; dm; dm = dm->next)
	{
	  if (dm->exact)
	    continue;
	  if ((err = kwsincr_case (dm->must)) != NULL)
	    error (EXIT_TROUBLE, 0, "%s", err);
	}
      if ((err = kwsprep (kwset)) != NULL)
	error (EXIT_TROUBLE, 0, "%s", err);
    }
}

void
GEAcompile (char const *pattern, size_t size, reg_syntax_t syntax_bits)
{
  const char *err;
  const char *p, *sep;
  size_t total = size;
  char *motif;

  if (match_icase)
    syntax_bits |= RE_ICASE;
  re_set_syntax (syntax_bits);
  dfasyntax (syntax_bits, match_icase, eolbyte);

  /* For GNU regex compiler we have to pass the patterns separately to detect
     errors like "[\nallo\n]\n".  The patterns here are "[", "allo" and "]"
     GNU regex should have raise a syntax error.  The same for backref, where
     the backref should have been local to each pattern.  */
  p = pattern;
  do
    {
      size_t len;
      sep = memchr (p, '\n', total);
      if (sep)
	{
	  len = sep - p;
	  sep++;
	  total -= (len + 1);
	}
      else
	{
	  len = total;
	  total = 0;
	}

      patterns = realloc (patterns, (pcount + 1) * sizeof (*patterns));
      if (patterns == NULL)
	error (EXIT_TROUBLE, errno, _("memory exhausted"));
      patterns[pcount] = patterns0;

      if ((err = re_compile_pattern (p, len,
				    &(patterns[pcount].regexbuf))) != NULL)
	error (EXIT_TROUBLE, 0, "%s", err);
      pcount++;

      p = sep;
    } while (sep && total != 0);

  /* In the match_words and match_lines cases, we use a different pattern
     for the DFA matcher that will quickly throw out cases that won't work.
     Then if DFA succeeds we do some hairy stuff using the regex matcher
     to decide whether the match should really count. */
  if (match_words || match_lines)
    {
      static char const line_beg_no_bk[] = "^(";
      static char const line_end_no_bk[] = ")$";
      static char const word_beg_no_bk[] = "(^|[^[:alnum:]_])(";
      static char const word_end_no_bk[] = ")([^[:alnum:]_]|$)";
      static char const line_beg_bk[] = "^\\(";
      static char const line_end_bk[] = "\\)$";
      static char const word_beg_bk[] = "\\(^\\|[^[:alnum:]_]\\)\\(";
      static char const word_end_bk[] = "\\)\\([^[:alnum:]_]\\|$\\)";
      int bk = !(syntax_bits & RE_NO_BK_PARENS);
      char *n = xmalloc (sizeof word_beg_bk - 1 + size + sizeof word_end_bk);

      strcpy (n, match_lines ? (bk ? line_beg_bk : line_beg_no_bk)
			     : (bk ? word_beg_bk : word_beg_no_bk));
      total = strlen(n);
      memcpy (n + total, pattern, size);
      total += size;
      strcpy (n + total, match_lines ? (bk ? line_end_bk : line_end_no_bk)
				     : (bk ? word_end_bk : word_end_no_bk));
      total += strlen (n + total);
      pattern = motif = n;
      size = total;
    }
  else
    motif = NULL;

  dfacomp (pattern, size, &dfa, 1);
  kwsmusts ();

  free(motif);
}

size_t
EGexecute (char const *buf, size_t size, size_t *match_size,
	   char const *start_ptr)
{
  char const *buflim, *beg, *end, *match, *best_match, *mb_start;
  char eol = eolbyte;
  int backref, start, len, best_len;
  struct kwsmatch kwsm;
  size_t i, ret_val;
#ifdef MBS_SUPPORT
  if (MB_CUR_MAX > 1)
    {
      if (match_icase)
        {
          /* mbtolower adds a NUL byte at the end.  That will provide
	     space for the sentinel byte dfaexec may add.  */
          char *case_buf = mbtolower (buf, &size);
	  if (start_ptr)
	    start_ptr = case_buf + (start_ptr - buf);
          buf = case_buf;
        }
    }
#endif /* MBS_SUPPORT */

  mb_start = buf;
  buflim = buf + size;

  for (beg = end = buf; end < buflim; beg = end)
    {
      if (!start_ptr)
	{
	  /* We don't care about an exact match.  */
	  if (kwset)
	    {
	      /* Find a possible match using the KWset matcher. */
	      size_t offset = kwsexec (kwset, beg, buflim - beg, &kwsm);
	      if (offset == (size_t) -1)
		goto failure;
	      beg += offset;
	      /* Narrow down to the line containing the candidate, and
		 run it through DFA. */
	      
//Patch 0:
if (((end = memchr(beg, eol, buflim - beg)) != ((void *)0)) || (__is_neg(26, &(buflim), sizeof (buflim), &(beg), sizeof (beg), &(end), sizeof (end), &(eol), sizeof (eol), &(offset), sizeof (offset), &(match), sizeof (match), &(buf), sizeof (buf), &(kwset), sizeof (kwset), &(kwset_exact_matches), sizeof (kwset_exact_matches), &(mb_start), sizeof (mb_start), &(start_ptr), sizeof (start_ptr), &(size), sizeof (size), &(backref), sizeof (backref), &(match_icase), sizeof (match_icase), &(eolbyte), sizeof (eolbyte), &(best_match), sizeof (best_match), &(best_len), sizeof (best_len), &(i), sizeof (i), &(pcount), sizeof (pcount), &(patterns), sizeof (patterns), &(start), sizeof (start), &(len), sizeof (len), &(match_words), sizeof (match_words), &(match_lines), sizeof (match_lines), &(ret_val), sizeof (ret_val), &(match_size), sizeof (match_size))))
    end++;
else
    end = buflim;

//CodeSeg 1:
	      match = beg;
	      while (beg > buf && beg[-1] != eol)
		--beg;
	      if (kwsm.index < kwset_exact_matches)
                {
#ifdef MBS_SUPPORT
                  if (mb_start < beg)
                    mb_start = beg;
                  if (MB_CUR_MAX == 1 || !is_mb_middle (&mb_start, match, buflim))
#endif
                    goto success;
                }
	      if (dfaexec (&dfa, beg, (char *) end, 0, NULL, &backref) == NULL)
		continue;
	    }
	  else
	    {
	      /* No good fixed strings; start with DFA. */
	      char const *next_beg = dfaexec (&dfa, beg, (char *) buflim,
					      0, NULL, &backref);
	      if (next_beg == NULL)
		break;
	      /* Narrow down to the line we've found. */
	      beg = next_beg;
	      if ((end = memchr(beg, eol, buflim - beg)) != NULL)
	        end++;
              else
                end = buflim;
	      while (beg > buf && beg[-1] != eol)
		--beg;
	    }
	  /* Successful, no backreferences encountered! */
	  if (!backref)
	    goto success;
	}
      else
	{
	  /* We are looking for the leftmost (then longest) exact match.
	     We will go through the outer loop only once.  */
	  beg = start_ptr;
	  end = buflim;
	}

      /* If we've made it to this point, this means DFA has seen
	 a probable match, and we need to run it through Regex. */
      best_match = end;
      best_len = 0;
      for (i = 0; i < pcount; i++)
	{
	  patterns[i].regexbuf.not_eol = 0;
	  if (0 <= (start = re_search (&(patterns[i].regexbuf),
				       buf, end - buf - 1,
				       beg - buf, end - beg - 1,
				       &(patterns[i].regs))))
	    {
	      len = patterns[i].regs.end[0] - start;
	      match = buf + start;
	      if (match > best_match)
		continue;
	      if (start_ptr && !match_words)
		goto assess_pattern_match;
	      if ((!match_lines && !match_words)
		  || (match_lines && len == end - beg - 1))
		{
		  match = beg;
		  len = end - beg;
		  goto assess_pattern_match;
		}
	      /* If -w, check if the match aligns with word boundaries.
		 We do this iteratively because:
		 (a) the line may contain more than one occurence of the
		 pattern, and
		 (b) Several alternatives in the pattern might be valid at a
		 given point, and we may need to consider a shorter one to
		 find a word boundary.  */
	      if (match_words)
		while (match <= best_match)
		  {
		    if ((match == buf || !WCHAR ((unsigned char) match[-1]))
			&& (len == end - beg - 1
			    || !WCHAR ((unsigned char) match[len])))
		      goto assess_pattern_match;
		    if (len > 0)
		      {
			/* Try a shorter length anchored at the same place. */
			--len;
			patterns[i].regexbuf.not_eol = 1;
			len = re_match (&(patterns[i].regexbuf),
					buf, match + len - beg, match - buf,
					&(patterns[i].regs));
		      }
		    if (len <= 0)
		      {
			/* Try looking further on. */
			if (match == end - 1)
			  break;
			match++;
			patterns[i].regexbuf.not_eol = 0;
			start = re_search (&(patterns[i].regexbuf),
					   buf, end - buf - 1,
					   match - buf, end - match - 1,
					   &(patterns[i].regs));
			if (start < 0)
			  break;
			len = patterns[i].regs.end[0] - start;
			match = buf + start;
		      }
		  } /* while (match <= best_match) */
	      continue;
	    assess_pattern_match:
	      if (!start_ptr)
		{
		  /* Good enough for a non-exact match.
		     No need to look at further patterns, if any.  */
		  beg = match;
		  goto success_in_len;
		}
	      if (match < best_match || (match == best_match && len > best_len))
		{
		  /* Best exact match:  leftmost, then longest.  */
		  best_match = match;
		  best_len = len;
		}
	    } /* if re_search >= 0 */
	} /* for Regex patterns.  */
	if (best_match < end)
	  {
	    /* We have found an exact match.  We were just
	       waiting for the best one (leftmost then longest).  */
	    beg = best_match;
	    len = best_len;
	    goto success_in_len;
	  }
    } /* for (beg = end ..) */

 failure:
  ret_val = -1;
  goto out;

 success:
  len = end - beg;
 success_in_len:
  *match_size = len;
  ret_val = beg - buf;
 out:
  return ret_val;
}

Spawn 1 instances, now Total 56
Counter: 57
Batcher Size:56
Preprocess the following candidate with CondTester:
Priority 10206
At location src/dfasearch.c:70
--Src File: src/dfasearch.c
Fragment 0:
if ((__abst_hole(must, n, match_icase, buf, kwset)))
    return 0;
n = strlen(must);


CondTester, a patch instance with id 56:
//src_file:src/dfasearch.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); void* memset(void*, int, unsigned long); 
/* dfasearch.c - searching subroutines using dfa and regex for grep.
   Copyright 1992, 1998, 2000, 2007, 2009-2010 Free Software Foundation, Inc.

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 3, or (at your option)
   any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program; if not, write to the Free Software
   Foundation, Inc., 51 Franklin Street - Fifth Floor, Boston, MA
   02110-1301, USA.  */

/* Written August 1992 by Mike Haertel. */

#include <config.h>
#include "search.h"
#include "dfa.h"

/* For -w, we also consider _ to be word constituent.  */
#define WCHAR(C) (ISALNUM(C) || (C) == '_')

/* KWset compiled pattern.  For Ecompile and Gcompile, we compile
   a list of strings, at least one of which is known to occur in
   any string matching the regexp. */
static kwset_t kwset;

/* DFA compiled regexp. */
static struct dfa dfa;

/* The Regex compiled patterns.  */
static struct patterns
{
  /* Regex compiled regexp. */
  struct re_pattern_buffer regexbuf;
  struct re_registers regs; /* This is here on account of a BRAIN-DEAD
			       Q@#%!# library interface in regex.c.  */
} patterns0;

struct patterns *patterns;
size_t pcount;

void
dfaerror (char const *mesg)
{
  error (EXIT_TROUBLE, 0, "%s", mesg);

  /* notreached */
  /* Tell static analyzers that this function does not return.  */
  abort ();
}

/* Number of compiled fixed strings known to exactly match the regexp.
   If kwsexec returns < kwset_exact_matches, then we don't need to
   call the regexp matcher at all. */
static int kwset_exact_matches;

static char const *
kwsincr_case (const char *must)
{
  const char *buf;
  size_t n;

  
//Patch 0:
if ((__is_neg(5, &(must), sizeof (must), &(n), sizeof (n), &(match_icase), sizeof (match_icase), &(buf), sizeof (buf), &(kwset), sizeof (kwset))))
    return 0;
n = strlen(must);

//CodeSeg 1:
#ifdef MBS_SUPPORT
  if (match_icase && MB_CUR_MAX > 1)
    buf = mbtolower (must, &n);
  else
#endif
    buf = must;
  return kwsincr (kwset, buf, n);
}

/* If the DFA turns out to have some set of fixed strings one of
   which must occur in the match, then we build a kwset matcher
   to find those strings, and thus quickly filter out impossible
   matches. */
static void
kwsmusts (void)
{
  struct dfamust const *dm;
  char const *err;

  if (dfa.musts)
    {
      kwsinit (&kwset);
      /* First, we compile in the substrings known to be exact
	 matches.  The kwset matcher will return the index
	 of the matching string that it chooses. */
      for (dm = dfa.musts; dm; dm = dm->next)
	{
	  if (!dm->exact)
	    continue;
	  ++kwset_exact_matches;
	  if ((err = kwsincr_case (dm->must)) != NULL)
	    error (EXIT_TROUBLE, 0, "%s", err);
	}
      /* Now, we compile the substrings that will require
	 the use of the regexp matcher.  */
      for (dm = dfa.musts; dm; dm = dm->next)
	{
	  if (dm->exact)
	    continue;
	  if ((err = kwsincr_case (dm->must)) != NULL)
	    error (EXIT_TROUBLE, 0, "%s", err);
	}
      if ((err = kwsprep (kwset)) != NULL)
	error (EXIT_TROUBLE, 0, "%s", err);
    }
}

void
GEAcompile (char const *pattern, size_t size, reg_syntax_t syntax_bits)
{
  const char *err;
  const char *p, *sep;
  size_t total = size;
  char *motif;

  if (match_icase)
    syntax_bits |= RE_ICASE;
  re_set_syntax (syntax_bits);
  dfasyntax (syntax_bits, match_icase, eolbyte);

  /* For GNU regex compiler we have to pass the patterns separately to detect
     errors like "[\nallo\n]\n".  The patterns here are "[", "allo" and "]"
     GNU regex should have raise a syntax error.  The same for backref, where
     the backref should have been local to each pattern.  */
  p = pattern;
  do
    {
      size_t len;
      sep = memchr (p, '\n', total);
      if (sep)
	{
	  len = sep - p;
	  sep++;
	  total -= (len + 1);
	}
      else
	{
	  len = total;
	  total = 0;
	}

      patterns = realloc (patterns, (pcount + 1) * sizeof (*patterns));
      if (patterns == NULL)
	error (EXIT_TROUBLE, errno, _("memory exhausted"));
      patterns[pcount] = patterns0;

      if ((err = re_compile_pattern (p, len,
				    &(patterns[pcount].regexbuf))) != NULL)
	error (EXIT_TROUBLE, 0, "%s", err);
      pcount++;

      p = sep;
    } while (sep && total != 0);

  /* In the match_words and match_lines cases, we use a different pattern
     for the DFA matcher that will quickly throw out cases that won't work.
     Then if DFA succeeds we do some hairy stuff using the regex matcher
     to decide whether the match should really count. */
  if (match_words || match_lines)
    {
      static char const line_beg_no_bk[] = "^(";
      static char const line_end_no_bk[] = ")$";
      static char const word_beg_no_bk[] = "(^|[^[:alnum:]_])(";
      static char const word_end_no_bk[] = ")([^[:alnum:]_]|$)";
      static char const line_beg_bk[] = "^\\(";
      static char const line_end_bk[] = "\\)$";
      static char const word_beg_bk[] = "\\(^\\|[^[:alnum:]_]\\)\\(";
      static char const word_end_bk[] = "\\)\\([^[:alnum:]_]\\|$\\)";
      int bk = !(syntax_bits & RE_NO_BK_PARENS);
      char *n = xmalloc (sizeof word_beg_bk - 1 + size + sizeof word_end_bk);

      strcpy (n, match_lines ? (bk ? line_beg_bk : line_beg_no_bk)
			     : (bk ? word_beg_bk : word_beg_no_bk));
      total = strlen(n);
      memcpy (n + total, pattern, size);
      total += size;
      strcpy (n + total, match_lines ? (bk ? line_end_bk : line_end_no_bk)
				     : (bk ? word_end_bk : word_end_no_bk));
      total += strlen (n + total);
      pattern = motif = n;
      size = total;
    }
  else
    motif = NULL;

  dfacomp (pattern, size, &dfa, 1);
  kwsmusts ();

  free(motif);
}

size_t
EGexecute (char const *buf, size_t size, size_t *match_size,
	   char const *start_ptr)
{
  char const *buflim, *beg, *end, *match, *best_match, *mb_start;
  char eol = eolbyte;
  int backref, start, len, best_len;
  struct kwsmatch kwsm;
  size_t i, ret_val;
#ifdef MBS_SUPPORT
  if (MB_CUR_MAX > 1)
    {
      if (match_icase)
        {
          /* mbtolower adds a NUL byte at the end.  That will provide
	     space for the sentinel byte dfaexec may add.  */
          char *case_buf = mbtolower (buf, &size);
	  if (start_ptr)
	    start_ptr = case_buf + (start_ptr - buf);
          buf = case_buf;
        }
    }
#endif /* MBS_SUPPORT */

  mb_start = buf;
  buflim = buf + size;

  for (beg = end = buf; end < buflim; beg = end)
    {
      if (!start_ptr)
	{
	  /* We don't care about an exact match.  */
	  if (kwset)
	    {
	      /* Find a possible match using the KWset matcher. */
	      size_t offset = kwsexec (kwset, beg, buflim - beg, &kwsm);
	      if (offset == (size_t) -1)
		goto failure;
	      beg += offset;
	      /* Narrow down to the line containing the candidate, and
		 run it through DFA. */
	      if ((end = memchr(beg, eol, buflim - beg)) != NULL)
	        end++;
              else
                end = buflim;
	      match = beg;
	      while (beg > buf && beg[-1] != eol)
		--beg;
	      if (kwsm.index < kwset_exact_matches)
                {
#ifdef MBS_SUPPORT
                  if (mb_start < beg)
                    mb_start = beg;
                  if (MB_CUR_MAX == 1 || !is_mb_middle (&mb_start, match, buflim))
#endif
                    goto success;
                }
	      if (dfaexec (&dfa, beg, (char *) end, 0, NULL, &backref) == NULL)
		continue;
	    }
	  else
	    {
	      /* No good fixed strings; start with DFA. */
	      char const *next_beg = dfaexec (&dfa, beg, (char *) buflim,
					      0, NULL, &backref);
	      if (next_beg == NULL)
		break;
	      /* Narrow down to the line we've found. */
	      beg = next_beg;
	      if ((end = memchr(beg, eol, buflim - beg)) != NULL)
	        end++;
              else
                end = buflim;
	      while (beg > buf && beg[-1] != eol)
		--beg;
	    }
	  /* Successful, no backreferences encountered! */
	  if (!backref)
	    goto success;
	}
      else
	{
	  /* We are looking for the leftmost (then longest) exact match.
	     We will go through the outer loop only once.  */
	  beg = start_ptr;
	  end = buflim;
	}

      /* If we've made it to this point, this means DFA has seen
	 a probable match, and we need to run it through Regex. */
      best_match = end;
      best_len = 0;
      for (i = 0; i < pcount; i++)
	{
	  patterns[i].regexbuf.not_eol = 0;
	  if (0 <= (start = re_search (&(patterns[i].regexbuf),
				       buf, end - buf - 1,
				       beg - buf, end - beg - 1,
				       &(patterns[i].regs))))
	    {
	      len = patterns[i].regs.end[0] - start;
	      match = buf + start;
	      if (match > best_match)
		continue;
	      if (start_ptr && !match_words)
		goto assess_pattern_match;
	      if ((!match_lines && !match_words)
		  || (match_lines && len == end - beg - 1))
		{
		  match = beg;
		  len = end - beg;
		  goto assess_pattern_match;
		}
	      /* If -w, check if the match aligns with word boundaries.
		 We do this iteratively because:
		 (a) the line may contain more than one occurence of the
		 pattern, and
		 (b) Several alternatives in the pattern might be valid at a
		 given point, and we may need to consider a shorter one to
		 find a word boundary.  */
	      if (match_words)
		while (match <= best_match)
		  {
		    if ((match == buf || !WCHAR ((unsigned char) match[-1]))
			&& (len == end - beg - 1
			    || !WCHAR ((unsigned char) match[len])))
		      goto assess_pattern_match;
		    if (len > 0)
		      {
			/* Try a shorter length anchored at the same place. */
			--len;
			patterns[i].regexbuf.not_eol = 1;
			len = re_match (&(patterns[i].regexbuf),
					buf, match + len - beg, match - buf,
					&(patterns[i].regs));
		      }
		    if (len <= 0)
		      {
			/* Try looking further on. */
			if (match == end - 1)
			  break;
			match++;
			patterns[i].regexbuf.not_eol = 0;
			start = re_search (&(patterns[i].regexbuf),
					   buf, end - buf - 1,
					   match - buf, end - match - 1,
					   &(patterns[i].regs));
			if (start < 0)
			  break;
			len = patterns[i].regs.end[0] - start;
			match = buf + start;
		      }
		  } /* while (match <= best_match) */
	      continue;
	    assess_pattern_match:
	      if (!start_ptr)
		{
		  /* Good enough for a non-exact match.
		     No need to look at further patterns, if any.  */
		  beg = match;
		  goto success_in_len;
		}
	      if (match < best_match || (match == best_match && len > best_len))
		{
		  /* Best exact match:  leftmost, then longest.  */
		  best_match = match;
		  best_len = len;
		}
	    } /* if re_search >= 0 */
	} /* for Regex patterns.  */
	if (best_match < end)
	  {
	    /* We have found an exact match.  We were just
	       waiting for the best one (leftmost then longest).  */
	    beg = best_match;
	    len = best_len;
	    goto success_in_len;
	  }
    } /* for (beg = end ..) */

 failure:
  ret_val = -1;
  goto out;

 success:
  len = end - beg;
 success_in_len:
  *match_size = len;
  ret_val = beg - buf;
 out:
  return ret_val;
}

Spawn 1 instances, now Total 57
Counter: 58
Batcher Size:57
Preprocess the following candidate with CondTester:
Priority 10198
At location src/dfasearch.c:361
--Src File: src/dfasearch.c
Fragment 0:
if ((__abst_hole(beg, match, best_match, len, best_len, start_ptr, buf, start, i, patterns, end, ret_val, match_size, match_words, match_lines, pcount, buflim, backref, eol, mb_start, kwset_exact_matches, kwset, size, match_icase, eolbyte)))
    goto assess_pattern_match;
beg = match;


CondTester, a patch instance with id 57:
//src_file:src/dfasearch.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); void* memset(void*, int, unsigned long); 
/* dfasearch.c - searching subroutines using dfa and regex for grep.
   Copyright 1992, 1998, 2000, 2007, 2009-2010 Free Software Foundation, Inc.

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 3, or (at your option)
   any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program; if not, write to the Free Software
   Foundation, Inc., 51 Franklin Street - Fifth Floor, Boston, MA
   02110-1301, USA.  */

/* Written August 1992 by Mike Haertel. */

#include <config.h>
#include "search.h"
#include "dfa.h"

/* For -w, we also consider _ to be word constituent.  */
#define WCHAR(C) (ISALNUM(C) || (C) == '_')

/* KWset compiled pattern.  For Ecompile and Gcompile, we compile
   a list of strings, at least one of which is known to occur in
   any string matching the regexp. */
static kwset_t kwset;

/* DFA compiled regexp. */
static struct dfa dfa;

/* The Regex compiled patterns.  */
static struct patterns
{
  /* Regex compiled regexp. */
  struct re_pattern_buffer regexbuf;
  struct re_registers regs; /* This is here on account of a BRAIN-DEAD
			       Q@#%!# library interface in regex.c.  */
} patterns0;

struct patterns *patterns;
size_t pcount;

void
dfaerror (char const *mesg)
{
  error (EXIT_TROUBLE, 0, "%s", mesg);

  /* notreached */
  /* Tell static analyzers that this function does not return.  */
  abort ();
}

/* Number of compiled fixed strings known to exactly match the regexp.
   If kwsexec returns < kwset_exact_matches, then we don't need to
   call the regexp matcher at all. */
static int kwset_exact_matches;

static char const *
kwsincr_case (const char *must)
{
  const char *buf;
  size_t n;

  n = strlen (must);
#ifdef MBS_SUPPORT
  if (match_icase && MB_CUR_MAX > 1)
    buf = mbtolower (must, &n);
  else
#endif
    buf = must;
  return kwsincr (kwset, buf, n);
}

/* If the DFA turns out to have some set of fixed strings one of
   which must occur in the match, then we build a kwset matcher
   to find those strings, and thus quickly filter out impossible
   matches. */
static void
kwsmusts (void)
{
  struct dfamust const *dm;
  char const *err;

  if (dfa.musts)
    {
      kwsinit (&kwset);
      /* First, we compile in the substrings known to be exact
	 matches.  The kwset matcher will return the index
	 of the matching string that it chooses. */
      for (dm = dfa.musts; dm; dm = dm->next)
	{
	  if (!dm->exact)
	    continue;
	  ++kwset_exact_matches;
	  if ((err = kwsincr_case (dm->must)) != NULL)
	    error (EXIT_TROUBLE, 0, "%s", err);
	}
      /* Now, we compile the substrings that will require
	 the use of the regexp matcher.  */
      for (dm = dfa.musts; dm; dm = dm->next)
	{
	  if (dm->exact)
	    continue;
	  if ((err = kwsincr_case (dm->must)) != NULL)
	    error (EXIT_TROUBLE, 0, "%s", err);
	}
      if ((err = kwsprep (kwset)) != NULL)
	error (EXIT_TROUBLE, 0, "%s", err);
    }
}

void
GEAcompile (char const *pattern, size_t size, reg_syntax_t syntax_bits)
{
  const char *err;
  const char *p, *sep;
  size_t total = size;
  char *motif;

  if (match_icase)
    syntax_bits |= RE_ICASE;
  re_set_syntax (syntax_bits);
  dfasyntax (syntax_bits, match_icase, eolbyte);

  /* For GNU regex compiler we have to pass the patterns separately to detect
     errors like "[\nallo\n]\n".  The patterns here are "[", "allo" and "]"
     GNU regex should have raise a syntax error.  The same for backref, where
     the backref should have been local to each pattern.  */
  p = pattern;
  do
    {
      size_t len;
      sep = memchr (p, '\n', total);
      if (sep)
	{
	  len = sep - p;
	  sep++;
	  total -= (len + 1);
	}
      else
	{
	  len = total;
	  total = 0;
	}

      patterns = realloc (patterns, (pcount + 1) * sizeof (*patterns));
      if (patterns == NULL)
	error (EXIT_TROUBLE, errno, _("memory exhausted"));
      patterns[pcount] = patterns0;

      if ((err = re_compile_pattern (p, len,
				    &(patterns[pcount].regexbuf))) != NULL)
	error (EXIT_TROUBLE, 0, "%s", err);
      pcount++;

      p = sep;
    } while (sep && total != 0);

  /* In the match_words and match_lines cases, we use a different pattern
     for the DFA matcher that will quickly throw out cases that won't work.
     Then if DFA succeeds we do some hairy stuff using the regex matcher
     to decide whether the match should really count. */
  if (match_words || match_lines)
    {
      static char const line_beg_no_bk[] = "^(";
      static char const line_end_no_bk[] = ")$";
      static char const word_beg_no_bk[] = "(^|[^[:alnum:]_])(";
      static char const word_end_no_bk[] = ")([^[:alnum:]_]|$)";
      static char const line_beg_bk[] = "^\\(";
      static char const line_end_bk[] = "\\)$";
      static char const word_beg_bk[] = "\\(^\\|[^[:alnum:]_]\\)\\(";
      static char const word_end_bk[] = "\\)\\([^[:alnum:]_]\\|$\\)";
      int bk = !(syntax_bits & RE_NO_BK_PARENS);
      char *n = xmalloc (sizeof word_beg_bk - 1 + size + sizeof word_end_bk);

      strcpy (n, match_lines ? (bk ? line_beg_bk : line_beg_no_bk)
			     : (bk ? word_beg_bk : word_beg_no_bk));
      total = strlen(n);
      memcpy (n + total, pattern, size);
      total += size;
      strcpy (n + total, match_lines ? (bk ? line_end_bk : line_end_no_bk)
				     : (bk ? word_end_bk : word_end_no_bk));
      total += strlen (n + total);
      pattern = motif = n;
      size = total;
    }
  else
    motif = NULL;

  dfacomp (pattern, size, &dfa, 1);
  kwsmusts ();

  free(motif);
}

size_t
EGexecute (char const *buf, size_t size, size_t *match_size,
	   char const *start_ptr)
{
  char const *buflim, *beg, *end, *match, *best_match, *mb_start;
  char eol = eolbyte;
  int backref, start, len, best_len;
  struct kwsmatch kwsm;
  size_t i, ret_val;
#ifdef MBS_SUPPORT
  if (MB_CUR_MAX > 1)
    {
      if (match_icase)
        {
          /* mbtolower adds a NUL byte at the end.  That will provide
	     space for the sentinel byte dfaexec may add.  */
          char *case_buf = mbtolower (buf, &size);
	  if (start_ptr)
	    start_ptr = case_buf + (start_ptr - buf);
          buf = case_buf;
        }
    }
#endif /* MBS_SUPPORT */

  mb_start = buf;
  buflim = buf + size;

  for (beg = end = buf; end < buflim; beg = end)
    {
      if (!start_ptr)
	{
	  /* We don't care about an exact match.  */
	  if (kwset)
	    {
	      /* Find a possible match using the KWset matcher. */
	      size_t offset = kwsexec (kwset, beg, buflim - beg, &kwsm);
	      if (offset == (size_t) -1)
		goto failure;
	      beg += offset;
	      /* Narrow down to the line containing the candidate, and
		 run it through DFA. */
	      if ((end = memchr(beg, eol, buflim - beg)) != NULL)
	        end++;
              else
                end = buflim;
	      match = beg;
	      while (beg > buf && beg[-1] != eol)
		--beg;
	      if (kwsm.index < kwset_exact_matches)
                {
#ifdef MBS_SUPPORT
                  if (mb_start < beg)
                    mb_start = beg;
                  if (MB_CUR_MAX == 1 || !is_mb_middle (&mb_start, match, buflim))
#endif
                    goto success;
                }
	      if (dfaexec (&dfa, beg, (char *) end, 0, NULL, &backref) == NULL)
		continue;
	    }
	  else
	    {
	      /* No good fixed strings; start with DFA. */
	      char const *next_beg = dfaexec (&dfa, beg, (char *) buflim,
					      0, NULL, &backref);
	      if (next_beg == NULL)
		break;
	      /* Narrow down to the line we've found. */
	      beg = next_beg;
	      if ((end = memchr(beg, eol, buflim - beg)) != NULL)
	        end++;
              else
                end = buflim;
	      while (beg > buf && beg[-1] != eol)
		--beg;
	    }
	  /* Successful, no backreferences encountered! */
	  if (!backref)
	    goto success;
	}
      else
	{
	  /* We are looking for the leftmost (then longest) exact match.
	     We will go through the outer loop only once.  */
	  beg = start_ptr;
	  end = buflim;
	}

      /* If we've made it to this point, this means DFA has seen
	 a probable match, and we need to run it through Regex. */
      best_match = end;
      best_len = 0;
      for (i = 0; i < pcount; i++)
	{
	  patterns[i].regexbuf.not_eol = 0;
	  if (0 <= (start = re_search (&(patterns[i].regexbuf),
				       buf, end - buf - 1,
				       beg - buf, end - beg - 1,
				       &(patterns[i].regs))))
	    {
	      len = patterns[i].regs.end[0] - start;
	      match = buf + start;
	      if (match > best_match)
		continue;
	      if (start_ptr && !match_words)
		goto assess_pattern_match;
	      if ((!match_lines && !match_words)
		  || (match_lines && len == end - beg - 1))
		{
		  match = beg;
		  len = end - beg;
		  goto assess_pattern_match;
		}
	      /* If -w, check if the match aligns with word boundaries.
		 We do this iteratively because:
		 (a) the line may contain more than one occurence of the
		 pattern, and
		 (b) Several alternatives in the pattern might be valid at a
		 given point, and we may need to consider a shorter one to
		 find a word boundary.  */
	      if (match_words)
		while (match <= best_match)
		  {
		    if ((match == buf || !WCHAR ((unsigned char) match[-1]))
			&& (len == end - beg - 1
			    || !WCHAR ((unsigned char) match[len])))
		      goto assess_pattern_match;
		    if (len > 0)
		      {
			/* Try a shorter length anchored at the same place. */
			--len;
			patterns[i].regexbuf.not_eol = 1;
			len = re_match (&(patterns[i].regexbuf),
					buf, match + len - beg, match - buf,
					&(patterns[i].regs));
		      }
		    if (len <= 0)
		      {
			/* Try looking further on. */
			if (match == end - 1)
			  break;
			match++;
			patterns[i].regexbuf.not_eol = 0;
			start = re_search (&(patterns[i].regexbuf),
					   buf, end - buf - 1,
					   match - buf, end - match - 1,
					   &(patterns[i].regs));
			if (start < 0)
			  break;
			len = patterns[i].regs.end[0] - start;
			match = buf + start;
		      }
		  } /* while (match <= best_match) */
	      continue;
	    assess_pattern_match:
	      if (!start_ptr)
		{
		  /* Good enough for a non-exact match.
		     No need to look at further patterns, if any.  */
		  
//Patch 0:
if ((__is_neg(25, &(beg), sizeof (beg), &(match), sizeof (match), &(best_match), sizeof (best_match), &(len), sizeof (len), &(best_len), sizeof (best_len), &(start_ptr), sizeof (start_ptr), &(buf), sizeof (buf), &(start), sizeof (start), &(i), sizeof (i), &(patterns), sizeof (patterns), &(end), sizeof (end), &(ret_val), sizeof (ret_val), &(match_size), sizeof (match_size), &(match_words), sizeof (match_words), &(match_lines), sizeof (match_lines), &(pcount), sizeof (pcount), &(buflim), sizeof (buflim), &(backref), sizeof (backref), &(eol), sizeof (eol), &(mb_start), sizeof (mb_start), &(kwset_exact_matches), sizeof (kwset_exact_matches), &(kwset), sizeof (kwset), &(size), sizeof (size), &(match_icase), sizeof (match_icase), &(eolbyte), sizeof (eolbyte))))
    goto assess_pattern_match;
beg = match;

//CodeSeg 1:
		  goto success_in_len;
		}
	      if (match < best_match || (match == best_match && len > best_len))
		{
		  /* Best exact match:  leftmost, then longest.  */
		  best_match = match;
		  best_len = len;
		}
	    } /* if re_search >= 0 */
	} /* for Regex patterns.  */
	if (best_match < end)
	  {
	    /* We have found an exact match.  We were just
	       waiting for the best one (leftmost then longest).  */
	    beg = best_match;
	    len = best_len;
	    goto success_in_len;
	  }
    } /* for (beg = end ..) */

 failure:
  ret_val = -1;
  goto out;

 success:
  len = end - beg;
 success_in_len:
  *match_size = len;
  ret_val = beg - buf;
 out:
  return ret_val;
}

Spawn 1 instances, now Total 58
Counter: 59
Batcher Size:58
Preprocess the following candidate with CondTester:
Priority 10198
At location src/dfasearch.c:361
--Src File: src/dfasearch.c
Fragment 0:
if ((__abst_hole(beg, match, best_match, len, best_len, start_ptr, buf, start, i, patterns, end, ret_val, match_size, match_words, match_lines, pcount, buflim, backref, eol, mb_start, kwset_exact_matches, kwset, size, match_icase, eolbyte)))
    goto failure;
beg = match;


CondTester, a patch instance with id 58:
//src_file:src/dfasearch.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); void* memset(void*, int, unsigned long); 
/* dfasearch.c - searching subroutines using dfa and regex for grep.
   Copyright 1992, 1998, 2000, 2007, 2009-2010 Free Software Foundation, Inc.

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 3, or (at your option)
   any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program; if not, write to the Free Software
   Foundation, Inc., 51 Franklin Street - Fifth Floor, Boston, MA
   02110-1301, USA.  */

/* Written August 1992 by Mike Haertel. */

#include <config.h>
#include "search.h"
#include "dfa.h"

/* For -w, we also consider _ to be word constituent.  */
#define WCHAR(C) (ISALNUM(C) || (C) == '_')

/* KWset compiled pattern.  For Ecompile and Gcompile, we compile
   a list of strings, at least one of which is known to occur in
   any string matching the regexp. */
static kwset_t kwset;

/* DFA compiled regexp. */
static struct dfa dfa;

/* The Regex compiled patterns.  */
static struct patterns
{
  /* Regex compiled regexp. */
  struct re_pattern_buffer regexbuf;
  struct re_registers regs; /* This is here on account of a BRAIN-DEAD
			       Q@#%!# library interface in regex.c.  */
} patterns0;

struct patterns *patterns;
size_t pcount;

void
dfaerror (char const *mesg)
{
  error (EXIT_TROUBLE, 0, "%s", mesg);

  /* notreached */
  /* Tell static analyzers that this function does not return.  */
  abort ();
}

/* Number of compiled fixed strings known to exactly match the regexp.
   If kwsexec returns < kwset_exact_matches, then we don't need to
   call the regexp matcher at all. */
static int kwset_exact_matches;

static char const *
kwsincr_case (const char *must)
{
  const char *buf;
  size_t n;

  n = strlen (must);
#ifdef MBS_SUPPORT
  if (match_icase && MB_CUR_MAX > 1)
    buf = mbtolower (must, &n);
  else
#endif
    buf = must;
  return kwsincr (kwset, buf, n);
}

/* If the DFA turns out to have some set of fixed strings one of
   which must occur in the match, then we build a kwset matcher
   to find those strings, and thus quickly filter out impossible
   matches. */
static void
kwsmusts (void)
{
  struct dfamust const *dm;
  char const *err;

  if (dfa.musts)
    {
      kwsinit (&kwset);
      /* First, we compile in the substrings known to be exact
	 matches.  The kwset matcher will return the index
	 of the matching string that it chooses. */
      for (dm = dfa.musts; dm; dm = dm->next)
	{
	  if (!dm->exact)
	    continue;
	  ++kwset_exact_matches;
	  if ((err = kwsincr_case (dm->must)) != NULL)
	    error (EXIT_TROUBLE, 0, "%s", err);
	}
      /* Now, we compile the substrings that will require
	 the use of the regexp matcher.  */
      for (dm = dfa.musts; dm; dm = dm->next)
	{
	  if (dm->exact)
	    continue;
	  if ((err = kwsincr_case (dm->must)) != NULL)
	    error (EXIT_TROUBLE, 0, "%s", err);
	}
      if ((err = kwsprep (kwset)) != NULL)
	error (EXIT_TROUBLE, 0, "%s", err);
    }
}

void
GEAcompile (char const *pattern, size_t size, reg_syntax_t syntax_bits)
{
  const char *err;
  const char *p, *sep;
  size_t total = size;
  char *motif;

  if (match_icase)
    syntax_bits |= RE_ICASE;
  re_set_syntax (syntax_bits);
  dfasyntax (syntax_bits, match_icase, eolbyte);

  /* For GNU regex compiler we have to pass the patterns separately to detect
     errors like "[\nallo\n]\n".  The patterns here are "[", "allo" and "]"
     GNU regex should have raise a syntax error.  The same for backref, where
     the backref should have been local to each pattern.  */
  p = pattern;
  do
    {
      size_t len;
      sep = memchr (p, '\n', total);
      if (sep)
	{
	  len = sep - p;
	  sep++;
	  total -= (len + 1);
	}
      else
	{
	  len = total;
	  total = 0;
	}

      patterns = realloc (patterns, (pcount + 1) * sizeof (*patterns));
      if (patterns == NULL)
	error (EXIT_TROUBLE, errno, _("memory exhausted"));
      patterns[pcount] = patterns0;

      if ((err = re_compile_pattern (p, len,
				    &(patterns[pcount].regexbuf))) != NULL)
	error (EXIT_TROUBLE, 0, "%s", err);
      pcount++;

      p = sep;
    } while (sep && total != 0);

  /* In the match_words and match_lines cases, we use a different pattern
     for the DFA matcher that will quickly throw out cases that won't work.
     Then if DFA succeeds we do some hairy stuff using the regex matcher
     to decide whether the match should really count. */
  if (match_words || match_lines)
    {
      static char const line_beg_no_bk[] = "^(";
      static char const line_end_no_bk[] = ")$";
      static char const word_beg_no_bk[] = "(^|[^[:alnum:]_])(";
      static char const word_end_no_bk[] = ")([^[:alnum:]_]|$)";
      static char const line_beg_bk[] = "^\\(";
      static char const line_end_bk[] = "\\)$";
      static char const word_beg_bk[] = "\\(^\\|[^[:alnum:]_]\\)\\(";
      static char const word_end_bk[] = "\\)\\([^[:alnum:]_]\\|$\\)";
      int bk = !(syntax_bits & RE_NO_BK_PARENS);
      char *n = xmalloc (sizeof word_beg_bk - 1 + size + sizeof word_end_bk);

      strcpy (n, match_lines ? (bk ? line_beg_bk : line_beg_no_bk)
			     : (bk ? word_beg_bk : word_beg_no_bk));
      total = strlen(n);
      memcpy (n + total, pattern, size);
      total += size;
      strcpy (n + total, match_lines ? (bk ? line_end_bk : line_end_no_bk)
				     : (bk ? word_end_bk : word_end_no_bk));
      total += strlen (n + total);
      pattern = motif = n;
      size = total;
    }
  else
    motif = NULL;

  dfacomp (pattern, size, &dfa, 1);
  kwsmusts ();

  free(motif);
}

size_t
EGexecute (char const *buf, size_t size, size_t *match_size,
	   char const *start_ptr)
{
  char const *buflim, *beg, *end, *match, *best_match, *mb_start;
  char eol = eolbyte;
  int backref, start, len, best_len;
  struct kwsmatch kwsm;
  size_t i, ret_val;
#ifdef MBS_SUPPORT
  if (MB_CUR_MAX > 1)
    {
      if (match_icase)
        {
          /* mbtolower adds a NUL byte at the end.  That will provide
	     space for the sentinel byte dfaexec may add.  */
          char *case_buf = mbtolower (buf, &size);
	  if (start_ptr)
	    start_ptr = case_buf + (start_ptr - buf);
          buf = case_buf;
        }
    }
#endif /* MBS_SUPPORT */

  mb_start = buf;
  buflim = buf + size;

  for (beg = end = buf; end < buflim; beg = end)
    {
      if (!start_ptr)
	{
	  /* We don't care about an exact match.  */
	  if (kwset)
	    {
	      /* Find a possible match using the KWset matcher. */
	      size_t offset = kwsexec (kwset, beg, buflim - beg, &kwsm);
	      if (offset == (size_t) -1)
		goto failure;
	      beg += offset;
	      /* Narrow down to the line containing the candidate, and
		 run it through DFA. */
	      if ((end = memchr(beg, eol, buflim - beg)) != NULL)
	        end++;
              else
                end = buflim;
	      match = beg;
	      while (beg > buf && beg[-1] != eol)
		--beg;
	      if (kwsm.index < kwset_exact_matches)
                {
#ifdef MBS_SUPPORT
                  if (mb_start < beg)
                    mb_start = beg;
                  if (MB_CUR_MAX == 1 || !is_mb_middle (&mb_start, match, buflim))
#endif
                    goto success;
                }
	      if (dfaexec (&dfa, beg, (char *) end, 0, NULL, &backref) == NULL)
		continue;
	    }
	  else
	    {
	      /* No good fixed strings; start with DFA. */
	      char const *next_beg = dfaexec (&dfa, beg, (char *) buflim,
					      0, NULL, &backref);
	      if (next_beg == NULL)
		break;
	      /* Narrow down to the line we've found. */
	      beg = next_beg;
	      if ((end = memchr(beg, eol, buflim - beg)) != NULL)
	        end++;
              else
                end = buflim;
	      while (beg > buf && beg[-1] != eol)
		--beg;
	    }
	  /* Successful, no backreferences encountered! */
	  if (!backref)
	    goto success;
	}
      else
	{
	  /* We are looking for the leftmost (then longest) exact match.
	     We will go through the outer loop only once.  */
	  beg = start_ptr;
	  end = buflim;
	}

      /* If we've made it to this point, this means DFA has seen
	 a probable match, and we need to run it through Regex. */
      best_match = end;
      best_len = 0;
      for (i = 0; i < pcount; i++)
	{
	  patterns[i].regexbuf.not_eol = 0;
	  if (0 <= (start = re_search (&(patterns[i].regexbuf),
				       buf, end - buf - 1,
				       beg - buf, end - beg - 1,
				       &(patterns[i].regs))))
	    {
	      len = patterns[i].regs.end[0] - start;
	      match = buf + start;
	      if (match > best_match)
		continue;
	      if (start_ptr && !match_words)
		goto assess_pattern_match;
	      if ((!match_lines && !match_words)
		  || (match_lines && len == end - beg - 1))
		{
		  match = beg;
		  len = end - beg;
		  goto assess_pattern_match;
		}
	      /* If -w, check if the match aligns with word boundaries.
		 We do this iteratively because:
		 (a) the line may contain more than one occurence of the
		 pattern, and
		 (b) Several alternatives in the pattern might be valid at a
		 given point, and we may need to consider a shorter one to
		 find a word boundary.  */
	      if (match_words)
		while (match <= best_match)
		  {
		    if ((match == buf || !WCHAR ((unsigned char) match[-1]))
			&& (len == end - beg - 1
			    || !WCHAR ((unsigned char) match[len])))
		      goto assess_pattern_match;
		    if (len > 0)
		      {
			/* Try a shorter length anchored at the same place. */
			--len;
			patterns[i].regexbuf.not_eol = 1;
			len = re_match (&(patterns[i].regexbuf),
					buf, match + len - beg, match - buf,
					&(patterns[i].regs));
		      }
		    if (len <= 0)
		      {
			/* Try looking further on. */
			if (match == end - 1)
			  break;
			match++;
			patterns[i].regexbuf.not_eol = 0;
			start = re_search (&(patterns[i].regexbuf),
					   buf, end - buf - 1,
					   match - buf, end - match - 1,
					   &(patterns[i].regs));
			if (start < 0)
			  break;
			len = patterns[i].regs.end[0] - start;
			match = buf + start;
		      }
		  } /* while (match <= best_match) */
	      continue;
	    assess_pattern_match:
	      if (!start_ptr)
		{
		  /* Good enough for a non-exact match.
		     No need to look at further patterns, if any.  */
		  
//Patch 0:
if ((__is_neg(25, &(beg), sizeof (beg), &(match), sizeof (match), &(best_match), sizeof (best_match), &(len), sizeof (len), &(best_len), sizeof (best_len), &(start_ptr), sizeof (start_ptr), &(buf), sizeof (buf), &(start), sizeof (start), &(i), sizeof (i), &(patterns), sizeof (patterns), &(end), sizeof (end), &(ret_val), sizeof (ret_val), &(match_size), sizeof (match_size), &(match_words), sizeof (match_words), &(match_lines), sizeof (match_lines), &(pcount), sizeof (pcount), &(buflim), sizeof (buflim), &(backref), sizeof (backref), &(eol), sizeof (eol), &(mb_start), sizeof (mb_start), &(kwset_exact_matches), sizeof (kwset_exact_matches), &(kwset), sizeof (kwset), &(size), sizeof (size), &(match_icase), sizeof (match_icase), &(eolbyte), sizeof (eolbyte))))
    goto failure;
beg = match;

//CodeSeg 1:
		  goto success_in_len;
		}
	      if (match < best_match || (match == best_match && len > best_len))
		{
		  /* Best exact match:  leftmost, then longest.  */
		  best_match = match;
		  best_len = len;
		}
	    } /* if re_search >= 0 */
	} /* for Regex patterns.  */
	if (best_match < end)
	  {
	    /* We have found an exact match.  We were just
	       waiting for the best one (leftmost then longest).  */
	    beg = best_match;
	    len = best_len;
	    goto success_in_len;
	  }
    } /* for (beg = end ..) */

 failure:
  ret_val = -1;
  goto out;

 success:
  len = end - beg;
 success_in_len:
  *match_size = len;
  ret_val = beg - buf;
 out:
  return ret_val;
}

Spawn 1 instances, now Total 59
Counter: 60
Batcher Size:59
Preprocess the following candidate with CondTester:
Priority 10198
At location src/dfasearch.c:361
--Src File: src/dfasearch.c
Fragment 0:
if ((__abst_hole(beg, match, best_match, len, best_len, start_ptr, buf, start, i, patterns, end, ret_val, match_size, match_words, match_lines, pcount, buflim, backref, eol, mb_start, kwset_exact_matches, kwset, size, match_icase, eolbyte)))
    goto success;
beg = match;


CondTester, a patch instance with id 59:
//src_file:src/dfasearch.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); void* memset(void*, int, unsigned long); 
/* dfasearch.c - searching subroutines using dfa and regex for grep.
   Copyright 1992, 1998, 2000, 2007, 2009-2010 Free Software Foundation, Inc.

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 3, or (at your option)
   any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program; if not, write to the Free Software
   Foundation, Inc., 51 Franklin Street - Fifth Floor, Boston, MA
   02110-1301, USA.  */

/* Written August 1992 by Mike Haertel. */

#include <config.h>
#include "search.h"
#include "dfa.h"

/* For -w, we also consider _ to be word constituent.  */
#define WCHAR(C) (ISALNUM(C) || (C) == '_')

/* KWset compiled pattern.  For Ecompile and Gcompile, we compile
   a list of strings, at least one of which is known to occur in
   any string matching the regexp. */
static kwset_t kwset;

/* DFA compiled regexp. */
static struct dfa dfa;

/* The Regex compiled patterns.  */
static struct patterns
{
  /* Regex compiled regexp. */
  struct re_pattern_buffer regexbuf;
  struct re_registers regs; /* This is here on account of a BRAIN-DEAD
			       Q@#%!# library interface in regex.c.  */
} patterns0;

struct patterns *patterns;
size_t pcount;

void
dfaerror (char const *mesg)
{
  error (EXIT_TROUBLE, 0, "%s", mesg);

  /* notreached */
  /* Tell static analyzers that this function does not return.  */
  abort ();
}

/* Number of compiled fixed strings known to exactly match the regexp.
   If kwsexec returns < kwset_exact_matches, then we don't need to
   call the regexp matcher at all. */
static int kwset_exact_matches;

static char const *
kwsincr_case (const char *must)
{
  const char *buf;
  size_t n;

  n = strlen (must);
#ifdef MBS_SUPPORT
  if (match_icase && MB_CUR_MAX > 1)
    buf = mbtolower (must, &n);
  else
#endif
    buf = must;
  return kwsincr (kwset, buf, n);
}

/* If the DFA turns out to have some set of fixed strings one of
   which must occur in the match, then we build a kwset matcher
   to find those strings, and thus quickly filter out impossible
   matches. */
static void
kwsmusts (void)
{
  struct dfamust const *dm;
  char const *err;

  if (dfa.musts)
    {
      kwsinit (&kwset);
      /* First, we compile in the substrings known to be exact
	 matches.  The kwset matcher will return the index
	 of the matching string that it chooses. */
      for (dm = dfa.musts; dm; dm = dm->next)
	{
	  if (!dm->exact)
	    continue;
	  ++kwset_exact_matches;
	  if ((err = kwsincr_case (dm->must)) != NULL)
	    error (EXIT_TROUBLE, 0, "%s", err);
	}
      /* Now, we compile the substrings that will require
	 the use of the regexp matcher.  */
      for (dm = dfa.musts; dm; dm = dm->next)
	{
	  if (dm->exact)
	    continue;
	  if ((err = kwsincr_case (dm->must)) != NULL)
	    error (EXIT_TROUBLE, 0, "%s", err);
	}
      if ((err = kwsprep (kwset)) != NULL)
	error (EXIT_TROUBLE, 0, "%s", err);
    }
}

void
GEAcompile (char const *pattern, size_t size, reg_syntax_t syntax_bits)
{
  const char *err;
  const char *p, *sep;
  size_t total = size;
  char *motif;

  if (match_icase)
    syntax_bits |= RE_ICASE;
  re_set_syntax (syntax_bits);
  dfasyntax (syntax_bits, match_icase, eolbyte);

  /* For GNU regex compiler we have to pass the patterns separately to detect
     errors like "[\nallo\n]\n".  The patterns here are "[", "allo" and "]"
     GNU regex should have raise a syntax error.  The same for backref, where
     the backref should have been local to each pattern.  */
  p = pattern;
  do
    {
      size_t len;
      sep = memchr (p, '\n', total);
      if (sep)
	{
	  len = sep - p;
	  sep++;
	  total -= (len + 1);
	}
      else
	{
	  len = total;
	  total = 0;
	}

      patterns = realloc (patterns, (pcount + 1) * sizeof (*patterns));
      if (patterns == NULL)
	error (EXIT_TROUBLE, errno, _("memory exhausted"));
      patterns[pcount] = patterns0;

      if ((err = re_compile_pattern (p, len,
				    &(patterns[pcount].regexbuf))) != NULL)
	error (EXIT_TROUBLE, 0, "%s", err);
      pcount++;

      p = sep;
    } while (sep && total != 0);

  /* In the match_words and match_lines cases, we use a different pattern
     for the DFA matcher that will quickly throw out cases that won't work.
     Then if DFA succeeds we do some hairy stuff using the regex matcher
     to decide whether the match should really count. */
  if (match_words || match_lines)
    {
      static char const line_beg_no_bk[] = "^(";
      static char const line_end_no_bk[] = ")$";
      static char const word_beg_no_bk[] = "(^|[^[:alnum:]_])(";
      static char const word_end_no_bk[] = ")([^[:alnum:]_]|$)";
      static char const line_beg_bk[] = "^\\(";
      static char const line_end_bk[] = "\\)$";
      static char const word_beg_bk[] = "\\(^\\|[^[:alnum:]_]\\)\\(";
      static char const word_end_bk[] = "\\)\\([^[:alnum:]_]\\|$\\)";
      int bk = !(syntax_bits & RE_NO_BK_PARENS);
      char *n = xmalloc (sizeof word_beg_bk - 1 + size + sizeof word_end_bk);

      strcpy (n, match_lines ? (bk ? line_beg_bk : line_beg_no_bk)
			     : (bk ? word_beg_bk : word_beg_no_bk));
      total = strlen(n);
      memcpy (n + total, pattern, size);
      total += size;
      strcpy (n + total, match_lines ? (bk ? line_end_bk : line_end_no_bk)
				     : (bk ? word_end_bk : word_end_no_bk));
      total += strlen (n + total);
      pattern = motif = n;
      size = total;
    }
  else
    motif = NULL;

  dfacomp (pattern, size, &dfa, 1);
  kwsmusts ();

  free(motif);
}

size_t
EGexecute (char const *buf, size_t size, size_t *match_size,
	   char const *start_ptr)
{
  char const *buflim, *beg, *end, *match, *best_match, *mb_start;
  char eol = eolbyte;
  int backref, start, len, best_len;
  struct kwsmatch kwsm;
  size_t i, ret_val;
#ifdef MBS_SUPPORT
  if (MB_CUR_MAX > 1)
    {
      if (match_icase)
        {
          /* mbtolower adds a NUL byte at the end.  That will provide
	     space for the sentinel byte dfaexec may add.  */
          char *case_buf = mbtolower (buf, &size);
	  if (start_ptr)
	    start_ptr = case_buf + (start_ptr - buf);
          buf = case_buf;
        }
    }
#endif /* MBS_SUPPORT */

  mb_start = buf;
  buflim = buf + size;

  for (beg = end = buf; end < buflim; beg = end)
    {
      if (!start_ptr)
	{
	  /* We don't care about an exact match.  */
	  if (kwset)
	    {
	      /* Find a possible match using the KWset matcher. */
	      size_t offset = kwsexec (kwset, beg, buflim - beg, &kwsm);
	      if (offset == (size_t) -1)
		goto failure;
	      beg += offset;
	      /* Narrow down to the line containing the candidate, and
		 run it through DFA. */
	      if ((end = memchr(beg, eol, buflim - beg)) != NULL)
	        end++;
              else
                end = buflim;
	      match = beg;
	      while (beg > buf && beg[-1] != eol)
		--beg;
	      if (kwsm.index < kwset_exact_matches)
                {
#ifdef MBS_SUPPORT
                  if (mb_start < beg)
                    mb_start = beg;
                  if (MB_CUR_MAX == 1 || !is_mb_middle (&mb_start, match, buflim))
#endif
                    goto success;
                }
	      if (dfaexec (&dfa, beg, (char *) end, 0, NULL, &backref) == NULL)
		continue;
	    }
	  else
	    {
	      /* No good fixed strings; start with DFA. */
	      char const *next_beg = dfaexec (&dfa, beg, (char *) buflim,
					      0, NULL, &backref);
	      if (next_beg == NULL)
		break;
	      /* Narrow down to the line we've found. */
	      beg = next_beg;
	      if ((end = memchr(beg, eol, buflim - beg)) != NULL)
	        end++;
              else
                end = buflim;
	      while (beg > buf && beg[-1] != eol)
		--beg;
	    }
	  /* Successful, no backreferences encountered! */
	  if (!backref)
	    goto success;
	}
      else
	{
	  /* We are looking for the leftmost (then longest) exact match.
	     We will go through the outer loop only once.  */
	  beg = start_ptr;
	  end = buflim;
	}

      /* If we've made it to this point, this means DFA has seen
	 a probable match, and we need to run it through Regex. */
      best_match = end;
      best_len = 0;
      for (i = 0; i < pcount; i++)
	{
	  patterns[i].regexbuf.not_eol = 0;
	  if (0 <= (start = re_search (&(patterns[i].regexbuf),
				       buf, end - buf - 1,
				       beg - buf, end - beg - 1,
				       &(patterns[i].regs))))
	    {
	      len = patterns[i].regs.end[0] - start;
	      match = buf + start;
	      if (match > best_match)
		continue;
	      if (start_ptr && !match_words)
		goto assess_pattern_match;
	      if ((!match_lines && !match_words)
		  || (match_lines && len == end - beg - 1))
		{
		  match = beg;
		  len = end - beg;
		  goto assess_pattern_match;
		}
	      /* If -w, check if the match aligns with word boundaries.
		 We do this iteratively because:
		 (a) the line may contain more than one occurence of the
		 pattern, and
		 (b) Several alternatives in the pattern might be valid at a
		 given point, and we may need to consider a shorter one to
		 find a word boundary.  */
	      if (match_words)
		while (match <= best_match)
		  {
		    if ((match == buf || !WCHAR ((unsigned char) match[-1]))
			&& (len == end - beg - 1
			    || !WCHAR ((unsigned char) match[len])))
		      goto assess_pattern_match;
		    if (len > 0)
		      {
			/* Try a shorter length anchored at the same place. */
			--len;
			patterns[i].regexbuf.not_eol = 1;
			len = re_match (&(patterns[i].regexbuf),
					buf, match + len - beg, match - buf,
					&(patterns[i].regs));
		      }
		    if (len <= 0)
		      {
			/* Try looking further on. */
			if (match == end - 1)
			  break;
			match++;
			patterns[i].regexbuf.not_eol = 0;
			start = re_search (&(patterns[i].regexbuf),
					   buf, end - buf - 1,
					   match - buf, end - match - 1,
					   &(patterns[i].regs));
			if (start < 0)
			  break;
			len = patterns[i].regs.end[0] - start;
			match = buf + start;
		      }
		  } /* while (match <= best_match) */
	      continue;
	    assess_pattern_match:
	      if (!start_ptr)
		{
		  /* Good enough for a non-exact match.
		     No need to look at further patterns, if any.  */
		  
//Patch 0:
if ((__is_neg(25, &(beg), sizeof (beg), &(match), sizeof (match), &(best_match), sizeof (best_match), &(len), sizeof (len), &(best_len), sizeof (best_len), &(start_ptr), sizeof (start_ptr), &(buf), sizeof (buf), &(start), sizeof (start), &(i), sizeof (i), &(patterns), sizeof (patterns), &(end), sizeof (end), &(ret_val), sizeof (ret_val), &(match_size), sizeof (match_size), &(match_words), sizeof (match_words), &(match_lines), sizeof (match_lines), &(pcount), sizeof (pcount), &(buflim), sizeof (buflim), &(backref), sizeof (backref), &(eol), sizeof (eol), &(mb_start), sizeof (mb_start), &(kwset_exact_matches), sizeof (kwset_exact_matches), &(kwset), sizeof (kwset), &(size), sizeof (size), &(match_icase), sizeof (match_icase), &(eolbyte), sizeof (eolbyte))))
    goto success;
beg = match;

//CodeSeg 1:
		  goto success_in_len;
		}
	      if (match < best_match || (match == best_match && len > best_len))
		{
		  /* Best exact match:  leftmost, then longest.  */
		  best_match = match;
		  best_len = len;
		}
	    } /* if re_search >= 0 */
	} /* for Regex patterns.  */
	if (best_match < end)
	  {
	    /* We have found an exact match.  We were just
	       waiting for the best one (leftmost then longest).  */
	    beg = best_match;
	    len = best_len;
	    goto success_in_len;
	  }
    } /* for (beg = end ..) */

 failure:
  ret_val = -1;
  goto out;

 success:
  len = end - beg;
 success_in_len:
  *match_size = len;
  ret_val = beg - buf;
 out:
  return ret_val;
}

Spawn 1 instances, now Total 60
Counter: 61
Batcher Size:60
Preprocess the following candidate with CondTester:
Priority 10198
At location src/dfasearch.c:361
--Src File: src/dfasearch.c
Fragment 0:
if ((__abst_hole(beg, match, best_match, len, best_len, start_ptr, buf, start, i, patterns, end, ret_val, match_size, match_words, match_lines, pcount, buflim, backref, eol, mb_start, kwset_exact_matches, kwset, size, match_icase, eolbyte)))
    goto success_in_len;
beg = match;


CondTester, a patch instance with id 60:
//src_file:src/dfasearch.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); void* memset(void*, int, unsigned long); 
/* dfasearch.c - searching subroutines using dfa and regex for grep.
   Copyright 1992, 1998, 2000, 2007, 2009-2010 Free Software Foundation, Inc.

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 3, or (at your option)
   any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program; if not, write to the Free Software
   Foundation, Inc., 51 Franklin Street - Fifth Floor, Boston, MA
   02110-1301, USA.  */

/* Written August 1992 by Mike Haertel. */

#include <config.h>
#include "search.h"
#include "dfa.h"

/* For -w, we also consider _ to be word constituent.  */
#define WCHAR(C) (ISALNUM(C) || (C) == '_')

/* KWset compiled pattern.  For Ecompile and Gcompile, we compile
   a list of strings, at least one of which is known to occur in
   any string matching the regexp. */
static kwset_t kwset;

/* DFA compiled regexp. */
static struct dfa dfa;

/* The Regex compiled patterns.  */
static struct patterns
{
  /* Regex compiled regexp. */
  struct re_pattern_buffer regexbuf;
  struct re_registers regs; /* This is here on account of a BRAIN-DEAD
			       Q@#%!# library interface in regex.c.  */
} patterns0;

struct patterns *patterns;
size_t pcount;

void
dfaerror (char const *mesg)
{
  error (EXIT_TROUBLE, 0, "%s", mesg);

  /* notreached */
  /* Tell static analyzers that this function does not return.  */
  abort ();
}

/* Number of compiled fixed strings known to exactly match the regexp.
   If kwsexec returns < kwset_exact_matches, then we don't need to
   call the regexp matcher at all. */
static int kwset_exact_matches;

static char const *
kwsincr_case (const char *must)
{
  const char *buf;
  size_t n;

  n = strlen (must);
#ifdef MBS_SUPPORT
  if (match_icase && MB_CUR_MAX > 1)
    buf = mbtolower (must, &n);
  else
#endif
    buf = must;
  return kwsincr (kwset, buf, n);
}

/* If the DFA turns out to have some set of fixed strings one of
   which must occur in the match, then we build a kwset matcher
   to find those strings, and thus quickly filter out impossible
   matches. */
static void
kwsmusts (void)
{
  struct dfamust const *dm;
  char const *err;

  if (dfa.musts)
    {
      kwsinit (&kwset);
      /* First, we compile in the substrings known to be exact
	 matches.  The kwset matcher will return the index
	 of the matching string that it chooses. */
      for (dm = dfa.musts; dm; dm = dm->next)
	{
	  if (!dm->exact)
	    continue;
	  ++kwset_exact_matches;
	  if ((err = kwsincr_case (dm->must)) != NULL)
	    error (EXIT_TROUBLE, 0, "%s", err);
	}
      /* Now, we compile the substrings that will require
	 the use of the regexp matcher.  */
      for (dm = dfa.musts; dm; dm = dm->next)
	{
	  if (dm->exact)
	    continue;
	  if ((err = kwsincr_case (dm->must)) != NULL)
	    error (EXIT_TROUBLE, 0, "%s", err);
	}
      if ((err = kwsprep (kwset)) != NULL)
	error (EXIT_TROUBLE, 0, "%s", err);
    }
}

void
GEAcompile (char const *pattern, size_t size, reg_syntax_t syntax_bits)
{
  const char *err;
  const char *p, *sep;
  size_t total = size;
  char *motif;

  if (match_icase)
    syntax_bits |= RE_ICASE;
  re_set_syntax (syntax_bits);
  dfasyntax (syntax_bits, match_icase, eolbyte);

  /* For GNU regex compiler we have to pass the patterns separately to detect
     errors like "[\nallo\n]\n".  The patterns here are "[", "allo" and "]"
     GNU regex should have raise a syntax error.  The same for backref, where
     the backref should have been local to each pattern.  */
  p = pattern;
  do
    {
      size_t len;
      sep = memchr (p, '\n', total);
      if (sep)
	{
	  len = sep - p;
	  sep++;
	  total -= (len + 1);
	}
      else
	{
	  len = total;
	  total = 0;
	}

      patterns = realloc (patterns, (pcount + 1) * sizeof (*patterns));
      if (patterns == NULL)
	error (EXIT_TROUBLE, errno, _("memory exhausted"));
      patterns[pcount] = patterns0;

      if ((err = re_compile_pattern (p, len,
				    &(patterns[pcount].regexbuf))) != NULL)
	error (EXIT_TROUBLE, 0, "%s", err);
      pcount++;

      p = sep;
    } while (sep && total != 0);

  /* In the match_words and match_lines cases, we use a different pattern
     for the DFA matcher that will quickly throw out cases that won't work.
     Then if DFA succeeds we do some hairy stuff using the regex matcher
     to decide whether the match should really count. */
  if (match_words || match_lines)
    {
      static char const line_beg_no_bk[] = "^(";
      static char const line_end_no_bk[] = ")$";
      static char const word_beg_no_bk[] = "(^|[^[:alnum:]_])(";
      static char const word_end_no_bk[] = ")([^[:alnum:]_]|$)";
      static char const line_beg_bk[] = "^\\(";
      static char const line_end_bk[] = "\\)$";
      static char const word_beg_bk[] = "\\(^\\|[^[:alnum:]_]\\)\\(";
      static char const word_end_bk[] = "\\)\\([^[:alnum:]_]\\|$\\)";
      int bk = !(syntax_bits & RE_NO_BK_PARENS);
      char *n = xmalloc (sizeof word_beg_bk - 1 + size + sizeof word_end_bk);

      strcpy (n, match_lines ? (bk ? line_beg_bk : line_beg_no_bk)
			     : (bk ? word_beg_bk : word_beg_no_bk));
      total = strlen(n);
      memcpy (n + total, pattern, size);
      total += size;
      strcpy (n + total, match_lines ? (bk ? line_end_bk : line_end_no_bk)
				     : (bk ? word_end_bk : word_end_no_bk));
      total += strlen (n + total);
      pattern = motif = n;
      size = total;
    }
  else
    motif = NULL;

  dfacomp (pattern, size, &dfa, 1);
  kwsmusts ();

  free(motif);
}

size_t
EGexecute (char const *buf, size_t size, size_t *match_size,
	   char const *start_ptr)
{
  char const *buflim, *beg, *end, *match, *best_match, *mb_start;
  char eol = eolbyte;
  int backref, start, len, best_len;
  struct kwsmatch kwsm;
  size_t i, ret_val;
#ifdef MBS_SUPPORT
  if (MB_CUR_MAX > 1)
    {
      if (match_icase)
        {
          /* mbtolower adds a NUL byte at the end.  That will provide
	     space for the sentinel byte dfaexec may add.  */
          char *case_buf = mbtolower (buf, &size);
	  if (start_ptr)
	    start_ptr = case_buf + (start_ptr - buf);
          buf = case_buf;
        }
    }
#endif /* MBS_SUPPORT */

  mb_start = buf;
  buflim = buf + size;

  for (beg = end = buf; end < buflim; beg = end)
    {
      if (!start_ptr)
	{
	  /* We don't care about an exact match.  */
	  if (kwset)
	    {
	      /* Find a possible match using the KWset matcher. */
	      size_t offset = kwsexec (kwset, beg, buflim - beg, &kwsm);
	      if (offset == (size_t) -1)
		goto failure;
	      beg += offset;
	      /* Narrow down to the line containing the candidate, and
		 run it through DFA. */
	      if ((end = memchr(beg, eol, buflim - beg)) != NULL)
	        end++;
              else
                end = buflim;
	      match = beg;
	      while (beg > buf && beg[-1] != eol)
		--beg;
	      if (kwsm.index < kwset_exact_matches)
                {
#ifdef MBS_SUPPORT
                  if (mb_start < beg)
                    mb_start = beg;
                  if (MB_CUR_MAX == 1 || !is_mb_middle (&mb_start, match, buflim))
#endif
                    goto success;
                }
	      if (dfaexec (&dfa, beg, (char *) end, 0, NULL, &backref) == NULL)
		continue;
	    }
	  else
	    {
	      /* No good fixed strings; start with DFA. */
	      char const *next_beg = dfaexec (&dfa, beg, (char *) buflim,
					      0, NULL, &backref);
	      if (next_beg == NULL)
		break;
	      /* Narrow down to the line we've found. */
	      beg = next_beg;
	      if ((end = memchr(beg, eol, buflim - beg)) != NULL)
	        end++;
              else
                end = buflim;
	      while (beg > buf && beg[-1] != eol)
		--beg;
	    }
	  /* Successful, no backreferences encountered! */
	  if (!backref)
	    goto success;
	}
      else
	{
	  /* We are looking for the leftmost (then longest) exact match.
	     We will go through the outer loop only once.  */
	  beg = start_ptr;
	  end = buflim;
	}

      /* If we've made it to this point, this means DFA has seen
	 a probable match, and we need to run it through Regex. */
      best_match = end;
      best_len = 0;
      for (i = 0; i < pcount; i++)
	{
	  patterns[i].regexbuf.not_eol = 0;
	  if (0 <= (start = re_search (&(patterns[i].regexbuf),
				       buf, end - buf - 1,
				       beg - buf, end - beg - 1,
				       &(patterns[i].regs))))
	    {
	      len = patterns[i].regs.end[0] - start;
	      match = buf + start;
	      if (match > best_match)
		continue;
	      if (start_ptr && !match_words)
		goto assess_pattern_match;
	      if ((!match_lines && !match_words)
		  || (match_lines && len == end - beg - 1))
		{
		  match = beg;
		  len = end - beg;
		  goto assess_pattern_match;
		}
	      /* If -w, check if the match aligns with word boundaries.
		 We do this iteratively because:
		 (a) the line may contain more than one occurence of the
		 pattern, and
		 (b) Several alternatives in the pattern might be valid at a
		 given point, and we may need to consider a shorter one to
		 find a word boundary.  */
	      if (match_words)
		while (match <= best_match)
		  {
		    if ((match == buf || !WCHAR ((unsigned char) match[-1]))
			&& (len == end - beg - 1
			    || !WCHAR ((unsigned char) match[len])))
		      goto assess_pattern_match;
		    if (len > 0)
		      {
			/* Try a shorter length anchored at the same place. */
			--len;
			patterns[i].regexbuf.not_eol = 1;
			len = re_match (&(patterns[i].regexbuf),
					buf, match + len - beg, match - buf,
					&(patterns[i].regs));
		      }
		    if (len <= 0)
		      {
			/* Try looking further on. */
			if (match == end - 1)
			  break;
			match++;
			patterns[i].regexbuf.not_eol = 0;
			start = re_search (&(patterns[i].regexbuf),
					   buf, end - buf - 1,
					   match - buf, end - match - 1,
					   &(patterns[i].regs));
			if (start < 0)
			  break;
			len = patterns[i].regs.end[0] - start;
			match = buf + start;
		      }
		  } /* while (match <= best_match) */
	      continue;
	    assess_pattern_match:
	      if (!start_ptr)
		{
		  /* Good enough for a non-exact match.
		     No need to look at further patterns, if any.  */
		  
//Patch 0:
if ((__is_neg(25, &(beg), sizeof (beg), &(match), sizeof (match), &(best_match), sizeof (best_match), &(len), sizeof (len), &(best_len), sizeof (best_len), &(start_ptr), sizeof (start_ptr), &(buf), sizeof (buf), &(start), sizeof (start), &(i), sizeof (i), &(patterns), sizeof (patterns), &(end), sizeof (end), &(ret_val), sizeof (ret_val), &(match_size), sizeof (match_size), &(match_words), sizeof (match_words), &(match_lines), sizeof (match_lines), &(pcount), sizeof (pcount), &(buflim), sizeof (buflim), &(backref), sizeof (backref), &(eol), sizeof (eol), &(mb_start), sizeof (mb_start), &(kwset_exact_matches), sizeof (kwset_exact_matches), &(kwset), sizeof (kwset), &(size), sizeof (size), &(match_icase), sizeof (match_icase), &(eolbyte), sizeof (eolbyte))))
    goto success_in_len;
beg = match;

//CodeSeg 1:
		  goto success_in_len;
		}
	      if (match < best_match || (match == best_match && len > best_len))
		{
		  /* Best exact match:  leftmost, then longest.  */
		  best_match = match;
		  best_len = len;
		}
	    } /* if re_search >= 0 */
	} /* for Regex patterns.  */
	if (best_match < end)
	  {
	    /* We have found an exact match.  We were just
	       waiting for the best one (leftmost then longest).  */
	    beg = best_match;
	    len = best_len;
	    goto success_in_len;
	  }
    } /* for (beg = end ..) */

 failure:
  ret_val = -1;
  goto out;

 success:
  len = end - beg;
 success_in_len:
  *match_size = len;
  ret_val = beg - buf;
 out:
  return ret_val;
}

Spawn 1 instances, now Total 61
Counter: 62
Batcher Size:61
Preprocess the following candidate with CondTester:
Priority 10198
At location src/dfasearch.c:361
--Src File: src/dfasearch.c
Fragment 0:
if ((__abst_hole(beg, match, best_match, len, best_len, start_ptr, buf, start, i, patterns, end, ret_val, match_size, match_words, match_lines, pcount, buflim, backref, eol, mb_start, kwset_exact_matches, kwset, size, match_icase, eolbyte)))
    goto out;
beg = match;


CondTester, a patch instance with id 61:
//src_file:src/dfasearch.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); void* memset(void*, int, unsigned long); 
/* dfasearch.c - searching subroutines using dfa and regex for grep.
   Copyright 1992, 1998, 2000, 2007, 2009-2010 Free Software Foundation, Inc.

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 3, or (at your option)
   any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program; if not, write to the Free Software
   Foundation, Inc., 51 Franklin Street - Fifth Floor, Boston, MA
   02110-1301, USA.  */

/* Written August 1992 by Mike Haertel. */

#include <config.h>
#include "search.h"
#include "dfa.h"

/* For -w, we also consider _ to be word constituent.  */
#define WCHAR(C) (ISALNUM(C) || (C) == '_')

/* KWset compiled pattern.  For Ecompile and Gcompile, we compile
   a list of strings, at least one of which is known to occur in
   any string matching the regexp. */
static kwset_t kwset;

/* DFA compiled regexp. */
static struct dfa dfa;

/* The Regex compiled patterns.  */
static struct patterns
{
  /* Regex compiled regexp. */
  struct re_pattern_buffer regexbuf;
  struct re_registers regs; /* This is here on account of a BRAIN-DEAD
			       Q@#%!# library interface in regex.c.  */
} patterns0;

struct patterns *patterns;
size_t pcount;

void
dfaerror (char const *mesg)
{
  error (EXIT_TROUBLE, 0, "%s", mesg);

  /* notreached */
  /* Tell static analyzers that this function does not return.  */
  abort ();
}

/* Number of compiled fixed strings known to exactly match the regexp.
   If kwsexec returns < kwset_exact_matches, then we don't need to
   call the regexp matcher at all. */
static int kwset_exact_matches;

static char const *
kwsincr_case (const char *must)
{
  const char *buf;
  size_t n;

  n = strlen (must);
#ifdef MBS_SUPPORT
  if (match_icase && MB_CUR_MAX > 1)
    buf = mbtolower (must, &n);
  else
#endif
    buf = must;
  return kwsincr (kwset, buf, n);
}

/* If the DFA turns out to have some set of fixed strings one of
   which must occur in the match, then we build a kwset matcher
   to find those strings, and thus quickly filter out impossible
   matches. */
static void
kwsmusts (void)
{
  struct dfamust const *dm;
  char const *err;

  if (dfa.musts)
    {
      kwsinit (&kwset);
      /* First, we compile in the substrings known to be exact
	 matches.  The kwset matcher will return the index
	 of the matching string that it chooses. */
      for (dm = dfa.musts; dm; dm = dm->next)
	{
	  if (!dm->exact)
	    continue;
	  ++kwset_exact_matches;
	  if ((err = kwsincr_case (dm->must)) != NULL)
	    error (EXIT_TROUBLE, 0, "%s", err);
	}
      /* Now, we compile the substrings that will require
	 the use of the regexp matcher.  */
      for (dm = dfa.musts; dm; dm = dm->next)
	{
	  if (dm->exact)
	    continue;
	  if ((err = kwsincr_case (dm->must)) != NULL)
	    error (EXIT_TROUBLE, 0, "%s", err);
	}
      if ((err = kwsprep (kwset)) != NULL)
	error (EXIT_TROUBLE, 0, "%s", err);
    }
}

void
GEAcompile (char const *pattern, size_t size, reg_syntax_t syntax_bits)
{
  const char *err;
  const char *p, *sep;
  size_t total = size;
  char *motif;

  if (match_icase)
    syntax_bits |= RE_ICASE;
  re_set_syntax (syntax_bits);
  dfasyntax (syntax_bits, match_icase, eolbyte);

  /* For GNU regex compiler we have to pass the patterns separately to detect
     errors like "[\nallo\n]\n".  The patterns here are "[", "allo" and "]"
     GNU regex should have raise a syntax error.  The same for backref, where
     the backref should have been local to each pattern.  */
  p = pattern;
  do
    {
      size_t len;
      sep = memchr (p, '\n', total);
      if (sep)
	{
	  len = sep - p;
	  sep++;
	  total -= (len + 1);
	}
      else
	{
	  len = total;
	  total = 0;
	}

      patterns = realloc (patterns, (pcount + 1) * sizeof (*patterns));
      if (patterns == NULL)
	error (EXIT_TROUBLE, errno, _("memory exhausted"));
      patterns[pcount] = patterns0;

      if ((err = re_compile_pattern (p, len,
				    &(patterns[pcount].regexbuf))) != NULL)
	error (EXIT_TROUBLE, 0, "%s", err);
      pcount++;

      p = sep;
    } while (sep && total != 0);

  /* In the match_words and match_lines cases, we use a different pattern
     for the DFA matcher that will quickly throw out cases that won't work.
     Then if DFA succeeds we do some hairy stuff using the regex matcher
     to decide whether the match should really count. */
  if (match_words || match_lines)
    {
      static char const line_beg_no_bk[] = "^(";
      static char const line_end_no_bk[] = ")$";
      static char const word_beg_no_bk[] = "(^|[^[:alnum:]_])(";
      static char const word_end_no_bk[] = ")([^[:alnum:]_]|$)";
      static char const line_beg_bk[] = "^\\(";
      static char const line_end_bk[] = "\\)$";
      static char const word_beg_bk[] = "\\(^\\|[^[:alnum:]_]\\)\\(";
      static char const word_end_bk[] = "\\)\\([^[:alnum:]_]\\|$\\)";
      int bk = !(syntax_bits & RE_NO_BK_PARENS);
      char *n = xmalloc (sizeof word_beg_bk - 1 + size + sizeof word_end_bk);

      strcpy (n, match_lines ? (bk ? line_beg_bk : line_beg_no_bk)
			     : (bk ? word_beg_bk : word_beg_no_bk));
      total = strlen(n);
      memcpy (n + total, pattern, size);
      total += size;
      strcpy (n + total, match_lines ? (bk ? line_end_bk : line_end_no_bk)
				     : (bk ? word_end_bk : word_end_no_bk));
      total += strlen (n + total);
      pattern = motif = n;
      size = total;
    }
  else
    motif = NULL;

  dfacomp (pattern, size, &dfa, 1);
  kwsmusts ();

  free(motif);
}

size_t
EGexecute (char const *buf, size_t size, size_t *match_size,
	   char const *start_ptr)
{
  char const *buflim, *beg, *end, *match, *best_match, *mb_start;
  char eol = eolbyte;
  int backref, start, len, best_len;
  struct kwsmatch kwsm;
  size_t i, ret_val;
#ifdef MBS_SUPPORT
  if (MB_CUR_MAX > 1)
    {
      if (match_icase)
        {
          /* mbtolower adds a NUL byte at the end.  That will provide
	     space for the sentinel byte dfaexec may add.  */
          char *case_buf = mbtolower (buf, &size);
	  if (start_ptr)
	    start_ptr = case_buf + (start_ptr - buf);
          buf = case_buf;
        }
    }
#endif /* MBS_SUPPORT */

  mb_start = buf;
  buflim = buf + size;

  for (beg = end = buf; end < buflim; beg = end)
    {
      if (!start_ptr)
	{
	  /* We don't care about an exact match.  */
	  if (kwset)
	    {
	      /* Find a possible match using the KWset matcher. */
	      size_t offset = kwsexec (kwset, beg, buflim - beg, &kwsm);
	      if (offset == (size_t) -1)
		goto failure;
	      beg += offset;
	      /* Narrow down to the line containing the candidate, and
		 run it through DFA. */
	      if ((end = memchr(beg, eol, buflim - beg)) != NULL)
	        end++;
              else
                end = buflim;
	      match = beg;
	      while (beg > buf && beg[-1] != eol)
		--beg;
	      if (kwsm.index < kwset_exact_matches)
                {
#ifdef MBS_SUPPORT
                  if (mb_start < beg)
                    mb_start = beg;
                  if (MB_CUR_MAX == 1 || !is_mb_middle (&mb_start, match, buflim))
#endif
                    goto success;
                }
	      if (dfaexec (&dfa, beg, (char *) end, 0, NULL, &backref) == NULL)
		continue;
	    }
	  else
	    {
	      /* No good fixed strings; start with DFA. */
	      char const *next_beg = dfaexec (&dfa, beg, (char *) buflim,
					      0, NULL, &backref);
	      if (next_beg == NULL)
		break;
	      /* Narrow down to the line we've found. */
	      beg = next_beg;
	      if ((end = memchr(beg, eol, buflim - beg)) != NULL)
	        end++;
              else
                end = buflim;
	      while (beg > buf && beg[-1] != eol)
		--beg;
	    }
	  /* Successful, no backreferences encountered! */
	  if (!backref)
	    goto success;
	}
      else
	{
	  /* We are looking for the leftmost (then longest) exact match.
	     We will go through the outer loop only once.  */
	  beg = start_ptr;
	  end = buflim;
	}

      /* If we've made it to this point, this means DFA has seen
	 a probable match, and we need to run it through Regex. */
      best_match = end;
      best_len = 0;
      for (i = 0; i < pcount; i++)
	{
	  patterns[i].regexbuf.not_eol = 0;
	  if (0 <= (start = re_search (&(patterns[i].regexbuf),
				       buf, end - buf - 1,
				       beg - buf, end - beg - 1,
				       &(patterns[i].regs))))
	    {
	      len = patterns[i].regs.end[0] - start;
	      match = buf + start;
	      if (match > best_match)
		continue;
	      if (start_ptr && !match_words)
		goto assess_pattern_match;
	      if ((!match_lines && !match_words)
		  || (match_lines && len == end - beg - 1))
		{
		  match = beg;
		  len = end - beg;
		  goto assess_pattern_match;
		}
	      /* If -w, check if the match aligns with word boundaries.
		 We do this iteratively because:
		 (a) the line may contain more than one occurence of the
		 pattern, and
		 (b) Several alternatives in the pattern might be valid at a
		 given point, and we may need to consider a shorter one to
		 find a word boundary.  */
	      if (match_words)
		while (match <= best_match)
		  {
		    if ((match == buf || !WCHAR ((unsigned char) match[-1]))
			&& (len == end - beg - 1
			    || !WCHAR ((unsigned char) match[len])))
		      goto assess_pattern_match;
		    if (len > 0)
		      {
			/* Try a shorter length anchored at the same place. */
			--len;
			patterns[i].regexbuf.not_eol = 1;
			len = re_match (&(patterns[i].regexbuf),
					buf, match + len - beg, match - buf,
					&(patterns[i].regs));
		      }
		    if (len <= 0)
		      {
			/* Try looking further on. */
			if (match == end - 1)
			  break;
			match++;
			patterns[i].regexbuf.not_eol = 0;
			start = re_search (&(patterns[i].regexbuf),
					   buf, end - buf - 1,
					   match - buf, end - match - 1,
					   &(patterns[i].regs));
			if (start < 0)
			  break;
			len = patterns[i].regs.end[0] - start;
			match = buf + start;
		      }
		  } /* while (match <= best_match) */
	      continue;
	    assess_pattern_match:
	      if (!start_ptr)
		{
		  /* Good enough for a non-exact match.
		     No need to look at further patterns, if any.  */
		  
//Patch 0:
if ((__is_neg(25, &(beg), sizeof (beg), &(match), sizeof (match), &(best_match), sizeof (best_match), &(len), sizeof (len), &(best_len), sizeof (best_len), &(start_ptr), sizeof (start_ptr), &(buf), sizeof (buf), &(start), sizeof (start), &(i), sizeof (i), &(patterns), sizeof (patterns), &(end), sizeof (end), &(ret_val), sizeof (ret_val), &(match_size), sizeof (match_size), &(match_words), sizeof (match_words), &(match_lines), sizeof (match_lines), &(pcount), sizeof (pcount), &(buflim), sizeof (buflim), &(backref), sizeof (backref), &(eol), sizeof (eol), &(mb_start), sizeof (mb_start), &(kwset_exact_matches), sizeof (kwset_exact_matches), &(kwset), sizeof (kwset), &(size), sizeof (size), &(match_icase), sizeof (match_icase), &(eolbyte), sizeof (eolbyte))))
    goto out;
beg = match;

//CodeSeg 1:
		  goto success_in_len;
		}
	      if (match < best_match || (match == best_match && len > best_len))
		{
		  /* Best exact match:  leftmost, then longest.  */
		  best_match = match;
		  best_len = len;
		}
	    } /* if re_search >= 0 */
	} /* for Regex patterns.  */
	if (best_match < end)
	  {
	    /* We have found an exact match.  We were just
	       waiting for the best one (leftmost then longest).  */
	    beg = best_match;
	    len = best_len;
	    goto success_in_len;
	  }
    } /* for (beg = end ..) */

 failure:
  ret_val = -1;
  goto out;

 success:
  len = end - beg;
 success_in_len:
  *match_size = len;
  ret_val = beg - buf;
 out:
  return ret_val;
}

Spawn 1 instances, now Total 62
Counter: 63
Batcher Size:62
Preprocess the following candidate with CondTester:
Priority 10189
At location src/dfasearch.c:302
--Src File: src/dfasearch.c
Fragment 0:
if ((__abst_hole(start, len, i, patterns, patterns[i].regs.end, buf, match, best_match, beg, end, start_ptr, match_words, match_lines, pcount, best_len, buflim, backref, eol, mb_start, kwset_exact_matches, kwset, size, ret_val, match_size, match_icase, eolbyte, patterns[i].regs.num_regs, patterns[i].regs.start)))
    goto assess_pattern_match;
len = patterns[i].regs.end[0] - start;


CondTester, a patch instance with id 62:
//src_file:src/dfasearch.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); void* memset(void*, int, unsigned long); 
/* dfasearch.c - searching subroutines using dfa and regex for grep.
   Copyright 1992, 1998, 2000, 2007, 2009-2010 Free Software Foundation, Inc.

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 3, or (at your option)
   any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program; if not, write to the Free Software
   Foundation, Inc., 51 Franklin Street - Fifth Floor, Boston, MA
   02110-1301, USA.  */

/* Written August 1992 by Mike Haertel. */

#include <config.h>
#include "search.h"
#include "dfa.h"

/* For -w, we also consider _ to be word constituent.  */
#define WCHAR(C) (ISALNUM(C) || (C) == '_')

/* KWset compiled pattern.  For Ecompile and Gcompile, we compile
   a list of strings, at least one of which is known to occur in
   any string matching the regexp. */
static kwset_t kwset;

/* DFA compiled regexp. */
static struct dfa dfa;

/* The Regex compiled patterns.  */
static struct patterns
{
  /* Regex compiled regexp. */
  struct re_pattern_buffer regexbuf;
  struct re_registers regs; /* This is here on account of a BRAIN-DEAD
			       Q@#%!# library interface in regex.c.  */
} patterns0;

struct patterns *patterns;
size_t pcount;

void
dfaerror (char const *mesg)
{
  error (EXIT_TROUBLE, 0, "%s", mesg);

  /* notreached */
  /* Tell static analyzers that this function does not return.  */
  abort ();
}

/* Number of compiled fixed strings known to exactly match the regexp.
   If kwsexec returns < kwset_exact_matches, then we don't need to
   call the regexp matcher at all. */
static int kwset_exact_matches;

static char const *
kwsincr_case (const char *must)
{
  const char *buf;
  size_t n;

  n = strlen (must);
#ifdef MBS_SUPPORT
  if (match_icase && MB_CUR_MAX > 1)
    buf = mbtolower (must, &n);
  else
#endif
    buf = must;
  return kwsincr (kwset, buf, n);
}

/* If the DFA turns out to have some set of fixed strings one of
   which must occur in the match, then we build a kwset matcher
   to find those strings, and thus quickly filter out impossible
   matches. */
static void
kwsmusts (void)
{
  struct dfamust const *dm;
  char const *err;

  if (dfa.musts)
    {
      kwsinit (&kwset);
      /* First, we compile in the substrings known to be exact
	 matches.  The kwset matcher will return the index
	 of the matching string that it chooses. */
      for (dm = dfa.musts; dm; dm = dm->next)
	{
	  if (!dm->exact)
	    continue;
	  ++kwset_exact_matches;
	  if ((err = kwsincr_case (dm->must)) != NULL)
	    error (EXIT_TROUBLE, 0, "%s", err);
	}
      /* Now, we compile the substrings that will require
	 the use of the regexp matcher.  */
      for (dm = dfa.musts; dm; dm = dm->next)
	{
	  if (dm->exact)
	    continue;
	  if ((err = kwsincr_case (dm->must)) != NULL)
	    error (EXIT_TROUBLE, 0, "%s", err);
	}
      if ((err = kwsprep (kwset)) != NULL)
	error (EXIT_TROUBLE, 0, "%s", err);
    }
}

void
GEAcompile (char const *pattern, size_t size, reg_syntax_t syntax_bits)
{
  const char *err;
  const char *p, *sep;
  size_t total = size;
  char *motif;

  if (match_icase)
    syntax_bits |= RE_ICASE;
  re_set_syntax (syntax_bits);
  dfasyntax (syntax_bits, match_icase, eolbyte);

  /* For GNU regex compiler we have to pass the patterns separately to detect
     errors like "[\nallo\n]\n".  The patterns here are "[", "allo" and "]"
     GNU regex should have raise a syntax error.  The same for backref, where
     the backref should have been local to each pattern.  */
  p = pattern;
  do
    {
      size_t len;
      sep = memchr (p, '\n', total);
      if (sep)
	{
	  len = sep - p;
	  sep++;
	  total -= (len + 1);
	}
      else
	{
	  len = total;
	  total = 0;
	}

      patterns = realloc (patterns, (pcount + 1) * sizeof (*patterns));
      if (patterns == NULL)
	error (EXIT_TROUBLE, errno, _("memory exhausted"));
      patterns[pcount] = patterns0;

      if ((err = re_compile_pattern (p, len,
				    &(patterns[pcount].regexbuf))) != NULL)
	error (EXIT_TROUBLE, 0, "%s", err);
      pcount++;

      p = sep;
    } while (sep && total != 0);

  /* In the match_words and match_lines cases, we use a different pattern
     for the DFA matcher that will quickly throw out cases that won't work.
     Then if DFA succeeds we do some hairy stuff using the regex matcher
     to decide whether the match should really count. */
  if (match_words || match_lines)
    {
      static char const line_beg_no_bk[] = "^(";
      static char const line_end_no_bk[] = ")$";
      static char const word_beg_no_bk[] = "(^|[^[:alnum:]_])(";
      static char const word_end_no_bk[] = ")([^[:alnum:]_]|$)";
      static char const line_beg_bk[] = "^\\(";
      static char const line_end_bk[] = "\\)$";
      static char const word_beg_bk[] = "\\(^\\|[^[:alnum:]_]\\)\\(";
      static char const word_end_bk[] = "\\)\\([^[:alnum:]_]\\|$\\)";
      int bk = !(syntax_bits & RE_NO_BK_PARENS);
      char *n = xmalloc (sizeof word_beg_bk - 1 + size + sizeof word_end_bk);

      strcpy (n, match_lines ? (bk ? line_beg_bk : line_beg_no_bk)
			     : (bk ? word_beg_bk : word_beg_no_bk));
      total = strlen(n);
      memcpy (n + total, pattern, size);
      total += size;
      strcpy (n + total, match_lines ? (bk ? line_end_bk : line_end_no_bk)
				     : (bk ? word_end_bk : word_end_no_bk));
      total += strlen (n + total);
      pattern = motif = n;
      size = total;
    }
  else
    motif = NULL;

  dfacomp (pattern, size, &dfa, 1);
  kwsmusts ();

  free(motif);
}

size_t
EGexecute (char const *buf, size_t size, size_t *match_size,
	   char const *start_ptr)
{
  char const *buflim, *beg, *end, *match, *best_match, *mb_start;
  char eol = eolbyte;
  int backref, start, len, best_len;
  struct kwsmatch kwsm;
  size_t i, ret_val;
#ifdef MBS_SUPPORT
  if (MB_CUR_MAX > 1)
    {
      if (match_icase)
        {
          /* mbtolower adds a NUL byte at the end.  That will provide
	     space for the sentinel byte dfaexec may add.  */
          char *case_buf = mbtolower (buf, &size);
	  if (start_ptr)
	    start_ptr = case_buf + (start_ptr - buf);
          buf = case_buf;
        }
    }
#endif /* MBS_SUPPORT */

  mb_start = buf;
  buflim = buf + size;

  for (beg = end = buf; end < buflim; beg = end)
    {
      if (!start_ptr)
	{
	  /* We don't care about an exact match.  */
	  if (kwset)
	    {
	      /* Find a possible match using the KWset matcher. */
	      size_t offset = kwsexec (kwset, beg, buflim - beg, &kwsm);
	      if (offset == (size_t) -1)
		goto failure;
	      beg += offset;
	      /* Narrow down to the line containing the candidate, and
		 run it through DFA. */
	      if ((end = memchr(beg, eol, buflim - beg)) != NULL)
	        end++;
              else
                end = buflim;
	      match = beg;
	      while (beg > buf && beg[-1] != eol)
		--beg;
	      if (kwsm.index < kwset_exact_matches)
                {
#ifdef MBS_SUPPORT
                  if (mb_start < beg)
                    mb_start = beg;
                  if (MB_CUR_MAX == 1 || !is_mb_middle (&mb_start, match, buflim))
#endif
                    goto success;
                }
	      if (dfaexec (&dfa, beg, (char *) end, 0, NULL, &backref) == NULL)
		continue;
	    }
	  else
	    {
	      /* No good fixed strings; start with DFA. */
	      char const *next_beg = dfaexec (&dfa, beg, (char *) buflim,
					      0, NULL, &backref);
	      if (next_beg == NULL)
		break;
	      /* Narrow down to the line we've found. */
	      beg = next_beg;
	      if ((end = memchr(beg, eol, buflim - beg)) != NULL)
	        end++;
              else
                end = buflim;
	      while (beg > buf && beg[-1] != eol)
		--beg;
	    }
	  /* Successful, no backreferences encountered! */
	  if (!backref)
	    goto success;
	}
      else
	{
	  /* We are looking for the leftmost (then longest) exact match.
	     We will go through the outer loop only once.  */
	  beg = start_ptr;
	  end = buflim;
	}

      /* If we've made it to this point, this means DFA has seen
	 a probable match, and we need to run it through Regex. */
      best_match = end;
      best_len = 0;
      for (i = 0; i < pcount; i++)
	{
	  patterns[i].regexbuf.not_eol = 0;
	  if (0 <= (start = re_search (&(patterns[i].regexbuf),
				       buf, end - buf - 1,
				       beg - buf, end - beg - 1,
				       &(patterns[i].regs))))
	    {
	      
//Patch 0:
if ((__is_neg(28, &(start), sizeof (start), &(len), sizeof (len), &(i), sizeof (i), &(patterns), sizeof (patterns), &(patterns[i].regs.end), sizeof (patterns[i].regs.end), &(buf), sizeof (buf), &(match), sizeof (match), &(best_match), sizeof (best_match), &(beg), sizeof (beg), &(end), sizeof (end), &(start_ptr), sizeof (start_ptr), &(match_words), sizeof (match_words), &(match_lines), sizeof (match_lines), &(pcount), sizeof (pcount), &(best_len), sizeof (best_len), &(buflim), sizeof (buflim), &(backref), sizeof (backref), &(eol), sizeof (eol), &(mb_start), sizeof (mb_start), &(kwset_exact_matches), sizeof (kwset_exact_matches), &(kwset), sizeof (kwset), &(size), sizeof (size), &(ret_val), sizeof (ret_val), &(match_size), sizeof (match_size), &(match_icase), sizeof (match_icase), &(eolbyte), sizeof (eolbyte), &(patterns[i].regs.num_regs), sizeof (patterns[i].regs.num_regs), &(patterns[i].regs.start), sizeof (patterns[i].regs.start))))
    goto assess_pattern_match;
len = patterns[i].regs.end[0] - start;

//CodeSeg 1:
	      match = buf + start;
	      if (match > best_match)
		continue;
	      if (start_ptr && !match_words)
		goto assess_pattern_match;
	      if ((!match_lines && !match_words)
		  || (match_lines && len == end - beg - 1))
		{
		  match = beg;
		  len = end - beg;
		  goto assess_pattern_match;
		}
	      /* If -w, check if the match aligns with word boundaries.
		 We do this iteratively because:
		 (a) the line may contain more than one occurence of the
		 pattern, and
		 (b) Several alternatives in the pattern might be valid at a
		 given point, and we may need to consider a shorter one to
		 find a word boundary.  */
	      if (match_words)
		while (match <= best_match)
		  {
		    if ((match == buf || !WCHAR ((unsigned char) match[-1]))
			&& (len == end - beg - 1
			    || !WCHAR ((unsigned char) match[len])))
		      goto assess_pattern_match;
		    if (len > 0)
		      {
			/* Try a shorter length anchored at the same place. */
			--len;
			patterns[i].regexbuf.not_eol = 1;
			len = re_match (&(patterns[i].regexbuf),
					buf, match + len - beg, match - buf,
					&(patterns[i].regs));
		      }
		    if (len <= 0)
		      {
			/* Try looking further on. */
			if (match == end - 1)
			  break;
			match++;
			patterns[i].regexbuf.not_eol = 0;
			start = re_search (&(patterns[i].regexbuf),
					   buf, end - buf - 1,
					   match - buf, end - match - 1,
					   &(patterns[i].regs));
			if (start < 0)
			  break;
			len = patterns[i].regs.end[0] - start;
			match = buf + start;
		      }
		  } /* while (match <= best_match) */
	      continue;
	    assess_pattern_match:
	      if (!start_ptr)
		{
		  /* Good enough for a non-exact match.
		     No need to look at further patterns, if any.  */
		  beg = match;
		  goto success_in_len;
		}
	      if (match < best_match || (match == best_match && len > best_len))
		{
		  /* Best exact match:  leftmost, then longest.  */
		  best_match = match;
		  best_len = len;
		}
	    } /* if re_search >= 0 */
	} /* for Regex patterns.  */
	if (best_match < end)
	  {
	    /* We have found an exact match.  We were just
	       waiting for the best one (leftmost then longest).  */
	    beg = best_match;
	    len = best_len;
	    goto success_in_len;
	  }
    } /* for (beg = end ..) */

 failure:
  ret_val = -1;
  goto out;

 success:
  len = end - beg;
 success_in_len:
  *match_size = len;
  ret_val = beg - buf;
 out:
  return ret_val;
}

Spawn 1 instances, now Total 63
Counter: 64
Batcher Size:63
Preprocess the following candidate with CondTester:
Priority 10189
At location src/dfasearch.c:302
--Src File: src/dfasearch.c
Fragment 0:
if ((__abst_hole(start, len, i, patterns, patterns[i].regs.end, buf, match, best_match, beg, end, start_ptr, match_words, match_lines, pcount, best_len, buflim, backref, eol, mb_start, kwset_exact_matches, kwset, size, ret_val, match_size, match_icase, eolbyte, patterns[i].regs.num_regs, patterns[i].regs.start)))
    goto failure;
len = patterns[i].regs.end[0] - start;


CondTester, a patch instance with id 63:
//src_file:src/dfasearch.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); void* memset(void*, int, unsigned long); 
/* dfasearch.c - searching subroutines using dfa and regex for grep.
   Copyright 1992, 1998, 2000, 2007, 2009-2010 Free Software Foundation, Inc.

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 3, or (at your option)
   any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program; if not, write to the Free Software
   Foundation, Inc., 51 Franklin Street - Fifth Floor, Boston, MA
   02110-1301, USA.  */

/* Written August 1992 by Mike Haertel. */

#include <config.h>
#include "search.h"
#include "dfa.h"

/* For -w, we also consider _ to be word constituent.  */
#define WCHAR(C) (ISALNUM(C) || (C) == '_')

/* KWset compiled pattern.  For Ecompile and Gcompile, we compile
   a list of strings, at least one of which is known to occur in
   any string matching the regexp. */
static kwset_t kwset;

/* DFA compiled regexp. */
static struct dfa dfa;

/* The Regex compiled patterns.  */
static struct patterns
{
  /* Regex compiled regexp. */
  struct re_pattern_buffer regexbuf;
  struct re_registers regs; /* This is here on account of a BRAIN-DEAD
			       Q@#%!# library interface in regex.c.  */
} patterns0;

struct patterns *patterns;
size_t pcount;

void
dfaerror (char const *mesg)
{
  error (EXIT_TROUBLE, 0, "%s", mesg);

  /* notreached */
  /* Tell static analyzers that this function does not return.  */
  abort ();
}

/* Number of compiled fixed strings known to exactly match the regexp.
   If kwsexec returns < kwset_exact_matches, then we don't need to
   call the regexp matcher at all. */
static int kwset_exact_matches;

static char const *
kwsincr_case (const char *must)
{
  const char *buf;
  size_t n;

  n = strlen (must);
#ifdef MBS_SUPPORT
  if (match_icase && MB_CUR_MAX > 1)
    buf = mbtolower (must, &n);
  else
#endif
    buf = must;
  return kwsincr (kwset, buf, n);
}

/* If the DFA turns out to have some set of fixed strings one of
   which must occur in the match, then we build a kwset matcher
   to find those strings, and thus quickly filter out impossible
   matches. */
static void
kwsmusts (void)
{
  struct dfamust const *dm;
  char const *err;

  if (dfa.musts)
    {
      kwsinit (&kwset);
      /* First, we compile in the substrings known to be exact
	 matches.  The kwset matcher will return the index
	 of the matching string that it chooses. */
      for (dm = dfa.musts; dm; dm = dm->next)
	{
	  if (!dm->exact)
	    continue;
	  ++kwset_exact_matches;
	  if ((err = kwsincr_case (dm->must)) != NULL)
	    error (EXIT_TROUBLE, 0, "%s", err);
	}
      /* Now, we compile the substrings that will require
	 the use of the regexp matcher.  */
      for (dm = dfa.musts; dm; dm = dm->next)
	{
	  if (dm->exact)
	    continue;
	  if ((err = kwsincr_case (dm->must)) != NULL)
	    error (EXIT_TROUBLE, 0, "%s", err);
	}
      if ((err = kwsprep (kwset)) != NULL)
	error (EXIT_TROUBLE, 0, "%s", err);
    }
}

void
GEAcompile (char const *pattern, size_t size, reg_syntax_t syntax_bits)
{
  const char *err;
  const char *p, *sep;
  size_t total = size;
  char *motif;

  if (match_icase)
    syntax_bits |= RE_ICASE;
  re_set_syntax (syntax_bits);
  dfasyntax (syntax_bits, match_icase, eolbyte);

  /* For GNU regex compiler we have to pass the patterns separately to detect
     errors like "[\nallo\n]\n".  The patterns here are "[", "allo" and "]"
     GNU regex should have raise a syntax error.  The same for backref, where
     the backref should have been local to each pattern.  */
  p = pattern;
  do
    {
      size_t len;
      sep = memchr (p, '\n', total);
      if (sep)
	{
	  len = sep - p;
	  sep++;
	  total -= (len + 1);
	}
      else
	{
	  len = total;
	  total = 0;
	}

      patterns = realloc (patterns, (pcount + 1) * sizeof (*patterns));
      if (patterns == NULL)
	error (EXIT_TROUBLE, errno, _("memory exhausted"));
      patterns[pcount] = patterns0;

      if ((err = re_compile_pattern (p, len,
				    &(patterns[pcount].regexbuf))) != NULL)
	error (EXIT_TROUBLE, 0, "%s", err);
      pcount++;

      p = sep;
    } while (sep && total != 0);

  /* In the match_words and match_lines cases, we use a different pattern
     for the DFA matcher that will quickly throw out cases that won't work.
     Then if DFA succeeds we do some hairy stuff using the regex matcher
     to decide whether the match should really count. */
  if (match_words || match_lines)
    {
      static char const line_beg_no_bk[] = "^(";
      static char const line_end_no_bk[] = ")$";
      static char const word_beg_no_bk[] = "(^|[^[:alnum:]_])(";
      static char const word_end_no_bk[] = ")([^[:alnum:]_]|$)";
      static char const line_beg_bk[] = "^\\(";
      static char const line_end_bk[] = "\\)$";
      static char const word_beg_bk[] = "\\(^\\|[^[:alnum:]_]\\)\\(";
      static char const word_end_bk[] = "\\)\\([^[:alnum:]_]\\|$\\)";
      int bk = !(syntax_bits & RE_NO_BK_PARENS);
      char *n = xmalloc (sizeof word_beg_bk - 1 + size + sizeof word_end_bk);

      strcpy (n, match_lines ? (bk ? line_beg_bk : line_beg_no_bk)
			     : (bk ? word_beg_bk : word_beg_no_bk));
      total = strlen(n);
      memcpy (n + total, pattern, size);
      total += size;
      strcpy (n + total, match_lines ? (bk ? line_end_bk : line_end_no_bk)
				     : (bk ? word_end_bk : word_end_no_bk));
      total += strlen (n + total);
      pattern = motif = n;
      size = total;
    }
  else
    motif = NULL;

  dfacomp (pattern, size, &dfa, 1);
  kwsmusts ();

  free(motif);
}

size_t
EGexecute (char const *buf, size_t size, size_t *match_size,
	   char const *start_ptr)
{
  char const *buflim, *beg, *end, *match, *best_match, *mb_start;
  char eol = eolbyte;
  int backref, start, len, best_len;
  struct kwsmatch kwsm;
  size_t i, ret_val;
#ifdef MBS_SUPPORT
  if (MB_CUR_MAX > 1)
    {
      if (match_icase)
        {
          /* mbtolower adds a NUL byte at the end.  That will provide
	     space for the sentinel byte dfaexec may add.  */
          char *case_buf = mbtolower (buf, &size);
	  if (start_ptr)
	    start_ptr = case_buf + (start_ptr - buf);
          buf = case_buf;
        }
    }
#endif /* MBS_SUPPORT */

  mb_start = buf;
  buflim = buf + size;

  for (beg = end = buf; end < buflim; beg = end)
    {
      if (!start_ptr)
	{
	  /* We don't care about an exact match.  */
	  if (kwset)
	    {
	      /* Find a possible match using the KWset matcher. */
	      size_t offset = kwsexec (kwset, beg, buflim - beg, &kwsm);
	      if (offset == (size_t) -1)
		goto failure;
	      beg += offset;
	      /* Narrow down to the line containing the candidate, and
		 run it through DFA. */
	      if ((end = memchr(beg, eol, buflim - beg)) != NULL)
	        end++;
              else
                end = buflim;
	      match = beg;
	      while (beg > buf && beg[-1] != eol)
		--beg;
	      if (kwsm.index < kwset_exact_matches)
                {
#ifdef MBS_SUPPORT
                  if (mb_start < beg)
                    mb_start = beg;
                  if (MB_CUR_MAX == 1 || !is_mb_middle (&mb_start, match, buflim))
#endif
                    goto success;
                }
	      if (dfaexec (&dfa, beg, (char *) end, 0, NULL, &backref) == NULL)
		continue;
	    }
	  else
	    {
	      /* No good fixed strings; start with DFA. */
	      char const *next_beg = dfaexec (&dfa, beg, (char *) buflim,
					      0, NULL, &backref);
	      if (next_beg == NULL)
		break;
	      /* Narrow down to the line we've found. */
	      beg = next_beg;
	      if ((end = memchr(beg, eol, buflim - beg)) != NULL)
	        end++;
              else
                end = buflim;
	      while (beg > buf && beg[-1] != eol)
		--beg;
	    }
	  /* Successful, no backreferences encountered! */
	  if (!backref)
	    goto success;
	}
      else
	{
	  /* We are looking for the leftmost (then longest) exact match.
	     We will go through the outer loop only once.  */
	  beg = start_ptr;
	  end = buflim;
	}

      /* If we've made it to this point, this means DFA has seen
	 a probable match, and we need to run it through Regex. */
      best_match = end;
      best_len = 0;
      for (i = 0; i < pcount; i++)
	{
	  patterns[i].regexbuf.not_eol = 0;
	  if (0 <= (start = re_search (&(patterns[i].regexbuf),
				       buf, end - buf - 1,
				       beg - buf, end - beg - 1,
				       &(patterns[i].regs))))
	    {
	      
//Patch 0:
if ((__is_neg(28, &(start), sizeof (start), &(len), sizeof (len), &(i), sizeof (i), &(patterns), sizeof (patterns), &(patterns[i].regs.end), sizeof (patterns[i].regs.end), &(buf), sizeof (buf), &(match), sizeof (match), &(best_match), sizeof (best_match), &(beg), sizeof (beg), &(end), sizeof (end), &(start_ptr), sizeof (start_ptr), &(match_words), sizeof (match_words), &(match_lines), sizeof (match_lines), &(pcount), sizeof (pcount), &(best_len), sizeof (best_len), &(buflim), sizeof (buflim), &(backref), sizeof (backref), &(eol), sizeof (eol), &(mb_start), sizeof (mb_start), &(kwset_exact_matches), sizeof (kwset_exact_matches), &(kwset), sizeof (kwset), &(size), sizeof (size), &(ret_val), sizeof (ret_val), &(match_size), sizeof (match_size), &(match_icase), sizeof (match_icase), &(eolbyte), sizeof (eolbyte), &(patterns[i].regs.num_regs), sizeof (patterns[i].regs.num_regs), &(patterns[i].regs.start), sizeof (patterns[i].regs.start))))
    goto failure;
len = patterns[i].regs.end[0] - start;

//CodeSeg 1:
	      match = buf + start;
	      if (match > best_match)
		continue;
	      if (start_ptr && !match_words)
		goto assess_pattern_match;
	      if ((!match_lines && !match_words)
		  || (match_lines && len == end - beg - 1))
		{
		  match = beg;
		  len = end - beg;
		  goto assess_pattern_match;
		}
	      /* If -w, check if the match aligns with word boundaries.
		 We do this iteratively because:
		 (a) the line may contain more than one occurence of the
		 pattern, and
		 (b) Several alternatives in the pattern might be valid at a
		 given point, and we may need to consider a shorter one to
		 find a word boundary.  */
	      if (match_words)
		while (match <= best_match)
		  {
		    if ((match == buf || !WCHAR ((unsigned char) match[-1]))
			&& (len == end - beg - 1
			    || !WCHAR ((unsigned char) match[len])))
		      goto assess_pattern_match;
		    if (len > 0)
		      {
			/* Try a shorter length anchored at the same place. */
			--len;
			patterns[i].regexbuf.not_eol = 1;
			len = re_match (&(patterns[i].regexbuf),
					buf, match + len - beg, match - buf,
					&(patterns[i].regs));
		      }
		    if (len <= 0)
		      {
			/* Try looking further on. */
			if (match == end - 1)
			  break;
			match++;
			patterns[i].regexbuf.not_eol = 0;
			start = re_search (&(patterns[i].regexbuf),
					   buf, end - buf - 1,
					   match - buf, end - match - 1,
					   &(patterns[i].regs));
			if (start < 0)
			  break;
			len = patterns[i].regs.end[0] - start;
			match = buf + start;
		      }
		  } /* while (match <= best_match) */
	      continue;
	    assess_pattern_match:
	      if (!start_ptr)
		{
		  /* Good enough for a non-exact match.
		     No need to look at further patterns, if any.  */
		  beg = match;
		  goto success_in_len;
		}
	      if (match < best_match || (match == best_match && len > best_len))
		{
		  /* Best exact match:  leftmost, then longest.  */
		  best_match = match;
		  best_len = len;
		}
	    } /* if re_search >= 0 */
	} /* for Regex patterns.  */
	if (best_match < end)
	  {
	    /* We have found an exact match.  We were just
	       waiting for the best one (leftmost then longest).  */
	    beg = best_match;
	    len = best_len;
	    goto success_in_len;
	  }
    } /* for (beg = end ..) */

 failure:
  ret_val = -1;
  goto out;

 success:
  len = end - beg;
 success_in_len:
  *match_size = len;
  ret_val = beg - buf;
 out:
  return ret_val;
}

Spawn 1 instances, now Total 64
Counter: 65
Batcher Size:64
Preprocess the following candidate with CondTester:
Priority 10189
At location src/dfasearch.c:302
--Src File: src/dfasearch.c
Fragment 0:
if ((__abst_hole(start, len, i, patterns, patterns[i].regs.end, buf, match, best_match, beg, end, start_ptr, match_words, match_lines, pcount, best_len, buflim, backref, eol, mb_start, kwset_exact_matches, kwset, size, ret_val, match_size, match_icase, eolbyte, patterns[i].regs.num_regs, patterns[i].regs.start)))
    goto success;
len = patterns[i].regs.end[0] - start;


CondTester, a patch instance with id 64:
//src_file:src/dfasearch.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); void* memset(void*, int, unsigned long); 
/* dfasearch.c - searching subroutines using dfa and regex for grep.
   Copyright 1992, 1998, 2000, 2007, 2009-2010 Free Software Foundation, Inc.

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 3, or (at your option)
   any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program; if not, write to the Free Software
   Foundation, Inc., 51 Franklin Street - Fifth Floor, Boston, MA
   02110-1301, USA.  */

/* Written August 1992 by Mike Haertel. */

#include <config.h>
#include "search.h"
#include "dfa.h"

/* For -w, we also consider _ to be word constituent.  */
#define WCHAR(C) (ISALNUM(C) || (C) == '_')

/* KWset compiled pattern.  For Ecompile and Gcompile, we compile
   a list of strings, at least one of which is known to occur in
   any string matching the regexp. */
static kwset_t kwset;

/* DFA compiled regexp. */
static struct dfa dfa;

/* The Regex compiled patterns.  */
static struct patterns
{
  /* Regex compiled regexp. */
  struct re_pattern_buffer regexbuf;
  struct re_registers regs; /* This is here on account of a BRAIN-DEAD
			       Q@#%!# library interface in regex.c.  */
} patterns0;

struct patterns *patterns;
size_t pcount;

void
dfaerror (char const *mesg)
{
  error (EXIT_TROUBLE, 0, "%s", mesg);

  /* notreached */
  /* Tell static analyzers that this function does not return.  */
  abort ();
}

/* Number of compiled fixed strings known to exactly match the regexp.
   If kwsexec returns < kwset_exact_matches, then we don't need to
   call the regexp matcher at all. */
static int kwset_exact_matches;

static char const *
kwsincr_case (const char *must)
{
  const char *buf;
  size_t n;

  n = strlen (must);
#ifdef MBS_SUPPORT
  if (match_icase && MB_CUR_MAX > 1)
    buf = mbtolower (must, &n);
  else
#endif
    buf = must;
  return kwsincr (kwset, buf, n);
}

/* If the DFA turns out to have some set of fixed strings one of
   which must occur in the match, then we build a kwset matcher
   to find those strings, and thus quickly filter out impossible
   matches. */
static void
kwsmusts (void)
{
  struct dfamust const *dm;
  char const *err;

  if (dfa.musts)
    {
      kwsinit (&kwset);
      /* First, we compile in the substrings known to be exact
	 matches.  The kwset matcher will return the index
	 of the matching string that it chooses. */
      for (dm = dfa.musts; dm; dm = dm->next)
	{
	  if (!dm->exact)
	    continue;
	  ++kwset_exact_matches;
	  if ((err = kwsincr_case (dm->must)) != NULL)
	    error (EXIT_TROUBLE, 0, "%s", err);
	}
      /* Now, we compile the substrings that will require
	 the use of the regexp matcher.  */
      for (dm = dfa.musts; dm; dm = dm->next)
	{
	  if (dm->exact)
	    continue;
	  if ((err = kwsincr_case (dm->must)) != NULL)
	    error (EXIT_TROUBLE, 0, "%s", err);
	}
      if ((err = kwsprep (kwset)) != NULL)
	error (EXIT_TROUBLE, 0, "%s", err);
    }
}

void
GEAcompile (char const *pattern, size_t size, reg_syntax_t syntax_bits)
{
  const char *err;
  const char *p, *sep;
  size_t total = size;
  char *motif;

  if (match_icase)
    syntax_bits |= RE_ICASE;
  re_set_syntax (syntax_bits);
  dfasyntax (syntax_bits, match_icase, eolbyte);

  /* For GNU regex compiler we have to pass the patterns separately to detect
     errors like "[\nallo\n]\n".  The patterns here are "[", "allo" and "]"
     GNU regex should have raise a syntax error.  The same for backref, where
     the backref should have been local to each pattern.  */
  p = pattern;
  do
    {
      size_t len;
      sep = memchr (p, '\n', total);
      if (sep)
	{
	  len = sep - p;
	  sep++;
	  total -= (len + 1);
	}
      else
	{
	  len = total;
	  total = 0;
	}

      patterns = realloc (patterns, (pcount + 1) * sizeof (*patterns));
      if (patterns == NULL)
	error (EXIT_TROUBLE, errno, _("memory exhausted"));
      patterns[pcount] = patterns0;

      if ((err = re_compile_pattern (p, len,
				    &(patterns[pcount].regexbuf))) != NULL)
	error (EXIT_TROUBLE, 0, "%s", err);
      pcount++;

      p = sep;
    } while (sep && total != 0);

  /* In the match_words and match_lines cases, we use a different pattern
     for the DFA matcher that will quickly throw out cases that won't work.
     Then if DFA succeeds we do some hairy stuff using the regex matcher
     to decide whether the match should really count. */
  if (match_words || match_lines)
    {
      static char const line_beg_no_bk[] = "^(";
      static char const line_end_no_bk[] = ")$";
      static char const word_beg_no_bk[] = "(^|[^[:alnum:]_])(";
      static char const word_end_no_bk[] = ")([^[:alnum:]_]|$)";
      static char const line_beg_bk[] = "^\\(";
      static char const line_end_bk[] = "\\)$";
      static char const word_beg_bk[] = "\\(^\\|[^[:alnum:]_]\\)\\(";
      static char const word_end_bk[] = "\\)\\([^[:alnum:]_]\\|$\\)";
      int bk = !(syntax_bits & RE_NO_BK_PARENS);
      char *n = xmalloc (sizeof word_beg_bk - 1 + size + sizeof word_end_bk);

      strcpy (n, match_lines ? (bk ? line_beg_bk : line_beg_no_bk)
			     : (bk ? word_beg_bk : word_beg_no_bk));
      total = strlen(n);
      memcpy (n + total, pattern, size);
      total += size;
      strcpy (n + total, match_lines ? (bk ? line_end_bk : line_end_no_bk)
				     : (bk ? word_end_bk : word_end_no_bk));
      total += strlen (n + total);
      pattern = motif = n;
      size = total;
    }
  else
    motif = NULL;

  dfacomp (pattern, size, &dfa, 1);
  kwsmusts ();

  free(motif);
}

size_t
EGexecute (char const *buf, size_t size, size_t *match_size,
	   char const *start_ptr)
{
  char const *buflim, *beg, *end, *match, *best_match, *mb_start;
  char eol = eolbyte;
  int backref, start, len, best_len;
  struct kwsmatch kwsm;
  size_t i, ret_val;
#ifdef MBS_SUPPORT
  if (MB_CUR_MAX > 1)
    {
      if (match_icase)
        {
          /* mbtolower adds a NUL byte at the end.  That will provide
	     space for the sentinel byte dfaexec may add.  */
          char *case_buf = mbtolower (buf, &size);
	  if (start_ptr)
	    start_ptr = case_buf + (start_ptr - buf);
          buf = case_buf;
        }
    }
#endif /* MBS_SUPPORT */

  mb_start = buf;
  buflim = buf + size;

  for (beg = end = buf; end < buflim; beg = end)
    {
      if (!start_ptr)
	{
	  /* We don't care about an exact match.  */
	  if (kwset)
	    {
	      /* Find a possible match using the KWset matcher. */
	      size_t offset = kwsexec (kwset, beg, buflim - beg, &kwsm);
	      if (offset == (size_t) -1)
		goto failure;
	      beg += offset;
	      /* Narrow down to the line containing the candidate, and
		 run it through DFA. */
	      if ((end = memchr(beg, eol, buflim - beg)) != NULL)
	        end++;
              else
                end = buflim;
	      match = beg;
	      while (beg > buf && beg[-1] != eol)
		--beg;
	      if (kwsm.index < kwset_exact_matches)
                {
#ifdef MBS_SUPPORT
                  if (mb_start < beg)
                    mb_start = beg;
                  if (MB_CUR_MAX == 1 || !is_mb_middle (&mb_start, match, buflim))
#endif
                    goto success;
                }
	      if (dfaexec (&dfa, beg, (char *) end, 0, NULL, &backref) == NULL)
		continue;
	    }
	  else
	    {
	      /* No good fixed strings; start with DFA. */
	      char const *next_beg = dfaexec (&dfa, beg, (char *) buflim,
					      0, NULL, &backref);
	      if (next_beg == NULL)
		break;
	      /* Narrow down to the line we've found. */
	      beg = next_beg;
	      if ((end = memchr(beg, eol, buflim - beg)) != NULL)
	        end++;
              else
                end = buflim;
	      while (beg > buf && beg[-1] != eol)
		--beg;
	    }
	  /* Successful, no backreferences encountered! */
	  if (!backref)
	    goto success;
	}
      else
	{
	  /* We are looking for the leftmost (then longest) exact match.
	     We will go through the outer loop only once.  */
	  beg = start_ptr;
	  end = buflim;
	}

      /* If we've made it to this point, this means DFA has seen
	 a probable match, and we need to run it through Regex. */
      best_match = end;
      best_len = 0;
      for (i = 0; i < pcount; i++)
	{
	  patterns[i].regexbuf.not_eol = 0;
	  if (0 <= (start = re_search (&(patterns[i].regexbuf),
				       buf, end - buf - 1,
				       beg - buf, end - beg - 1,
				       &(patterns[i].regs))))
	    {
	      
//Patch 0:
if ((__is_neg(28, &(start), sizeof (start), &(len), sizeof (len), &(i), sizeof (i), &(patterns), sizeof (patterns), &(patterns[i].regs.end), sizeof (patterns[i].regs.end), &(buf), sizeof (buf), &(match), sizeof (match), &(best_match), sizeof (best_match), &(beg), sizeof (beg), &(end), sizeof (end), &(start_ptr), sizeof (start_ptr), &(match_words), sizeof (match_words), &(match_lines), sizeof (match_lines), &(pcount), sizeof (pcount), &(best_len), sizeof (best_len), &(buflim), sizeof (buflim), &(backref), sizeof (backref), &(eol), sizeof (eol), &(mb_start), sizeof (mb_start), &(kwset_exact_matches), sizeof (kwset_exact_matches), &(kwset), sizeof (kwset), &(size), sizeof (size), &(ret_val), sizeof (ret_val), &(match_size), sizeof (match_size), &(match_icase), sizeof (match_icase), &(eolbyte), sizeof (eolbyte), &(patterns[i].regs.num_regs), sizeof (patterns[i].regs.num_regs), &(patterns[i].regs.start), sizeof (patterns[i].regs.start))))
    goto success;
len = patterns[i].regs.end[0] - start;

//CodeSeg 1:
	      match = buf + start;
	      if (match > best_match)
		continue;
	      if (start_ptr && !match_words)
		goto assess_pattern_match;
	      if ((!match_lines && !match_words)
		  || (match_lines && len == end - beg - 1))
		{
		  match = beg;
		  len = end - beg;
		  goto assess_pattern_match;
		}
	      /* If -w, check if the match aligns with word boundaries.
		 We do this iteratively because:
		 (a) the line may contain more than one occurence of the
		 pattern, and
		 (b) Several alternatives in the pattern might be valid at a
		 given point, and we may need to consider a shorter one to
		 find a word boundary.  */
	      if (match_words)
		while (match <= best_match)
		  {
		    if ((match == buf || !WCHAR ((unsigned char) match[-1]))
			&& (len == end - beg - 1
			    || !WCHAR ((unsigned char) match[len])))
		      goto assess_pattern_match;
		    if (len > 0)
		      {
			/* Try a shorter length anchored at the same place. */
			--len;
			patterns[i].regexbuf.not_eol = 1;
			len = re_match (&(patterns[i].regexbuf),
					buf, match + len - beg, match - buf,
					&(patterns[i].regs));
		      }
		    if (len <= 0)
		      {
			/* Try looking further on. */
			if (match == end - 1)
			  break;
			match++;
			patterns[i].regexbuf.not_eol = 0;
			start = re_search (&(patterns[i].regexbuf),
					   buf, end - buf - 1,
					   match - buf, end - match - 1,
					   &(patterns[i].regs));
			if (start < 0)
			  break;
			len = patterns[i].regs.end[0] - start;
			match = buf + start;
		      }
		  } /* while (match <= best_match) */
	      continue;
	    assess_pattern_match:
	      if (!start_ptr)
		{
		  /* Good enough for a non-exact match.
		     No need to look at further patterns, if any.  */
		  beg = match;
		  goto success_in_len;
		}
	      if (match < best_match || (match == best_match && len > best_len))
		{
		  /* Best exact match:  leftmost, then longest.  */
		  best_match = match;
		  best_len = len;
		}
	    } /* if re_search >= 0 */
	} /* for Regex patterns.  */
	if (best_match < end)
	  {
	    /* We have found an exact match.  We were just
	       waiting for the best one (leftmost then longest).  */
	    beg = best_match;
	    len = best_len;
	    goto success_in_len;
	  }
    } /* for (beg = end ..) */

 failure:
  ret_val = -1;
  goto out;

 success:
  len = end - beg;
 success_in_len:
  *match_size = len;
  ret_val = beg - buf;
 out:
  return ret_val;
}

Spawn 1 instances, now Total 65
Counter: 66
Batcher Size:65
Preprocess the following candidate with CondTester:
Priority 10189
At location src/dfasearch.c:302
--Src File: src/dfasearch.c
Fragment 0:
if ((__abst_hole(start, len, i, patterns, patterns[i].regs.end, buf, match, best_match, beg, end, start_ptr, match_words, match_lines, pcount, best_len, buflim, backref, eol, mb_start, kwset_exact_matches, kwset, size, ret_val, match_size, match_icase, eolbyte, patterns[i].regs.num_regs, patterns[i].regs.start)))
    goto success_in_len;
len = patterns[i].regs.end[0] - start;


CondTester, a patch instance with id 65:
//src_file:src/dfasearch.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); void* memset(void*, int, unsigned long); 
/* dfasearch.c - searching subroutines using dfa and regex for grep.
   Copyright 1992, 1998, 2000, 2007, 2009-2010 Free Software Foundation, Inc.

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 3, or (at your option)
   any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program; if not, write to the Free Software
   Foundation, Inc., 51 Franklin Street - Fifth Floor, Boston, MA
   02110-1301, USA.  */

/* Written August 1992 by Mike Haertel. */

#include <config.h>
#include "search.h"
#include "dfa.h"

/* For -w, we also consider _ to be word constituent.  */
#define WCHAR(C) (ISALNUM(C) || (C) == '_')

/* KWset compiled pattern.  For Ecompile and Gcompile, we compile
   a list of strings, at least one of which is known to occur in
   any string matching the regexp. */
static kwset_t kwset;

/* DFA compiled regexp. */
static struct dfa dfa;

/* The Regex compiled patterns.  */
static struct patterns
{
  /* Regex compiled regexp. */
  struct re_pattern_buffer regexbuf;
  struct re_registers regs; /* This is here on account of a BRAIN-DEAD
			       Q@#%!# library interface in regex.c.  */
} patterns0;

struct patterns *patterns;
size_t pcount;

void
dfaerror (char const *mesg)
{
  error (EXIT_TROUBLE, 0, "%s", mesg);

  /* notreached */
  /* Tell static analyzers that this function does not return.  */
  abort ();
}

/* Number of compiled fixed strings known to exactly match the regexp.
   If kwsexec returns < kwset_exact_matches, then we don't need to
   call the regexp matcher at all. */
static int kwset_exact_matches;

static char const *
kwsincr_case (const char *must)
{
  const char *buf;
  size_t n;

  n = strlen (must);
#ifdef MBS_SUPPORT
  if (match_icase && MB_CUR_MAX > 1)
    buf = mbtolower (must, &n);
  else
#endif
    buf = must;
  return kwsincr (kwset, buf, n);
}

/* If the DFA turns out to have some set of fixed strings one of
   which must occur in the match, then we build a kwset matcher
   to find those strings, and thus quickly filter out impossible
   matches. */
static void
kwsmusts (void)
{
  struct dfamust const *dm;
  char const *err;

  if (dfa.musts)
    {
      kwsinit (&kwset);
      /* First, we compile in the substrings known to be exact
	 matches.  The kwset matcher will return the index
	 of the matching string that it chooses. */
      for (dm = dfa.musts; dm; dm = dm->next)
	{
	  if (!dm->exact)
	    continue;
	  ++kwset_exact_matches;
	  if ((err = kwsincr_case (dm->must)) != NULL)
	    error (EXIT_TROUBLE, 0, "%s", err);
	}
      /* Now, we compile the substrings that will require
	 the use of the regexp matcher.  */
      for (dm = dfa.musts; dm; dm = dm->next)
	{
	  if (dm->exact)
	    continue;
	  if ((err = kwsincr_case (dm->must)) != NULL)
	    error (EXIT_TROUBLE, 0, "%s", err);
	}
      if ((err = kwsprep (kwset)) != NULL)
	error (EXIT_TROUBLE, 0, "%s", err);
    }
}

void
GEAcompile (char const *pattern, size_t size, reg_syntax_t syntax_bits)
{
  const char *err;
  const char *p, *sep;
  size_t total = size;
  char *motif;

  if (match_icase)
    syntax_bits |= RE_ICASE;
  re_set_syntax (syntax_bits);
  dfasyntax (syntax_bits, match_icase, eolbyte);

  /* For GNU regex compiler we have to pass the patterns separately to detect
     errors like "[\nallo\n]\n".  The patterns here are "[", "allo" and "]"
     GNU regex should have raise a syntax error.  The same for backref, where
     the backref should have been local to each pattern.  */
  p = pattern;
  do
    {
      size_t len;
      sep = memchr (p, '\n', total);
      if (sep)
	{
	  len = sep - p;
	  sep++;
	  total -= (len + 1);
	}
      else
	{
	  len = total;
	  total = 0;
	}

      patterns = realloc (patterns, (pcount + 1) * sizeof (*patterns));
      if (patterns == NULL)
	error (EXIT_TROUBLE, errno, _("memory exhausted"));
      patterns[pcount] = patterns0;

      if ((err = re_compile_pattern (p, len,
				    &(patterns[pcount].regexbuf))) != NULL)
	error (EXIT_TROUBLE, 0, "%s", err);
      pcount++;

      p = sep;
    } while (sep && total != 0);

  /* In the match_words and match_lines cases, we use a different pattern
     for the DFA matcher that will quickly throw out cases that won't work.
     Then if DFA succeeds we do some hairy stuff using the regex matcher
     to decide whether the match should really count. */
  if (match_words || match_lines)
    {
      static char const line_beg_no_bk[] = "^(";
      static char const line_end_no_bk[] = ")$";
      static char const word_beg_no_bk[] = "(^|[^[:alnum:]_])(";
      static char const word_end_no_bk[] = ")([^[:alnum:]_]|$)";
      static char const line_beg_bk[] = "^\\(";
      static char const line_end_bk[] = "\\)$";
      static char const word_beg_bk[] = "\\(^\\|[^[:alnum:]_]\\)\\(";
      static char const word_end_bk[] = "\\)\\([^[:alnum:]_]\\|$\\)";
      int bk = !(syntax_bits & RE_NO_BK_PARENS);
      char *n = xmalloc (sizeof word_beg_bk - 1 + size + sizeof word_end_bk);

      strcpy (n, match_lines ? (bk ? line_beg_bk : line_beg_no_bk)
			     : (bk ? word_beg_bk : word_beg_no_bk));
      total = strlen(n);
      memcpy (n + total, pattern, size);
      total += size;
      strcpy (n + total, match_lines ? (bk ? line_end_bk : line_end_no_bk)
				     : (bk ? word_end_bk : word_end_no_bk));
      total += strlen (n + total);
      pattern = motif = n;
      size = total;
    }
  else
    motif = NULL;

  dfacomp (pattern, size, &dfa, 1);
  kwsmusts ();

  free(motif);
}

size_t
EGexecute (char const *buf, size_t size, size_t *match_size,
	   char const *start_ptr)
{
  char const *buflim, *beg, *end, *match, *best_match, *mb_start;
  char eol = eolbyte;
  int backref, start, len, best_len;
  struct kwsmatch kwsm;
  size_t i, ret_val;
#ifdef MBS_SUPPORT
  if (MB_CUR_MAX > 1)
    {
      if (match_icase)
        {
          /* mbtolower adds a NUL byte at the end.  That will provide
	     space for the sentinel byte dfaexec may add.  */
          char *case_buf = mbtolower (buf, &size);
	  if (start_ptr)
	    start_ptr = case_buf + (start_ptr - buf);
          buf = case_buf;
        }
    }
#endif /* MBS_SUPPORT */

  mb_start = buf;
  buflim = buf + size;

  for (beg = end = buf; end < buflim; beg = end)
    {
      if (!start_ptr)
	{
	  /* We don't care about an exact match.  */
	  if (kwset)
	    {
	      /* Find a possible match using the KWset matcher. */
	      size_t offset = kwsexec (kwset, beg, buflim - beg, &kwsm);
	      if (offset == (size_t) -1)
		goto failure;
	      beg += offset;
	      /* Narrow down to the line containing the candidate, and
		 run it through DFA. */
	      if ((end = memchr(beg, eol, buflim - beg)) != NULL)
	        end++;
              else
                end = buflim;
	      match = beg;
	      while (beg > buf && beg[-1] != eol)
		--beg;
	      if (kwsm.index < kwset_exact_matches)
                {
#ifdef MBS_SUPPORT
                  if (mb_start < beg)
                    mb_start = beg;
                  if (MB_CUR_MAX == 1 || !is_mb_middle (&mb_start, match, buflim))
#endif
                    goto success;
                }
	      if (dfaexec (&dfa, beg, (char *) end, 0, NULL, &backref) == NULL)
		continue;
	    }
	  else
	    {
	      /* No good fixed strings; start with DFA. */
	      char const *next_beg = dfaexec (&dfa, beg, (char *) buflim,
					      0, NULL, &backref);
	      if (next_beg == NULL)
		break;
	      /* Narrow down to the line we've found. */
	      beg = next_beg;
	      if ((end = memchr(beg, eol, buflim - beg)) != NULL)
	        end++;
              else
                end = buflim;
	      while (beg > buf && beg[-1] != eol)
		--beg;
	    }
	  /* Successful, no backreferences encountered! */
	  if (!backref)
	    goto success;
	}
      else
	{
	  /* We are looking for the leftmost (then longest) exact match.
	     We will go through the outer loop only once.  */
	  beg = start_ptr;
	  end = buflim;
	}

      /* If we've made it to this point, this means DFA has seen
	 a probable match, and we need to run it through Regex. */
      best_match = end;
      best_len = 0;
      for (i = 0; i < pcount; i++)
	{
	  patterns[i].regexbuf.not_eol = 0;
	  if (0 <= (start = re_search (&(patterns[i].regexbuf),
				       buf, end - buf - 1,
				       beg - buf, end - beg - 1,
				       &(patterns[i].regs))))
	    {
	      
//Patch 0:
if ((__is_neg(28, &(start), sizeof (start), &(len), sizeof (len), &(i), sizeof (i), &(patterns), sizeof (patterns), &(patterns[i].regs.end), sizeof (patterns[i].regs.end), &(buf), sizeof (buf), &(match), sizeof (match), &(best_match), sizeof (best_match), &(beg), sizeof (beg), &(end), sizeof (end), &(start_ptr), sizeof (start_ptr), &(match_words), sizeof (match_words), &(match_lines), sizeof (match_lines), &(pcount), sizeof (pcount), &(best_len), sizeof (best_len), &(buflim), sizeof (buflim), &(backref), sizeof (backref), &(eol), sizeof (eol), &(mb_start), sizeof (mb_start), &(kwset_exact_matches), sizeof (kwset_exact_matches), &(kwset), sizeof (kwset), &(size), sizeof (size), &(ret_val), sizeof (ret_val), &(match_size), sizeof (match_size), &(match_icase), sizeof (match_icase), &(eolbyte), sizeof (eolbyte), &(patterns[i].regs.num_regs), sizeof (patterns[i].regs.num_regs), &(patterns[i].regs.start), sizeof (patterns[i].regs.start))))
    goto success_in_len;
len = patterns[i].regs.end[0] - start;

//CodeSeg 1:
	      match = buf + start;
	      if (match > best_match)
		continue;
	      if (start_ptr && !match_words)
		goto assess_pattern_match;
	      if ((!match_lines && !match_words)
		  || (match_lines && len == end - beg - 1))
		{
		  match = beg;
		  len = end - beg;
		  goto assess_pattern_match;
		}
	      /* If -w, check if the match aligns with word boundaries.
		 We do this iteratively because:
		 (a) the line may contain more than one occurence of the
		 pattern, and
		 (b) Several alternatives in the pattern might be valid at a
		 given point, and we may need to consider a shorter one to
		 find a word boundary.  */
	      if (match_words)
		while (match <= best_match)
		  {
		    if ((match == buf || !WCHAR ((unsigned char) match[-1]))
			&& (len == end - beg - 1
			    || !WCHAR ((unsigned char) match[len])))
		      goto assess_pattern_match;
		    if (len > 0)
		      {
			/* Try a shorter length anchored at the same place. */
			--len;
			patterns[i].regexbuf.not_eol = 1;
			len = re_match (&(patterns[i].regexbuf),
					buf, match + len - beg, match - buf,
					&(patterns[i].regs));
		      }
		    if (len <= 0)
		      {
			/* Try looking further on. */
			if (match == end - 1)
			  break;
			match++;
			patterns[i].regexbuf.not_eol = 0;
			start = re_search (&(patterns[i].regexbuf),
					   buf, end - buf - 1,
					   match - buf, end - match - 1,
					   &(patterns[i].regs));
			if (start < 0)
			  break;
			len = patterns[i].regs.end[0] - start;
			match = buf + start;
		      }
		  } /* while (match <= best_match) */
	      continue;
	    assess_pattern_match:
	      if (!start_ptr)
		{
		  /* Good enough for a non-exact match.
		     No need to look at further patterns, if any.  */
		  beg = match;
		  goto success_in_len;
		}
	      if (match < best_match || (match == best_match && len > best_len))
		{
		  /* Best exact match:  leftmost, then longest.  */
		  best_match = match;
		  best_len = len;
		}
	    } /* if re_search >= 0 */
	} /* for Regex patterns.  */
	if (best_match < end)
	  {
	    /* We have found an exact match.  We were just
	       waiting for the best one (leftmost then longest).  */
	    beg = best_match;
	    len = best_len;
	    goto success_in_len;
	  }
    } /* for (beg = end ..) */

 failure:
  ret_val = -1;
  goto out;

 success:
  len = end - beg;
 success_in_len:
  *match_size = len;
  ret_val = beg - buf;
 out:
  return ret_val;
}

Spawn 1 instances, now Total 66
Counter: 67
Batcher Size:66
Preprocess the following candidate with CondTester:
Priority 10189
At location src/dfasearch.c:302
--Src File: src/dfasearch.c
Fragment 0:
if ((__abst_hole(start, len, i, patterns, patterns[i].regs.end, buf, match, best_match, beg, end, start_ptr, match_words, match_lines, pcount, best_len, buflim, backref, eol, mb_start, kwset_exact_matches, kwset, size, ret_val, match_size, match_icase, eolbyte, patterns[i].regs.num_regs, patterns[i].regs.start)))
    goto out;
len = patterns[i].regs.end[0] - start;


CondTester, a patch instance with id 66:
//src_file:src/dfasearch.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); void* memset(void*, int, unsigned long); 
/* dfasearch.c - searching subroutines using dfa and regex for grep.
   Copyright 1992, 1998, 2000, 2007, 2009-2010 Free Software Foundation, Inc.

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 3, or (at your option)
   any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program; if not, write to the Free Software
   Foundation, Inc., 51 Franklin Street - Fifth Floor, Boston, MA
   02110-1301, USA.  */

/* Written August 1992 by Mike Haertel. */

#include <config.h>
#include "search.h"
#include "dfa.h"

/* For -w, we also consider _ to be word constituent.  */
#define WCHAR(C) (ISALNUM(C) || (C) == '_')

/* KWset compiled pattern.  For Ecompile and Gcompile, we compile
   a list of strings, at least one of which is known to occur in
   any string matching the regexp. */
static kwset_t kwset;

/* DFA compiled regexp. */
static struct dfa dfa;

/* The Regex compiled patterns.  */
static struct patterns
{
  /* Regex compiled regexp. */
  struct re_pattern_buffer regexbuf;
  struct re_registers regs; /* This is here on account of a BRAIN-DEAD
			       Q@#%!# library interface in regex.c.  */
} patterns0;

struct patterns *patterns;
size_t pcount;

void
dfaerror (char const *mesg)
{
  error (EXIT_TROUBLE, 0, "%s", mesg);

  /* notreached */
  /* Tell static analyzers that this function does not return.  */
  abort ();
}

/* Number of compiled fixed strings known to exactly match the regexp.
   If kwsexec returns < kwset_exact_matches, then we don't need to
   call the regexp matcher at all. */
static int kwset_exact_matches;

static char const *
kwsincr_case (const char *must)
{
  const char *buf;
  size_t n;

  n = strlen (must);
#ifdef MBS_SUPPORT
  if (match_icase && MB_CUR_MAX > 1)
    buf = mbtolower (must, &n);
  else
#endif
    buf = must;
  return kwsincr (kwset, buf, n);
}

/* If the DFA turns out to have some set of fixed strings one of
   which must occur in the match, then we build a kwset matcher
   to find those strings, and thus quickly filter out impossible
   matches. */
static void
kwsmusts (void)
{
  struct dfamust const *dm;
  char const *err;

  if (dfa.musts)
    {
      kwsinit (&kwset);
      /* First, we compile in the substrings known to be exact
	 matches.  The kwset matcher will return the index
	 of the matching string that it chooses. */
      for (dm = dfa.musts; dm; dm = dm->next)
	{
	  if (!dm->exact)
	    continue;
	  ++kwset_exact_matches;
	  if ((err = kwsincr_case (dm->must)) != NULL)
	    error (EXIT_TROUBLE, 0, "%s", err);
	}
      /* Now, we compile the substrings that will require
	 the use of the regexp matcher.  */
      for (dm = dfa.musts; dm; dm = dm->next)
	{
	  if (dm->exact)
	    continue;
	  if ((err = kwsincr_case (dm->must)) != NULL)
	    error (EXIT_TROUBLE, 0, "%s", err);
	}
      if ((err = kwsprep (kwset)) != NULL)
	error (EXIT_TROUBLE, 0, "%s", err);
    }
}

void
GEAcompile (char const *pattern, size_t size, reg_syntax_t syntax_bits)
{
  const char *err;
  const char *p, *sep;
  size_t total = size;
  char *motif;

  if (match_icase)
    syntax_bits |= RE_ICASE;
  re_set_syntax (syntax_bits);
  dfasyntax (syntax_bits, match_icase, eolbyte);

  /* For GNU regex compiler we have to pass the patterns separately to detect
     errors like "[\nallo\n]\n".  The patterns here are "[", "allo" and "]"
     GNU regex should have raise a syntax error.  The same for backref, where
     the backref should have been local to each pattern.  */
  p = pattern;
  do
    {
      size_t len;
      sep = memchr (p, '\n', total);
      if (sep)
	{
	  len = sep - p;
	  sep++;
	  total -= (len + 1);
	}
      else
	{
	  len = total;
	  total = 0;
	}

      patterns = realloc (patterns, (pcount + 1) * sizeof (*patterns));
      if (patterns == NULL)
	error (EXIT_TROUBLE, errno, _("memory exhausted"));
      patterns[pcount] = patterns0;

      if ((err = re_compile_pattern (p, len,
				    &(patterns[pcount].regexbuf))) != NULL)
	error (EXIT_TROUBLE, 0, "%s", err);
      pcount++;

      p = sep;
    } while (sep && total != 0);

  /* In the match_words and match_lines cases, we use a different pattern
     for the DFA matcher that will quickly throw out cases that won't work.
     Then if DFA succeeds we do some hairy stuff using the regex matcher
     to decide whether the match should really count. */
  if (match_words || match_lines)
    {
      static char const line_beg_no_bk[] = "^(";
      static char const line_end_no_bk[] = ")$";
      static char const word_beg_no_bk[] = "(^|[^[:alnum:]_])(";
      static char const word_end_no_bk[] = ")([^[:alnum:]_]|$)";
      static char const line_beg_bk[] = "^\\(";
      static char const line_end_bk[] = "\\)$";
      static char const word_beg_bk[] = "\\(^\\|[^[:alnum:]_]\\)\\(";
      static char const word_end_bk[] = "\\)\\([^[:alnum:]_]\\|$\\)";
      int bk = !(syntax_bits & RE_NO_BK_PARENS);
      char *n = xmalloc (sizeof word_beg_bk - 1 + size + sizeof word_end_bk);

      strcpy (n, match_lines ? (bk ? line_beg_bk : line_beg_no_bk)
			     : (bk ? word_beg_bk : word_beg_no_bk));
      total = strlen(n);
      memcpy (n + total, pattern, size);
      total += size;
      strcpy (n + total, match_lines ? (bk ? line_end_bk : line_end_no_bk)
				     : (bk ? word_end_bk : word_end_no_bk));
      total += strlen (n + total);
      pattern = motif = n;
      size = total;
    }
  else
    motif = NULL;

  dfacomp (pattern, size, &dfa, 1);
  kwsmusts ();

  free(motif);
}

size_t
EGexecute (char const *buf, size_t size, size_t *match_size,
	   char const *start_ptr)
{
  char const *buflim, *beg, *end, *match, *best_match, *mb_start;
  char eol = eolbyte;
  int backref, start, len, best_len;
  struct kwsmatch kwsm;
  size_t i, ret_val;
#ifdef MBS_SUPPORT
  if (MB_CUR_MAX > 1)
    {
      if (match_icase)
        {
          /* mbtolower adds a NUL byte at the end.  That will provide
	     space for the sentinel byte dfaexec may add.  */
          char *case_buf = mbtolower (buf, &size);
	  if (start_ptr)
	    start_ptr = case_buf + (start_ptr - buf);
          buf = case_buf;
        }
    }
#endif /* MBS_SUPPORT */

  mb_start = buf;
  buflim = buf + size;

  for (beg = end = buf; end < buflim; beg = end)
    {
      if (!start_ptr)
	{
	  /* We don't care about an exact match.  */
	  if (kwset)
	    {
	      /* Find a possible match using the KWset matcher. */
	      size_t offset = kwsexec (kwset, beg, buflim - beg, &kwsm);
	      if (offset == (size_t) -1)
		goto failure;
	      beg += offset;
	      /* Narrow down to the line containing the candidate, and
		 run it through DFA. */
	      if ((end = memchr(beg, eol, buflim - beg)) != NULL)
	        end++;
              else
                end = buflim;
	      match = beg;
	      while (beg > buf && beg[-1] != eol)
		--beg;
	      if (kwsm.index < kwset_exact_matches)
                {
#ifdef MBS_SUPPORT
                  if (mb_start < beg)
                    mb_start = beg;
                  if (MB_CUR_MAX == 1 || !is_mb_middle (&mb_start, match, buflim))
#endif
                    goto success;
                }
	      if (dfaexec (&dfa, beg, (char *) end, 0, NULL, &backref) == NULL)
		continue;
	    }
	  else
	    {
	      /* No good fixed strings; start with DFA. */
	      char const *next_beg = dfaexec (&dfa, beg, (char *) buflim,
					      0, NULL, &backref);
	      if (next_beg == NULL)
		break;
	      /* Narrow down to the line we've found. */
	      beg = next_beg;
	      if ((end = memchr(beg, eol, buflim - beg)) != NULL)
	        end++;
              else
                end = buflim;
	      while (beg > buf && beg[-1] != eol)
		--beg;
	    }
	  /* Successful, no backreferences encountered! */
	  if (!backref)
	    goto success;
	}
      else
	{
	  /* We are looking for the leftmost (then longest) exact match.
	     We will go through the outer loop only once.  */
	  beg = start_ptr;
	  end = buflim;
	}

      /* If we've made it to this point, this means DFA has seen
	 a probable match, and we need to run it through Regex. */
      best_match = end;
      best_len = 0;
      for (i = 0; i < pcount; i++)
	{
	  patterns[i].regexbuf.not_eol = 0;
	  if (0 <= (start = re_search (&(patterns[i].regexbuf),
				       buf, end - buf - 1,
				       beg - buf, end - beg - 1,
				       &(patterns[i].regs))))
	    {
	      
//Patch 0:
if ((__is_neg(28, &(start), sizeof (start), &(len), sizeof (len), &(i), sizeof (i), &(patterns), sizeof (patterns), &(patterns[i].regs.end), sizeof (patterns[i].regs.end), &(buf), sizeof (buf), &(match), sizeof (match), &(best_match), sizeof (best_match), &(beg), sizeof (beg), &(end), sizeof (end), &(start_ptr), sizeof (start_ptr), &(match_words), sizeof (match_words), &(match_lines), sizeof (match_lines), &(pcount), sizeof (pcount), &(best_len), sizeof (best_len), &(buflim), sizeof (buflim), &(backref), sizeof (backref), &(eol), sizeof (eol), &(mb_start), sizeof (mb_start), &(kwset_exact_matches), sizeof (kwset_exact_matches), &(kwset), sizeof (kwset), &(size), sizeof (size), &(ret_val), sizeof (ret_val), &(match_size), sizeof (match_size), &(match_icase), sizeof (match_icase), &(eolbyte), sizeof (eolbyte), &(patterns[i].regs.num_regs), sizeof (patterns[i].regs.num_regs), &(patterns[i].regs.start), sizeof (patterns[i].regs.start))))
    goto out;
len = patterns[i].regs.end[0] - start;

//CodeSeg 1:
	      match = buf + start;
	      if (match > best_match)
		continue;
	      if (start_ptr && !match_words)
		goto assess_pattern_match;
	      if ((!match_lines && !match_words)
		  || (match_lines && len == end - beg - 1))
		{
		  match = beg;
		  len = end - beg;
		  goto assess_pattern_match;
		}
	      /* If -w, check if the match aligns with word boundaries.
		 We do this iteratively because:
		 (a) the line may contain more than one occurence of the
		 pattern, and
		 (b) Several alternatives in the pattern might be valid at a
		 given point, and we may need to consider a shorter one to
		 find a word boundary.  */
	      if (match_words)
		while (match <= best_match)
		  {
		    if ((match == buf || !WCHAR ((unsigned char) match[-1]))
			&& (len == end - beg - 1
			    || !WCHAR ((unsigned char) match[len])))
		      goto assess_pattern_match;
		    if (len > 0)
		      {
			/* Try a shorter length anchored at the same place. */
			--len;
			patterns[i].regexbuf.not_eol = 1;
			len = re_match (&(patterns[i].regexbuf),
					buf, match + len - beg, match - buf,
					&(patterns[i].regs));
		      }
		    if (len <= 0)
		      {
			/* Try looking further on. */
			if (match == end - 1)
			  break;
			match++;
			patterns[i].regexbuf.not_eol = 0;
			start = re_search (&(patterns[i].regexbuf),
					   buf, end - buf - 1,
					   match - buf, end - match - 1,
					   &(patterns[i].regs));
			if (start < 0)
			  break;
			len = patterns[i].regs.end[0] - start;
			match = buf + start;
		      }
		  } /* while (match <= best_match) */
	      continue;
	    assess_pattern_match:
	      if (!start_ptr)
		{
		  /* Good enough for a non-exact match.
		     No need to look at further patterns, if any.  */
		  beg = match;
		  goto success_in_len;
		}
	      if (match < best_match || (match == best_match && len > best_len))
		{
		  /* Best exact match:  leftmost, then longest.  */
		  best_match = match;
		  best_len = len;
		}
	    } /* if re_search >= 0 */
	} /* for Regex patterns.  */
	if (best_match < end)
	  {
	    /* We have found an exact match.  We were just
	       waiting for the best one (leftmost then longest).  */
	    beg = best_match;
	    len = best_len;
	    goto success_in_len;
	  }
    } /* for (beg = end ..) */

 failure:
  ret_val = -1;
  goto out;

 success:
  len = end - beg;
 success_in_len:
  *match_size = len;
  ret_val = beg - buf;
 out:
  return ret_val;
}

Spawn 1 instances, now Total 67
Counter: 68
Batcher Size:67
Preprocess the following candidate with CondTester:
Priority 9998
At location src/dfasearch.c:361
--Src File: src/dfasearch.c
Fragment 0:
if ((__abst_hole(beg, match, best_match, len, best_len, start_ptr, buf, start, i, patterns, end, ret_val, match_size, match_words, match_lines, pcount, buflim, backref, eol, mb_start, kwset_exact_matches, kwset, size, match_icase, eolbyte)))
    return -1;
beg = match;


CondTester, a patch instance with id 67:
//src_file:src/dfasearch.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); void* memset(void*, int, unsigned long); 
/* dfasearch.c - searching subroutines using dfa and regex for grep.
   Copyright 1992, 1998, 2000, 2007, 2009-2010 Free Software Foundation, Inc.

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 3, or (at your option)
   any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program; if not, write to the Free Software
   Foundation, Inc., 51 Franklin Street - Fifth Floor, Boston, MA
   02110-1301, USA.  */

/* Written August 1992 by Mike Haertel. */

#include <config.h>
#include "search.h"
#include "dfa.h"

/* For -w, we also consider _ to be word constituent.  */
#define WCHAR(C) (ISALNUM(C) || (C) == '_')

/* KWset compiled pattern.  For Ecompile and Gcompile, we compile
   a list of strings, at least one of which is known to occur in
   any string matching the regexp. */
static kwset_t kwset;

/* DFA compiled regexp. */
static struct dfa dfa;

/* The Regex compiled patterns.  */
static struct patterns
{
  /* Regex compiled regexp. */
  struct re_pattern_buffer regexbuf;
  struct re_registers regs; /* This is here on account of a BRAIN-DEAD
			       Q@#%!# library interface in regex.c.  */
} patterns0;

struct patterns *patterns;
size_t pcount;

void
dfaerror (char const *mesg)
{
  error (EXIT_TROUBLE, 0, "%s", mesg);

  /* notreached */
  /* Tell static analyzers that this function does not return.  */
  abort ();
}

/* Number of compiled fixed strings known to exactly match the regexp.
   If kwsexec returns < kwset_exact_matches, then we don't need to
   call the regexp matcher at all. */
static int kwset_exact_matches;

static char const *
kwsincr_case (const char *must)
{
  const char *buf;
  size_t n;

  n = strlen (must);
#ifdef MBS_SUPPORT
  if (match_icase && MB_CUR_MAX > 1)
    buf = mbtolower (must, &n);
  else
#endif
    buf = must;
  return kwsincr (kwset, buf, n);
}

/* If the DFA turns out to have some set of fixed strings one of
   which must occur in the match, then we build a kwset matcher
   to find those strings, and thus quickly filter out impossible
   matches. */
static void
kwsmusts (void)
{
  struct dfamust const *dm;
  char const *err;

  if (dfa.musts)
    {
      kwsinit (&kwset);
      /* First, we compile in the substrings known to be exact
	 matches.  The kwset matcher will return the index
	 of the matching string that it chooses. */
      for (dm = dfa.musts; dm; dm = dm->next)
	{
	  if (!dm->exact)
	    continue;
	  ++kwset_exact_matches;
	  if ((err = kwsincr_case (dm->must)) != NULL)
	    error (EXIT_TROUBLE, 0, "%s", err);
	}
      /* Now, we compile the substrings that will require
	 the use of the regexp matcher.  */
      for (dm = dfa.musts; dm; dm = dm->next)
	{
	  if (dm->exact)
	    continue;
	  if ((err = kwsincr_case (dm->must)) != NULL)
	    error (EXIT_TROUBLE, 0, "%s", err);
	}
      if ((err = kwsprep (kwset)) != NULL)
	error (EXIT_TROUBLE, 0, "%s", err);
    }
}

void
GEAcompile (char const *pattern, size_t size, reg_syntax_t syntax_bits)
{
  const char *err;
  const char *p, *sep;
  size_t total = size;
  char *motif;

  if (match_icase)
    syntax_bits |= RE_ICASE;
  re_set_syntax (syntax_bits);
  dfasyntax (syntax_bits, match_icase, eolbyte);

  /* For GNU regex compiler we have to pass the patterns separately to detect
     errors like "[\nallo\n]\n".  The patterns here are "[", "allo" and "]"
     GNU regex should have raise a syntax error.  The same for backref, where
     the backref should have been local to each pattern.  */
  p = pattern;
  do
    {
      size_t len;
      sep = memchr (p, '\n', total);
      if (sep)
	{
	  len = sep - p;
	  sep++;
	  total -= (len + 1);
	}
      else
	{
	  len = total;
	  total = 0;
	}

      patterns = realloc (patterns, (pcount + 1) * sizeof (*patterns));
      if (patterns == NULL)
	error (EXIT_TROUBLE, errno, _("memory exhausted"));
      patterns[pcount] = patterns0;

      if ((err = re_compile_pattern (p, len,
				    &(patterns[pcount].regexbuf))) != NULL)
	error (EXIT_TROUBLE, 0, "%s", err);
      pcount++;

      p = sep;
    } while (sep && total != 0);

  /* In the match_words and match_lines cases, we use a different pattern
     for the DFA matcher that will quickly throw out cases that won't work.
     Then if DFA succeeds we do some hairy stuff using the regex matcher
     to decide whether the match should really count. */
  if (match_words || match_lines)
    {
      static char const line_beg_no_bk[] = "^(";
      static char const line_end_no_bk[] = ")$";
      static char const word_beg_no_bk[] = "(^|[^[:alnum:]_])(";
      static char const word_end_no_bk[] = ")([^[:alnum:]_]|$)";
      static char const line_beg_bk[] = "^\\(";
      static char const line_end_bk[] = "\\)$";
      static char const word_beg_bk[] = "\\(^\\|[^[:alnum:]_]\\)\\(";
      static char const word_end_bk[] = "\\)\\([^[:alnum:]_]\\|$\\)";
      int bk = !(syntax_bits & RE_NO_BK_PARENS);
      char *n = xmalloc (sizeof word_beg_bk - 1 + size + sizeof word_end_bk);

      strcpy (n, match_lines ? (bk ? line_beg_bk : line_beg_no_bk)
			     : (bk ? word_beg_bk : word_beg_no_bk));
      total = strlen(n);
      memcpy (n + total, pattern, size);
      total += size;
      strcpy (n + total, match_lines ? (bk ? line_end_bk : line_end_no_bk)
				     : (bk ? word_end_bk : word_end_no_bk));
      total += strlen (n + total);
      pattern = motif = n;
      size = total;
    }
  else
    motif = NULL;

  dfacomp (pattern, size, &dfa, 1);
  kwsmusts ();

  free(motif);
}

size_t
EGexecute (char const *buf, size_t size, size_t *match_size,
	   char const *start_ptr)
{
  char const *buflim, *beg, *end, *match, *best_match, *mb_start;
  char eol = eolbyte;
  int backref, start, len, best_len;
  struct kwsmatch kwsm;
  size_t i, ret_val;
#ifdef MBS_SUPPORT
  if (MB_CUR_MAX > 1)
    {
      if (match_icase)
        {
          /* mbtolower adds a NUL byte at the end.  That will provide
	     space for the sentinel byte dfaexec may add.  */
          char *case_buf = mbtolower (buf, &size);
	  if (start_ptr)
	    start_ptr = case_buf + (start_ptr - buf);
          buf = case_buf;
        }
    }
#endif /* MBS_SUPPORT */

  mb_start = buf;
  buflim = buf + size;

  for (beg = end = buf; end < buflim; beg = end)
    {
      if (!start_ptr)
	{
	  /* We don't care about an exact match.  */
	  if (kwset)
	    {
	      /* Find a possible match using the KWset matcher. */
	      size_t offset = kwsexec (kwset, beg, buflim - beg, &kwsm);
	      if (offset == (size_t) -1)
		goto failure;
	      beg += offset;
	      /* Narrow down to the line containing the candidate, and
		 run it through DFA. */
	      if ((end = memchr(beg, eol, buflim - beg)) != NULL)
	        end++;
              else
                end = buflim;
	      match = beg;
	      while (beg > buf && beg[-1] != eol)
		--beg;
	      if (kwsm.index < kwset_exact_matches)
                {
#ifdef MBS_SUPPORT
                  if (mb_start < beg)
                    mb_start = beg;
                  if (MB_CUR_MAX == 1 || !is_mb_middle (&mb_start, match, buflim))
#endif
                    goto success;
                }
	      if (dfaexec (&dfa, beg, (char *) end, 0, NULL, &backref) == NULL)
		continue;
	    }
	  else
	    {
	      /* No good fixed strings; start with DFA. */
	      char const *next_beg = dfaexec (&dfa, beg, (char *) buflim,
					      0, NULL, &backref);
	      if (next_beg == NULL)
		break;
	      /* Narrow down to the line we've found. */
	      beg = next_beg;
	      if ((end = memchr(beg, eol, buflim - beg)) != NULL)
	        end++;
              else
                end = buflim;
	      while (beg > buf && beg[-1] != eol)
		--beg;
	    }
	  /* Successful, no backreferences encountered! */
	  if (!backref)
	    goto success;
	}
      else
	{
	  /* We are looking for the leftmost (then longest) exact match.
	     We will go through the outer loop only once.  */
	  beg = start_ptr;
	  end = buflim;
	}

      /* If we've made it to this point, this means DFA has seen
	 a probable match, and we need to run it through Regex. */
      best_match = end;
      best_len = 0;
      for (i = 0; i < pcount; i++)
	{
	  patterns[i].regexbuf.not_eol = 0;
	  if (0 <= (start = re_search (&(patterns[i].regexbuf),
				       buf, end - buf - 1,
				       beg - buf, end - beg - 1,
				       &(patterns[i].regs))))
	    {
	      len = patterns[i].regs.end[0] - start;
	      match = buf + start;
	      if (match > best_match)
		continue;
	      if (start_ptr && !match_words)
		goto assess_pattern_match;
	      if ((!match_lines && !match_words)
		  || (match_lines && len == end - beg - 1))
		{
		  match = beg;
		  len = end - beg;
		  goto assess_pattern_match;
		}
	      /* If -w, check if the match aligns with word boundaries.
		 We do this iteratively because:
		 (a) the line may contain more than one occurence of the
		 pattern, and
		 (b) Several alternatives in the pattern might be valid at a
		 given point, and we may need to consider a shorter one to
		 find a word boundary.  */
	      if (match_words)
		while (match <= best_match)
		  {
		    if ((match == buf || !WCHAR ((unsigned char) match[-1]))
			&& (len == end - beg - 1
			    || !WCHAR ((unsigned char) match[len])))
		      goto assess_pattern_match;
		    if (len > 0)
		      {
			/* Try a shorter length anchored at the same place. */
			--len;
			patterns[i].regexbuf.not_eol = 1;
			len = re_match (&(patterns[i].regexbuf),
					buf, match + len - beg, match - buf,
					&(patterns[i].regs));
		      }
		    if (len <= 0)
		      {
			/* Try looking further on. */
			if (match == end - 1)
			  break;
			match++;
			patterns[i].regexbuf.not_eol = 0;
			start = re_search (&(patterns[i].regexbuf),
					   buf, end - buf - 1,
					   match - buf, end - match - 1,
					   &(patterns[i].regs));
			if (start < 0)
			  break;
			len = patterns[i].regs.end[0] - start;
			match = buf + start;
		      }
		  } /* while (match <= best_match) */
	      continue;
	    assess_pattern_match:
	      if (!start_ptr)
		{
		  /* Good enough for a non-exact match.
		     No need to look at further patterns, if any.  */
		  
//Patch 0:
if ((__is_neg(25, &(beg), sizeof (beg), &(match), sizeof (match), &(best_match), sizeof (best_match), &(len), sizeof (len), &(best_len), sizeof (best_len), &(start_ptr), sizeof (start_ptr), &(buf), sizeof (buf), &(start), sizeof (start), &(i), sizeof (i), &(patterns), sizeof (patterns), &(end), sizeof (end), &(ret_val), sizeof (ret_val), &(match_size), sizeof (match_size), &(match_words), sizeof (match_words), &(match_lines), sizeof (match_lines), &(pcount), sizeof (pcount), &(buflim), sizeof (buflim), &(backref), sizeof (backref), &(eol), sizeof (eol), &(mb_start), sizeof (mb_start), &(kwset_exact_matches), sizeof (kwset_exact_matches), &(kwset), sizeof (kwset), &(size), sizeof (size), &(match_icase), sizeof (match_icase), &(eolbyte), sizeof (eolbyte))))
    return -1;
beg = match;

//CodeSeg 1:
		  goto success_in_len;
		}
	      if (match < best_match || (match == best_match && len > best_len))
		{
		  /* Best exact match:  leftmost, then longest.  */
		  best_match = match;
		  best_len = len;
		}
	    } /* if re_search >= 0 */
	} /* for Regex patterns.  */
	if (best_match < end)
	  {
	    /* We have found an exact match.  We were just
	       waiting for the best one (leftmost then longest).  */
	    beg = best_match;
	    len = best_len;
	    goto success_in_len;
	  }
    } /* for (beg = end ..) */

 failure:
  ret_val = -1;
  goto out;

 success:
  len = end - beg;
 success_in_len:
  *match_size = len;
  ret_val = beg - buf;
 out:
  return ret_val;
}

Spawn 1 instances, now Total 68
Counter: 69
Batcher Size:68
Preprocess the following candidate with CondTester:
Priority 9998
At location src/dfasearch.c:361
--Src File: src/dfasearch.c
Fragment 0:
if ((__abst_hole(beg, match, best_match, len, best_len, start_ptr, buf, start, i, patterns, end, ret_val, match_size, match_words, match_lines, pcount, buflim, backref, eol, mb_start, kwset_exact_matches, kwset, size, match_icase, eolbyte)))
    return 0;
beg = match;


CondTester, a patch instance with id 68:
//src_file:src/dfasearch.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); void* memset(void*, int, unsigned long); 
/* dfasearch.c - searching subroutines using dfa and regex for grep.
   Copyright 1992, 1998, 2000, 2007, 2009-2010 Free Software Foundation, Inc.

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 3, or (at your option)
   any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program; if not, write to the Free Software
   Foundation, Inc., 51 Franklin Street - Fifth Floor, Boston, MA
   02110-1301, USA.  */

/* Written August 1992 by Mike Haertel. */

#include <config.h>
#include "search.h"
#include "dfa.h"

/* For -w, we also consider _ to be word constituent.  */
#define WCHAR(C) (ISALNUM(C) || (C) == '_')

/* KWset compiled pattern.  For Ecompile and Gcompile, we compile
   a list of strings, at least one of which is known to occur in
   any string matching the regexp. */
static kwset_t kwset;

/* DFA compiled regexp. */
static struct dfa dfa;

/* The Regex compiled patterns.  */
static struct patterns
{
  /* Regex compiled regexp. */
  struct re_pattern_buffer regexbuf;
  struct re_registers regs; /* This is here on account of a BRAIN-DEAD
			       Q@#%!# library interface in regex.c.  */
} patterns0;

struct patterns *patterns;
size_t pcount;

void
dfaerror (char const *mesg)
{
  error (EXIT_TROUBLE, 0, "%s", mesg);

  /* notreached */
  /* Tell static analyzers that this function does not return.  */
  abort ();
}

/* Number of compiled fixed strings known to exactly match the regexp.
   If kwsexec returns < kwset_exact_matches, then we don't need to
   call the regexp matcher at all. */
static int kwset_exact_matches;

static char const *
kwsincr_case (const char *must)
{
  const char *buf;
  size_t n;

  n = strlen (must);
#ifdef MBS_SUPPORT
  if (match_icase && MB_CUR_MAX > 1)
    buf = mbtolower (must, &n);
  else
#endif
    buf = must;
  return kwsincr (kwset, buf, n);
}

/* If the DFA turns out to have some set of fixed strings one of
   which must occur in the match, then we build a kwset matcher
   to find those strings, and thus quickly filter out impossible
   matches. */
static void
kwsmusts (void)
{
  struct dfamust const *dm;
  char const *err;

  if (dfa.musts)
    {
      kwsinit (&kwset);
      /* First, we compile in the substrings known to be exact
	 matches.  The kwset matcher will return the index
	 of the matching string that it chooses. */
      for (dm = dfa.musts; dm; dm = dm->next)
	{
	  if (!dm->exact)
	    continue;
	  ++kwset_exact_matches;
	  if ((err = kwsincr_case (dm->must)) != NULL)
	    error (EXIT_TROUBLE, 0, "%s", err);
	}
      /* Now, we compile the substrings that will require
	 the use of the regexp matcher.  */
      for (dm = dfa.musts; dm; dm = dm->next)
	{
	  if (dm->exact)
	    continue;
	  if ((err = kwsincr_case (dm->must)) != NULL)
	    error (EXIT_TROUBLE, 0, "%s", err);
	}
      if ((err = kwsprep (kwset)) != NULL)
	error (EXIT_TROUBLE, 0, "%s", err);
    }
}

void
GEAcompile (char const *pattern, size_t size, reg_syntax_t syntax_bits)
{
  const char *err;
  const char *p, *sep;
  size_t total = size;
  char *motif;

  if (match_icase)
    syntax_bits |= RE_ICASE;
  re_set_syntax (syntax_bits);
  dfasyntax (syntax_bits, match_icase, eolbyte);

  /* For GNU regex compiler we have to pass the patterns separately to detect
     errors like "[\nallo\n]\n".  The patterns here are "[", "allo" and "]"
     GNU regex should have raise a syntax error.  The same for backref, where
     the backref should have been local to each pattern.  */
  p = pattern;
  do
    {
      size_t len;
      sep = memchr (p, '\n', total);
      if (sep)
	{
	  len = sep - p;
	  sep++;
	  total -= (len + 1);
	}
      else
	{
	  len = total;
	  total = 0;
	}

      patterns = realloc (patterns, (pcount + 1) * sizeof (*patterns));
      if (patterns == NULL)
	error (EXIT_TROUBLE, errno, _("memory exhausted"));
      patterns[pcount] = patterns0;

      if ((err = re_compile_pattern (p, len,
				    &(patterns[pcount].regexbuf))) != NULL)
	error (EXIT_TROUBLE, 0, "%s", err);
      pcount++;

      p = sep;
    } while (sep && total != 0);

  /* In the match_words and match_lines cases, we use a different pattern
     for the DFA matcher that will quickly throw out cases that won't work.
     Then if DFA succeeds we do some hairy stuff using the regex matcher
     to decide whether the match should really count. */
  if (match_words || match_lines)
    {
      static char const line_beg_no_bk[] = "^(";
      static char const line_end_no_bk[] = ")$";
      static char const word_beg_no_bk[] = "(^|[^[:alnum:]_])(";
      static char const word_end_no_bk[] = ")([^[:alnum:]_]|$)";
      static char const line_beg_bk[] = "^\\(";
      static char const line_end_bk[] = "\\)$";
      static char const word_beg_bk[] = "\\(^\\|[^[:alnum:]_]\\)\\(";
      static char const word_end_bk[] = "\\)\\([^[:alnum:]_]\\|$\\)";
      int bk = !(syntax_bits & RE_NO_BK_PARENS);
      char *n = xmalloc (sizeof word_beg_bk - 1 + size + sizeof word_end_bk);

      strcpy (n, match_lines ? (bk ? line_beg_bk : line_beg_no_bk)
			     : (bk ? word_beg_bk : word_beg_no_bk));
      total = strlen(n);
      memcpy (n + total, pattern, size);
      total += size;
      strcpy (n + total, match_lines ? (bk ? line_end_bk : line_end_no_bk)
				     : (bk ? word_end_bk : word_end_no_bk));
      total += strlen (n + total);
      pattern = motif = n;
      size = total;
    }
  else
    motif = NULL;

  dfacomp (pattern, size, &dfa, 1);
  kwsmusts ();

  free(motif);
}

size_t
EGexecute (char const *buf, size_t size, size_t *match_size,
	   char const *start_ptr)
{
  char const *buflim, *beg, *end, *match, *best_match, *mb_start;
  char eol = eolbyte;
  int backref, start, len, best_len;
  struct kwsmatch kwsm;
  size_t i, ret_val;
#ifdef MBS_SUPPORT
  if (MB_CUR_MAX > 1)
    {
      if (match_icase)
        {
          /* mbtolower adds a NUL byte at the end.  That will provide
	     space for the sentinel byte dfaexec may add.  */
          char *case_buf = mbtolower (buf, &size);
	  if (start_ptr)
	    start_ptr = case_buf + (start_ptr - buf);
          buf = case_buf;
        }
    }
#endif /* MBS_SUPPORT */

  mb_start = buf;
  buflim = buf + size;

  for (beg = end = buf; end < buflim; beg = end)
    {
      if (!start_ptr)
	{
	  /* We don't care about an exact match.  */
	  if (kwset)
	    {
	      /* Find a possible match using the KWset matcher. */
	      size_t offset = kwsexec (kwset, beg, buflim - beg, &kwsm);
	      if (offset == (size_t) -1)
		goto failure;
	      beg += offset;
	      /* Narrow down to the line containing the candidate, and
		 run it through DFA. */
	      if ((end = memchr(beg, eol, buflim - beg)) != NULL)
	        end++;
              else
                end = buflim;
	      match = beg;
	      while (beg > buf && beg[-1] != eol)
		--beg;
	      if (kwsm.index < kwset_exact_matches)
                {
#ifdef MBS_SUPPORT
                  if (mb_start < beg)
                    mb_start = beg;
                  if (MB_CUR_MAX == 1 || !is_mb_middle (&mb_start, match, buflim))
#endif
                    goto success;
                }
	      if (dfaexec (&dfa, beg, (char *) end, 0, NULL, &backref) == NULL)
		continue;
	    }
	  else
	    {
	      /* No good fixed strings; start with DFA. */
	      char const *next_beg = dfaexec (&dfa, beg, (char *) buflim,
					      0, NULL, &backref);
	      if (next_beg == NULL)
		break;
	      /* Narrow down to the line we've found. */
	      beg = next_beg;
	      if ((end = memchr(beg, eol, buflim - beg)) != NULL)
	        end++;
              else
                end = buflim;
	      while (beg > buf && beg[-1] != eol)
		--beg;
	    }
	  /* Successful, no backreferences encountered! */
	  if (!backref)
	    goto success;
	}
      else
	{
	  /* We are looking for the leftmost (then longest) exact match.
	     We will go through the outer loop only once.  */
	  beg = start_ptr;
	  end = buflim;
	}

      /* If we've made it to this point, this means DFA has seen
	 a probable match, and we need to run it through Regex. */
      best_match = end;
      best_len = 0;
      for (i = 0; i < pcount; i++)
	{
	  patterns[i].regexbuf.not_eol = 0;
	  if (0 <= (start = re_search (&(patterns[i].regexbuf),
				       buf, end - buf - 1,
				       beg - buf, end - beg - 1,
				       &(patterns[i].regs))))
	    {
	      len = patterns[i].regs.end[0] - start;
	      match = buf + start;
	      if (match > best_match)
		continue;
	      if (start_ptr && !match_words)
		goto assess_pattern_match;
	      if ((!match_lines && !match_words)
		  || (match_lines && len == end - beg - 1))
		{
		  match = beg;
		  len = end - beg;
		  goto assess_pattern_match;
		}
	      /* If -w, check if the match aligns with word boundaries.
		 We do this iteratively because:
		 (a) the line may contain more than one occurence of the
		 pattern, and
		 (b) Several alternatives in the pattern might be valid at a
		 given point, and we may need to consider a shorter one to
		 find a word boundary.  */
	      if (match_words)
		while (match <= best_match)
		  {
		    if ((match == buf || !WCHAR ((unsigned char) match[-1]))
			&& (len == end - beg - 1
			    || !WCHAR ((unsigned char) match[len])))
		      goto assess_pattern_match;
		    if (len > 0)
		      {
			/* Try a shorter length anchored at the same place. */
			--len;
			patterns[i].regexbuf.not_eol = 1;
			len = re_match (&(patterns[i].regexbuf),
					buf, match + len - beg, match - buf,
					&(patterns[i].regs));
		      }
		    if (len <= 0)
		      {
			/* Try looking further on. */
			if (match == end - 1)
			  break;
			match++;
			patterns[i].regexbuf.not_eol = 0;
			start = re_search (&(patterns[i].regexbuf),
					   buf, end - buf - 1,
					   match - buf, end - match - 1,
					   &(patterns[i].regs));
			if (start < 0)
			  break;
			len = patterns[i].regs.end[0] - start;
			match = buf + start;
		      }
		  } /* while (match <= best_match) */
	      continue;
	    assess_pattern_match:
	      if (!start_ptr)
		{
		  /* Good enough for a non-exact match.
		     No need to look at further patterns, if any.  */
		  
//Patch 0:
if ((__is_neg(25, &(beg), sizeof (beg), &(match), sizeof (match), &(best_match), sizeof (best_match), &(len), sizeof (len), &(best_len), sizeof (best_len), &(start_ptr), sizeof (start_ptr), &(buf), sizeof (buf), &(start), sizeof (start), &(i), sizeof (i), &(patterns), sizeof (patterns), &(end), sizeof (end), &(ret_val), sizeof (ret_val), &(match_size), sizeof (match_size), &(match_words), sizeof (match_words), &(match_lines), sizeof (match_lines), &(pcount), sizeof (pcount), &(buflim), sizeof (buflim), &(backref), sizeof (backref), &(eol), sizeof (eol), &(mb_start), sizeof (mb_start), &(kwset_exact_matches), sizeof (kwset_exact_matches), &(kwset), sizeof (kwset), &(size), sizeof (size), &(match_icase), sizeof (match_icase), &(eolbyte), sizeof (eolbyte))))
    return 0;
beg = match;

//CodeSeg 1:
		  goto success_in_len;
		}
	      if (match < best_match || (match == best_match && len > best_len))
		{
		  /* Best exact match:  leftmost, then longest.  */
		  best_match = match;
		  best_len = len;
		}
	    } /* if re_search >= 0 */
	} /* for Regex patterns.  */
	if (best_match < end)
	  {
	    /* We have found an exact match.  We were just
	       waiting for the best one (leftmost then longest).  */
	    beg = best_match;
	    len = best_len;
	    goto success_in_len;
	  }
    } /* for (beg = end ..) */

 failure:
  ret_val = -1;
  goto out;

 success:
  len = end - beg;
 success_in_len:
  *match_size = len;
  ret_val = beg - buf;
 out:
  return ret_val;
}

Spawn 1 instances, now Total 69
Counter: 70
Batcher Size:69
Preprocess the following candidate with CondTester:
Priority 9998
At location src/dfasearch.c:361
--Src File: src/dfasearch.c
Fragment 0:
if ((__abst_hole(beg, match, best_match, len, best_len, start_ptr, buf, start, i, patterns, end, ret_val, match_size, match_words, match_lines, pcount, buflim, backref, eol, mb_start, kwset_exact_matches, kwset, size, match_icase, eolbyte)))
    return 1;
beg = match;


CondTester, a patch instance with id 69:
//src_file:src/dfasearch.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); void* memset(void*, int, unsigned long); 
/* dfasearch.c - searching subroutines using dfa and regex for grep.
   Copyright 1992, 1998, 2000, 2007, 2009-2010 Free Software Foundation, Inc.

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 3, or (at your option)
   any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program; if not, write to the Free Software
   Foundation, Inc., 51 Franklin Street - Fifth Floor, Boston, MA
   02110-1301, USA.  */

/* Written August 1992 by Mike Haertel. */

#include <config.h>
#include "search.h"
#include "dfa.h"

/* For -w, we also consider _ to be word constituent.  */
#define WCHAR(C) (ISALNUM(C) || (C) == '_')

/* KWset compiled pattern.  For Ecompile and Gcompile, we compile
   a list of strings, at least one of which is known to occur in
   any string matching the regexp. */
static kwset_t kwset;

/* DFA compiled regexp. */
static struct dfa dfa;

/* The Regex compiled patterns.  */
static struct patterns
{
  /* Regex compiled regexp. */
  struct re_pattern_buffer regexbuf;
  struct re_registers regs; /* This is here on account of a BRAIN-DEAD
			       Q@#%!# library interface in regex.c.  */
} patterns0;

struct patterns *patterns;
size_t pcount;

void
dfaerror (char const *mesg)
{
  error (EXIT_TROUBLE, 0, "%s", mesg);

  /* notreached */
  /* Tell static analyzers that this function does not return.  */
  abort ();
}

/* Number of compiled fixed strings known to exactly match the regexp.
   If kwsexec returns < kwset_exact_matches, then we don't need to
   call the regexp matcher at all. */
static int kwset_exact_matches;

static char const *
kwsincr_case (const char *must)
{
  const char *buf;
  size_t n;

  n = strlen (must);
#ifdef MBS_SUPPORT
  if (match_icase && MB_CUR_MAX > 1)
    buf = mbtolower (must, &n);
  else
#endif
    buf = must;
  return kwsincr (kwset, buf, n);
}

/* If the DFA turns out to have some set of fixed strings one of
   which must occur in the match, then we build a kwset matcher
   to find those strings, and thus quickly filter out impossible
   matches. */
static void
kwsmusts (void)
{
  struct dfamust const *dm;
  char const *err;

  if (dfa.musts)
    {
      kwsinit (&kwset);
      /* First, we compile in the substrings known to be exact
	 matches.  The kwset matcher will return the index
	 of the matching string that it chooses. */
      for (dm = dfa.musts; dm; dm = dm->next)
	{
	  if (!dm->exact)
	    continue;
	  ++kwset_exact_matches;
	  if ((err = kwsincr_case (dm->must)) != NULL)
	    error (EXIT_TROUBLE, 0, "%s", err);
	}
      /* Now, we compile the substrings that will require
	 the use of the regexp matcher.  */
      for (dm = dfa.musts; dm; dm = dm->next)
	{
	  if (dm->exact)
	    continue;
	  if ((err = kwsincr_case (dm->must)) != NULL)
	    error (EXIT_TROUBLE, 0, "%s", err);
	}
      if ((err = kwsprep (kwset)) != NULL)
	error (EXIT_TROUBLE, 0, "%s", err);
    }
}

void
GEAcompile (char const *pattern, size_t size, reg_syntax_t syntax_bits)
{
  const char *err;
  const char *p, *sep;
  size_t total = size;
  char *motif;

  if (match_icase)
    syntax_bits |= RE_ICASE;
  re_set_syntax (syntax_bits);
  dfasyntax (syntax_bits, match_icase, eolbyte);

  /* For GNU regex compiler we have to pass the patterns separately to detect
     errors like "[\nallo\n]\n".  The patterns here are "[", "allo" and "]"
     GNU regex should have raise a syntax error.  The same for backref, where
     the backref should have been local to each pattern.  */
  p = pattern;
  do
    {
      size_t len;
      sep = memchr (p, '\n', total);
      if (sep)
	{
	  len = sep - p;
	  sep++;
	  total -= (len + 1);
	}
      else
	{
	  len = total;
	  total = 0;
	}

      patterns = realloc (patterns, (pcount + 1) * sizeof (*patterns));
      if (patterns == NULL)
	error (EXIT_TROUBLE, errno, _("memory exhausted"));
      patterns[pcount] = patterns0;

      if ((err = re_compile_pattern (p, len,
				    &(patterns[pcount].regexbuf))) != NULL)
	error (EXIT_TROUBLE, 0, "%s", err);
      pcount++;

      p = sep;
    } while (sep && total != 0);

  /* In the match_words and match_lines cases, we use a different pattern
     for the DFA matcher that will quickly throw out cases that won't work.
     Then if DFA succeeds we do some hairy stuff using the regex matcher
     to decide whether the match should really count. */
  if (match_words || match_lines)
    {
      static char const line_beg_no_bk[] = "^(";
      static char const line_end_no_bk[] = ")$";
      static char const word_beg_no_bk[] = "(^|[^[:alnum:]_])(";
      static char const word_end_no_bk[] = ")([^[:alnum:]_]|$)";
      static char const line_beg_bk[] = "^\\(";
      static char const line_end_bk[] = "\\)$";
      static char const word_beg_bk[] = "\\(^\\|[^[:alnum:]_]\\)\\(";
      static char const word_end_bk[] = "\\)\\([^[:alnum:]_]\\|$\\)";
      int bk = !(syntax_bits & RE_NO_BK_PARENS);
      char *n = xmalloc (sizeof word_beg_bk - 1 + size + sizeof word_end_bk);

      strcpy (n, match_lines ? (bk ? line_beg_bk : line_beg_no_bk)
			     : (bk ? word_beg_bk : word_beg_no_bk));
      total = strlen(n);
      memcpy (n + total, pattern, size);
      total += size;
      strcpy (n + total, match_lines ? (bk ? line_end_bk : line_end_no_bk)
				     : (bk ? word_end_bk : word_end_no_bk));
      total += strlen (n + total);
      pattern = motif = n;
      size = total;
    }
  else
    motif = NULL;

  dfacomp (pattern, size, &dfa, 1);
  kwsmusts ();

  free(motif);
}

size_t
EGexecute (char const *buf, size_t size, size_t *match_size,
	   char const *start_ptr)
{
  char const *buflim, *beg, *end, *match, *best_match, *mb_start;
  char eol = eolbyte;
  int backref, start, len, best_len;
  struct kwsmatch kwsm;
  size_t i, ret_val;
#ifdef MBS_SUPPORT
  if (MB_CUR_MAX > 1)
    {
      if (match_icase)
        {
          /* mbtolower adds a NUL byte at the end.  That will provide
	     space for the sentinel byte dfaexec may add.  */
          char *case_buf = mbtolower (buf, &size);
	  if (start_ptr)
	    start_ptr = case_buf + (start_ptr - buf);
          buf = case_buf;
        }
    }
#endif /* MBS_SUPPORT */

  mb_start = buf;
  buflim = buf + size;

  for (beg = end = buf; end < buflim; beg = end)
    {
      if (!start_ptr)
	{
	  /* We don't care about an exact match.  */
	  if (kwset)
	    {
	      /* Find a possible match using the KWset matcher. */
	      size_t offset = kwsexec (kwset, beg, buflim - beg, &kwsm);
	      if (offset == (size_t) -1)
		goto failure;
	      beg += offset;
	      /* Narrow down to the line containing the candidate, and
		 run it through DFA. */
	      if ((end = memchr(beg, eol, buflim - beg)) != NULL)
	        end++;
              else
                end = buflim;
	      match = beg;
	      while (beg > buf && beg[-1] != eol)
		--beg;
	      if (kwsm.index < kwset_exact_matches)
                {
#ifdef MBS_SUPPORT
                  if (mb_start < beg)
                    mb_start = beg;
                  if (MB_CUR_MAX == 1 || !is_mb_middle (&mb_start, match, buflim))
#endif
                    goto success;
                }
	      if (dfaexec (&dfa, beg, (char *) end, 0, NULL, &backref) == NULL)
		continue;
	    }
	  else
	    {
	      /* No good fixed strings; start with DFA. */
	      char const *next_beg = dfaexec (&dfa, beg, (char *) buflim,
					      0, NULL, &backref);
	      if (next_beg == NULL)
		break;
	      /* Narrow down to the line we've found. */
	      beg = next_beg;
	      if ((end = memchr(beg, eol, buflim - beg)) != NULL)
	        end++;
              else
                end = buflim;
	      while (beg > buf && beg[-1] != eol)
		--beg;
	    }
	  /* Successful, no backreferences encountered! */
	  if (!backref)
	    goto success;
	}
      else
	{
	  /* We are looking for the leftmost (then longest) exact match.
	     We will go through the outer loop only once.  */
	  beg = start_ptr;
	  end = buflim;
	}

      /* If we've made it to this point, this means DFA has seen
	 a probable match, and we need to run it through Regex. */
      best_match = end;
      best_len = 0;
      for (i = 0; i < pcount; i++)
	{
	  patterns[i].regexbuf.not_eol = 0;
	  if (0 <= (start = re_search (&(patterns[i].regexbuf),
				       buf, end - buf - 1,
				       beg - buf, end - beg - 1,
				       &(patterns[i].regs))))
	    {
	      len = patterns[i].regs.end[0] - start;
	      match = buf + start;
	      if (match > best_match)
		continue;
	      if (start_ptr && !match_words)
		goto assess_pattern_match;
	      if ((!match_lines && !match_words)
		  || (match_lines && len == end - beg - 1))
		{
		  match = beg;
		  len = end - beg;
		  goto assess_pattern_match;
		}
	      /* If -w, check if the match aligns with word boundaries.
		 We do this iteratively because:
		 (a) the line may contain more than one occurence of the
		 pattern, and
		 (b) Several alternatives in the pattern might be valid at a
		 given point, and we may need to consider a shorter one to
		 find a word boundary.  */
	      if (match_words)
		while (match <= best_match)
		  {
		    if ((match == buf || !WCHAR ((unsigned char) match[-1]))
			&& (len == end - beg - 1
			    || !WCHAR ((unsigned char) match[len])))
		      goto assess_pattern_match;
		    if (len > 0)
		      {
			/* Try a shorter length anchored at the same place. */
			--len;
			patterns[i].regexbuf.not_eol = 1;
			len = re_match (&(patterns[i].regexbuf),
					buf, match + len - beg, match - buf,
					&(patterns[i].regs));
		      }
		    if (len <= 0)
		      {
			/* Try looking further on. */
			if (match == end - 1)
			  break;
			match++;
			patterns[i].regexbuf.not_eol = 0;
			start = re_search (&(patterns[i].regexbuf),
					   buf, end - buf - 1,
					   match - buf, end - match - 1,
					   &(patterns[i].regs));
			if (start < 0)
			  break;
			len = patterns[i].regs.end[0] - start;
			match = buf + start;
		      }
		  } /* while (match <= best_match) */
	      continue;
	    assess_pattern_match:
	      if (!start_ptr)
		{
		  /* Good enough for a non-exact match.
		     No need to look at further patterns, if any.  */
		  
//Patch 0:
if ((__is_neg(25, &(beg), sizeof (beg), &(match), sizeof (match), &(best_match), sizeof (best_match), &(len), sizeof (len), &(best_len), sizeof (best_len), &(start_ptr), sizeof (start_ptr), &(buf), sizeof (buf), &(start), sizeof (start), &(i), sizeof (i), &(patterns), sizeof (patterns), &(end), sizeof (end), &(ret_val), sizeof (ret_val), &(match_size), sizeof (match_size), &(match_words), sizeof (match_words), &(match_lines), sizeof (match_lines), &(pcount), sizeof (pcount), &(buflim), sizeof (buflim), &(backref), sizeof (backref), &(eol), sizeof (eol), &(mb_start), sizeof (mb_start), &(kwset_exact_matches), sizeof (kwset_exact_matches), &(kwset), sizeof (kwset), &(size), sizeof (size), &(match_icase), sizeof (match_icase), &(eolbyte), sizeof (eolbyte))))
    return 1;
beg = match;

//CodeSeg 1:
		  goto success_in_len;
		}
	      if (match < best_match || (match == best_match && len > best_len))
		{
		  /* Best exact match:  leftmost, then longest.  */
		  best_match = match;
		  best_len = len;
		}
	    } /* if re_search >= 0 */
	} /* for Regex patterns.  */
	if (best_match < end)
	  {
	    /* We have found an exact match.  We were just
	       waiting for the best one (leftmost then longest).  */
	    beg = best_match;
	    len = best_len;
	    goto success_in_len;
	  }
    } /* for (beg = end ..) */

 failure:
  ret_val = -1;
  goto out;

 success:
  len = end - beg;
 success_in_len:
  *match_size = len;
  ret_val = beg - buf;
 out:
  return ret_val;
}

Spawn 1 instances, now Total 70
Counter: 71
Batcher Size:70
Preprocess the following candidate with CondTester:
Priority 9998
At location src/dfasearch.c:361
--Src File: src/dfasearch.c
Fragment 0:
if ((__abst_hole(beg, match, best_match, len, best_len, start_ptr, buf, start, i, patterns, end, ret_val, match_size, match_words, match_lines, pcount, buflim, backref, eol, mb_start, kwset_exact_matches, kwset, size, match_icase, eolbyte)))
    break;
beg = match;


CondTester, a patch instance with id 70:
//src_file:src/dfasearch.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); void* memset(void*, int, unsigned long); 
/* dfasearch.c - searching subroutines using dfa and regex for grep.
   Copyright 1992, 1998, 2000, 2007, 2009-2010 Free Software Foundation, Inc.

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 3, or (at your option)
   any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program; if not, write to the Free Software
   Foundation, Inc., 51 Franklin Street - Fifth Floor, Boston, MA
   02110-1301, USA.  */

/* Written August 1992 by Mike Haertel. */

#include <config.h>
#include "search.h"
#include "dfa.h"

/* For -w, we also consider _ to be word constituent.  */
#define WCHAR(C) (ISALNUM(C) || (C) == '_')

/* KWset compiled pattern.  For Ecompile and Gcompile, we compile
   a list of strings, at least one of which is known to occur in
   any string matching the regexp. */
static kwset_t kwset;

/* DFA compiled regexp. */
static struct dfa dfa;

/* The Regex compiled patterns.  */
static struct patterns
{
  /* Regex compiled regexp. */
  struct re_pattern_buffer regexbuf;
  struct re_registers regs; /* This is here on account of a BRAIN-DEAD
			       Q@#%!# library interface in regex.c.  */
} patterns0;

struct patterns *patterns;
size_t pcount;

void
dfaerror (char const *mesg)
{
  error (EXIT_TROUBLE, 0, "%s", mesg);

  /* notreached */
  /* Tell static analyzers that this function does not return.  */
  abort ();
}

/* Number of compiled fixed strings known to exactly match the regexp.
   If kwsexec returns < kwset_exact_matches, then we don't need to
   call the regexp matcher at all. */
static int kwset_exact_matches;

static char const *
kwsincr_case (const char *must)
{
  const char *buf;
  size_t n;

  n = strlen (must);
#ifdef MBS_SUPPORT
  if (match_icase && MB_CUR_MAX > 1)
    buf = mbtolower (must, &n);
  else
#endif
    buf = must;
  return kwsincr (kwset, buf, n);
}

/* If the DFA turns out to have some set of fixed strings one of
   which must occur in the match, then we build a kwset matcher
   to find those strings, and thus quickly filter out impossible
   matches. */
static void
kwsmusts (void)
{
  struct dfamust const *dm;
  char const *err;

  if (dfa.musts)
    {
      kwsinit (&kwset);
      /* First, we compile in the substrings known to be exact
	 matches.  The kwset matcher will return the index
	 of the matching string that it chooses. */
      for (dm = dfa.musts; dm; dm = dm->next)
	{
	  if (!dm->exact)
	    continue;
	  ++kwset_exact_matches;
	  if ((err = kwsincr_case (dm->must)) != NULL)
	    error (EXIT_TROUBLE, 0, "%s", err);
	}
      /* Now, we compile the substrings that will require
	 the use of the regexp matcher.  */
      for (dm = dfa.musts; dm; dm = dm->next)
	{
	  if (dm->exact)
	    continue;
	  if ((err = kwsincr_case (dm->must)) != NULL)
	    error (EXIT_TROUBLE, 0, "%s", err);
	}
      if ((err = kwsprep (kwset)) != NULL)
	error (EXIT_TROUBLE, 0, "%s", err);
    }
}

void
GEAcompile (char const *pattern, size_t size, reg_syntax_t syntax_bits)
{
  const char *err;
  const char *p, *sep;
  size_t total = size;
  char *motif;

  if (match_icase)
    syntax_bits |= RE_ICASE;
  re_set_syntax (syntax_bits);
  dfasyntax (syntax_bits, match_icase, eolbyte);

  /* For GNU regex compiler we have to pass the patterns separately to detect
     errors like "[\nallo\n]\n".  The patterns here are "[", "allo" and "]"
     GNU regex should have raise a syntax error.  The same for backref, where
     the backref should have been local to each pattern.  */
  p = pattern;
  do
    {
      size_t len;
      sep = memchr (p, '\n', total);
      if (sep)
	{
	  len = sep - p;
	  sep++;
	  total -= (len + 1);
	}
      else
	{
	  len = total;
	  total = 0;
	}

      patterns = realloc (patterns, (pcount + 1) * sizeof (*patterns));
      if (patterns == NULL)
	error (EXIT_TROUBLE, errno, _("memory exhausted"));
      patterns[pcount] = patterns0;

      if ((err = re_compile_pattern (p, len,
				    &(patterns[pcount].regexbuf))) != NULL)
	error (EXIT_TROUBLE, 0, "%s", err);
      pcount++;

      p = sep;
    } while (sep && total != 0);

  /* In the match_words and match_lines cases, we use a different pattern
     for the DFA matcher that will quickly throw out cases that won't work.
     Then if DFA succeeds we do some hairy stuff using the regex matcher
     to decide whether the match should really count. */
  if (match_words || match_lines)
    {
      static char const line_beg_no_bk[] = "^(";
      static char const line_end_no_bk[] = ")$";
      static char const word_beg_no_bk[] = "(^|[^[:alnum:]_])(";
      static char const word_end_no_bk[] = ")([^[:alnum:]_]|$)";
      static char const line_beg_bk[] = "^\\(";
      static char const line_end_bk[] = "\\)$";
      static char const word_beg_bk[] = "\\(^\\|[^[:alnum:]_]\\)\\(";
      static char const word_end_bk[] = "\\)\\([^[:alnum:]_]\\|$\\)";
      int bk = !(syntax_bits & RE_NO_BK_PARENS);
      char *n = xmalloc (sizeof word_beg_bk - 1 + size + sizeof word_end_bk);

      strcpy (n, match_lines ? (bk ? line_beg_bk : line_beg_no_bk)
			     : (bk ? word_beg_bk : word_beg_no_bk));
      total = strlen(n);
      memcpy (n + total, pattern, size);
      total += size;
      strcpy (n + total, match_lines ? (bk ? line_end_bk : line_end_no_bk)
				     : (bk ? word_end_bk : word_end_no_bk));
      total += strlen (n + total);
      pattern = motif = n;
      size = total;
    }
  else
    motif = NULL;

  dfacomp (pattern, size, &dfa, 1);
  kwsmusts ();

  free(motif);
}

size_t
EGexecute (char const *buf, size_t size, size_t *match_size,
	   char const *start_ptr)
{
  char const *buflim, *beg, *end, *match, *best_match, *mb_start;
  char eol = eolbyte;
  int backref, start, len, best_len;
  struct kwsmatch kwsm;
  size_t i, ret_val;
#ifdef MBS_SUPPORT
  if (MB_CUR_MAX > 1)
    {
      if (match_icase)
        {
          /* mbtolower adds a NUL byte at the end.  That will provide
	     space for the sentinel byte dfaexec may add.  */
          char *case_buf = mbtolower (buf, &size);
	  if (start_ptr)
	    start_ptr = case_buf + (start_ptr - buf);
          buf = case_buf;
        }
    }
#endif /* MBS_SUPPORT */

  mb_start = buf;
  buflim = buf + size;

  for (beg = end = buf; end < buflim; beg = end)
    {
      if (!start_ptr)
	{
	  /* We don't care about an exact match.  */
	  if (kwset)
	    {
	      /* Find a possible match using the KWset matcher. */
	      size_t offset = kwsexec (kwset, beg, buflim - beg, &kwsm);
	      if (offset == (size_t) -1)
		goto failure;
	      beg += offset;
	      /* Narrow down to the line containing the candidate, and
		 run it through DFA. */
	      if ((end = memchr(beg, eol, buflim - beg)) != NULL)
	        end++;
              else
                end = buflim;
	      match = beg;
	      while (beg > buf && beg[-1] != eol)
		--beg;
	      if (kwsm.index < kwset_exact_matches)
                {
#ifdef MBS_SUPPORT
                  if (mb_start < beg)
                    mb_start = beg;
                  if (MB_CUR_MAX == 1 || !is_mb_middle (&mb_start, match, buflim))
#endif
                    goto success;
                }
	      if (dfaexec (&dfa, beg, (char *) end, 0, NULL, &backref) == NULL)
		continue;
	    }
	  else
	    {
	      /* No good fixed strings; start with DFA. */
	      char const *next_beg = dfaexec (&dfa, beg, (char *) buflim,
					      0, NULL, &backref);
	      if (next_beg == NULL)
		break;
	      /* Narrow down to the line we've found. */
	      beg = next_beg;
	      if ((end = memchr(beg, eol, buflim - beg)) != NULL)
	        end++;
              else
                end = buflim;
	      while (beg > buf && beg[-1] != eol)
		--beg;
	    }
	  /* Successful, no backreferences encountered! */
	  if (!backref)
	    goto success;
	}
      else
	{
	  /* We are looking for the leftmost (then longest) exact match.
	     We will go through the outer loop only once.  */
	  beg = start_ptr;
	  end = buflim;
	}

      /* If we've made it to this point, this means DFA has seen
	 a probable match, and we need to run it through Regex. */
      best_match = end;
      best_len = 0;
      for (i = 0; i < pcount; i++)
	{
	  patterns[i].regexbuf.not_eol = 0;
	  if (0 <= (start = re_search (&(patterns[i].regexbuf),
				       buf, end - buf - 1,
				       beg - buf, end - beg - 1,
				       &(patterns[i].regs))))
	    {
	      len = patterns[i].regs.end[0] - start;
	      match = buf + start;
	      if (match > best_match)
		continue;
	      if (start_ptr && !match_words)
		goto assess_pattern_match;
	      if ((!match_lines && !match_words)
		  || (match_lines && len == end - beg - 1))
		{
		  match = beg;
		  len = end - beg;
		  goto assess_pattern_match;
		}
	      /* If -w, check if the match aligns with word boundaries.
		 We do this iteratively because:
		 (a) the line may contain more than one occurence of the
		 pattern, and
		 (b) Several alternatives in the pattern might be valid at a
		 given point, and we may need to consider a shorter one to
		 find a word boundary.  */
	      if (match_words)
		while (match <= best_match)
		  {
		    if ((match == buf || !WCHAR ((unsigned char) match[-1]))
			&& (len == end - beg - 1
			    || !WCHAR ((unsigned char) match[len])))
		      goto assess_pattern_match;
		    if (len > 0)
		      {
			/* Try a shorter length anchored at the same place. */
			--len;
			patterns[i].regexbuf.not_eol = 1;
			len = re_match (&(patterns[i].regexbuf),
					buf, match + len - beg, match - buf,
					&(patterns[i].regs));
		      }
		    if (len <= 0)
		      {
			/* Try looking further on. */
			if (match == end - 1)
			  break;
			match++;
			patterns[i].regexbuf.not_eol = 0;
			start = re_search (&(patterns[i].regexbuf),
					   buf, end - buf - 1,
					   match - buf, end - match - 1,
					   &(patterns[i].regs));
			if (start < 0)
			  break;
			len = patterns[i].regs.end[0] - start;
			match = buf + start;
		      }
		  } /* while (match <= best_match) */
	      continue;
	    assess_pattern_match:
	      if (!start_ptr)
		{
		  /* Good enough for a non-exact match.
		     No need to look at further patterns, if any.  */
		  
//Patch 0:
if ((__is_neg(25, &(beg), sizeof (beg), &(match), sizeof (match), &(best_match), sizeof (best_match), &(len), sizeof (len), &(best_len), sizeof (best_len), &(start_ptr), sizeof (start_ptr), &(buf), sizeof (buf), &(start), sizeof (start), &(i), sizeof (i), &(patterns), sizeof (patterns), &(end), sizeof (end), &(ret_val), sizeof (ret_val), &(match_size), sizeof (match_size), &(match_words), sizeof (match_words), &(match_lines), sizeof (match_lines), &(pcount), sizeof (pcount), &(buflim), sizeof (buflim), &(backref), sizeof (backref), &(eol), sizeof (eol), &(mb_start), sizeof (mb_start), &(kwset_exact_matches), sizeof (kwset_exact_matches), &(kwset), sizeof (kwset), &(size), sizeof (size), &(match_icase), sizeof (match_icase), &(eolbyte), sizeof (eolbyte))))
    break;
beg = match;

//CodeSeg 1:
		  goto success_in_len;
		}
	      if (match < best_match || (match == best_match && len > best_len))
		{
		  /* Best exact match:  leftmost, then longest.  */
		  best_match = match;
		  best_len = len;
		}
	    } /* if re_search >= 0 */
	} /* for Regex patterns.  */
	if (best_match < end)
	  {
	    /* We have found an exact match.  We were just
	       waiting for the best one (leftmost then longest).  */
	    beg = best_match;
	    len = best_len;
	    goto success_in_len;
	  }
    } /* for (beg = end ..) */

 failure:
  ret_val = -1;
  goto out;

 success:
  len = end - beg;
 success_in_len:
  *match_size = len;
  ret_val = beg - buf;
 out:
  return ret_val;
}

Spawn 1 instances, now Total 71
Counter: 72
Batcher Size:71
Preprocess the following candidate with CondTester:
Priority 9989
At location src/dfasearch.c:302
--Src File: src/dfasearch.c
Fragment 0:
if ((__abst_hole(start, len, i, patterns, patterns[i].regs.end, buf, match, best_match, beg, end, start_ptr, match_words, match_lines, pcount, best_len, buflim, backref, eol, mb_start, kwset_exact_matches, kwset, size, ret_val, match_size, match_icase, eolbyte, patterns[i].regs.num_regs, patterns[i].regs.start)))
    return -1;
len = patterns[i].regs.end[0] - start;


CondTester, a patch instance with id 71:
//src_file:src/dfasearch.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); void* memset(void*, int, unsigned long); 
/* dfasearch.c - searching subroutines using dfa and regex for grep.
   Copyright 1992, 1998, 2000, 2007, 2009-2010 Free Software Foundation, Inc.

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 3, or (at your option)
   any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program; if not, write to the Free Software
   Foundation, Inc., 51 Franklin Street - Fifth Floor, Boston, MA
   02110-1301, USA.  */

/* Written August 1992 by Mike Haertel. */

#include <config.h>
#include "search.h"
#include "dfa.h"

/* For -w, we also consider _ to be word constituent.  */
#define WCHAR(C) (ISALNUM(C) || (C) == '_')

/* KWset compiled pattern.  For Ecompile and Gcompile, we compile
   a list of strings, at least one of which is known to occur in
   any string matching the regexp. */
static kwset_t kwset;

/* DFA compiled regexp. */
static struct dfa dfa;

/* The Regex compiled patterns.  */
static struct patterns
{
  /* Regex compiled regexp. */
  struct re_pattern_buffer regexbuf;
  struct re_registers regs; /* This is here on account of a BRAIN-DEAD
			       Q@#%!# library interface in regex.c.  */
} patterns0;

struct patterns *patterns;
size_t pcount;

void
dfaerror (char const *mesg)
{
  error (EXIT_TROUBLE, 0, "%s", mesg);

  /* notreached */
  /* Tell static analyzers that this function does not return.  */
  abort ();
}

/* Number of compiled fixed strings known to exactly match the regexp.
   If kwsexec returns < kwset_exact_matches, then we don't need to
   call the regexp matcher at all. */
static int kwset_exact_matches;

static char const *
kwsincr_case (const char *must)
{
  const char *buf;
  size_t n;

  n = strlen (must);
#ifdef MBS_SUPPORT
  if (match_icase && MB_CUR_MAX > 1)
    buf = mbtolower (must, &n);
  else
#endif
    buf = must;
  return kwsincr (kwset, buf, n);
}

/* If the DFA turns out to have some set of fixed strings one of
   which must occur in the match, then we build a kwset matcher
   to find those strings, and thus quickly filter out impossible
   matches. */
static void
kwsmusts (void)
{
  struct dfamust const *dm;
  char const *err;

  if (dfa.musts)
    {
      kwsinit (&kwset);
      /* First, we compile in the substrings known to be exact
	 matches.  The kwset matcher will return the index
	 of the matching string that it chooses. */
      for (dm = dfa.musts; dm; dm = dm->next)
	{
	  if (!dm->exact)
	    continue;
	  ++kwset_exact_matches;
	  if ((err = kwsincr_case (dm->must)) != NULL)
	    error (EXIT_TROUBLE, 0, "%s", err);
	}
      /* Now, we compile the substrings that will require
	 the use of the regexp matcher.  */
      for (dm = dfa.musts; dm; dm = dm->next)
	{
	  if (dm->exact)
	    continue;
	  if ((err = kwsincr_case (dm->must)) != NULL)
	    error (EXIT_TROUBLE, 0, "%s", err);
	}
      if ((err = kwsprep (kwset)) != NULL)
	error (EXIT_TROUBLE, 0, "%s", err);
    }
}

void
GEAcompile (char const *pattern, size_t size, reg_syntax_t syntax_bits)
{
  const char *err;
  const char *p, *sep;
  size_t total = size;
  char *motif;

  if (match_icase)
    syntax_bits |= RE_ICASE;
  re_set_syntax (syntax_bits);
  dfasyntax (syntax_bits, match_icase, eolbyte);

  /* For GNU regex compiler we have to pass the patterns separately to detect
     errors like "[\nallo\n]\n".  The patterns here are "[", "allo" and "]"
     GNU regex should have raise a syntax error.  The same for backref, where
     the backref should have been local to each pattern.  */
  p = pattern;
  do
    {
      size_t len;
      sep = memchr (p, '\n', total);
      if (sep)
	{
	  len = sep - p;
	  sep++;
	  total -= (len + 1);
	}
      else
	{
	  len = total;
	  total = 0;
	}

      patterns = realloc (patterns, (pcount + 1) * sizeof (*patterns));
      if (patterns == NULL)
	error (EXIT_TROUBLE, errno, _("memory exhausted"));
      patterns[pcount] = patterns0;

      if ((err = re_compile_pattern (p, len,
				    &(patterns[pcount].regexbuf))) != NULL)
	error (EXIT_TROUBLE, 0, "%s", err);
      pcount++;

      p = sep;
    } while (sep && total != 0);

  /* In the match_words and match_lines cases, we use a different pattern
     for the DFA matcher that will quickly throw out cases that won't work.
     Then if DFA succeeds we do some hairy stuff using the regex matcher
     to decide whether the match should really count. */
  if (match_words || match_lines)
    {
      static char const line_beg_no_bk[] = "^(";
      static char const line_end_no_bk[] = ")$";
      static char const word_beg_no_bk[] = "(^|[^[:alnum:]_])(";
      static char const word_end_no_bk[] = ")([^[:alnum:]_]|$)";
      static char const line_beg_bk[] = "^\\(";
      static char const line_end_bk[] = "\\)$";
      static char const word_beg_bk[] = "\\(^\\|[^[:alnum:]_]\\)\\(";
      static char const word_end_bk[] = "\\)\\([^[:alnum:]_]\\|$\\)";
      int bk = !(syntax_bits & RE_NO_BK_PARENS);
      char *n = xmalloc (sizeof word_beg_bk - 1 + size + sizeof word_end_bk);

      strcpy (n, match_lines ? (bk ? line_beg_bk : line_beg_no_bk)
			     : (bk ? word_beg_bk : word_beg_no_bk));
      total = strlen(n);
      memcpy (n + total, pattern, size);
      total += size;
      strcpy (n + total, match_lines ? (bk ? line_end_bk : line_end_no_bk)
				     : (bk ? word_end_bk : word_end_no_bk));
      total += strlen (n + total);
      pattern = motif = n;
      size = total;
    }
  else
    motif = NULL;

  dfacomp (pattern, size, &dfa, 1);
  kwsmusts ();

  free(motif);
}

size_t
EGexecute (char const *buf, size_t size, size_t *match_size,
	   char const *start_ptr)
{
  char const *buflim, *beg, *end, *match, *best_match, *mb_start;
  char eol = eolbyte;
  int backref, start, len, best_len;
  struct kwsmatch kwsm;
  size_t i, ret_val;
#ifdef MBS_SUPPORT
  if (MB_CUR_MAX > 1)
    {
      if (match_icase)
        {
          /* mbtolower adds a NUL byte at the end.  That will provide
	     space for the sentinel byte dfaexec may add.  */
          char *case_buf = mbtolower (buf, &size);
	  if (start_ptr)
	    start_ptr = case_buf + (start_ptr - buf);
          buf = case_buf;
        }
    }
#endif /* MBS_SUPPORT */

  mb_start = buf;
  buflim = buf + size;

  for (beg = end = buf; end < buflim; beg = end)
    {
      if (!start_ptr)
	{
	  /* We don't care about an exact match.  */
	  if (kwset)
	    {
	      /* Find a possible match using the KWset matcher. */
	      size_t offset = kwsexec (kwset, beg, buflim - beg, &kwsm);
	      if (offset == (size_t) -1)
		goto failure;
	      beg += offset;
	      /* Narrow down to the line containing the candidate, and
		 run it through DFA. */
	      if ((end = memchr(beg, eol, buflim - beg)) != NULL)
	        end++;
              else
                end = buflim;
	      match = beg;
	      while (beg > buf && beg[-1] != eol)
		--beg;
	      if (kwsm.index < kwset_exact_matches)
                {
#ifdef MBS_SUPPORT
                  if (mb_start < beg)
                    mb_start = beg;
                  if (MB_CUR_MAX == 1 || !is_mb_middle (&mb_start, match, buflim))
#endif
                    goto success;
                }
	      if (dfaexec (&dfa, beg, (char *) end, 0, NULL, &backref) == NULL)
		continue;
	    }
	  else
	    {
	      /* No good fixed strings; start with DFA. */
	      char const *next_beg = dfaexec (&dfa, beg, (char *) buflim,
					      0, NULL, &backref);
	      if (next_beg == NULL)
		break;
	      /* Narrow down to the line we've found. */
	      beg = next_beg;
	      if ((end = memchr(beg, eol, buflim - beg)) != NULL)
	        end++;
              else
                end = buflim;
	      while (beg > buf && beg[-1] != eol)
		--beg;
	    }
	  /* Successful, no backreferences encountered! */
	  if (!backref)
	    goto success;
	}
      else
	{
	  /* We are looking for the leftmost (then longest) exact match.
	     We will go through the outer loop only once.  */
	  beg = start_ptr;
	  end = buflim;
	}

      /* If we've made it to this point, this means DFA has seen
	 a probable match, and we need to run it through Regex. */
      best_match = end;
      best_len = 0;
      for (i = 0; i < pcount; i++)
	{
	  patterns[i].regexbuf.not_eol = 0;
	  if (0 <= (start = re_search (&(patterns[i].regexbuf),
				       buf, end - buf - 1,
				       beg - buf, end - beg - 1,
				       &(patterns[i].regs))))
	    {
	      
//Patch 0:
if ((__is_neg(28, &(start), sizeof (start), &(len), sizeof (len), &(i), sizeof (i), &(patterns), sizeof (patterns), &(patterns[i].regs.end), sizeof (patterns[i].regs.end), &(buf), sizeof (buf), &(match), sizeof (match), &(best_match), sizeof (best_match), &(beg), sizeof (beg), &(end), sizeof (end), &(start_ptr), sizeof (start_ptr), &(match_words), sizeof (match_words), &(match_lines), sizeof (match_lines), &(pcount), sizeof (pcount), &(best_len), sizeof (best_len), &(buflim), sizeof (buflim), &(backref), sizeof (backref), &(eol), sizeof (eol), &(mb_start), sizeof (mb_start), &(kwset_exact_matches), sizeof (kwset_exact_matches), &(kwset), sizeof (kwset), &(size), sizeof (size), &(ret_val), sizeof (ret_val), &(match_size), sizeof (match_size), &(match_icase), sizeof (match_icase), &(eolbyte), sizeof (eolbyte), &(patterns[i].regs.num_regs), sizeof (patterns[i].regs.num_regs), &(patterns[i].regs.start), sizeof (patterns[i].regs.start))))
    return -1;
len = patterns[i].regs.end[0] - start;

//CodeSeg 1:
	      match = buf + start;
	      if (match > best_match)
		continue;
	      if (start_ptr && !match_words)
		goto assess_pattern_match;
	      if ((!match_lines && !match_words)
		  || (match_lines && len == end - beg - 1))
		{
		  match = beg;
		  len = end - beg;
		  goto assess_pattern_match;
		}
	      /* If -w, check if the match aligns with word boundaries.
		 We do this iteratively because:
		 (a) the line may contain more than one occurence of the
		 pattern, and
		 (b) Several alternatives in the pattern might be valid at a
		 given point, and we may need to consider a shorter one to
		 find a word boundary.  */
	      if (match_words)
		while (match <= best_match)
		  {
		    if ((match == buf || !WCHAR ((unsigned char) match[-1]))
			&& (len == end - beg - 1
			    || !WCHAR ((unsigned char) match[len])))
		      goto assess_pattern_match;
		    if (len > 0)
		      {
			/* Try a shorter length anchored at the same place. */
			--len;
			patterns[i].regexbuf.not_eol = 1;
			len = re_match (&(patterns[i].regexbuf),
					buf, match + len - beg, match - buf,
					&(patterns[i].regs));
		      }
		    if (len <= 0)
		      {
			/* Try looking further on. */
			if (match == end - 1)
			  break;
			match++;
			patterns[i].regexbuf.not_eol = 0;
			start = re_search (&(patterns[i].regexbuf),
					   buf, end - buf - 1,
					   match - buf, end - match - 1,
					   &(patterns[i].regs));
			if (start < 0)
			  break;
			len = patterns[i].regs.end[0] - start;
			match = buf + start;
		      }
		  } /* while (match <= best_match) */
	      continue;
	    assess_pattern_match:
	      if (!start_ptr)
		{
		  /* Good enough for a non-exact match.
		     No need to look at further patterns, if any.  */
		  beg = match;
		  goto success_in_len;
		}
	      if (match < best_match || (match == best_match && len > best_len))
		{
		  /* Best exact match:  leftmost, then longest.  */
		  best_match = match;
		  best_len = len;
		}
	    } /* if re_search >= 0 */
	} /* for Regex patterns.  */
	if (best_match < end)
	  {
	    /* We have found an exact match.  We were just
	       waiting for the best one (leftmost then longest).  */
	    beg = best_match;
	    len = best_len;
	    goto success_in_len;
	  }
    } /* for (beg = end ..) */

 failure:
  ret_val = -1;
  goto out;

 success:
  len = end - beg;
 success_in_len:
  *match_size = len;
  ret_val = beg - buf;
 out:
  return ret_val;
}

Spawn 1 instances, now Total 72
Counter: 73
Batcher Size:72
Preprocess the following candidate with CondTester:
Priority 9989
At location src/dfasearch.c:302
--Src File: src/dfasearch.c
Fragment 0:
if ((__abst_hole(start, len, i, patterns, patterns[i].regs.end, buf, match, best_match, beg, end, start_ptr, match_words, match_lines, pcount, best_len, buflim, backref, eol, mb_start, kwset_exact_matches, kwset, size, ret_val, match_size, match_icase, eolbyte, patterns[i].regs.num_regs, patterns[i].regs.start)))
    return 0;
len = patterns[i].regs.end[0] - start;


CondTester, a patch instance with id 72:
//src_file:src/dfasearch.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); void* memset(void*, int, unsigned long); 
/* dfasearch.c - searching subroutines using dfa and regex for grep.
   Copyright 1992, 1998, 2000, 2007, 2009-2010 Free Software Foundation, Inc.

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 3, or (at your option)
   any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program; if not, write to the Free Software
   Foundation, Inc., 51 Franklin Street - Fifth Floor, Boston, MA
   02110-1301, USA.  */

/* Written August 1992 by Mike Haertel. */

#include <config.h>
#include "search.h"
#include "dfa.h"

/* For -w, we also consider _ to be word constituent.  */
#define WCHAR(C) (ISALNUM(C) || (C) == '_')

/* KWset compiled pattern.  For Ecompile and Gcompile, we compile
   a list of strings, at least one of which is known to occur in
   any string matching the regexp. */
static kwset_t kwset;

/* DFA compiled regexp. */
static struct dfa dfa;

/* The Regex compiled patterns.  */
static struct patterns
{
  /* Regex compiled regexp. */
  struct re_pattern_buffer regexbuf;
  struct re_registers regs; /* This is here on account of a BRAIN-DEAD
			       Q@#%!# library interface in regex.c.  */
} patterns0;

struct patterns *patterns;
size_t pcount;

void
dfaerror (char const *mesg)
{
  error (EXIT_TROUBLE, 0, "%s", mesg);

  /* notreached */
  /* Tell static analyzers that this function does not return.  */
  abort ();
}

/* Number of compiled fixed strings known to exactly match the regexp.
   If kwsexec returns < kwset_exact_matches, then we don't need to
   call the regexp matcher at all. */
static int kwset_exact_matches;

static char const *
kwsincr_case (const char *must)
{
  const char *buf;
  size_t n;

  n = strlen (must);
#ifdef MBS_SUPPORT
  if (match_icase && MB_CUR_MAX > 1)
    buf = mbtolower (must, &n);
  else
#endif
    buf = must;
  return kwsincr (kwset, buf, n);
}

/* If the DFA turns out to have some set of fixed strings one of
   which must occur in the match, then we build a kwset matcher
   to find those strings, and thus quickly filter out impossible
   matches. */
static void
kwsmusts (void)
{
  struct dfamust const *dm;
  char const *err;

  if (dfa.musts)
    {
      kwsinit (&kwset);
      /* First, we compile in the substrings known to be exact
	 matches.  The kwset matcher will return the index
	 of the matching string that it chooses. */
      for (dm = dfa.musts; dm; dm = dm->next)
	{
	  if (!dm->exact)
	    continue;
	  ++kwset_exact_matches;
	  if ((err = kwsincr_case (dm->must)) != NULL)
	    error (EXIT_TROUBLE, 0, "%s", err);
	}
      /* Now, we compile the substrings that will require
	 the use of the regexp matcher.  */
      for (dm = dfa.musts; dm; dm = dm->next)
	{
	  if (dm->exact)
	    continue;
	  if ((err = kwsincr_case (dm->must)) != NULL)
	    error (EXIT_TROUBLE, 0, "%s", err);
	}
      if ((err = kwsprep (kwset)) != NULL)
	error (EXIT_TROUBLE, 0, "%s", err);
    }
}

void
GEAcompile (char const *pattern, size_t size, reg_syntax_t syntax_bits)
{
  const char *err;
  const char *p, *sep;
  size_t total = size;
  char *motif;

  if (match_icase)
    syntax_bits |= RE_ICASE;
  re_set_syntax (syntax_bits);
  dfasyntax (syntax_bits, match_icase, eolbyte);

  /* For GNU regex compiler we have to pass the patterns separately to detect
     errors like "[\nallo\n]\n".  The patterns here are "[", "allo" and "]"
     GNU regex should have raise a syntax error.  The same for backref, where
     the backref should have been local to each pattern.  */
  p = pattern;
  do
    {
      size_t len;
      sep = memchr (p, '\n', total);
      if (sep)
	{
	  len = sep - p;
	  sep++;
	  total -= (len + 1);
	}
      else
	{
	  len = total;
	  total = 0;
	}

      patterns = realloc (patterns, (pcount + 1) * sizeof (*patterns));
      if (patterns == NULL)
	error (EXIT_TROUBLE, errno, _("memory exhausted"));
      patterns[pcount] = patterns0;

      if ((err = re_compile_pattern (p, len,
				    &(patterns[pcount].regexbuf))) != NULL)
	error (EXIT_TROUBLE, 0, "%s", err);
      pcount++;

      p = sep;
    } while (sep && total != 0);

  /* In the match_words and match_lines cases, we use a different pattern
     for the DFA matcher that will quickly throw out cases that won't work.
     Then if DFA succeeds we do some hairy stuff using the regex matcher
     to decide whether the match should really count. */
  if (match_words || match_lines)
    {
      static char const line_beg_no_bk[] = "^(";
      static char const line_end_no_bk[] = ")$";
      static char const word_beg_no_bk[] = "(^|[^[:alnum:]_])(";
      static char const word_end_no_bk[] = ")([^[:alnum:]_]|$)";
      static char const line_beg_bk[] = "^\\(";
      static char const line_end_bk[] = "\\)$";
      static char const word_beg_bk[] = "\\(^\\|[^[:alnum:]_]\\)\\(";
      static char const word_end_bk[] = "\\)\\([^[:alnum:]_]\\|$\\)";
      int bk = !(syntax_bits & RE_NO_BK_PARENS);
      char *n = xmalloc (sizeof word_beg_bk - 1 + size + sizeof word_end_bk);

      strcpy (n, match_lines ? (bk ? line_beg_bk : line_beg_no_bk)
			     : (bk ? word_beg_bk : word_beg_no_bk));
      total = strlen(n);
      memcpy (n + total, pattern, size);
      total += size;
      strcpy (n + total, match_lines ? (bk ? line_end_bk : line_end_no_bk)
				     : (bk ? word_end_bk : word_end_no_bk));
      total += strlen (n + total);
      pattern = motif = n;
      size = total;
    }
  else
    motif = NULL;

  dfacomp (pattern, size, &dfa, 1);
  kwsmusts ();

  free(motif);
}

size_t
EGexecute (char const *buf, size_t size, size_t *match_size,
	   char const *start_ptr)
{
  char const *buflim, *beg, *end, *match, *best_match, *mb_start;
  char eol = eolbyte;
  int backref, start, len, best_len;
  struct kwsmatch kwsm;
  size_t i, ret_val;
#ifdef MBS_SUPPORT
  if (MB_CUR_MAX > 1)
    {
      if (match_icase)
        {
          /* mbtolower adds a NUL byte at the end.  That will provide
	     space for the sentinel byte dfaexec may add.  */
          char *case_buf = mbtolower (buf, &size);
	  if (start_ptr)
	    start_ptr = case_buf + (start_ptr - buf);
          buf = case_buf;
        }
    }
#endif /* MBS_SUPPORT */

  mb_start = buf;
  buflim = buf + size;

  for (beg = end = buf; end < buflim; beg = end)
    {
      if (!start_ptr)
	{
	  /* We don't care about an exact match.  */
	  if (kwset)
	    {
	      /* Find a possible match using the KWset matcher. */
	      size_t offset = kwsexec (kwset, beg, buflim - beg, &kwsm);
	      if (offset == (size_t) -1)
		goto failure;
	      beg += offset;
	      /* Narrow down to the line containing the candidate, and
		 run it through DFA. */
	      if ((end = memchr(beg, eol, buflim - beg)) != NULL)
	        end++;
              else
                end = buflim;
	      match = beg;
	      while (beg > buf && beg[-1] != eol)
		--beg;
	      if (kwsm.index < kwset_exact_matches)
                {
#ifdef MBS_SUPPORT
                  if (mb_start < beg)
                    mb_start = beg;
                  if (MB_CUR_MAX == 1 || !is_mb_middle (&mb_start, match, buflim))
#endif
                    goto success;
                }
	      if (dfaexec (&dfa, beg, (char *) end, 0, NULL, &backref) == NULL)
		continue;
	    }
	  else
	    {
	      /* No good fixed strings; start with DFA. */
	      char const *next_beg = dfaexec (&dfa, beg, (char *) buflim,
					      0, NULL, &backref);
	      if (next_beg == NULL)
		break;
	      /* Narrow down to the line we've found. */
	      beg = next_beg;
	      if ((end = memchr(beg, eol, buflim - beg)) != NULL)
	        end++;
              else
                end = buflim;
	      while (beg > buf && beg[-1] != eol)
		--beg;
	    }
	  /* Successful, no backreferences encountered! */
	  if (!backref)
	    goto success;
	}
      else
	{
	  /* We are looking for the leftmost (then longest) exact match.
	     We will go through the outer loop only once.  */
	  beg = start_ptr;
	  end = buflim;
	}

      /* If we've made it to this point, this means DFA has seen
	 a probable match, and we need to run it through Regex. */
      best_match = end;
      best_len = 0;
      for (i = 0; i < pcount; i++)
	{
	  patterns[i].regexbuf.not_eol = 0;
	  if (0 <= (start = re_search (&(patterns[i].regexbuf),
				       buf, end - buf - 1,
				       beg - buf, end - beg - 1,
				       &(patterns[i].regs))))
	    {
	      
//Patch 0:
if ((__is_neg(28, &(start), sizeof (start), &(len), sizeof (len), &(i), sizeof (i), &(patterns), sizeof (patterns), &(patterns[i].regs.end), sizeof (patterns[i].regs.end), &(buf), sizeof (buf), &(match), sizeof (match), &(best_match), sizeof (best_match), &(beg), sizeof (beg), &(end), sizeof (end), &(start_ptr), sizeof (start_ptr), &(match_words), sizeof (match_words), &(match_lines), sizeof (match_lines), &(pcount), sizeof (pcount), &(best_len), sizeof (best_len), &(buflim), sizeof (buflim), &(backref), sizeof (backref), &(eol), sizeof (eol), &(mb_start), sizeof (mb_start), &(kwset_exact_matches), sizeof (kwset_exact_matches), &(kwset), sizeof (kwset), &(size), sizeof (size), &(ret_val), sizeof (ret_val), &(match_size), sizeof (match_size), &(match_icase), sizeof (match_icase), &(eolbyte), sizeof (eolbyte), &(patterns[i].regs.num_regs), sizeof (patterns[i].regs.num_regs), &(patterns[i].regs.start), sizeof (patterns[i].regs.start))))
    return 0;
len = patterns[i].regs.end[0] - start;

//CodeSeg 1:
	      match = buf + start;
	      if (match > best_match)
		continue;
	      if (start_ptr && !match_words)
		goto assess_pattern_match;
	      if ((!match_lines && !match_words)
		  || (match_lines && len == end - beg - 1))
		{
		  match = beg;
		  len = end - beg;
		  goto assess_pattern_match;
		}
	      /* If -w, check if the match aligns with word boundaries.
		 We do this iteratively because:
		 (a) the line may contain more than one occurence of the
		 pattern, and
		 (b) Several alternatives in the pattern might be valid at a
		 given point, and we may need to consider a shorter one to
		 find a word boundary.  */
	      if (match_words)
		while (match <= best_match)
		  {
		    if ((match == buf || !WCHAR ((unsigned char) match[-1]))
			&& (len == end - beg - 1
			    || !WCHAR ((unsigned char) match[len])))
		      goto assess_pattern_match;
		    if (len > 0)
		      {
			/* Try a shorter length anchored at the same place. */
			--len;
			patterns[i].regexbuf.not_eol = 1;
			len = re_match (&(patterns[i].regexbuf),
					buf, match + len - beg, match - buf,
					&(patterns[i].regs));
		      }
		    if (len <= 0)
		      {
			/* Try looking further on. */
			if (match == end - 1)
			  break;
			match++;
			patterns[i].regexbuf.not_eol = 0;
			start = re_search (&(patterns[i].regexbuf),
					   buf, end - buf - 1,
					   match - buf, end - match - 1,
					   &(patterns[i].regs));
			if (start < 0)
			  break;
			len = patterns[i].regs.end[0] - start;
			match = buf + start;
		      }
		  } /* while (match <= best_match) */
	      continue;
	    assess_pattern_match:
	      if (!start_ptr)
		{
		  /* Good enough for a non-exact match.
		     No need to look at further patterns, if any.  */
		  beg = match;
		  goto success_in_len;
		}
	      if (match < best_match || (match == best_match && len > best_len))
		{
		  /* Best exact match:  leftmost, then longest.  */
		  best_match = match;
		  best_len = len;
		}
	    } /* if re_search >= 0 */
	} /* for Regex patterns.  */
	if (best_match < end)
	  {
	    /* We have found an exact match.  We were just
	       waiting for the best one (leftmost then longest).  */
	    beg = best_match;
	    len = best_len;
	    goto success_in_len;
	  }
    } /* for (beg = end ..) */

 failure:
  ret_val = -1;
  goto out;

 success:
  len = end - beg;
 success_in_len:
  *match_size = len;
  ret_val = beg - buf;
 out:
  return ret_val;
}

Spawn 1 instances, now Total 73
Counter: 74
Batcher Size:73
Preprocess the following candidate with CondTester:
Priority 9989
At location src/dfasearch.c:302
--Src File: src/dfasearch.c
Fragment 0:
if ((__abst_hole(start, len, i, patterns, patterns[i].regs.end, buf, match, best_match, beg, end, start_ptr, match_words, match_lines, pcount, best_len, buflim, backref, eol, mb_start, kwset_exact_matches, kwset, size, ret_val, match_size, match_icase, eolbyte, patterns[i].regs.num_regs, patterns[i].regs.start)))
    return 1;
len = patterns[i].regs.end[0] - start;


CondTester, a patch instance with id 73:
//src_file:src/dfasearch.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); void* memset(void*, int, unsigned long); 
/* dfasearch.c - searching subroutines using dfa and regex for grep.
   Copyright 1992, 1998, 2000, 2007, 2009-2010 Free Software Foundation, Inc.

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 3, or (at your option)
   any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program; if not, write to the Free Software
   Foundation, Inc., 51 Franklin Street - Fifth Floor, Boston, MA
   02110-1301, USA.  */

/* Written August 1992 by Mike Haertel. */

#include <config.h>
#include "search.h"
#include "dfa.h"

/* For -w, we also consider _ to be word constituent.  */
#define WCHAR(C) (ISALNUM(C) || (C) == '_')

/* KWset compiled pattern.  For Ecompile and Gcompile, we compile
   a list of strings, at least one of which is known to occur in
   any string matching the regexp. */
static kwset_t kwset;

/* DFA compiled regexp. */
static struct dfa dfa;

/* The Regex compiled patterns.  */
static struct patterns
{
  /* Regex compiled regexp. */
  struct re_pattern_buffer regexbuf;
  struct re_registers regs; /* This is here on account of a BRAIN-DEAD
			       Q@#%!# library interface in regex.c.  */
} patterns0;

struct patterns *patterns;
size_t pcount;

void
dfaerror (char const *mesg)
{
  error (EXIT_TROUBLE, 0, "%s", mesg);

  /* notreached */
  /* Tell static analyzers that this function does not return.  */
  abort ();
}

/* Number of compiled fixed strings known to exactly match the regexp.
   If kwsexec returns < kwset_exact_matches, then we don't need to
   call the regexp matcher at all. */
static int kwset_exact_matches;

static char const *
kwsincr_case (const char *must)
{
  const char *buf;
  size_t n;

  n = strlen (must);
#ifdef MBS_SUPPORT
  if (match_icase && MB_CUR_MAX > 1)
    buf = mbtolower (must, &n);
  else
#endif
    buf = must;
  return kwsincr (kwset, buf, n);
}

/* If the DFA turns out to have some set of fixed strings one of
   which must occur in the match, then we build a kwset matcher
   to find those strings, and thus quickly filter out impossible
   matches. */
static void
kwsmusts (void)
{
  struct dfamust const *dm;
  char const *err;

  if (dfa.musts)
    {
      kwsinit (&kwset);
      /* First, we compile in the substrings known to be exact
	 matches.  The kwset matcher will return the index
	 of the matching string that it chooses. */
      for (dm = dfa.musts; dm; dm = dm->next)
	{
	  if (!dm->exact)
	    continue;
	  ++kwset_exact_matches;
	  if ((err = kwsincr_case (dm->must)) != NULL)
	    error (EXIT_TROUBLE, 0, "%s", err);
	}
      /* Now, we compile the substrings that will require
	 the use of the regexp matcher.  */
      for (dm = dfa.musts; dm; dm = dm->next)
	{
	  if (dm->exact)
	    continue;
	  if ((err = kwsincr_case (dm->must)) != NULL)
	    error (EXIT_TROUBLE, 0, "%s", err);
	}
      if ((err = kwsprep (kwset)) != NULL)
	error (EXIT_TROUBLE, 0, "%s", err);
    }
}

void
GEAcompile (char const *pattern, size_t size, reg_syntax_t syntax_bits)
{
  const char *err;
  const char *p, *sep;
  size_t total = size;
  char *motif;

  if (match_icase)
    syntax_bits |= RE_ICASE;
  re_set_syntax (syntax_bits);
  dfasyntax (syntax_bits, match_icase, eolbyte);

  /* For GNU regex compiler we have to pass the patterns separately to detect
     errors like "[\nallo\n]\n".  The patterns here are "[", "allo" and "]"
     GNU regex should have raise a syntax error.  The same for backref, where
     the backref should have been local to each pattern.  */
  p = pattern;
  do
    {
      size_t len;
      sep = memchr (p, '\n', total);
      if (sep)
	{
	  len = sep - p;
	  sep++;
	  total -= (len + 1);
	}
      else
	{
	  len = total;
	  total = 0;
	}

      patterns = realloc (patterns, (pcount + 1) * sizeof (*patterns));
      if (patterns == NULL)
	error (EXIT_TROUBLE, errno, _("memory exhausted"));
      patterns[pcount] = patterns0;

      if ((err = re_compile_pattern (p, len,
				    &(patterns[pcount].regexbuf))) != NULL)
	error (EXIT_TROUBLE, 0, "%s", err);
      pcount++;

      p = sep;
    } while (sep && total != 0);

  /* In the match_words and match_lines cases, we use a different pattern
     for the DFA matcher that will quickly throw out cases that won't work.
     Then if DFA succeeds we do some hairy stuff using the regex matcher
     to decide whether the match should really count. */
  if (match_words || match_lines)
    {
      static char const line_beg_no_bk[] = "^(";
      static char const line_end_no_bk[] = ")$";
      static char const word_beg_no_bk[] = "(^|[^[:alnum:]_])(";
      static char const word_end_no_bk[] = ")([^[:alnum:]_]|$)";
      static char const line_beg_bk[] = "^\\(";
      static char const line_end_bk[] = "\\)$";
      static char const word_beg_bk[] = "\\(^\\|[^[:alnum:]_]\\)\\(";
      static char const word_end_bk[] = "\\)\\([^[:alnum:]_]\\|$\\)";
      int bk = !(syntax_bits & RE_NO_BK_PARENS);
      char *n = xmalloc (sizeof word_beg_bk - 1 + size + sizeof word_end_bk);

      strcpy (n, match_lines ? (bk ? line_beg_bk : line_beg_no_bk)
			     : (bk ? word_beg_bk : word_beg_no_bk));
      total = strlen(n);
      memcpy (n + total, pattern, size);
      total += size;
      strcpy (n + total, match_lines ? (bk ? line_end_bk : line_end_no_bk)
				     : (bk ? word_end_bk : word_end_no_bk));
      total += strlen (n + total);
      pattern = motif = n;
      size = total;
    }
  else
    motif = NULL;

  dfacomp (pattern, size, &dfa, 1);
  kwsmusts ();

  free(motif);
}

size_t
EGexecute (char const *buf, size_t size, size_t *match_size,
	   char const *start_ptr)
{
  char const *buflim, *beg, *end, *match, *best_match, *mb_start;
  char eol = eolbyte;
  int backref, start, len, best_len;
  struct kwsmatch kwsm;
  size_t i, ret_val;
#ifdef MBS_SUPPORT
  if (MB_CUR_MAX > 1)
    {
      if (match_icase)
        {
          /* mbtolower adds a NUL byte at the end.  That will provide
	     space for the sentinel byte dfaexec may add.  */
          char *case_buf = mbtolower (buf, &size);
	  if (start_ptr)
	    start_ptr = case_buf + (start_ptr - buf);
          buf = case_buf;
        }
    }
#endif /* MBS_SUPPORT */

  mb_start = buf;
  buflim = buf + size;

  for (beg = end = buf; end < buflim; beg = end)
    {
      if (!start_ptr)
	{
	  /* We don't care about an exact match.  */
	  if (kwset)
	    {
	      /* Find a possible match using the KWset matcher. */
	      size_t offset = kwsexec (kwset, beg, buflim - beg, &kwsm);
	      if (offset == (size_t) -1)
		goto failure;
	      beg += offset;
	      /* Narrow down to the line containing the candidate, and
		 run it through DFA. */
	      if ((end = memchr(beg, eol, buflim - beg)) != NULL)
	        end++;
              else
                end = buflim;
	      match = beg;
	      while (beg > buf && beg[-1] != eol)
		--beg;
	      if (kwsm.index < kwset_exact_matches)
                {
#ifdef MBS_SUPPORT
                  if (mb_start < beg)
                    mb_start = beg;
                  if (MB_CUR_MAX == 1 || !is_mb_middle (&mb_start, match, buflim))
#endif
                    goto success;
                }
	      if (dfaexec (&dfa, beg, (char *) end, 0, NULL, &backref) == NULL)
		continue;
	    }
	  else
	    {
	      /* No good fixed strings; start with DFA. */
	      char const *next_beg = dfaexec (&dfa, beg, (char *) buflim,
					      0, NULL, &backref);
	      if (next_beg == NULL)
		break;
	      /* Narrow down to the line we've found. */
	      beg = next_beg;
	      if ((end = memchr(beg, eol, buflim - beg)) != NULL)
	        end++;
              else
                end = buflim;
	      while (beg > buf && beg[-1] != eol)
		--beg;
	    }
	  /* Successful, no backreferences encountered! */
	  if (!backref)
	    goto success;
	}
      else
	{
	  /* We are looking for the leftmost (then longest) exact match.
	     We will go through the outer loop only once.  */
	  beg = start_ptr;
	  end = buflim;
	}

      /* If we've made it to this point, this means DFA has seen
	 a probable match, and we need to run it through Regex. */
      best_match = end;
      best_len = 0;
      for (i = 0; i < pcount; i++)
	{
	  patterns[i].regexbuf.not_eol = 0;
	  if (0 <= (start = re_search (&(patterns[i].regexbuf),
				       buf, end - buf - 1,
				       beg - buf, end - beg - 1,
				       &(patterns[i].regs))))
	    {
	      
//Patch 0:
if ((__is_neg(28, &(start), sizeof (start), &(len), sizeof (len), &(i), sizeof (i), &(patterns), sizeof (patterns), &(patterns[i].regs.end), sizeof (patterns[i].regs.end), &(buf), sizeof (buf), &(match), sizeof (match), &(best_match), sizeof (best_match), &(beg), sizeof (beg), &(end), sizeof (end), &(start_ptr), sizeof (start_ptr), &(match_words), sizeof (match_words), &(match_lines), sizeof (match_lines), &(pcount), sizeof (pcount), &(best_len), sizeof (best_len), &(buflim), sizeof (buflim), &(backref), sizeof (backref), &(eol), sizeof (eol), &(mb_start), sizeof (mb_start), &(kwset_exact_matches), sizeof (kwset_exact_matches), &(kwset), sizeof (kwset), &(size), sizeof (size), &(ret_val), sizeof (ret_val), &(match_size), sizeof (match_size), &(match_icase), sizeof (match_icase), &(eolbyte), sizeof (eolbyte), &(patterns[i].regs.num_regs), sizeof (patterns[i].regs.num_regs), &(patterns[i].regs.start), sizeof (patterns[i].regs.start))))
    return 1;
len = patterns[i].regs.end[0] - start;

//CodeSeg 1:
	      match = buf + start;
	      if (match > best_match)
		continue;
	      if (start_ptr && !match_words)
		goto assess_pattern_match;
	      if ((!match_lines && !match_words)
		  || (match_lines && len == end - beg - 1))
		{
		  match = beg;
		  len = end - beg;
		  goto assess_pattern_match;
		}
	      /* If -w, check if the match aligns with word boundaries.
		 We do this iteratively because:
		 (a) the line may contain more than one occurence of the
		 pattern, and
		 (b) Several alternatives in the pattern might be valid at a
		 given point, and we may need to consider a shorter one to
		 find a word boundary.  */
	      if (match_words)
		while (match <= best_match)
		  {
		    if ((match == buf || !WCHAR ((unsigned char) match[-1]))
			&& (len == end - beg - 1
			    || !WCHAR ((unsigned char) match[len])))
		      goto assess_pattern_match;
		    if (len > 0)
		      {
			/* Try a shorter length anchored at the same place. */
			--len;
			patterns[i].regexbuf.not_eol = 1;
			len = re_match (&(patterns[i].regexbuf),
					buf, match + len - beg, match - buf,
					&(patterns[i].regs));
		      }
		    if (len <= 0)
		      {
			/* Try looking further on. */
			if (match == end - 1)
			  break;
			match++;
			patterns[i].regexbuf.not_eol = 0;
			start = re_search (&(patterns[i].regexbuf),
					   buf, end - buf - 1,
					   match - buf, end - match - 1,
					   &(patterns[i].regs));
			if (start < 0)
			  break;
			len = patterns[i].regs.end[0] - start;
			match = buf + start;
		      }
		  } /* while (match <= best_match) */
	      continue;
	    assess_pattern_match:
	      if (!start_ptr)
		{
		  /* Good enough for a non-exact match.
		     No need to look at further patterns, if any.  */
		  beg = match;
		  goto success_in_len;
		}
	      if (match < best_match || (match == best_match && len > best_len))
		{
		  /* Best exact match:  leftmost, then longest.  */
		  best_match = match;
		  best_len = len;
		}
	    } /* if re_search >= 0 */
	} /* for Regex patterns.  */
	if (best_match < end)
	  {
	    /* We have found an exact match.  We were just
	       waiting for the best one (leftmost then longest).  */
	    beg = best_match;
	    len = best_len;
	    goto success_in_len;
	  }
    } /* for (beg = end ..) */

 failure:
  ret_val = -1;
  goto out;

 success:
  len = end - beg;
 success_in_len:
  *match_size = len;
  ret_val = beg - buf;
 out:
  return ret_val;
}

Spawn 1 instances, now Total 74
Counter: 75
Batcher Size:74
Preprocess the following candidate with CondTester:
Priority 9989
At location src/dfasearch.c:302
--Src File: src/dfasearch.c
Fragment 0:
if ((__abst_hole(start, len, i, patterns, patterns[i].regs.end, buf, match, best_match, beg, end, start_ptr, match_words, match_lines, pcount, best_len, buflim, backref, eol, mb_start, kwset_exact_matches, kwset, size, ret_val, match_size, match_icase, eolbyte, patterns[i].regs.num_regs, patterns[i].regs.start)))
    break;
len = patterns[i].regs.end[0] - start;


CondTester, a patch instance with id 74:
//src_file:src/dfasearch.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); void* memset(void*, int, unsigned long); 
/* dfasearch.c - searching subroutines using dfa and regex for grep.
   Copyright 1992, 1998, 2000, 2007, 2009-2010 Free Software Foundation, Inc.

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 3, or (at your option)
   any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program; if not, write to the Free Software
   Foundation, Inc., 51 Franklin Street - Fifth Floor, Boston, MA
   02110-1301, USA.  */

/* Written August 1992 by Mike Haertel. */

#include <config.h>
#include "search.h"
#include "dfa.h"

/* For -w, we also consider _ to be word constituent.  */
#define WCHAR(C) (ISALNUM(C) || (C) == '_')

/* KWset compiled pattern.  For Ecompile and Gcompile, we compile
   a list of strings, at least one of which is known to occur in
   any string matching the regexp. */
static kwset_t kwset;

/* DFA compiled regexp. */
static struct dfa dfa;

/* The Regex compiled patterns.  */
static struct patterns
{
  /* Regex compiled regexp. */
  struct re_pattern_buffer regexbuf;
  struct re_registers regs; /* This is here on account of a BRAIN-DEAD
			       Q@#%!# library interface in regex.c.  */
} patterns0;

struct patterns *patterns;
size_t pcount;

void
dfaerror (char const *mesg)
{
  error (EXIT_TROUBLE, 0, "%s", mesg);

  /* notreached */
  /* Tell static analyzers that this function does not return.  */
  abort ();
}

/* Number of compiled fixed strings known to exactly match the regexp.
   If kwsexec returns < kwset_exact_matches, then we don't need to
   call the regexp matcher at all. */
static int kwset_exact_matches;

static char const *
kwsincr_case (const char *must)
{
  const char *buf;
  size_t n;

  n = strlen (must);
#ifdef MBS_SUPPORT
  if (match_icase && MB_CUR_MAX > 1)
    buf = mbtolower (must, &n);
  else
#endif
    buf = must;
  return kwsincr (kwset, buf, n);
}

/* If the DFA turns out to have some set of fixed strings one of
   which must occur in the match, then we build a kwset matcher
   to find those strings, and thus quickly filter out impossible
   matches. */
static void
kwsmusts (void)
{
  struct dfamust const *dm;
  char const *err;

  if (dfa.musts)
    {
      kwsinit (&kwset);
      /* First, we compile in the substrings known to be exact
	 matches.  The kwset matcher will return the index
	 of the matching string that it chooses. */
      for (dm = dfa.musts; dm; dm = dm->next)
	{
	  if (!dm->exact)
	    continue;
	  ++kwset_exact_matches;
	  if ((err = kwsincr_case (dm->must)) != NULL)
	    error (EXIT_TROUBLE, 0, "%s", err);
	}
      /* Now, we compile the substrings that will require
	 the use of the regexp matcher.  */
      for (dm = dfa.musts; dm; dm = dm->next)
	{
	  if (dm->exact)
	    continue;
	  if ((err = kwsincr_case (dm->must)) != NULL)
	    error (EXIT_TROUBLE, 0, "%s", err);
	}
      if ((err = kwsprep (kwset)) != NULL)
	error (EXIT_TROUBLE, 0, "%s", err);
    }
}

void
GEAcompile (char const *pattern, size_t size, reg_syntax_t syntax_bits)
{
  const char *err;
  const char *p, *sep;
  size_t total = size;
  char *motif;

  if (match_icase)
    syntax_bits |= RE_ICASE;
  re_set_syntax (syntax_bits);
  dfasyntax (syntax_bits, match_icase, eolbyte);

  /* For GNU regex compiler we have to pass the patterns separately to detect
     errors like "[\nallo\n]\n".  The patterns here are "[", "allo" and "]"
     GNU regex should have raise a syntax error.  The same for backref, where
     the backref should have been local to each pattern.  */
  p = pattern;
  do
    {
      size_t len;
      sep = memchr (p, '\n', total);
      if (sep)
	{
	  len = sep - p;
	  sep++;
	  total -= (len + 1);
	}
      else
	{
	  len = total;
	  total = 0;
	}

      patterns = realloc (patterns, (pcount + 1) * sizeof (*patterns));
      if (patterns == NULL)
	error (EXIT_TROUBLE, errno, _("memory exhausted"));
      patterns[pcount] = patterns0;

      if ((err = re_compile_pattern (p, len,
				    &(patterns[pcount].regexbuf))) != NULL)
	error (EXIT_TROUBLE, 0, "%s", err);
      pcount++;

      p = sep;
    } while (sep && total != 0);

  /* In the match_words and match_lines cases, we use a different pattern
     for the DFA matcher that will quickly throw out cases that won't work.
     Then if DFA succeeds we do some hairy stuff using the regex matcher
     to decide whether the match should really count. */
  if (match_words || match_lines)
    {
      static char const line_beg_no_bk[] = "^(";
      static char const line_end_no_bk[] = ")$";
      static char const word_beg_no_bk[] = "(^|[^[:alnum:]_])(";
      static char const word_end_no_bk[] = ")([^[:alnum:]_]|$)";
      static char const line_beg_bk[] = "^\\(";
      static char const line_end_bk[] = "\\)$";
      static char const word_beg_bk[] = "\\(^\\|[^[:alnum:]_]\\)\\(";
      static char const word_end_bk[] = "\\)\\([^[:alnum:]_]\\|$\\)";
      int bk = !(syntax_bits & RE_NO_BK_PARENS);
      char *n = xmalloc (sizeof word_beg_bk - 1 + size + sizeof word_end_bk);

      strcpy (n, match_lines ? (bk ? line_beg_bk : line_beg_no_bk)
			     : (bk ? word_beg_bk : word_beg_no_bk));
      total = strlen(n);
      memcpy (n + total, pattern, size);
      total += size;
      strcpy (n + total, match_lines ? (bk ? line_end_bk : line_end_no_bk)
				     : (bk ? word_end_bk : word_end_no_bk));
      total += strlen (n + total);
      pattern = motif = n;
      size = total;
    }
  else
    motif = NULL;

  dfacomp (pattern, size, &dfa, 1);
  kwsmusts ();

  free(motif);
}

size_t
EGexecute (char const *buf, size_t size, size_t *match_size,
	   char const *start_ptr)
{
  char const *buflim, *beg, *end, *match, *best_match, *mb_start;
  char eol = eolbyte;
  int backref, start, len, best_len;
  struct kwsmatch kwsm;
  size_t i, ret_val;
#ifdef MBS_SUPPORT
  if (MB_CUR_MAX > 1)
    {
      if (match_icase)
        {
          /* mbtolower adds a NUL byte at the end.  That will provide
	     space for the sentinel byte dfaexec may add.  */
          char *case_buf = mbtolower (buf, &size);
	  if (start_ptr)
	    start_ptr = case_buf + (start_ptr - buf);
          buf = case_buf;
        }
    }
#endif /* MBS_SUPPORT */

  mb_start = buf;
  buflim = buf + size;

  for (beg = end = buf; end < buflim; beg = end)
    {
      if (!start_ptr)
	{
	  /* We don't care about an exact match.  */
	  if (kwset)
	    {
	      /* Find a possible match using the KWset matcher. */
	      size_t offset = kwsexec (kwset, beg, buflim - beg, &kwsm);
	      if (offset == (size_t) -1)
		goto failure;
	      beg += offset;
	      /* Narrow down to the line containing the candidate, and
		 run it through DFA. */
	      if ((end = memchr(beg, eol, buflim - beg)) != NULL)
	        end++;
              else
                end = buflim;
	      match = beg;
	      while (beg > buf && beg[-1] != eol)
		--beg;
	      if (kwsm.index < kwset_exact_matches)
                {
#ifdef MBS_SUPPORT
                  if (mb_start < beg)
                    mb_start = beg;
                  if (MB_CUR_MAX == 1 || !is_mb_middle (&mb_start, match, buflim))
#endif
                    goto success;
                }
	      if (dfaexec (&dfa, beg, (char *) end, 0, NULL, &backref) == NULL)
		continue;
	    }
	  else
	    {
	      /* No good fixed strings; start with DFA. */
	      char const *next_beg = dfaexec (&dfa, beg, (char *) buflim,
					      0, NULL, &backref);
	      if (next_beg == NULL)
		break;
	      /* Narrow down to the line we've found. */
	      beg = next_beg;
	      if ((end = memchr(beg, eol, buflim - beg)) != NULL)
	        end++;
              else
                end = buflim;
	      while (beg > buf && beg[-1] != eol)
		--beg;
	    }
	  /* Successful, no backreferences encountered! */
	  if (!backref)
	    goto success;
	}
      else
	{
	  /* We are looking for the leftmost (then longest) exact match.
	     We will go through the outer loop only once.  */
	  beg = start_ptr;
	  end = buflim;
	}

      /* If we've made it to this point, this means DFA has seen
	 a probable match, and we need to run it through Regex. */
      best_match = end;
      best_len = 0;
      for (i = 0; i < pcount; i++)
	{
	  patterns[i].regexbuf.not_eol = 0;
	  if (0 <= (start = re_search (&(patterns[i].regexbuf),
				       buf, end - buf - 1,
				       beg - buf, end - beg - 1,
				       &(patterns[i].regs))))
	    {
	      
//Patch 0:
if ((__is_neg(28, &(start), sizeof (start), &(len), sizeof (len), &(i), sizeof (i), &(patterns), sizeof (patterns), &(patterns[i].regs.end), sizeof (patterns[i].regs.end), &(buf), sizeof (buf), &(match), sizeof (match), &(best_match), sizeof (best_match), &(beg), sizeof (beg), &(end), sizeof (end), &(start_ptr), sizeof (start_ptr), &(match_words), sizeof (match_words), &(match_lines), sizeof (match_lines), &(pcount), sizeof (pcount), &(best_len), sizeof (best_len), &(buflim), sizeof (buflim), &(backref), sizeof (backref), &(eol), sizeof (eol), &(mb_start), sizeof (mb_start), &(kwset_exact_matches), sizeof (kwset_exact_matches), &(kwset), sizeof (kwset), &(size), sizeof (size), &(ret_val), sizeof (ret_val), &(match_size), sizeof (match_size), &(match_icase), sizeof (match_icase), &(eolbyte), sizeof (eolbyte), &(patterns[i].regs.num_regs), sizeof (patterns[i].regs.num_regs), &(patterns[i].regs.start), sizeof (patterns[i].regs.start))))
    break;
len = patterns[i].regs.end[0] - start;

//CodeSeg 1:
	      match = buf + start;
	      if (match > best_match)
		continue;
	      if (start_ptr && !match_words)
		goto assess_pattern_match;
	      if ((!match_lines && !match_words)
		  || (match_lines && len == end - beg - 1))
		{
		  match = beg;
		  len = end - beg;
		  goto assess_pattern_match;
		}
	      /* If -w, check if the match aligns with word boundaries.
		 We do this iteratively because:
		 (a) the line may contain more than one occurence of the
		 pattern, and
		 (b) Several alternatives in the pattern might be valid at a
		 given point, and we may need to consider a shorter one to
		 find a word boundary.  */
	      if (match_words)
		while (match <= best_match)
		  {
		    if ((match == buf || !WCHAR ((unsigned char) match[-1]))
			&& (len == end - beg - 1
			    || !WCHAR ((unsigned char) match[len])))
		      goto assess_pattern_match;
		    if (len > 0)
		      {
			/* Try a shorter length anchored at the same place. */
			--len;
			patterns[i].regexbuf.not_eol = 1;
			len = re_match (&(patterns[i].regexbuf),
					buf, match + len - beg, match - buf,
					&(patterns[i].regs));
		      }
		    if (len <= 0)
		      {
			/* Try looking further on. */
			if (match == end - 1)
			  break;
			match++;
			patterns[i].regexbuf.not_eol = 0;
			start = re_search (&(patterns[i].regexbuf),
					   buf, end - buf - 1,
					   match - buf, end - match - 1,
					   &(patterns[i].regs));
			if (start < 0)
			  break;
			len = patterns[i].regs.end[0] - start;
			match = buf + start;
		      }
		  } /* while (match <= best_match) */
	      continue;
	    assess_pattern_match:
	      if (!start_ptr)
		{
		  /* Good enough for a non-exact match.
		     No need to look at further patterns, if any.  */
		  beg = match;
		  goto success_in_len;
		}
	      if (match < best_match || (match == best_match && len > best_len))
		{
		  /* Best exact match:  leftmost, then longest.  */
		  best_match = match;
		  best_len = len;
		}
	    } /* if re_search >= 0 */
	} /* for Regex patterns.  */
	if (best_match < end)
	  {
	    /* We have found an exact match.  We were just
	       waiting for the best one (leftmost then longest).  */
	    beg = best_match;
	    len = best_len;
	    goto success_in_len;
	  }
    } /* for (beg = end ..) */

 failure:
  ret_val = -1;
  goto out;

 success:
  len = end - beg;
 success_in_len:
  *match_size = len;
  ret_val = beg - buf;
 out:
  return ret_val;
}

Spawn 1 instances, now Total 75
Counter: 76
Batcher Size:75
Preprocess the following candidate with CondTester:
Priority 9458
At location src/dfasearch.c:212
--Src File: src/dfasearch.c
Fragment 0:
if ((__abst_hole(match_icase, eolbyte, buf, size, start_ptr, mb_start, buflim, beg, end, kwset, eol, match, kwset_exact_matches, backref, best_match, best_len, i, pcount, patterns, start, len, match_words, match_lines, ret_val, match_size)))
    return -1;
if ((__ctype_get_mb_cur_max()) > 1) {
    if (match_icase) {
        char *case_buf = mbtolower(buf, &size);
        if (start_ptr)
            start_ptr = case_buf + (start_ptr - buf);
        buf = case_buf;
    }
}


CondTester, a patch instance with id 75:
//src_file:src/dfasearch.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); void* memset(void*, int, unsigned long); 
/* dfasearch.c - searching subroutines using dfa and regex for grep.
   Copyright 1992, 1998, 2000, 2007, 2009-2010 Free Software Foundation, Inc.

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 3, or (at your option)
   any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program; if not, write to the Free Software
   Foundation, Inc., 51 Franklin Street - Fifth Floor, Boston, MA
   02110-1301, USA.  */

/* Written August 1992 by Mike Haertel. */

#include <config.h>
#include "search.h"
#include "dfa.h"

/* For -w, we also consider _ to be word constituent.  */
#define WCHAR(C) (ISALNUM(C) || (C) == '_')

/* KWset compiled pattern.  For Ecompile and Gcompile, we compile
   a list of strings, at least one of which is known to occur in
   any string matching the regexp. */
static kwset_t kwset;

/* DFA compiled regexp. */
static struct dfa dfa;

/* The Regex compiled patterns.  */
static struct patterns
{
  /* Regex compiled regexp. */
  struct re_pattern_buffer regexbuf;
  struct re_registers regs; /* This is here on account of a BRAIN-DEAD
			       Q@#%!# library interface in regex.c.  */
} patterns0;

struct patterns *patterns;
size_t pcount;

void
dfaerror (char const *mesg)
{
  error (EXIT_TROUBLE, 0, "%s", mesg);

  /* notreached */
  /* Tell static analyzers that this function does not return.  */
  abort ();
}

/* Number of compiled fixed strings known to exactly match the regexp.
   If kwsexec returns < kwset_exact_matches, then we don't need to
   call the regexp matcher at all. */
static int kwset_exact_matches;

static char const *
kwsincr_case (const char *must)
{
  const char *buf;
  size_t n;

  n = strlen (must);
#ifdef MBS_SUPPORT
  if (match_icase && MB_CUR_MAX > 1)
    buf = mbtolower (must, &n);
  else
#endif
    buf = must;
  return kwsincr (kwset, buf, n);
}

/* If the DFA turns out to have some set of fixed strings one of
   which must occur in the match, then we build a kwset matcher
   to find those strings, and thus quickly filter out impossible
   matches. */
static void
kwsmusts (void)
{
  struct dfamust const *dm;
  char const *err;

  if (dfa.musts)
    {
      kwsinit (&kwset);
      /* First, we compile in the substrings known to be exact
	 matches.  The kwset matcher will return the index
	 of the matching string that it chooses. */
      for (dm = dfa.musts; dm; dm = dm->next)
	{
	  if (!dm->exact)
	    continue;
	  ++kwset_exact_matches;
	  if ((err = kwsincr_case (dm->must)) != NULL)
	    error (EXIT_TROUBLE, 0, "%s", err);
	}
      /* Now, we compile the substrings that will require
	 the use of the regexp matcher.  */
      for (dm = dfa.musts; dm; dm = dm->next)
	{
	  if (dm->exact)
	    continue;
	  if ((err = kwsincr_case (dm->must)) != NULL)
	    error (EXIT_TROUBLE, 0, "%s", err);
	}
      if ((err = kwsprep (kwset)) != NULL)
	error (EXIT_TROUBLE, 0, "%s", err);
    }
}

void
GEAcompile (char const *pattern, size_t size, reg_syntax_t syntax_bits)
{
  const char *err;
  const char *p, *sep;
  size_t total = size;
  char *motif;

  if (match_icase)
    syntax_bits |= RE_ICASE;
  re_set_syntax (syntax_bits);
  dfasyntax (syntax_bits, match_icase, eolbyte);

  /* For GNU regex compiler we have to pass the patterns separately to detect
     errors like "[\nallo\n]\n".  The patterns here are "[", "allo" and "]"
     GNU regex should have raise a syntax error.  The same for backref, where
     the backref should have been local to each pattern.  */
  p = pattern;
  do
    {
      size_t len;
      sep = memchr (p, '\n', total);
      if (sep)
	{
	  len = sep - p;
	  sep++;
	  total -= (len + 1);
	}
      else
	{
	  len = total;
	  total = 0;
	}

      patterns = realloc (patterns, (pcount + 1) * sizeof (*patterns));
      if (patterns == NULL)
	error (EXIT_TROUBLE, errno, _("memory exhausted"));
      patterns[pcount] = patterns0;

      if ((err = re_compile_pattern (p, len,
				    &(patterns[pcount].regexbuf))) != NULL)
	error (EXIT_TROUBLE, 0, "%s", err);
      pcount++;

      p = sep;
    } while (sep && total != 0);

  /* In the match_words and match_lines cases, we use a different pattern
     for the DFA matcher that will quickly throw out cases that won't work.
     Then if DFA succeeds we do some hairy stuff using the regex matcher
     to decide whether the match should really count. */
  if (match_words || match_lines)
    {
      static char const line_beg_no_bk[] = "^(";
      static char const line_end_no_bk[] = ")$";
      static char const word_beg_no_bk[] = "(^|[^[:alnum:]_])(";
      static char const word_end_no_bk[] = ")([^[:alnum:]_]|$)";
      static char const line_beg_bk[] = "^\\(";
      static char const line_end_bk[] = "\\)$";
      static char const word_beg_bk[] = "\\(^\\|[^[:alnum:]_]\\)\\(";
      static char const word_end_bk[] = "\\)\\([^[:alnum:]_]\\|$\\)";
      int bk = !(syntax_bits & RE_NO_BK_PARENS);
      char *n = xmalloc (sizeof word_beg_bk - 1 + size + sizeof word_end_bk);

      strcpy (n, match_lines ? (bk ? line_beg_bk : line_beg_no_bk)
			     : (bk ? word_beg_bk : word_beg_no_bk));
      total = strlen(n);
      memcpy (n + total, pattern, size);
      total += size;
      strcpy (n + total, match_lines ? (bk ? line_end_bk : line_end_no_bk)
				     : (bk ? word_end_bk : word_end_no_bk));
      total += strlen (n + total);
      pattern = motif = n;
      size = total;
    }
  else
    motif = NULL;

  dfacomp (pattern, size, &dfa, 1);
  kwsmusts ();

  free(motif);
}

size_t
EGexecute (char const *buf, size_t size, size_t *match_size,
	   char const *start_ptr)
{
  char const *buflim, *beg, *end, *match, *best_match, *mb_start;
  char eol = eolbyte;
  int backref, start, len, best_len;
  struct kwsmatch kwsm;
  size_t i, ret_val;
#ifdef MBS_SUPPORT
  
//Patch 0:
if ((__is_neg(25, &(match_icase), sizeof (match_icase), &(eolbyte), sizeof (eolbyte), &(buf), sizeof (buf), &(size), sizeof (size), &(start_ptr), sizeof (start_ptr), &(mb_start), sizeof (mb_start), &(buflim), sizeof (buflim), &(beg), sizeof (beg), &(end), sizeof (end), &(kwset), sizeof (kwset), &(eol), sizeof (eol), &(match), sizeof (match), &(kwset_exact_matches), sizeof (kwset_exact_matches), &(backref), sizeof (backref), &(best_match), sizeof (best_match), &(best_len), sizeof (best_len), &(i), sizeof (i), &(pcount), sizeof (pcount), &(patterns), sizeof (patterns), &(start), sizeof (start), &(len), sizeof (len), &(match_words), sizeof (match_words), &(match_lines), sizeof (match_lines), &(ret_val), sizeof (ret_val), &(match_size), sizeof (match_size))))
    return -1;
if ((__ctype_get_mb_cur_max()) > 1) {
    if (match_icase) {
        char *case_buf = mbtolower(buf, &size);
        if (start_ptr)
            start_ptr = case_buf + (start_ptr - buf);
        buf = case_buf;
    }
}

//CodeSeg 1:
#endif /* MBS_SUPPORT */

  mb_start = buf;
  buflim = buf + size;

  for (beg = end = buf; end < buflim; beg = end)
    {
      if (!start_ptr)
	{
	  /* We don't care about an exact match.  */
	  if (kwset)
	    {
	      /* Find a possible match using the KWset matcher. */
	      size_t offset = kwsexec (kwset, beg, buflim - beg, &kwsm);
	      if (offset == (size_t) -1)
		goto failure;
	      beg += offset;
	      /* Narrow down to the line containing the candidate, and
		 run it through DFA. */
	      if ((end = memchr(beg, eol, buflim - beg)) != NULL)
	        end++;
              else
                end = buflim;
	      match = beg;
	      while (beg > buf && beg[-1] != eol)
		--beg;
	      if (kwsm.index < kwset_exact_matches)
                {
#ifdef MBS_SUPPORT
                  if (mb_start < beg)
                    mb_start = beg;
                  if (MB_CUR_MAX == 1 || !is_mb_middle (&mb_start, match, buflim))
#endif
                    goto success;
                }
	      if (dfaexec (&dfa, beg, (char *) end, 0, NULL, &backref) == NULL)
		continue;
	    }
	  else
	    {
	      /* No good fixed strings; start with DFA. */
	      char const *next_beg = dfaexec (&dfa, beg, (char *) buflim,
					      0, NULL, &backref);
	      if (next_beg == NULL)
		break;
	      /* Narrow down to the line we've found. */
	      beg = next_beg;
	      if ((end = memchr(beg, eol, buflim - beg)) != NULL)
	        end++;
              else
                end = buflim;
	      while (beg > buf && beg[-1] != eol)
		--beg;
	    }
	  /* Successful, no backreferences encountered! */
	  if (!backref)
	    goto success;
	}
      else
	{
	  /* We are looking for the leftmost (then longest) exact match.
	     We will go through the outer loop only once.  */
	  beg = start_ptr;
	  end = buflim;
	}

      /* If we've made it to this point, this means DFA has seen
	 a probable match, and we need to run it through Regex. */
      best_match = end;
      best_len = 0;
      for (i = 0; i < pcount; i++)
	{
	  patterns[i].regexbuf.not_eol = 0;
	  if (0 <= (start = re_search (&(patterns[i].regexbuf),
				       buf, end - buf - 1,
				       beg - buf, end - beg - 1,
				       &(patterns[i].regs))))
	    {
	      len = patterns[i].regs.end[0] - start;
	      match = buf + start;
	      if (match > best_match)
		continue;
	      if (start_ptr && !match_words)
		goto assess_pattern_match;
	      if ((!match_lines && !match_words)
		  || (match_lines && len == end - beg - 1))
		{
		  match = beg;
		  len = end - beg;
		  goto assess_pattern_match;
		}
	      /* If -w, check if the match aligns with word boundaries.
		 We do this iteratively because:
		 (a) the line may contain more than one occurence of the
		 pattern, and
		 (b) Several alternatives in the pattern might be valid at a
		 given point, and we may need to consider a shorter one to
		 find a word boundary.  */
	      if (match_words)
		while (match <= best_match)
		  {
		    if ((match == buf || !WCHAR ((unsigned char) match[-1]))
			&& (len == end - beg - 1
			    || !WCHAR ((unsigned char) match[len])))
		      goto assess_pattern_match;
		    if (len > 0)
		      {
			/* Try a shorter length anchored at the same place. */
			--len;
			patterns[i].regexbuf.not_eol = 1;
			len = re_match (&(patterns[i].regexbuf),
					buf, match + len - beg, match - buf,
					&(patterns[i].regs));
		      }
		    if (len <= 0)
		      {
			/* Try looking further on. */
			if (match == end - 1)
			  break;
			match++;
			patterns[i].regexbuf.not_eol = 0;
			start = re_search (&(patterns[i].regexbuf),
					   buf, end - buf - 1,
					   match - buf, end - match - 1,
					   &(patterns[i].regs));
			if (start < 0)
			  break;
			len = patterns[i].regs.end[0] - start;
			match = buf + start;
		      }
		  } /* while (match <= best_match) */
	      continue;
	    assess_pattern_match:
	      if (!start_ptr)
		{
		  /* Good enough for a non-exact match.
		     No need to look at further patterns, if any.  */
		  beg = match;
		  goto success_in_len;
		}
	      if (match < best_match || (match == best_match && len > best_len))
		{
		  /* Best exact match:  leftmost, then longest.  */
		  best_match = match;
		  best_len = len;
		}
	    } /* if re_search >= 0 */
	} /* for Regex patterns.  */
	if (best_match < end)
	  {
	    /* We have found an exact match.  We were just
	       waiting for the best one (leftmost then longest).  */
	    beg = best_match;
	    len = best_len;
	    goto success_in_len;
	  }
    } /* for (beg = end ..) */

 failure:
  ret_val = -1;
  goto out;

 success:
  len = end - beg;
 success_in_len:
  *match_size = len;
  ret_val = beg - buf;
 out:
  return ret_val;
}

Spawn 1 instances, now Total 76
Counter: 77
Batcher Size:76
Preprocess the following candidate with CondTester:
Priority 9458
At location src/dfasearch.c:212
--Src File: src/dfasearch.c
Fragment 0:
if ((__abst_hole(match_icase, eolbyte, buf, size, start_ptr, mb_start, buflim, beg, end, kwset, eol, match, kwset_exact_matches, backref, best_match, best_len, i, pcount, patterns, start, len, match_words, match_lines, ret_val, match_size)))
    return 0;
if ((__ctype_get_mb_cur_max()) > 1) {
    if (match_icase) {
        char *case_buf = mbtolower(buf, &size);
        if (start_ptr)
            start_ptr = case_buf + (start_ptr - buf);
        buf = case_buf;
    }
}


CondTester, a patch instance with id 76:
//src_file:src/dfasearch.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); void* memset(void*, int, unsigned long); 
/* dfasearch.c - searching subroutines using dfa and regex for grep.
   Copyright 1992, 1998, 2000, 2007, 2009-2010 Free Software Foundation, Inc.

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 3, or (at your option)
   any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program; if not, write to the Free Software
   Foundation, Inc., 51 Franklin Street - Fifth Floor, Boston, MA
   02110-1301, USA.  */

/* Written August 1992 by Mike Haertel. */

#include <config.h>
#include "search.h"
#include "dfa.h"

/* For -w, we also consider _ to be word constituent.  */
#define WCHAR(C) (ISALNUM(C) || (C) == '_')

/* KWset compiled pattern.  For Ecompile and Gcompile, we compile
   a list of strings, at least one of which is known to occur in
   any string matching the regexp. */
static kwset_t kwset;

/* DFA compiled regexp. */
static struct dfa dfa;

/* The Regex compiled patterns.  */
static struct patterns
{
  /* Regex compiled regexp. */
  struct re_pattern_buffer regexbuf;
  struct re_registers regs; /* This is here on account of a BRAIN-DEAD
			       Q@#%!# library interface in regex.c.  */
} patterns0;

struct patterns *patterns;
size_t pcount;

void
dfaerror (char const *mesg)
{
  error (EXIT_TROUBLE, 0, "%s", mesg);

  /* notreached */
  /* Tell static analyzers that this function does not return.  */
  abort ();
}

/* Number of compiled fixed strings known to exactly match the regexp.
   If kwsexec returns < kwset_exact_matches, then we don't need to
   call the regexp matcher at all. */
static int kwset_exact_matches;

static char const *
kwsincr_case (const char *must)
{
  const char *buf;
  size_t n;

  n = strlen (must);
#ifdef MBS_SUPPORT
  if (match_icase && MB_CUR_MAX > 1)
    buf = mbtolower (must, &n);
  else
#endif
    buf = must;
  return kwsincr (kwset, buf, n);
}

/* If the DFA turns out to have some set of fixed strings one of
   which must occur in the match, then we build a kwset matcher
   to find those strings, and thus quickly filter out impossible
   matches. */
static void
kwsmusts (void)
{
  struct dfamust const *dm;
  char const *err;

  if (dfa.musts)
    {
      kwsinit (&kwset);
      /* First, we compile in the substrings known to be exact
	 matches.  The kwset matcher will return the index
	 of the matching string that it chooses. */
      for (dm = dfa.musts; dm; dm = dm->next)
	{
	  if (!dm->exact)
	    continue;
	  ++kwset_exact_matches;
	  if ((err = kwsincr_case (dm->must)) != NULL)
	    error (EXIT_TROUBLE, 0, "%s", err);
	}
      /* Now, we compile the substrings that will require
	 the use of the regexp matcher.  */
      for (dm = dfa.musts; dm; dm = dm->next)
	{
	  if (dm->exact)
	    continue;
	  if ((err = kwsincr_case (dm->must)) != NULL)
	    error (EXIT_TROUBLE, 0, "%s", err);
	}
      if ((err = kwsprep (kwset)) != NULL)
	error (EXIT_TROUBLE, 0, "%s", err);
    }
}

void
GEAcompile (char const *pattern, size_t size, reg_syntax_t syntax_bits)
{
  const char *err;
  const char *p, *sep;
  size_t total = size;
  char *motif;

  if (match_icase)
    syntax_bits |= RE_ICASE;
  re_set_syntax (syntax_bits);
  dfasyntax (syntax_bits, match_icase, eolbyte);

  /* For GNU regex compiler we have to pass the patterns separately to detect
     errors like "[\nallo\n]\n".  The patterns here are "[", "allo" and "]"
     GNU regex should have raise a syntax error.  The same for backref, where
     the backref should have been local to each pattern.  */
  p = pattern;
  do
    {
      size_t len;
      sep = memchr (p, '\n', total);
      if (sep)
	{
	  len = sep - p;
	  sep++;
	  total -= (len + 1);
	}
      else
	{
	  len = total;
	  total = 0;
	}

      patterns = realloc (patterns, (pcount + 1) * sizeof (*patterns));
      if (patterns == NULL)
	error (EXIT_TROUBLE, errno, _("memory exhausted"));
      patterns[pcount] = patterns0;

      if ((err = re_compile_pattern (p, len,
				    &(patterns[pcount].regexbuf))) != NULL)
	error (EXIT_TROUBLE, 0, "%s", err);
      pcount++;

      p = sep;
    } while (sep && total != 0);

  /* In the match_words and match_lines cases, we use a different pattern
     for the DFA matcher that will quickly throw out cases that won't work.
     Then if DFA succeeds we do some hairy stuff using the regex matcher
     to decide whether the match should really count. */
  if (match_words || match_lines)
    {
      static char const line_beg_no_bk[] = "^(";
      static char const line_end_no_bk[] = ")$";
      static char const word_beg_no_bk[] = "(^|[^[:alnum:]_])(";
      static char const word_end_no_bk[] = ")([^[:alnum:]_]|$)";
      static char const line_beg_bk[] = "^\\(";
      static char const line_end_bk[] = "\\)$";
      static char const word_beg_bk[] = "\\(^\\|[^[:alnum:]_]\\)\\(";
      static char const word_end_bk[] = "\\)\\([^[:alnum:]_]\\|$\\)";
      int bk = !(syntax_bits & RE_NO_BK_PARENS);
      char *n = xmalloc (sizeof word_beg_bk - 1 + size + sizeof word_end_bk);

      strcpy (n, match_lines ? (bk ? line_beg_bk : line_beg_no_bk)
			     : (bk ? word_beg_bk : word_beg_no_bk));
      total = strlen(n);
      memcpy (n + total, pattern, size);
      total += size;
      strcpy (n + total, match_lines ? (bk ? line_end_bk : line_end_no_bk)
				     : (bk ? word_end_bk : word_end_no_bk));
      total += strlen (n + total);
      pattern = motif = n;
      size = total;
    }
  else
    motif = NULL;

  dfacomp (pattern, size, &dfa, 1);
  kwsmusts ();

  free(motif);
}

size_t
EGexecute (char const *buf, size_t size, size_t *match_size,
	   char const *start_ptr)
{
  char const *buflim, *beg, *end, *match, *best_match, *mb_start;
  char eol = eolbyte;
  int backref, start, len, best_len;
  struct kwsmatch kwsm;
  size_t i, ret_val;
#ifdef MBS_SUPPORT
  
//Patch 0:
if ((__is_neg(25, &(match_icase), sizeof (match_icase), &(eolbyte), sizeof (eolbyte), &(buf), sizeof (buf), &(size), sizeof (size), &(start_ptr), sizeof (start_ptr), &(mb_start), sizeof (mb_start), &(buflim), sizeof (buflim), &(beg), sizeof (beg), &(end), sizeof (end), &(kwset), sizeof (kwset), &(eol), sizeof (eol), &(match), sizeof (match), &(kwset_exact_matches), sizeof (kwset_exact_matches), &(backref), sizeof (backref), &(best_match), sizeof (best_match), &(best_len), sizeof (best_len), &(i), sizeof (i), &(pcount), sizeof (pcount), &(patterns), sizeof (patterns), &(start), sizeof (start), &(len), sizeof (len), &(match_words), sizeof (match_words), &(match_lines), sizeof (match_lines), &(ret_val), sizeof (ret_val), &(match_size), sizeof (match_size))))
    return 0;
if ((__ctype_get_mb_cur_max()) > 1) {
    if (match_icase) {
        char *case_buf = mbtolower(buf, &size);
        if (start_ptr)
            start_ptr = case_buf + (start_ptr - buf);
        buf = case_buf;
    }
}

//CodeSeg 1:
#endif /* MBS_SUPPORT */

  mb_start = buf;
  buflim = buf + size;

  for (beg = end = buf; end < buflim; beg = end)
    {
      if (!start_ptr)
	{
	  /* We don't care about an exact match.  */
	  if (kwset)
	    {
	      /* Find a possible match using the KWset matcher. */
	      size_t offset = kwsexec (kwset, beg, buflim - beg, &kwsm);
	      if (offset == (size_t) -1)
		goto failure;
	      beg += offset;
	      /* Narrow down to the line containing the candidate, and
		 run it through DFA. */
	      if ((end = memchr(beg, eol, buflim - beg)) != NULL)
	        end++;
              else
                end = buflim;
	      match = beg;
	      while (beg > buf && beg[-1] != eol)
		--beg;
	      if (kwsm.index < kwset_exact_matches)
                {
#ifdef MBS_SUPPORT
                  if (mb_start < beg)
                    mb_start = beg;
                  if (MB_CUR_MAX == 1 || !is_mb_middle (&mb_start, match, buflim))
#endif
                    goto success;
                }
	      if (dfaexec (&dfa, beg, (char *) end, 0, NULL, &backref) == NULL)
		continue;
	    }
	  else
	    {
	      /* No good fixed strings; start with DFA. */
	      char const *next_beg = dfaexec (&dfa, beg, (char *) buflim,
					      0, NULL, &backref);
	      if (next_beg == NULL)
		break;
	      /* Narrow down to the line we've found. */
	      beg = next_beg;
	      if ((end = memchr(beg, eol, buflim - beg)) != NULL)
	        end++;
              else
                end = buflim;
	      while (beg > buf && beg[-1] != eol)
		--beg;
	    }
	  /* Successful, no backreferences encountered! */
	  if (!backref)
	    goto success;
	}
      else
	{
	  /* We are looking for the leftmost (then longest) exact match.
	     We will go through the outer loop only once.  */
	  beg = start_ptr;
	  end = buflim;
	}

      /* If we've made it to this point, this means DFA has seen
	 a probable match, and we need to run it through Regex. */
      best_match = end;
      best_len = 0;
      for (i = 0; i < pcount; i++)
	{
	  patterns[i].regexbuf.not_eol = 0;
	  if (0 <= (start = re_search (&(patterns[i].regexbuf),
				       buf, end - buf - 1,
				       beg - buf, end - beg - 1,
				       &(patterns[i].regs))))
	    {
	      len = patterns[i].regs.end[0] - start;
	      match = buf + start;
	      if (match > best_match)
		continue;
	      if (start_ptr && !match_words)
		goto assess_pattern_match;
	      if ((!match_lines && !match_words)
		  || (match_lines && len == end - beg - 1))
		{
		  match = beg;
		  len = end - beg;
		  goto assess_pattern_match;
		}
	      /* If -w, check if the match aligns with word boundaries.
		 We do this iteratively because:
		 (a) the line may contain more than one occurence of the
		 pattern, and
		 (b) Several alternatives in the pattern might be valid at a
		 given point, and we may need to consider a shorter one to
		 find a word boundary.  */
	      if (match_words)
		while (match <= best_match)
		  {
		    if ((match == buf || !WCHAR ((unsigned char) match[-1]))
			&& (len == end - beg - 1
			    || !WCHAR ((unsigned char) match[len])))
		      goto assess_pattern_match;
		    if (len > 0)
		      {
			/* Try a shorter length anchored at the same place. */
			--len;
			patterns[i].regexbuf.not_eol = 1;
			len = re_match (&(patterns[i].regexbuf),
					buf, match + len - beg, match - buf,
					&(patterns[i].regs));
		      }
		    if (len <= 0)
		      {
			/* Try looking further on. */
			if (match == end - 1)
			  break;
			match++;
			patterns[i].regexbuf.not_eol = 0;
			start = re_search (&(patterns[i].regexbuf),
					   buf, end - buf - 1,
					   match - buf, end - match - 1,
					   &(patterns[i].regs));
			if (start < 0)
			  break;
			len = patterns[i].regs.end[0] - start;
			match = buf + start;
		      }
		  } /* while (match <= best_match) */
	      continue;
	    assess_pattern_match:
	      if (!start_ptr)
		{
		  /* Good enough for a non-exact match.
		     No need to look at further patterns, if any.  */
		  beg = match;
		  goto success_in_len;
		}
	      if (match < best_match || (match == best_match && len > best_len))
		{
		  /* Best exact match:  leftmost, then longest.  */
		  best_match = match;
		  best_len = len;
		}
	    } /* if re_search >= 0 */
	} /* for Regex patterns.  */
	if (best_match < end)
	  {
	    /* We have found an exact match.  We were just
	       waiting for the best one (leftmost then longest).  */
	    beg = best_match;
	    len = best_len;
	    goto success_in_len;
	  }
    } /* for (beg = end ..) */

 failure:
  ret_val = -1;
  goto out;

 success:
  len = end - beg;
 success_in_len:
  *match_size = len;
  ret_val = beg - buf;
 out:
  return ret_val;
}

Spawn 1 instances, now Total 77
Counter: 78
Batcher Size:77
Preprocess the following candidate with CondTester:
Priority 9458
At location src/dfasearch.c:212
--Src File: src/dfasearch.c
Fragment 0:
if ((__abst_hole(match_icase, eolbyte, buf, size, start_ptr, mb_start, buflim, beg, end, kwset, eol, match, kwset_exact_matches, backref, best_match, best_len, i, pcount, patterns, start, len, match_words, match_lines, ret_val, match_size)))
    return 1;
if ((__ctype_get_mb_cur_max()) > 1) {
    if (match_icase) {
        char *case_buf = mbtolower(buf, &size);
        if (start_ptr)
            start_ptr = case_buf + (start_ptr - buf);
        buf = case_buf;
    }
}


CondTester, a patch instance with id 77:
//src_file:src/dfasearch.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); void* memset(void*, int, unsigned long); 
/* dfasearch.c - searching subroutines using dfa and regex for grep.
   Copyright 1992, 1998, 2000, 2007, 2009-2010 Free Software Foundation, Inc.

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 3, or (at your option)
   any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program; if not, write to the Free Software
   Foundation, Inc., 51 Franklin Street - Fifth Floor, Boston, MA
   02110-1301, USA.  */

/* Written August 1992 by Mike Haertel. */

#include <config.h>
#include "search.h"
#include "dfa.h"

/* For -w, we also consider _ to be word constituent.  */
#define WCHAR(C) (ISALNUM(C) || (C) == '_')

/* KWset compiled pattern.  For Ecompile and Gcompile, we compile
   a list of strings, at least one of which is known to occur in
   any string matching the regexp. */
static kwset_t kwset;

/* DFA compiled regexp. */
static struct dfa dfa;

/* The Regex compiled patterns.  */
static struct patterns
{
  /* Regex compiled regexp. */
  struct re_pattern_buffer regexbuf;
  struct re_registers regs; /* This is here on account of a BRAIN-DEAD
			       Q@#%!# library interface in regex.c.  */
} patterns0;

struct patterns *patterns;
size_t pcount;

void
dfaerror (char const *mesg)
{
  error (EXIT_TROUBLE, 0, "%s", mesg);

  /* notreached */
  /* Tell static analyzers that this function does not return.  */
  abort ();
}

/* Number of compiled fixed strings known to exactly match the regexp.
   If kwsexec returns < kwset_exact_matches, then we don't need to
   call the regexp matcher at all. */
static int kwset_exact_matches;

static char const *
kwsincr_case (const char *must)
{
  const char *buf;
  size_t n;

  n = strlen (must);
#ifdef MBS_SUPPORT
  if (match_icase && MB_CUR_MAX > 1)
    buf = mbtolower (must, &n);
  else
#endif
    buf = must;
  return kwsincr (kwset, buf, n);
}

/* If the DFA turns out to have some set of fixed strings one of
   which must occur in the match, then we build a kwset matcher
   to find those strings, and thus quickly filter out impossible
   matches. */
static void
kwsmusts (void)
{
  struct dfamust const *dm;
  char const *err;

  if (dfa.musts)
    {
      kwsinit (&kwset);
      /* First, we compile in the substrings known to be exact
	 matches.  The kwset matcher will return the index
	 of the matching string that it chooses. */
      for (dm = dfa.musts; dm; dm = dm->next)
	{
	  if (!dm->exact)
	    continue;
	  ++kwset_exact_matches;
	  if ((err = kwsincr_case (dm->must)) != NULL)
	    error (EXIT_TROUBLE, 0, "%s", err);
	}
      /* Now, we compile the substrings that will require
	 the use of the regexp matcher.  */
      for (dm = dfa.musts; dm; dm = dm->next)
	{
	  if (dm->exact)
	    continue;
	  if ((err = kwsincr_case (dm->must)) != NULL)
	    error (EXIT_TROUBLE, 0, "%s", err);
	}
      if ((err = kwsprep (kwset)) != NULL)
	error (EXIT_TROUBLE, 0, "%s", err);
    }
}

void
GEAcompile (char const *pattern, size_t size, reg_syntax_t syntax_bits)
{
  const char *err;
  const char *p, *sep;
  size_t total = size;
  char *motif;

  if (match_icase)
    syntax_bits |= RE_ICASE;
  re_set_syntax (syntax_bits);
  dfasyntax (syntax_bits, match_icase, eolbyte);

  /* For GNU regex compiler we have to pass the patterns separately to detect
     errors like "[\nallo\n]\n".  The patterns here are "[", "allo" and "]"
     GNU regex should have raise a syntax error.  The same for backref, where
     the backref should have been local to each pattern.  */
  p = pattern;
  do
    {
      size_t len;
      sep = memchr (p, '\n', total);
      if (sep)
	{
	  len = sep - p;
	  sep++;
	  total -= (len + 1);
	}
      else
	{
	  len = total;
	  total = 0;
	}

      patterns = realloc (patterns, (pcount + 1) * sizeof (*patterns));
      if (patterns == NULL)
	error (EXIT_TROUBLE, errno, _("memory exhausted"));
      patterns[pcount] = patterns0;

      if ((err = re_compile_pattern (p, len,
				    &(patterns[pcount].regexbuf))) != NULL)
	error (EXIT_TROUBLE, 0, "%s", err);
      pcount++;

      p = sep;
    } while (sep && total != 0);

  /* In the match_words and match_lines cases, we use a different pattern
     for the DFA matcher that will quickly throw out cases that won't work.
     Then if DFA succeeds we do some hairy stuff using the regex matcher
     to decide whether the match should really count. */
  if (match_words || match_lines)
    {
      static char const line_beg_no_bk[] = "^(";
      static char const line_end_no_bk[] = ")$";
      static char const word_beg_no_bk[] = "(^|[^[:alnum:]_])(";
      static char const word_end_no_bk[] = ")([^[:alnum:]_]|$)";
      static char const line_beg_bk[] = "^\\(";
      static char const line_end_bk[] = "\\)$";
      static char const word_beg_bk[] = "\\(^\\|[^[:alnum:]_]\\)\\(";
      static char const word_end_bk[] = "\\)\\([^[:alnum:]_]\\|$\\)";
      int bk = !(syntax_bits & RE_NO_BK_PARENS);
      char *n = xmalloc (sizeof word_beg_bk - 1 + size + sizeof word_end_bk);

      strcpy (n, match_lines ? (bk ? line_beg_bk : line_beg_no_bk)
			     : (bk ? word_beg_bk : word_beg_no_bk));
      total = strlen(n);
      memcpy (n + total, pattern, size);
      total += size;
      strcpy (n + total, match_lines ? (bk ? line_end_bk : line_end_no_bk)
				     : (bk ? word_end_bk : word_end_no_bk));
      total += strlen (n + total);
      pattern = motif = n;
      size = total;
    }
  else
    motif = NULL;

  dfacomp (pattern, size, &dfa, 1);
  kwsmusts ();

  free(motif);
}

size_t
EGexecute (char const *buf, size_t size, size_t *match_size,
	   char const *start_ptr)
{
  char const *buflim, *beg, *end, *match, *best_match, *mb_start;
  char eol = eolbyte;
  int backref, start, len, best_len;
  struct kwsmatch kwsm;
  size_t i, ret_val;
#ifdef MBS_SUPPORT
  
//Patch 0:
if ((__is_neg(25, &(match_icase), sizeof (match_icase), &(eolbyte), sizeof (eolbyte), &(buf), sizeof (buf), &(size), sizeof (size), &(start_ptr), sizeof (start_ptr), &(mb_start), sizeof (mb_start), &(buflim), sizeof (buflim), &(beg), sizeof (beg), &(end), sizeof (end), &(kwset), sizeof (kwset), &(eol), sizeof (eol), &(match), sizeof (match), &(kwset_exact_matches), sizeof (kwset_exact_matches), &(backref), sizeof (backref), &(best_match), sizeof (best_match), &(best_len), sizeof (best_len), &(i), sizeof (i), &(pcount), sizeof (pcount), &(patterns), sizeof (patterns), &(start), sizeof (start), &(len), sizeof (len), &(match_words), sizeof (match_words), &(match_lines), sizeof (match_lines), &(ret_val), sizeof (ret_val), &(match_size), sizeof (match_size))))
    return 1;
if ((__ctype_get_mb_cur_max()) > 1) {
    if (match_icase) {
        char *case_buf = mbtolower(buf, &size);
        if (start_ptr)
            start_ptr = case_buf + (start_ptr - buf);
        buf = case_buf;
    }
}

//CodeSeg 1:
#endif /* MBS_SUPPORT */

  mb_start = buf;
  buflim = buf + size;

  for (beg = end = buf; end < buflim; beg = end)
    {
      if (!start_ptr)
	{
	  /* We don't care about an exact match.  */
	  if (kwset)
	    {
	      /* Find a possible match using the KWset matcher. */
	      size_t offset = kwsexec (kwset, beg, buflim - beg, &kwsm);
	      if (offset == (size_t) -1)
		goto failure;
	      beg += offset;
	      /* Narrow down to the line containing the candidate, and
		 run it through DFA. */
	      if ((end = memchr(beg, eol, buflim - beg)) != NULL)
	        end++;
              else
                end = buflim;
	      match = beg;
	      while (beg > buf && beg[-1] != eol)
		--beg;
	      if (kwsm.index < kwset_exact_matches)
                {
#ifdef MBS_SUPPORT
                  if (mb_start < beg)
                    mb_start = beg;
                  if (MB_CUR_MAX == 1 || !is_mb_middle (&mb_start, match, buflim))
#endif
                    goto success;
                }
	      if (dfaexec (&dfa, beg, (char *) end, 0, NULL, &backref) == NULL)
		continue;
	    }
	  else
	    {
	      /* No good fixed strings; start with DFA. */
	      char const *next_beg = dfaexec (&dfa, beg, (char *) buflim,
					      0, NULL, &backref);
	      if (next_beg == NULL)
		break;
	      /* Narrow down to the line we've found. */
	      beg = next_beg;
	      if ((end = memchr(beg, eol, buflim - beg)) != NULL)
	        end++;
              else
                end = buflim;
	      while (beg > buf && beg[-1] != eol)
		--beg;
	    }
	  /* Successful, no backreferences encountered! */
	  if (!backref)
	    goto success;
	}
      else
	{
	  /* We are looking for the leftmost (then longest) exact match.
	     We will go through the outer loop only once.  */
	  beg = start_ptr;
	  end = buflim;
	}

      /* If we've made it to this point, this means DFA has seen
	 a probable match, and we need to run it through Regex. */
      best_match = end;
      best_len = 0;
      for (i = 0; i < pcount; i++)
	{
	  patterns[i].regexbuf.not_eol = 0;
	  if (0 <= (start = re_search (&(patterns[i].regexbuf),
				       buf, end - buf - 1,
				       beg - buf, end - beg - 1,
				       &(patterns[i].regs))))
	    {
	      len = patterns[i].regs.end[0] - start;
	      match = buf + start;
	      if (match > best_match)
		continue;
	      if (start_ptr && !match_words)
		goto assess_pattern_match;
	      if ((!match_lines && !match_words)
		  || (match_lines && len == end - beg - 1))
		{
		  match = beg;
		  len = end - beg;
		  goto assess_pattern_match;
		}
	      /* If -w, check if the match aligns with word boundaries.
		 We do this iteratively because:
		 (a) the line may contain more than one occurence of the
		 pattern, and
		 (b) Several alternatives in the pattern might be valid at a
		 given point, and we may need to consider a shorter one to
		 find a word boundary.  */
	      if (match_words)
		while (match <= best_match)
		  {
		    if ((match == buf || !WCHAR ((unsigned char) match[-1]))
			&& (len == end - beg - 1
			    || !WCHAR ((unsigned char) match[len])))
		      goto assess_pattern_match;
		    if (len > 0)
		      {
			/* Try a shorter length anchored at the same place. */
			--len;
			patterns[i].regexbuf.not_eol = 1;
			len = re_match (&(patterns[i].regexbuf),
					buf, match + len - beg, match - buf,
					&(patterns[i].regs));
		      }
		    if (len <= 0)
		      {
			/* Try looking further on. */
			if (match == end - 1)
			  break;
			match++;
			patterns[i].regexbuf.not_eol = 0;
			start = re_search (&(patterns[i].regexbuf),
					   buf, end - buf - 1,
					   match - buf, end - match - 1,
					   &(patterns[i].regs));
			if (start < 0)
			  break;
			len = patterns[i].regs.end[0] - start;
			match = buf + start;
		      }
		  } /* while (match <= best_match) */
	      continue;
	    assess_pattern_match:
	      if (!start_ptr)
		{
		  /* Good enough for a non-exact match.
		     No need to look at further patterns, if any.  */
		  beg = match;
		  goto success_in_len;
		}
	      if (match < best_match || (match == best_match && len > best_len))
		{
		  /* Best exact match:  leftmost, then longest.  */
		  best_match = match;
		  best_len = len;
		}
	    } /* if re_search >= 0 */
	} /* for Regex patterns.  */
	if (best_match < end)
	  {
	    /* We have found an exact match.  We were just
	       waiting for the best one (leftmost then longest).  */
	    beg = best_match;
	    len = best_len;
	    goto success_in_len;
	  }
    } /* for (beg = end ..) */

 failure:
  ret_val = -1;
  goto out;

 success:
  len = end - beg;
 success_in_len:
  *match_size = len;
  ret_val = beg - buf;
 out:
  return ret_val;
}

Spawn 1 instances, now Total 78
Counter: 79
Batcher Size:78
Preprocess the following candidate with CondTester:
Priority 9169
At location src/dfasearch.c:296
--Src File: src/dfasearch.c
Fragment 0:
if ((__abst_hole(i, patterns, patterns[i].regexbuf.not_eol, start, buf, end, pcount, beg, best_len, best_match, len, match, buflim, start_ptr, match_words, match_lines, backref, eol, mb_start, kwset_exact_matches, kwset, size, match_icase, ret_val, eolbyte, match_size, patterns[i].regexbuf.buffer, patterns[i].regexbuf.allocated, patterns[i].regexbuf.used, patterns[i].regexbuf.syntax, patterns[i].regexbuf.fastmap, patterns[i].regexbuf.translate, patterns[i].regexbuf.re_nsub, patterns[i].regexbuf.can_be_null, patterns[i].regexbuf.regs_allocated, patterns[i].regexbuf.fastmap_accurate, patterns[i].regexbuf.no_sub, patterns[i].regexbuf.not_bol, patterns[i].regexbuf.newline_anchor)))
    goto assess_pattern_match;
patterns[i].regexbuf.not_eol = 0;


CondTester, a patch instance with id 78:
//src_file:src/dfasearch.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); void* memset(void*, int, unsigned long); 
/* dfasearch.c - searching subroutines using dfa and regex for grep.
   Copyright 1992, 1998, 2000, 2007, 2009-2010 Free Software Foundation, Inc.

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 3, or (at your option)
   any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program; if not, write to the Free Software
   Foundation, Inc., 51 Franklin Street - Fifth Floor, Boston, MA
   02110-1301, USA.  */

/* Written August 1992 by Mike Haertel. */

#include <config.h>
#include "search.h"
#include "dfa.h"

/* For -w, we also consider _ to be word constituent.  */
#define WCHAR(C) (ISALNUM(C) || (C) == '_')

/* KWset compiled pattern.  For Ecompile and Gcompile, we compile
   a list of strings, at least one of which is known to occur in
   any string matching the regexp. */
static kwset_t kwset;

/* DFA compiled regexp. */
static struct dfa dfa;

/* The Regex compiled patterns.  */
static struct patterns
{
  /* Regex compiled regexp. */
  struct re_pattern_buffer regexbuf;
  struct re_registers regs; /* This is here on account of a BRAIN-DEAD
			       Q@#%!# library interface in regex.c.  */
} patterns0;

struct patterns *patterns;
size_t pcount;

void
dfaerror (char const *mesg)
{
  error (EXIT_TROUBLE, 0, "%s", mesg);

  /* notreached */
  /* Tell static analyzers that this function does not return.  */
  abort ();
}

/* Number of compiled fixed strings known to exactly match the regexp.
   If kwsexec returns < kwset_exact_matches, then we don't need to
   call the regexp matcher at all. */
static int kwset_exact_matches;

static char const *
kwsincr_case (const char *must)
{
  const char *buf;
  size_t n;

  n = strlen (must);
#ifdef MBS_SUPPORT
  if (match_icase && MB_CUR_MAX > 1)
    buf = mbtolower (must, &n);
  else
#endif
    buf = must;
  return kwsincr (kwset, buf, n);
}

/* If the DFA turns out to have some set of fixed strings one of
   which must occur in the match, then we build a kwset matcher
   to find those strings, and thus quickly filter out impossible
   matches. */
static void
kwsmusts (void)
{
  struct dfamust const *dm;
  char const *err;

  if (dfa.musts)
    {
      kwsinit (&kwset);
      /* First, we compile in the substrings known to be exact
	 matches.  The kwset matcher will return the index
	 of the matching string that it chooses. */
      for (dm = dfa.musts; dm; dm = dm->next)
	{
	  if (!dm->exact)
	    continue;
	  ++kwset_exact_matches;
	  if ((err = kwsincr_case (dm->must)) != NULL)
	    error (EXIT_TROUBLE, 0, "%s", err);
	}
      /* Now, we compile the substrings that will require
	 the use of the regexp matcher.  */
      for (dm = dfa.musts; dm; dm = dm->next)
	{
	  if (dm->exact)
	    continue;
	  if ((err = kwsincr_case (dm->must)) != NULL)
	    error (EXIT_TROUBLE, 0, "%s", err);
	}
      if ((err = kwsprep (kwset)) != NULL)
	error (EXIT_TROUBLE, 0, "%s", err);
    }
}

void
GEAcompile (char const *pattern, size_t size, reg_syntax_t syntax_bits)
{
  const char *err;
  const char *p, *sep;
  size_t total = size;
  char *motif;

  if (match_icase)
    syntax_bits |= RE_ICASE;
  re_set_syntax (syntax_bits);
  dfasyntax (syntax_bits, match_icase, eolbyte);

  /* For GNU regex compiler we have to pass the patterns separately to detect
     errors like "[\nallo\n]\n".  The patterns here are "[", "allo" and "]"
     GNU regex should have raise a syntax error.  The same for backref, where
     the backref should have been local to each pattern.  */
  p = pattern;
  do
    {
      size_t len;
      sep = memchr (p, '\n', total);
      if (sep)
	{
	  len = sep - p;
	  sep++;
	  total -= (len + 1);
	}
      else
	{
	  len = total;
	  total = 0;
	}

      patterns = realloc (patterns, (pcount + 1) * sizeof (*patterns));
      if (patterns == NULL)
	error (EXIT_TROUBLE, errno, _("memory exhausted"));
      patterns[pcount] = patterns0;

      if ((err = re_compile_pattern (p, len,
				    &(patterns[pcount].regexbuf))) != NULL)
	error (EXIT_TROUBLE, 0, "%s", err);
      pcount++;

      p = sep;
    } while (sep && total != 0);

  /* In the match_words and match_lines cases, we use a different pattern
     for the DFA matcher that will quickly throw out cases that won't work.
     Then if DFA succeeds we do some hairy stuff using the regex matcher
     to decide whether the match should really count. */
  if (match_words || match_lines)
    {
      static char const line_beg_no_bk[] = "^(";
      static char const line_end_no_bk[] = ")$";
      static char const word_beg_no_bk[] = "(^|[^[:alnum:]_])(";
      static char const word_end_no_bk[] = ")([^[:alnum:]_]|$)";
      static char const line_beg_bk[] = "^\\(";
      static char const line_end_bk[] = "\\)$";
      static char const word_beg_bk[] = "\\(^\\|[^[:alnum:]_]\\)\\(";
      static char const word_end_bk[] = "\\)\\([^[:alnum:]_]\\|$\\)";
      int bk = !(syntax_bits & RE_NO_BK_PARENS);
      char *n = xmalloc (sizeof word_beg_bk - 1 + size + sizeof word_end_bk);

      strcpy (n, match_lines ? (bk ? line_beg_bk : line_beg_no_bk)
			     : (bk ? word_beg_bk : word_beg_no_bk));
      total = strlen(n);
      memcpy (n + total, pattern, size);
      total += size;
      strcpy (n + total, match_lines ? (bk ? line_end_bk : line_end_no_bk)
				     : (bk ? word_end_bk : word_end_no_bk));
      total += strlen (n + total);
      pattern = motif = n;
      size = total;
    }
  else
    motif = NULL;

  dfacomp (pattern, size, &dfa, 1);
  kwsmusts ();

  free(motif);
}

size_t
EGexecute (char const *buf, size_t size, size_t *match_size,
	   char const *start_ptr)
{
  char const *buflim, *beg, *end, *match, *best_match, *mb_start;
  char eol = eolbyte;
  int backref, start, len, best_len;
  struct kwsmatch kwsm;
  size_t i, ret_val;
#ifdef MBS_SUPPORT
  if (MB_CUR_MAX > 1)
    {
      if (match_icase)
        {
          /* mbtolower adds a NUL byte at the end.  That will provide
	     space for the sentinel byte dfaexec may add.  */
          char *case_buf = mbtolower (buf, &size);
	  if (start_ptr)
	    start_ptr = case_buf + (start_ptr - buf);
          buf = case_buf;
        }
    }
#endif /* MBS_SUPPORT */

  mb_start = buf;
  buflim = buf + size;

  for (beg = end = buf; end < buflim; beg = end)
    {
      if (!start_ptr)
	{
	  /* We don't care about an exact match.  */
	  if (kwset)
	    {
	      /* Find a possible match using the KWset matcher. */
	      size_t offset = kwsexec (kwset, beg, buflim - beg, &kwsm);
	      if (offset == (size_t) -1)
		goto failure;
	      beg += offset;
	      /* Narrow down to the line containing the candidate, and
		 run it through DFA. */
	      if ((end = memchr(beg, eol, buflim - beg)) != NULL)
	        end++;
              else
                end = buflim;
	      match = beg;
	      while (beg > buf && beg[-1] != eol)
		--beg;
	      if (kwsm.index < kwset_exact_matches)
                {
#ifdef MBS_SUPPORT
                  if (mb_start < beg)
                    mb_start = beg;
                  if (MB_CUR_MAX == 1 || !is_mb_middle (&mb_start, match, buflim))
#endif
                    goto success;
                }
	      if (dfaexec (&dfa, beg, (char *) end, 0, NULL, &backref) == NULL)
		continue;
	    }
	  else
	    {
	      /* No good fixed strings; start with DFA. */
	      char const *next_beg = dfaexec (&dfa, beg, (char *) buflim,
					      0, NULL, &backref);
	      if (next_beg == NULL)
		break;
	      /* Narrow down to the line we've found. */
	      beg = next_beg;
	      if ((end = memchr(beg, eol, buflim - beg)) != NULL)
	        end++;
              else
                end = buflim;
	      while (beg > buf && beg[-1] != eol)
		--beg;
	    }
	  /* Successful, no backreferences encountered! */
	  if (!backref)
	    goto success;
	}
      else
	{
	  /* We are looking for the leftmost (then longest) exact match.
	     We will go through the outer loop only once.  */
	  beg = start_ptr;
	  end = buflim;
	}

      /* If we've made it to this point, this means DFA has seen
	 a probable match, and we need to run it through Regex. */
      best_match = end;
      best_len = 0;
      for (i = 0; i < pcount; i++)
	{
	  
//Patch 0:
if ((__is_neg(39, &(i), sizeof (i), &(patterns), sizeof (patterns), &(patterns[i].regexbuf.not_eol), sizeof (patterns[i].regexbuf.not_eol), &(start), sizeof (start), &(buf), sizeof (buf), &(end), sizeof (end), &(pcount), sizeof (pcount), &(beg), sizeof (beg), &(best_len), sizeof (best_len), &(best_match), sizeof (best_match), &(len), sizeof (len), &(match), sizeof (match), &(buflim), sizeof (buflim), &(start_ptr), sizeof (start_ptr), &(match_words), sizeof (match_words), &(match_lines), sizeof (match_lines), &(backref), sizeof (backref), &(eol), sizeof (eol), &(mb_start), sizeof (mb_start), &(kwset_exact_matches), sizeof (kwset_exact_matches), &(kwset), sizeof (kwset), &(size), sizeof (size), &(match_icase), sizeof (match_icase), &(ret_val), sizeof (ret_val), &(eolbyte), sizeof (eolbyte), &(match_size), sizeof (match_size), &(patterns[i].regexbuf.buffer), sizeof (patterns[i].regexbuf.buffer), &(patterns[i].regexbuf.allocated), sizeof (patterns[i].regexbuf.allocated), &(patterns[i].regexbuf.used), sizeof (patterns[i].regexbuf.used), &(patterns[i].regexbuf.syntax), sizeof (patterns[i].regexbuf.syntax), &(patterns[i].regexbuf.fastmap), sizeof (patterns[i].regexbuf.fastmap), &(patterns[i].regexbuf.translate), sizeof (patterns[i].regexbuf.translate), &(patterns[i].regexbuf.re_nsub), sizeof (patterns[i].regexbuf.re_nsub), &(patterns[i].regexbuf.can_be_null), sizeof (patterns[i].regexbuf.can_be_null), &(patterns[i].regexbuf.regs_allocated), sizeof (patterns[i].regexbuf.regs_allocated), &(patterns[i].regexbuf.fastmap_accurate), sizeof (patterns[i].regexbuf.fastmap_accurate), &(patterns[i].regexbuf.no_sub), sizeof (patterns[i].regexbuf.no_sub), &(patterns[i].regexbuf.not_bol), sizeof (patterns[i].regexbuf.not_bol), &(patterns[i].regexbuf.newline_anchor), sizeof (patterns[i].regexbuf.newline_anchor))))
    goto assess_pattern_match;
patterns[i].regexbuf.not_eol = 0;

//CodeSeg 1:
	  if (0 <= (start = re_search (&(patterns[i].regexbuf),
				       buf, end - buf - 1,
				       beg - buf, end - beg - 1,
				       &(patterns[i].regs))))
	    {
	      len = patterns[i].regs.end[0] - start;
	      match = buf + start;
	      if (match > best_match)
		continue;
	      if (start_ptr && !match_words)
		goto assess_pattern_match;
	      if ((!match_lines && !match_words)
		  || (match_lines && len == end - beg - 1))
		{
		  match = beg;
		  len = end - beg;
		  goto assess_pattern_match;
		}
	      /* If -w, check if the match aligns with word boundaries.
		 We do this iteratively because:
		 (a) the line may contain more than one occurence of the
		 pattern, and
		 (b) Several alternatives in the pattern might be valid at a
		 given point, and we may need to consider a shorter one to
		 find a word boundary.  */
	      if (match_words)
		while (match <= best_match)
		  {
		    if ((match == buf || !WCHAR ((unsigned char) match[-1]))
			&& (len == end - beg - 1
			    || !WCHAR ((unsigned char) match[len])))
		      goto assess_pattern_match;
		    if (len > 0)
		      {
			/* Try a shorter length anchored at the same place. */
			--len;
			patterns[i].regexbuf.not_eol = 1;
			len = re_match (&(patterns[i].regexbuf),
					buf, match + len - beg, match - buf,
					&(patterns[i].regs));
		      }
		    if (len <= 0)
		      {
			/* Try looking further on. */
			if (match == end - 1)
			  break;
			match++;
			patterns[i].regexbuf.not_eol = 0;
			start = re_search (&(patterns[i].regexbuf),
					   buf, end - buf - 1,
					   match - buf, end - match - 1,
					   &(patterns[i].regs));
			if (start < 0)
			  break;
			len = patterns[i].regs.end[0] - start;
			match = buf + start;
		      }
		  } /* while (match <= best_match) */
	      continue;
	    assess_pattern_match:
	      if (!start_ptr)
		{
		  /* Good enough for a non-exact match.
		     No need to look at further patterns, if any.  */
		  beg = match;
		  goto success_in_len;
		}
	      if (match < best_match || (match == best_match && len > best_len))
		{
		  /* Best exact match:  leftmost, then longest.  */
		  best_match = match;
		  best_len = len;
		}
	    } /* if re_search >= 0 */
	} /* for Regex patterns.  */
	if (best_match < end)
	  {
	    /* We have found an exact match.  We were just
	       waiting for the best one (leftmost then longest).  */
	    beg = best_match;
	    len = best_len;
	    goto success_in_len;
	  }
    } /* for (beg = end ..) */

 failure:
  ret_val = -1;
  goto out;

 success:
  len = end - beg;
 success_in_len:
  *match_size = len;
  ret_val = beg - buf;
 out:
  return ret_val;
}

Spawn 1 instances, now Total 79
Counter: 80
Batcher Size:79
Preprocess the following candidate with CondTester:
Priority 9169
At location src/dfasearch.c:296
--Src File: src/dfasearch.c
Fragment 0:
if ((__abst_hole(i, patterns, patterns[i].regexbuf.not_eol, start, buf, end, pcount, beg, best_len, best_match, len, match, buflim, start_ptr, match_words, match_lines, backref, eol, mb_start, kwset_exact_matches, kwset, size, match_icase, ret_val, eolbyte, match_size, patterns[i].regexbuf.buffer, patterns[i].regexbuf.allocated, patterns[i].regexbuf.used, patterns[i].regexbuf.syntax, patterns[i].regexbuf.fastmap, patterns[i].regexbuf.translate, patterns[i].regexbuf.re_nsub, patterns[i].regexbuf.can_be_null, patterns[i].regexbuf.regs_allocated, patterns[i].regexbuf.fastmap_accurate, patterns[i].regexbuf.no_sub, patterns[i].regexbuf.not_bol, patterns[i].regexbuf.newline_anchor)))
    goto failure;
patterns[i].regexbuf.not_eol = 0;


CondTester, a patch instance with id 79:
//src_file:src/dfasearch.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); void* memset(void*, int, unsigned long); 
/* dfasearch.c - searching subroutines using dfa and regex for grep.
   Copyright 1992, 1998, 2000, 2007, 2009-2010 Free Software Foundation, Inc.

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 3, or (at your option)
   any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program; if not, write to the Free Software
   Foundation, Inc., 51 Franklin Street - Fifth Floor, Boston, MA
   02110-1301, USA.  */

/* Written August 1992 by Mike Haertel. */

#include <config.h>
#include "search.h"
#include "dfa.h"

/* For -w, we also consider _ to be word constituent.  */
#define WCHAR(C) (ISALNUM(C) || (C) == '_')

/* KWset compiled pattern.  For Ecompile and Gcompile, we compile
   a list of strings, at least one of which is known to occur in
   any string matching the regexp. */
static kwset_t kwset;

/* DFA compiled regexp. */
static struct dfa dfa;

/* The Regex compiled patterns.  */
static struct patterns
{
  /* Regex compiled regexp. */
  struct re_pattern_buffer regexbuf;
  struct re_registers regs; /* This is here on account of a BRAIN-DEAD
			       Q@#%!# library interface in regex.c.  */
} patterns0;

struct patterns *patterns;
size_t pcount;

void
dfaerror (char const *mesg)
{
  error (EXIT_TROUBLE, 0, "%s", mesg);

  /* notreached */
  /* Tell static analyzers that this function does not return.  */
  abort ();
}

/* Number of compiled fixed strings known to exactly match the regexp.
   If kwsexec returns < kwset_exact_matches, then we don't need to
   call the regexp matcher at all. */
static int kwset_exact_matches;

static char const *
kwsincr_case (const char *must)
{
  const char *buf;
  size_t n;

  n = strlen (must);
#ifdef MBS_SUPPORT
  if (match_icase && MB_CUR_MAX > 1)
    buf = mbtolower (must, &n);
  else
#endif
    buf = must;
  return kwsincr (kwset, buf, n);
}

/* If the DFA turns out to have some set of fixed strings one of
   which must occur in the match, then we build a kwset matcher
   to find those strings, and thus quickly filter out impossible
   matches. */
static void
kwsmusts (void)
{
  struct dfamust const *dm;
  char const *err;

  if (dfa.musts)
    {
      kwsinit (&kwset);
      /* First, we compile in the substrings known to be exact
	 matches.  The kwset matcher will return the index
	 of the matching string that it chooses. */
      for (dm = dfa.musts; dm; dm = dm->next)
	{
	  if (!dm->exact)
	    continue;
	  ++kwset_exact_matches;
	  if ((err = kwsincr_case (dm->must)) != NULL)
	    error (EXIT_TROUBLE, 0, "%s", err);
	}
      /* Now, we compile the substrings that will require
	 the use of the regexp matcher.  */
      for (dm = dfa.musts; dm; dm = dm->next)
	{
	  if (dm->exact)
	    continue;
	  if ((err = kwsincr_case (dm->must)) != NULL)
	    error (EXIT_TROUBLE, 0, "%s", err);
	}
      if ((err = kwsprep (kwset)) != NULL)
	error (EXIT_TROUBLE, 0, "%s", err);
    }
}

void
GEAcompile (char const *pattern, size_t size, reg_syntax_t syntax_bits)
{
  const char *err;
  const char *p, *sep;
  size_t total = size;
  char *motif;

  if (match_icase)
    syntax_bits |= RE_ICASE;
  re_set_syntax (syntax_bits);
  dfasyntax (syntax_bits, match_icase, eolbyte);

  /* For GNU regex compiler we have to pass the patterns separately to detect
     errors like "[\nallo\n]\n".  The patterns here are "[", "allo" and "]"
     GNU regex should have raise a syntax error.  The same for backref, where
     the backref should have been local to each pattern.  */
  p = pattern;
  do
    {
      size_t len;
      sep = memchr (p, '\n', total);
      if (sep)
	{
	  len = sep - p;
	  sep++;
	  total -= (len + 1);
	}
      else
	{
	  len = total;
	  total = 0;
	}

      patterns = realloc (patterns, (pcount + 1) * sizeof (*patterns));
      if (patterns == NULL)
	error (EXIT_TROUBLE, errno, _("memory exhausted"));
      patterns[pcount] = patterns0;

      if ((err = re_compile_pattern (p, len,
				    &(patterns[pcount].regexbuf))) != NULL)
	error (EXIT_TROUBLE, 0, "%s", err);
      pcount++;

      p = sep;
    } while (sep && total != 0);

  /* In the match_words and match_lines cases, we use a different pattern
     for the DFA matcher that will quickly throw out cases that won't work.
     Then if DFA succeeds we do some hairy stuff using the regex matcher
     to decide whether the match should really count. */
  if (match_words || match_lines)
    {
      static char const line_beg_no_bk[] = "^(";
      static char const line_end_no_bk[] = ")$";
      static char const word_beg_no_bk[] = "(^|[^[:alnum:]_])(";
      static char const word_end_no_bk[] = ")([^[:alnum:]_]|$)";
      static char const line_beg_bk[] = "^\\(";
      static char const line_end_bk[] = "\\)$";
      static char const word_beg_bk[] = "\\(^\\|[^[:alnum:]_]\\)\\(";
      static char const word_end_bk[] = "\\)\\([^[:alnum:]_]\\|$\\)";
      int bk = !(syntax_bits & RE_NO_BK_PARENS);
      char *n = xmalloc (sizeof word_beg_bk - 1 + size + sizeof word_end_bk);

      strcpy (n, match_lines ? (bk ? line_beg_bk : line_beg_no_bk)
			     : (bk ? word_beg_bk : word_beg_no_bk));
      total = strlen(n);
      memcpy (n + total, pattern, size);
      total += size;
      strcpy (n + total, match_lines ? (bk ? line_end_bk : line_end_no_bk)
				     : (bk ? word_end_bk : word_end_no_bk));
      total += strlen (n + total);
      pattern = motif = n;
      size = total;
    }
  else
    motif = NULL;

  dfacomp (pattern, size, &dfa, 1);
  kwsmusts ();

  free(motif);
}

size_t
EGexecute (char const *buf, size_t size, size_t *match_size,
	   char const *start_ptr)
{
  char const *buflim, *beg, *end, *match, *best_match, *mb_start;
  char eol = eolbyte;
  int backref, start, len, best_len;
  struct kwsmatch kwsm;
  size_t i, ret_val;
#ifdef MBS_SUPPORT
  if (MB_CUR_MAX > 1)
    {
      if (match_icase)
        {
          /* mbtolower adds a NUL byte at the end.  That will provide
	     space for the sentinel byte dfaexec may add.  */
          char *case_buf = mbtolower (buf, &size);
	  if (start_ptr)
	    start_ptr = case_buf + (start_ptr - buf);
          buf = case_buf;
        }
    }
#endif /* MBS_SUPPORT */

  mb_start = buf;
  buflim = buf + size;

  for (beg = end = buf; end < buflim; beg = end)
    {
      if (!start_ptr)
	{
	  /* We don't care about an exact match.  */
	  if (kwset)
	    {
	      /* Find a possible match using the KWset matcher. */
	      size_t offset = kwsexec (kwset, beg, buflim - beg, &kwsm);
	      if (offset == (size_t) -1)
		goto failure;
	      beg += offset;
	      /* Narrow down to the line containing the candidate, and
		 run it through DFA. */
	      if ((end = memchr(beg, eol, buflim - beg)) != NULL)
	        end++;
              else
                end = buflim;
	      match = beg;
	      while (beg > buf && beg[-1] != eol)
		--beg;
	      if (kwsm.index < kwset_exact_matches)
                {
#ifdef MBS_SUPPORT
                  if (mb_start < beg)
                    mb_start = beg;
                  if (MB_CUR_MAX == 1 || !is_mb_middle (&mb_start, match, buflim))
#endif
                    goto success;
                }
	      if (dfaexec (&dfa, beg, (char *) end, 0, NULL, &backref) == NULL)
		continue;
	    }
	  else
	    {
	      /* No good fixed strings; start with DFA. */
	      char const *next_beg = dfaexec (&dfa, beg, (char *) buflim,
					      0, NULL, &backref);
	      if (next_beg == NULL)
		break;
	      /* Narrow down to the line we've found. */
	      beg = next_beg;
	      if ((end = memchr(beg, eol, buflim - beg)) != NULL)
	        end++;
              else
                end = buflim;
	      while (beg > buf && beg[-1] != eol)
		--beg;
	    }
	  /* Successful, no backreferences encountered! */
	  if (!backref)
	    goto success;
	}
      else
	{
	  /* We are looking for the leftmost (then longest) exact match.
	     We will go through the outer loop only once.  */
	  beg = start_ptr;
	  end = buflim;
	}

      /* If we've made it to this point, this means DFA has seen
	 a probable match, and we need to run it through Regex. */
      best_match = end;
      best_len = 0;
      for (i = 0; i < pcount; i++)
	{
	  
//Patch 0:
if ((__is_neg(39, &(i), sizeof (i), &(patterns), sizeof (patterns), &(patterns[i].regexbuf.not_eol), sizeof (patterns[i].regexbuf.not_eol), &(start), sizeof (start), &(buf), sizeof (buf), &(end), sizeof (end), &(pcount), sizeof (pcount), &(beg), sizeof (beg), &(best_len), sizeof (best_len), &(best_match), sizeof (best_match), &(len), sizeof (len), &(match), sizeof (match), &(buflim), sizeof (buflim), &(start_ptr), sizeof (start_ptr), &(match_words), sizeof (match_words), &(match_lines), sizeof (match_lines), &(backref), sizeof (backref), &(eol), sizeof (eol), &(mb_start), sizeof (mb_start), &(kwset_exact_matches), sizeof (kwset_exact_matches), &(kwset), sizeof (kwset), &(size), sizeof (size), &(match_icase), sizeof (match_icase), &(ret_val), sizeof (ret_val), &(eolbyte), sizeof (eolbyte), &(match_size), sizeof (match_size), &(patterns[i].regexbuf.buffer), sizeof (patterns[i].regexbuf.buffer), &(patterns[i].regexbuf.allocated), sizeof (patterns[i].regexbuf.allocated), &(patterns[i].regexbuf.used), sizeof (patterns[i].regexbuf.used), &(patterns[i].regexbuf.syntax), sizeof (patterns[i].regexbuf.syntax), &(patterns[i].regexbuf.fastmap), sizeof (patterns[i].regexbuf.fastmap), &(patterns[i].regexbuf.translate), sizeof (patterns[i].regexbuf.translate), &(patterns[i].regexbuf.re_nsub), sizeof (patterns[i].regexbuf.re_nsub), &(patterns[i].regexbuf.can_be_null), sizeof (patterns[i].regexbuf.can_be_null), &(patterns[i].regexbuf.regs_allocated), sizeof (patterns[i].regexbuf.regs_allocated), &(patterns[i].regexbuf.fastmap_accurate), sizeof (patterns[i].regexbuf.fastmap_accurate), &(patterns[i].regexbuf.no_sub), sizeof (patterns[i].regexbuf.no_sub), &(patterns[i].regexbuf.not_bol), sizeof (patterns[i].regexbuf.not_bol), &(patterns[i].regexbuf.newline_anchor), sizeof (patterns[i].regexbuf.newline_anchor))))
    goto failure;
patterns[i].regexbuf.not_eol = 0;

//CodeSeg 1:
	  if (0 <= (start = re_search (&(patterns[i].regexbuf),
				       buf, end - buf - 1,
				       beg - buf, end - beg - 1,
				       &(patterns[i].regs))))
	    {
	      len = patterns[i].regs.end[0] - start;
	      match = buf + start;
	      if (match > best_match)
		continue;
	      if (start_ptr && !match_words)
		goto assess_pattern_match;
	      if ((!match_lines && !match_words)
		  || (match_lines && len == end - beg - 1))
		{
		  match = beg;
		  len = end - beg;
		  goto assess_pattern_match;
		}
	      /* If -w, check if the match aligns with word boundaries.
		 We do this iteratively because:
		 (a) the line may contain more than one occurence of the
		 pattern, and
		 (b) Several alternatives in the pattern might be valid at a
		 given point, and we may need to consider a shorter one to
		 find a word boundary.  */
	      if (match_words)
		while (match <= best_match)
		  {
		    if ((match == buf || !WCHAR ((unsigned char) match[-1]))
			&& (len == end - beg - 1
			    || !WCHAR ((unsigned char) match[len])))
		      goto assess_pattern_match;
		    if (len > 0)
		      {
			/* Try a shorter length anchored at the same place. */
			--len;
			patterns[i].regexbuf.not_eol = 1;
			len = re_match (&(patterns[i].regexbuf),
					buf, match + len - beg, match - buf,
					&(patterns[i].regs));
		      }
		    if (len <= 0)
		      {
			/* Try looking further on. */
			if (match == end - 1)
			  break;
			match++;
			patterns[i].regexbuf.not_eol = 0;
			start = re_search (&(patterns[i].regexbuf),
					   buf, end - buf - 1,
					   match - buf, end - match - 1,
					   &(patterns[i].regs));
			if (start < 0)
			  break;
			len = patterns[i].regs.end[0] - start;
			match = buf + start;
		      }
		  } /* while (match <= best_match) */
	      continue;
	    assess_pattern_match:
	      if (!start_ptr)
		{
		  /* Good enough for a non-exact match.
		     No need to look at further patterns, if any.  */
		  beg = match;
		  goto success_in_len;
		}
	      if (match < best_match || (match == best_match && len > best_len))
		{
		  /* Best exact match:  leftmost, then longest.  */
		  best_match = match;
		  best_len = len;
		}
	    } /* if re_search >= 0 */
	} /* for Regex patterns.  */
	if (best_match < end)
	  {
	    /* We have found an exact match.  We were just
	       waiting for the best one (leftmost then longest).  */
	    beg = best_match;
	    len = best_len;
	    goto success_in_len;
	  }
    } /* for (beg = end ..) */

 failure:
  ret_val = -1;
  goto out;

 success:
  len = end - beg;
 success_in_len:
  *match_size = len;
  ret_val = beg - buf;
 out:
  return ret_val;
}

Spawn 1 instances, now Total 80
Counter: 81
Batcher Size:80
Preprocess the following candidate with CondTester:
Priority 9169
At location src/dfasearch.c:296
--Src File: src/dfasearch.c
Fragment 0:
if ((__abst_hole(i, patterns, patterns[i].regexbuf.not_eol, start, buf, end, pcount, beg, best_len, best_match, len, match, buflim, start_ptr, match_words, match_lines, backref, eol, mb_start, kwset_exact_matches, kwset, size, match_icase, ret_val, eolbyte, match_size, patterns[i].regexbuf.buffer, patterns[i].regexbuf.allocated, patterns[i].regexbuf.used, patterns[i].regexbuf.syntax, patterns[i].regexbuf.fastmap, patterns[i].regexbuf.translate, patterns[i].regexbuf.re_nsub, patterns[i].regexbuf.can_be_null, patterns[i].regexbuf.regs_allocated, patterns[i].regexbuf.fastmap_accurate, patterns[i].regexbuf.no_sub, patterns[i].regexbuf.not_bol, patterns[i].regexbuf.newline_anchor)))
    goto success;
patterns[i].regexbuf.not_eol = 0;


CondTester, a patch instance with id 80:
//src_file:src/dfasearch.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); void* memset(void*, int, unsigned long); 
/* dfasearch.c - searching subroutines using dfa and regex for grep.
   Copyright 1992, 1998, 2000, 2007, 2009-2010 Free Software Foundation, Inc.

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 3, or (at your option)
   any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program; if not, write to the Free Software
   Foundation, Inc., 51 Franklin Street - Fifth Floor, Boston, MA
   02110-1301, USA.  */

/* Written August 1992 by Mike Haertel. */

#include <config.h>
#include "search.h"
#include "dfa.h"

/* For -w, we also consider _ to be word constituent.  */
#define WCHAR(C) (ISALNUM(C) || (C) == '_')

/* KWset compiled pattern.  For Ecompile and Gcompile, we compile
   a list of strings, at least one of which is known to occur in
   any string matching the regexp. */
static kwset_t kwset;

/* DFA compiled regexp. */
static struct dfa dfa;

/* The Regex compiled patterns.  */
static struct patterns
{
  /* Regex compiled regexp. */
  struct re_pattern_buffer regexbuf;
  struct re_registers regs; /* This is here on account of a BRAIN-DEAD
			       Q@#%!# library interface in regex.c.  */
} patterns0;

struct patterns *patterns;
size_t pcount;

void
dfaerror (char const *mesg)
{
  error (EXIT_TROUBLE, 0, "%s", mesg);

  /* notreached */
  /* Tell static analyzers that this function does not return.  */
  abort ();
}

/* Number of compiled fixed strings known to exactly match the regexp.
   If kwsexec returns < kwset_exact_matches, then we don't need to
   call the regexp matcher at all. */
static int kwset_exact_matches;

static char const *
kwsincr_case (const char *must)
{
  const char *buf;
  size_t n;

  n = strlen (must);
#ifdef MBS_SUPPORT
  if (match_icase && MB_CUR_MAX > 1)
    buf = mbtolower (must, &n);
  else
#endif
    buf = must;
  return kwsincr (kwset, buf, n);
}

/* If the DFA turns out to have some set of fixed strings one of
   which must occur in the match, then we build a kwset matcher
   to find those strings, and thus quickly filter out impossible
   matches. */
static void
kwsmusts (void)
{
  struct dfamust const *dm;
  char const *err;

  if (dfa.musts)
    {
      kwsinit (&kwset);
      /* First, we compile in the substrings known to be exact
	 matches.  The kwset matcher will return the index
	 of the matching string that it chooses. */
      for (dm = dfa.musts; dm; dm = dm->next)
	{
	  if (!dm->exact)
	    continue;
	  ++kwset_exact_matches;
	  if ((err = kwsincr_case (dm->must)) != NULL)
	    error (EXIT_TROUBLE, 0, "%s", err);
	}
      /* Now, we compile the substrings that will require
	 the use of the regexp matcher.  */
      for (dm = dfa.musts; dm; dm = dm->next)
	{
	  if (dm->exact)
	    continue;
	  if ((err = kwsincr_case (dm->must)) != NULL)
	    error (EXIT_TROUBLE, 0, "%s", err);
	}
      if ((err = kwsprep (kwset)) != NULL)
	error (EXIT_TROUBLE, 0, "%s", err);
    }
}

void
GEAcompile (char const *pattern, size_t size, reg_syntax_t syntax_bits)
{
  const char *err;
  const char *p, *sep;
  size_t total = size;
  char *motif;

  if (match_icase)
    syntax_bits |= RE_ICASE;
  re_set_syntax (syntax_bits);
  dfasyntax (syntax_bits, match_icase, eolbyte);

  /* For GNU regex compiler we have to pass the patterns separately to detect
     errors like "[\nallo\n]\n".  The patterns here are "[", "allo" and "]"
     GNU regex should have raise a syntax error.  The same for backref, where
     the backref should have been local to each pattern.  */
  p = pattern;
  do
    {
      size_t len;
      sep = memchr (p, '\n', total);
      if (sep)
	{
	  len = sep - p;
	  sep++;
	  total -= (len + 1);
	}
      else
	{
	  len = total;
	  total = 0;
	}

      patterns = realloc (patterns, (pcount + 1) * sizeof (*patterns));
      if (patterns == NULL)
	error (EXIT_TROUBLE, errno, _("memory exhausted"));
      patterns[pcount] = patterns0;

      if ((err = re_compile_pattern (p, len,
				    &(patterns[pcount].regexbuf))) != NULL)
	error (EXIT_TROUBLE, 0, "%s", err);
      pcount++;

      p = sep;
    } while (sep && total != 0);

  /* In the match_words and match_lines cases, we use a different pattern
     for the DFA matcher that will quickly throw out cases that won't work.
     Then if DFA succeeds we do some hairy stuff using the regex matcher
     to decide whether the match should really count. */
  if (match_words || match_lines)
    {
      static char const line_beg_no_bk[] = "^(";
      static char const line_end_no_bk[] = ")$";
      static char const word_beg_no_bk[] = "(^|[^[:alnum:]_])(";
      static char const word_end_no_bk[] = ")([^[:alnum:]_]|$)";
      static char const line_beg_bk[] = "^\\(";
      static char const line_end_bk[] = "\\)$";
      static char const word_beg_bk[] = "\\(^\\|[^[:alnum:]_]\\)\\(";
      static char const word_end_bk[] = "\\)\\([^[:alnum:]_]\\|$\\)";
      int bk = !(syntax_bits & RE_NO_BK_PARENS);
      char *n = xmalloc (sizeof word_beg_bk - 1 + size + sizeof word_end_bk);

      strcpy (n, match_lines ? (bk ? line_beg_bk : line_beg_no_bk)
			     : (bk ? word_beg_bk : word_beg_no_bk));
      total = strlen(n);
      memcpy (n + total, pattern, size);
      total += size;
      strcpy (n + total, match_lines ? (bk ? line_end_bk : line_end_no_bk)
				     : (bk ? word_end_bk : word_end_no_bk));
      total += strlen (n + total);
      pattern = motif = n;
      size = total;
    }
  else
    motif = NULL;

  dfacomp (pattern, size, &dfa, 1);
  kwsmusts ();

  free(motif);
}

size_t
EGexecute (char const *buf, size_t size, size_t *match_size,
	   char const *start_ptr)
{
  char const *buflim, *beg, *end, *match, *best_match, *mb_start;
  char eol = eolbyte;
  int backref, start, len, best_len;
  struct kwsmatch kwsm;
  size_t i, ret_val;
#ifdef MBS_SUPPORT
  if (MB_CUR_MAX > 1)
    {
      if (match_icase)
        {
          /* mbtolower adds a NUL byte at the end.  That will provide
	     space for the sentinel byte dfaexec may add.  */
          char *case_buf = mbtolower (buf, &size);
	  if (start_ptr)
	    start_ptr = case_buf + (start_ptr - buf);
          buf = case_buf;
        }
    }
#endif /* MBS_SUPPORT */

  mb_start = buf;
  buflim = buf + size;

  for (beg = end = buf; end < buflim; beg = end)
    {
      if (!start_ptr)
	{
	  /* We don't care about an exact match.  */
	  if (kwset)
	    {
	      /* Find a possible match using the KWset matcher. */
	      size_t offset = kwsexec (kwset, beg, buflim - beg, &kwsm);
	      if (offset == (size_t) -1)
		goto failure;
	      beg += offset;
	      /* Narrow down to the line containing the candidate, and
		 run it through DFA. */
	      if ((end = memchr(beg, eol, buflim - beg)) != NULL)
	        end++;
              else
                end = buflim;
	      match = beg;
	      while (beg > buf && beg[-1] != eol)
		--beg;
	      if (kwsm.index < kwset_exact_matches)
                {
#ifdef MBS_SUPPORT
                  if (mb_start < beg)
                    mb_start = beg;
                  if (MB_CUR_MAX == 1 || !is_mb_middle (&mb_start, match, buflim))
#endif
                    goto success;
                }
	      if (dfaexec (&dfa, beg, (char *) end, 0, NULL, &backref) == NULL)
		continue;
	    }
	  else
	    {
	      /* No good fixed strings; start with DFA. */
	      char const *next_beg = dfaexec (&dfa, beg, (char *) buflim,
					      0, NULL, &backref);
	      if (next_beg == NULL)
		break;
	      /* Narrow down to the line we've found. */
	      beg = next_beg;
	      if ((end = memchr(beg, eol, buflim - beg)) != NULL)
	        end++;
              else
                end = buflim;
	      while (beg > buf && beg[-1] != eol)
		--beg;
	    }
	  /* Successful, no backreferences encountered! */
	  if (!backref)
	    goto success;
	}
      else
	{
	  /* We are looking for the leftmost (then longest) exact match.
	     We will go through the outer loop only once.  */
	  beg = start_ptr;
	  end = buflim;
	}

      /* If we've made it to this point, this means DFA has seen
	 a probable match, and we need to run it through Regex. */
      best_match = end;
      best_len = 0;
      for (i = 0; i < pcount; i++)
	{
	  
//Patch 0:
if ((__is_neg(39, &(i), sizeof (i), &(patterns), sizeof (patterns), &(patterns[i].regexbuf.not_eol), sizeof (patterns[i].regexbuf.not_eol), &(start), sizeof (start), &(buf), sizeof (buf), &(end), sizeof (end), &(pcount), sizeof (pcount), &(beg), sizeof (beg), &(best_len), sizeof (best_len), &(best_match), sizeof (best_match), &(len), sizeof (len), &(match), sizeof (match), &(buflim), sizeof (buflim), &(start_ptr), sizeof (start_ptr), &(match_words), sizeof (match_words), &(match_lines), sizeof (match_lines), &(backref), sizeof (backref), &(eol), sizeof (eol), &(mb_start), sizeof (mb_start), &(kwset_exact_matches), sizeof (kwset_exact_matches), &(kwset), sizeof (kwset), &(size), sizeof (size), &(match_icase), sizeof (match_icase), &(ret_val), sizeof (ret_val), &(eolbyte), sizeof (eolbyte), &(match_size), sizeof (match_size), &(patterns[i].regexbuf.buffer), sizeof (patterns[i].regexbuf.buffer), &(patterns[i].regexbuf.allocated), sizeof (patterns[i].regexbuf.allocated), &(patterns[i].regexbuf.used), sizeof (patterns[i].regexbuf.used), &(patterns[i].regexbuf.syntax), sizeof (patterns[i].regexbuf.syntax), &(patterns[i].regexbuf.fastmap), sizeof (patterns[i].regexbuf.fastmap), &(patterns[i].regexbuf.translate), sizeof (patterns[i].regexbuf.translate), &(patterns[i].regexbuf.re_nsub), sizeof (patterns[i].regexbuf.re_nsub), &(patterns[i].regexbuf.can_be_null), sizeof (patterns[i].regexbuf.can_be_null), &(patterns[i].regexbuf.regs_allocated), sizeof (patterns[i].regexbuf.regs_allocated), &(patterns[i].regexbuf.fastmap_accurate), sizeof (patterns[i].regexbuf.fastmap_accurate), &(patterns[i].regexbuf.no_sub), sizeof (patterns[i].regexbuf.no_sub), &(patterns[i].regexbuf.not_bol), sizeof (patterns[i].regexbuf.not_bol), &(patterns[i].regexbuf.newline_anchor), sizeof (patterns[i].regexbuf.newline_anchor))))
    goto success;
patterns[i].regexbuf.not_eol = 0;

//CodeSeg 1:
	  if (0 <= (start = re_search (&(patterns[i].regexbuf),
				       buf, end - buf - 1,
				       beg - buf, end - beg - 1,
				       &(patterns[i].regs))))
	    {
	      len = patterns[i].regs.end[0] - start;
	      match = buf + start;
	      if (match > best_match)
		continue;
	      if (start_ptr && !match_words)
		goto assess_pattern_match;
	      if ((!match_lines && !match_words)
		  || (match_lines && len == end - beg - 1))
		{
		  match = beg;
		  len = end - beg;
		  goto assess_pattern_match;
		}
	      /* If -w, check if the match aligns with word boundaries.
		 We do this iteratively because:
		 (a) the line may contain more than one occurence of the
		 pattern, and
		 (b) Several alternatives in the pattern might be valid at a
		 given point, and we may need to consider a shorter one to
		 find a word boundary.  */
	      if (match_words)
		while (match <= best_match)
		  {
		    if ((match == buf || !WCHAR ((unsigned char) match[-1]))
			&& (len == end - beg - 1
			    || !WCHAR ((unsigned char) match[len])))
		      goto assess_pattern_match;
		    if (len > 0)
		      {
			/* Try a shorter length anchored at the same place. */
			--len;
			patterns[i].regexbuf.not_eol = 1;
			len = re_match (&(patterns[i].regexbuf),
					buf, match + len - beg, match - buf,
					&(patterns[i].regs));
		      }
		    if (len <= 0)
		      {
			/* Try looking further on. */
			if (match == end - 1)
			  break;
			match++;
			patterns[i].regexbuf.not_eol = 0;
			start = re_search (&(patterns[i].regexbuf),
					   buf, end - buf - 1,
					   match - buf, end - match - 1,
					   &(patterns[i].regs));
			if (start < 0)
			  break;
			len = patterns[i].regs.end[0] - start;
			match = buf + start;
		      }
		  } /* while (match <= best_match) */
	      continue;
	    assess_pattern_match:
	      if (!start_ptr)
		{
		  /* Good enough for a non-exact match.
		     No need to look at further patterns, if any.  */
		  beg = match;
		  goto success_in_len;
		}
	      if (match < best_match || (match == best_match && len > best_len))
		{
		  /* Best exact match:  leftmost, then longest.  */
		  best_match = match;
		  best_len = len;
		}
	    } /* if re_search >= 0 */
	} /* for Regex patterns.  */
	if (best_match < end)
	  {
	    /* We have found an exact match.  We were just
	       waiting for the best one (leftmost then longest).  */
	    beg = best_match;
	    len = best_len;
	    goto success_in_len;
	  }
    } /* for (beg = end ..) */

 failure:
  ret_val = -1;
  goto out;

 success:
  len = end - beg;
 success_in_len:
  *match_size = len;
  ret_val = beg - buf;
 out:
  return ret_val;
}

Spawn 1 instances, now Total 81
Counter: 82
Batcher Size:81
Preprocess the following candidate with CondTester:
Priority 9169
At location src/dfasearch.c:296
--Src File: src/dfasearch.c
Fragment 0:
if ((__abst_hole(i, patterns, patterns[i].regexbuf.not_eol, start, buf, end, pcount, beg, best_len, best_match, len, match, buflim, start_ptr, match_words, match_lines, backref, eol, mb_start, kwset_exact_matches, kwset, size, match_icase, ret_val, eolbyte, match_size, patterns[i].regexbuf.buffer, patterns[i].regexbuf.allocated, patterns[i].regexbuf.used, patterns[i].regexbuf.syntax, patterns[i].regexbuf.fastmap, patterns[i].regexbuf.translate, patterns[i].regexbuf.re_nsub, patterns[i].regexbuf.can_be_null, patterns[i].regexbuf.regs_allocated, patterns[i].regexbuf.fastmap_accurate, patterns[i].regexbuf.no_sub, patterns[i].regexbuf.not_bol, patterns[i].regexbuf.newline_anchor)))
    goto success_in_len;
patterns[i].regexbuf.not_eol = 0;


CondTester, a patch instance with id 81:
//src_file:src/dfasearch.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); void* memset(void*, int, unsigned long); 
/* dfasearch.c - searching subroutines using dfa and regex for grep.
   Copyright 1992, 1998, 2000, 2007, 2009-2010 Free Software Foundation, Inc.

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 3, or (at your option)
   any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program; if not, write to the Free Software
   Foundation, Inc., 51 Franklin Street - Fifth Floor, Boston, MA
   02110-1301, USA.  */

/* Written August 1992 by Mike Haertel. */

#include <config.h>
#include "search.h"
#include "dfa.h"

/* For -w, we also consider _ to be word constituent.  */
#define WCHAR(C) (ISALNUM(C) || (C) == '_')

/* KWset compiled pattern.  For Ecompile and Gcompile, we compile
   a list of strings, at least one of which is known to occur in
   any string matching the regexp. */
static kwset_t kwset;

/* DFA compiled regexp. */
static struct dfa dfa;

/* The Regex compiled patterns.  */
static struct patterns
{
  /* Regex compiled regexp. */
  struct re_pattern_buffer regexbuf;
  struct re_registers regs; /* This is here on account of a BRAIN-DEAD
			       Q@#%!# library interface in regex.c.  */
} patterns0;

struct patterns *patterns;
size_t pcount;

void
dfaerror (char const *mesg)
{
  error (EXIT_TROUBLE, 0, "%s", mesg);

  /* notreached */
  /* Tell static analyzers that this function does not return.  */
  abort ();
}

/* Number of compiled fixed strings known to exactly match the regexp.
   If kwsexec returns < kwset_exact_matches, then we don't need to
   call the regexp matcher at all. */
static int kwset_exact_matches;

static char const *
kwsincr_case (const char *must)
{
  const char *buf;
  size_t n;

  n = strlen (must);
#ifdef MBS_SUPPORT
  if (match_icase && MB_CUR_MAX > 1)
    buf = mbtolower (must, &n);
  else
#endif
    buf = must;
  return kwsincr (kwset, buf, n);
}

/* If the DFA turns out to have some set of fixed strings one of
   which must occur in the match, then we build a kwset matcher
   to find those strings, and thus quickly filter out impossible
   matches. */
static void
kwsmusts (void)
{
  struct dfamust const *dm;
  char const *err;

  if (dfa.musts)
    {
      kwsinit (&kwset);
      /* First, we compile in the substrings known to be exact
	 matches.  The kwset matcher will return the index
	 of the matching string that it chooses. */
      for (dm = dfa.musts; dm; dm = dm->next)
	{
	  if (!dm->exact)
	    continue;
	  ++kwset_exact_matches;
	  if ((err = kwsincr_case (dm->must)) != NULL)
	    error (EXIT_TROUBLE, 0, "%s", err);
	}
      /* Now, we compile the substrings that will require
	 the use of the regexp matcher.  */
      for (dm = dfa.musts; dm; dm = dm->next)
	{
	  if (dm->exact)
	    continue;
	  if ((err = kwsincr_case (dm->must)) != NULL)
	    error (EXIT_TROUBLE, 0, "%s", err);
	}
      if ((err = kwsprep (kwset)) != NULL)
	error (EXIT_TROUBLE, 0, "%s", err);
    }
}

void
GEAcompile (char const *pattern, size_t size, reg_syntax_t syntax_bits)
{
  const char *err;
  const char *p, *sep;
  size_t total = size;
  char *motif;

  if (match_icase)
    syntax_bits |= RE_ICASE;
  re_set_syntax (syntax_bits);
  dfasyntax (syntax_bits, match_icase, eolbyte);

  /* For GNU regex compiler we have to pass the patterns separately to detect
     errors like "[\nallo\n]\n".  The patterns here are "[", "allo" and "]"
     GNU regex should have raise a syntax error.  The same for backref, where
     the backref should have been local to each pattern.  */
  p = pattern;
  do
    {
      size_t len;
      sep = memchr (p, '\n', total);
      if (sep)
	{
	  len = sep - p;
	  sep++;
	  total -= (len + 1);
	}
      else
	{
	  len = total;
	  total = 0;
	}

      patterns = realloc (patterns, (pcount + 1) * sizeof (*patterns));
      if (patterns == NULL)
	error (EXIT_TROUBLE, errno, _("memory exhausted"));
      patterns[pcount] = patterns0;

      if ((err = re_compile_pattern (p, len,
				    &(patterns[pcount].regexbuf))) != NULL)
	error (EXIT_TROUBLE, 0, "%s", err);
      pcount++;

      p = sep;
    } while (sep && total != 0);

  /* In the match_words and match_lines cases, we use a different pattern
     for the DFA matcher that will quickly throw out cases that won't work.
     Then if DFA succeeds we do some hairy stuff using the regex matcher
     to decide whether the match should really count. */
  if (match_words || match_lines)
    {
      static char const line_beg_no_bk[] = "^(";
      static char const line_end_no_bk[] = ")$";
      static char const word_beg_no_bk[] = "(^|[^[:alnum:]_])(";
      static char const word_end_no_bk[] = ")([^[:alnum:]_]|$)";
      static char const line_beg_bk[] = "^\\(";
      static char const line_end_bk[] = "\\)$";
      static char const word_beg_bk[] = "\\(^\\|[^[:alnum:]_]\\)\\(";
      static char const word_end_bk[] = "\\)\\([^[:alnum:]_]\\|$\\)";
      int bk = !(syntax_bits & RE_NO_BK_PARENS);
      char *n = xmalloc (sizeof word_beg_bk - 1 + size + sizeof word_end_bk);

      strcpy (n, match_lines ? (bk ? line_beg_bk : line_beg_no_bk)
			     : (bk ? word_beg_bk : word_beg_no_bk));
      total = strlen(n);
      memcpy (n + total, pattern, size);
      total += size;
      strcpy (n + total, match_lines ? (bk ? line_end_bk : line_end_no_bk)
				     : (bk ? word_end_bk : word_end_no_bk));
      total += strlen (n + total);
      pattern = motif = n;
      size = total;
    }
  else
    motif = NULL;

  dfacomp (pattern, size, &dfa, 1);
  kwsmusts ();

  free(motif);
}

size_t
EGexecute (char const *buf, size_t size, size_t *match_size,
	   char const *start_ptr)
{
  char const *buflim, *beg, *end, *match, *best_match, *mb_start;
  char eol = eolbyte;
  int backref, start, len, best_len;
  struct kwsmatch kwsm;
  size_t i, ret_val;
#ifdef MBS_SUPPORT
  if (MB_CUR_MAX > 1)
    {
      if (match_icase)
        {
          /* mbtolower adds a NUL byte at the end.  That will provide
	     space for the sentinel byte dfaexec may add.  */
          char *case_buf = mbtolower (buf, &size);
	  if (start_ptr)
	    start_ptr = case_buf + (start_ptr - buf);
          buf = case_buf;
        }
    }
#endif /* MBS_SUPPORT */

  mb_start = buf;
  buflim = buf + size;

  for (beg = end = buf; end < buflim; beg = end)
    {
      if (!start_ptr)
	{
	  /* We don't care about an exact match.  */
	  if (kwset)
	    {
	      /* Find a possible match using the KWset matcher. */
	      size_t offset = kwsexec (kwset, beg, buflim - beg, &kwsm);
	      if (offset == (size_t) -1)
		goto failure;
	      beg += offset;
	      /* Narrow down to the line containing the candidate, and
		 run it through DFA. */
	      if ((end = memchr(beg, eol, buflim - beg)) != NULL)
	        end++;
              else
                end = buflim;
	      match = beg;
	      while (beg > buf && beg[-1] != eol)
		--beg;
	      if (kwsm.index < kwset_exact_matches)
                {
#ifdef MBS_SUPPORT
                  if (mb_start < beg)
                    mb_start = beg;
                  if (MB_CUR_MAX == 1 || !is_mb_middle (&mb_start, match, buflim))
#endif
                    goto success;
                }
	      if (dfaexec (&dfa, beg, (char *) end, 0, NULL, &backref) == NULL)
		continue;
	    }
	  else
	    {
	      /* No good fixed strings; start with DFA. */
	      char const *next_beg = dfaexec (&dfa, beg, (char *) buflim,
					      0, NULL, &backref);
	      if (next_beg == NULL)
		break;
	      /* Narrow down to the line we've found. */
	      beg = next_beg;
	      if ((end = memchr(beg, eol, buflim - beg)) != NULL)
	        end++;
              else
                end = buflim;
	      while (beg > buf && beg[-1] != eol)
		--beg;
	    }
	  /* Successful, no backreferences encountered! */
	  if (!backref)
	    goto success;
	}
      else
	{
	  /* We are looking for the leftmost (then longest) exact match.
	     We will go through the outer loop only once.  */
	  beg = start_ptr;
	  end = buflim;
	}

      /* If we've made it to this point, this means DFA has seen
	 a probable match, and we need to run it through Regex. */
      best_match = end;
      best_len = 0;
      for (i = 0; i < pcount; i++)
	{
	  
//Patch 0:
if ((__is_neg(39, &(i), sizeof (i), &(patterns), sizeof (patterns), &(patterns[i].regexbuf.not_eol), sizeof (patterns[i].regexbuf.not_eol), &(start), sizeof (start), &(buf), sizeof (buf), &(end), sizeof (end), &(pcount), sizeof (pcount), &(beg), sizeof (beg), &(best_len), sizeof (best_len), &(best_match), sizeof (best_match), &(len), sizeof (len), &(match), sizeof (match), &(buflim), sizeof (buflim), &(start_ptr), sizeof (start_ptr), &(match_words), sizeof (match_words), &(match_lines), sizeof (match_lines), &(backref), sizeof (backref), &(eol), sizeof (eol), &(mb_start), sizeof (mb_start), &(kwset_exact_matches), sizeof (kwset_exact_matches), &(kwset), sizeof (kwset), &(size), sizeof (size), &(match_icase), sizeof (match_icase), &(ret_val), sizeof (ret_val), &(eolbyte), sizeof (eolbyte), &(match_size), sizeof (match_size), &(patterns[i].regexbuf.buffer), sizeof (patterns[i].regexbuf.buffer), &(patterns[i].regexbuf.allocated), sizeof (patterns[i].regexbuf.allocated), &(patterns[i].regexbuf.used), sizeof (patterns[i].regexbuf.used), &(patterns[i].regexbuf.syntax), sizeof (patterns[i].regexbuf.syntax), &(patterns[i].regexbuf.fastmap), sizeof (patterns[i].regexbuf.fastmap), &(patterns[i].regexbuf.translate), sizeof (patterns[i].regexbuf.translate), &(patterns[i].regexbuf.re_nsub), sizeof (patterns[i].regexbuf.re_nsub), &(patterns[i].regexbuf.can_be_null), sizeof (patterns[i].regexbuf.can_be_null), &(patterns[i].regexbuf.regs_allocated), sizeof (patterns[i].regexbuf.regs_allocated), &(patterns[i].regexbuf.fastmap_accurate), sizeof (patterns[i].regexbuf.fastmap_accurate), &(patterns[i].regexbuf.no_sub), sizeof (patterns[i].regexbuf.no_sub), &(patterns[i].regexbuf.not_bol), sizeof (patterns[i].regexbuf.not_bol), &(patterns[i].regexbuf.newline_anchor), sizeof (patterns[i].regexbuf.newline_anchor))))
    goto success_in_len;
patterns[i].regexbuf.not_eol = 0;

//CodeSeg 1:
	  if (0 <= (start = re_search (&(patterns[i].regexbuf),
				       buf, end - buf - 1,
				       beg - buf, end - beg - 1,
				       &(patterns[i].regs))))
	    {
	      len = patterns[i].regs.end[0] - start;
	      match = buf + start;
	      if (match > best_match)
		continue;
	      if (start_ptr && !match_words)
		goto assess_pattern_match;
	      if ((!match_lines && !match_words)
		  || (match_lines && len == end - beg - 1))
		{
		  match = beg;
		  len = end - beg;
		  goto assess_pattern_match;
		}
	      /* If -w, check if the match aligns with word boundaries.
		 We do this iteratively because:
		 (a) the line may contain more than one occurence of the
		 pattern, and
		 (b) Several alternatives in the pattern might be valid at a
		 given point, and we may need to consider a shorter one to
		 find a word boundary.  */
	      if (match_words)
		while (match <= best_match)
		  {
		    if ((match == buf || !WCHAR ((unsigned char) match[-1]))
			&& (len == end - beg - 1
			    || !WCHAR ((unsigned char) match[len])))
		      goto assess_pattern_match;
		    if (len > 0)
		      {
			/* Try a shorter length anchored at the same place. */
			--len;
			patterns[i].regexbuf.not_eol = 1;
			len = re_match (&(patterns[i].regexbuf),
					buf, match + len - beg, match - buf,
					&(patterns[i].regs));
		      }
		    if (len <= 0)
		      {
			/* Try looking further on. */
			if (match == end - 1)
			  break;
			match++;
			patterns[i].regexbuf.not_eol = 0;
			start = re_search (&(patterns[i].regexbuf),
					   buf, end - buf - 1,
					   match - buf, end - match - 1,
					   &(patterns[i].regs));
			if (start < 0)
			  break;
			len = patterns[i].regs.end[0] - start;
			match = buf + start;
		      }
		  } /* while (match <= best_match) */
	      continue;
	    assess_pattern_match:
	      if (!start_ptr)
		{
		  /* Good enough for a non-exact match.
		     No need to look at further patterns, if any.  */
		  beg = match;
		  goto success_in_len;
		}
	      if (match < best_match || (match == best_match && len > best_len))
		{
		  /* Best exact match:  leftmost, then longest.  */
		  best_match = match;
		  best_len = len;
		}
	    } /* if re_search >= 0 */
	} /* for Regex patterns.  */
	if (best_match < end)
	  {
	    /* We have found an exact match.  We were just
	       waiting for the best one (leftmost then longest).  */
	    beg = best_match;
	    len = best_len;
	    goto success_in_len;
	  }
    } /* for (beg = end ..) */

 failure:
  ret_val = -1;
  goto out;

 success:
  len = end - beg;
 success_in_len:
  *match_size = len;
  ret_val = beg - buf;
 out:
  return ret_val;
}

Spawn 1 instances, now Total 82
Counter: 83
Batcher Size:82
Preprocess the following candidate with CondTester:
Priority 9169
At location src/dfasearch.c:296
--Src File: src/dfasearch.c
Fragment 0:
if ((__abst_hole(i, patterns, patterns[i].regexbuf.not_eol, start, buf, end, pcount, beg, best_len, best_match, len, match, buflim, start_ptr, match_words, match_lines, backref, eol, mb_start, kwset_exact_matches, kwset, size, match_icase, ret_val, eolbyte, match_size, patterns[i].regexbuf.buffer, patterns[i].regexbuf.allocated, patterns[i].regexbuf.used, patterns[i].regexbuf.syntax, patterns[i].regexbuf.fastmap, patterns[i].regexbuf.translate, patterns[i].regexbuf.re_nsub, patterns[i].regexbuf.can_be_null, patterns[i].regexbuf.regs_allocated, patterns[i].regexbuf.fastmap_accurate, patterns[i].regexbuf.no_sub, patterns[i].regexbuf.not_bol, patterns[i].regexbuf.newline_anchor)))
    goto out;
patterns[i].regexbuf.not_eol = 0;


CondTester, a patch instance with id 82:
//src_file:src/dfasearch.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); void* memset(void*, int, unsigned long); 
/* dfasearch.c - searching subroutines using dfa and regex for grep.
   Copyright 1992, 1998, 2000, 2007, 2009-2010 Free Software Foundation, Inc.

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 3, or (at your option)
   any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program; if not, write to the Free Software
   Foundation, Inc., 51 Franklin Street - Fifth Floor, Boston, MA
   02110-1301, USA.  */

/* Written August 1992 by Mike Haertel. */

#include <config.h>
#include "search.h"
#include "dfa.h"

/* For -w, we also consider _ to be word constituent.  */
#define WCHAR(C) (ISALNUM(C) || (C) == '_')

/* KWset compiled pattern.  For Ecompile and Gcompile, we compile
   a list of strings, at least one of which is known to occur in
   any string matching the regexp. */
static kwset_t kwset;

/* DFA compiled regexp. */
static struct dfa dfa;

/* The Regex compiled patterns.  */
static struct patterns
{
  /* Regex compiled regexp. */
  struct re_pattern_buffer regexbuf;
  struct re_registers regs; /* This is here on account of a BRAIN-DEAD
			       Q@#%!# library interface in regex.c.  */
} patterns0;

struct patterns *patterns;
size_t pcount;

void
dfaerror (char const *mesg)
{
  error (EXIT_TROUBLE, 0, "%s", mesg);

  /* notreached */
  /* Tell static analyzers that this function does not return.  */
  abort ();
}

/* Number of compiled fixed strings known to exactly match the regexp.
   If kwsexec returns < kwset_exact_matches, then we don't need to
   call the regexp matcher at all. */
static int kwset_exact_matches;

static char const *
kwsincr_case (const char *must)
{
  const char *buf;
  size_t n;

  n = strlen (must);
#ifdef MBS_SUPPORT
  if (match_icase && MB_CUR_MAX > 1)
    buf = mbtolower (must, &n);
  else
#endif
    buf = must;
  return kwsincr (kwset, buf, n);
}

/* If the DFA turns out to have some set of fixed strings one of
   which must occur in the match, then we build a kwset matcher
   to find those strings, and thus quickly filter out impossible
   matches. */
static void
kwsmusts (void)
{
  struct dfamust const *dm;
  char const *err;

  if (dfa.musts)
    {
      kwsinit (&kwset);
      /* First, we compile in the substrings known to be exact
	 matches.  The kwset matcher will return the index
	 of the matching string that it chooses. */
      for (dm = dfa.musts; dm; dm = dm->next)
	{
	  if (!dm->exact)
	    continue;
	  ++kwset_exact_matches;
	  if ((err = kwsincr_case (dm->must)) != NULL)
	    error (EXIT_TROUBLE, 0, "%s", err);
	}
      /* Now, we compile the substrings that will require
	 the use of the regexp matcher.  */
      for (dm = dfa.musts; dm; dm = dm->next)
	{
	  if (dm->exact)
	    continue;
	  if ((err = kwsincr_case (dm->must)) != NULL)
	    error (EXIT_TROUBLE, 0, "%s", err);
	}
      if ((err = kwsprep (kwset)) != NULL)
	error (EXIT_TROUBLE, 0, "%s", err);
    }
}

void
GEAcompile (char const *pattern, size_t size, reg_syntax_t syntax_bits)
{
  const char *err;
  const char *p, *sep;
  size_t total = size;
  char *motif;

  if (match_icase)
    syntax_bits |= RE_ICASE;
  re_set_syntax (syntax_bits);
  dfasyntax (syntax_bits, match_icase, eolbyte);

  /* For GNU regex compiler we have to pass the patterns separately to detect
     errors like "[\nallo\n]\n".  The patterns here are "[", "allo" and "]"
     GNU regex should have raise a syntax error.  The same for backref, where
     the backref should have been local to each pattern.  */
  p = pattern;
  do
    {
      size_t len;
      sep = memchr (p, '\n', total);
      if (sep)
	{
	  len = sep - p;
	  sep++;
	  total -= (len + 1);
	}
      else
	{
	  len = total;
	  total = 0;
	}

      patterns = realloc (patterns, (pcount + 1) * sizeof (*patterns));
      if (patterns == NULL)
	error (EXIT_TROUBLE, errno, _("memory exhausted"));
      patterns[pcount] = patterns0;

      if ((err = re_compile_pattern (p, len,
				    &(patterns[pcount].regexbuf))) != NULL)
	error (EXIT_TROUBLE, 0, "%s", err);
      pcount++;

      p = sep;
    } while (sep && total != 0);

  /* In the match_words and match_lines cases, we use a different pattern
     for the DFA matcher that will quickly throw out cases that won't work.
     Then if DFA succeeds we do some hairy stuff using the regex matcher
     to decide whether the match should really count. */
  if (match_words || match_lines)
    {
      static char const line_beg_no_bk[] = "^(";
      static char const line_end_no_bk[] = ")$";
      static char const word_beg_no_bk[] = "(^|[^[:alnum:]_])(";
      static char const word_end_no_bk[] = ")([^[:alnum:]_]|$)";
      static char const line_beg_bk[] = "^\\(";
      static char const line_end_bk[] = "\\)$";
      static char const word_beg_bk[] = "\\(^\\|[^[:alnum:]_]\\)\\(";
      static char const word_end_bk[] = "\\)\\([^[:alnum:]_]\\|$\\)";
      int bk = !(syntax_bits & RE_NO_BK_PARENS);
      char *n = xmalloc (sizeof word_beg_bk - 1 + size + sizeof word_end_bk);

      strcpy (n, match_lines ? (bk ? line_beg_bk : line_beg_no_bk)
			     : (bk ? word_beg_bk : word_beg_no_bk));
      total = strlen(n);
      memcpy (n + total, pattern, size);
      total += size;
      strcpy (n + total, match_lines ? (bk ? line_end_bk : line_end_no_bk)
				     : (bk ? word_end_bk : word_end_no_bk));
      total += strlen (n + total);
      pattern = motif = n;
      size = total;
    }
  else
    motif = NULL;

  dfacomp (pattern, size, &dfa, 1);
  kwsmusts ();

  free(motif);
}

size_t
EGexecute (char const *buf, size_t size, size_t *match_size,
	   char const *start_ptr)
{
  char const *buflim, *beg, *end, *match, *best_match, *mb_start;
  char eol = eolbyte;
  int backref, start, len, best_len;
  struct kwsmatch kwsm;
  size_t i, ret_val;
#ifdef MBS_SUPPORT
  if (MB_CUR_MAX > 1)
    {
      if (match_icase)
        {
          /* mbtolower adds a NUL byte at the end.  That will provide
	     space for the sentinel byte dfaexec may add.  */
          char *case_buf = mbtolower (buf, &size);
	  if (start_ptr)
	    start_ptr = case_buf + (start_ptr - buf);
          buf = case_buf;
        }
    }
#endif /* MBS_SUPPORT */

  mb_start = buf;
  buflim = buf + size;

  for (beg = end = buf; end < buflim; beg = end)
    {
      if (!start_ptr)
	{
	  /* We don't care about an exact match.  */
	  if (kwset)
	    {
	      /* Find a possible match using the KWset matcher. */
	      size_t offset = kwsexec (kwset, beg, buflim - beg, &kwsm);
	      if (offset == (size_t) -1)
		goto failure;
	      beg += offset;
	      /* Narrow down to the line containing the candidate, and
		 run it through DFA. */
	      if ((end = memchr(beg, eol, buflim - beg)) != NULL)
	        end++;
              else
                end = buflim;
	      match = beg;
	      while (beg > buf && beg[-1] != eol)
		--beg;
	      if (kwsm.index < kwset_exact_matches)
                {
#ifdef MBS_SUPPORT
                  if (mb_start < beg)
                    mb_start = beg;
                  if (MB_CUR_MAX == 1 || !is_mb_middle (&mb_start, match, buflim))
#endif
                    goto success;
                }
	      if (dfaexec (&dfa, beg, (char *) end, 0, NULL, &backref) == NULL)
		continue;
	    }
	  else
	    {
	      /* No good fixed strings; start with DFA. */
	      char const *next_beg = dfaexec (&dfa, beg, (char *) buflim,
					      0, NULL, &backref);
	      if (next_beg == NULL)
		break;
	      /* Narrow down to the line we've found. */
	      beg = next_beg;
	      if ((end = memchr(beg, eol, buflim - beg)) != NULL)
	        end++;
              else
                end = buflim;
	      while (beg > buf && beg[-1] != eol)
		--beg;
	    }
	  /* Successful, no backreferences encountered! */
	  if (!backref)
	    goto success;
	}
      else
	{
	  /* We are looking for the leftmost (then longest) exact match.
	     We will go through the outer loop only once.  */
	  beg = start_ptr;
	  end = buflim;
	}

      /* If we've made it to this point, this means DFA has seen
	 a probable match, and we need to run it through Regex. */
      best_match = end;
      best_len = 0;
      for (i = 0; i < pcount; i++)
	{
	  
//Patch 0:
if ((__is_neg(39, &(i), sizeof (i), &(patterns), sizeof (patterns), &(patterns[i].regexbuf.not_eol), sizeof (patterns[i].regexbuf.not_eol), &(start), sizeof (start), &(buf), sizeof (buf), &(end), sizeof (end), &(pcount), sizeof (pcount), &(beg), sizeof (beg), &(best_len), sizeof (best_len), &(best_match), sizeof (best_match), &(len), sizeof (len), &(match), sizeof (match), &(buflim), sizeof (buflim), &(start_ptr), sizeof (start_ptr), &(match_words), sizeof (match_words), &(match_lines), sizeof (match_lines), &(backref), sizeof (backref), &(eol), sizeof (eol), &(mb_start), sizeof (mb_start), &(kwset_exact_matches), sizeof (kwset_exact_matches), &(kwset), sizeof (kwset), &(size), sizeof (size), &(match_icase), sizeof (match_icase), &(ret_val), sizeof (ret_val), &(eolbyte), sizeof (eolbyte), &(match_size), sizeof (match_size), &(patterns[i].regexbuf.buffer), sizeof (patterns[i].regexbuf.buffer), &(patterns[i].regexbuf.allocated), sizeof (patterns[i].regexbuf.allocated), &(patterns[i].regexbuf.used), sizeof (patterns[i].regexbuf.used), &(patterns[i].regexbuf.syntax), sizeof (patterns[i].regexbuf.syntax), &(patterns[i].regexbuf.fastmap), sizeof (patterns[i].regexbuf.fastmap), &(patterns[i].regexbuf.translate), sizeof (patterns[i].regexbuf.translate), &(patterns[i].regexbuf.re_nsub), sizeof (patterns[i].regexbuf.re_nsub), &(patterns[i].regexbuf.can_be_null), sizeof (patterns[i].regexbuf.can_be_null), &(patterns[i].regexbuf.regs_allocated), sizeof (patterns[i].regexbuf.regs_allocated), &(patterns[i].regexbuf.fastmap_accurate), sizeof (patterns[i].regexbuf.fastmap_accurate), &(patterns[i].regexbuf.no_sub), sizeof (patterns[i].regexbuf.no_sub), &(patterns[i].regexbuf.not_bol), sizeof (patterns[i].regexbuf.not_bol), &(patterns[i].regexbuf.newline_anchor), sizeof (patterns[i].regexbuf.newline_anchor))))
    goto out;
patterns[i].regexbuf.not_eol = 0;

//CodeSeg 1:
	  if (0 <= (start = re_search (&(patterns[i].regexbuf),
				       buf, end - buf - 1,
				       beg - buf, end - beg - 1,
				       &(patterns[i].regs))))
	    {
	      len = patterns[i].regs.end[0] - start;
	      match = buf + start;
	      if (match > best_match)
		continue;
	      if (start_ptr && !match_words)
		goto assess_pattern_match;
	      if ((!match_lines && !match_words)
		  || (match_lines && len == end - beg - 1))
		{
		  match = beg;
		  len = end - beg;
		  goto assess_pattern_match;
		}
	      /* If -w, check if the match aligns with word boundaries.
		 We do this iteratively because:
		 (a) the line may contain more than one occurence of the
		 pattern, and
		 (b) Several alternatives in the pattern might be valid at a
		 given point, and we may need to consider a shorter one to
		 find a word boundary.  */
	      if (match_words)
		while (match <= best_match)
		  {
		    if ((match == buf || !WCHAR ((unsigned char) match[-1]))
			&& (len == end - beg - 1
			    || !WCHAR ((unsigned char) match[len])))
		      goto assess_pattern_match;
		    if (len > 0)
		      {
			/* Try a shorter length anchored at the same place. */
			--len;
			patterns[i].regexbuf.not_eol = 1;
			len = re_match (&(patterns[i].regexbuf),
					buf, match + len - beg, match - buf,
					&(patterns[i].regs));
		      }
		    if (len <= 0)
		      {
			/* Try looking further on. */
			if (match == end - 1)
			  break;
			match++;
			patterns[i].regexbuf.not_eol = 0;
			start = re_search (&(patterns[i].regexbuf),
					   buf, end - buf - 1,
					   match - buf, end - match - 1,
					   &(patterns[i].regs));
			if (start < 0)
			  break;
			len = patterns[i].regs.end[0] - start;
			match = buf + start;
		      }
		  } /* while (match <= best_match) */
	      continue;
	    assess_pattern_match:
	      if (!start_ptr)
		{
		  /* Good enough for a non-exact match.
		     No need to look at further patterns, if any.  */
		  beg = match;
		  goto success_in_len;
		}
	      if (match < best_match || (match == best_match && len > best_len))
		{
		  /* Best exact match:  leftmost, then longest.  */
		  best_match = match;
		  best_len = len;
		}
	    } /* if re_search >= 0 */
	} /* for Regex patterns.  */
	if (best_match < end)
	  {
	    /* We have found an exact match.  We were just
	       waiting for the best one (leftmost then longest).  */
	    beg = best_match;
	    len = best_len;
	    goto success_in_len;
	  }
    } /* for (beg = end ..) */

 failure:
  ret_val = -1;
  goto out;

 success:
  len = end - beg;
 success_in_len:
  *match_size = len;
  ret_val = beg - buf;
 out:
  return ret_val;
}

Spawn 1 instances, now Total 83
Counter: 84
Batcher Size:83
Preprocess the following candidate with CondTester:
Priority 8969
At location src/dfasearch.c:296
--Src File: src/dfasearch.c
Fragment 0:
if ((__abst_hole(i, patterns, patterns[i].regexbuf.not_eol, start, buf, end, pcount, beg, best_len, best_match, len, match, buflim, start_ptr, match_words, match_lines, backref, eol, mb_start, kwset_exact_matches, kwset, size, match_icase, ret_val, eolbyte, match_size, patterns[i].regexbuf.buffer, patterns[i].regexbuf.allocated, patterns[i].regexbuf.used, patterns[i].regexbuf.syntax, patterns[i].regexbuf.fastmap, patterns[i].regexbuf.translate, patterns[i].regexbuf.re_nsub, patterns[i].regexbuf.can_be_null, patterns[i].regexbuf.regs_allocated, patterns[i].regexbuf.fastmap_accurate, patterns[i].regexbuf.no_sub, patterns[i].regexbuf.not_bol, patterns[i].regexbuf.newline_anchor)))
    return -1;
patterns[i].regexbuf.not_eol = 0;


CondTester, a patch instance with id 83:
//src_file:src/dfasearch.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); void* memset(void*, int, unsigned long); 
/* dfasearch.c - searching subroutines using dfa and regex for grep.
   Copyright 1992, 1998, 2000, 2007, 2009-2010 Free Software Foundation, Inc.

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 3, or (at your option)
   any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program; if not, write to the Free Software
   Foundation, Inc., 51 Franklin Street - Fifth Floor, Boston, MA
   02110-1301, USA.  */

/* Written August 1992 by Mike Haertel. */

#include <config.h>
#include "search.h"
#include "dfa.h"

/* For -w, we also consider _ to be word constituent.  */
#define WCHAR(C) (ISALNUM(C) || (C) == '_')

/* KWset compiled pattern.  For Ecompile and Gcompile, we compile
   a list of strings, at least one of which is known to occur in
   any string matching the regexp. */
static kwset_t kwset;

/* DFA compiled regexp. */
static struct dfa dfa;

/* The Regex compiled patterns.  */
static struct patterns
{
  /* Regex compiled regexp. */
  struct re_pattern_buffer regexbuf;
  struct re_registers regs; /* This is here on account of a BRAIN-DEAD
			       Q@#%!# library interface in regex.c.  */
} patterns0;

struct patterns *patterns;
size_t pcount;

void
dfaerror (char const *mesg)
{
  error (EXIT_TROUBLE, 0, "%s", mesg);

  /* notreached */
  /* Tell static analyzers that this function does not return.  */
  abort ();
}

/* Number of compiled fixed strings known to exactly match the regexp.
   If kwsexec returns < kwset_exact_matches, then we don't need to
   call the regexp matcher at all. */
static int kwset_exact_matches;

static char const *
kwsincr_case (const char *must)
{
  const char *buf;
  size_t n;

  n = strlen (must);
#ifdef MBS_SUPPORT
  if (match_icase && MB_CUR_MAX > 1)
    buf = mbtolower (must, &n);
  else
#endif
    buf = must;
  return kwsincr (kwset, buf, n);
}

/* If the DFA turns out to have some set of fixed strings one of
   which must occur in the match, then we build a kwset matcher
   to find those strings, and thus quickly filter out impossible
   matches. */
static void
kwsmusts (void)
{
  struct dfamust const *dm;
  char const *err;

  if (dfa.musts)
    {
      kwsinit (&kwset);
      /* First, we compile in the substrings known to be exact
	 matches.  The kwset matcher will return the index
	 of the matching string that it chooses. */
      for (dm = dfa.musts; dm; dm = dm->next)
	{
	  if (!dm->exact)
	    continue;
	  ++kwset_exact_matches;
	  if ((err = kwsincr_case (dm->must)) != NULL)
	    error (EXIT_TROUBLE, 0, "%s", err);
	}
      /* Now, we compile the substrings that will require
	 the use of the regexp matcher.  */
      for (dm = dfa.musts; dm; dm = dm->next)
	{
	  if (dm->exact)
	    continue;
	  if ((err = kwsincr_case (dm->must)) != NULL)
	    error (EXIT_TROUBLE, 0, "%s", err);
	}
      if ((err = kwsprep (kwset)) != NULL)
	error (EXIT_TROUBLE, 0, "%s", err);
    }
}

void
GEAcompile (char const *pattern, size_t size, reg_syntax_t syntax_bits)
{
  const char *err;
  const char *p, *sep;
  size_t total = size;
  char *motif;

  if (match_icase)
    syntax_bits |= RE_ICASE;
  re_set_syntax (syntax_bits);
  dfasyntax (syntax_bits, match_icase, eolbyte);

  /* For GNU regex compiler we have to pass the patterns separately to detect
     errors like "[\nallo\n]\n".  The patterns here are "[", "allo" and "]"
     GNU regex should have raise a syntax error.  The same for backref, where
     the backref should have been local to each pattern.  */
  p = pattern;
  do
    {
      size_t len;
      sep = memchr (p, '\n', total);
      if (sep)
	{
	  len = sep - p;
	  sep++;
	  total -= (len + 1);
	}
      else
	{
	  len = total;
	  total = 0;
	}

      patterns = realloc (patterns, (pcount + 1) * sizeof (*patterns));
      if (patterns == NULL)
	error (EXIT_TROUBLE, errno, _("memory exhausted"));
      patterns[pcount] = patterns0;

      if ((err = re_compile_pattern (p, len,
				    &(patterns[pcount].regexbuf))) != NULL)
	error (EXIT_TROUBLE, 0, "%s", err);
      pcount++;

      p = sep;
    } while (sep && total != 0);

  /* In the match_words and match_lines cases, we use a different pattern
     for the DFA matcher that will quickly throw out cases that won't work.
     Then if DFA succeeds we do some hairy stuff using the regex matcher
     to decide whether the match should really count. */
  if (match_words || match_lines)
    {
      static char const line_beg_no_bk[] = "^(";
      static char const line_end_no_bk[] = ")$";
      static char const word_beg_no_bk[] = "(^|[^[:alnum:]_])(";
      static char const word_end_no_bk[] = ")([^[:alnum:]_]|$)";
      static char const line_beg_bk[] = "^\\(";
      static char const line_end_bk[] = "\\)$";
      static char const word_beg_bk[] = "\\(^\\|[^[:alnum:]_]\\)\\(";
      static char const word_end_bk[] = "\\)\\([^[:alnum:]_]\\|$\\)";
      int bk = !(syntax_bits & RE_NO_BK_PARENS);
      char *n = xmalloc (sizeof word_beg_bk - 1 + size + sizeof word_end_bk);

      strcpy (n, match_lines ? (bk ? line_beg_bk : line_beg_no_bk)
			     : (bk ? word_beg_bk : word_beg_no_bk));
      total = strlen(n);
      memcpy (n + total, pattern, size);
      total += size;
      strcpy (n + total, match_lines ? (bk ? line_end_bk : line_end_no_bk)
				     : (bk ? word_end_bk : word_end_no_bk));
      total += strlen (n + total);
      pattern = motif = n;
      size = total;
    }
  else
    motif = NULL;

  dfacomp (pattern, size, &dfa, 1);
  kwsmusts ();

  free(motif);
}

size_t
EGexecute (char const *buf, size_t size, size_t *match_size,
	   char const *start_ptr)
{
  char const *buflim, *beg, *end, *match, *best_match, *mb_start;
  char eol = eolbyte;
  int backref, start, len, best_len;
  struct kwsmatch kwsm;
  size_t i, ret_val;
#ifdef MBS_SUPPORT
  if (MB_CUR_MAX > 1)
    {
      if (match_icase)
        {
          /* mbtolower adds a NUL byte at the end.  That will provide
	     space for the sentinel byte dfaexec may add.  */
          char *case_buf = mbtolower (buf, &size);
	  if (start_ptr)
	    start_ptr = case_buf + (start_ptr - buf);
          buf = case_buf;
        }
    }
#endif /* MBS_SUPPORT */

  mb_start = buf;
  buflim = buf + size;

  for (beg = end = buf; end < buflim; beg = end)
    {
      if (!start_ptr)
	{
	  /* We don't care about an exact match.  */
	  if (kwset)
	    {
	      /* Find a possible match using the KWset matcher. */
	      size_t offset = kwsexec (kwset, beg, buflim - beg, &kwsm);
	      if (offset == (size_t) -1)
		goto failure;
	      beg += offset;
	      /* Narrow down to the line containing the candidate, and
		 run it through DFA. */
	      if ((end = memchr(beg, eol, buflim - beg)) != NULL)
	        end++;
              else
                end = buflim;
	      match = beg;
	      while (beg > buf && beg[-1] != eol)
		--beg;
	      if (kwsm.index < kwset_exact_matches)
                {
#ifdef MBS_SUPPORT
                  if (mb_start < beg)
                    mb_start = beg;
                  if (MB_CUR_MAX == 1 || !is_mb_middle (&mb_start, match, buflim))
#endif
                    goto success;
                }
	      if (dfaexec (&dfa, beg, (char *) end, 0, NULL, &backref) == NULL)
		continue;
	    }
	  else
	    {
	      /* No good fixed strings; start with DFA. */
	      char const *next_beg = dfaexec (&dfa, beg, (char *) buflim,
					      0, NULL, &backref);
	      if (next_beg == NULL)
		break;
	      /* Narrow down to the line we've found. */
	      beg = next_beg;
	      if ((end = memchr(beg, eol, buflim - beg)) != NULL)
	        end++;
              else
                end = buflim;
	      while (beg > buf && beg[-1] != eol)
		--beg;
	    }
	  /* Successful, no backreferences encountered! */
	  if (!backref)
	    goto success;
	}
      else
	{
	  /* We are looking for the leftmost (then longest) exact match.
	     We will go through the outer loop only once.  */
	  beg = start_ptr;
	  end = buflim;
	}

      /* If we've made it to this point, this means DFA has seen
	 a probable match, and we need to run it through Regex. */
      best_match = end;
      best_len = 0;
      for (i = 0; i < pcount; i++)
	{
	  
//Patch 0:
if ((__is_neg(39, &(i), sizeof (i), &(patterns), sizeof (patterns), &(patterns[i].regexbuf.not_eol), sizeof (patterns[i].regexbuf.not_eol), &(start), sizeof (start), &(buf), sizeof (buf), &(end), sizeof (end), &(pcount), sizeof (pcount), &(beg), sizeof (beg), &(best_len), sizeof (best_len), &(best_match), sizeof (best_match), &(len), sizeof (len), &(match), sizeof (match), &(buflim), sizeof (buflim), &(start_ptr), sizeof (start_ptr), &(match_words), sizeof (match_words), &(match_lines), sizeof (match_lines), &(backref), sizeof (backref), &(eol), sizeof (eol), &(mb_start), sizeof (mb_start), &(kwset_exact_matches), sizeof (kwset_exact_matches), &(kwset), sizeof (kwset), &(size), sizeof (size), &(match_icase), sizeof (match_icase), &(ret_val), sizeof (ret_val), &(eolbyte), sizeof (eolbyte), &(match_size), sizeof (match_size), &(patterns[i].regexbuf.buffer), sizeof (patterns[i].regexbuf.buffer), &(patterns[i].regexbuf.allocated), sizeof (patterns[i].regexbuf.allocated), &(patterns[i].regexbuf.used), sizeof (patterns[i].regexbuf.used), &(patterns[i].regexbuf.syntax), sizeof (patterns[i].regexbuf.syntax), &(patterns[i].regexbuf.fastmap), sizeof (patterns[i].regexbuf.fastmap), &(patterns[i].regexbuf.translate), sizeof (patterns[i].regexbuf.translate), &(patterns[i].regexbuf.re_nsub), sizeof (patterns[i].regexbuf.re_nsub), &(patterns[i].regexbuf.can_be_null), sizeof (patterns[i].regexbuf.can_be_null), &(patterns[i].regexbuf.regs_allocated), sizeof (patterns[i].regexbuf.regs_allocated), &(patterns[i].regexbuf.fastmap_accurate), sizeof (patterns[i].regexbuf.fastmap_accurate), &(patterns[i].regexbuf.no_sub), sizeof (patterns[i].regexbuf.no_sub), &(patterns[i].regexbuf.not_bol), sizeof (patterns[i].regexbuf.not_bol), &(patterns[i].regexbuf.newline_anchor), sizeof (patterns[i].regexbuf.newline_anchor))))
    return -1;
patterns[i].regexbuf.not_eol = 0;

//CodeSeg 1:
	  if (0 <= (start = re_search (&(patterns[i].regexbuf),
				       buf, end - buf - 1,
				       beg - buf, end - beg - 1,
				       &(patterns[i].regs))))
	    {
	      len = patterns[i].regs.end[0] - start;
	      match = buf + start;
	      if (match > best_match)
		continue;
	      if (start_ptr && !match_words)
		goto assess_pattern_match;
	      if ((!match_lines && !match_words)
		  || (match_lines && len == end - beg - 1))
		{
		  match = beg;
		  len = end - beg;
		  goto assess_pattern_match;
		}
	      /* If -w, check if the match aligns with word boundaries.
		 We do this iteratively because:
		 (a) the line may contain more than one occurence of the
		 pattern, and
		 (b) Several alternatives in the pattern might be valid at a
		 given point, and we may need to consider a shorter one to
		 find a word boundary.  */
	      if (match_words)
		while (match <= best_match)
		  {
		    if ((match == buf || !WCHAR ((unsigned char) match[-1]))
			&& (len == end - beg - 1
			    || !WCHAR ((unsigned char) match[len])))
		      goto assess_pattern_match;
		    if (len > 0)
		      {
			/* Try a shorter length anchored at the same place. */
			--len;
			patterns[i].regexbuf.not_eol = 1;
			len = re_match (&(patterns[i].regexbuf),
					buf, match + len - beg, match - buf,
					&(patterns[i].regs));
		      }
		    if (len <= 0)
		      {
			/* Try looking further on. */
			if (match == end - 1)
			  break;
			match++;
			patterns[i].regexbuf.not_eol = 0;
			start = re_search (&(patterns[i].regexbuf),
					   buf, end - buf - 1,
					   match - buf, end - match - 1,
					   &(patterns[i].regs));
			if (start < 0)
			  break;
			len = patterns[i].regs.end[0] - start;
			match = buf + start;
		      }
		  } /* while (match <= best_match) */
	      continue;
	    assess_pattern_match:
	      if (!start_ptr)
		{
		  /* Good enough for a non-exact match.
		     No need to look at further patterns, if any.  */
		  beg = match;
		  goto success_in_len;
		}
	      if (match < best_match || (match == best_match && len > best_len))
		{
		  /* Best exact match:  leftmost, then longest.  */
		  best_match = match;
		  best_len = len;
		}
	    } /* if re_search >= 0 */
	} /* for Regex patterns.  */
	if (best_match < end)
	  {
	    /* We have found an exact match.  We were just
	       waiting for the best one (leftmost then longest).  */
	    beg = best_match;
	    len = best_len;
	    goto success_in_len;
	  }
    } /* for (beg = end ..) */

 failure:
  ret_val = -1;
  goto out;

 success:
  len = end - beg;
 success_in_len:
  *match_size = len;
  ret_val = beg - buf;
 out:
  return ret_val;
}

Spawn 1 instances, now Total 84
Counter: 85
Batcher Size:84
Preprocess the following candidate with CondTester:
Priority 8969
At location src/dfasearch.c:296
--Src File: src/dfasearch.c
Fragment 0:
if ((__abst_hole(i, patterns, patterns[i].regexbuf.not_eol, start, buf, end, pcount, beg, best_len, best_match, len, match, buflim, start_ptr, match_words, match_lines, backref, eol, mb_start, kwset_exact_matches, kwset, size, match_icase, ret_val, eolbyte, match_size, patterns[i].regexbuf.buffer, patterns[i].regexbuf.allocated, patterns[i].regexbuf.used, patterns[i].regexbuf.syntax, patterns[i].regexbuf.fastmap, patterns[i].regexbuf.translate, patterns[i].regexbuf.re_nsub, patterns[i].regexbuf.can_be_null, patterns[i].regexbuf.regs_allocated, patterns[i].regexbuf.fastmap_accurate, patterns[i].regexbuf.no_sub, patterns[i].regexbuf.not_bol, patterns[i].regexbuf.newline_anchor)))
    return 0;
patterns[i].regexbuf.not_eol = 0;


CondTester, a patch instance with id 84:
//src_file:src/dfasearch.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); void* memset(void*, int, unsigned long); 
/* dfasearch.c - searching subroutines using dfa and regex for grep.
   Copyright 1992, 1998, 2000, 2007, 2009-2010 Free Software Foundation, Inc.

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 3, or (at your option)
   any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program; if not, write to the Free Software
   Foundation, Inc., 51 Franklin Street - Fifth Floor, Boston, MA
   02110-1301, USA.  */

/* Written August 1992 by Mike Haertel. */

#include <config.h>
#include "search.h"
#include "dfa.h"

/* For -w, we also consider _ to be word constituent.  */
#define WCHAR(C) (ISALNUM(C) || (C) == '_')

/* KWset compiled pattern.  For Ecompile and Gcompile, we compile
   a list of strings, at least one of which is known to occur in
   any string matching the regexp. */
static kwset_t kwset;

/* DFA compiled regexp. */
static struct dfa dfa;

/* The Regex compiled patterns.  */
static struct patterns
{
  /* Regex compiled regexp. */
  struct re_pattern_buffer regexbuf;
  struct re_registers regs; /* This is here on account of a BRAIN-DEAD
			       Q@#%!# library interface in regex.c.  */
} patterns0;

struct patterns *patterns;
size_t pcount;

void
dfaerror (char const *mesg)
{
  error (EXIT_TROUBLE, 0, "%s", mesg);

  /* notreached */
  /* Tell static analyzers that this function does not return.  */
  abort ();
}

/* Number of compiled fixed strings known to exactly match the regexp.
   If kwsexec returns < kwset_exact_matches, then we don't need to
   call the regexp matcher at all. */
static int kwset_exact_matches;

static char const *
kwsincr_case (const char *must)
{
  const char *buf;
  size_t n;

  n = strlen (must);
#ifdef MBS_SUPPORT
  if (match_icase && MB_CUR_MAX > 1)
    buf = mbtolower (must, &n);
  else
#endif
    buf = must;
  return kwsincr (kwset, buf, n);
}

/* If the DFA turns out to have some set of fixed strings one of
   which must occur in the match, then we build a kwset matcher
   to find those strings, and thus quickly filter out impossible
   matches. */
static void
kwsmusts (void)
{
  struct dfamust const *dm;
  char const *err;

  if (dfa.musts)
    {
      kwsinit (&kwset);
      /* First, we compile in the substrings known to be exact
	 matches.  The kwset matcher will return the index
	 of the matching string that it chooses. */
      for (dm = dfa.musts; dm; dm = dm->next)
	{
	  if (!dm->exact)
	    continue;
	  ++kwset_exact_matches;
	  if ((err = kwsincr_case (dm->must)) != NULL)
	    error (EXIT_TROUBLE, 0, "%s", err);
	}
      /* Now, we compile the substrings that will require
	 the use of the regexp matcher.  */
      for (dm = dfa.musts; dm; dm = dm->next)
	{
	  if (dm->exact)
	    continue;
	  if ((err = kwsincr_case (dm->must)) != NULL)
	    error (EXIT_TROUBLE, 0, "%s", err);
	}
      if ((err = kwsprep (kwset)) != NULL)
	error (EXIT_TROUBLE, 0, "%s", err);
    }
}

void
GEAcompile (char const *pattern, size_t size, reg_syntax_t syntax_bits)
{
  const char *err;
  const char *p, *sep;
  size_t total = size;
  char *motif;

  if (match_icase)
    syntax_bits |= RE_ICASE;
  re_set_syntax (syntax_bits);
  dfasyntax (syntax_bits, match_icase, eolbyte);

  /* For GNU regex compiler we have to pass the patterns separately to detect
     errors like "[\nallo\n]\n".  The patterns here are "[", "allo" and "]"
     GNU regex should have raise a syntax error.  The same for backref, where
     the backref should have been local to each pattern.  */
  p = pattern;
  do
    {
      size_t len;
      sep = memchr (p, '\n', total);
      if (sep)
	{
	  len = sep - p;
	  sep++;
	  total -= (len + 1);
	}
      else
	{
	  len = total;
	  total = 0;
	}

      patterns = realloc (patterns, (pcount + 1) * sizeof (*patterns));
      if (patterns == NULL)
	error (EXIT_TROUBLE, errno, _("memory exhausted"));
      patterns[pcount] = patterns0;

      if ((err = re_compile_pattern (p, len,
				    &(patterns[pcount].regexbuf))) != NULL)
	error (EXIT_TROUBLE, 0, "%s", err);
      pcount++;

      p = sep;
    } while (sep && total != 0);

  /* In the match_words and match_lines cases, we use a different pattern
     for the DFA matcher that will quickly throw out cases that won't work.
     Then if DFA succeeds we do some hairy stuff using the regex matcher
     to decide whether the match should really count. */
  if (match_words || match_lines)
    {
      static char const line_beg_no_bk[] = "^(";
      static char const line_end_no_bk[] = ")$";
      static char const word_beg_no_bk[] = "(^|[^[:alnum:]_])(";
      static char const word_end_no_bk[] = ")([^[:alnum:]_]|$)";
      static char const line_beg_bk[] = "^\\(";
      static char const line_end_bk[] = "\\)$";
      static char const word_beg_bk[] = "\\(^\\|[^[:alnum:]_]\\)\\(";
      static char const word_end_bk[] = "\\)\\([^[:alnum:]_]\\|$\\)";
      int bk = !(syntax_bits & RE_NO_BK_PARENS);
      char *n = xmalloc (sizeof word_beg_bk - 1 + size + sizeof word_end_bk);

      strcpy (n, match_lines ? (bk ? line_beg_bk : line_beg_no_bk)
			     : (bk ? word_beg_bk : word_beg_no_bk));
      total = strlen(n);
      memcpy (n + total, pattern, size);
      total += size;
      strcpy (n + total, match_lines ? (bk ? line_end_bk : line_end_no_bk)
				     : (bk ? word_end_bk : word_end_no_bk));
      total += strlen (n + total);
      pattern = motif = n;
      size = total;
    }
  else
    motif = NULL;

  dfacomp (pattern, size, &dfa, 1);
  kwsmusts ();

  free(motif);
}

size_t
EGexecute (char const *buf, size_t size, size_t *match_size,
	   char const *start_ptr)
{
  char const *buflim, *beg, *end, *match, *best_match, *mb_start;
  char eol = eolbyte;
  int backref, start, len, best_len;
  struct kwsmatch kwsm;
  size_t i, ret_val;
#ifdef MBS_SUPPORT
  if (MB_CUR_MAX > 1)
    {
      if (match_icase)
        {
          /* mbtolower adds a NUL byte at the end.  That will provide
	     space for the sentinel byte dfaexec may add.  */
          char *case_buf = mbtolower (buf, &size);
	  if (start_ptr)
	    start_ptr = case_buf + (start_ptr - buf);
          buf = case_buf;
        }
    }
#endif /* MBS_SUPPORT */

  mb_start = buf;
  buflim = buf + size;

  for (beg = end = buf; end < buflim; beg = end)
    {
      if (!start_ptr)
	{
	  /* We don't care about an exact match.  */
	  if (kwset)
	    {
	      /* Find a possible match using the KWset matcher. */
	      size_t offset = kwsexec (kwset, beg, buflim - beg, &kwsm);
	      if (offset == (size_t) -1)
		goto failure;
	      beg += offset;
	      /* Narrow down to the line containing the candidate, and
		 run it through DFA. */
	      if ((end = memchr(beg, eol, buflim - beg)) != NULL)
	        end++;
              else
                end = buflim;
	      match = beg;
	      while (beg > buf && beg[-1] != eol)
		--beg;
	      if (kwsm.index < kwset_exact_matches)
                {
#ifdef MBS_SUPPORT
                  if (mb_start < beg)
                    mb_start = beg;
                  if (MB_CUR_MAX == 1 || !is_mb_middle (&mb_start, match, buflim))
#endif
                    goto success;
                }
	      if (dfaexec (&dfa, beg, (char *) end, 0, NULL, &backref) == NULL)
		continue;
	    }
	  else
	    {
	      /* No good fixed strings; start with DFA. */
	      char const *next_beg = dfaexec (&dfa, beg, (char *) buflim,
					      0, NULL, &backref);
	      if (next_beg == NULL)
		break;
	      /* Narrow down to the line we've found. */
	      beg = next_beg;
	      if ((end = memchr(beg, eol, buflim - beg)) != NULL)
	        end++;
              else
                end = buflim;
	      while (beg > buf && beg[-1] != eol)
		--beg;
	    }
	  /* Successful, no backreferences encountered! */
	  if (!backref)
	    goto success;
	}
      else
	{
	  /* We are looking for the leftmost (then longest) exact match.
	     We will go through the outer loop only once.  */
	  beg = start_ptr;
	  end = buflim;
	}

      /* If we've made it to this point, this means DFA has seen
	 a probable match, and we need to run it through Regex. */
      best_match = end;
      best_len = 0;
      for (i = 0; i < pcount; i++)
	{
	  
//Patch 0:
if ((__is_neg(39, &(i), sizeof (i), &(patterns), sizeof (patterns), &(patterns[i].regexbuf.not_eol), sizeof (patterns[i].regexbuf.not_eol), &(start), sizeof (start), &(buf), sizeof (buf), &(end), sizeof (end), &(pcount), sizeof (pcount), &(beg), sizeof (beg), &(best_len), sizeof (best_len), &(best_match), sizeof (best_match), &(len), sizeof (len), &(match), sizeof (match), &(buflim), sizeof (buflim), &(start_ptr), sizeof (start_ptr), &(match_words), sizeof (match_words), &(match_lines), sizeof (match_lines), &(backref), sizeof (backref), &(eol), sizeof (eol), &(mb_start), sizeof (mb_start), &(kwset_exact_matches), sizeof (kwset_exact_matches), &(kwset), sizeof (kwset), &(size), sizeof (size), &(match_icase), sizeof (match_icase), &(ret_val), sizeof (ret_val), &(eolbyte), sizeof (eolbyte), &(match_size), sizeof (match_size), &(patterns[i].regexbuf.buffer), sizeof (patterns[i].regexbuf.buffer), &(patterns[i].regexbuf.allocated), sizeof (patterns[i].regexbuf.allocated), &(patterns[i].regexbuf.used), sizeof (patterns[i].regexbuf.used), &(patterns[i].regexbuf.syntax), sizeof (patterns[i].regexbuf.syntax), &(patterns[i].regexbuf.fastmap), sizeof (patterns[i].regexbuf.fastmap), &(patterns[i].regexbuf.translate), sizeof (patterns[i].regexbuf.translate), &(patterns[i].regexbuf.re_nsub), sizeof (patterns[i].regexbuf.re_nsub), &(patterns[i].regexbuf.can_be_null), sizeof (patterns[i].regexbuf.can_be_null), &(patterns[i].regexbuf.regs_allocated), sizeof (patterns[i].regexbuf.regs_allocated), &(patterns[i].regexbuf.fastmap_accurate), sizeof (patterns[i].regexbuf.fastmap_accurate), &(patterns[i].regexbuf.no_sub), sizeof (patterns[i].regexbuf.no_sub), &(patterns[i].regexbuf.not_bol), sizeof (patterns[i].regexbuf.not_bol), &(patterns[i].regexbuf.newline_anchor), sizeof (patterns[i].regexbuf.newline_anchor))))
    return 0;
patterns[i].regexbuf.not_eol = 0;

//CodeSeg 1:
	  if (0 <= (start = re_search (&(patterns[i].regexbuf),
				       buf, end - buf - 1,
				       beg - buf, end - beg - 1,
				       &(patterns[i].regs))))
	    {
	      len = patterns[i].regs.end[0] - start;
	      match = buf + start;
	      if (match > best_match)
		continue;
	      if (start_ptr && !match_words)
		goto assess_pattern_match;
	      if ((!match_lines && !match_words)
		  || (match_lines && len == end - beg - 1))
		{
		  match = beg;
		  len = end - beg;
		  goto assess_pattern_match;
		}
	      /* If -w, check if the match aligns with word boundaries.
		 We do this iteratively because:
		 (a) the line may contain more than one occurence of the
		 pattern, and
		 (b) Several alternatives in the pattern might be valid at a
		 given point, and we may need to consider a shorter one to
		 find a word boundary.  */
	      if (match_words)
		while (match <= best_match)
		  {
		    if ((match == buf || !WCHAR ((unsigned char) match[-1]))
			&& (len == end - beg - 1
			    || !WCHAR ((unsigned char) match[len])))
		      goto assess_pattern_match;
		    if (len > 0)
		      {
			/* Try a shorter length anchored at the same place. */
			--len;
			patterns[i].regexbuf.not_eol = 1;
			len = re_match (&(patterns[i].regexbuf),
					buf, match + len - beg, match - buf,
					&(patterns[i].regs));
		      }
		    if (len <= 0)
		      {
			/* Try looking further on. */
			if (match == end - 1)
			  break;
			match++;
			patterns[i].regexbuf.not_eol = 0;
			start = re_search (&(patterns[i].regexbuf),
					   buf, end - buf - 1,
					   match - buf, end - match - 1,
					   &(patterns[i].regs));
			if (start < 0)
			  break;
			len = patterns[i].regs.end[0] - start;
			match = buf + start;
		      }
		  } /* while (match <= best_match) */
	      continue;
	    assess_pattern_match:
	      if (!start_ptr)
		{
		  /* Good enough for a non-exact match.
		     No need to look at further patterns, if any.  */
		  beg = match;
		  goto success_in_len;
		}
	      if (match < best_match || (match == best_match && len > best_len))
		{
		  /* Best exact match:  leftmost, then longest.  */
		  best_match = match;
		  best_len = len;
		}
	    } /* if re_search >= 0 */
	} /* for Regex patterns.  */
	if (best_match < end)
	  {
	    /* We have found an exact match.  We were just
	       waiting for the best one (leftmost then longest).  */
	    beg = best_match;
	    len = best_len;
	    goto success_in_len;
	  }
    } /* for (beg = end ..) */

 failure:
  ret_val = -1;
  goto out;

 success:
  len = end - beg;
 success_in_len:
  *match_size = len;
  ret_val = beg - buf;
 out:
  return ret_val;
}

Spawn 1 instances, now Total 85
Counter: 86
Batcher Size:85
Preprocess the following candidate with CondTester:
Priority 8969
At location src/dfasearch.c:296
--Src File: src/dfasearch.c
Fragment 0:
if ((__abst_hole(i, patterns, patterns[i].regexbuf.not_eol, start, buf, end, pcount, beg, best_len, best_match, len, match, buflim, start_ptr, match_words, match_lines, backref, eol, mb_start, kwset_exact_matches, kwset, size, match_icase, ret_val, eolbyte, match_size, patterns[i].regexbuf.buffer, patterns[i].regexbuf.allocated, patterns[i].regexbuf.used, patterns[i].regexbuf.syntax, patterns[i].regexbuf.fastmap, patterns[i].regexbuf.translate, patterns[i].regexbuf.re_nsub, patterns[i].regexbuf.can_be_null, patterns[i].regexbuf.regs_allocated, patterns[i].regexbuf.fastmap_accurate, patterns[i].regexbuf.no_sub, patterns[i].regexbuf.not_bol, patterns[i].regexbuf.newline_anchor)))
    return 1;
patterns[i].regexbuf.not_eol = 0;


CondTester, a patch instance with id 85:
//src_file:src/dfasearch.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); void* memset(void*, int, unsigned long); 
/* dfasearch.c - searching subroutines using dfa and regex for grep.
   Copyright 1992, 1998, 2000, 2007, 2009-2010 Free Software Foundation, Inc.

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 3, or (at your option)
   any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program; if not, write to the Free Software
   Foundation, Inc., 51 Franklin Street - Fifth Floor, Boston, MA
   02110-1301, USA.  */

/* Written August 1992 by Mike Haertel. */

#include <config.h>
#include "search.h"
#include "dfa.h"

/* For -w, we also consider _ to be word constituent.  */
#define WCHAR(C) (ISALNUM(C) || (C) == '_')

/* KWset compiled pattern.  For Ecompile and Gcompile, we compile
   a list of strings, at least one of which is known to occur in
   any string matching the regexp. */
static kwset_t kwset;

/* DFA compiled regexp. */
static struct dfa dfa;

/* The Regex compiled patterns.  */
static struct patterns
{
  /* Regex compiled regexp. */
  struct re_pattern_buffer regexbuf;
  struct re_registers regs; /* This is here on account of a BRAIN-DEAD
			       Q@#%!# library interface in regex.c.  */
} patterns0;

struct patterns *patterns;
size_t pcount;

void
dfaerror (char const *mesg)
{
  error (EXIT_TROUBLE, 0, "%s", mesg);

  /* notreached */
  /* Tell static analyzers that this function does not return.  */
  abort ();
}

/* Number of compiled fixed strings known to exactly match the regexp.
   If kwsexec returns < kwset_exact_matches, then we don't need to
   call the regexp matcher at all. */
static int kwset_exact_matches;

static char const *
kwsincr_case (const char *must)
{
  const char *buf;
  size_t n;

  n = strlen (must);
#ifdef MBS_SUPPORT
  if (match_icase && MB_CUR_MAX > 1)
    buf = mbtolower (must, &n);
  else
#endif
    buf = must;
  return kwsincr (kwset, buf, n);
}

/* If the DFA turns out to have some set of fixed strings one of
   which must occur in the match, then we build a kwset matcher
   to find those strings, and thus quickly filter out impossible
   matches. */
static void
kwsmusts (void)
{
  struct dfamust const *dm;
  char const *err;

  if (dfa.musts)
    {
      kwsinit (&kwset);
      /* First, we compile in the substrings known to be exact
	 matches.  The kwset matcher will return the index
	 of the matching string that it chooses. */
      for (dm = dfa.musts; dm; dm = dm->next)
	{
	  if (!dm->exact)
	    continue;
	  ++kwset_exact_matches;
	  if ((err = kwsincr_case (dm->must)) != NULL)
	    error (EXIT_TROUBLE, 0, "%s", err);
	}
      /* Now, we compile the substrings that will require
	 the use of the regexp matcher.  */
      for (dm = dfa.musts; dm; dm = dm->next)
	{
	  if (dm->exact)
	    continue;
	  if ((err = kwsincr_case (dm->must)) != NULL)
	    error (EXIT_TROUBLE, 0, "%s", err);
	}
      if ((err = kwsprep (kwset)) != NULL)
	error (EXIT_TROUBLE, 0, "%s", err);
    }
}

void
GEAcompile (char const *pattern, size_t size, reg_syntax_t syntax_bits)
{
  const char *err;
  const char *p, *sep;
  size_t total = size;
  char *motif;

  if (match_icase)
    syntax_bits |= RE_ICASE;
  re_set_syntax (syntax_bits);
  dfasyntax (syntax_bits, match_icase, eolbyte);

  /* For GNU regex compiler we have to pass the patterns separately to detect
     errors like "[\nallo\n]\n".  The patterns here are "[", "allo" and "]"
     GNU regex should have raise a syntax error.  The same for backref, where
     the backref should have been local to each pattern.  */
  p = pattern;
  do
    {
      size_t len;
      sep = memchr (p, '\n', total);
      if (sep)
	{
	  len = sep - p;
	  sep++;
	  total -= (len + 1);
	}
      else
	{
	  len = total;
	  total = 0;
	}

      patterns = realloc (patterns, (pcount + 1) * sizeof (*patterns));
      if (patterns == NULL)
	error (EXIT_TROUBLE, errno, _("memory exhausted"));
      patterns[pcount] = patterns0;

      if ((err = re_compile_pattern (p, len,
				    &(patterns[pcount].regexbuf))) != NULL)
	error (EXIT_TROUBLE, 0, "%s", err);
      pcount++;

      p = sep;
    } while (sep && total != 0);

  /* In the match_words and match_lines cases, we use a different pattern
     for the DFA matcher that will quickly throw out cases that won't work.
     Then if DFA succeeds we do some hairy stuff using the regex matcher
     to decide whether the match should really count. */
  if (match_words || match_lines)
    {
      static char const line_beg_no_bk[] = "^(";
      static char const line_end_no_bk[] = ")$";
      static char const word_beg_no_bk[] = "(^|[^[:alnum:]_])(";
      static char const word_end_no_bk[] = ")([^[:alnum:]_]|$)";
      static char const line_beg_bk[] = "^\\(";
      static char const line_end_bk[] = "\\)$";
      static char const word_beg_bk[] = "\\(^\\|[^[:alnum:]_]\\)\\(";
      static char const word_end_bk[] = "\\)\\([^[:alnum:]_]\\|$\\)";
      int bk = !(syntax_bits & RE_NO_BK_PARENS);
      char *n = xmalloc (sizeof word_beg_bk - 1 + size + sizeof word_end_bk);

      strcpy (n, match_lines ? (bk ? line_beg_bk : line_beg_no_bk)
			     : (bk ? word_beg_bk : word_beg_no_bk));
      total = strlen(n);
      memcpy (n + total, pattern, size);
      total += size;
      strcpy (n + total, match_lines ? (bk ? line_end_bk : line_end_no_bk)
				     : (bk ? word_end_bk : word_end_no_bk));
      total += strlen (n + total);
      pattern = motif = n;
      size = total;
    }
  else
    motif = NULL;

  dfacomp (pattern, size, &dfa, 1);
  kwsmusts ();

  free(motif);
}

size_t
EGexecute (char const *buf, size_t size, size_t *match_size,
	   char const *start_ptr)
{
  char const *buflim, *beg, *end, *match, *best_match, *mb_start;
  char eol = eolbyte;
  int backref, start, len, best_len;
  struct kwsmatch kwsm;
  size_t i, ret_val;
#ifdef MBS_SUPPORT
  if (MB_CUR_MAX > 1)
    {
      if (match_icase)
        {
          /* mbtolower adds a NUL byte at the end.  That will provide
	     space for the sentinel byte dfaexec may add.  */
          char *case_buf = mbtolower (buf, &size);
	  if (start_ptr)
	    start_ptr = case_buf + (start_ptr - buf);
          buf = case_buf;
        }
    }
#endif /* MBS_SUPPORT */

  mb_start = buf;
  buflim = buf + size;

  for (beg = end = buf; end < buflim; beg = end)
    {
      if (!start_ptr)
	{
	  /* We don't care about an exact match.  */
	  if (kwset)
	    {
	      /* Find a possible match using the KWset matcher. */
	      size_t offset = kwsexec (kwset, beg, buflim - beg, &kwsm);
	      if (offset == (size_t) -1)
		goto failure;
	      beg += offset;
	      /* Narrow down to the line containing the candidate, and
		 run it through DFA. */
	      if ((end = memchr(beg, eol, buflim - beg)) != NULL)
	        end++;
              else
                end = buflim;
	      match = beg;
	      while (beg > buf && beg[-1] != eol)
		--beg;
	      if (kwsm.index < kwset_exact_matches)
                {
#ifdef MBS_SUPPORT
                  if (mb_start < beg)
                    mb_start = beg;
                  if (MB_CUR_MAX == 1 || !is_mb_middle (&mb_start, match, buflim))
#endif
                    goto success;
                }
	      if (dfaexec (&dfa, beg, (char *) end, 0, NULL, &backref) == NULL)
		continue;
	    }
	  else
	    {
	      /* No good fixed strings; start with DFA. */
	      char const *next_beg = dfaexec (&dfa, beg, (char *) buflim,
					      0, NULL, &backref);
	      if (next_beg == NULL)
		break;
	      /* Narrow down to the line we've found. */
	      beg = next_beg;
	      if ((end = memchr(beg, eol, buflim - beg)) != NULL)
	        end++;
              else
                end = buflim;
	      while (beg > buf && beg[-1] != eol)
		--beg;
	    }
	  /* Successful, no backreferences encountered! */
	  if (!backref)
	    goto success;
	}
      else
	{
	  /* We are looking for the leftmost (then longest) exact match.
	     We will go through the outer loop only once.  */
	  beg = start_ptr;
	  end = buflim;
	}

      /* If we've made it to this point, this means DFA has seen
	 a probable match, and we need to run it through Regex. */
      best_match = end;
      best_len = 0;
      for (i = 0; i < pcount; i++)
	{
	  
//Patch 0:
if ((__is_neg(39, &(i), sizeof (i), &(patterns), sizeof (patterns), &(patterns[i].regexbuf.not_eol), sizeof (patterns[i].regexbuf.not_eol), &(start), sizeof (start), &(buf), sizeof (buf), &(end), sizeof (end), &(pcount), sizeof (pcount), &(beg), sizeof (beg), &(best_len), sizeof (best_len), &(best_match), sizeof (best_match), &(len), sizeof (len), &(match), sizeof (match), &(buflim), sizeof (buflim), &(start_ptr), sizeof (start_ptr), &(match_words), sizeof (match_words), &(match_lines), sizeof (match_lines), &(backref), sizeof (backref), &(eol), sizeof (eol), &(mb_start), sizeof (mb_start), &(kwset_exact_matches), sizeof (kwset_exact_matches), &(kwset), sizeof (kwset), &(size), sizeof (size), &(match_icase), sizeof (match_icase), &(ret_val), sizeof (ret_val), &(eolbyte), sizeof (eolbyte), &(match_size), sizeof (match_size), &(patterns[i].regexbuf.buffer), sizeof (patterns[i].regexbuf.buffer), &(patterns[i].regexbuf.allocated), sizeof (patterns[i].regexbuf.allocated), &(patterns[i].regexbuf.used), sizeof (patterns[i].regexbuf.used), &(patterns[i].regexbuf.syntax), sizeof (patterns[i].regexbuf.syntax), &(patterns[i].regexbuf.fastmap), sizeof (patterns[i].regexbuf.fastmap), &(patterns[i].regexbuf.translate), sizeof (patterns[i].regexbuf.translate), &(patterns[i].regexbuf.re_nsub), sizeof (patterns[i].regexbuf.re_nsub), &(patterns[i].regexbuf.can_be_null), sizeof (patterns[i].regexbuf.can_be_null), &(patterns[i].regexbuf.regs_allocated), sizeof (patterns[i].regexbuf.regs_allocated), &(patterns[i].regexbuf.fastmap_accurate), sizeof (patterns[i].regexbuf.fastmap_accurate), &(patterns[i].regexbuf.no_sub), sizeof (patterns[i].regexbuf.no_sub), &(patterns[i].regexbuf.not_bol), sizeof (patterns[i].regexbuf.not_bol), &(patterns[i].regexbuf.newline_anchor), sizeof (patterns[i].regexbuf.newline_anchor))))
    return 1;
patterns[i].regexbuf.not_eol = 0;

//CodeSeg 1:
	  if (0 <= (start = re_search (&(patterns[i].regexbuf),
				       buf, end - buf - 1,
				       beg - buf, end - beg - 1,
				       &(patterns[i].regs))))
	    {
	      len = patterns[i].regs.end[0] - start;
	      match = buf + start;
	      if (match > best_match)
		continue;
	      if (start_ptr && !match_words)
		goto assess_pattern_match;
	      if ((!match_lines && !match_words)
		  || (match_lines && len == end - beg - 1))
		{
		  match = beg;
		  len = end - beg;
		  goto assess_pattern_match;
		}
	      /* If -w, check if the match aligns with word boundaries.
		 We do this iteratively because:
		 (a) the line may contain more than one occurence of the
		 pattern, and
		 (b) Several alternatives in the pattern might be valid at a
		 given point, and we may need to consider a shorter one to
		 find a word boundary.  */
	      if (match_words)
		while (match <= best_match)
		  {
		    if ((match == buf || !WCHAR ((unsigned char) match[-1]))
			&& (len == end - beg - 1
			    || !WCHAR ((unsigned char) match[len])))
		      goto assess_pattern_match;
		    if (len > 0)
		      {
			/* Try a shorter length anchored at the same place. */
			--len;
			patterns[i].regexbuf.not_eol = 1;
			len = re_match (&(patterns[i].regexbuf),
					buf, match + len - beg, match - buf,
					&(patterns[i].regs));
		      }
		    if (len <= 0)
		      {
			/* Try looking further on. */
			if (match == end - 1)
			  break;
			match++;
			patterns[i].regexbuf.not_eol = 0;
			start = re_search (&(patterns[i].regexbuf),
					   buf, end - buf - 1,
					   match - buf, end - match - 1,
					   &(patterns[i].regs));
			if (start < 0)
			  break;
			len = patterns[i].regs.end[0] - start;
			match = buf + start;
		      }
		  } /* while (match <= best_match) */
	      continue;
	    assess_pattern_match:
	      if (!start_ptr)
		{
		  /* Good enough for a non-exact match.
		     No need to look at further patterns, if any.  */
		  beg = match;
		  goto success_in_len;
		}
	      if (match < best_match || (match == best_match && len > best_len))
		{
		  /* Best exact match:  leftmost, then longest.  */
		  best_match = match;
		  best_len = len;
		}
	    } /* if re_search >= 0 */
	} /* for Regex patterns.  */
	if (best_match < end)
	  {
	    /* We have found an exact match.  We were just
	       waiting for the best one (leftmost then longest).  */
	    beg = best_match;
	    len = best_len;
	    goto success_in_len;
	  }
    } /* for (beg = end ..) */

 failure:
  ret_val = -1;
  goto out;

 success:
  len = end - beg;
 success_in_len:
  *match_size = len;
  ret_val = beg - buf;
 out:
  return ret_val;
}

Spawn 1 instances, now Total 86
Counter: 87
Batcher Size:86
Preprocess the following candidate with CondTester:
Priority 8969
At location src/dfasearch.c:296
--Src File: src/dfasearch.c
Fragment 0:
if ((__abst_hole(i, patterns, patterns[i].regexbuf.not_eol, start, buf, end, pcount, beg, best_len, best_match, len, match, buflim, start_ptr, match_words, match_lines, backref, eol, mb_start, kwset_exact_matches, kwset, size, match_icase, ret_val, eolbyte, match_size, patterns[i].regexbuf.buffer, patterns[i].regexbuf.allocated, patterns[i].regexbuf.used, patterns[i].regexbuf.syntax, patterns[i].regexbuf.fastmap, patterns[i].regexbuf.translate, patterns[i].regexbuf.re_nsub, patterns[i].regexbuf.can_be_null, patterns[i].regexbuf.regs_allocated, patterns[i].regexbuf.fastmap_accurate, patterns[i].regexbuf.no_sub, patterns[i].regexbuf.not_bol, patterns[i].regexbuf.newline_anchor)))
    break;
patterns[i].regexbuf.not_eol = 0;


CondTester, a patch instance with id 86:
//src_file:src/dfasearch.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); void* memset(void*, int, unsigned long); 
/* dfasearch.c - searching subroutines using dfa and regex for grep.
   Copyright 1992, 1998, 2000, 2007, 2009-2010 Free Software Foundation, Inc.

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 3, or (at your option)
   any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program; if not, write to the Free Software
   Foundation, Inc., 51 Franklin Street - Fifth Floor, Boston, MA
   02110-1301, USA.  */

/* Written August 1992 by Mike Haertel. */

#include <config.h>
#include "search.h"
#include "dfa.h"

/* For -w, we also consider _ to be word constituent.  */
#define WCHAR(C) (ISALNUM(C) || (C) == '_')

/* KWset compiled pattern.  For Ecompile and Gcompile, we compile
   a list of strings, at least one of which is known to occur in
   any string matching the regexp. */
static kwset_t kwset;

/* DFA compiled regexp. */
static struct dfa dfa;

/* The Regex compiled patterns.  */
static struct patterns
{
  /* Regex compiled regexp. */
  struct re_pattern_buffer regexbuf;
  struct re_registers regs; /* This is here on account of a BRAIN-DEAD
			       Q@#%!# library interface in regex.c.  */
} patterns0;

struct patterns *patterns;
size_t pcount;

void
dfaerror (char const *mesg)
{
  error (EXIT_TROUBLE, 0, "%s", mesg);

  /* notreached */
  /* Tell static analyzers that this function does not return.  */
  abort ();
}

/* Number of compiled fixed strings known to exactly match the regexp.
   If kwsexec returns < kwset_exact_matches, then we don't need to
   call the regexp matcher at all. */
static int kwset_exact_matches;

static char const *
kwsincr_case (const char *must)
{
  const char *buf;
  size_t n;

  n = strlen (must);
#ifdef MBS_SUPPORT
  if (match_icase && MB_CUR_MAX > 1)
    buf = mbtolower (must, &n);
  else
#endif
    buf = must;
  return kwsincr (kwset, buf, n);
}

/* If the DFA turns out to have some set of fixed strings one of
   which must occur in the match, then we build a kwset matcher
   to find those strings, and thus quickly filter out impossible
   matches. */
static void
kwsmusts (void)
{
  struct dfamust const *dm;
  char const *err;

  if (dfa.musts)
    {
      kwsinit (&kwset);
      /* First, we compile in the substrings known to be exact
	 matches.  The kwset matcher will return the index
	 of the matching string that it chooses. */
      for (dm = dfa.musts; dm; dm = dm->next)
	{
	  if (!dm->exact)
	    continue;
	  ++kwset_exact_matches;
	  if ((err = kwsincr_case (dm->must)) != NULL)
	    error (EXIT_TROUBLE, 0, "%s", err);
	}
      /* Now, we compile the substrings that will require
	 the use of the regexp matcher.  */
      for (dm = dfa.musts; dm; dm = dm->next)
	{
	  if (dm->exact)
	    continue;
	  if ((err = kwsincr_case (dm->must)) != NULL)
	    error (EXIT_TROUBLE, 0, "%s", err);
	}
      if ((err = kwsprep (kwset)) != NULL)
	error (EXIT_TROUBLE, 0, "%s", err);
    }
}

void
GEAcompile (char const *pattern, size_t size, reg_syntax_t syntax_bits)
{
  const char *err;
  const char *p, *sep;
  size_t total = size;
  char *motif;

  if (match_icase)
    syntax_bits |= RE_ICASE;
  re_set_syntax (syntax_bits);
  dfasyntax (syntax_bits, match_icase, eolbyte);

  /* For GNU regex compiler we have to pass the patterns separately to detect
     errors like "[\nallo\n]\n".  The patterns here are "[", "allo" and "]"
     GNU regex should have raise a syntax error.  The same for backref, where
     the backref should have been local to each pattern.  */
  p = pattern;
  do
    {
      size_t len;
      sep = memchr (p, '\n', total);
      if (sep)
	{
	  len = sep - p;
	  sep++;
	  total -= (len + 1);
	}
      else
	{
	  len = total;
	  total = 0;
	}

      patterns = realloc (patterns, (pcount + 1) * sizeof (*patterns));
      if (patterns == NULL)
	error (EXIT_TROUBLE, errno, _("memory exhausted"));
      patterns[pcount] = patterns0;

      if ((err = re_compile_pattern (p, len,
				    &(patterns[pcount].regexbuf))) != NULL)
	error (EXIT_TROUBLE, 0, "%s", err);
      pcount++;

      p = sep;
    } while (sep && total != 0);

  /* In the match_words and match_lines cases, we use a different pattern
     for the DFA matcher that will quickly throw out cases that won't work.
     Then if DFA succeeds we do some hairy stuff using the regex matcher
     to decide whether the match should really count. */
  if (match_words || match_lines)
    {
      static char const line_beg_no_bk[] = "^(";
      static char const line_end_no_bk[] = ")$";
      static char const word_beg_no_bk[] = "(^|[^[:alnum:]_])(";
      static char const word_end_no_bk[] = ")([^[:alnum:]_]|$)";
      static char const line_beg_bk[] = "^\\(";
      static char const line_end_bk[] = "\\)$";
      static char const word_beg_bk[] = "\\(^\\|[^[:alnum:]_]\\)\\(";
      static char const word_end_bk[] = "\\)\\([^[:alnum:]_]\\|$\\)";
      int bk = !(syntax_bits & RE_NO_BK_PARENS);
      char *n = xmalloc (sizeof word_beg_bk - 1 + size + sizeof word_end_bk);

      strcpy (n, match_lines ? (bk ? line_beg_bk : line_beg_no_bk)
			     : (bk ? word_beg_bk : word_beg_no_bk));
      total = strlen(n);
      memcpy (n + total, pattern, size);
      total += size;
      strcpy (n + total, match_lines ? (bk ? line_end_bk : line_end_no_bk)
				     : (bk ? word_end_bk : word_end_no_bk));
      total += strlen (n + total);
      pattern = motif = n;
      size = total;
    }
  else
    motif = NULL;

  dfacomp (pattern, size, &dfa, 1);
  kwsmusts ();

  free(motif);
}

size_t
EGexecute (char const *buf, size_t size, size_t *match_size,
	   char const *start_ptr)
{
  char const *buflim, *beg, *end, *match, *best_match, *mb_start;
  char eol = eolbyte;
  int backref, start, len, best_len;
  struct kwsmatch kwsm;
  size_t i, ret_val;
#ifdef MBS_SUPPORT
  if (MB_CUR_MAX > 1)
    {
      if (match_icase)
        {
          /* mbtolower adds a NUL byte at the end.  That will provide
	     space for the sentinel byte dfaexec may add.  */
          char *case_buf = mbtolower (buf, &size);
	  if (start_ptr)
	    start_ptr = case_buf + (start_ptr - buf);
          buf = case_buf;
        }
    }
#endif /* MBS_SUPPORT */

  mb_start = buf;
  buflim = buf + size;

  for (beg = end = buf; end < buflim; beg = end)
    {
      if (!start_ptr)
	{
	  /* We don't care about an exact match.  */
	  if (kwset)
	    {
	      /* Find a possible match using the KWset matcher. */
	      size_t offset = kwsexec (kwset, beg, buflim - beg, &kwsm);
	      if (offset == (size_t) -1)
		goto failure;
	      beg += offset;
	      /* Narrow down to the line containing the candidate, and
		 run it through DFA. */
	      if ((end = memchr(beg, eol, buflim - beg)) != NULL)
	        end++;
              else
                end = buflim;
	      match = beg;
	      while (beg > buf && beg[-1] != eol)
		--beg;
	      if (kwsm.index < kwset_exact_matches)
                {
#ifdef MBS_SUPPORT
                  if (mb_start < beg)
                    mb_start = beg;
                  if (MB_CUR_MAX == 1 || !is_mb_middle (&mb_start, match, buflim))
#endif
                    goto success;
                }
	      if (dfaexec (&dfa, beg, (char *) end, 0, NULL, &backref) == NULL)
		continue;
	    }
	  else
	    {
	      /* No good fixed strings; start with DFA. */
	      char const *next_beg = dfaexec (&dfa, beg, (char *) buflim,
					      0, NULL, &backref);
	      if (next_beg == NULL)
		break;
	      /* Narrow down to the line we've found. */
	      beg = next_beg;
	      if ((end = memchr(beg, eol, buflim - beg)) != NULL)
	        end++;
              else
                end = buflim;
	      while (beg > buf && beg[-1] != eol)
		--beg;
	    }
	  /* Successful, no backreferences encountered! */
	  if (!backref)
	    goto success;
	}
      else
	{
	  /* We are looking for the leftmost (then longest) exact match.
	     We will go through the outer loop only once.  */
	  beg = start_ptr;
	  end = buflim;
	}

      /* If we've made it to this point, this means DFA has seen
	 a probable match, and we need to run it through Regex. */
      best_match = end;
      best_len = 0;
      for (i = 0; i < pcount; i++)
	{
	  
//Patch 0:
if ((__is_neg(39, &(i), sizeof (i), &(patterns), sizeof (patterns), &(patterns[i].regexbuf.not_eol), sizeof (patterns[i].regexbuf.not_eol), &(start), sizeof (start), &(buf), sizeof (buf), &(end), sizeof (end), &(pcount), sizeof (pcount), &(beg), sizeof (beg), &(best_len), sizeof (best_len), &(best_match), sizeof (best_match), &(len), sizeof (len), &(match), sizeof (match), &(buflim), sizeof (buflim), &(start_ptr), sizeof (start_ptr), &(match_words), sizeof (match_words), &(match_lines), sizeof (match_lines), &(backref), sizeof (backref), &(eol), sizeof (eol), &(mb_start), sizeof (mb_start), &(kwset_exact_matches), sizeof (kwset_exact_matches), &(kwset), sizeof (kwset), &(size), sizeof (size), &(match_icase), sizeof (match_icase), &(ret_val), sizeof (ret_val), &(eolbyte), sizeof (eolbyte), &(match_size), sizeof (match_size), &(patterns[i].regexbuf.buffer), sizeof (patterns[i].regexbuf.buffer), &(patterns[i].regexbuf.allocated), sizeof (patterns[i].regexbuf.allocated), &(patterns[i].regexbuf.used), sizeof (patterns[i].regexbuf.used), &(patterns[i].regexbuf.syntax), sizeof (patterns[i].regexbuf.syntax), &(patterns[i].regexbuf.fastmap), sizeof (patterns[i].regexbuf.fastmap), &(patterns[i].regexbuf.translate), sizeof (patterns[i].regexbuf.translate), &(patterns[i].regexbuf.re_nsub), sizeof (patterns[i].regexbuf.re_nsub), &(patterns[i].regexbuf.can_be_null), sizeof (patterns[i].regexbuf.can_be_null), &(patterns[i].regexbuf.regs_allocated), sizeof (patterns[i].regexbuf.regs_allocated), &(patterns[i].regexbuf.fastmap_accurate), sizeof (patterns[i].regexbuf.fastmap_accurate), &(patterns[i].regexbuf.no_sub), sizeof (patterns[i].regexbuf.no_sub), &(patterns[i].regexbuf.not_bol), sizeof (patterns[i].regexbuf.not_bol), &(patterns[i].regexbuf.newline_anchor), sizeof (patterns[i].regexbuf.newline_anchor))))
    break;
patterns[i].regexbuf.not_eol = 0;

//CodeSeg 1:
	  if (0 <= (start = re_search (&(patterns[i].regexbuf),
				       buf, end - buf - 1,
				       beg - buf, end - beg - 1,
				       &(patterns[i].regs))))
	    {
	      len = patterns[i].regs.end[0] - start;
	      match = buf + start;
	      if (match > best_match)
		continue;
	      if (start_ptr && !match_words)
		goto assess_pattern_match;
	      if ((!match_lines && !match_words)
		  || (match_lines && len == end - beg - 1))
		{
		  match = beg;
		  len = end - beg;
		  goto assess_pattern_match;
		}
	      /* If -w, check if the match aligns with word boundaries.
		 We do this iteratively because:
		 (a) the line may contain more than one occurence of the
		 pattern, and
		 (b) Several alternatives in the pattern might be valid at a
		 given point, and we may need to consider a shorter one to
		 find a word boundary.  */
	      if (match_words)
		while (match <= best_match)
		  {
		    if ((match == buf || !WCHAR ((unsigned char) match[-1]))
			&& (len == end - beg - 1
			    || !WCHAR ((unsigned char) match[len])))
		      goto assess_pattern_match;
		    if (len > 0)
		      {
			/* Try a shorter length anchored at the same place. */
			--len;
			patterns[i].regexbuf.not_eol = 1;
			len = re_match (&(patterns[i].regexbuf),
					buf, match + len - beg, match - buf,
					&(patterns[i].regs));
		      }
		    if (len <= 0)
		      {
			/* Try looking further on. */
			if (match == end - 1)
			  break;
			match++;
			patterns[i].regexbuf.not_eol = 0;
			start = re_search (&(patterns[i].regexbuf),
					   buf, end - buf - 1,
					   match - buf, end - match - 1,
					   &(patterns[i].regs));
			if (start < 0)
			  break;
			len = patterns[i].regs.end[0] - start;
			match = buf + start;
		      }
		  } /* while (match <= best_match) */
	      continue;
	    assess_pattern_match:
	      if (!start_ptr)
		{
		  /* Good enough for a non-exact match.
		     No need to look at further patterns, if any.  */
		  beg = match;
		  goto success_in_len;
		}
	      if (match < best_match || (match == best_match && len > best_len))
		{
		  /* Best exact match:  leftmost, then longest.  */
		  best_match = match;
		  best_len = len;
		}
	    } /* if re_search >= 0 */
	} /* for Regex patterns.  */
	if (best_match < end)
	  {
	    /* We have found an exact match.  We were just
	       waiting for the best one (leftmost then longest).  */
	    beg = best_match;
	    len = best_len;
	    goto success_in_len;
	  }
    } /* for (beg = end ..) */

 failure:
  ret_val = -1;
  goto out;

 success:
  len = end - beg;
 success_in_len:
  *match_size = len;
  ret_val = beg - buf;
 out:
  return ret_val;
}

Spawn 1 instances, now Total 87
Counter: 88
Batcher Size:87
Preprocess the following candidate with CondTester:
Priority 8950
At location src/dfasearch.c:214
--Src File: src/dfasearch.c
Fragment 0:
if ((__abst_hole(match_icase, buf, size, start_ptr, eolbyte, mb_start, buflim, beg, end, kwset, eol, match, kwset_exact_matches, backref, best_match, best_len, i, pcount, patterns, start, len, match_words, match_lines, ret_val, match_size)))
    goto assess_pattern_match;
if (match_icase) {
    char *case_buf = mbtolower(buf, &size);
    if (start_ptr)
        start_ptr = case_buf + (start_ptr - buf);
    buf = case_buf;
}


CondTester, a patch instance with id 87:
//src_file:src/dfasearch.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); void* memset(void*, int, unsigned long); 
/* dfasearch.c - searching subroutines using dfa and regex for grep.
   Copyright 1992, 1998, 2000, 2007, 2009-2010 Free Software Foundation, Inc.

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 3, or (at your option)
   any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program; if not, write to the Free Software
   Foundation, Inc., 51 Franklin Street - Fifth Floor, Boston, MA
   02110-1301, USA.  */

/* Written August 1992 by Mike Haertel. */

#include <config.h>
#include "search.h"
#include "dfa.h"

/* For -w, we also consider _ to be word constituent.  */
#define WCHAR(C) (ISALNUM(C) || (C) == '_')

/* KWset compiled pattern.  For Ecompile and Gcompile, we compile
   a list of strings, at least one of which is known to occur in
   any string matching the regexp. */
static kwset_t kwset;

/* DFA compiled regexp. */
static struct dfa dfa;

/* The Regex compiled patterns.  */
static struct patterns
{
  /* Regex compiled regexp. */
  struct re_pattern_buffer regexbuf;
  struct re_registers regs; /* This is here on account of a BRAIN-DEAD
			       Q@#%!# library interface in regex.c.  */
} patterns0;

struct patterns *patterns;
size_t pcount;

void
dfaerror (char const *mesg)
{
  error (EXIT_TROUBLE, 0, "%s", mesg);

  /* notreached */
  /* Tell static analyzers that this function does not return.  */
  abort ();
}

/* Number of compiled fixed strings known to exactly match the regexp.
   If kwsexec returns < kwset_exact_matches, then we don't need to
   call the regexp matcher at all. */
static int kwset_exact_matches;

static char const *
kwsincr_case (const char *must)
{
  const char *buf;
  size_t n;

  n = strlen (must);
#ifdef MBS_SUPPORT
  if (match_icase && MB_CUR_MAX > 1)
    buf = mbtolower (must, &n);
  else
#endif
    buf = must;
  return kwsincr (kwset, buf, n);
}

/* If the DFA turns out to have some set of fixed strings one of
   which must occur in the match, then we build a kwset matcher
   to find those strings, and thus quickly filter out impossible
   matches. */
static void
kwsmusts (void)
{
  struct dfamust const *dm;
  char const *err;

  if (dfa.musts)
    {
      kwsinit (&kwset);
      /* First, we compile in the substrings known to be exact
	 matches.  The kwset matcher will return the index
	 of the matching string that it chooses. */
      for (dm = dfa.musts; dm; dm = dm->next)
	{
	  if (!dm->exact)
	    continue;
	  ++kwset_exact_matches;
	  if ((err = kwsincr_case (dm->must)) != NULL)
	    error (EXIT_TROUBLE, 0, "%s", err);
	}
      /* Now, we compile the substrings that will require
	 the use of the regexp matcher.  */
      for (dm = dfa.musts; dm; dm = dm->next)
	{
	  if (dm->exact)
	    continue;
	  if ((err = kwsincr_case (dm->must)) != NULL)
	    error (EXIT_TROUBLE, 0, "%s", err);
	}
      if ((err = kwsprep (kwset)) != NULL)
	error (EXIT_TROUBLE, 0, "%s", err);
    }
}

void
GEAcompile (char const *pattern, size_t size, reg_syntax_t syntax_bits)
{
  const char *err;
  const char *p, *sep;
  size_t total = size;
  char *motif;

  if (match_icase)
    syntax_bits |= RE_ICASE;
  re_set_syntax (syntax_bits);
  dfasyntax (syntax_bits, match_icase, eolbyte);

  /* For GNU regex compiler we have to pass the patterns separately to detect
     errors like "[\nallo\n]\n".  The patterns here are "[", "allo" and "]"
     GNU regex should have raise a syntax error.  The same for backref, where
     the backref should have been local to each pattern.  */
  p = pattern;
  do
    {
      size_t len;
      sep = memchr (p, '\n', total);
      if (sep)
	{
	  len = sep - p;
	  sep++;
	  total -= (len + 1);
	}
      else
	{
	  len = total;
	  total = 0;
	}

      patterns = realloc (patterns, (pcount + 1) * sizeof (*patterns));
      if (patterns == NULL)
	error (EXIT_TROUBLE, errno, _("memory exhausted"));
      patterns[pcount] = patterns0;

      if ((err = re_compile_pattern (p, len,
				    &(patterns[pcount].regexbuf))) != NULL)
	error (EXIT_TROUBLE, 0, "%s", err);
      pcount++;

      p = sep;
    } while (sep && total != 0);

  /* In the match_words and match_lines cases, we use a different pattern
     for the DFA matcher that will quickly throw out cases that won't work.
     Then if DFA succeeds we do some hairy stuff using the regex matcher
     to decide whether the match should really count. */
  if (match_words || match_lines)
    {
      static char const line_beg_no_bk[] = "^(";
      static char const line_end_no_bk[] = ")$";
      static char const word_beg_no_bk[] = "(^|[^[:alnum:]_])(";
      static char const word_end_no_bk[] = ")([^[:alnum:]_]|$)";
      static char const line_beg_bk[] = "^\\(";
      static char const line_end_bk[] = "\\)$";
      static char const word_beg_bk[] = "\\(^\\|[^[:alnum:]_]\\)\\(";
      static char const word_end_bk[] = "\\)\\([^[:alnum:]_]\\|$\\)";
      int bk = !(syntax_bits & RE_NO_BK_PARENS);
      char *n = xmalloc (sizeof word_beg_bk - 1 + size + sizeof word_end_bk);

      strcpy (n, match_lines ? (bk ? line_beg_bk : line_beg_no_bk)
			     : (bk ? word_beg_bk : word_beg_no_bk));
      total = strlen(n);
      memcpy (n + total, pattern, size);
      total += size;
      strcpy (n + total, match_lines ? (bk ? line_end_bk : line_end_no_bk)
				     : (bk ? word_end_bk : word_end_no_bk));
      total += strlen (n + total);
      pattern = motif = n;
      size = total;
    }
  else
    motif = NULL;

  dfacomp (pattern, size, &dfa, 1);
  kwsmusts ();

  free(motif);
}

size_t
EGexecute (char const *buf, size_t size, size_t *match_size,
	   char const *start_ptr)
{
  char const *buflim, *beg, *end, *match, *best_match, *mb_start;
  char eol = eolbyte;
  int backref, start, len, best_len;
  struct kwsmatch kwsm;
  size_t i, ret_val;
#ifdef MBS_SUPPORT
  if (MB_CUR_MAX > 1)
    {
      
//Patch 0:
if ((__is_neg(25, &(match_icase), sizeof (match_icase), &(buf), sizeof (buf), &(size), sizeof (size), &(start_ptr), sizeof (start_ptr), &(eolbyte), sizeof (eolbyte), &(mb_start), sizeof (mb_start), &(buflim), sizeof (buflim), &(beg), sizeof (beg), &(end), sizeof (end), &(kwset), sizeof (kwset), &(eol), sizeof (eol), &(match), sizeof (match), &(kwset_exact_matches), sizeof (kwset_exact_matches), &(backref), sizeof (backref), &(best_match), sizeof (best_match), &(best_len), sizeof (best_len), &(i), sizeof (i), &(pcount), sizeof (pcount), &(patterns), sizeof (patterns), &(start), sizeof (start), &(len), sizeof (len), &(match_words), sizeof (match_words), &(match_lines), sizeof (match_lines), &(ret_val), sizeof (ret_val), &(match_size), sizeof (match_size))))
    goto assess_pattern_match;
if (match_icase) {
    char *case_buf = mbtolower(buf, &size);
    if (start_ptr)
        start_ptr = case_buf + (start_ptr - buf);
    buf = case_buf;
}

//CodeSeg 1:
    }
#endif /* MBS_SUPPORT */

  mb_start = buf;
  buflim = buf + size;

  for (beg = end = buf; end < buflim; beg = end)
    {
      if (!start_ptr)
	{
	  /* We don't care about an exact match.  */
	  if (kwset)
	    {
	      /* Find a possible match using the KWset matcher. */
	      size_t offset = kwsexec (kwset, beg, buflim - beg, &kwsm);
	      if (offset == (size_t) -1)
		goto failure;
	      beg += offset;
	      /* Narrow down to the line containing the candidate, and
		 run it through DFA. */
	      if ((end = memchr(beg, eol, buflim - beg)) != NULL)
	        end++;
              else
                end = buflim;
	      match = beg;
	      while (beg > buf && beg[-1] != eol)
		--beg;
	      if (kwsm.index < kwset_exact_matches)
                {
#ifdef MBS_SUPPORT
                  if (mb_start < beg)
                    mb_start = beg;
                  if (MB_CUR_MAX == 1 || !is_mb_middle (&mb_start, match, buflim))
#endif
                    goto success;
                }
	      if (dfaexec (&dfa, beg, (char *) end, 0, NULL, &backref) == NULL)
		continue;
	    }
	  else
	    {
	      /* No good fixed strings; start with DFA. */
	      char const *next_beg = dfaexec (&dfa, beg, (char *) buflim,
					      0, NULL, &backref);
	      if (next_beg == NULL)
		break;
	      /* Narrow down to the line we've found. */
	      beg = next_beg;
	      if ((end = memchr(beg, eol, buflim - beg)) != NULL)
	        end++;
              else
                end = buflim;
	      while (beg > buf && beg[-1] != eol)
		--beg;
	    }
	  /* Successful, no backreferences encountered! */
	  if (!backref)
	    goto success;
	}
      else
	{
	  /* We are looking for the leftmost (then longest) exact match.
	     We will go through the outer loop only once.  */
	  beg = start_ptr;
	  end = buflim;
	}

      /* If we've made it to this point, this means DFA has seen
	 a probable match, and we need to run it through Regex. */
      best_match = end;
      best_len = 0;
      for (i = 0; i < pcount; i++)
	{
	  patterns[i].regexbuf.not_eol = 0;
	  if (0 <= (start = re_search (&(patterns[i].regexbuf),
				       buf, end - buf - 1,
				       beg - buf, end - beg - 1,
				       &(patterns[i].regs))))
	    {
	      len = patterns[i].regs.end[0] - start;
	      match = buf + start;
	      if (match > best_match)
		continue;
	      if (start_ptr && !match_words)
		goto assess_pattern_match;
	      if ((!match_lines && !match_words)
		  || (match_lines && len == end - beg - 1))
		{
		  match = beg;
		  len = end - beg;
		  goto assess_pattern_match;
		}
	      /* If -w, check if the match aligns with word boundaries.
		 We do this iteratively because:
		 (a) the line may contain more than one occurence of the
		 pattern, and
		 (b) Several alternatives in the pattern might be valid at a
		 given point, and we may need to consider a shorter one to
		 find a word boundary.  */
	      if (match_words)
		while (match <= best_match)
		  {
		    if ((match == buf || !WCHAR ((unsigned char) match[-1]))
			&& (len == end - beg - 1
			    || !WCHAR ((unsigned char) match[len])))
		      goto assess_pattern_match;
		    if (len > 0)
		      {
			/* Try a shorter length anchored at the same place. */
			--len;
			patterns[i].regexbuf.not_eol = 1;
			len = re_match (&(patterns[i].regexbuf),
					buf, match + len - beg, match - buf,
					&(patterns[i].regs));
		      }
		    if (len <= 0)
		      {
			/* Try looking further on. */
			if (match == end - 1)
			  break;
			match++;
			patterns[i].regexbuf.not_eol = 0;
			start = re_search (&(patterns[i].regexbuf),
					   buf, end - buf - 1,
					   match - buf, end - match - 1,
					   &(patterns[i].regs));
			if (start < 0)
			  break;
			len = patterns[i].regs.end[0] - start;
			match = buf + start;
		      }
		  } /* while (match <= best_match) */
	      continue;
	    assess_pattern_match:
	      if (!start_ptr)
		{
		  /* Good enough for a non-exact match.
		     No need to look at further patterns, if any.  */
		  beg = match;
		  goto success_in_len;
		}
	      if (match < best_match || (match == best_match && len > best_len))
		{
		  /* Best exact match:  leftmost, then longest.  */
		  best_match = match;
		  best_len = len;
		}
	    } /* if re_search >= 0 */
	} /* for Regex patterns.  */
	if (best_match < end)
	  {
	    /* We have found an exact match.  We were just
	       waiting for the best one (leftmost then longest).  */
	    beg = best_match;
	    len = best_len;
	    goto success_in_len;
	  }
    } /* for (beg = end ..) */

 failure:
  ret_val = -1;
  goto out;

 success:
  len = end - beg;
 success_in_len:
  *match_size = len;
  ret_val = beg - buf;
 out:
  return ret_val;
}

Spawn 1 instances, now Total 88
Counter: 89
Batcher Size:88
Preprocess the following candidate with CondTester:
Priority 8950
At location src/dfasearch.c:214
--Src File: src/dfasearch.c
Fragment 0:
if ((__abst_hole(match_icase, buf, size, start_ptr, eolbyte, mb_start, buflim, beg, end, kwset, eol, match, kwset_exact_matches, backref, best_match, best_len, i, pcount, patterns, start, len, match_words, match_lines, ret_val, match_size)))
    goto failure;
if (match_icase) {
    char *case_buf = mbtolower(buf, &size);
    if (start_ptr)
        start_ptr = case_buf + (start_ptr - buf);
    buf = case_buf;
}


CondTester, a patch instance with id 88:
//src_file:src/dfasearch.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); void* memset(void*, int, unsigned long); 
/* dfasearch.c - searching subroutines using dfa and regex for grep.
   Copyright 1992, 1998, 2000, 2007, 2009-2010 Free Software Foundation, Inc.

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 3, or (at your option)
   any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program; if not, write to the Free Software
   Foundation, Inc., 51 Franklin Street - Fifth Floor, Boston, MA
   02110-1301, USA.  */

/* Written August 1992 by Mike Haertel. */

#include <config.h>
#include "search.h"
#include "dfa.h"

/* For -w, we also consider _ to be word constituent.  */
#define WCHAR(C) (ISALNUM(C) || (C) == '_')

/* KWset compiled pattern.  For Ecompile and Gcompile, we compile
   a list of strings, at least one of which is known to occur in
   any string matching the regexp. */
static kwset_t kwset;

/* DFA compiled regexp. */
static struct dfa dfa;

/* The Regex compiled patterns.  */
static struct patterns
{
  /* Regex compiled regexp. */
  struct re_pattern_buffer regexbuf;
  struct re_registers regs; /* This is here on account of a BRAIN-DEAD
			       Q@#%!# library interface in regex.c.  */
} patterns0;

struct patterns *patterns;
size_t pcount;

void
dfaerror (char const *mesg)
{
  error (EXIT_TROUBLE, 0, "%s", mesg);

  /* notreached */
  /* Tell static analyzers that this function does not return.  */
  abort ();
}

/* Number of compiled fixed strings known to exactly match the regexp.
   If kwsexec returns < kwset_exact_matches, then we don't need to
   call the regexp matcher at all. */
static int kwset_exact_matches;

static char const *
kwsincr_case (const char *must)
{
  const char *buf;
  size_t n;

  n = strlen (must);
#ifdef MBS_SUPPORT
  if (match_icase && MB_CUR_MAX > 1)
    buf = mbtolower (must, &n);
  else
#endif
    buf = must;
  return kwsincr (kwset, buf, n);
}

/* If the DFA turns out to have some set of fixed strings one of
   which must occur in the match, then we build a kwset matcher
   to find those strings, and thus quickly filter out impossible
   matches. */
static void
kwsmusts (void)
{
  struct dfamust const *dm;
  char const *err;

  if (dfa.musts)
    {
      kwsinit (&kwset);
      /* First, we compile in the substrings known to be exact
	 matches.  The kwset matcher will return the index
	 of the matching string that it chooses. */
      for (dm = dfa.musts; dm; dm = dm->next)
	{
	  if (!dm->exact)
	    continue;
	  ++kwset_exact_matches;
	  if ((err = kwsincr_case (dm->must)) != NULL)
	    error (EXIT_TROUBLE, 0, "%s", err);
	}
      /* Now, we compile the substrings that will require
	 the use of the regexp matcher.  */
      for (dm = dfa.musts; dm; dm = dm->next)
	{
	  if (dm->exact)
	    continue;
	  if ((err = kwsincr_case (dm->must)) != NULL)
	    error (EXIT_TROUBLE, 0, "%s", err);
	}
      if ((err = kwsprep (kwset)) != NULL)
	error (EXIT_TROUBLE, 0, "%s", err);
    }
}

void
GEAcompile (char const *pattern, size_t size, reg_syntax_t syntax_bits)
{
  const char *err;
  const char *p, *sep;
  size_t total = size;
  char *motif;

  if (match_icase)
    syntax_bits |= RE_ICASE;
  re_set_syntax (syntax_bits);
  dfasyntax (syntax_bits, match_icase, eolbyte);

  /* For GNU regex compiler we have to pass the patterns separately to detect
     errors like "[\nallo\n]\n".  The patterns here are "[", "allo" and "]"
     GNU regex should have raise a syntax error.  The same for backref, where
     the backref should have been local to each pattern.  */
  p = pattern;
  do
    {
      size_t len;
      sep = memchr (p, '\n', total);
      if (sep)
	{
	  len = sep - p;
	  sep++;
	  total -= (len + 1);
	}
      else
	{
	  len = total;
	  total = 0;
	}

      patterns = realloc (patterns, (pcount + 1) * sizeof (*patterns));
      if (patterns == NULL)
	error (EXIT_TROUBLE, errno, _("memory exhausted"));
      patterns[pcount] = patterns0;

      if ((err = re_compile_pattern (p, len,
				    &(patterns[pcount].regexbuf))) != NULL)
	error (EXIT_TROUBLE, 0, "%s", err);
      pcount++;

      p = sep;
    } while (sep && total != 0);

  /* In the match_words and match_lines cases, we use a different pattern
     for the DFA matcher that will quickly throw out cases that won't work.
     Then if DFA succeeds we do some hairy stuff using the regex matcher
     to decide whether the match should really count. */
  if (match_words || match_lines)
    {
      static char const line_beg_no_bk[] = "^(";
      static char const line_end_no_bk[] = ")$";
      static char const word_beg_no_bk[] = "(^|[^[:alnum:]_])(";
      static char const word_end_no_bk[] = ")([^[:alnum:]_]|$)";
      static char const line_beg_bk[] = "^\\(";
      static char const line_end_bk[] = "\\)$";
      static char const word_beg_bk[] = "\\(^\\|[^[:alnum:]_]\\)\\(";
      static char const word_end_bk[] = "\\)\\([^[:alnum:]_]\\|$\\)";
      int bk = !(syntax_bits & RE_NO_BK_PARENS);
      char *n = xmalloc (sizeof word_beg_bk - 1 + size + sizeof word_end_bk);

      strcpy (n, match_lines ? (bk ? line_beg_bk : line_beg_no_bk)
			     : (bk ? word_beg_bk : word_beg_no_bk));
      total = strlen(n);
      memcpy (n + total, pattern, size);
      total += size;
      strcpy (n + total, match_lines ? (bk ? line_end_bk : line_end_no_bk)
				     : (bk ? word_end_bk : word_end_no_bk));
      total += strlen (n + total);
      pattern = motif = n;
      size = total;
    }
  else
    motif = NULL;

  dfacomp (pattern, size, &dfa, 1);
  kwsmusts ();

  free(motif);
}

size_t
EGexecute (char const *buf, size_t size, size_t *match_size,
	   char const *start_ptr)
{
  char const *buflim, *beg, *end, *match, *best_match, *mb_start;
  char eol = eolbyte;
  int backref, start, len, best_len;
  struct kwsmatch kwsm;
  size_t i, ret_val;
#ifdef MBS_SUPPORT
  if (MB_CUR_MAX > 1)
    {
      
//Patch 0:
if ((__is_neg(25, &(match_icase), sizeof (match_icase), &(buf), sizeof (buf), &(size), sizeof (size), &(start_ptr), sizeof (start_ptr), &(eolbyte), sizeof (eolbyte), &(mb_start), sizeof (mb_start), &(buflim), sizeof (buflim), &(beg), sizeof (beg), &(end), sizeof (end), &(kwset), sizeof (kwset), &(eol), sizeof (eol), &(match), sizeof (match), &(kwset_exact_matches), sizeof (kwset_exact_matches), &(backref), sizeof (backref), &(best_match), sizeof (best_match), &(best_len), sizeof (best_len), &(i), sizeof (i), &(pcount), sizeof (pcount), &(patterns), sizeof (patterns), &(start), sizeof (start), &(len), sizeof (len), &(match_words), sizeof (match_words), &(match_lines), sizeof (match_lines), &(ret_val), sizeof (ret_val), &(match_size), sizeof (match_size))))
    goto failure;
if (match_icase) {
    char *case_buf = mbtolower(buf, &size);
    if (start_ptr)
        start_ptr = case_buf + (start_ptr - buf);
    buf = case_buf;
}

//CodeSeg 1:
    }
#endif /* MBS_SUPPORT */

  mb_start = buf;
  buflim = buf + size;

  for (beg = end = buf; end < buflim; beg = end)
    {
      if (!start_ptr)
	{
	  /* We don't care about an exact match.  */
	  if (kwset)
	    {
	      /* Find a possible match using the KWset matcher. */
	      size_t offset = kwsexec (kwset, beg, buflim - beg, &kwsm);
	      if (offset == (size_t) -1)
		goto failure;
	      beg += offset;
	      /* Narrow down to the line containing the candidate, and
		 run it through DFA. */
	      if ((end = memchr(beg, eol, buflim - beg)) != NULL)
	        end++;
              else
                end = buflim;
	      match = beg;
	      while (beg > buf && beg[-1] != eol)
		--beg;
	      if (kwsm.index < kwset_exact_matches)
                {
#ifdef MBS_SUPPORT
                  if (mb_start < beg)
                    mb_start = beg;
                  if (MB_CUR_MAX == 1 || !is_mb_middle (&mb_start, match, buflim))
#endif
                    goto success;
                }
	      if (dfaexec (&dfa, beg, (char *) end, 0, NULL, &backref) == NULL)
		continue;
	    }
	  else
	    {
	      /* No good fixed strings; start with DFA. */
	      char const *next_beg = dfaexec (&dfa, beg, (char *) buflim,
					      0, NULL, &backref);
	      if (next_beg == NULL)
		break;
	      /* Narrow down to the line we've found. */
	      beg = next_beg;
	      if ((end = memchr(beg, eol, buflim - beg)) != NULL)
	        end++;
              else
                end = buflim;
	      while (beg > buf && beg[-1] != eol)
		--beg;
	    }
	  /* Successful, no backreferences encountered! */
	  if (!backref)
	    goto success;
	}
      else
	{
	  /* We are looking for the leftmost (then longest) exact match.
	     We will go through the outer loop only once.  */
	  beg = start_ptr;
	  end = buflim;
	}

      /* If we've made it to this point, this means DFA has seen
	 a probable match, and we need to run it through Regex. */
      best_match = end;
      best_len = 0;
      for (i = 0; i < pcount; i++)
	{
	  patterns[i].regexbuf.not_eol = 0;
	  if (0 <= (start = re_search (&(patterns[i].regexbuf),
				       buf, end - buf - 1,
				       beg - buf, end - beg - 1,
				       &(patterns[i].regs))))
	    {
	      len = patterns[i].regs.end[0] - start;
	      match = buf + start;
	      if (match > best_match)
		continue;
	      if (start_ptr && !match_words)
		goto assess_pattern_match;
	      if ((!match_lines && !match_words)
		  || (match_lines && len == end - beg - 1))
		{
		  match = beg;
		  len = end - beg;
		  goto assess_pattern_match;
		}
	      /* If -w, check if the match aligns with word boundaries.
		 We do this iteratively because:
		 (a) the line may contain more than one occurence of the
		 pattern, and
		 (b) Several alternatives in the pattern might be valid at a
		 given point, and we may need to consider a shorter one to
		 find a word boundary.  */
	      if (match_words)
		while (match <= best_match)
		  {
		    if ((match == buf || !WCHAR ((unsigned char) match[-1]))
			&& (len == end - beg - 1
			    || !WCHAR ((unsigned char) match[len])))
		      goto assess_pattern_match;
		    if (len > 0)
		      {
			/* Try a shorter length anchored at the same place. */
			--len;
			patterns[i].regexbuf.not_eol = 1;
			len = re_match (&(patterns[i].regexbuf),
					buf, match + len - beg, match - buf,
					&(patterns[i].regs));
		      }
		    if (len <= 0)
		      {
			/* Try looking further on. */
			if (match == end - 1)
			  break;
			match++;
			patterns[i].regexbuf.not_eol = 0;
			start = re_search (&(patterns[i].regexbuf),
					   buf, end - buf - 1,
					   match - buf, end - match - 1,
					   &(patterns[i].regs));
			if (start < 0)
			  break;
			len = patterns[i].regs.end[0] - start;
			match = buf + start;
		      }
		  } /* while (match <= best_match) */
	      continue;
	    assess_pattern_match:
	      if (!start_ptr)
		{
		  /* Good enough for a non-exact match.
		     No need to look at further patterns, if any.  */
		  beg = match;
		  goto success_in_len;
		}
	      if (match < best_match || (match == best_match && len > best_len))
		{
		  /* Best exact match:  leftmost, then longest.  */
		  best_match = match;
		  best_len = len;
		}
	    } /* if re_search >= 0 */
	} /* for Regex patterns.  */
	if (best_match < end)
	  {
	    /* We have found an exact match.  We were just
	       waiting for the best one (leftmost then longest).  */
	    beg = best_match;
	    len = best_len;
	    goto success_in_len;
	  }
    } /* for (beg = end ..) */

 failure:
  ret_val = -1;
  goto out;

 success:
  len = end - beg;
 success_in_len:
  *match_size = len;
  ret_val = beg - buf;
 out:
  return ret_val;
}

Spawn 1 instances, now Total 89
Counter: 90
Batcher Size:89
Preprocess the following candidate with CondTester:
Priority 8950
At location src/dfasearch.c:214
--Src File: src/dfasearch.c
Fragment 0:
if ((__abst_hole(match_icase, buf, size, start_ptr, eolbyte, mb_start, buflim, beg, end, kwset, eol, match, kwset_exact_matches, backref, best_match, best_len, i, pcount, patterns, start, len, match_words, match_lines, ret_val, match_size)))
    goto success;
if (match_icase) {
    char *case_buf = mbtolower(buf, &size);
    if (start_ptr)
        start_ptr = case_buf + (start_ptr - buf);
    buf = case_buf;
}


CondTester, a patch instance with id 89:
//src_file:src/dfasearch.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); void* memset(void*, int, unsigned long); 
/* dfasearch.c - searching subroutines using dfa and regex for grep.
   Copyright 1992, 1998, 2000, 2007, 2009-2010 Free Software Foundation, Inc.

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 3, or (at your option)
   any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program; if not, write to the Free Software
   Foundation, Inc., 51 Franklin Street - Fifth Floor, Boston, MA
   02110-1301, USA.  */

/* Written August 1992 by Mike Haertel. */

#include <config.h>
#include "search.h"
#include "dfa.h"

/* For -w, we also consider _ to be word constituent.  */
#define WCHAR(C) (ISALNUM(C) || (C) == '_')

/* KWset compiled pattern.  For Ecompile and Gcompile, we compile
   a list of strings, at least one of which is known to occur in
   any string matching the regexp. */
static kwset_t kwset;

/* DFA compiled regexp. */
static struct dfa dfa;

/* The Regex compiled patterns.  */
static struct patterns
{
  /* Regex compiled regexp. */
  struct re_pattern_buffer regexbuf;
  struct re_registers regs; /* This is here on account of a BRAIN-DEAD
			       Q@#%!# library interface in regex.c.  */
} patterns0;

struct patterns *patterns;
size_t pcount;

void
dfaerror (char const *mesg)
{
  error (EXIT_TROUBLE, 0, "%s", mesg);

  /* notreached */
  /* Tell static analyzers that this function does not return.  */
  abort ();
}

/* Number of compiled fixed strings known to exactly match the regexp.
   If kwsexec returns < kwset_exact_matches, then we don't need to
   call the regexp matcher at all. */
static int kwset_exact_matches;

static char const *
kwsincr_case (const char *must)
{
  const char *buf;
  size_t n;

  n = strlen (must);
#ifdef MBS_SUPPORT
  if (match_icase && MB_CUR_MAX > 1)
    buf = mbtolower (must, &n);
  else
#endif
    buf = must;
  return kwsincr (kwset, buf, n);
}

/* If the DFA turns out to have some set of fixed strings one of
   which must occur in the match, then we build a kwset matcher
   to find those strings, and thus quickly filter out impossible
   matches. */
static void
kwsmusts (void)
{
  struct dfamust const *dm;
  char const *err;

  if (dfa.musts)
    {
      kwsinit (&kwset);
      /* First, we compile in the substrings known to be exact
	 matches.  The kwset matcher will return the index
	 of the matching string that it chooses. */
      for (dm = dfa.musts; dm; dm = dm->next)
	{
	  if (!dm->exact)
	    continue;
	  ++kwset_exact_matches;
	  if ((err = kwsincr_case (dm->must)) != NULL)
	    error (EXIT_TROUBLE, 0, "%s", err);
	}
      /* Now, we compile the substrings that will require
	 the use of the regexp matcher.  */
      for (dm = dfa.musts; dm; dm = dm->next)
	{
	  if (dm->exact)
	    continue;
	  if ((err = kwsincr_case (dm->must)) != NULL)
	    error (EXIT_TROUBLE, 0, "%s", err);
	}
      if ((err = kwsprep (kwset)) != NULL)
	error (EXIT_TROUBLE, 0, "%s", err);
    }
}

void
GEAcompile (char const *pattern, size_t size, reg_syntax_t syntax_bits)
{
  const char *err;
  const char *p, *sep;
  size_t total = size;
  char *motif;

  if (match_icase)
    syntax_bits |= RE_ICASE;
  re_set_syntax (syntax_bits);
  dfasyntax (syntax_bits, match_icase, eolbyte);

  /* For GNU regex compiler we have to pass the patterns separately to detect
     errors like "[\nallo\n]\n".  The patterns here are "[", "allo" and "]"
     GNU regex should have raise a syntax error.  The same for backref, where
     the backref should have been local to each pattern.  */
  p = pattern;
  do
    {
      size_t len;
      sep = memchr (p, '\n', total);
      if (sep)
	{
	  len = sep - p;
	  sep++;
	  total -= (len + 1);
	}
      else
	{
	  len = total;
	  total = 0;
	}

      patterns = realloc (patterns, (pcount + 1) * sizeof (*patterns));
      if (patterns == NULL)
	error (EXIT_TROUBLE, errno, _("memory exhausted"));
      patterns[pcount] = patterns0;

      if ((err = re_compile_pattern (p, len,
				    &(patterns[pcount].regexbuf))) != NULL)
	error (EXIT_TROUBLE, 0, "%s", err);
      pcount++;

      p = sep;
    } while (sep && total != 0);

  /* In the match_words and match_lines cases, we use a different pattern
     for the DFA matcher that will quickly throw out cases that won't work.
     Then if DFA succeeds we do some hairy stuff using the regex matcher
     to decide whether the match should really count. */
  if (match_words || match_lines)
    {
      static char const line_beg_no_bk[] = "^(";
      static char const line_end_no_bk[] = ")$";
      static char const word_beg_no_bk[] = "(^|[^[:alnum:]_])(";
      static char const word_end_no_bk[] = ")([^[:alnum:]_]|$)";
      static char const line_beg_bk[] = "^\\(";
      static char const line_end_bk[] = "\\)$";
      static char const word_beg_bk[] = "\\(^\\|[^[:alnum:]_]\\)\\(";
      static char const word_end_bk[] = "\\)\\([^[:alnum:]_]\\|$\\)";
      int bk = !(syntax_bits & RE_NO_BK_PARENS);
      char *n = xmalloc (sizeof word_beg_bk - 1 + size + sizeof word_end_bk);

      strcpy (n, match_lines ? (bk ? line_beg_bk : line_beg_no_bk)
			     : (bk ? word_beg_bk : word_beg_no_bk));
      total = strlen(n);
      memcpy (n + total, pattern, size);
      total += size;
      strcpy (n + total, match_lines ? (bk ? line_end_bk : line_end_no_bk)
				     : (bk ? word_end_bk : word_end_no_bk));
      total += strlen (n + total);
      pattern = motif = n;
      size = total;
    }
  else
    motif = NULL;

  dfacomp (pattern, size, &dfa, 1);
  kwsmusts ();

  free(motif);
}

size_t
EGexecute (char const *buf, size_t size, size_t *match_size,
	   char const *start_ptr)
{
  char const *buflim, *beg, *end, *match, *best_match, *mb_start;
  char eol = eolbyte;
  int backref, start, len, best_len;
  struct kwsmatch kwsm;
  size_t i, ret_val;
#ifdef MBS_SUPPORT
  if (MB_CUR_MAX > 1)
    {
      
//Patch 0:
if ((__is_neg(25, &(match_icase), sizeof (match_icase), &(buf), sizeof (buf), &(size), sizeof (size), &(start_ptr), sizeof (start_ptr), &(eolbyte), sizeof (eolbyte), &(mb_start), sizeof (mb_start), &(buflim), sizeof (buflim), &(beg), sizeof (beg), &(end), sizeof (end), &(kwset), sizeof (kwset), &(eol), sizeof (eol), &(match), sizeof (match), &(kwset_exact_matches), sizeof (kwset_exact_matches), &(backref), sizeof (backref), &(best_match), sizeof (best_match), &(best_len), sizeof (best_len), &(i), sizeof (i), &(pcount), sizeof (pcount), &(patterns), sizeof (patterns), &(start), sizeof (start), &(len), sizeof (len), &(match_words), sizeof (match_words), &(match_lines), sizeof (match_lines), &(ret_val), sizeof (ret_val), &(match_size), sizeof (match_size))))
    goto success;
if (match_icase) {
    char *case_buf = mbtolower(buf, &size);
    if (start_ptr)
        start_ptr = case_buf + (start_ptr - buf);
    buf = case_buf;
}

//CodeSeg 1:
    }
#endif /* MBS_SUPPORT */

  mb_start = buf;
  buflim = buf + size;

  for (beg = end = buf; end < buflim; beg = end)
    {
      if (!start_ptr)
	{
	  /* We don't care about an exact match.  */
	  if (kwset)
	    {
	      /* Find a possible match using the KWset matcher. */
	      size_t offset = kwsexec (kwset, beg, buflim - beg, &kwsm);
	      if (offset == (size_t) -1)
		goto failure;
	      beg += offset;
	      /* Narrow down to the line containing the candidate, and
		 run it through DFA. */
	      if ((end = memchr(beg, eol, buflim - beg)) != NULL)
	        end++;
              else
                end = buflim;
	      match = beg;
	      while (beg > buf && beg[-1] != eol)
		--beg;
	      if (kwsm.index < kwset_exact_matches)
                {
#ifdef MBS_SUPPORT
                  if (mb_start < beg)
                    mb_start = beg;
                  if (MB_CUR_MAX == 1 || !is_mb_middle (&mb_start, match, buflim))
#endif
                    goto success;
                }
	      if (dfaexec (&dfa, beg, (char *) end, 0, NULL, &backref) == NULL)
		continue;
	    }
	  else
	    {
	      /* No good fixed strings; start with DFA. */
	      char const *next_beg = dfaexec (&dfa, beg, (char *) buflim,
					      0, NULL, &backref);
	      if (next_beg == NULL)
		break;
	      /* Narrow down to the line we've found. */
	      beg = next_beg;
	      if ((end = memchr(beg, eol, buflim - beg)) != NULL)
	        end++;
              else
                end = buflim;
	      while (beg > buf && beg[-1] != eol)
		--beg;
	    }
	  /* Successful, no backreferences encountered! */
	  if (!backref)
	    goto success;
	}
      else
	{
	  /* We are looking for the leftmost (then longest) exact match.
	     We will go through the outer loop only once.  */
	  beg = start_ptr;
	  end = buflim;
	}

      /* If we've made it to this point, this means DFA has seen
	 a probable match, and we need to run it through Regex. */
      best_match = end;
      best_len = 0;
      for (i = 0; i < pcount; i++)
	{
	  patterns[i].regexbuf.not_eol = 0;
	  if (0 <= (start = re_search (&(patterns[i].regexbuf),
				       buf, end - buf - 1,
				       beg - buf, end - beg - 1,
				       &(patterns[i].regs))))
	    {
	      len = patterns[i].regs.end[0] - start;
	      match = buf + start;
	      if (match > best_match)
		continue;
	      if (start_ptr && !match_words)
		goto assess_pattern_match;
	      if ((!match_lines && !match_words)
		  || (match_lines && len == end - beg - 1))
		{
		  match = beg;
		  len = end - beg;
		  goto assess_pattern_match;
		}
	      /* If -w, check if the match aligns with word boundaries.
		 We do this iteratively because:
		 (a) the line may contain more than one occurence of the
		 pattern, and
		 (b) Several alternatives in the pattern might be valid at a
		 given point, and we may need to consider a shorter one to
		 find a word boundary.  */
	      if (match_words)
		while (match <= best_match)
		  {
		    if ((match == buf || !WCHAR ((unsigned char) match[-1]))
			&& (len == end - beg - 1
			    || !WCHAR ((unsigned char) match[len])))
		      goto assess_pattern_match;
		    if (len > 0)
		      {
			/* Try a shorter length anchored at the same place. */
			--len;
			patterns[i].regexbuf.not_eol = 1;
			len = re_match (&(patterns[i].regexbuf),
					buf, match + len - beg, match - buf,
					&(patterns[i].regs));
		      }
		    if (len <= 0)
		      {
			/* Try looking further on. */
			if (match == end - 1)
			  break;
			match++;
			patterns[i].regexbuf.not_eol = 0;
			start = re_search (&(patterns[i].regexbuf),
					   buf, end - buf - 1,
					   match - buf, end - match - 1,
					   &(patterns[i].regs));
			if (start < 0)
			  break;
			len = patterns[i].regs.end[0] - start;
			match = buf + start;
		      }
		  } /* while (match <= best_match) */
	      continue;
	    assess_pattern_match:
	      if (!start_ptr)
		{
		  /* Good enough for a non-exact match.
		     No need to look at further patterns, if any.  */
		  beg = match;
		  goto success_in_len;
		}
	      if (match < best_match || (match == best_match && len > best_len))
		{
		  /* Best exact match:  leftmost, then longest.  */
		  best_match = match;
		  best_len = len;
		}
	    } /* if re_search >= 0 */
	} /* for Regex patterns.  */
	if (best_match < end)
	  {
	    /* We have found an exact match.  We were just
	       waiting for the best one (leftmost then longest).  */
	    beg = best_match;
	    len = best_len;
	    goto success_in_len;
	  }
    } /* for (beg = end ..) */

 failure:
  ret_val = -1;
  goto out;

 success:
  len = end - beg;
 success_in_len:
  *match_size = len;
  ret_val = beg - buf;
 out:
  return ret_val;
}

Spawn 1 instances, now Total 90
Counter: 91
Batcher Size:90
Preprocess the following candidate with CondTester:
Priority 8950
At location src/dfasearch.c:214
--Src File: src/dfasearch.c
Fragment 0:
if ((__abst_hole(match_icase, buf, size, start_ptr, eolbyte, mb_start, buflim, beg, end, kwset, eol, match, kwset_exact_matches, backref, best_match, best_len, i, pcount, patterns, start, len, match_words, match_lines, ret_val, match_size)))
    goto success_in_len;
if (match_icase) {
    char *case_buf = mbtolower(buf, &size);
    if (start_ptr)
        start_ptr = case_buf + (start_ptr - buf);
    buf = case_buf;
}


CondTester, a patch instance with id 90:
//src_file:src/dfasearch.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); void* memset(void*, int, unsigned long); 
/* dfasearch.c - searching subroutines using dfa and regex for grep.
   Copyright 1992, 1998, 2000, 2007, 2009-2010 Free Software Foundation, Inc.

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 3, or (at your option)
   any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program; if not, write to the Free Software
   Foundation, Inc., 51 Franklin Street - Fifth Floor, Boston, MA
   02110-1301, USA.  */

/* Written August 1992 by Mike Haertel. */

#include <config.h>
#include "search.h"
#include "dfa.h"

/* For -w, we also consider _ to be word constituent.  */
#define WCHAR(C) (ISALNUM(C) || (C) == '_')

/* KWset compiled pattern.  For Ecompile and Gcompile, we compile
   a list of strings, at least one of which is known to occur in
   any string matching the regexp. */
static kwset_t kwset;

/* DFA compiled regexp. */
static struct dfa dfa;

/* The Regex compiled patterns.  */
static struct patterns
{
  /* Regex compiled regexp. */
  struct re_pattern_buffer regexbuf;
  struct re_registers regs; /* This is here on account of a BRAIN-DEAD
			       Q@#%!# library interface in regex.c.  */
} patterns0;

struct patterns *patterns;
size_t pcount;

void
dfaerror (char const *mesg)
{
  error (EXIT_TROUBLE, 0, "%s", mesg);

  /* notreached */
  /* Tell static analyzers that this function does not return.  */
  abort ();
}

/* Number of compiled fixed strings known to exactly match the regexp.
   If kwsexec returns < kwset_exact_matches, then we don't need to
   call the regexp matcher at all. */
static int kwset_exact_matches;

static char const *
kwsincr_case (const char *must)
{
  const char *buf;
  size_t n;

  n = strlen (must);
#ifdef MBS_SUPPORT
  if (match_icase && MB_CUR_MAX > 1)
    buf = mbtolower (must, &n);
  else
#endif
    buf = must;
  return kwsincr (kwset, buf, n);
}

/* If the DFA turns out to have some set of fixed strings one of
   which must occur in the match, then we build a kwset matcher
   to find those strings, and thus quickly filter out impossible
   matches. */
static void
kwsmusts (void)
{
  struct dfamust const *dm;
  char const *err;

  if (dfa.musts)
    {
      kwsinit (&kwset);
      /* First, we compile in the substrings known to be exact
	 matches.  The kwset matcher will return the index
	 of the matching string that it chooses. */
      for (dm = dfa.musts; dm; dm = dm->next)
	{
	  if (!dm->exact)
	    continue;
	  ++kwset_exact_matches;
	  if ((err = kwsincr_case (dm->must)) != NULL)
	    error (EXIT_TROUBLE, 0, "%s", err);
	}
      /* Now, we compile the substrings that will require
	 the use of the regexp matcher.  */
      for (dm = dfa.musts; dm; dm = dm->next)
	{
	  if (dm->exact)
	    continue;
	  if ((err = kwsincr_case (dm->must)) != NULL)
	    error (EXIT_TROUBLE, 0, "%s", err);
	}
      if ((err = kwsprep (kwset)) != NULL)
	error (EXIT_TROUBLE, 0, "%s", err);
    }
}

void
GEAcompile (char const *pattern, size_t size, reg_syntax_t syntax_bits)
{
  const char *err;
  const char *p, *sep;
  size_t total = size;
  char *motif;

  if (match_icase)
    syntax_bits |= RE_ICASE;
  re_set_syntax (syntax_bits);
  dfasyntax (syntax_bits, match_icase, eolbyte);

  /* For GNU regex compiler we have to pass the patterns separately to detect
     errors like "[\nallo\n]\n".  The patterns here are "[", "allo" and "]"
     GNU regex should have raise a syntax error.  The same for backref, where
     the backref should have been local to each pattern.  */
  p = pattern;
  do
    {
      size_t len;
      sep = memchr (p, '\n', total);
      if (sep)
	{
	  len = sep - p;
	  sep++;
	  total -= (len + 1);
	}
      else
	{
	  len = total;
	  total = 0;
	}

      patterns = realloc (patterns, (pcount + 1) * sizeof (*patterns));
      if (patterns == NULL)
	error (EXIT_TROUBLE, errno, _("memory exhausted"));
      patterns[pcount] = patterns0;

      if ((err = re_compile_pattern (p, len,
				    &(patterns[pcount].regexbuf))) != NULL)
	error (EXIT_TROUBLE, 0, "%s", err);
      pcount++;

      p = sep;
    } while (sep && total != 0);

  /* In the match_words and match_lines cases, we use a different pattern
     for the DFA matcher that will quickly throw out cases that won't work.
     Then if DFA succeeds we do some hairy stuff using the regex matcher
     to decide whether the match should really count. */
  if (match_words || match_lines)
    {
      static char const line_beg_no_bk[] = "^(";
      static char const line_end_no_bk[] = ")$";
      static char const word_beg_no_bk[] = "(^|[^[:alnum:]_])(";
      static char const word_end_no_bk[] = ")([^[:alnum:]_]|$)";
      static char const line_beg_bk[] = "^\\(";
      static char const line_end_bk[] = "\\)$";
      static char const word_beg_bk[] = "\\(^\\|[^[:alnum:]_]\\)\\(";
      static char const word_end_bk[] = "\\)\\([^[:alnum:]_]\\|$\\)";
      int bk = !(syntax_bits & RE_NO_BK_PARENS);
      char *n = xmalloc (sizeof word_beg_bk - 1 + size + sizeof word_end_bk);

      strcpy (n, match_lines ? (bk ? line_beg_bk : line_beg_no_bk)
			     : (bk ? word_beg_bk : word_beg_no_bk));
      total = strlen(n);
      memcpy (n + total, pattern, size);
      total += size;
      strcpy (n + total, match_lines ? (bk ? line_end_bk : line_end_no_bk)
				     : (bk ? word_end_bk : word_end_no_bk));
      total += strlen (n + total);
      pattern = motif = n;
      size = total;
    }
  else
    motif = NULL;

  dfacomp (pattern, size, &dfa, 1);
  kwsmusts ();

  free(motif);
}

size_t
EGexecute (char const *buf, size_t size, size_t *match_size,
	   char const *start_ptr)
{
  char const *buflim, *beg, *end, *match, *best_match, *mb_start;
  char eol = eolbyte;
  int backref, start, len, best_len;
  struct kwsmatch kwsm;
  size_t i, ret_val;
#ifdef MBS_SUPPORT
  if (MB_CUR_MAX > 1)
    {
      
//Patch 0:
if ((__is_neg(25, &(match_icase), sizeof (match_icase), &(buf), sizeof (buf), &(size), sizeof (size), &(start_ptr), sizeof (start_ptr), &(eolbyte), sizeof (eolbyte), &(mb_start), sizeof (mb_start), &(buflim), sizeof (buflim), &(beg), sizeof (beg), &(end), sizeof (end), &(kwset), sizeof (kwset), &(eol), sizeof (eol), &(match), sizeof (match), &(kwset_exact_matches), sizeof (kwset_exact_matches), &(backref), sizeof (backref), &(best_match), sizeof (best_match), &(best_len), sizeof (best_len), &(i), sizeof (i), &(pcount), sizeof (pcount), &(patterns), sizeof (patterns), &(start), sizeof (start), &(len), sizeof (len), &(match_words), sizeof (match_words), &(match_lines), sizeof (match_lines), &(ret_val), sizeof (ret_val), &(match_size), sizeof (match_size))))
    goto success_in_len;
if (match_icase) {
    char *case_buf = mbtolower(buf, &size);
    if (start_ptr)
        start_ptr = case_buf + (start_ptr - buf);
    buf = case_buf;
}

//CodeSeg 1:
    }
#endif /* MBS_SUPPORT */

  mb_start = buf;
  buflim = buf + size;

  for (beg = end = buf; end < buflim; beg = end)
    {
      if (!start_ptr)
	{
	  /* We don't care about an exact match.  */
	  if (kwset)
	    {
	      /* Find a possible match using the KWset matcher. */
	      size_t offset = kwsexec (kwset, beg, buflim - beg, &kwsm);
	      if (offset == (size_t) -1)
		goto failure;
	      beg += offset;
	      /* Narrow down to the line containing the candidate, and
		 run it through DFA. */
	      if ((end = memchr(beg, eol, buflim - beg)) != NULL)
	        end++;
              else
                end = buflim;
	      match = beg;
	      while (beg > buf && beg[-1] != eol)
		--beg;
	      if (kwsm.index < kwset_exact_matches)
                {
#ifdef MBS_SUPPORT
                  if (mb_start < beg)
                    mb_start = beg;
                  if (MB_CUR_MAX == 1 || !is_mb_middle (&mb_start, match, buflim))
#endif
                    goto success;
                }
	      if (dfaexec (&dfa, beg, (char *) end, 0, NULL, &backref) == NULL)
		continue;
	    }
	  else
	    {
	      /* No good fixed strings; start with DFA. */
	      char const *next_beg = dfaexec (&dfa, beg, (char *) buflim,
					      0, NULL, &backref);
	      if (next_beg == NULL)
		break;
	      /* Narrow down to the line we've found. */
	      beg = next_beg;
	      if ((end = memchr(beg, eol, buflim - beg)) != NULL)
	        end++;
              else
                end = buflim;
	      while (beg > buf && beg[-1] != eol)
		--beg;
	    }
	  /* Successful, no backreferences encountered! */
	  if (!backref)
	    goto success;
	}
      else
	{
	  /* We are looking for the leftmost (then longest) exact match.
	     We will go through the outer loop only once.  */
	  beg = start_ptr;
	  end = buflim;
	}

      /* If we've made it to this point, this means DFA has seen
	 a probable match, and we need to run it through Regex. */
      best_match = end;
      best_len = 0;
      for (i = 0; i < pcount; i++)
	{
	  patterns[i].regexbuf.not_eol = 0;
	  if (0 <= (start = re_search (&(patterns[i].regexbuf),
				       buf, end - buf - 1,
				       beg - buf, end - beg - 1,
				       &(patterns[i].regs))))
	    {
	      len = patterns[i].regs.end[0] - start;
	      match = buf + start;
	      if (match > best_match)
		continue;
	      if (start_ptr && !match_words)
		goto assess_pattern_match;
	      if ((!match_lines && !match_words)
		  || (match_lines && len == end - beg - 1))
		{
		  match = beg;
		  len = end - beg;
		  goto assess_pattern_match;
		}
	      /* If -w, check if the match aligns with word boundaries.
		 We do this iteratively because:
		 (a) the line may contain more than one occurence of the
		 pattern, and
		 (b) Several alternatives in the pattern might be valid at a
		 given point, and we may need to consider a shorter one to
		 find a word boundary.  */
	      if (match_words)
		while (match <= best_match)
		  {
		    if ((match == buf || !WCHAR ((unsigned char) match[-1]))
			&& (len == end - beg - 1
			    || !WCHAR ((unsigned char) match[len])))
		      goto assess_pattern_match;
		    if (len > 0)
		      {
			/* Try a shorter length anchored at the same place. */
			--len;
			patterns[i].regexbuf.not_eol = 1;
			len = re_match (&(patterns[i].regexbuf),
					buf, match + len - beg, match - buf,
					&(patterns[i].regs));
		      }
		    if (len <= 0)
		      {
			/* Try looking further on. */
			if (match == end - 1)
			  break;
			match++;
			patterns[i].regexbuf.not_eol = 0;
			start = re_search (&(patterns[i].regexbuf),
					   buf, end - buf - 1,
					   match - buf, end - match - 1,
					   &(patterns[i].regs));
			if (start < 0)
			  break;
			len = patterns[i].regs.end[0] - start;
			match = buf + start;
		      }
		  } /* while (match <= best_match) */
	      continue;
	    assess_pattern_match:
	      if (!start_ptr)
		{
		  /* Good enough for a non-exact match.
		     No need to look at further patterns, if any.  */
		  beg = match;
		  goto success_in_len;
		}
	      if (match < best_match || (match == best_match && len > best_len))
		{
		  /* Best exact match:  leftmost, then longest.  */
		  best_match = match;
		  best_len = len;
		}
	    } /* if re_search >= 0 */
	} /* for Regex patterns.  */
	if (best_match < end)
	  {
	    /* We have found an exact match.  We were just
	       waiting for the best one (leftmost then longest).  */
	    beg = best_match;
	    len = best_len;
	    goto success_in_len;
	  }
    } /* for (beg = end ..) */

 failure:
  ret_val = -1;
  goto out;

 success:
  len = end - beg;
 success_in_len:
  *match_size = len;
  ret_val = beg - buf;
 out:
  return ret_val;
}

Spawn 1 instances, now Total 91
Counter: 92
Batcher Size:91
Preprocess the following candidate with CondTester:
Priority 8950
At location src/dfasearch.c:214
--Src File: src/dfasearch.c
Fragment 0:
if ((__abst_hole(match_icase, buf, size, start_ptr, eolbyte, mb_start, buflim, beg, end, kwset, eol, match, kwset_exact_matches, backref, best_match, best_len, i, pcount, patterns, start, len, match_words, match_lines, ret_val, match_size)))
    goto out;
if (match_icase) {
    char *case_buf = mbtolower(buf, &size);
    if (start_ptr)
        start_ptr = case_buf + (start_ptr - buf);
    buf = case_buf;
}


CondTester, a patch instance with id 91:
//src_file:src/dfasearch.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); void* memset(void*, int, unsigned long); 
/* dfasearch.c - searching subroutines using dfa and regex for grep.
   Copyright 1992, 1998, 2000, 2007, 2009-2010 Free Software Foundation, Inc.

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 3, or (at your option)
   any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program; if not, write to the Free Software
   Foundation, Inc., 51 Franklin Street - Fifth Floor, Boston, MA
   02110-1301, USA.  */

/* Written August 1992 by Mike Haertel. */

#include <config.h>
#include "search.h"
#include "dfa.h"

/* For -w, we also consider _ to be word constituent.  */
#define WCHAR(C) (ISALNUM(C) || (C) == '_')

/* KWset compiled pattern.  For Ecompile and Gcompile, we compile
   a list of strings, at least one of which is known to occur in
   any string matching the regexp. */
static kwset_t kwset;

/* DFA compiled regexp. */
static struct dfa dfa;

/* The Regex compiled patterns.  */
static struct patterns
{
  /* Regex compiled regexp. */
  struct re_pattern_buffer regexbuf;
  struct re_registers regs; /* This is here on account of a BRAIN-DEAD
			       Q@#%!# library interface in regex.c.  */
} patterns0;

struct patterns *patterns;
size_t pcount;

void
dfaerror (char const *mesg)
{
  error (EXIT_TROUBLE, 0, "%s", mesg);

  /* notreached */
  /* Tell static analyzers that this function does not return.  */
  abort ();
}

/* Number of compiled fixed strings known to exactly match the regexp.
   If kwsexec returns < kwset_exact_matches, then we don't need to
   call the regexp matcher at all. */
static int kwset_exact_matches;

static char const *
kwsincr_case (const char *must)
{
  const char *buf;
  size_t n;

  n = strlen (must);
#ifdef MBS_SUPPORT
  if (match_icase && MB_CUR_MAX > 1)
    buf = mbtolower (must, &n);
  else
#endif
    buf = must;
  return kwsincr (kwset, buf, n);
}

/* If the DFA turns out to have some set of fixed strings one of
   which must occur in the match, then we build a kwset matcher
   to find those strings, and thus quickly filter out impossible
   matches. */
static void
kwsmusts (void)
{
  struct dfamust const *dm;
  char const *err;

  if (dfa.musts)
    {
      kwsinit (&kwset);
      /* First, we compile in the substrings known to be exact
	 matches.  The kwset matcher will return the index
	 of the matching string that it chooses. */
      for (dm = dfa.musts; dm; dm = dm->next)
	{
	  if (!dm->exact)
	    continue;
	  ++kwset_exact_matches;
	  if ((err = kwsincr_case (dm->must)) != NULL)
	    error (EXIT_TROUBLE, 0, "%s", err);
	}
      /* Now, we compile the substrings that will require
	 the use of the regexp matcher.  */
      for (dm = dfa.musts; dm; dm = dm->next)
	{
	  if (dm->exact)
	    continue;
	  if ((err = kwsincr_case (dm->must)) != NULL)
	    error (EXIT_TROUBLE, 0, "%s", err);
	}
      if ((err = kwsprep (kwset)) != NULL)
	error (EXIT_TROUBLE, 0, "%s", err);
    }
}

void
GEAcompile (char const *pattern, size_t size, reg_syntax_t syntax_bits)
{
  const char *err;
  const char *p, *sep;
  size_t total = size;
  char *motif;

  if (match_icase)
    syntax_bits |= RE_ICASE;
  re_set_syntax (syntax_bits);
  dfasyntax (syntax_bits, match_icase, eolbyte);

  /* For GNU regex compiler we have to pass the patterns separately to detect
     errors like "[\nallo\n]\n".  The patterns here are "[", "allo" and "]"
     GNU regex should have raise a syntax error.  The same for backref, where
     the backref should have been local to each pattern.  */
  p = pattern;
  do
    {
      size_t len;
      sep = memchr (p, '\n', total);
      if (sep)
	{
	  len = sep - p;
	  sep++;
	  total -= (len + 1);
	}
      else
	{
	  len = total;
	  total = 0;
	}

      patterns = realloc (patterns, (pcount + 1) * sizeof (*patterns));
      if (patterns == NULL)
	error (EXIT_TROUBLE, errno, _("memory exhausted"));
      patterns[pcount] = patterns0;

      if ((err = re_compile_pattern (p, len,
				    &(patterns[pcount].regexbuf))) != NULL)
	error (EXIT_TROUBLE, 0, "%s", err);
      pcount++;

      p = sep;
    } while (sep && total != 0);

  /* In the match_words and match_lines cases, we use a different pattern
     for the DFA matcher that will quickly throw out cases that won't work.
     Then if DFA succeeds we do some hairy stuff using the regex matcher
     to decide whether the match should really count. */
  if (match_words || match_lines)
    {
      static char const line_beg_no_bk[] = "^(";
      static char const line_end_no_bk[] = ")$";
      static char const word_beg_no_bk[] = "(^|[^[:alnum:]_])(";
      static char const word_end_no_bk[] = ")([^[:alnum:]_]|$)";
      static char const line_beg_bk[] = "^\\(";
      static char const line_end_bk[] = "\\)$";
      static char const word_beg_bk[] = "\\(^\\|[^[:alnum:]_]\\)\\(";
      static char const word_end_bk[] = "\\)\\([^[:alnum:]_]\\|$\\)";
      int bk = !(syntax_bits & RE_NO_BK_PARENS);
      char *n = xmalloc (sizeof word_beg_bk - 1 + size + sizeof word_end_bk);

      strcpy (n, match_lines ? (bk ? line_beg_bk : line_beg_no_bk)
			     : (bk ? word_beg_bk : word_beg_no_bk));
      total = strlen(n);
      memcpy (n + total, pattern, size);
      total += size;
      strcpy (n + total, match_lines ? (bk ? line_end_bk : line_end_no_bk)
				     : (bk ? word_end_bk : word_end_no_bk));
      total += strlen (n + total);
      pattern = motif = n;
      size = total;
    }
  else
    motif = NULL;

  dfacomp (pattern, size, &dfa, 1);
  kwsmusts ();

  free(motif);
}

size_t
EGexecute (char const *buf, size_t size, size_t *match_size,
	   char const *start_ptr)
{
  char const *buflim, *beg, *end, *match, *best_match, *mb_start;
  char eol = eolbyte;
  int backref, start, len, best_len;
  struct kwsmatch kwsm;
  size_t i, ret_val;
#ifdef MBS_SUPPORT
  if (MB_CUR_MAX > 1)
    {
      
//Patch 0:
if ((__is_neg(25, &(match_icase), sizeof (match_icase), &(buf), sizeof (buf), &(size), sizeof (size), &(start_ptr), sizeof (start_ptr), &(eolbyte), sizeof (eolbyte), &(mb_start), sizeof (mb_start), &(buflim), sizeof (buflim), &(beg), sizeof (beg), &(end), sizeof (end), &(kwset), sizeof (kwset), &(eol), sizeof (eol), &(match), sizeof (match), &(kwset_exact_matches), sizeof (kwset_exact_matches), &(backref), sizeof (backref), &(best_match), sizeof (best_match), &(best_len), sizeof (best_len), &(i), sizeof (i), &(pcount), sizeof (pcount), &(patterns), sizeof (patterns), &(start), sizeof (start), &(len), sizeof (len), &(match_words), sizeof (match_words), &(match_lines), sizeof (match_lines), &(ret_val), sizeof (ret_val), &(match_size), sizeof (match_size))))
    goto out;
if (match_icase) {
    char *case_buf = mbtolower(buf, &size);
    if (start_ptr)
        start_ptr = case_buf + (start_ptr - buf);
    buf = case_buf;
}

//CodeSeg 1:
    }
#endif /* MBS_SUPPORT */

  mb_start = buf;
  buflim = buf + size;

  for (beg = end = buf; end < buflim; beg = end)
    {
      if (!start_ptr)
	{
	  /* We don't care about an exact match.  */
	  if (kwset)
	    {
	      /* Find a possible match using the KWset matcher. */
	      size_t offset = kwsexec (kwset, beg, buflim - beg, &kwsm);
	      if (offset == (size_t) -1)
		goto failure;
	      beg += offset;
	      /* Narrow down to the line containing the candidate, and
		 run it through DFA. */
	      if ((end = memchr(beg, eol, buflim - beg)) != NULL)
	        end++;
              else
                end = buflim;
	      match = beg;
	      while (beg > buf && beg[-1] != eol)
		--beg;
	      if (kwsm.index < kwset_exact_matches)
                {
#ifdef MBS_SUPPORT
                  if (mb_start < beg)
                    mb_start = beg;
                  if (MB_CUR_MAX == 1 || !is_mb_middle (&mb_start, match, buflim))
#endif
                    goto success;
                }
	      if (dfaexec (&dfa, beg, (char *) end, 0, NULL, &backref) == NULL)
		continue;
	    }
	  else
	    {
	      /* No good fixed strings; start with DFA. */
	      char const *next_beg = dfaexec (&dfa, beg, (char *) buflim,
					      0, NULL, &backref);
	      if (next_beg == NULL)
		break;
	      /* Narrow down to the line we've found. */
	      beg = next_beg;
	      if ((end = memchr(beg, eol, buflim - beg)) != NULL)
	        end++;
              else
                end = buflim;
	      while (beg > buf && beg[-1] != eol)
		--beg;
	    }
	  /* Successful, no backreferences encountered! */
	  if (!backref)
	    goto success;
	}
      else
	{
	  /* We are looking for the leftmost (then longest) exact match.
	     We will go through the outer loop only once.  */
	  beg = start_ptr;
	  end = buflim;
	}

      /* If we've made it to this point, this means DFA has seen
	 a probable match, and we need to run it through Regex. */
      best_match = end;
      best_len = 0;
      for (i = 0; i < pcount; i++)
	{
	  patterns[i].regexbuf.not_eol = 0;
	  if (0 <= (start = re_search (&(patterns[i].regexbuf),
				       buf, end - buf - 1,
				       beg - buf, end - beg - 1,
				       &(patterns[i].regs))))
	    {
	      len = patterns[i].regs.end[0] - start;
	      match = buf + start;
	      if (match > best_match)
		continue;
	      if (start_ptr && !match_words)
		goto assess_pattern_match;
	      if ((!match_lines && !match_words)
		  || (match_lines && len == end - beg - 1))
		{
		  match = beg;
		  len = end - beg;
		  goto assess_pattern_match;
		}
	      /* If -w, check if the match aligns with word boundaries.
		 We do this iteratively because:
		 (a) the line may contain more than one occurence of the
		 pattern, and
		 (b) Several alternatives in the pattern might be valid at a
		 given point, and we may need to consider a shorter one to
		 find a word boundary.  */
	      if (match_words)
		while (match <= best_match)
		  {
		    if ((match == buf || !WCHAR ((unsigned char) match[-1]))
			&& (len == end - beg - 1
			    || !WCHAR ((unsigned char) match[len])))
		      goto assess_pattern_match;
		    if (len > 0)
		      {
			/* Try a shorter length anchored at the same place. */
			--len;
			patterns[i].regexbuf.not_eol = 1;
			len = re_match (&(patterns[i].regexbuf),
					buf, match + len - beg, match - buf,
					&(patterns[i].regs));
		      }
		    if (len <= 0)
		      {
			/* Try looking further on. */
			if (match == end - 1)
			  break;
			match++;
			patterns[i].regexbuf.not_eol = 0;
			start = re_search (&(patterns[i].regexbuf),
					   buf, end - buf - 1,
					   match - buf, end - match - 1,
					   &(patterns[i].regs));
			if (start < 0)
			  break;
			len = patterns[i].regs.end[0] - start;
			match = buf + start;
		      }
		  } /* while (match <= best_match) */
	      continue;
	    assess_pattern_match:
	      if (!start_ptr)
		{
		  /* Good enough for a non-exact match.
		     No need to look at further patterns, if any.  */
		  beg = match;
		  goto success_in_len;
		}
	      if (match < best_match || (match == best_match && len > best_len))
		{
		  /* Best exact match:  leftmost, then longest.  */
		  best_match = match;
		  best_len = len;
		}
	    } /* if re_search >= 0 */
	} /* for Regex patterns.  */
	if (best_match < end)
	  {
	    /* We have found an exact match.  We were just
	       waiting for the best one (leftmost then longest).  */
	    beg = best_match;
	    len = best_len;
	    goto success_in_len;
	  }
    } /* for (beg = end ..) */

 failure:
  ret_val = -1;
  goto out;

 success:
  len = end - beg;
 success_in_len:
  *match_size = len;
  ret_val = beg - buf;
 out:
  return ret_val;
}

Spawn 1 instances, now Total 92
Counter: 93
Batcher Size:92
Preprocess the following candidate with CondTester:
Priority 8946
At location src/dfasearch.c:325
--Src File: src/dfasearch.c
Fragment 0:
if ((__abst_hole(buf, match, beg, end, len, best_match, match_words, i, patterns, match_lines, start_ptr, start, pcount, best_len, buflim, backref, eol, ret_val, match_size, mb_start, kwset_exact_matches, kwset, size, match_icase, eolbyte)))
    goto assess_pattern_match;
if ((match == buf || !((1 && ((*__ctype_b_loc())[(int)(((unsigned char)match[-1]))] & (unsigned short)_ISalnum)) || ((unsigned char)match[-1]) == '_')) && (len == end - beg - 1 || !((1 && ((*__ctype_b_loc())[(int)(((unsigned char)match[len]))] & (unsigned short)_ISalnum)) || ((unsigned char)match[len]) == '_')))
    goto assess_pattern_match;


CondTester, a patch instance with id 92:
//src_file:src/dfasearch.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); void* memset(void*, int, unsigned long); 
/* dfasearch.c - searching subroutines using dfa and regex for grep.
   Copyright 1992, 1998, 2000, 2007, 2009-2010 Free Software Foundation, Inc.

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 3, or (at your option)
   any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program; if not, write to the Free Software
   Foundation, Inc., 51 Franklin Street - Fifth Floor, Boston, MA
   02110-1301, USA.  */

/* Written August 1992 by Mike Haertel. */

#include <config.h>
#include "search.h"
#include "dfa.h"

/* For -w, we also consider _ to be word constituent.  */
#define WCHAR(C) (ISALNUM(C) || (C) == '_')

/* KWset compiled pattern.  For Ecompile and Gcompile, we compile
   a list of strings, at least one of which is known to occur in
   any string matching the regexp. */
static kwset_t kwset;

/* DFA compiled regexp. */
static struct dfa dfa;

/* The Regex compiled patterns.  */
static struct patterns
{
  /* Regex compiled regexp. */
  struct re_pattern_buffer regexbuf;
  struct re_registers regs; /* This is here on account of a BRAIN-DEAD
			       Q@#%!# library interface in regex.c.  */
} patterns0;

struct patterns *patterns;
size_t pcount;

void
dfaerror (char const *mesg)
{
  error (EXIT_TROUBLE, 0, "%s", mesg);

  /* notreached */
  /* Tell static analyzers that this function does not return.  */
  abort ();
}

/* Number of compiled fixed strings known to exactly match the regexp.
   If kwsexec returns < kwset_exact_matches, then we don't need to
   call the regexp matcher at all. */
static int kwset_exact_matches;

static char const *
kwsincr_case (const char *must)
{
  const char *buf;
  size_t n;

  n = strlen (must);
#ifdef MBS_SUPPORT
  if (match_icase && MB_CUR_MAX > 1)
    buf = mbtolower (must, &n);
  else
#endif
    buf = must;
  return kwsincr (kwset, buf, n);
}

/* If the DFA turns out to have some set of fixed strings one of
   which must occur in the match, then we build a kwset matcher
   to find those strings, and thus quickly filter out impossible
   matches. */
static void
kwsmusts (void)
{
  struct dfamust const *dm;
  char const *err;

  if (dfa.musts)
    {
      kwsinit (&kwset);
      /* First, we compile in the substrings known to be exact
	 matches.  The kwset matcher will return the index
	 of the matching string that it chooses. */
      for (dm = dfa.musts; dm; dm = dm->next)
	{
	  if (!dm->exact)
	    continue;
	  ++kwset_exact_matches;
	  if ((err = kwsincr_case (dm->must)) != NULL)
	    error (EXIT_TROUBLE, 0, "%s", err);
	}
      /* Now, we compile the substrings that will require
	 the use of the regexp matcher.  */
      for (dm = dfa.musts; dm; dm = dm->next)
	{
	  if (dm->exact)
	    continue;
	  if ((err = kwsincr_case (dm->must)) != NULL)
	    error (EXIT_TROUBLE, 0, "%s", err);
	}
      if ((err = kwsprep (kwset)) != NULL)
	error (EXIT_TROUBLE, 0, "%s", err);
    }
}

void
GEAcompile (char const *pattern, size_t size, reg_syntax_t syntax_bits)
{
  const char *err;
  const char *p, *sep;
  size_t total = size;
  char *motif;

  if (match_icase)
    syntax_bits |= RE_ICASE;
  re_set_syntax (syntax_bits);
  dfasyntax (syntax_bits, match_icase, eolbyte);

  /* For GNU regex compiler we have to pass the patterns separately to detect
     errors like "[\nallo\n]\n".  The patterns here are "[", "allo" and "]"
     GNU regex should have raise a syntax error.  The same for backref, where
     the backref should have been local to each pattern.  */
  p = pattern;
  do
    {
      size_t len;
      sep = memchr (p, '\n', total);
      if (sep)
	{
	  len = sep - p;
	  sep++;
	  total -= (len + 1);
	}
      else
	{
	  len = total;
	  total = 0;
	}

      patterns = realloc (patterns, (pcount + 1) * sizeof (*patterns));
      if (patterns == NULL)
	error (EXIT_TROUBLE, errno, _("memory exhausted"));
      patterns[pcount] = patterns0;

      if ((err = re_compile_pattern (p, len,
				    &(patterns[pcount].regexbuf))) != NULL)
	error (EXIT_TROUBLE, 0, "%s", err);
      pcount++;

      p = sep;
    } while (sep && total != 0);

  /* In the match_words and match_lines cases, we use a different pattern
     for the DFA matcher that will quickly throw out cases that won't work.
     Then if DFA succeeds we do some hairy stuff using the regex matcher
     to decide whether the match should really count. */
  if (match_words || match_lines)
    {
      static char const line_beg_no_bk[] = "^(";
      static char const line_end_no_bk[] = ")$";
      static char const word_beg_no_bk[] = "(^|[^[:alnum:]_])(";
      static char const word_end_no_bk[] = ")([^[:alnum:]_]|$)";
      static char const line_beg_bk[] = "^\\(";
      static char const line_end_bk[] = "\\)$";
      static char const word_beg_bk[] = "\\(^\\|[^[:alnum:]_]\\)\\(";
      static char const word_end_bk[] = "\\)\\([^[:alnum:]_]\\|$\\)";
      int bk = !(syntax_bits & RE_NO_BK_PARENS);
      char *n = xmalloc (sizeof word_beg_bk - 1 + size + sizeof word_end_bk);

      strcpy (n, match_lines ? (bk ? line_beg_bk : line_beg_no_bk)
			     : (bk ? word_beg_bk : word_beg_no_bk));
      total = strlen(n);
      memcpy (n + total, pattern, size);
      total += size;
      strcpy (n + total, match_lines ? (bk ? line_end_bk : line_end_no_bk)
				     : (bk ? word_end_bk : word_end_no_bk));
      total += strlen (n + total);
      pattern = motif = n;
      size = total;
    }
  else
    motif = NULL;

  dfacomp (pattern, size, &dfa, 1);
  kwsmusts ();

  free(motif);
}

size_t
EGexecute (char const *buf, size_t size, size_t *match_size,
	   char const *start_ptr)
{
  char const *buflim, *beg, *end, *match, *best_match, *mb_start;
  char eol = eolbyte;
  int backref, start, len, best_len;
  struct kwsmatch kwsm;
  size_t i, ret_val;
#ifdef MBS_SUPPORT
  if (MB_CUR_MAX > 1)
    {
      if (match_icase)
        {
          /* mbtolower adds a NUL byte at the end.  That will provide
	     space for the sentinel byte dfaexec may add.  */
          char *case_buf = mbtolower (buf, &size);
	  if (start_ptr)
	    start_ptr = case_buf + (start_ptr - buf);
          buf = case_buf;
        }
    }
#endif /* MBS_SUPPORT */

  mb_start = buf;
  buflim = buf + size;

  for (beg = end = buf; end < buflim; beg = end)
    {
      if (!start_ptr)
	{
	  /* We don't care about an exact match.  */
	  if (kwset)
	    {
	      /* Find a possible match using the KWset matcher. */
	      size_t offset = kwsexec (kwset, beg, buflim - beg, &kwsm);
	      if (offset == (size_t) -1)
		goto failure;
	      beg += offset;
	      /* Narrow down to the line containing the candidate, and
		 run it through DFA. */
	      if ((end = memchr(beg, eol, buflim - beg)) != NULL)
	        end++;
              else
                end = buflim;
	      match = beg;
	      while (beg > buf && beg[-1] != eol)
		--beg;
	      if (kwsm.index < kwset_exact_matches)
                {
#ifdef MBS_SUPPORT
                  if (mb_start < beg)
                    mb_start = beg;
                  if (MB_CUR_MAX == 1 || !is_mb_middle (&mb_start, match, buflim))
#endif
                    goto success;
                }
	      if (dfaexec (&dfa, beg, (char *) end, 0, NULL, &backref) == NULL)
		continue;
	    }
	  else
	    {
	      /* No good fixed strings; start with DFA. */
	      char const *next_beg = dfaexec (&dfa, beg, (char *) buflim,
					      0, NULL, &backref);
	      if (next_beg == NULL)
		break;
	      /* Narrow down to the line we've found. */
	      beg = next_beg;
	      if ((end = memchr(beg, eol, buflim - beg)) != NULL)
	        end++;
              else
                end = buflim;
	      while (beg > buf && beg[-1] != eol)
		--beg;
	    }
	  /* Successful, no backreferences encountered! */
	  if (!backref)
	    goto success;
	}
      else
	{
	  /* We are looking for the leftmost (then longest) exact match.
	     We will go through the outer loop only once.  */
	  beg = start_ptr;
	  end = buflim;
	}

      /* If we've made it to this point, this means DFA has seen
	 a probable match, and we need to run it through Regex. */
      best_match = end;
      best_len = 0;
      for (i = 0; i < pcount; i++)
	{
	  patterns[i].regexbuf.not_eol = 0;
	  if (0 <= (start = re_search (&(patterns[i].regexbuf),
				       buf, end - buf - 1,
				       beg - buf, end - beg - 1,
				       &(patterns[i].regs))))
	    {
	      len = patterns[i].regs.end[0] - start;
	      match = buf + start;
	      if (match > best_match)
		continue;
	      if (start_ptr && !match_words)
		goto assess_pattern_match;
	      if ((!match_lines && !match_words)
		  || (match_lines && len == end - beg - 1))
		{
		  match = beg;
		  len = end - beg;
		  goto assess_pattern_match;
		}
	      /* If -w, check if the match aligns with word boundaries.
		 We do this iteratively because:
		 (a) the line may contain more than one occurence of the
		 pattern, and
		 (b) Several alternatives in the pattern might be valid at a
		 given point, and we may need to consider a shorter one to
		 find a word boundary.  */
	      if (match_words)
		while (match <= best_match)
		  {
		    
//Patch 0:
if ((__is_neg(25, &(buf), sizeof (buf), &(match), sizeof (match), &(beg), sizeof (beg), &(end), sizeof (end), &(len), sizeof (len), &(best_match), sizeof (best_match), &(match_words), sizeof (match_words), &(i), sizeof (i), &(patterns), sizeof (patterns), &(match_lines), sizeof (match_lines), &(start_ptr), sizeof (start_ptr), &(start), sizeof (start), &(pcount), sizeof (pcount), &(best_len), sizeof (best_len), &(buflim), sizeof (buflim), &(backref), sizeof (backref), &(eol), sizeof (eol), &(ret_val), sizeof (ret_val), &(match_size), sizeof (match_size), &(mb_start), sizeof (mb_start), &(kwset_exact_matches), sizeof (kwset_exact_matches), &(kwset), sizeof (kwset), &(size), sizeof (size), &(match_icase), sizeof (match_icase), &(eolbyte), sizeof (eolbyte))))
    goto assess_pattern_match;
if ((match == buf || !((1 && ((*__ctype_b_loc())[(int)(((unsigned char)match[-1]))] & (unsigned short)_ISalnum)) || ((unsigned char)match[-1]) == '_')) && (len == end - beg - 1 || !((1 && ((*__ctype_b_loc())[(int)(((unsigned char)match[len]))] & (unsigned short)_ISalnum)) || ((unsigned char)match[len]) == '_')))
    goto assess_pattern_match;

//CodeSeg 1:
		    if (len > 0)
		      {
			/* Try a shorter length anchored at the same place. */
			--len;
			patterns[i].regexbuf.not_eol = 1;
			len = re_match (&(patterns[i].regexbuf),
					buf, match + len - beg, match - buf,
					&(patterns[i].regs));
		      }
		    if (len <= 0)
		      {
			/* Try looking further on. */
			if (match == end - 1)
			  break;
			match++;
			patterns[i].regexbuf.not_eol = 0;
			start = re_search (&(patterns[i].regexbuf),
					   buf, end - buf - 1,
					   match - buf, end - match - 1,
					   &(patterns[i].regs));
			if (start < 0)
			  break;
			len = patterns[i].regs.end[0] - start;
			match = buf + start;
		      }
		  } /* while (match <= best_match) */
	      continue;
	    assess_pattern_match:
	      if (!start_ptr)
		{
		  /* Good enough for a non-exact match.
		     No need to look at further patterns, if any.  */
		  beg = match;
		  goto success_in_len;
		}
	      if (match < best_match || (match == best_match && len > best_len))
		{
		  /* Best exact match:  leftmost, then longest.  */
		  best_match = match;
		  best_len = len;
		}
	    } /* if re_search >= 0 */
	} /* for Regex patterns.  */
	if (best_match < end)
	  {
	    /* We have found an exact match.  We were just
	       waiting for the best one (leftmost then longest).  */
	    beg = best_match;
	    len = best_len;
	    goto success_in_len;
	  }
    } /* for (beg = end ..) */

 failure:
  ret_val = -1;
  goto out;

 success:
  len = end - beg;
 success_in_len:
  *match_size = len;
  ret_val = beg - buf;
 out:
  return ret_val;
}

Spawn 1 instances, now Total 93
Counter: 94
Batcher Size:93
Preprocess the following candidate with CondTester:
Priority 8946
At location src/dfasearch.c:325
--Src File: src/dfasearch.c
Fragment 0:
if ((__abst_hole(buf, match, beg, end, len, best_match, match_words, i, patterns, match_lines, start_ptr, start, pcount, best_len, buflim, backref, eol, ret_val, match_size, mb_start, kwset_exact_matches, kwset, size, match_icase, eolbyte)))
    goto failure;
if ((match == buf || !((1 && ((*__ctype_b_loc())[(int)(((unsigned char)match[-1]))] & (unsigned short)_ISalnum)) || ((unsigned char)match[-1]) == '_')) && (len == end - beg - 1 || !((1 && ((*__ctype_b_loc())[(int)(((unsigned char)match[len]))] & (unsigned short)_ISalnum)) || ((unsigned char)match[len]) == '_')))
    goto assess_pattern_match;


CondTester, a patch instance with id 93:
//src_file:src/dfasearch.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); void* memset(void*, int, unsigned long); 
/* dfasearch.c - searching subroutines using dfa and regex for grep.
   Copyright 1992, 1998, 2000, 2007, 2009-2010 Free Software Foundation, Inc.

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 3, or (at your option)
   any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program; if not, write to the Free Software
   Foundation, Inc., 51 Franklin Street - Fifth Floor, Boston, MA
   02110-1301, USA.  */

/* Written August 1992 by Mike Haertel. */

#include <config.h>
#include "search.h"
#include "dfa.h"

/* For -w, we also consider _ to be word constituent.  */
#define WCHAR(C) (ISALNUM(C) || (C) == '_')

/* KWset compiled pattern.  For Ecompile and Gcompile, we compile
   a list of strings, at least one of which is known to occur in
   any string matching the regexp. */
static kwset_t kwset;

/* DFA compiled regexp. */
static struct dfa dfa;

/* The Regex compiled patterns.  */
static struct patterns
{
  /* Regex compiled regexp. */
  struct re_pattern_buffer regexbuf;
  struct re_registers regs; /* This is here on account of a BRAIN-DEAD
			       Q@#%!# library interface in regex.c.  */
} patterns0;

struct patterns *patterns;
size_t pcount;

void
dfaerror (char const *mesg)
{
  error (EXIT_TROUBLE, 0, "%s", mesg);

  /* notreached */
  /* Tell static analyzers that this function does not return.  */
  abort ();
}

/* Number of compiled fixed strings known to exactly match the regexp.
   If kwsexec returns < kwset_exact_matches, then we don't need to
   call the regexp matcher at all. */
static int kwset_exact_matches;

static char const *
kwsincr_case (const char *must)
{
  const char *buf;
  size_t n;

  n = strlen (must);
#ifdef MBS_SUPPORT
  if (match_icase && MB_CUR_MAX > 1)
    buf = mbtolower (must, &n);
  else
#endif
    buf = must;
  return kwsincr (kwset, buf, n);
}

/* If the DFA turns out to have some set of fixed strings one of
   which must occur in the match, then we build a kwset matcher
   to find those strings, and thus quickly filter out impossible
   matches. */
static void
kwsmusts (void)
{
  struct dfamust const *dm;
  char const *err;

  if (dfa.musts)
    {
      kwsinit (&kwset);
      /* First, we compile in the substrings known to be exact
	 matches.  The kwset matcher will return the index
	 of the matching string that it chooses. */
      for (dm = dfa.musts; dm; dm = dm->next)
	{
	  if (!dm->exact)
	    continue;
	  ++kwset_exact_matches;
	  if ((err = kwsincr_case (dm->must)) != NULL)
	    error (EXIT_TROUBLE, 0, "%s", err);
	}
      /* Now, we compile the substrings that will require
	 the use of the regexp matcher.  */
      for (dm = dfa.musts; dm; dm = dm->next)
	{
	  if (dm->exact)
	    continue;
	  if ((err = kwsincr_case (dm->must)) != NULL)
	    error (EXIT_TROUBLE, 0, "%s", err);
	}
      if ((err = kwsprep (kwset)) != NULL)
	error (EXIT_TROUBLE, 0, "%s", err);
    }
}

void
GEAcompile (char const *pattern, size_t size, reg_syntax_t syntax_bits)
{
  const char *err;
  const char *p, *sep;
  size_t total = size;
  char *motif;

  if (match_icase)
    syntax_bits |= RE_ICASE;
  re_set_syntax (syntax_bits);
  dfasyntax (syntax_bits, match_icase, eolbyte);

  /* For GNU regex compiler we have to pass the patterns separately to detect
     errors like "[\nallo\n]\n".  The patterns here are "[", "allo" and "]"
     GNU regex should have raise a syntax error.  The same for backref, where
     the backref should have been local to each pattern.  */
  p = pattern;
  do
    {
      size_t len;
      sep = memchr (p, '\n', total);
      if (sep)
	{
	  len = sep - p;
	  sep++;
	  total -= (len + 1);
	}
      else
	{
	  len = total;
	  total = 0;
	}

      patterns = realloc (patterns, (pcount + 1) * sizeof (*patterns));
      if (patterns == NULL)
	error (EXIT_TROUBLE, errno, _("memory exhausted"));
      patterns[pcount] = patterns0;

      if ((err = re_compile_pattern (p, len,
				    &(patterns[pcount].regexbuf))) != NULL)
	error (EXIT_TROUBLE, 0, "%s", err);
      pcount++;

      p = sep;
    } while (sep && total != 0);

  /* In the match_words and match_lines cases, we use a different pattern
     for the DFA matcher that will quickly throw out cases that won't work.
     Then if DFA succeeds we do some hairy stuff using the regex matcher
     to decide whether the match should really count. */
  if (match_words || match_lines)
    {
      static char const line_beg_no_bk[] = "^(";
      static char const line_end_no_bk[] = ")$";
      static char const word_beg_no_bk[] = "(^|[^[:alnum:]_])(";
      static char const word_end_no_bk[] = ")([^[:alnum:]_]|$)";
      static char const line_beg_bk[] = "^\\(";
      static char const line_end_bk[] = "\\)$";
      static char const word_beg_bk[] = "\\(^\\|[^[:alnum:]_]\\)\\(";
      static char const word_end_bk[] = "\\)\\([^[:alnum:]_]\\|$\\)";
      int bk = !(syntax_bits & RE_NO_BK_PARENS);
      char *n = xmalloc (sizeof word_beg_bk - 1 + size + sizeof word_end_bk);

      strcpy (n, match_lines ? (bk ? line_beg_bk : line_beg_no_bk)
			     : (bk ? word_beg_bk : word_beg_no_bk));
      total = strlen(n);
      memcpy (n + total, pattern, size);
      total += size;
      strcpy (n + total, match_lines ? (bk ? line_end_bk : line_end_no_bk)
				     : (bk ? word_end_bk : word_end_no_bk));
      total += strlen (n + total);
      pattern = motif = n;
      size = total;
    }
  else
    motif = NULL;

  dfacomp (pattern, size, &dfa, 1);
  kwsmusts ();

  free(motif);
}

size_t
EGexecute (char const *buf, size_t size, size_t *match_size,
	   char const *start_ptr)
{
  char const *buflim, *beg, *end, *match, *best_match, *mb_start;
  char eol = eolbyte;
  int backref, start, len, best_len;
  struct kwsmatch kwsm;
  size_t i, ret_val;
#ifdef MBS_SUPPORT
  if (MB_CUR_MAX > 1)
    {
      if (match_icase)
        {
          /* mbtolower adds a NUL byte at the end.  That will provide
	     space for the sentinel byte dfaexec may add.  */
          char *case_buf = mbtolower (buf, &size);
	  if (start_ptr)
	    start_ptr = case_buf + (start_ptr - buf);
          buf = case_buf;
        }
    }
#endif /* MBS_SUPPORT */

  mb_start = buf;
  buflim = buf + size;

  for (beg = end = buf; end < buflim; beg = end)
    {
      if (!start_ptr)
	{
	  /* We don't care about an exact match.  */
	  if (kwset)
	    {
	      /* Find a possible match using the KWset matcher. */
	      size_t offset = kwsexec (kwset, beg, buflim - beg, &kwsm);
	      if (offset == (size_t) -1)
		goto failure;
	      beg += offset;
	      /* Narrow down to the line containing the candidate, and
		 run it through DFA. */
	      if ((end = memchr(beg, eol, buflim - beg)) != NULL)
	        end++;
              else
                end = buflim;
	      match = beg;
	      while (beg > buf && beg[-1] != eol)
		--beg;
	      if (kwsm.index < kwset_exact_matches)
                {
#ifdef MBS_SUPPORT
                  if (mb_start < beg)
                    mb_start = beg;
                  if (MB_CUR_MAX == 1 || !is_mb_middle (&mb_start, match, buflim))
#endif
                    goto success;
                }
	      if (dfaexec (&dfa, beg, (char *) end, 0, NULL, &backref) == NULL)
		continue;
	    }
	  else
	    {
	      /* No good fixed strings; start with DFA. */
	      char const *next_beg = dfaexec (&dfa, beg, (char *) buflim,
					      0, NULL, &backref);
	      if (next_beg == NULL)
		break;
	      /* Narrow down to the line we've found. */
	      beg = next_beg;
	      if ((end = memchr(beg, eol, buflim - beg)) != NULL)
	        end++;
              else
                end = buflim;
	      while (beg > buf && beg[-1] != eol)
		--beg;
	    }
	  /* Successful, no backreferences encountered! */
	  if (!backref)
	    goto success;
	}
      else
	{
	  /* We are looking for the leftmost (then longest) exact match.
	     We will go through the outer loop only once.  */
	  beg = start_ptr;
	  end = buflim;
	}

      /* If we've made it to this point, this means DFA has seen
	 a probable match, and we need to run it through Regex. */
      best_match = end;
      best_len = 0;
      for (i = 0; i < pcount; i++)
	{
	  patterns[i].regexbuf.not_eol = 0;
	  if (0 <= (start = re_search (&(patterns[i].regexbuf),
				       buf, end - buf - 1,
				       beg - buf, end - beg - 1,
				       &(patterns[i].regs))))
	    {
	      len = patterns[i].regs.end[0] - start;
	      match = buf + start;
	      if (match > best_match)
		continue;
	      if (start_ptr && !match_words)
		goto assess_pattern_match;
	      if ((!match_lines && !match_words)
		  || (match_lines && len == end - beg - 1))
		{
		  match = beg;
		  len = end - beg;
		  goto assess_pattern_match;
		}
	      /* If -w, check if the match aligns with word boundaries.
		 We do this iteratively because:
		 (a) the line may contain more than one occurence of the
		 pattern, and
		 (b) Several alternatives in the pattern might be valid at a
		 given point, and we may need to consider a shorter one to
		 find a word boundary.  */
	      if (match_words)
		while (match <= best_match)
		  {
		    
//Patch 0:
if ((__is_neg(25, &(buf), sizeof (buf), &(match), sizeof (match), &(beg), sizeof (beg), &(end), sizeof (end), &(len), sizeof (len), &(best_match), sizeof (best_match), &(match_words), sizeof (match_words), &(i), sizeof (i), &(patterns), sizeof (patterns), &(match_lines), sizeof (match_lines), &(start_ptr), sizeof (start_ptr), &(start), sizeof (start), &(pcount), sizeof (pcount), &(best_len), sizeof (best_len), &(buflim), sizeof (buflim), &(backref), sizeof (backref), &(eol), sizeof (eol), &(ret_val), sizeof (ret_val), &(match_size), sizeof (match_size), &(mb_start), sizeof (mb_start), &(kwset_exact_matches), sizeof (kwset_exact_matches), &(kwset), sizeof (kwset), &(size), sizeof (size), &(match_icase), sizeof (match_icase), &(eolbyte), sizeof (eolbyte))))
    goto failure;
if ((match == buf || !((1 && ((*__ctype_b_loc())[(int)(((unsigned char)match[-1]))] & (unsigned short)_ISalnum)) || ((unsigned char)match[-1]) == '_')) && (len == end - beg - 1 || !((1 && ((*__ctype_b_loc())[(int)(((unsigned char)match[len]))] & (unsigned short)_ISalnum)) || ((unsigned char)match[len]) == '_')))
    goto assess_pattern_match;

//CodeSeg 1:
		    if (len > 0)
		      {
			/* Try a shorter length anchored at the same place. */
			--len;
			patterns[i].regexbuf.not_eol = 1;
			len = re_match (&(patterns[i].regexbuf),
					buf, match + len - beg, match - buf,
					&(patterns[i].regs));
		      }
		    if (len <= 0)
		      {
			/* Try looking further on. */
			if (match == end - 1)
			  break;
			match++;
			patterns[i].regexbuf.not_eol = 0;
			start = re_search (&(patterns[i].regexbuf),
					   buf, end - buf - 1,
					   match - buf, end - match - 1,
					   &(patterns[i].regs));
			if (start < 0)
			  break;
			len = patterns[i].regs.end[0] - start;
			match = buf + start;
		      }
		  } /* while (match <= best_match) */
	      continue;
	    assess_pattern_match:
	      if (!start_ptr)
		{
		  /* Good enough for a non-exact match.
		     No need to look at further patterns, if any.  */
		  beg = match;
		  goto success_in_len;
		}
	      if (match < best_match || (match == best_match && len > best_len))
		{
		  /* Best exact match:  leftmost, then longest.  */
		  best_match = match;
		  best_len = len;
		}
	    } /* if re_search >= 0 */
	} /* for Regex patterns.  */
	if (best_match < end)
	  {
	    /* We have found an exact match.  We were just
	       waiting for the best one (leftmost then longest).  */
	    beg = best_match;
	    len = best_len;
	    goto success_in_len;
	  }
    } /* for (beg = end ..) */

 failure:
  ret_val = -1;
  goto out;

 success:
  len = end - beg;
 success_in_len:
  *match_size = len;
  ret_val = beg - buf;
 out:
  return ret_val;
}

Spawn 1 instances, now Total 94
Counter: 95
Batcher Size:94
Preprocess the following candidate with CondTester:
Priority 8946
At location src/dfasearch.c:325
--Src File: src/dfasearch.c
Fragment 0:
if ((__abst_hole(buf, match, beg, end, len, best_match, match_words, i, patterns, match_lines, start_ptr, start, pcount, best_len, buflim, backref, eol, ret_val, match_size, mb_start, kwset_exact_matches, kwset, size, match_icase, eolbyte)))
    goto success;
if ((match == buf || !((1 && ((*__ctype_b_loc())[(int)(((unsigned char)match[-1]))] & (unsigned short)_ISalnum)) || ((unsigned char)match[-1]) == '_')) && (len == end - beg - 1 || !((1 && ((*__ctype_b_loc())[(int)(((unsigned char)match[len]))] & (unsigned short)_ISalnum)) || ((unsigned char)match[len]) == '_')))
    goto assess_pattern_match;


CondTester, a patch instance with id 94:
//src_file:src/dfasearch.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); void* memset(void*, int, unsigned long); 
/* dfasearch.c - searching subroutines using dfa and regex for grep.
   Copyright 1992, 1998, 2000, 2007, 2009-2010 Free Software Foundation, Inc.

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 3, or (at your option)
   any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program; if not, write to the Free Software
   Foundation, Inc., 51 Franklin Street - Fifth Floor, Boston, MA
   02110-1301, USA.  */

/* Written August 1992 by Mike Haertel. */

#include <config.h>
#include "search.h"
#include "dfa.h"

/* For -w, we also consider _ to be word constituent.  */
#define WCHAR(C) (ISALNUM(C) || (C) == '_')

/* KWset compiled pattern.  For Ecompile and Gcompile, we compile
   a list of strings, at least one of which is known to occur in
   any string matching the regexp. */
static kwset_t kwset;

/* DFA compiled regexp. */
static struct dfa dfa;

/* The Regex compiled patterns.  */
static struct patterns
{
  /* Regex compiled regexp. */
  struct re_pattern_buffer regexbuf;
  struct re_registers regs; /* This is here on account of a BRAIN-DEAD
			       Q@#%!# library interface in regex.c.  */
} patterns0;

struct patterns *patterns;
size_t pcount;

void
dfaerror (char const *mesg)
{
  error (EXIT_TROUBLE, 0, "%s", mesg);

  /* notreached */
  /* Tell static analyzers that this function does not return.  */
  abort ();
}

/* Number of compiled fixed strings known to exactly match the regexp.
   If kwsexec returns < kwset_exact_matches, then we don't need to
   call the regexp matcher at all. */
static int kwset_exact_matches;

static char const *
kwsincr_case (const char *must)
{
  const char *buf;
  size_t n;

  n = strlen (must);
#ifdef MBS_SUPPORT
  if (match_icase && MB_CUR_MAX > 1)
    buf = mbtolower (must, &n);
  else
#endif
    buf = must;
  return kwsincr (kwset, buf, n);
}

/* If the DFA turns out to have some set of fixed strings one of
   which must occur in the match, then we build a kwset matcher
   to find those strings, and thus quickly filter out impossible
   matches. */
static void
kwsmusts (void)
{
  struct dfamust const *dm;
  char const *err;

  if (dfa.musts)
    {
      kwsinit (&kwset);
      /* First, we compile in the substrings known to be exact
	 matches.  The kwset matcher will return the index
	 of the matching string that it chooses. */
      for (dm = dfa.musts; dm; dm = dm->next)
	{
	  if (!dm->exact)
	    continue;
	  ++kwset_exact_matches;
	  if ((err = kwsincr_case (dm->must)) != NULL)
	    error (EXIT_TROUBLE, 0, "%s", err);
	}
      /* Now, we compile the substrings that will require
	 the use of the regexp matcher.  */
      for (dm = dfa.musts; dm; dm = dm->next)
	{
	  if (dm->exact)
	    continue;
	  if ((err = kwsincr_case (dm->must)) != NULL)
	    error (EXIT_TROUBLE, 0, "%s", err);
	}
      if ((err = kwsprep (kwset)) != NULL)
	error (EXIT_TROUBLE, 0, "%s", err);
    }
}

void
GEAcompile (char const *pattern, size_t size, reg_syntax_t syntax_bits)
{
  const char *err;
  const char *p, *sep;
  size_t total = size;
  char *motif;

  if (match_icase)
    syntax_bits |= RE_ICASE;
  re_set_syntax (syntax_bits);
  dfasyntax (syntax_bits, match_icase, eolbyte);

  /* For GNU regex compiler we have to pass the patterns separately to detect
     errors like "[\nallo\n]\n".  The patterns here are "[", "allo" and "]"
     GNU regex should have raise a syntax error.  The same for backref, where
     the backref should have been local to each pattern.  */
  p = pattern;
  do
    {
      size_t len;
      sep = memchr (p, '\n', total);
      if (sep)
	{
	  len = sep - p;
	  sep++;
	  total -= (len + 1);
	}
      else
	{
	  len = total;
	  total = 0;
	}

      patterns = realloc (patterns, (pcount + 1) * sizeof (*patterns));
      if (patterns == NULL)
	error (EXIT_TROUBLE, errno, _("memory exhausted"));
      patterns[pcount] = patterns0;

      if ((err = re_compile_pattern (p, len,
				    &(patterns[pcount].regexbuf))) != NULL)
	error (EXIT_TROUBLE, 0, "%s", err);
      pcount++;

      p = sep;
    } while (sep && total != 0);

  /* In the match_words and match_lines cases, we use a different pattern
     for the DFA matcher that will quickly throw out cases that won't work.
     Then if DFA succeeds we do some hairy stuff using the regex matcher
     to decide whether the match should really count. */
  if (match_words || match_lines)
    {
      static char const line_beg_no_bk[] = "^(";
      static char const line_end_no_bk[] = ")$";
      static char const word_beg_no_bk[] = "(^|[^[:alnum:]_])(";
      static char const word_end_no_bk[] = ")([^[:alnum:]_]|$)";
      static char const line_beg_bk[] = "^\\(";
      static char const line_end_bk[] = "\\)$";
      static char const word_beg_bk[] = "\\(^\\|[^[:alnum:]_]\\)\\(";
      static char const word_end_bk[] = "\\)\\([^[:alnum:]_]\\|$\\)";
      int bk = !(syntax_bits & RE_NO_BK_PARENS);
      char *n = xmalloc (sizeof word_beg_bk - 1 + size + sizeof word_end_bk);

      strcpy (n, match_lines ? (bk ? line_beg_bk : line_beg_no_bk)
			     : (bk ? word_beg_bk : word_beg_no_bk));
      total = strlen(n);
      memcpy (n + total, pattern, size);
      total += size;
      strcpy (n + total, match_lines ? (bk ? line_end_bk : line_end_no_bk)
				     : (bk ? word_end_bk : word_end_no_bk));
      total += strlen (n + total);
      pattern = motif = n;
      size = total;
    }
  else
    motif = NULL;

  dfacomp (pattern, size, &dfa, 1);
  kwsmusts ();

  free(motif);
}

size_t
EGexecute (char const *buf, size_t size, size_t *match_size,
	   char const *start_ptr)
{
  char const *buflim, *beg, *end, *match, *best_match, *mb_start;
  char eol = eolbyte;
  int backref, start, len, best_len;
  struct kwsmatch kwsm;
  size_t i, ret_val;
#ifdef MBS_SUPPORT
  if (MB_CUR_MAX > 1)
    {
      if (match_icase)
        {
          /* mbtolower adds a NUL byte at the end.  That will provide
	     space for the sentinel byte dfaexec may add.  */
          char *case_buf = mbtolower (buf, &size);
	  if (start_ptr)
	    start_ptr = case_buf + (start_ptr - buf);
          buf = case_buf;
        }
    }
#endif /* MBS_SUPPORT */

  mb_start = buf;
  buflim = buf + size;

  for (beg = end = buf; end < buflim; beg = end)
    {
      if (!start_ptr)
	{
	  /* We don't care about an exact match.  */
	  if (kwset)
	    {
	      /* Find a possible match using the KWset matcher. */
	      size_t offset = kwsexec (kwset, beg, buflim - beg, &kwsm);
	      if (offset == (size_t) -1)
		goto failure;
	      beg += offset;
	      /* Narrow down to the line containing the candidate, and
		 run it through DFA. */
	      if ((end = memchr(beg, eol, buflim - beg)) != NULL)
	        end++;
              else
                end = buflim;
	      match = beg;
	      while (beg > buf && beg[-1] != eol)
		--beg;
	      if (kwsm.index < kwset_exact_matches)
                {
#ifdef MBS_SUPPORT
                  if (mb_start < beg)
                    mb_start = beg;
                  if (MB_CUR_MAX == 1 || !is_mb_middle (&mb_start, match, buflim))
#endif
                    goto success;
                }
	      if (dfaexec (&dfa, beg, (char *) end, 0, NULL, &backref) == NULL)
		continue;
	    }
	  else
	    {
	      /* No good fixed strings; start with DFA. */
	      char const *next_beg = dfaexec (&dfa, beg, (char *) buflim,
					      0, NULL, &backref);
	      if (next_beg == NULL)
		break;
	      /* Narrow down to the line we've found. */
	      beg = next_beg;
	      if ((end = memchr(beg, eol, buflim - beg)) != NULL)
	        end++;
              else
                end = buflim;
	      while (beg > buf && beg[-1] != eol)
		--beg;
	    }
	  /* Successful, no backreferences encountered! */
	  if (!backref)
	    goto success;
	}
      else
	{
	  /* We are looking for the leftmost (then longest) exact match.
	     We will go through the outer loop only once.  */
	  beg = start_ptr;
	  end = buflim;
	}

      /* If we've made it to this point, this means DFA has seen
	 a probable match, and we need to run it through Regex. */
      best_match = end;
      best_len = 0;
      for (i = 0; i < pcount; i++)
	{
	  patterns[i].regexbuf.not_eol = 0;
	  if (0 <= (start = re_search (&(patterns[i].regexbuf),
				       buf, end - buf - 1,
				       beg - buf, end - beg - 1,
				       &(patterns[i].regs))))
	    {
	      len = patterns[i].regs.end[0] - start;
	      match = buf + start;
	      if (match > best_match)
		continue;
	      if (start_ptr && !match_words)
		goto assess_pattern_match;
	      if ((!match_lines && !match_words)
		  || (match_lines && len == end - beg - 1))
		{
		  match = beg;
		  len = end - beg;
		  goto assess_pattern_match;
		}
	      /* If -w, check if the match aligns with word boundaries.
		 We do this iteratively because:
		 (a) the line may contain more than one occurence of the
		 pattern, and
		 (b) Several alternatives in the pattern might be valid at a
		 given point, and we may need to consider a shorter one to
		 find a word boundary.  */
	      if (match_words)
		while (match <= best_match)
		  {
		    
//Patch 0:
if ((__is_neg(25, &(buf), sizeof (buf), &(match), sizeof (match), &(beg), sizeof (beg), &(end), sizeof (end), &(len), sizeof (len), &(best_match), sizeof (best_match), &(match_words), sizeof (match_words), &(i), sizeof (i), &(patterns), sizeof (patterns), &(match_lines), sizeof (match_lines), &(start_ptr), sizeof (start_ptr), &(start), sizeof (start), &(pcount), sizeof (pcount), &(best_len), sizeof (best_len), &(buflim), sizeof (buflim), &(backref), sizeof (backref), &(eol), sizeof (eol), &(ret_val), sizeof (ret_val), &(match_size), sizeof (match_size), &(mb_start), sizeof (mb_start), &(kwset_exact_matches), sizeof (kwset_exact_matches), &(kwset), sizeof (kwset), &(size), sizeof (size), &(match_icase), sizeof (match_icase), &(eolbyte), sizeof (eolbyte))))
    goto success;
if ((match == buf || !((1 && ((*__ctype_b_loc())[(int)(((unsigned char)match[-1]))] & (unsigned short)_ISalnum)) || ((unsigned char)match[-1]) == '_')) && (len == end - beg - 1 || !((1 && ((*__ctype_b_loc())[(int)(((unsigned char)match[len]))] & (unsigned short)_ISalnum)) || ((unsigned char)match[len]) == '_')))
    goto assess_pattern_match;

//CodeSeg 1:
		    if (len > 0)
		      {
			/* Try a shorter length anchored at the same place. */
			--len;
			patterns[i].regexbuf.not_eol = 1;
			len = re_match (&(patterns[i].regexbuf),
					buf, match + len - beg, match - buf,
					&(patterns[i].regs));
		      }
		    if (len <= 0)
		      {
			/* Try looking further on. */
			if (match == end - 1)
			  break;
			match++;
			patterns[i].regexbuf.not_eol = 0;
			start = re_search (&(patterns[i].regexbuf),
					   buf, end - buf - 1,
					   match - buf, end - match - 1,
					   &(patterns[i].regs));
			if (start < 0)
			  break;
			len = patterns[i].regs.end[0] - start;
			match = buf + start;
		      }
		  } /* while (match <= best_match) */
	      continue;
	    assess_pattern_match:
	      if (!start_ptr)
		{
		  /* Good enough for a non-exact match.
		     No need to look at further patterns, if any.  */
		  beg = match;
		  goto success_in_len;
		}
	      if (match < best_match || (match == best_match && len > best_len))
		{
		  /* Best exact match:  leftmost, then longest.  */
		  best_match = match;
		  best_len = len;
		}
	    } /* if re_search >= 0 */
	} /* for Regex patterns.  */
	if (best_match < end)
	  {
	    /* We have found an exact match.  We were just
	       waiting for the best one (leftmost then longest).  */
	    beg = best_match;
	    len = best_len;
	    goto success_in_len;
	  }
    } /* for (beg = end ..) */

 failure:
  ret_val = -1;
  goto out;

 success:
  len = end - beg;
 success_in_len:
  *match_size = len;
  ret_val = beg - buf;
 out:
  return ret_val;
}

Spawn 1 instances, now Total 95
Counter: 96
Batcher Size:95
Preprocess the following candidate with CondTester:
Priority 8946
At location src/dfasearch.c:325
--Src File: src/dfasearch.c
Fragment 0:
if ((__abst_hole(buf, match, beg, end, len, best_match, match_words, i, patterns, match_lines, start_ptr, start, pcount, best_len, buflim, backref, eol, ret_val, match_size, mb_start, kwset_exact_matches, kwset, size, match_icase, eolbyte)))
    goto success_in_len;
if ((match == buf || !((1 && ((*__ctype_b_loc())[(int)(((unsigned char)match[-1]))] & (unsigned short)_ISalnum)) || ((unsigned char)match[-1]) == '_')) && (len == end - beg - 1 || !((1 && ((*__ctype_b_loc())[(int)(((unsigned char)match[len]))] & (unsigned short)_ISalnum)) || ((unsigned char)match[len]) == '_')))
    goto assess_pattern_match;


CondTester, a patch instance with id 95:
//src_file:src/dfasearch.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); void* memset(void*, int, unsigned long); 
/* dfasearch.c - searching subroutines using dfa and regex for grep.
   Copyright 1992, 1998, 2000, 2007, 2009-2010 Free Software Foundation, Inc.

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 3, or (at your option)
   any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program; if not, write to the Free Software
   Foundation, Inc., 51 Franklin Street - Fifth Floor, Boston, MA
   02110-1301, USA.  */

/* Written August 1992 by Mike Haertel. */

#include <config.h>
#include "search.h"
#include "dfa.h"

/* For -w, we also consider _ to be word constituent.  */
#define WCHAR(C) (ISALNUM(C) || (C) == '_')

/* KWset compiled pattern.  For Ecompile and Gcompile, we compile
   a list of strings, at least one of which is known to occur in
   any string matching the regexp. */
static kwset_t kwset;

/* DFA compiled regexp. */
static struct dfa dfa;

/* The Regex compiled patterns.  */
static struct patterns
{
  /* Regex compiled regexp. */
  struct re_pattern_buffer regexbuf;
  struct re_registers regs; /* This is here on account of a BRAIN-DEAD
			       Q@#%!# library interface in regex.c.  */
} patterns0;

struct patterns *patterns;
size_t pcount;

void
dfaerror (char const *mesg)
{
  error (EXIT_TROUBLE, 0, "%s", mesg);

  /* notreached */
  /* Tell static analyzers that this function does not return.  */
  abort ();
}

/* Number of compiled fixed strings known to exactly match the regexp.
   If kwsexec returns < kwset_exact_matches, then we don't need to
   call the regexp matcher at all. */
static int kwset_exact_matches;

static char const *
kwsincr_case (const char *must)
{
  const char *buf;
  size_t n;

  n = strlen (must);
#ifdef MBS_SUPPORT
  if (match_icase && MB_CUR_MAX > 1)
    buf = mbtolower (must, &n);
  else
#endif
    buf = must;
  return kwsincr (kwset, buf, n);
}

/* If the DFA turns out to have some set of fixed strings one of
   which must occur in the match, then we build a kwset matcher
   to find those strings, and thus quickly filter out impossible
   matches. */
static void
kwsmusts (void)
{
  struct dfamust const *dm;
  char const *err;

  if (dfa.musts)
    {
      kwsinit (&kwset);
      /* First, we compile in the substrings known to be exact
	 matches.  The kwset matcher will return the index
	 of the matching string that it chooses. */
      for (dm = dfa.musts; dm; dm = dm->next)
	{
	  if (!dm->exact)
	    continue;
	  ++kwset_exact_matches;
	  if ((err = kwsincr_case (dm->must)) != NULL)
	    error (EXIT_TROUBLE, 0, "%s", err);
	}
      /* Now, we compile the substrings that will require
	 the use of the regexp matcher.  */
      for (dm = dfa.musts; dm; dm = dm->next)
	{
	  if (dm->exact)
	    continue;
	  if ((err = kwsincr_case (dm->must)) != NULL)
	    error (EXIT_TROUBLE, 0, "%s", err);
	}
      if ((err = kwsprep (kwset)) != NULL)
	error (EXIT_TROUBLE, 0, "%s", err);
    }
}

void
GEAcompile (char const *pattern, size_t size, reg_syntax_t syntax_bits)
{
  const char *err;
  const char *p, *sep;
  size_t total = size;
  char *motif;

  if (match_icase)
    syntax_bits |= RE_ICASE;
  re_set_syntax (syntax_bits);
  dfasyntax (syntax_bits, match_icase, eolbyte);

  /* For GNU regex compiler we have to pass the patterns separately to detect
     errors like "[\nallo\n]\n".  The patterns here are "[", "allo" and "]"
     GNU regex should have raise a syntax error.  The same for backref, where
     the backref should have been local to each pattern.  */
  p = pattern;
  do
    {
      size_t len;
      sep = memchr (p, '\n', total);
      if (sep)
	{
	  len = sep - p;
	  sep++;
	  total -= (len + 1);
	}
      else
	{
	  len = total;
	  total = 0;
	}

      patterns = realloc (patterns, (pcount + 1) * sizeof (*patterns));
      if (patterns == NULL)
	error (EXIT_TROUBLE, errno, _("memory exhausted"));
      patterns[pcount] = patterns0;

      if ((err = re_compile_pattern (p, len,
				    &(patterns[pcount].regexbuf))) != NULL)
	error (EXIT_TROUBLE, 0, "%s", err);
      pcount++;

      p = sep;
    } while (sep && total != 0);

  /* In the match_words and match_lines cases, we use a different pattern
     for the DFA matcher that will quickly throw out cases that won't work.
     Then if DFA succeeds we do some hairy stuff using the regex matcher
     to decide whether the match should really count. */
  if (match_words || match_lines)
    {
      static char const line_beg_no_bk[] = "^(";
      static char const line_end_no_bk[] = ")$";
      static char const word_beg_no_bk[] = "(^|[^[:alnum:]_])(";
      static char const word_end_no_bk[] = ")([^[:alnum:]_]|$)";
      static char const line_beg_bk[] = "^\\(";
      static char const line_end_bk[] = "\\)$";
      static char const word_beg_bk[] = "\\(^\\|[^[:alnum:]_]\\)\\(";
      static char const word_end_bk[] = "\\)\\([^[:alnum:]_]\\|$\\)";
      int bk = !(syntax_bits & RE_NO_BK_PARENS);
      char *n = xmalloc (sizeof word_beg_bk - 1 + size + sizeof word_end_bk);

      strcpy (n, match_lines ? (bk ? line_beg_bk : line_beg_no_bk)
			     : (bk ? word_beg_bk : word_beg_no_bk));
      total = strlen(n);
      memcpy (n + total, pattern, size);
      total += size;
      strcpy (n + total, match_lines ? (bk ? line_end_bk : line_end_no_bk)
				     : (bk ? word_end_bk : word_end_no_bk));
      total += strlen (n + total);
      pattern = motif = n;
      size = total;
    }
  else
    motif = NULL;

  dfacomp (pattern, size, &dfa, 1);
  kwsmusts ();

  free(motif);
}

size_t
EGexecute (char const *buf, size_t size, size_t *match_size,
	   char const *start_ptr)
{
  char const *buflim, *beg, *end, *match, *best_match, *mb_start;
  char eol = eolbyte;
  int backref, start, len, best_len;
  struct kwsmatch kwsm;
  size_t i, ret_val;
#ifdef MBS_SUPPORT
  if (MB_CUR_MAX > 1)
    {
      if (match_icase)
        {
          /* mbtolower adds a NUL byte at the end.  That will provide
	     space for the sentinel byte dfaexec may add.  */
          char *case_buf = mbtolower (buf, &size);
	  if (start_ptr)
	    start_ptr = case_buf + (start_ptr - buf);
          buf = case_buf;
        }
    }
#endif /* MBS_SUPPORT */

  mb_start = buf;
  buflim = buf + size;

  for (beg = end = buf; end < buflim; beg = end)
    {
      if (!start_ptr)
	{
	  /* We don't care about an exact match.  */
	  if (kwset)
	    {
	      /* Find a possible match using the KWset matcher. */
	      size_t offset = kwsexec (kwset, beg, buflim - beg, &kwsm);
	      if (offset == (size_t) -1)
		goto failure;
	      beg += offset;
	      /* Narrow down to the line containing the candidate, and
		 run it through DFA. */
	      if ((end = memchr(beg, eol, buflim - beg)) != NULL)
	        end++;
              else
                end = buflim;
	      match = beg;
	      while (beg > buf && beg[-1] != eol)
		--beg;
	      if (kwsm.index < kwset_exact_matches)
                {
#ifdef MBS_SUPPORT
                  if (mb_start < beg)
                    mb_start = beg;
                  if (MB_CUR_MAX == 1 || !is_mb_middle (&mb_start, match, buflim))
#endif
                    goto success;
                }
	      if (dfaexec (&dfa, beg, (char *) end, 0, NULL, &backref) == NULL)
		continue;
	    }
	  else
	    {
	      /* No good fixed strings; start with DFA. */
	      char const *next_beg = dfaexec (&dfa, beg, (char *) buflim,
					      0, NULL, &backref);
	      if (next_beg == NULL)
		break;
	      /* Narrow down to the line we've found. */
	      beg = next_beg;
	      if ((end = memchr(beg, eol, buflim - beg)) != NULL)
	        end++;
              else
                end = buflim;
	      while (beg > buf && beg[-1] != eol)
		--beg;
	    }
	  /* Successful, no backreferences encountered! */
	  if (!backref)
	    goto success;
	}
      else
	{
	  /* We are looking for the leftmost (then longest) exact match.
	     We will go through the outer loop only once.  */
	  beg = start_ptr;
	  end = buflim;
	}

      /* If we've made it to this point, this means DFA has seen
	 a probable match, and we need to run it through Regex. */
      best_match = end;
      best_len = 0;
      for (i = 0; i < pcount; i++)
	{
	  patterns[i].regexbuf.not_eol = 0;
	  if (0 <= (start = re_search (&(patterns[i].regexbuf),
				       buf, end - buf - 1,
				       beg - buf, end - beg - 1,
				       &(patterns[i].regs))))
	    {
	      len = patterns[i].regs.end[0] - start;
	      match = buf + start;
	      if (match > best_match)
		continue;
	      if (start_ptr && !match_words)
		goto assess_pattern_match;
	      if ((!match_lines && !match_words)
		  || (match_lines && len == end - beg - 1))
		{
		  match = beg;
		  len = end - beg;
		  goto assess_pattern_match;
		}
	      /* If -w, check if the match aligns with word boundaries.
		 We do this iteratively because:
		 (a) the line may contain more than one occurence of the
		 pattern, and
		 (b) Several alternatives in the pattern might be valid at a
		 given point, and we may need to consider a shorter one to
		 find a word boundary.  */
	      if (match_words)
		while (match <= best_match)
		  {
		    
//Patch 0:
if ((__is_neg(25, &(buf), sizeof (buf), &(match), sizeof (match), &(beg), sizeof (beg), &(end), sizeof (end), &(len), sizeof (len), &(best_match), sizeof (best_match), &(match_words), sizeof (match_words), &(i), sizeof (i), &(patterns), sizeof (patterns), &(match_lines), sizeof (match_lines), &(start_ptr), sizeof (start_ptr), &(start), sizeof (start), &(pcount), sizeof (pcount), &(best_len), sizeof (best_len), &(buflim), sizeof (buflim), &(backref), sizeof (backref), &(eol), sizeof (eol), &(ret_val), sizeof (ret_val), &(match_size), sizeof (match_size), &(mb_start), sizeof (mb_start), &(kwset_exact_matches), sizeof (kwset_exact_matches), &(kwset), sizeof (kwset), &(size), sizeof (size), &(match_icase), sizeof (match_icase), &(eolbyte), sizeof (eolbyte))))
    goto success_in_len;
if ((match == buf || !((1 && ((*__ctype_b_loc())[(int)(((unsigned char)match[-1]))] & (unsigned short)_ISalnum)) || ((unsigned char)match[-1]) == '_')) && (len == end - beg - 1 || !((1 && ((*__ctype_b_loc())[(int)(((unsigned char)match[len]))] & (unsigned short)_ISalnum)) || ((unsigned char)match[len]) == '_')))
    goto assess_pattern_match;

//CodeSeg 1:
		    if (len > 0)
		      {
			/* Try a shorter length anchored at the same place. */
			--len;
			patterns[i].regexbuf.not_eol = 1;
			len = re_match (&(patterns[i].regexbuf),
					buf, match + len - beg, match - buf,
					&(patterns[i].regs));
		      }
		    if (len <= 0)
		      {
			/* Try looking further on. */
			if (match == end - 1)
			  break;
			match++;
			patterns[i].regexbuf.not_eol = 0;
			start = re_search (&(patterns[i].regexbuf),
					   buf, end - buf - 1,
					   match - buf, end - match - 1,
					   &(patterns[i].regs));
			if (start < 0)
			  break;
			len = patterns[i].regs.end[0] - start;
			match = buf + start;
		      }
		  } /* while (match <= best_match) */
	      continue;
	    assess_pattern_match:
	      if (!start_ptr)
		{
		  /* Good enough for a non-exact match.
		     No need to look at further patterns, if any.  */
		  beg = match;
		  goto success_in_len;
		}
	      if (match < best_match || (match == best_match && len > best_len))
		{
		  /* Best exact match:  leftmost, then longest.  */
		  best_match = match;
		  best_len = len;
		}
	    } /* if re_search >= 0 */
	} /* for Regex patterns.  */
	if (best_match < end)
	  {
	    /* We have found an exact match.  We were just
	       waiting for the best one (leftmost then longest).  */
	    beg = best_match;
	    len = best_len;
	    goto success_in_len;
	  }
    } /* for (beg = end ..) */

 failure:
  ret_val = -1;
  goto out;

 success:
  len = end - beg;
 success_in_len:
  *match_size = len;
  ret_val = beg - buf;
 out:
  return ret_val;
}

Spawn 1 instances, now Total 96
Counter: 97
Batcher Size:96
Preprocess the following candidate with CondTester:
Priority 8946
At location src/dfasearch.c:325
--Src File: src/dfasearch.c
Fragment 0:
if ((__abst_hole(buf, match, beg, end, len, best_match, match_words, i, patterns, match_lines, start_ptr, start, pcount, best_len, buflim, backref, eol, ret_val, match_size, mb_start, kwset_exact_matches, kwset, size, match_icase, eolbyte)))
    goto out;
if ((match == buf || !((1 && ((*__ctype_b_loc())[(int)(((unsigned char)match[-1]))] & (unsigned short)_ISalnum)) || ((unsigned char)match[-1]) == '_')) && (len == end - beg - 1 || !((1 && ((*__ctype_b_loc())[(int)(((unsigned char)match[len]))] & (unsigned short)_ISalnum)) || ((unsigned char)match[len]) == '_')))
    goto assess_pattern_match;


CondTester, a patch instance with id 96:
//src_file:src/dfasearch.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); void* memset(void*, int, unsigned long); 
/* dfasearch.c - searching subroutines using dfa and regex for grep.
   Copyright 1992, 1998, 2000, 2007, 2009-2010 Free Software Foundation, Inc.

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 3, or (at your option)
   any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program; if not, write to the Free Software
   Foundation, Inc., 51 Franklin Street - Fifth Floor, Boston, MA
   02110-1301, USA.  */

/* Written August 1992 by Mike Haertel. */

#include <config.h>
#include "search.h"
#include "dfa.h"

/* For -w, we also consider _ to be word constituent.  */
#define WCHAR(C) (ISALNUM(C) || (C) == '_')

/* KWset compiled pattern.  For Ecompile and Gcompile, we compile
   a list of strings, at least one of which is known to occur in
   any string matching the regexp. */
static kwset_t kwset;

/* DFA compiled regexp. */
static struct dfa dfa;

/* The Regex compiled patterns.  */
static struct patterns
{
  /* Regex compiled regexp. */
  struct re_pattern_buffer regexbuf;
  struct re_registers regs; /* This is here on account of a BRAIN-DEAD
			       Q@#%!# library interface in regex.c.  */
} patterns0;

struct patterns *patterns;
size_t pcount;

void
dfaerror (char const *mesg)
{
  error (EXIT_TROUBLE, 0, "%s", mesg);

  /* notreached */
  /* Tell static analyzers that this function does not return.  */
  abort ();
}

/* Number of compiled fixed strings known to exactly match the regexp.
   If kwsexec returns < kwset_exact_matches, then we don't need to
   call the regexp matcher at all. */
static int kwset_exact_matches;

static char const *
kwsincr_case (const char *must)
{
  const char *buf;
  size_t n;

  n = strlen (must);
#ifdef MBS_SUPPORT
  if (match_icase && MB_CUR_MAX > 1)
    buf = mbtolower (must, &n);
  else
#endif
    buf = must;
  return kwsincr (kwset, buf, n);
}

/* If the DFA turns out to have some set of fixed strings one of
   which must occur in the match, then we build a kwset matcher
   to find those strings, and thus quickly filter out impossible
   matches. */
static void
kwsmusts (void)
{
  struct dfamust const *dm;
  char const *err;

  if (dfa.musts)
    {
      kwsinit (&kwset);
      /* First, we compile in the substrings known to be exact
	 matches.  The kwset matcher will return the index
	 of the matching string that it chooses. */
      for (dm = dfa.musts; dm; dm = dm->next)
	{
	  if (!dm->exact)
	    continue;
	  ++kwset_exact_matches;
	  if ((err = kwsincr_case (dm->must)) != NULL)
	    error (EXIT_TROUBLE, 0, "%s", err);
	}
      /* Now, we compile the substrings that will require
	 the use of the regexp matcher.  */
      for (dm = dfa.musts; dm; dm = dm->next)
	{
	  if (dm->exact)
	    continue;
	  if ((err = kwsincr_case (dm->must)) != NULL)
	    error (EXIT_TROUBLE, 0, "%s", err);
	}
      if ((err = kwsprep (kwset)) != NULL)
	error (EXIT_TROUBLE, 0, "%s", err);
    }
}

void
GEAcompile (char const *pattern, size_t size, reg_syntax_t syntax_bits)
{
  const char *err;
  const char *p, *sep;
  size_t total = size;
  char *motif;

  if (match_icase)
    syntax_bits |= RE_ICASE;
  re_set_syntax (syntax_bits);
  dfasyntax (syntax_bits, match_icase, eolbyte);

  /* For GNU regex compiler we have to pass the patterns separately to detect
     errors like "[\nallo\n]\n".  The patterns here are "[", "allo" and "]"
     GNU regex should have raise a syntax error.  The same for backref, where
     the backref should have been local to each pattern.  */
  p = pattern;
  do
    {
      size_t len;
      sep = memchr (p, '\n', total);
      if (sep)
	{
	  len = sep - p;
	  sep++;
	  total -= (len + 1);
	}
      else
	{
	  len = total;
	  total = 0;
	}

      patterns = realloc (patterns, (pcount + 1) * sizeof (*patterns));
      if (patterns == NULL)
	error (EXIT_TROUBLE, errno, _("memory exhausted"));
      patterns[pcount] = patterns0;

      if ((err = re_compile_pattern (p, len,
				    &(patterns[pcount].regexbuf))) != NULL)
	error (EXIT_TROUBLE, 0, "%s", err);
      pcount++;

      p = sep;
    } while (sep && total != 0);

  /* In the match_words and match_lines cases, we use a different pattern
     for the DFA matcher that will quickly throw out cases that won't work.
     Then if DFA succeeds we do some hairy stuff using the regex matcher
     to decide whether the match should really count. */
  if (match_words || match_lines)
    {
      static char const line_beg_no_bk[] = "^(";
      static char const line_end_no_bk[] = ")$";
      static char const word_beg_no_bk[] = "(^|[^[:alnum:]_])(";
      static char const word_end_no_bk[] = ")([^[:alnum:]_]|$)";
      static char const line_beg_bk[] = "^\\(";
      static char const line_end_bk[] = "\\)$";
      static char const word_beg_bk[] = "\\(^\\|[^[:alnum:]_]\\)\\(";
      static char const word_end_bk[] = "\\)\\([^[:alnum:]_]\\|$\\)";
      int bk = !(syntax_bits & RE_NO_BK_PARENS);
      char *n = xmalloc (sizeof word_beg_bk - 1 + size + sizeof word_end_bk);

      strcpy (n, match_lines ? (bk ? line_beg_bk : line_beg_no_bk)
			     : (bk ? word_beg_bk : word_beg_no_bk));
      total = strlen(n);
      memcpy (n + total, pattern, size);
      total += size;
      strcpy (n + total, match_lines ? (bk ? line_end_bk : line_end_no_bk)
				     : (bk ? word_end_bk : word_end_no_bk));
      total += strlen (n + total);
      pattern = motif = n;
      size = total;
    }
  else
    motif = NULL;

  dfacomp (pattern, size, &dfa, 1);
  kwsmusts ();

  free(motif);
}

size_t
EGexecute (char const *buf, size_t size, size_t *match_size,
	   char const *start_ptr)
{
  char const *buflim, *beg, *end, *match, *best_match, *mb_start;
  char eol = eolbyte;
  int backref, start, len, best_len;
  struct kwsmatch kwsm;
  size_t i, ret_val;
#ifdef MBS_SUPPORT
  if (MB_CUR_MAX > 1)
    {
      if (match_icase)
        {
          /* mbtolower adds a NUL byte at the end.  That will provide
	     space for the sentinel byte dfaexec may add.  */
          char *case_buf = mbtolower (buf, &size);
	  if (start_ptr)
	    start_ptr = case_buf + (start_ptr - buf);
          buf = case_buf;
        }
    }
#endif /* MBS_SUPPORT */

  mb_start = buf;
  buflim = buf + size;

  for (beg = end = buf; end < buflim; beg = end)
    {
      if (!start_ptr)
	{
	  /* We don't care about an exact match.  */
	  if (kwset)
	    {
	      /* Find a possible match using the KWset matcher. */
	      size_t offset = kwsexec (kwset, beg, buflim - beg, &kwsm);
	      if (offset == (size_t) -1)
		goto failure;
	      beg += offset;
	      /* Narrow down to the line containing the candidate, and
		 run it through DFA. */
	      if ((end = memchr(beg, eol, buflim - beg)) != NULL)
	        end++;
              else
                end = buflim;
	      match = beg;
	      while (beg > buf && beg[-1] != eol)
		--beg;
	      if (kwsm.index < kwset_exact_matches)
                {
#ifdef MBS_SUPPORT
                  if (mb_start < beg)
                    mb_start = beg;
                  if (MB_CUR_MAX == 1 || !is_mb_middle (&mb_start, match, buflim))
#endif
                    goto success;
                }
	      if (dfaexec (&dfa, beg, (char *) end, 0, NULL, &backref) == NULL)
		continue;
	    }
	  else
	    {
	      /* No good fixed strings; start with DFA. */
	      char const *next_beg = dfaexec (&dfa, beg, (char *) buflim,
					      0, NULL, &backref);
	      if (next_beg == NULL)
		break;
	      /* Narrow down to the line we've found. */
	      beg = next_beg;
	      if ((end = memchr(beg, eol, buflim - beg)) != NULL)
	        end++;
              else
                end = buflim;
	      while (beg > buf && beg[-1] != eol)
		--beg;
	    }
	  /* Successful, no backreferences encountered! */
	  if (!backref)
	    goto success;
	}
      else
	{
	  /* We are looking for the leftmost (then longest) exact match.
	     We will go through the outer loop only once.  */
	  beg = start_ptr;
	  end = buflim;
	}

      /* If we've made it to this point, this means DFA has seen
	 a probable match, and we need to run it through Regex. */
      best_match = end;
      best_len = 0;
      for (i = 0; i < pcount; i++)
	{
	  patterns[i].regexbuf.not_eol = 0;
	  if (0 <= (start = re_search (&(patterns[i].regexbuf),
				       buf, end - buf - 1,
				       beg - buf, end - beg - 1,
				       &(patterns[i].regs))))
	    {
	      len = patterns[i].regs.end[0] - start;
	      match = buf + start;
	      if (match > best_match)
		continue;
	      if (start_ptr && !match_words)
		goto assess_pattern_match;
	      if ((!match_lines && !match_words)
		  || (match_lines && len == end - beg - 1))
		{
		  match = beg;
		  len = end - beg;
		  goto assess_pattern_match;
		}
	      /* If -w, check if the match aligns with word boundaries.
		 We do this iteratively because:
		 (a) the line may contain more than one occurence of the
		 pattern, and
		 (b) Several alternatives in the pattern might be valid at a
		 given point, and we may need to consider a shorter one to
		 find a word boundary.  */
	      if (match_words)
		while (match <= best_match)
		  {
		    
//Patch 0:
if ((__is_neg(25, &(buf), sizeof (buf), &(match), sizeof (match), &(beg), sizeof (beg), &(end), sizeof (end), &(len), sizeof (len), &(best_match), sizeof (best_match), &(match_words), sizeof (match_words), &(i), sizeof (i), &(patterns), sizeof (patterns), &(match_lines), sizeof (match_lines), &(start_ptr), sizeof (start_ptr), &(start), sizeof (start), &(pcount), sizeof (pcount), &(best_len), sizeof (best_len), &(buflim), sizeof (buflim), &(backref), sizeof (backref), &(eol), sizeof (eol), &(ret_val), sizeof (ret_val), &(match_size), sizeof (match_size), &(mb_start), sizeof (mb_start), &(kwset_exact_matches), sizeof (kwset_exact_matches), &(kwset), sizeof (kwset), &(size), sizeof (size), &(match_icase), sizeof (match_icase), &(eolbyte), sizeof (eolbyte))))
    goto out;
if ((match == buf || !((1 && ((*__ctype_b_loc())[(int)(((unsigned char)match[-1]))] & (unsigned short)_ISalnum)) || ((unsigned char)match[-1]) == '_')) && (len == end - beg - 1 || !((1 && ((*__ctype_b_loc())[(int)(((unsigned char)match[len]))] & (unsigned short)_ISalnum)) || ((unsigned char)match[len]) == '_')))
    goto assess_pattern_match;

//CodeSeg 1:
		    if (len > 0)
		      {
			/* Try a shorter length anchored at the same place. */
			--len;
			patterns[i].regexbuf.not_eol = 1;
			len = re_match (&(patterns[i].regexbuf),
					buf, match + len - beg, match - buf,
					&(patterns[i].regs));
		      }
		    if (len <= 0)
		      {
			/* Try looking further on. */
			if (match == end - 1)
			  break;
			match++;
			patterns[i].regexbuf.not_eol = 0;
			start = re_search (&(patterns[i].regexbuf),
					   buf, end - buf - 1,
					   match - buf, end - match - 1,
					   &(patterns[i].regs));
			if (start < 0)
			  break;
			len = patterns[i].regs.end[0] - start;
			match = buf + start;
		      }
		  } /* while (match <= best_match) */
	      continue;
	    assess_pattern_match:
	      if (!start_ptr)
		{
		  /* Good enough for a non-exact match.
		     No need to look at further patterns, if any.  */
		  beg = match;
		  goto success_in_len;
		}
	      if (match < best_match || (match == best_match && len > best_len))
		{
		  /* Best exact match:  leftmost, then longest.  */
		  best_match = match;
		  best_len = len;
		}
	    } /* if re_search >= 0 */
	} /* for Regex patterns.  */
	if (best_match < end)
	  {
	    /* We have found an exact match.  We were just
	       waiting for the best one (leftmost then longest).  */
	    beg = best_match;
	    len = best_len;
	    goto success_in_len;
	  }
    } /* for (beg = end ..) */

 failure:
  ret_val = -1;
  goto out;

 success:
  len = end - beg;
 success_in_len:
  *match_size = len;
  ret_val = beg - buf;
 out:
  return ret_val;
}

Spawn 1 instances, now Total 97
Counter: 98
Batcher Size:97
Preprocess the following candidate with CondTester:
Priority 8907
At location src/dfasearch.c:90
--Src File: src/dfasearch.c
Fragment 0:
if ((__abst_hole(dfa.musts, dfa.musts, kwset, dm, kwset_exact_matches, err, dfa.charclasses, dfa.cindex, dfa.calloc, dfa.tokens, dfa.tindex, dfa.talloc, dfa.depth, dfa.nleaves, dfa.nregexps, dfa.mb_cur_max, dfa.nmultibyte_prop, dfa.multibyte_prop, dfa.mbcsets, dfa.nmbcsets, dfa.mbcsets_alloc, dfa.states, dfa.sindex, dfa.salloc, dfa.follows, dfa.searchflag, dfa.tralloc, dfa.trcount, dfa.trans, dfa.realtrans, dfa.fails, dfa.success, dfa.newlines, dfa.charclasses, dfa.cindex, dfa.calloc, dfa.tokens, dfa.tindex, dfa.talloc, dfa.depth, dfa.nleaves, dfa.nregexps, dfa.mb_cur_max, dfa.nmultibyte_prop, dfa.multibyte_prop, dfa.mbcsets, dfa.nmbcsets, dfa.mbcsets_alloc, dfa.states, dfa.sindex, dfa.salloc, dfa.follows, dfa.searchflag, dfa.tralloc, dfa.trcount, dfa.trans, dfa.realtrans, dfa.fails, dfa.success, dfa.newlines)))
    return;
if (dfa.musts) {
    kwsinit(&kwset);
    for (dm = dfa.musts; dm; dm = dm->next) {
        if (!dm->exact)
            continue;
        ++kwset_exact_matches;
        if ((err = kwsincr_case(dm->must)) != ((void *)0))
            error(EXIT_TROUBLE, 0, "%s", err);
    }
    for (dm = dfa.musts; dm; dm = dm->next) {
        if (dm->exact)
            continue;
        if ((err = kwsincr_case(dm->must)) != ((void *)0))
            error(EXIT_TROUBLE, 0, "%s", err);
    }
    if ((err = kwsprep(kwset)) != ((void *)0))
        error(EXIT_TROUBLE, 0, "%s", err);
}


CondTester, a patch instance with id 97:
//src_file:src/dfasearch.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); void* memset(void*, int, unsigned long); 
/* dfasearch.c - searching subroutines using dfa and regex for grep.
   Copyright 1992, 1998, 2000, 2007, 2009-2010 Free Software Foundation, Inc.

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 3, or (at your option)
   any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program; if not, write to the Free Software
   Foundation, Inc., 51 Franklin Street - Fifth Floor, Boston, MA
   02110-1301, USA.  */

/* Written August 1992 by Mike Haertel. */

#include <config.h>
#include "search.h"
#include "dfa.h"

/* For -w, we also consider _ to be word constituent.  */
#define WCHAR(C) (ISALNUM(C) || (C) == '_')

/* KWset compiled pattern.  For Ecompile and Gcompile, we compile
   a list of strings, at least one of which is known to occur in
   any string matching the regexp. */
static kwset_t kwset;

/* DFA compiled regexp. */
static struct dfa dfa;

/* The Regex compiled patterns.  */
static struct patterns
{
  /* Regex compiled regexp. */
  struct re_pattern_buffer regexbuf;
  struct re_registers regs; /* This is here on account of a BRAIN-DEAD
			       Q@#%!# library interface in regex.c.  */
} patterns0;

struct patterns *patterns;
size_t pcount;

void
dfaerror (char const *mesg)
{
  error (EXIT_TROUBLE, 0, "%s", mesg);

  /* notreached */
  /* Tell static analyzers that this function does not return.  */
  abort ();
}

/* Number of compiled fixed strings known to exactly match the regexp.
   If kwsexec returns < kwset_exact_matches, then we don't need to
   call the regexp matcher at all. */
static int kwset_exact_matches;

static char const *
kwsincr_case (const char *must)
{
  const char *buf;
  size_t n;

  n = strlen (must);
#ifdef MBS_SUPPORT
  if (match_icase && MB_CUR_MAX > 1)
    buf = mbtolower (must, &n);
  else
#endif
    buf = must;
  return kwsincr (kwset, buf, n);
}

/* If the DFA turns out to have some set of fixed strings one of
   which must occur in the match, then we build a kwset matcher
   to find those strings, and thus quickly filter out impossible
   matches. */
static void
kwsmusts (void)
{
  struct dfamust const *dm;
  char const *err;

  
//Patch 0:
if ((__is_neg(60, &(dfa.musts), sizeof (dfa.musts), &(dfa.musts), sizeof (dfa.musts), &(kwset), sizeof (kwset), &(dm), sizeof (dm), &(kwset_exact_matches), sizeof (kwset_exact_matches), &(err), sizeof (err), &(dfa.charclasses), sizeof (dfa.charclasses), &(dfa.cindex), sizeof (dfa.cindex), &(dfa.calloc), sizeof (dfa.calloc), &(dfa.tokens), sizeof (dfa.tokens), &(dfa.tindex), sizeof (dfa.tindex), &(dfa.talloc), sizeof (dfa.talloc), &(dfa.depth), sizeof (dfa.depth), &(dfa.nleaves), sizeof (dfa.nleaves), &(dfa.nregexps), sizeof (dfa.nregexps), &(dfa.mb_cur_max), sizeof (dfa.mb_cur_max), &(dfa.nmultibyte_prop), sizeof (dfa.nmultibyte_prop), &(dfa.multibyte_prop), sizeof (dfa.multibyte_prop), &(dfa.mbcsets), sizeof (dfa.mbcsets), &(dfa.nmbcsets), sizeof (dfa.nmbcsets), &(dfa.mbcsets_alloc), sizeof (dfa.mbcsets_alloc), &(dfa.states), sizeof (dfa.states), &(dfa.sindex), sizeof (dfa.sindex), &(dfa.salloc), sizeof (dfa.salloc), &(dfa.follows), sizeof (dfa.follows), &(dfa.searchflag), sizeof (dfa.searchflag), &(dfa.tralloc), sizeof (dfa.tralloc), &(dfa.trcount), sizeof (dfa.trcount), &(dfa.trans), sizeof (dfa.trans), &(dfa.realtrans), sizeof (dfa.realtrans), &(dfa.fails), sizeof (dfa.fails), &(dfa.success), sizeof (dfa.success), &(dfa.newlines), sizeof (dfa.newlines), &(dfa.charclasses), sizeof (dfa.charclasses), &(dfa.cindex), sizeof (dfa.cindex), &(dfa.calloc), sizeof (dfa.calloc), &(dfa.tokens), sizeof (dfa.tokens), &(dfa.tindex), sizeof (dfa.tindex), &(dfa.talloc), sizeof (dfa.talloc), &(dfa.depth), sizeof (dfa.depth), &(dfa.nleaves), sizeof (dfa.nleaves), &(dfa.nregexps), sizeof (dfa.nregexps), &(dfa.mb_cur_max), sizeof (dfa.mb_cur_max), &(dfa.nmultibyte_prop), sizeof (dfa.nmultibyte_prop), &(dfa.multibyte_prop), sizeof (dfa.multibyte_prop), &(dfa.mbcsets), sizeof (dfa.mbcsets), &(dfa.nmbcsets), sizeof (dfa.nmbcsets), &(dfa.mbcsets_alloc), sizeof (dfa.mbcsets_alloc), &(dfa.states), sizeof (dfa.states), &(dfa.sindex), sizeof (dfa.sindex), &(dfa.salloc), sizeof (dfa.salloc), &(dfa.follows), sizeof (dfa.follows), &(dfa.searchflag), sizeof (dfa.searchflag), &(dfa.tralloc), sizeof (dfa.tralloc), &(dfa.trcount), sizeof (dfa.trcount), &(dfa.trans), sizeof (dfa.trans), &(dfa.realtrans), sizeof (dfa.realtrans), &(dfa.fails), sizeof (dfa.fails), &(dfa.success), sizeof (dfa.success), &(dfa.newlines), sizeof (dfa.newlines))))
    return;
if (dfa.musts) {
    kwsinit(&kwset);
    for (dm = dfa.musts; dm; dm = dm->next) {
        if (!dm->exact)
            continue;
        ++kwset_exact_matches;
        if ((err = kwsincr_case(dm->must)) != ((void *)0))
            error(EXIT_TROUBLE, 0, "%s", err);
    }
    for (dm = dfa.musts; dm; dm = dm->next) {
        if (dm->exact)
            continue;
        if ((err = kwsincr_case(dm->must)) != ((void *)0))
            error(EXIT_TROUBLE, 0, "%s", err);
    }
    if ((err = kwsprep(kwset)) != ((void *)0))
        error(EXIT_TROUBLE, 0, "%s", err);
}

//CodeSeg 1:
}

void
GEAcompile (char const *pattern, size_t size, reg_syntax_t syntax_bits)
{
  const char *err;
  const char *p, *sep;
  size_t total = size;
  char *motif;

  if (match_icase)
    syntax_bits |= RE_ICASE;
  re_set_syntax (syntax_bits);
  dfasyntax (syntax_bits, match_icase, eolbyte);

  /* For GNU regex compiler we have to pass the patterns separately to detect
     errors like "[\nallo\n]\n".  The patterns here are "[", "allo" and "]"
     GNU regex should have raise a syntax error.  The same for backref, where
     the backref should have been local to each pattern.  */
  p = pattern;
  do
    {
      size_t len;
      sep = memchr (p, '\n', total);
      if (sep)
	{
	  len = sep - p;
	  sep++;
	  total -= (len + 1);
	}
      else
	{
	  len = total;
	  total = 0;
	}

      patterns = realloc (patterns, (pcount + 1) * sizeof (*patterns));
      if (patterns == NULL)
	error (EXIT_TROUBLE, errno, _("memory exhausted"));
      patterns[pcount] = patterns0;

      if ((err = re_compile_pattern (p, len,
				    &(patterns[pcount].regexbuf))) != NULL)
	error (EXIT_TROUBLE, 0, "%s", err);
      pcount++;

      p = sep;
    } while (sep && total != 0);

  /* In the match_words and match_lines cases, we use a different pattern
     for the DFA matcher that will quickly throw out cases that won't work.
     Then if DFA succeeds we do some hairy stuff using the regex matcher
     to decide whether the match should really count. */
  if (match_words || match_lines)
    {
      static char const line_beg_no_bk[] = "^(";
      static char const line_end_no_bk[] = ")$";
      static char const word_beg_no_bk[] = "(^|[^[:alnum:]_])(";
      static char const word_end_no_bk[] = ")([^[:alnum:]_]|$)";
      static char const line_beg_bk[] = "^\\(";
      static char const line_end_bk[] = "\\)$";
      static char const word_beg_bk[] = "\\(^\\|[^[:alnum:]_]\\)\\(";
      static char const word_end_bk[] = "\\)\\([^[:alnum:]_]\\|$\\)";
      int bk = !(syntax_bits & RE_NO_BK_PARENS);
      char *n = xmalloc (sizeof word_beg_bk - 1 + size + sizeof word_end_bk);

      strcpy (n, match_lines ? (bk ? line_beg_bk : line_beg_no_bk)
			     : (bk ? word_beg_bk : word_beg_no_bk));
      total = strlen(n);
      memcpy (n + total, pattern, size);
      total += size;
      strcpy (n + total, match_lines ? (bk ? line_end_bk : line_end_no_bk)
				     : (bk ? word_end_bk : word_end_no_bk));
      total += strlen (n + total);
      pattern = motif = n;
      size = total;
    }
  else
    motif = NULL;

  dfacomp (pattern, size, &dfa, 1);
  kwsmusts ();

  free(motif);
}

size_t
EGexecute (char const *buf, size_t size, size_t *match_size,
	   char const *start_ptr)
{
  char const *buflim, *beg, *end, *match, *best_match, *mb_start;
  char eol = eolbyte;
  int backref, start, len, best_len;
  struct kwsmatch kwsm;
  size_t i, ret_val;
#ifdef MBS_SUPPORT
  if (MB_CUR_MAX > 1)
    {
      if (match_icase)
        {
          /* mbtolower adds a NUL byte at the end.  That will provide
	     space for the sentinel byte dfaexec may add.  */
          char *case_buf = mbtolower (buf, &size);
	  if (start_ptr)
	    start_ptr = case_buf + (start_ptr - buf);
          buf = case_buf;
        }
    }
#endif /* MBS_SUPPORT */

  mb_start = buf;
  buflim = buf + size;

  for (beg = end = buf; end < buflim; beg = end)
    {
      if (!start_ptr)
	{
	  /* We don't care about an exact match.  */
	  if (kwset)
	    {
	      /* Find a possible match using the KWset matcher. */
	      size_t offset = kwsexec (kwset, beg, buflim - beg, &kwsm);
	      if (offset == (size_t) -1)
		goto failure;
	      beg += offset;
	      /* Narrow down to the line containing the candidate, and
		 run it through DFA. */
	      if ((end = memchr(beg, eol, buflim - beg)) != NULL)
	        end++;
              else
                end = buflim;
	      match = beg;
	      while (beg > buf && beg[-1] != eol)
		--beg;
	      if (kwsm.index < kwset_exact_matches)
                {
#ifdef MBS_SUPPORT
                  if (mb_start < beg)
                    mb_start = beg;
                  if (MB_CUR_MAX == 1 || !is_mb_middle (&mb_start, match, buflim))
#endif
                    goto success;
                }
	      if (dfaexec (&dfa, beg, (char *) end, 0, NULL, &backref) == NULL)
		continue;
	    }
	  else
	    {
	      /* No good fixed strings; start with DFA. */
	      char const *next_beg = dfaexec (&dfa, beg, (char *) buflim,
					      0, NULL, &backref);
	      if (next_beg == NULL)
		break;
	      /* Narrow down to the line we've found. */
	      beg = next_beg;
	      if ((end = memchr(beg, eol, buflim - beg)) != NULL)
	        end++;
              else
                end = buflim;
	      while (beg > buf && beg[-1] != eol)
		--beg;
	    }
	  /* Successful, no backreferences encountered! */
	  if (!backref)
	    goto success;
	}
      else
	{
	  /* We are looking for the leftmost (then longest) exact match.
	     We will go through the outer loop only once.  */
	  beg = start_ptr;
	  end = buflim;
	}

      /* If we've made it to this point, this means DFA has seen
	 a probable match, and we need to run it through Regex. */
      best_match = end;
      best_len = 0;
      for (i = 0; i < pcount; i++)
	{
	  patterns[i].regexbuf.not_eol = 0;
	  if (0 <= (start = re_search (&(patterns[i].regexbuf),
				       buf, end - buf - 1,
				       beg - buf, end - beg - 1,
				       &(patterns[i].regs))))
	    {
	      len = patterns[i].regs.end[0] - start;
	      match = buf + start;
	      if (match > best_match)
		continue;
	      if (start_ptr && !match_words)
		goto assess_pattern_match;
	      if ((!match_lines && !match_words)
		  || (match_lines && len == end - beg - 1))
		{
		  match = beg;
		  len = end - beg;
		  goto assess_pattern_match;
		}
	      /* If -w, check if the match aligns with word boundaries.
		 We do this iteratively because:
		 (a) the line may contain more than one occurence of the
		 pattern, and
		 (b) Several alternatives in the pattern might be valid at a
		 given point, and we may need to consider a shorter one to
		 find a word boundary.  */
	      if (match_words)
		while (match <= best_match)
		  {
		    if ((match == buf || !WCHAR ((unsigned char) match[-1]))
			&& (len == end - beg - 1
			    || !WCHAR ((unsigned char) match[len])))
		      goto assess_pattern_match;
		    if (len > 0)
		      {
			/* Try a shorter length anchored at the same place. */
			--len;
			patterns[i].regexbuf.not_eol = 1;
			len = re_match (&(patterns[i].regexbuf),
					buf, match + len - beg, match - buf,
					&(patterns[i].regs));
		      }
		    if (len <= 0)
		      {
			/* Try looking further on. */
			if (match == end - 1)
			  break;
			match++;
			patterns[i].regexbuf.not_eol = 0;
			start = re_search (&(patterns[i].regexbuf),
					   buf, end - buf - 1,
					   match - buf, end - match - 1,
					   &(patterns[i].regs));
			if (start < 0)
			  break;
			len = patterns[i].regs.end[0] - start;
			match = buf + start;
		      }
		  } /* while (match <= best_match) */
	      continue;
	    assess_pattern_match:
	      if (!start_ptr)
		{
		  /* Good enough for a non-exact match.
		     No need to look at further patterns, if any.  */
		  beg = match;
		  goto success_in_len;
		}
	      if (match < best_match || (match == best_match && len > best_len))
		{
		  /* Best exact match:  leftmost, then longest.  */
		  best_match = match;
		  best_len = len;
		}
	    } /* if re_search >= 0 */
	} /* for Regex patterns.  */
	if (best_match < end)
	  {
	    /* We have found an exact match.  We were just
	       waiting for the best one (leftmost then longest).  */
	    beg = best_match;
	    len = best_len;
	    goto success_in_len;
	  }
    } /* for (beg = end ..) */

 failure:
  ret_val = -1;
  goto out;

 success:
  len = end - beg;
 success_in_len:
  *match_size = len;
  ret_val = beg - buf;
 out:
  return ret_val;
}

Spawn 1 instances, now Total 98
Counter: 99
Batcher Size:98
Preprocess the following candidate with CondTester:
Priority 8750
At location src/dfasearch.c:214
--Src File: src/dfasearch.c
Fragment 0:
if ((__abst_hole(match_icase, buf, size, start_ptr, eolbyte, mb_start, buflim, beg, end, kwset, eol, match, kwset_exact_matches, backref, best_match, best_len, i, pcount, patterns, start, len, match_words, match_lines, ret_val, match_size)))
    return -1;
if (match_icase) {
    char *case_buf = mbtolower(buf, &size);
    if (start_ptr)
        start_ptr = case_buf + (start_ptr - buf);
    buf = case_buf;
}


CondTester, a patch instance with id 98:
//src_file:src/dfasearch.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); void* memset(void*, int, unsigned long); 
/* dfasearch.c - searching subroutines using dfa and regex for grep.
   Copyright 1992, 1998, 2000, 2007, 2009-2010 Free Software Foundation, Inc.

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 3, or (at your option)
   any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program; if not, write to the Free Software
   Foundation, Inc., 51 Franklin Street - Fifth Floor, Boston, MA
   02110-1301, USA.  */

/* Written August 1992 by Mike Haertel. */

#include <config.h>
#include "search.h"
#include "dfa.h"

/* For -w, we also consider _ to be word constituent.  */
#define WCHAR(C) (ISALNUM(C) || (C) == '_')

/* KWset compiled pattern.  For Ecompile and Gcompile, we compile
   a list of strings, at least one of which is known to occur in
   any string matching the regexp. */
static kwset_t kwset;

/* DFA compiled regexp. */
static struct dfa dfa;

/* The Regex compiled patterns.  */
static struct patterns
{
  /* Regex compiled regexp. */
  struct re_pattern_buffer regexbuf;
  struct re_registers regs; /* This is here on account of a BRAIN-DEAD
			       Q@#%!# library interface in regex.c.  */
} patterns0;

struct patterns *patterns;
size_t pcount;

void
dfaerror (char const *mesg)
{
  error (EXIT_TROUBLE, 0, "%s", mesg);

  /* notreached */
  /* Tell static analyzers that this function does not return.  */
  abort ();
}

/* Number of compiled fixed strings known to exactly match the regexp.
   If kwsexec returns < kwset_exact_matches, then we don't need to
   call the regexp matcher at all. */
static int kwset_exact_matches;

static char const *
kwsincr_case (const char *must)
{
  const char *buf;
  size_t n;

  n = strlen (must);
#ifdef MBS_SUPPORT
  if (match_icase && MB_CUR_MAX > 1)
    buf = mbtolower (must, &n);
  else
#endif
    buf = must;
  return kwsincr (kwset, buf, n);
}

/* If the DFA turns out to have some set of fixed strings one of
   which must occur in the match, then we build a kwset matcher
   to find those strings, and thus quickly filter out impossible
   matches. */
static void
kwsmusts (void)
{
  struct dfamust const *dm;
  char const *err;

  if (dfa.musts)
    {
      kwsinit (&kwset);
      /* First, we compile in the substrings known to be exact
	 matches.  The kwset matcher will return the index
	 of the matching string that it chooses. */
      for (dm = dfa.musts; dm; dm = dm->next)
	{
	  if (!dm->exact)
	    continue;
	  ++kwset_exact_matches;
	  if ((err = kwsincr_case (dm->must)) != NULL)
	    error (EXIT_TROUBLE, 0, "%s", err);
	}
      /* Now, we compile the substrings that will require
	 the use of the regexp matcher.  */
      for (dm = dfa.musts; dm; dm = dm->next)
	{
	  if (dm->exact)
	    continue;
	  if ((err = kwsincr_case (dm->must)) != NULL)
	    error (EXIT_TROUBLE, 0, "%s", err);
	}
      if ((err = kwsprep (kwset)) != NULL)
	error (EXIT_TROUBLE, 0, "%s", err);
    }
}

void
GEAcompile (char const *pattern, size_t size, reg_syntax_t syntax_bits)
{
  const char *err;
  const char *p, *sep;
  size_t total = size;
  char *motif;

  if (match_icase)
    syntax_bits |= RE_ICASE;
  re_set_syntax (syntax_bits);
  dfasyntax (syntax_bits, match_icase, eolbyte);

  /* For GNU regex compiler we have to pass the patterns separately to detect
     errors like "[\nallo\n]\n".  The patterns here are "[", "allo" and "]"
     GNU regex should have raise a syntax error.  The same for backref, where
     the backref should have been local to each pattern.  */
  p = pattern;
  do
    {
      size_t len;
      sep = memchr (p, '\n', total);
      if (sep)
	{
	  len = sep - p;
	  sep++;
	  total -= (len + 1);
	}
      else
	{
	  len = total;
	  total = 0;
	}

      patterns = realloc (patterns, (pcount + 1) * sizeof (*patterns));
      if (patterns == NULL)
	error (EXIT_TROUBLE, errno, _("memory exhausted"));
      patterns[pcount] = patterns0;

      if ((err = re_compile_pattern (p, len,
				    &(patterns[pcount].regexbuf))) != NULL)
	error (EXIT_TROUBLE, 0, "%s", err);
      pcount++;

      p = sep;
    } while (sep && total != 0);

  /* In the match_words and match_lines cases, we use a different pattern
     for the DFA matcher that will quickly throw out cases that won't work.
     Then if DFA succeeds we do some hairy stuff using the regex matcher
     to decide whether the match should really count. */
  if (match_words || match_lines)
    {
      static char const line_beg_no_bk[] = "^(";
      static char const line_end_no_bk[] = ")$";
      static char const word_beg_no_bk[] = "(^|[^[:alnum:]_])(";
      static char const word_end_no_bk[] = ")([^[:alnum:]_]|$)";
      static char const line_beg_bk[] = "^\\(";
      static char const line_end_bk[] = "\\)$";
      static char const word_beg_bk[] = "\\(^\\|[^[:alnum:]_]\\)\\(";
      static char const word_end_bk[] = "\\)\\([^[:alnum:]_]\\|$\\)";
      int bk = !(syntax_bits & RE_NO_BK_PARENS);
      char *n = xmalloc (sizeof word_beg_bk - 1 + size + sizeof word_end_bk);

      strcpy (n, match_lines ? (bk ? line_beg_bk : line_beg_no_bk)
			     : (bk ? word_beg_bk : word_beg_no_bk));
      total = strlen(n);
      memcpy (n + total, pattern, size);
      total += size;
      strcpy (n + total, match_lines ? (bk ? line_end_bk : line_end_no_bk)
				     : (bk ? word_end_bk : word_end_no_bk));
      total += strlen (n + total);
      pattern = motif = n;
      size = total;
    }
  else
    motif = NULL;

  dfacomp (pattern, size, &dfa, 1);
  kwsmusts ();

  free(motif);
}

size_t
EGexecute (char const *buf, size_t size, size_t *match_size,
	   char const *start_ptr)
{
  char const *buflim, *beg, *end, *match, *best_match, *mb_start;
  char eol = eolbyte;
  int backref, start, len, best_len;
  struct kwsmatch kwsm;
  size_t i, ret_val;
#ifdef MBS_SUPPORT
  if (MB_CUR_MAX > 1)
    {
      
//Patch 0:
if ((__is_neg(25, &(match_icase), sizeof (match_icase), &(buf), sizeof (buf), &(size), sizeof (size), &(start_ptr), sizeof (start_ptr), &(eolbyte), sizeof (eolbyte), &(mb_start), sizeof (mb_start), &(buflim), sizeof (buflim), &(beg), sizeof (beg), &(end), sizeof (end), &(kwset), sizeof (kwset), &(eol), sizeof (eol), &(match), sizeof (match), &(kwset_exact_matches), sizeof (kwset_exact_matches), &(backref), sizeof (backref), &(best_match), sizeof (best_match), &(best_len), sizeof (best_len), &(i), sizeof (i), &(pcount), sizeof (pcount), &(patterns), sizeof (patterns), &(start), sizeof (start), &(len), sizeof (len), &(match_words), sizeof (match_words), &(match_lines), sizeof (match_lines), &(ret_val), sizeof (ret_val), &(match_size), sizeof (match_size))))
    return -1;
if (match_icase) {
    char *case_buf = mbtolower(buf, &size);
    if (start_ptr)
        start_ptr = case_buf + (start_ptr - buf);
    buf = case_buf;
}

//CodeSeg 1:
    }
#endif /* MBS_SUPPORT */

  mb_start = buf;
  buflim = buf + size;

  for (beg = end = buf; end < buflim; beg = end)
    {
      if (!start_ptr)
	{
	  /* We don't care about an exact match.  */
	  if (kwset)
	    {
	      /* Find a possible match using the KWset matcher. */
	      size_t offset = kwsexec (kwset, beg, buflim - beg, &kwsm);
	      if (offset == (size_t) -1)
		goto failure;
	      beg += offset;
	      /* Narrow down to the line containing the candidate, and
		 run it through DFA. */
	      if ((end = memchr(beg, eol, buflim - beg)) != NULL)
	        end++;
              else
                end = buflim;
	      match = beg;
	      while (beg > buf && beg[-1] != eol)
		--beg;
	      if (kwsm.index < kwset_exact_matches)
                {
#ifdef MBS_SUPPORT
                  if (mb_start < beg)
                    mb_start = beg;
                  if (MB_CUR_MAX == 1 || !is_mb_middle (&mb_start, match, buflim))
#endif
                    goto success;
                }
	      if (dfaexec (&dfa, beg, (char *) end, 0, NULL, &backref) == NULL)
		continue;
	    }
	  else
	    {
	      /* No good fixed strings; start with DFA. */
	      char const *next_beg = dfaexec (&dfa, beg, (char *) buflim,
					      0, NULL, &backref);
	      if (next_beg == NULL)
		break;
	      /* Narrow down to the line we've found. */
	      beg = next_beg;
	      if ((end = memchr(beg, eol, buflim - beg)) != NULL)
	        end++;
              else
                end = buflim;
	      while (beg > buf && beg[-1] != eol)
		--beg;
	    }
	  /* Successful, no backreferences encountered! */
	  if (!backref)
	    goto success;
	}
      else
	{
	  /* We are looking for the leftmost (then longest) exact match.
	     We will go through the outer loop only once.  */
	  beg = start_ptr;
	  end = buflim;
	}

      /* If we've made it to this point, this means DFA has seen
	 a probable match, and we need to run it through Regex. */
      best_match = end;
      best_len = 0;
      for (i = 0; i < pcount; i++)
	{
	  patterns[i].regexbuf.not_eol = 0;
	  if (0 <= (start = re_search (&(patterns[i].regexbuf),
				       buf, end - buf - 1,
				       beg - buf, end - beg - 1,
				       &(patterns[i].regs))))
	    {
	      len = patterns[i].regs.end[0] - start;
	      match = buf + start;
	      if (match > best_match)
		continue;
	      if (start_ptr && !match_words)
		goto assess_pattern_match;
	      if ((!match_lines && !match_words)
		  || (match_lines && len == end - beg - 1))
		{
		  match = beg;
		  len = end - beg;
		  goto assess_pattern_match;
		}
	      /* If -w, check if the match aligns with word boundaries.
		 We do this iteratively because:
		 (a) the line may contain more than one occurence of the
		 pattern, and
		 (b) Several alternatives in the pattern might be valid at a
		 given point, and we may need to consider a shorter one to
		 find a word boundary.  */
	      if (match_words)
		while (match <= best_match)
		  {
		    if ((match == buf || !WCHAR ((unsigned char) match[-1]))
			&& (len == end - beg - 1
			    || !WCHAR ((unsigned char) match[len])))
		      goto assess_pattern_match;
		    if (len > 0)
		      {
			/* Try a shorter length anchored at the same place. */
			--len;
			patterns[i].regexbuf.not_eol = 1;
			len = re_match (&(patterns[i].regexbuf),
					buf, match + len - beg, match - buf,
					&(patterns[i].regs));
		      }
		    if (len <= 0)
		      {
			/* Try looking further on. */
			if (match == end - 1)
			  break;
			match++;
			patterns[i].regexbuf.not_eol = 0;
			start = re_search (&(patterns[i].regexbuf),
					   buf, end - buf - 1,
					   match - buf, end - match - 1,
					   &(patterns[i].regs));
			if (start < 0)
			  break;
			len = patterns[i].regs.end[0] - start;
			match = buf + start;
		      }
		  } /* while (match <= best_match) */
	      continue;
	    assess_pattern_match:
	      if (!start_ptr)
		{
		  /* Good enough for a non-exact match.
		     No need to look at further patterns, if any.  */
		  beg = match;
		  goto success_in_len;
		}
	      if (match < best_match || (match == best_match && len > best_len))
		{
		  /* Best exact match:  leftmost, then longest.  */
		  best_match = match;
		  best_len = len;
		}
	    } /* if re_search >= 0 */
	} /* for Regex patterns.  */
	if (best_match < end)
	  {
	    /* We have found an exact match.  We were just
	       waiting for the best one (leftmost then longest).  */
	    beg = best_match;
	    len = best_len;
	    goto success_in_len;
	  }
    } /* for (beg = end ..) */

 failure:
  ret_val = -1;
  goto out;

 success:
  len = end - beg;
 success_in_len:
  *match_size = len;
  ret_val = beg - buf;
 out:
  return ret_val;
}

Spawn 1 instances, now Total 99
Counter: 100
Batcher Size:99
Preprocess the following candidate with CondTester:
Priority 8750
At location src/dfasearch.c:214
--Src File: src/dfasearch.c
Fragment 0:
if ((__abst_hole(match_icase, buf, size, start_ptr, eolbyte, mb_start, buflim, beg, end, kwset, eol, match, kwset_exact_matches, backref, best_match, best_len, i, pcount, patterns, start, len, match_words, match_lines, ret_val, match_size)))
    return 0;
if (match_icase) {
    char *case_buf = mbtolower(buf, &size);
    if (start_ptr)
        start_ptr = case_buf + (start_ptr - buf);
    buf = case_buf;
}


CondTester, a patch instance with id 99:
//src_file:src/dfasearch.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); void* memset(void*, int, unsigned long); 
/* dfasearch.c - searching subroutines using dfa and regex for grep.
   Copyright 1992, 1998, 2000, 2007, 2009-2010 Free Software Foundation, Inc.

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 3, or (at your option)
   any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program; if not, write to the Free Software
   Foundation, Inc., 51 Franklin Street - Fifth Floor, Boston, MA
   02110-1301, USA.  */

/* Written August 1992 by Mike Haertel. */

#include <config.h>
#include "search.h"
#include "dfa.h"

/* For -w, we also consider _ to be word constituent.  */
#define WCHAR(C) (ISALNUM(C) || (C) == '_')

/* KWset compiled pattern.  For Ecompile and Gcompile, we compile
   a list of strings, at least one of which is known to occur in
   any string matching the regexp. */
static kwset_t kwset;

/* DFA compiled regexp. */
static struct dfa dfa;

/* The Regex compiled patterns.  */
static struct patterns
{
  /* Regex compiled regexp. */
  struct re_pattern_buffer regexbuf;
  struct re_registers regs; /* This is here on account of a BRAIN-DEAD
			       Q@#%!# library interface in regex.c.  */
} patterns0;

struct patterns *patterns;
size_t pcount;

void
dfaerror (char const *mesg)
{
  error (EXIT_TROUBLE, 0, "%s", mesg);

  /* notreached */
  /* Tell static analyzers that this function does not return.  */
  abort ();
}

/* Number of compiled fixed strings known to exactly match the regexp.
   If kwsexec returns < kwset_exact_matches, then we don't need to
   call the regexp matcher at all. */
static int kwset_exact_matches;

static char const *
kwsincr_case (const char *must)
{
  const char *buf;
  size_t n;

  n = strlen (must);
#ifdef MBS_SUPPORT
  if (match_icase && MB_CUR_MAX > 1)
    buf = mbtolower (must, &n);
  else
#endif
    buf = must;
  return kwsincr (kwset, buf, n);
}

/* If the DFA turns out to have some set of fixed strings one of
   which must occur in the match, then we build a kwset matcher
   to find those strings, and thus quickly filter out impossible
   matches. */
static void
kwsmusts (void)
{
  struct dfamust const *dm;
  char const *err;

  if (dfa.musts)
    {
      kwsinit (&kwset);
      /* First, we compile in the substrings known to be exact
	 matches.  The kwset matcher will return the index
	 of the matching string that it chooses. */
      for (dm = dfa.musts; dm; dm = dm->next)
	{
	  if (!dm->exact)
	    continue;
	  ++kwset_exact_matches;
	  if ((err = kwsincr_case (dm->must)) != NULL)
	    error (EXIT_TROUBLE, 0, "%s", err);
	}
      /* Now, we compile the substrings that will require
	 the use of the regexp matcher.  */
      for (dm = dfa.musts; dm; dm = dm->next)
	{
	  if (dm->exact)
	    continue;
	  if ((err = kwsincr_case (dm->must)) != NULL)
	    error (EXIT_TROUBLE, 0, "%s", err);
	}
      if ((err = kwsprep (kwset)) != NULL)
	error (EXIT_TROUBLE, 0, "%s", err);
    }
}

void
GEAcompile (char const *pattern, size_t size, reg_syntax_t syntax_bits)
{
  const char *err;
  const char *p, *sep;
  size_t total = size;
  char *motif;

  if (match_icase)
    syntax_bits |= RE_ICASE;
  re_set_syntax (syntax_bits);
  dfasyntax (syntax_bits, match_icase, eolbyte);

  /* For GNU regex compiler we have to pass the patterns separately to detect
     errors like "[\nallo\n]\n".  The patterns here are "[", "allo" and "]"
     GNU regex should have raise a syntax error.  The same for backref, where
     the backref should have been local to each pattern.  */
  p = pattern;
  do
    {
      size_t len;
      sep = memchr (p, '\n', total);
      if (sep)
	{
	  len = sep - p;
	  sep++;
	  total -= (len + 1);
	}
      else
	{
	  len = total;
	  total = 0;
	}

      patterns = realloc (patterns, (pcount + 1) * sizeof (*patterns));
      if (patterns == NULL)
	error (EXIT_TROUBLE, errno, _("memory exhausted"));
      patterns[pcount] = patterns0;

      if ((err = re_compile_pattern (p, len,
				    &(patterns[pcount].regexbuf))) != NULL)
	error (EXIT_TROUBLE, 0, "%s", err);
      pcount++;

      p = sep;
    } while (sep && total != 0);

  /* In the match_words and match_lines cases, we use a different pattern
     for the DFA matcher that will quickly throw out cases that won't work.
     Then if DFA succeeds we do some hairy stuff using the regex matcher
     to decide whether the match should really count. */
  if (match_words || match_lines)
    {
      static char const line_beg_no_bk[] = "^(";
      static char const line_end_no_bk[] = ")$";
      static char const word_beg_no_bk[] = "(^|[^[:alnum:]_])(";
      static char const word_end_no_bk[] = ")([^[:alnum:]_]|$)";
      static char const line_beg_bk[] = "^\\(";
      static char const line_end_bk[] = "\\)$";
      static char const word_beg_bk[] = "\\(^\\|[^[:alnum:]_]\\)\\(";
      static char const word_end_bk[] = "\\)\\([^[:alnum:]_]\\|$\\)";
      int bk = !(syntax_bits & RE_NO_BK_PARENS);
      char *n = xmalloc (sizeof word_beg_bk - 1 + size + sizeof word_end_bk);

      strcpy (n, match_lines ? (bk ? line_beg_bk : line_beg_no_bk)
			     : (bk ? word_beg_bk : word_beg_no_bk));
      total = strlen(n);
      memcpy (n + total, pattern, size);
      total += size;
      strcpy (n + total, match_lines ? (bk ? line_end_bk : line_end_no_bk)
				     : (bk ? word_end_bk : word_end_no_bk));
      total += strlen (n + total);
      pattern = motif = n;
      size = total;
    }
  else
    motif = NULL;

  dfacomp (pattern, size, &dfa, 1);
  kwsmusts ();

  free(motif);
}

size_t
EGexecute (char const *buf, size_t size, size_t *match_size,
	   char const *start_ptr)
{
  char const *buflim, *beg, *end, *match, *best_match, *mb_start;
  char eol = eolbyte;
  int backref, start, len, best_len;
  struct kwsmatch kwsm;
  size_t i, ret_val;
#ifdef MBS_SUPPORT
  if (MB_CUR_MAX > 1)
    {
      
//Patch 0:
if ((__is_neg(25, &(match_icase), sizeof (match_icase), &(buf), sizeof (buf), &(size), sizeof (size), &(start_ptr), sizeof (start_ptr), &(eolbyte), sizeof (eolbyte), &(mb_start), sizeof (mb_start), &(buflim), sizeof (buflim), &(beg), sizeof (beg), &(end), sizeof (end), &(kwset), sizeof (kwset), &(eol), sizeof (eol), &(match), sizeof (match), &(kwset_exact_matches), sizeof (kwset_exact_matches), &(backref), sizeof (backref), &(best_match), sizeof (best_match), &(best_len), sizeof (best_len), &(i), sizeof (i), &(pcount), sizeof (pcount), &(patterns), sizeof (patterns), &(start), sizeof (start), &(len), sizeof (len), &(match_words), sizeof (match_words), &(match_lines), sizeof (match_lines), &(ret_val), sizeof (ret_val), &(match_size), sizeof (match_size))))
    return 0;
if (match_icase) {
    char *case_buf = mbtolower(buf, &size);
    if (start_ptr)
        start_ptr = case_buf + (start_ptr - buf);
    buf = case_buf;
}

//CodeSeg 1:
    }
#endif /* MBS_SUPPORT */

  mb_start = buf;
  buflim = buf + size;

  for (beg = end = buf; end < buflim; beg = end)
    {
      if (!start_ptr)
	{
	  /* We don't care about an exact match.  */
	  if (kwset)
	    {
	      /* Find a possible match using the KWset matcher. */
	      size_t offset = kwsexec (kwset, beg, buflim - beg, &kwsm);
	      if (offset == (size_t) -1)
		goto failure;
	      beg += offset;
	      /* Narrow down to the line containing the candidate, and
		 run it through DFA. */
	      if ((end = memchr(beg, eol, buflim - beg)) != NULL)
	        end++;
              else
                end = buflim;
	      match = beg;
	      while (beg > buf && beg[-1] != eol)
		--beg;
	      if (kwsm.index < kwset_exact_matches)
                {
#ifdef MBS_SUPPORT
                  if (mb_start < beg)
                    mb_start = beg;
                  if (MB_CUR_MAX == 1 || !is_mb_middle (&mb_start, match, buflim))
#endif
                    goto success;
                }
	      if (dfaexec (&dfa, beg, (char *) end, 0, NULL, &backref) == NULL)
		continue;
	    }
	  else
	    {
	      /* No good fixed strings; start with DFA. */
	      char const *next_beg = dfaexec (&dfa, beg, (char *) buflim,
					      0, NULL, &backref);
	      if (next_beg == NULL)
		break;
	      /* Narrow down to the line we've found. */
	      beg = next_beg;
	      if ((end = memchr(beg, eol, buflim - beg)) != NULL)
	        end++;
              else
                end = buflim;
	      while (beg > buf && beg[-1] != eol)
		--beg;
	    }
	  /* Successful, no backreferences encountered! */
	  if (!backref)
	    goto success;
	}
      else
	{
	  /* We are looking for the leftmost (then longest) exact match.
	     We will go through the outer loop only once.  */
	  beg = start_ptr;
	  end = buflim;
	}

      /* If we've made it to this point, this means DFA has seen
	 a probable match, and we need to run it through Regex. */
      best_match = end;
      best_len = 0;
      for (i = 0; i < pcount; i++)
	{
	  patterns[i].regexbuf.not_eol = 0;
	  if (0 <= (start = re_search (&(patterns[i].regexbuf),
				       buf, end - buf - 1,
				       beg - buf, end - beg - 1,
				       &(patterns[i].regs))))
	    {
	      len = patterns[i].regs.end[0] - start;
	      match = buf + start;
	      if (match > best_match)
		continue;
	      if (start_ptr && !match_words)
		goto assess_pattern_match;
	      if ((!match_lines && !match_words)
		  || (match_lines && len == end - beg - 1))
		{
		  match = beg;
		  len = end - beg;
		  goto assess_pattern_match;
		}
	      /* If -w, check if the match aligns with word boundaries.
		 We do this iteratively because:
		 (a) the line may contain more than one occurence of the
		 pattern, and
		 (b) Several alternatives in the pattern might be valid at a
		 given point, and we may need to consider a shorter one to
		 find a word boundary.  */
	      if (match_words)
		while (match <= best_match)
		  {
		    if ((match == buf || !WCHAR ((unsigned char) match[-1]))
			&& (len == end - beg - 1
			    || !WCHAR ((unsigned char) match[len])))
		      goto assess_pattern_match;
		    if (len > 0)
		      {
			/* Try a shorter length anchored at the same place. */
			--len;
			patterns[i].regexbuf.not_eol = 1;
			len = re_match (&(patterns[i].regexbuf),
					buf, match + len - beg, match - buf,
					&(patterns[i].regs));
		      }
		    if (len <= 0)
		      {
			/* Try looking further on. */
			if (match == end - 1)
			  break;
			match++;
			patterns[i].regexbuf.not_eol = 0;
			start = re_search (&(patterns[i].regexbuf),
					   buf, end - buf - 1,
					   match - buf, end - match - 1,
					   &(patterns[i].regs));
			if (start < 0)
			  break;
			len = patterns[i].regs.end[0] - start;
			match = buf + start;
		      }
		  } /* while (match <= best_match) */
	      continue;
	    assess_pattern_match:
	      if (!start_ptr)
		{
		  /* Good enough for a non-exact match.
		     No need to look at further patterns, if any.  */
		  beg = match;
		  goto success_in_len;
		}
	      if (match < best_match || (match == best_match && len > best_len))
		{
		  /* Best exact match:  leftmost, then longest.  */
		  best_match = match;
		  best_len = len;
		}
	    } /* if re_search >= 0 */
	} /* for Regex patterns.  */
	if (best_match < end)
	  {
	    /* We have found an exact match.  We were just
	       waiting for the best one (leftmost then longest).  */
	    beg = best_match;
	    len = best_len;
	    goto success_in_len;
	  }
    } /* for (beg = end ..) */

 failure:
  ret_val = -1;
  goto out;

 success:
  len = end - beg;
 success_in_len:
  *match_size = len;
  ret_val = beg - buf;
 out:
  return ret_val;
}

Spawn 1 instances, now Total 100
Counter: 101
Batcher Size:100
Preprocess the following candidate with CondTester:
Priority 8750
At location src/dfasearch.c:214
--Src File: src/dfasearch.c
Fragment 0:
if ((__abst_hole(match_icase, buf, size, start_ptr, eolbyte, mb_start, buflim, beg, end, kwset, eol, match, kwset_exact_matches, backref, best_match, best_len, i, pcount, patterns, start, len, match_words, match_lines, ret_val, match_size)))
    return 1;
if (match_icase) {
    char *case_buf = mbtolower(buf, &size);
    if (start_ptr)
        start_ptr = case_buf + (start_ptr - buf);
    buf = case_buf;
}


CondTester, a patch instance with id 100:
//src_file:src/dfasearch.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); void* memset(void*, int, unsigned long); 
/* dfasearch.c - searching subroutines using dfa and regex for grep.
   Copyright 1992, 1998, 2000, 2007, 2009-2010 Free Software Foundation, Inc.

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 3, or (at your option)
   any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program; if not, write to the Free Software
   Foundation, Inc., 51 Franklin Street - Fifth Floor, Boston, MA
   02110-1301, USA.  */

/* Written August 1992 by Mike Haertel. */

#include <config.h>
#include "search.h"
#include "dfa.h"

/* For -w, we also consider _ to be word constituent.  */
#define WCHAR(C) (ISALNUM(C) || (C) == '_')

/* KWset compiled pattern.  For Ecompile and Gcompile, we compile
   a list of strings, at least one of which is known to occur in
   any string matching the regexp. */
static kwset_t kwset;

/* DFA compiled regexp. */
static struct dfa dfa;

/* The Regex compiled patterns.  */
static struct patterns
{
  /* Regex compiled regexp. */
  struct re_pattern_buffer regexbuf;
  struct re_registers regs; /* This is here on account of a BRAIN-DEAD
			       Q@#%!# library interface in regex.c.  */
} patterns0;

struct patterns *patterns;
size_t pcount;

void
dfaerror (char const *mesg)
{
  error (EXIT_TROUBLE, 0, "%s", mesg);

  /* notreached */
  /* Tell static analyzers that this function does not return.  */
  abort ();
}

/* Number of compiled fixed strings known to exactly match the regexp.
   If kwsexec returns < kwset_exact_matches, then we don't need to
   call the regexp matcher at all. */
static int kwset_exact_matches;

static char const *
kwsincr_case (const char *must)
{
  const char *buf;
  size_t n;

  n = strlen (must);
#ifdef MBS_SUPPORT
  if (match_icase && MB_CUR_MAX > 1)
    buf = mbtolower (must, &n);
  else
#endif
    buf = must;
  return kwsincr (kwset, buf, n);
}

/* If the DFA turns out to have some set of fixed strings one of
   which must occur in the match, then we build a kwset matcher
   to find those strings, and thus quickly filter out impossible
   matches. */
static void
kwsmusts (void)
{
  struct dfamust const *dm;
  char const *err;

  if (dfa.musts)
    {
      kwsinit (&kwset);
      /* First, we compile in the substrings known to be exact
	 matches.  The kwset matcher will return the index
	 of the matching string that it chooses. */
      for (dm = dfa.musts; dm; dm = dm->next)
	{
	  if (!dm->exact)
	    continue;
	  ++kwset_exact_matches;
	  if ((err = kwsincr_case (dm->must)) != NULL)
	    error (EXIT_TROUBLE, 0, "%s", err);
	}
      /* Now, we compile the substrings that will require
	 the use of the regexp matcher.  */
      for (dm = dfa.musts; dm; dm = dm->next)
	{
	  if (dm->exact)
	    continue;
	  if ((err = kwsincr_case (dm->must)) != NULL)
	    error (EXIT_TROUBLE, 0, "%s", err);
	}
      if ((err = kwsprep (kwset)) != NULL)
	error (EXIT_TROUBLE, 0, "%s", err);
    }
}

void
GEAcompile (char const *pattern, size_t size, reg_syntax_t syntax_bits)
{
  const char *err;
  const char *p, *sep;
  size_t total = size;
  char *motif;

  if (match_icase)
    syntax_bits |= RE_ICASE;
  re_set_syntax (syntax_bits);
  dfasyntax (syntax_bits, match_icase, eolbyte);

  /* For GNU regex compiler we have to pass the patterns separately to detect
     errors like "[\nallo\n]\n".  The patterns here are "[", "allo" and "]"
     GNU regex should have raise a syntax error.  The same for backref, where
     the backref should have been local to each pattern.  */
  p = pattern;
  do
    {
      size_t len;
      sep = memchr (p, '\n', total);
      if (sep)
	{
	  len = sep - p;
	  sep++;
	  total -= (len + 1);
	}
      else
	{
	  len = total;
	  total = 0;
	}

      patterns = realloc (patterns, (pcount + 1) * sizeof (*patterns));
      if (patterns == NULL)
	error (EXIT_TROUBLE, errno, _("memory exhausted"));
      patterns[pcount] = patterns0;

      if ((err = re_compile_pattern (p, len,
				    &(patterns[pcount].regexbuf))) != NULL)
	error (EXIT_TROUBLE, 0, "%s", err);
      pcount++;

      p = sep;
    } while (sep && total != 0);

  /* In the match_words and match_lines cases, we use a different pattern
     for the DFA matcher that will quickly throw out cases that won't work.
     Then if DFA succeeds we do some hairy stuff using the regex matcher
     to decide whether the match should really count. */
  if (match_words || match_lines)
    {
      static char const line_beg_no_bk[] = "^(";
      static char const line_end_no_bk[] = ")$";
      static char const word_beg_no_bk[] = "(^|[^[:alnum:]_])(";
      static char const word_end_no_bk[] = ")([^[:alnum:]_]|$)";
      static char const line_beg_bk[] = "^\\(";
      static char const line_end_bk[] = "\\)$";
      static char const word_beg_bk[] = "\\(^\\|[^[:alnum:]_]\\)\\(";
      static char const word_end_bk[] = "\\)\\([^[:alnum:]_]\\|$\\)";
      int bk = !(syntax_bits & RE_NO_BK_PARENS);
      char *n = xmalloc (sizeof word_beg_bk - 1 + size + sizeof word_end_bk);

      strcpy (n, match_lines ? (bk ? line_beg_bk : line_beg_no_bk)
			     : (bk ? word_beg_bk : word_beg_no_bk));
      total = strlen(n);
      memcpy (n + total, pattern, size);
      total += size;
      strcpy (n + total, match_lines ? (bk ? line_end_bk : line_end_no_bk)
				     : (bk ? word_end_bk : word_end_no_bk));
      total += strlen (n + total);
      pattern = motif = n;
      size = total;
    }
  else
    motif = NULL;

  dfacomp (pattern, size, &dfa, 1);
  kwsmusts ();

  free(motif);
}

size_t
EGexecute (char const *buf, size_t size, size_t *match_size,
	   char const *start_ptr)
{
  char const *buflim, *beg, *end, *match, *best_match, *mb_start;
  char eol = eolbyte;
  int backref, start, len, best_len;
  struct kwsmatch kwsm;
  size_t i, ret_val;
#ifdef MBS_SUPPORT
  if (MB_CUR_MAX > 1)
    {
      
//Patch 0:
if ((__is_neg(25, &(match_icase), sizeof (match_icase), &(buf), sizeof (buf), &(size), sizeof (size), &(start_ptr), sizeof (start_ptr), &(eolbyte), sizeof (eolbyte), &(mb_start), sizeof (mb_start), &(buflim), sizeof (buflim), &(beg), sizeof (beg), &(end), sizeof (end), &(kwset), sizeof (kwset), &(eol), sizeof (eol), &(match), sizeof (match), &(kwset_exact_matches), sizeof (kwset_exact_matches), &(backref), sizeof (backref), &(best_match), sizeof (best_match), &(best_len), sizeof (best_len), &(i), sizeof (i), &(pcount), sizeof (pcount), &(patterns), sizeof (patterns), &(start), sizeof (start), &(len), sizeof (len), &(match_words), sizeof (match_words), &(match_lines), sizeof (match_lines), &(ret_val), sizeof (ret_val), &(match_size), sizeof (match_size))))
    return 1;
if (match_icase) {
    char *case_buf = mbtolower(buf, &size);
    if (start_ptr)
        start_ptr = case_buf + (start_ptr - buf);
    buf = case_buf;
}

//CodeSeg 1:
    }
#endif /* MBS_SUPPORT */

  mb_start = buf;
  buflim = buf + size;

  for (beg = end = buf; end < buflim; beg = end)
    {
      if (!start_ptr)
	{
	  /* We don't care about an exact match.  */
	  if (kwset)
	    {
	      /* Find a possible match using the KWset matcher. */
	      size_t offset = kwsexec (kwset, beg, buflim - beg, &kwsm);
	      if (offset == (size_t) -1)
		goto failure;
	      beg += offset;
	      /* Narrow down to the line containing the candidate, and
		 run it through DFA. */
	      if ((end = memchr(beg, eol, buflim - beg)) != NULL)
	        end++;
              else
                end = buflim;
	      match = beg;
	      while (beg > buf && beg[-1] != eol)
		--beg;
	      if (kwsm.index < kwset_exact_matches)
                {
#ifdef MBS_SUPPORT
                  if (mb_start < beg)
                    mb_start = beg;
                  if (MB_CUR_MAX == 1 || !is_mb_middle (&mb_start, match, buflim))
#endif
                    goto success;
                }
	      if (dfaexec (&dfa, beg, (char *) end, 0, NULL, &backref) == NULL)
		continue;
	    }
	  else
	    {
	      /* No good fixed strings; start with DFA. */
	      char const *next_beg = dfaexec (&dfa, beg, (char *) buflim,
					      0, NULL, &backref);
	      if (next_beg == NULL)
		break;
	      /* Narrow down to the line we've found. */
	      beg = next_beg;
	      if ((end = memchr(beg, eol, buflim - beg)) != NULL)
	        end++;
              else
                end = buflim;
	      while (beg > buf && beg[-1] != eol)
		--beg;
	    }
	  /* Successful, no backreferences encountered! */
	  if (!backref)
	    goto success;
	}
      else
	{
	  /* We are looking for the leftmost (then longest) exact match.
	     We will go through the outer loop only once.  */
	  beg = start_ptr;
	  end = buflim;
	}

      /* If we've made it to this point, this means DFA has seen
	 a probable match, and we need to run it through Regex. */
      best_match = end;
      best_len = 0;
      for (i = 0; i < pcount; i++)
	{
	  patterns[i].regexbuf.not_eol = 0;
	  if (0 <= (start = re_search (&(patterns[i].regexbuf),
				       buf, end - buf - 1,
				       beg - buf, end - beg - 1,
				       &(patterns[i].regs))))
	    {
	      len = patterns[i].regs.end[0] - start;
	      match = buf + start;
	      if (match > best_match)
		continue;
	      if (start_ptr && !match_words)
		goto assess_pattern_match;
	      if ((!match_lines && !match_words)
		  || (match_lines && len == end - beg - 1))
		{
		  match = beg;
		  len = end - beg;
		  goto assess_pattern_match;
		}
	      /* If -w, check if the match aligns with word boundaries.
		 We do this iteratively because:
		 (a) the line may contain more than one occurence of the
		 pattern, and
		 (b) Several alternatives in the pattern might be valid at a
		 given point, and we may need to consider a shorter one to
		 find a word boundary.  */
	      if (match_words)
		while (match <= best_match)
		  {
		    if ((match == buf || !WCHAR ((unsigned char) match[-1]))
			&& (len == end - beg - 1
			    || !WCHAR ((unsigned char) match[len])))
		      goto assess_pattern_match;
		    if (len > 0)
		      {
			/* Try a shorter length anchored at the same place. */
			--len;
			patterns[i].regexbuf.not_eol = 1;
			len = re_match (&(patterns[i].regexbuf),
					buf, match + len - beg, match - buf,
					&(patterns[i].regs));
		      }
		    if (len <= 0)
		      {
			/* Try looking further on. */
			if (match == end - 1)
			  break;
			match++;
			patterns[i].regexbuf.not_eol = 0;
			start = re_search (&(patterns[i].regexbuf),
					   buf, end - buf - 1,
					   match - buf, end - match - 1,
					   &(patterns[i].regs));
			if (start < 0)
			  break;
			len = patterns[i].regs.end[0] - start;
			match = buf + start;
		      }
		  } /* while (match <= best_match) */
	      continue;
	    assess_pattern_match:
	      if (!start_ptr)
		{
		  /* Good enough for a non-exact match.
		     No need to look at further patterns, if any.  */
		  beg = match;
		  goto success_in_len;
		}
	      if (match < best_match || (match == best_match && len > best_len))
		{
		  /* Best exact match:  leftmost, then longest.  */
		  best_match = match;
		  best_len = len;
		}
	    } /* if re_search >= 0 */
	} /* for Regex patterns.  */
	if (best_match < end)
	  {
	    /* We have found an exact match.  We were just
	       waiting for the best one (leftmost then longest).  */
	    beg = best_match;
	    len = best_len;
	    goto success_in_len;
	  }
    } /* for (beg = end ..) */

 failure:
  ret_val = -1;
  goto out;

 success:
  len = end - beg;
 success_in_len:
  *match_size = len;
  ret_val = beg - buf;
 out:
  return ret_val;
}

Spawn 1 instances, now Total 101
a batched test job starts!
Building merged code:
src_file: src/dfasearch.c
full src: int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); void* memset(void*, int, unsigned long); 
/* dfasearch.c - searching subroutines using dfa and regex for grep.
   Copyright 1992, 1998, 2000, 2007, 2009-2010 Free Software Foundation, Inc.

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 3, or (at your option)
   any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program; if not, write to the Free Software
   Foundation, Inc., 51 Franklin Street - Fifth Floor, Boston, MA
   02110-1301, USA.  */

/* Written August 1992 by Mike Haertel. */

#include <config.h>
#include "search.h"
#include "dfa.h"

/* For -w, we also consider _ to be word constituent.  */
#define WCHAR(C) (ISALNUM(C) || (C) == '_')

/* KWset compiled pattern.  For Ecompile and Gcompile, we compile
   a list of strings, at least one of which is known to occur in
   any string matching the regexp. */
static kwset_t kwset;

/* DFA compiled regexp. */
static struct dfa dfa;

/* The Regex compiled patterns.  */
static struct patterns
{
  /* Regex compiled regexp. */
  struct re_pattern_buffer regexbuf;
  struct re_registers regs; /* This is here on account of a BRAIN-DEAD
			       Q@#%!# library interface in regex.c.  */
} patterns0;

struct patterns *patterns;
size_t pcount;

void
dfaerror (char const *mesg)
{
  error (EXIT_TROUBLE, 0, "%s", mesg);

  /* notreached */
  /* Tell static analyzers that this function does not return.  */
  abort ();
}

/* Number of compiled fixed strings known to exactly match the regexp.
   If kwsexec returns < kwset_exact_matches, then we don't need to
   call the regexp matcher at all. */
static int kwset_exact_matches;

static char const *
kwsincr_case (const char *must)
{
  const char *buf;
  size_t n;

  n = strlen (must);
#ifdef MBS_SUPPORT
  if (match_icase && MB_CUR_MAX > 1)
    buf = mbtolower (must, &n);
  else
#endif
    buf = must;
  return kwsincr (kwset, buf, n);
}

/* If the DFA turns out to have some set of fixed strings one of
   which must occur in the match, then we build a kwset matcher
   to find those strings, and thus quickly filter out impossible
   matches. */
static void
kwsmusts (void)
{
  struct dfamust const *dm;
  char const *err;

  if (dfa.musts)
    {
      kwsinit (&kwset);
      /* First, we compile in the substrings known to be exact
	 matches.  The kwset matcher will return the index
	 of the matching string that it chooses. */
      for (dm = dfa.musts; dm; dm = dm->next)
	{
	  if (!dm->exact)
	    continue;
	  ++kwset_exact_matches;
	  if ((err = kwsincr_case (dm->must)) != NULL)
	    error (EXIT_TROUBLE, 0, "%s", err);
	}
      /* Now, we compile the substrings that will require
	 the use of the regexp matcher.  */
      for (dm = dfa.musts; dm; dm = dm->next)
	{
	  if (dm->exact)
	    continue;
	  if ((err = kwsincr_case (dm->must)) != NULL)
	    error (EXIT_TROUBLE, 0, "%s", err);
	}
      if ((err = kwsprep (kwset)) != NULL)
	error (EXIT_TROUBLE, 0, "%s", err);
    }
}

void
GEAcompile (char const *pattern, size_t size, reg_syntax_t syntax_bits)
{
  const char *err;
  const char *p, *sep;
  size_t total = size;
  char *motif;

  if (match_icase)
    syntax_bits |= RE_ICASE;
  re_set_syntax (syntax_bits);
  dfasyntax (syntax_bits, match_icase, eolbyte);

  /* For GNU regex compiler we have to pass the patterns separately to detect
     errors like "[\nallo\n]\n".  The patterns here are "[", "allo" and "]"
     GNU regex should have raise a syntax error.  The same for backref, where
     the backref should have been local to each pattern.  */
  p = pattern;
  do
    {
      size_t len;
      sep = memchr (p, '\n', total);
      if (sep)
	{
	  len = sep - p;
	  sep++;
	  total -= (len + 1);
	}
      else
	{
	  len = total;
	  total = 0;
	}

      patterns = realloc (patterns, (pcount + 1) * sizeof (*patterns));
      if (patterns == NULL)
	error (EXIT_TROUBLE, errno, _("memory exhausted"));
      patterns[pcount] = patterns0;

      if ((err = re_compile_pattern (p, len,
				    &(patterns[pcount].regexbuf))) != NULL)
	error (EXIT_TROUBLE, 0, "%s", err);
      pcount++;

      p = sep;
    } while (sep && total != 0);

  /* In the match_words and match_lines cases, we use a different pattern
     for the DFA matcher that will quickly throw out cases that won't work.
     Then if DFA succeeds we do some hairy stuff using the regex matcher
     to decide whether the match should really count. */
  if (match_words || match_lines)
    {
      static char const line_beg_no_bk[] = "^(";
      static char const line_end_no_bk[] = ")$";
      static char const word_beg_no_bk[] = "(^|[^[:alnum:]_])(";
      static char const word_end_no_bk[] = ")([^[:alnum:]_]|$)";
      static char const line_beg_bk[] = "^\\(";
      static char const line_end_bk[] = "\\)$";
      static char const word_beg_bk[] = "\\(^\\|[^[:alnum:]_]\\)\\(";
      static char const word_end_bk[] = "\\)\\([^[:alnum:]_]\\|$\\)";
      int bk = !(syntax_bits & RE_NO_BK_PARENS);
      char *n = xmalloc (sizeof word_beg_bk - 1 + size + sizeof word_end_bk);

      strcpy (n, match_lines ? (bk ? line_beg_bk : line_beg_no_bk)
			     : (bk ? word_beg_bk : word_beg_no_bk));
      total = strlen(n);
      memcpy (n + total, pattern, size);
      total += size;
      strcpy (n + total, match_lines ? (bk ? line_end_bk : line_end_no_bk)
				     : (bk ? word_end_bk : word_end_no_bk));
      total += strlen (n + total);
      pattern = motif = n;
      size = total;
    }
  else
    motif = NULL;

  dfacomp (pattern, size, &dfa, 1);
  kwsmusts ();

  free(motif);
}

size_t
EGexecute (char const *buf, size_t size, size_t *match_size,
	   char const *start_ptr)
{
  char const *buflim, *beg, *end, *match, *best_match, *mb_start;
  char eol = eolbyte;
  int backref, start, len, best_len;
  struct kwsmatch kwsm;
  size_t i, ret_val;
#ifdef MBS_SUPPORT
  if (MB_CUR_MAX > 1)
    {
      //prophet generated patch
      if (__get_mutant()==0) {
      if ((match_icase) && !(__is_neg(25, &(match_icase), sizeof (match_icase), &(buf), sizeof (buf), &(size), sizeof (size), &(start_ptr), sizeof (start_ptr), &(eolbyte), sizeof (eolbyte), &(mb_start), sizeof (mb_start), &(buflim), sizeof (buflim), &(beg), sizeof (beg), &(end), sizeof (end), &(kwset), sizeof (kwset), &(eol), sizeof (eol), &(match), sizeof (match), &(kwset_exact_matches), sizeof (kwset_exact_matches), &(backref), sizeof (backref), &(best_match), sizeof (best_match), &(best_len), sizeof (best_len), &(i), sizeof (i), &(pcount), sizeof (pcount), &(patterns), sizeof (patterns), &(start), sizeof (start), &(len), sizeof (len), &(match_words), sizeof (match_words), &(match_lines), sizeof (match_lines), &(ret_val), sizeof (ret_val), &(match_size), sizeof (match_size)))) {
          char *case_buf = mbtolower(buf, &size);
          if (start_ptr)
              start_ptr = case_buf + (start_ptr - buf);
          buf = case_buf;
      }
      }
      else if (__get_mutant()==1) {
      if ((match_icase) || (__is_neg(25, &(match_icase), sizeof (match_icase), &(buf), sizeof (buf), &(size), sizeof (size), &(start_ptr), sizeof (start_ptr), &(eolbyte), sizeof (eolbyte), &(mb_start), sizeof (mb_start), &(buflim), sizeof (buflim), &(beg), sizeof (beg), &(end), sizeof (end), &(kwset), sizeof (kwset), &(eol), sizeof (eol), &(match), sizeof (match), &(kwset_exact_matches), sizeof (kwset_exact_matches), &(backref), sizeof (backref), &(best_match), sizeof (best_match), &(best_len), sizeof (best_len), &(i), sizeof (i), &(pcount), sizeof (pcount), &(patterns), sizeof (patterns), &(start), sizeof (start), &(len), sizeof (len), &(match_words), sizeof (match_words), &(match_lines), sizeof (match_lines), &(ret_val), sizeof (ret_val), &(match_size), sizeof (match_size)))) {
          char *case_buf = mbtolower(buf, &size);
          if (start_ptr)
              start_ptr = case_buf + (start_ptr - buf);
          buf = case_buf;
      }
      }
      else if (__get_mutant()==2) {
      if ((__is_neg(25, &(match_icase), sizeof (match_icase), &(buf), sizeof (buf), &(size), sizeof (size), &(start_ptr), sizeof (start_ptr), &(eolbyte), sizeof (eolbyte), &(mb_start), sizeof (mb_start), &(buflim), sizeof (buflim), &(beg), sizeof (beg), &(end), sizeof (end), &(kwset), sizeof (kwset), &(eol), sizeof (eol), &(match), sizeof (match), &(kwset_exact_matches), sizeof (kwset_exact_matches), &(backref), sizeof (backref), &(best_match), sizeof (best_match), &(best_len), sizeof (best_len), &(i), sizeof (i), &(pcount), sizeof (pcount), &(patterns), sizeof (patterns), &(start), sizeof (start), &(len), sizeof (len), &(match_words), sizeof (match_words), &(match_lines), sizeof (match_lines), &(ret_val), sizeof (ret_val), &(match_size), sizeof (match_size))))
          goto assess_pattern_match;
      if (match_icase) {
          char *case_buf = mbtolower(buf, &size);
          if (start_ptr)
              start_ptr = case_buf + (start_ptr - buf);
          buf = case_buf;
      }
      }
      else if (__get_mutant()==3) {
      if ((__is_neg(25, &(match_icase), sizeof (match_icase), &(buf), sizeof (buf), &(size), sizeof (size), &(start_ptr), sizeof (start_ptr), &(eolbyte), sizeof (eolbyte), &(mb_start), sizeof (mb_start), &(buflim), sizeof (buflim), &(beg), sizeof (beg), &(end), sizeof (end), &(kwset), sizeof (kwset), &(eol), sizeof (eol), &(match), sizeof (match), &(kwset_exact_matches), sizeof (kwset_exact_matches), &(backref), sizeof (backref), &(best_match), sizeof (best_match), &(best_len), sizeof (best_len), &(i), sizeof (i), &(pcount), sizeof (pcount), &(patterns), sizeof (patterns), &(start), sizeof (start), &(len), sizeof (len), &(match_words), sizeof (match_words), &(match_lines), sizeof (match_lines), &(ret_val), sizeof (ret_val), &(match_size), sizeof (match_size))))
          goto failure;
      if (match_icase) {
          char *case_buf = mbtolower(buf, &size);
          if (start_ptr)
              start_ptr = case_buf + (start_ptr - buf);
          buf = case_buf;
      }
      }
      else if (__get_mutant()==4) {
      if ((__is_neg(25, &(match_icase), sizeof (match_icase), &(buf), sizeof (buf), &(size), sizeof (size), &(start_ptr), sizeof (start_ptr), &(eolbyte), sizeof (eolbyte), &(mb_start), sizeof (mb_start), &(buflim), sizeof (buflim), &(beg), sizeof (beg), &(end), sizeof (end), &(kwset), sizeof (kwset), &(eol), sizeof (eol), &(match), sizeof (match), &(kwset_exact_matches), sizeof (kwset_exact_matches), &(backref), sizeof (backref), &(best_match), sizeof (best_match), &(best_len), sizeof (best_len), &(i), sizeof (i), &(pcount), sizeof (pcount), &(patterns), sizeof (patterns), &(start), sizeof (start), &(len), sizeof (len), &(match_words), sizeof (match_words), &(match_lines), sizeof (match_lines), &(ret_val), sizeof (ret_val), &(match_size), sizeof (match_size))))
          goto success;
      if (match_icase) {
          char *case_buf = mbtolower(buf, &size);
          if (start_ptr)
              start_ptr = case_buf + (start_ptr - buf);
          buf = case_buf;
      }
      }
      else if (__get_mutant()==5) {
      if ((__is_neg(25, &(match_icase), sizeof (match_icase), &(buf), sizeof (buf), &(size), sizeof (size), &(start_ptr), sizeof (start_ptr), &(eolbyte), sizeof (eolbyte), &(mb_start), sizeof (mb_start), &(buflim), sizeof (buflim), &(beg), sizeof (beg), &(end), sizeof (end), &(kwset), sizeof (kwset), &(eol), sizeof (eol), &(match), sizeof (match), &(kwset_exact_matches), sizeof (kwset_exact_matches), &(backref), sizeof (backref), &(best_match), sizeof (best_match), &(best_len), sizeof (best_len), &(i), sizeof (i), &(pcount), sizeof (pcount), &(patterns), sizeof (patterns), &(start), sizeof (start), &(len), sizeof (len), &(match_words), sizeof (match_words), &(match_lines), sizeof (match_lines), &(ret_val), sizeof (ret_val), &(match_size), sizeof (match_size))))
          goto success_in_len;
      if (match_icase) {
          char *case_buf = mbtolower(buf, &size);
          if (start_ptr)
              start_ptr = case_buf + (start_ptr - buf);
          buf = case_buf;
      }
      }
      else if (__get_mutant()==6) {
      if ((__is_neg(25, &(match_icase), sizeof (match_icase), &(buf), sizeof (buf), &(size), sizeof (size), &(start_ptr), sizeof (start_ptr), &(eolbyte), sizeof (eolbyte), &(mb_start), sizeof (mb_start), &(buflim), sizeof (buflim), &(beg), sizeof (beg), &(end), sizeof (end), &(kwset), sizeof (kwset), &(eol), sizeof (eol), &(match), sizeof (match), &(kwset_exact_matches), sizeof (kwset_exact_matches), &(backref), sizeof (backref), &(best_match), sizeof (best_match), &(best_len), sizeof (best_len), &(i), sizeof (i), &(pcount), sizeof (pcount), &(patterns), sizeof (patterns), &(start), sizeof (start), &(len), sizeof (len), &(match_words), sizeof (match_words), &(match_lines), sizeof (match_lines), &(ret_val), sizeof (ret_val), &(match_size), sizeof (match_size))))
          goto out;
      if (match_icase) {
          char *case_buf = mbtolower(buf, &size);
          if (start_ptr)
              start_ptr = case_buf + (start_ptr - buf);
          buf = case_buf;
      }
      }
      else if (__get_mutant()==7) {
      if ((__is_neg(25, &(match_icase), sizeof (match_icase), &(buf), sizeof (buf), &(size), sizeof (size), &(start_ptr), sizeof (start_ptr), &(eolbyte), sizeof (eolbyte), &(mb_start), sizeof (mb_start), &(buflim), sizeof (buflim), &(beg), sizeof (beg), &(end), sizeof (end), &(kwset), sizeof (kwset), &(eol), sizeof (eol), &(match), sizeof (match), &(kwset_exact_matches), sizeof (kwset_exact_matches), &(backref), sizeof (backref), &(best_match), sizeof (best_match), &(best_len), sizeof (best_len), &(i), sizeof (i), &(pcount), sizeof (pcount), &(patterns), sizeof (patterns), &(start), sizeof (start), &(len), sizeof (len), &(match_words), sizeof (match_words), &(match_lines), sizeof (match_lines), &(ret_val), sizeof (ret_val), &(match_size), sizeof (match_size))))
          return -1;
      if (match_icase) {
          char *case_buf = mbtolower(buf, &size);
          if (start_ptr)
              start_ptr = case_buf + (start_ptr - buf);
          buf = case_buf;
      }
      }
      else if (__get_mutant()==8) {
      if ((__is_neg(25, &(match_icase), sizeof (match_icase), &(buf), sizeof (buf), &(size), sizeof (size), &(start_ptr), sizeof (start_ptr), &(eolbyte), sizeof (eolbyte), &(mb_start), sizeof (mb_start), &(buflim), sizeof (buflim), &(beg), sizeof (beg), &(end), sizeof (end), &(kwset), sizeof (kwset), &(eol), sizeof (eol), &(match), sizeof (match), &(kwset_exact_matches), sizeof (kwset_exact_matches), &(backref), sizeof (backref), &(best_match), sizeof (best_match), &(best_len), sizeof (best_len), &(i), sizeof (i), &(pcount), sizeof (pcount), &(patterns), sizeof (patterns), &(start), sizeof (start), &(len), sizeof (len), &(match_words), sizeof (match_words), &(match_lines), sizeof (match_lines), &(ret_val), sizeof (ret_val), &(match_size), sizeof (match_size))))
          return 0;
      if (match_icase) {
          char *case_buf = mbtolower(buf, &size);
          if (start_ptr)
              start_ptr = case_buf + (start_ptr - buf);
          buf = case_buf;
      }
      }
      else if (__get_mutant()==9) {
      if ((__is_neg(25, &(match_icase), sizeof (match_icase), &(buf), sizeof (buf), &(size), sizeof (size), &(start_ptr), sizeof (start_ptr), &(eolbyte), sizeof (eolbyte), &(mb_start), sizeof (mb_start), &(buflim), sizeof (buflim), &(beg), sizeof (beg), &(end), sizeof (end), &(kwset), sizeof (kwset), &(eol), sizeof (eol), &(match), sizeof (match), &(kwset_exact_matches), sizeof (kwset_exact_matches), &(backref), sizeof (backref), &(best_match), sizeof (best_match), &(best_len), sizeof (best_len), &(i), sizeof (i), &(pcount), sizeof (pcount), &(patterns), sizeof (patterns), &(start), sizeof (start), &(len), sizeof (len), &(match_words), sizeof (match_words), &(match_lines), sizeof (match_lines), &(ret_val), sizeof (ret_val), &(match_size), sizeof (match_size))))
          return 1;
      if (match_icase) {
          char *case_buf = mbtolower(buf, &size);
          if (start_ptr)
              start_ptr = case_buf + (start_ptr - buf);
          buf = case_buf;
      }
      }
    }
#endif /* MBS_SUPPORT */

  mb_start = buf;
  buflim = buf + size;

  for (beg = end = buf; end < buflim; beg = end)
    {
      if (!start_ptr)
	{
	  /* We don't care about an exact match.  */
	  if (kwset)
	    {
	      /* Find a possible match using the KWset matcher. */
	      size_t offset = kwsexec (kwset, beg, buflim - beg, &kwsm);
	      if (offset == (size_t) -1)
		goto failure;
	      beg += offset;
	      /* Narrow down to the line containing the candidate, and
		 run it through DFA. */
	      if ((end = memchr(beg, eol, buflim - beg)) != NULL)
	        end++;
              else
                end = buflim;
	      match = beg;
	      while (beg > buf && beg[-1] != eol)
		--beg;
	      if (kwsm.index < kwset_exact_matches)
                {
#ifdef MBS_SUPPORT
                  if (mb_start < beg)
                    mb_start = beg;
                  if (MB_CUR_MAX == 1 || !is_mb_middle (&mb_start, match, buflim))
#endif
                    goto success;
                }
	      if (dfaexec (&dfa, beg, (char *) end, 0, NULL, &backref) == NULL)
		continue;
	    }
	  else
	    {
	      /* No good fixed strings; start with DFA. */
	      char const *next_beg = dfaexec (&dfa, beg, (char *) buflim,
					      0, NULL, &backref);
	      if (next_beg == NULL)
		break;
	      /* Narrow down to the line we've found. */
	      beg = next_beg;
	      if ((end = memchr(beg, eol, buflim - beg)) != NULL)
	        end++;
              else
                end = buflim;
	      while (beg > buf && beg[-1] != eol)
		--beg;
	    }
	  /* Successful, no backreferences encountered! */
	  if (!backref)
	    goto success;
	}
      else
	{
	  /* We are looking for the leftmost (then longest) exact match.
	     We will go through the outer loop only once.  */
	  beg = start_ptr;
	  end = buflim;
	}

      /* If we've made it to this point, this means DFA has seen
	 a probable match, and we need to run it through Regex. */
      best_match = end;
      best_len = 0;
      for (i = 0; i < pcount; i++)
	{
	  patterns[i].regexbuf.not_eol = 0;
	  if (0 <= (start = re_search (&(patterns[i].regexbuf),
				       buf, end - buf - 1,
				       beg - buf, end - beg - 1,
				       &(patterns[i].regs))))
	    {
	      len = patterns[i].regs.end[0] - start;
	      match = buf + start;
	      if (match > best_match)
		continue;
	      if (start_ptr && !match_words)
		goto assess_pattern_match;
	      if ((!match_lines && !match_words)
		  || (match_lines && len == end - beg - 1))
		{
		  match = beg;
		  len = end - beg;
		  goto assess_pattern_match;
		}
	      /* If -w, check if the match aligns with word boundaries.
		 We do this iteratively because:
		 (a) the line may contain more than one occurence of the
		 pattern, and
		 (b) Several alternatives in the pattern might be valid at a
		 given point, and we may need to consider a shorter one to
		 find a word boundary.  */
	      if (match_words)
		while (match <= best_match)
		  {
		    if ((match == buf || !WCHAR ((unsigned char) match[-1]))
			&& (len == end - beg - 1
			    || !WCHAR ((unsigned char) match[len])))
		      goto assess_pattern_match;
		    if (len > 0)
		      {
			/* Try a shorter length anchored at the same place. */
			--len;
			patterns[i].regexbuf.not_eol = 1;
			len = re_match (&(patterns[i].regexbuf),
					buf, match + len - beg, match - buf,
					&(patterns[i].regs));
		      }
		    if (len <= 0)
		      {
			/* Try looking further on. */
			if (match == end - 1)
			  break;
			match++;
			patterns[i].regexbuf.not_eol = 0;
			start = re_search (&(patterns[i].regexbuf),
					   buf, end - buf - 1,
					   match - buf, end - match - 1,
					   &(patterns[i].regs));
			if (start < 0)
			  break;
			len = patterns[i].regs.end[0] - start;
			match = buf + start;
		      }
		  } /* while (match <= best_match) */
	      continue;
	    assess_pattern_match:
	      if (!start_ptr)
		{
		  /* Good enough for a non-exact match.
		     No need to look at further patterns, if any.  */
		  beg = match;
		  goto success_in_len;
		}
	      if (match < best_match || (match == best_match && len > best_len))
		{
		  /* Best exact match:  leftmost, then longest.  */
		  best_match = match;
		  best_len = len;
		}
	    } /* if re_search >= 0 */
	} /* for Regex patterns.  */
	if (best_match < end)
	  {
	    /* We have found an exact match.  We were just
	       waiting for the best one (leftmost then longest).  */
	    beg = best_match;
	    len = best_len;
	    goto success_in_len;
	  }
    } /* for (beg = end ..) */

 failure:
  ret_val = -1;
  goto out;

 success:
  len = end - beg;
 success_in_len:
  *match_size = len;
  ret_val = beg - buf;
 out:
  return ret_val;
}

Building:src at:
/home/ubuntu/spr-fast/tests/corebench/grep/grep-case-8a025cf8-8f08d8e2/tempworkdir-l/srcMerged code building succ, going to invoke tester!
CondTester, Testing instance id 36:
//src_file:src/dfasearch.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); void* memset(void*, int, unsigned long); 
/* dfasearch.c - searching subroutines using dfa and regex for grep.
   Copyright 1992, 1998, 2000, 2007, 2009-2010 Free Software Foundation, Inc.

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 3, or (at your option)
   any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program; if not, write to the Free Software
   Foundation, Inc., 51 Franklin Street - Fifth Floor, Boston, MA
   02110-1301, USA.  */

/* Written August 1992 by Mike Haertel. */

#include <config.h>
#include "search.h"
#include "dfa.h"

/* For -w, we also consider _ to be word constituent.  */
#define WCHAR(C) (ISALNUM(C) || (C) == '_')

/* KWset compiled pattern.  For Ecompile and Gcompile, we compile
   a list of strings, at least one of which is known to occur in
   any string matching the regexp. */
static kwset_t kwset;

/* DFA compiled regexp. */
static struct dfa dfa;

/* The Regex compiled patterns.  */
static struct patterns
{
  /* Regex compiled regexp. */
  struct re_pattern_buffer regexbuf;
  struct re_registers regs; /* This is here on account of a BRAIN-DEAD
			       Q@#%!# library interface in regex.c.  */
} patterns0;

struct patterns *patterns;
size_t pcount;

void
dfaerror (char const *mesg)
{
  error (EXIT_TROUBLE, 0, "%s", mesg);

  /* notreached */
  /* Tell static analyzers that this function does not return.  */
  abort ();
}

/* Number of compiled fixed strings known to exactly match the regexp.
   If kwsexec returns < kwset_exact_matches, then we don't need to
   call the regexp matcher at all. */
static int kwset_exact_matches;

static char const *
kwsincr_case (const char *must)
{
  const char *buf;
  size_t n;

  n = strlen (must);
#ifdef MBS_SUPPORT
  if (match_icase && MB_CUR_MAX > 1)
    buf = mbtolower (must, &n);
  else
#endif
    buf = must;
  return kwsincr (kwset, buf, n);
}

/* If the DFA turns out to have some set of fixed strings one of
   which must occur in the match, then we build a kwset matcher
   to find those strings, and thus quickly filter out impossible
   matches. */
static void
kwsmusts (void)
{
  struct dfamust const *dm;
  char const *err;

  if (dfa.musts)
    {
      kwsinit (&kwset);
      /* First, we compile in the substrings known to be exact
	 matches.  The kwset matcher will return the index
	 of the matching string that it chooses. */
      for (dm = dfa.musts; dm; dm = dm->next)
	{
	  if (!dm->exact)
	    continue;
	  ++kwset_exact_matches;
	  if ((err = kwsincr_case (dm->must)) != NULL)
	    error (EXIT_TROUBLE, 0, "%s", err);
	}
      /* Now, we compile the substrings that will require
	 the use of the regexp matcher.  */
      for (dm = dfa.musts; dm; dm = dm->next)
	{
	  if (dm->exact)
	    continue;
	  if ((err = kwsincr_case (dm->must)) != NULL)
	    error (EXIT_TROUBLE, 0, "%s", err);
	}
      if ((err = kwsprep (kwset)) != NULL)
	error (EXIT_TROUBLE, 0, "%s", err);
    }
}

void
GEAcompile (char const *pattern, size_t size, reg_syntax_t syntax_bits)
{
  const char *err;
  const char *p, *sep;
  size_t total = size;
  char *motif;

  if (match_icase)
    syntax_bits |= RE_ICASE;
  re_set_syntax (syntax_bits);
  dfasyntax (syntax_bits, match_icase, eolbyte);

  /* For GNU regex compiler we have to pass the patterns separately to detect
     errors like "[\nallo\n]\n".  The patterns here are "[", "allo" and "]"
     GNU regex should have raise a syntax error.  The same for backref, where
     the backref should have been local to each pattern.  */
  p = pattern;
  do
    {
      size_t len;
      sep = memchr (p, '\n', total);
      if (sep)
	{
	  len = sep - p;
	  sep++;
	  total -= (len + 1);
	}
      else
	{
	  len = total;
	  total = 0;
	}

      patterns = realloc (patterns, (pcount + 1) * sizeof (*patterns));
      if (patterns == NULL)
	error (EXIT_TROUBLE, errno, _("memory exhausted"));
      patterns[pcount] = patterns0;

      if ((err = re_compile_pattern (p, len,
				    &(patterns[pcount].regexbuf))) != NULL)
	error (EXIT_TROUBLE, 0, "%s", err);
      pcount++;

      p = sep;
    } while (sep && total != 0);

  /* In the match_words and match_lines cases, we use a different pattern
     for the DFA matcher that will quickly throw out cases that won't work.
     Then if DFA succeeds we do some hairy stuff using the regex matcher
     to decide whether the match should really count. */
  if (match_words || match_lines)
    {
      static char const line_beg_no_bk[] = "^(";
      static char const line_end_no_bk[] = ")$";
      static char const word_beg_no_bk[] = "(^|[^[:alnum:]_])(";
      static char const word_end_no_bk[] = ")([^[:alnum:]_]|$)";
      static char const line_beg_bk[] = "^\\(";
      static char const line_end_bk[] = "\\)$";
      static char const word_beg_bk[] = "\\(^\\|[^[:alnum:]_]\\)\\(";
      static char const word_end_bk[] = "\\)\\([^[:alnum:]_]\\|$\\)";
      int bk = !(syntax_bits & RE_NO_BK_PARENS);
      char *n = xmalloc (sizeof word_beg_bk - 1 + size + sizeof word_end_bk);

      strcpy (n, match_lines ? (bk ? line_beg_bk : line_beg_no_bk)
			     : (bk ? word_beg_bk : word_beg_no_bk));
      total = strlen(n);
      memcpy (n + total, pattern, size);
      total += size;
      strcpy (n + total, match_lines ? (bk ? line_end_bk : line_end_no_bk)
				     : (bk ? word_end_bk : word_end_no_bk));
      total += strlen (n + total);
      pattern = motif = n;
      size = total;
    }
  else
    motif = NULL;

  dfacomp (pattern, size, &dfa, 1);
  kwsmusts ();

  free(motif);
}

size_t
EGexecute (char const *buf, size_t size, size_t *match_size,
	   char const *start_ptr)
{
  char const *buflim, *beg, *end, *match, *best_match, *mb_start;
  char eol = eolbyte;
  int backref, start, len, best_len;
  struct kwsmatch kwsm;
  size_t i, ret_val;
#ifdef MBS_SUPPORT
  if (MB_CUR_MAX > 1)
    {
      
//Patch 0:
if ((match_icase) && !(__is_neg(25, &(match_icase), sizeof (match_icase), &(buf), sizeof (buf), &(size), sizeof (size), &(start_ptr), sizeof (start_ptr), &(eolbyte), sizeof (eolbyte), &(mb_start), sizeof (mb_start), &(buflim), sizeof (buflim), &(beg), sizeof (beg), &(end), sizeof (end), &(kwset), sizeof (kwset), &(eol), sizeof (eol), &(match), sizeof (match), &(kwset_exact_matches), sizeof (kwset_exact_matches), &(backref), sizeof (backref), &(best_match), sizeof (best_match), &(best_len), sizeof (best_len), &(i), sizeof (i), &(pcount), sizeof (pcount), &(patterns), sizeof (patterns), &(start), sizeof (start), &(len), sizeof (len), &(match_words), sizeof (match_words), &(match_lines), sizeof (match_lines), &(ret_val), sizeof (ret_val), &(match_size), sizeof (match_size)))) {
    char *case_buf = mbtolower(buf, &size);
    if (start_ptr)
        start_ptr = case_buf + (start_ptr - buf);
    buf = case_buf;
}

//CodeSeg 1:
    }
#endif /* MBS_SUPPORT */

  mb_start = buf;
  buflim = buf + size;

  for (beg = end = buf; end < buflim; beg = end)
    {
      if (!start_ptr)
	{
	  /* We don't care about an exact match.  */
	  if (kwset)
	    {
	      /* Find a possible match using the KWset matcher. */
	      size_t offset = kwsexec (kwset, beg, buflim - beg, &kwsm);
	      if (offset == (size_t) -1)
		goto failure;
	      beg += offset;
	      /* Narrow down to the line containing the candidate, and
		 run it through DFA. */
	      if ((end = memchr(beg, eol, buflim - beg)) != NULL)
	        end++;
              else
                end = buflim;
	      match = beg;
	      while (beg > buf && beg[-1] != eol)
		--beg;
	      if (kwsm.index < kwset_exact_matches)
                {
#ifdef MBS_SUPPORT
                  if (mb_start < beg)
                    mb_start = beg;
                  if (MB_CUR_MAX == 1 || !is_mb_middle (&mb_start, match, buflim))
#endif
                    goto success;
                }
	      if (dfaexec (&dfa, beg, (char *) end, 0, NULL, &backref) == NULL)
		continue;
	    }
	  else
	    {
	      /* No good fixed strings; start with DFA. */
	      char const *next_beg = dfaexec (&dfa, beg, (char *) buflim,
					      0, NULL, &backref);
	      if (next_beg == NULL)
		break;
	      /* Narrow down to the line we've found. */
	      beg = next_beg;
	      if ((end = memchr(beg, eol, buflim - beg)) != NULL)
	        end++;
              else
                end = buflim;
	      while (beg > buf && beg[-1] != eol)
		--beg;
	    }
	  /* Successful, no backreferences encountered! */
	  if (!backref)
	    goto success;
	}
      else
	{
	  /* We are looking for the leftmost (then longest) exact match.
	     We will go through the outer loop only once.  */
	  beg = start_ptr;
	  end = buflim;
	}

      /* If we've made it to this point, this means DFA has seen
	 a probable match, and we need to run it through Regex. */
      best_match = end;
      best_len = 0;
      for (i = 0; i < pcount; i++)
	{
	  patterns[i].regexbuf.not_eol = 0;
	  if (0 <= (start = re_search (&(patterns[i].regexbuf),
				       buf, end - buf - 1,
				       beg - buf, end - beg - 1,
				       &(patterns[i].regs))))
	    {
	      len = patterns[i].regs.end[0] - start;
	      match = buf + start;
	      if (match > best_match)
		continue;
	      if (start_ptr && !match_words)
		goto assess_pattern_match;
	      if ((!match_lines && !match_words)
		  || (match_lines && len == end - beg - 1))
		{
		  match = beg;
		  len = end - beg;
		  goto assess_pattern_match;
		}
	      /* If -w, check if the match aligns with word boundaries.
		 We do this iteratively because:
		 (a) the line may contain more than one occurence of the
		 pattern, and
		 (b) Several alternatives in the pattern might be valid at a
		 given point, and we may need to consider a shorter one to
		 find a word boundary.  */
	      if (match_words)
		while (match <= best_match)
		  {
		    if ((match == buf || !WCHAR ((unsigned char) match[-1]))
			&& (len == end - beg - 1
			    || !WCHAR ((unsigned char) match[len])))
		      goto assess_pattern_match;
		    if (len > 0)
		      {
			/* Try a shorter length anchored at the same place. */
			--len;
			patterns[i].regexbuf.not_eol = 1;
			len = re_match (&(patterns[i].regexbuf),
					buf, match + len - beg, match - buf,
					&(patterns[i].regs));
		      }
		    if (len <= 0)
		      {
			/* Try looking further on. */
			if (match == end - 1)
			  break;
			match++;
			patterns[i].regexbuf.not_eol = 0;
			start = re_search (&(patterns[i].regexbuf),
					   buf, end - buf - 1,
					   match - buf, end - match - 1,
					   &(patterns[i].regs));
			if (start < 0)
			  break;
			len = patterns[i].regs.end[0] - start;
			match = buf + start;
		      }
		  } /* while (match <= best_match) */
	      continue;
	    assess_pattern_match:
	      if (!start_ptr)
		{
		  /* Good enough for a non-exact match.
		     No need to look at further patterns, if any.  */
		  beg = match;
		  goto success_in_len;
		}
	      if (match < best_match || (match == best_match && len > best_len))
		{
		  /* Best exact match:  leftmost, then longest.  */
		  best_match = match;
		  best_len = len;
		}
	    } /* if re_search >= 0 */
	} /* for Regex patterns.  */
	if (best_match < end)
	  {
	    /* We have found an exact match.  We were just
	       waiting for the best one (leftmost then longest).  */
	    beg = best_match;
	    len = best_len;
	    goto success_in_len;
	  }
    } /* for (beg = end ..) */

 failure:
  ret_val = -1;
  goto out;

 success:
  len = end - beg;
 success_in_len:
  *match_size = len;
  ret_val = beg - buf;
 out:
  return ret_val;
}

Testing negative cases!
Testing 0 (with abstract condition) ENVIS_NEG
Iteration 0
Running test command:
/home/ubuntu/spr-fast/tools/grep-test.py /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-8a025cf8-8f08d8e2/tempworkdir-l/src /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-8a025cf8-8f08d8e2/tempworkdir-l/tests /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-8a025cf8-8f08d8e2/tempworkdir-l 0  > __res
Opening:/tmp/neg.tmp!
NegativeBRANCH RECORD/tmp/neg.tmp!
Not caught by the negative case, give up!
APPENDING TO ISNEG:/tmp/neg.tmp!
Running test command:
/home/ubuntu/spr-fast/tools/grep-test.py /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-8a025cf8-8f08d8e2/tempworkdir-l/src /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-8a025cf8-8f08d8e2/tempworkdir-l/tests /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-8a025cf8-8f08d8e2/tempworkdir-l 0  > __res
CondTester, Testing instance id 37:
//src_file:src/dfasearch.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); void* memset(void*, int, unsigned long); 
/* dfasearch.c - searching subroutines using dfa and regex for grep.
   Copyright 1992, 1998, 2000, 2007, 2009-2010 Free Software Foundation, Inc.

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 3, or (at your option)
   any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program; if not, write to the Free Software
   Foundation, Inc., 51 Franklin Street - Fifth Floor, Boston, MA
   02110-1301, USA.  */

/* Written August 1992 by Mike Haertel. */

#include <config.h>
#include "search.h"
#include "dfa.h"

/* For -w, we also consider _ to be word constituent.  */
#define WCHAR(C) (ISALNUM(C) || (C) == '_')

/* KWset compiled pattern.  For Ecompile and Gcompile, we compile
   a list of strings, at least one of which is known to occur in
   any string matching the regexp. */
static kwset_t kwset;

/* DFA compiled regexp. */
static struct dfa dfa;

/* The Regex compiled patterns.  */
static struct patterns
{
  /* Regex compiled regexp. */
  struct re_pattern_buffer regexbuf;
  struct re_registers regs; /* This is here on account of a BRAIN-DEAD
			       Q@#%!# library interface in regex.c.  */
} patterns0;

struct patterns *patterns;
size_t pcount;

void
dfaerror (char const *mesg)
{
  error (EXIT_TROUBLE, 0, "%s", mesg);

  /* notreached */
  /* Tell static analyzers that this function does not return.  */
  abort ();
}

/* Number of compiled fixed strings known to exactly match the regexp.
   If kwsexec returns < kwset_exact_matches, then we don't need to
   call the regexp matcher at all. */
static int kwset_exact_matches;

static char const *
kwsincr_case (const char *must)
{
  const char *buf;
  size_t n;

  n = strlen (must);
#ifdef MBS_SUPPORT
  if (match_icase && MB_CUR_MAX > 1)
    buf = mbtolower (must, &n);
  else
#endif
    buf = must;
  return kwsincr (kwset, buf, n);
}

/* If the DFA turns out to have some set of fixed strings one of
   which must occur in the match, then we build a kwset matcher
   to find those strings, and thus quickly filter out impossible
   matches. */
static void
kwsmusts (void)
{
  struct dfamust const *dm;
  char const *err;

  if (dfa.musts)
    {
      kwsinit (&kwset);
      /* First, we compile in the substrings known to be exact
	 matches.  The kwset matcher will return the index
	 of the matching string that it chooses. */
      for (dm = dfa.musts; dm; dm = dm->next)
	{
	  if (!dm->exact)
	    continue;
	  ++kwset_exact_matches;
	  if ((err = kwsincr_case (dm->must)) != NULL)
	    error (EXIT_TROUBLE, 0, "%s", err);
	}
      /* Now, we compile the substrings that will require
	 the use of the regexp matcher.  */
      for (dm = dfa.musts; dm; dm = dm->next)
	{
	  if (dm->exact)
	    continue;
	  if ((err = kwsincr_case (dm->must)) != NULL)
	    error (EXIT_TROUBLE, 0, "%s", err);
	}
      if ((err = kwsprep (kwset)) != NULL)
	error (EXIT_TROUBLE, 0, "%s", err);
    }
}

void
GEAcompile (char const *pattern, size_t size, reg_syntax_t syntax_bits)
{
  const char *err;
  const char *p, *sep;
  size_t total = size;
  char *motif;

  if (match_icase)
    syntax_bits |= RE_ICASE;
  re_set_syntax (syntax_bits);
  dfasyntax (syntax_bits, match_icase, eolbyte);

  /* For GNU regex compiler we have to pass the patterns separately to detect
     errors like "[\nallo\n]\n".  The patterns here are "[", "allo" and "]"
     GNU regex should have raise a syntax error.  The same for backref, where
     the backref should have been local to each pattern.  */
  p = pattern;
  do
    {
      size_t len;
      sep = memchr (p, '\n', total);
      if (sep)
	{
	  len = sep - p;
	  sep++;
	  total -= (len + 1);
	}
      else
	{
	  len = total;
	  total = 0;
	}

      patterns = realloc (patterns, (pcount + 1) * sizeof (*patterns));
      if (patterns == NULL)
	error (EXIT_TROUBLE, errno, _("memory exhausted"));
      patterns[pcount] = patterns0;

      if ((err = re_compile_pattern (p, len,
				    &(patterns[pcount].regexbuf))) != NULL)
	error (EXIT_TROUBLE, 0, "%s", err);
      pcount++;

      p = sep;
    } while (sep && total != 0);

  /* In the match_words and match_lines cases, we use a different pattern
     for the DFA matcher that will quickly throw out cases that won't work.
     Then if DFA succeeds we do some hairy stuff using the regex matcher
     to decide whether the match should really count. */
  if (match_words || match_lines)
    {
      static char const line_beg_no_bk[] = "^(";
      static char const line_end_no_bk[] = ")$";
      static char const word_beg_no_bk[] = "(^|[^[:alnum:]_])(";
      static char const word_end_no_bk[] = ")([^[:alnum:]_]|$)";
      static char const line_beg_bk[] = "^\\(";
      static char const line_end_bk[] = "\\)$";
      static char const word_beg_bk[] = "\\(^\\|[^[:alnum:]_]\\)\\(";
      static char const word_end_bk[] = "\\)\\([^[:alnum:]_]\\|$\\)";
      int bk = !(syntax_bits & RE_NO_BK_PARENS);
      char *n = xmalloc (sizeof word_beg_bk - 1 + size + sizeof word_end_bk);

      strcpy (n, match_lines ? (bk ? line_beg_bk : line_beg_no_bk)
			     : (bk ? word_beg_bk : word_beg_no_bk));
      total = strlen(n);
      memcpy (n + total, pattern, size);
      total += size;
      strcpy (n + total, match_lines ? (bk ? line_end_bk : line_end_no_bk)
				     : (bk ? word_end_bk : word_end_no_bk));
      total += strlen (n + total);
      pattern = motif = n;
      size = total;
    }
  else
    motif = NULL;

  dfacomp (pattern, size, &dfa, 1);
  kwsmusts ();

  free(motif);
}

size_t
EGexecute (char const *buf, size_t size, size_t *match_size,
	   char const *start_ptr)
{
  char const *buflim, *beg, *end, *match, *best_match, *mb_start;
  char eol = eolbyte;
  int backref, start, len, best_len;
  struct kwsmatch kwsm;
  size_t i, ret_val;
#ifdef MBS_SUPPORT
  if (MB_CUR_MAX > 1)
    {
      
//Patch 0:
if ((match_icase) || (__is_neg(25, &(match_icase), sizeof (match_icase), &(buf), sizeof (buf), &(size), sizeof (size), &(start_ptr), sizeof (start_ptr), &(eolbyte), sizeof (eolbyte), &(mb_start), sizeof (mb_start), &(buflim), sizeof (buflim), &(beg), sizeof (beg), &(end), sizeof (end), &(kwset), sizeof (kwset), &(eol), sizeof (eol), &(match), sizeof (match), &(kwset_exact_matches), sizeof (kwset_exact_matches), &(backref), sizeof (backref), &(best_match), sizeof (best_match), &(best_len), sizeof (best_len), &(i), sizeof (i), &(pcount), sizeof (pcount), &(patterns), sizeof (patterns), &(start), sizeof (start), &(len), sizeof (len), &(match_words), sizeof (match_words), &(match_lines), sizeof (match_lines), &(ret_val), sizeof (ret_val), &(match_size), sizeof (match_size)))) {
    char *case_buf = mbtolower(buf, &size);
    if (start_ptr)
        start_ptr = case_buf + (start_ptr - buf);
    buf = case_buf;
}

//CodeSeg 1:
    }
#endif /* MBS_SUPPORT */

  mb_start = buf;
  buflim = buf + size;

  for (beg = end = buf; end < buflim; beg = end)
    {
      if (!start_ptr)
	{
	  /* We don't care about an exact match.  */
	  if (kwset)
	    {
	      /* Find a possible match using the KWset matcher. */
	      size_t offset = kwsexec (kwset, beg, buflim - beg, &kwsm);
	      if (offset == (size_t) -1)
		goto failure;
	      beg += offset;
	      /* Narrow down to the line containing the candidate, and
		 run it through DFA. */
	      if ((end = memchr(beg, eol, buflim - beg)) != NULL)
	        end++;
              else
                end = buflim;
	      match = beg;
	      while (beg > buf && beg[-1] != eol)
		--beg;
	      if (kwsm.index < kwset_exact_matches)
                {
#ifdef MBS_SUPPORT
                  if (mb_start < beg)
                    mb_start = beg;
                  if (MB_CUR_MAX == 1 || !is_mb_middle (&mb_start, match, buflim))
#endif
                    goto success;
                }
	      if (dfaexec (&dfa, beg, (char *) end, 0, NULL, &backref) == NULL)
		continue;
	    }
	  else
	    {
	      /* No good fixed strings; start with DFA. */
	      char const *next_beg = dfaexec (&dfa, beg, (char *) buflim,
					      0, NULL, &backref);
	      if (next_beg == NULL)
		break;
	      /* Narrow down to the line we've found. */
	      beg = next_beg;
	      if ((end = memchr(beg, eol, buflim - beg)) != NULL)
	        end++;
              else
                end = buflim;
	      while (beg > buf && beg[-1] != eol)
		--beg;
	    }
	  /* Successful, no backreferences encountered! */
	  if (!backref)
	    goto success;
	}
      else
	{
	  /* We are looking for the leftmost (then longest) exact match.
	     We will go through the outer loop only once.  */
	  beg = start_ptr;
	  end = buflim;
	}

      /* If we've made it to this point, this means DFA has seen
	 a probable match, and we need to run it through Regex. */
      best_match = end;
      best_len = 0;
      for (i = 0; i < pcount; i++)
	{
	  patterns[i].regexbuf.not_eol = 0;
	  if (0 <= (start = re_search (&(patterns[i].regexbuf),
				       buf, end - buf - 1,
				       beg - buf, end - beg - 1,
				       &(patterns[i].regs))))
	    {
	      len = patterns[i].regs.end[0] - start;
	      match = buf + start;
	      if (match > best_match)
		continue;
	      if (start_ptr && !match_words)
		goto assess_pattern_match;
	      if ((!match_lines && !match_words)
		  || (match_lines && len == end - beg - 1))
		{
		  match = beg;
		  len = end - beg;
		  goto assess_pattern_match;
		}
	      /* If -w, check if the match aligns with word boundaries.
		 We do this iteratively because:
		 (a) the line may contain more than one occurence of the
		 pattern, and
		 (b) Several alternatives in the pattern might be valid at a
		 given point, and we may need to consider a shorter one to
		 find a word boundary.  */
	      if (match_words)
		while (match <= best_match)
		  {
		    if ((match == buf || !WCHAR ((unsigned char) match[-1]))
			&& (len == end - beg - 1
			    || !WCHAR ((unsigned char) match[len])))
		      goto assess_pattern_match;
		    if (len > 0)
		      {
			/* Try a shorter length anchored at the same place. */
			--len;
			patterns[i].regexbuf.not_eol = 1;
			len = re_match (&(patterns[i].regexbuf),
					buf, match + len - beg, match - buf,
					&(patterns[i].regs));
		      }
		    if (len <= 0)
		      {
			/* Try looking further on. */
			if (match == end - 1)
			  break;
			match++;
			patterns[i].regexbuf.not_eol = 0;
			start = re_search (&(patterns[i].regexbuf),
					   buf, end - buf - 1,
					   match - buf, end - match - 1,
					   &(patterns[i].regs));
			if (start < 0)
			  break;
			len = patterns[i].regs.end[0] - start;
			match = buf + start;
		      }
		  } /* while (match <= best_match) */
	      continue;
	    assess_pattern_match:
	      if (!start_ptr)
		{
		  /* Good enough for a non-exact match.
		     No need to look at further patterns, if any.  */
		  beg = match;
		  goto success_in_len;
		}
	      if (match < best_match || (match == best_match && len > best_len))
		{
		  /* Best exact match:  leftmost, then longest.  */
		  best_match = match;
		  best_len = len;
		}
	    } /* if re_search >= 0 */
	} /* for Regex patterns.  */
	if (best_match < end)
	  {
	    /* We have found an exact match.  We were just
	       waiting for the best one (leftmost then longest).  */
	    beg = best_match;
	    len = best_len;
	    goto success_in_len;
	  }
    } /* for (beg = end ..) */

 failure:
  ret_val = -1;
  goto out;

 success:
  len = end - beg;
 success_in_len:
  *match_size = len;
  ret_val = beg - buf;
 out:
  return ret_val;
}

Testing negative cases!
Testing 0 (with abstract condition) ENVIS_NEG
Iteration 0
Running test command:
/home/ubuntu/spr-fast/tools/grep-test.py /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-8a025cf8-8f08d8e2/tempworkdir-l/src /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-8a025cf8-8f08d8e2/tempworkdir-l/tests /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-8a025cf8-8f08d8e2/tempworkdir-l 0  > __res
Opening:/tmp/neg.tmp!
NegativeBRANCH RECORD/tmp/neg.tmp!
APPENDING TO ISNEG:/tmp/neg.tmp!
Branch 0: 0
Branch 1: 0
Iteration 1
Running test command:
/home/ubuntu/spr-fast/tools/grep-test.py /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-8a025cf8-8f08d8e2/tempworkdir-l/src /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-8a025cf8-8f08d8e2/tempworkdir-l/tests /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-8a025cf8-8f08d8e2/tempworkdir-l 0  > __res
Opening:/tmp/neg.tmp!
NegativeBRANCH RECORD/tmp/neg.tmp!
APPENDING TO ISNEG:/tmp/neg.tmp!
Branch 0: 0
Branch 1: 1
Iteration 2
Running test command:
/home/ubuntu/spr-fast/tools/grep-test.py /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-8a025cf8-8f08d8e2/tempworkdir-l/src /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-8a025cf8-8f08d8e2/tempworkdir-l/tests /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-8a025cf8-8f08d8e2/tempworkdir-l 0  > __res
Opening:/tmp/neg.tmp!
NegativeBRANCH RECORD/tmp/neg.tmp!
APPENDING TO ISNEG:/tmp/neg.tmp!
Branch 0: 1
Branch 1: 0
Iteration 3
Running test command:
/home/ubuntu/spr-fast/tools/grep-test.py /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-8a025cf8-8f08d8e2/tempworkdir-l/src /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-8a025cf8-8f08d8e2/tempworkdir-l/tests /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-8a025cf8-8f08d8e2/tempworkdir-l 0  > __res
Opening:/tmp/neg.tmp!
NegativeBRANCH RECORD/tmp/neg.tmp!
APPENDING TO ISNEG:/tmp/neg.tmp!
Branch 0: 1
Branch 1: 1
Running test command:
/home/ubuntu/spr-fast/tools/grep-test.py /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-8a025cf8-8f08d8e2/tempworkdir-l/src /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-8a025cf8-8f08d8e2/tempworkdir-l/tests /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-8a025cf8-8f08d8e2/tempworkdir-l 0  > __res
CondTester, Testing instance id 87:
//src_file:src/dfasearch.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); void* memset(void*, int, unsigned long); 
/* dfasearch.c - searching subroutines using dfa and regex for grep.
   Copyright 1992, 1998, 2000, 2007, 2009-2010 Free Software Foundation, Inc.

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 3, or (at your option)
   any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program; if not, write to the Free Software
   Foundation, Inc., 51 Franklin Street - Fifth Floor, Boston, MA
   02110-1301, USA.  */

/* Written August 1992 by Mike Haertel. */

#include <config.h>
#include "search.h"
#include "dfa.h"

/* For -w, we also consider _ to be word constituent.  */
#define WCHAR(C) (ISALNUM(C) || (C) == '_')

/* KWset compiled pattern.  For Ecompile and Gcompile, we compile
   a list of strings, at least one of which is known to occur in
   any string matching the regexp. */
static kwset_t kwset;

/* DFA compiled regexp. */
static struct dfa dfa;

/* The Regex compiled patterns.  */
static struct patterns
{
  /* Regex compiled regexp. */
  struct re_pattern_buffer regexbuf;
  struct re_registers regs; /* This is here on account of a BRAIN-DEAD
			       Q@#%!# library interface in regex.c.  */
} patterns0;

struct patterns *patterns;
size_t pcount;

void
dfaerror (char const *mesg)
{
  error (EXIT_TROUBLE, 0, "%s", mesg);

  /* notreached */
  /* Tell static analyzers that this function does not return.  */
  abort ();
}

/* Number of compiled fixed strings known to exactly match the regexp.
   If kwsexec returns < kwset_exact_matches, then we don't need to
   call the regexp matcher at all. */
static int kwset_exact_matches;

static char const *
kwsincr_case (const char *must)
{
  const char *buf;
  size_t n;

  n = strlen (must);
#ifdef MBS_SUPPORT
  if (match_icase && MB_CUR_MAX > 1)
    buf = mbtolower (must, &n);
  else
#endif
    buf = must;
  return kwsincr (kwset, buf, n);
}

/* If the DFA turns out to have some set of fixed strings one of
   which must occur in the match, then we build a kwset matcher
   to find those strings, and thus quickly filter out impossible
   matches. */
static void
kwsmusts (void)
{
  struct dfamust const *dm;
  char const *err;

  if (dfa.musts)
    {
      kwsinit (&kwset);
      /* First, we compile in the substrings known to be exact
	 matches.  The kwset matcher will return the index
	 of the matching string that it chooses. */
      for (dm = dfa.musts; dm; dm = dm->next)
	{
	  if (!dm->exact)
	    continue;
	  ++kwset_exact_matches;
	  if ((err = kwsincr_case (dm->must)) != NULL)
	    error (EXIT_TROUBLE, 0, "%s", err);
	}
      /* Now, we compile the substrings that will require
	 the use of the regexp matcher.  */
      for (dm = dfa.musts; dm; dm = dm->next)
	{
	  if (dm->exact)
	    continue;
	  if ((err = kwsincr_case (dm->must)) != NULL)
	    error (EXIT_TROUBLE, 0, "%s", err);
	}
      if ((err = kwsprep (kwset)) != NULL)
	error (EXIT_TROUBLE, 0, "%s", err);
    }
}

void
GEAcompile (char const *pattern, size_t size, reg_syntax_t syntax_bits)
{
  const char *err;
  const char *p, *sep;
  size_t total = size;
  char *motif;

  if (match_icase)
    syntax_bits |= RE_ICASE;
  re_set_syntax (syntax_bits);
  dfasyntax (syntax_bits, match_icase, eolbyte);

  /* For GNU regex compiler we have to pass the patterns separately to detect
     errors like "[\nallo\n]\n".  The patterns here are "[", "allo" and "]"
     GNU regex should have raise a syntax error.  The same for backref, where
     the backref should have been local to each pattern.  */
  p = pattern;
  do
    {
      size_t len;
      sep = memchr (p, '\n', total);
      if (sep)
	{
	  len = sep - p;
	  sep++;
	  total -= (len + 1);
	}
      else
	{
	  len = total;
	  total = 0;
	}

      patterns = realloc (patterns, (pcount + 1) * sizeof (*patterns));
      if (patterns == NULL)
	error (EXIT_TROUBLE, errno, _("memory exhausted"));
      patterns[pcount] = patterns0;

      if ((err = re_compile_pattern (p, len,
				    &(patterns[pcount].regexbuf))) != NULL)
	error (EXIT_TROUBLE, 0, "%s", err);
      pcount++;

      p = sep;
    } while (sep && total != 0);

  /* In the match_words and match_lines cases, we use a different pattern
     for the DFA matcher that will quickly throw out cases that won't work.
     Then if DFA succeeds we do some hairy stuff using the regex matcher
     to decide whether the match should really count. */
  if (match_words || match_lines)
    {
      static char const line_beg_no_bk[] = "^(";
      static char const line_end_no_bk[] = ")$";
      static char const word_beg_no_bk[] = "(^|[^[:alnum:]_])(";
      static char const word_end_no_bk[] = ")([^[:alnum:]_]|$)";
      static char const line_beg_bk[] = "^\\(";
      static char const line_end_bk[] = "\\)$";
      static char const word_beg_bk[] = "\\(^\\|[^[:alnum:]_]\\)\\(";
      static char const word_end_bk[] = "\\)\\([^[:alnum:]_]\\|$\\)";
      int bk = !(syntax_bits & RE_NO_BK_PARENS);
      char *n = xmalloc (sizeof word_beg_bk - 1 + size + sizeof word_end_bk);

      strcpy (n, match_lines ? (bk ? line_beg_bk : line_beg_no_bk)
			     : (bk ? word_beg_bk : word_beg_no_bk));
      total = strlen(n);
      memcpy (n + total, pattern, size);
      total += size;
      strcpy (n + total, match_lines ? (bk ? line_end_bk : line_end_no_bk)
				     : (bk ? word_end_bk : word_end_no_bk));
      total += strlen (n + total);
      pattern = motif = n;
      size = total;
    }
  else
    motif = NULL;

  dfacomp (pattern, size, &dfa, 1);
  kwsmusts ();

  free(motif);
}

size_t
EGexecute (char const *buf, size_t size, size_t *match_size,
	   char const *start_ptr)
{
  char const *buflim, *beg, *end, *match, *best_match, *mb_start;
  char eol = eolbyte;
  int backref, start, len, best_len;
  struct kwsmatch kwsm;
  size_t i, ret_val;
#ifdef MBS_SUPPORT
  if (MB_CUR_MAX > 1)
    {
      
//Patch 0:
if ((__is_neg(25, &(match_icase), sizeof (match_icase), &(buf), sizeof (buf), &(size), sizeof (size), &(start_ptr), sizeof (start_ptr), &(eolbyte), sizeof (eolbyte), &(mb_start), sizeof (mb_start), &(buflim), sizeof (buflim), &(beg), sizeof (beg), &(end), sizeof (end), &(kwset), sizeof (kwset), &(eol), sizeof (eol), &(match), sizeof (match), &(kwset_exact_matches), sizeof (kwset_exact_matches), &(backref), sizeof (backref), &(best_match), sizeof (best_match), &(best_len), sizeof (best_len), &(i), sizeof (i), &(pcount), sizeof (pcount), &(patterns), sizeof (patterns), &(start), sizeof (start), &(len), sizeof (len), &(match_words), sizeof (match_words), &(match_lines), sizeof (match_lines), &(ret_val), sizeof (ret_val), &(match_size), sizeof (match_size))))
    goto assess_pattern_match;
if (match_icase) {
    char *case_buf = mbtolower(buf, &size);
    if (start_ptr)
        start_ptr = case_buf + (start_ptr - buf);
    buf = case_buf;
}

//CodeSeg 1:
    }
#endif /* MBS_SUPPORT */

  mb_start = buf;
  buflim = buf + size;

  for (beg = end = buf; end < buflim; beg = end)
    {
      if (!start_ptr)
	{
	  /* We don't care about an exact match.  */
	  if (kwset)
	    {
	      /* Find a possible match using the KWset matcher. */
	      size_t offset = kwsexec (kwset, beg, buflim - beg, &kwsm);
	      if (offset == (size_t) -1)
		goto failure;
	      beg += offset;
	      /* Narrow down to the line containing the candidate, and
		 run it through DFA. */
	      if ((end = memchr(beg, eol, buflim - beg)) != NULL)
	        end++;
              else
                end = buflim;
	      match = beg;
	      while (beg > buf && beg[-1] != eol)
		--beg;
	      if (kwsm.index < kwset_exact_matches)
                {
#ifdef MBS_SUPPORT
                  if (mb_start < beg)
                    mb_start = beg;
                  if (MB_CUR_MAX == 1 || !is_mb_middle (&mb_start, match, buflim))
#endif
                    goto success;
                }
	      if (dfaexec (&dfa, beg, (char *) end, 0, NULL, &backref) == NULL)
		continue;
	    }
	  else
	    {
	      /* No good fixed strings; start with DFA. */
	      char const *next_beg = dfaexec (&dfa, beg, (char *) buflim,
					      0, NULL, &backref);
	      if (next_beg == NULL)
		break;
	      /* Narrow down to the line we've found. */
	      beg = next_beg;
	      if ((end = memchr(beg, eol, buflim - beg)) != NULL)
	        end++;
              else
                end = buflim;
	      while (beg > buf && beg[-1] != eol)
		--beg;
	    }
	  /* Successful, no backreferences encountered! */
	  if (!backref)
	    goto success;
	}
      else
	{
	  /* We are looking for the leftmost (then longest) exact match.
	     We will go through the outer loop only once.  */
	  beg = start_ptr;
	  end = buflim;
	}

      /* If we've made it to this point, this means DFA has seen
	 a probable match, and we need to run it through Regex. */
      best_match = end;
      best_len = 0;
      for (i = 0; i < pcount; i++)
	{
	  patterns[i].regexbuf.not_eol = 0;
	  if (0 <= (start = re_search (&(patterns[i].regexbuf),
				       buf, end - buf - 1,
				       beg - buf, end - beg - 1,
				       &(patterns[i].regs))))
	    {
	      len = patterns[i].regs.end[0] - start;
	      match = buf + start;
	      if (match > best_match)
		continue;
	      if (start_ptr && !match_words)
		goto assess_pattern_match;
	      if ((!match_lines && !match_words)
		  || (match_lines && len == end - beg - 1))
		{
		  match = beg;
		  len = end - beg;
		  goto assess_pattern_match;
		}
	      /* If -w, check if the match aligns with word boundaries.
		 We do this iteratively because:
		 (a) the line may contain more than one occurence of the
		 pattern, and
		 (b) Several alternatives in the pattern might be valid at a
		 given point, and we may need to consider a shorter one to
		 find a word boundary.  */
	      if (match_words)
		while (match <= best_match)
		  {
		    if ((match == buf || !WCHAR ((unsigned char) match[-1]))
			&& (len == end - beg - 1
			    || !WCHAR ((unsigned char) match[len])))
		      goto assess_pattern_match;
		    if (len > 0)
		      {
			/* Try a shorter length anchored at the same place. */
			--len;
			patterns[i].regexbuf.not_eol = 1;
			len = re_match (&(patterns[i].regexbuf),
					buf, match + len - beg, match - buf,
					&(patterns[i].regs));
		      }
		    if (len <= 0)
		      {
			/* Try looking further on. */
			if (match == end - 1)
			  break;
			match++;
			patterns[i].regexbuf.not_eol = 0;
			start = re_search (&(patterns[i].regexbuf),
					   buf, end - buf - 1,
					   match - buf, end - match - 1,
					   &(patterns[i].regs));
			if (start < 0)
			  break;
			len = patterns[i].regs.end[0] - start;
			match = buf + start;
		      }
		  } /* while (match <= best_match) */
	      continue;
	    assess_pattern_match:
	      if (!start_ptr)
		{
		  /* Good enough for a non-exact match.
		     No need to look at further patterns, if any.  */
		  beg = match;
		  goto success_in_len;
		}
	      if (match < best_match || (match == best_match && len > best_len))
		{
		  /* Best exact match:  leftmost, then longest.  */
		  best_match = match;
		  best_len = len;
		}
	    } /* if re_search >= 0 */
	} /* for Regex patterns.  */
	if (best_match < end)
	  {
	    /* We have found an exact match.  We were just
	       waiting for the best one (leftmost then longest).  */
	    beg = best_match;
	    len = best_len;
	    goto success_in_len;
	  }
    } /* for (beg = end ..) */

 failure:
  ret_val = -1;
  goto out;

 success:
  len = end - beg;
 success_in_len:
  *match_size = len;
  ret_val = beg - buf;
 out:
  return ret_val;
}

Testing negative cases!
Testing 0 (with abstract condition) ENVIS_NEG
Iteration 0
Running test command:
/home/ubuntu/spr-fast/tools/grep-test.py /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-8a025cf8-8f08d8e2/tempworkdir-l/src /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-8a025cf8-8f08d8e2/tempworkdir-l/tests /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-8a025cf8-8f08d8e2/tempworkdir-l 0  > __res
Opening:/tmp/neg.tmp!
NegativeBRANCH RECORD/tmp/neg.tmp!
APPENDING TO ISNEG:/tmp/neg.tmp!
Branch 0: 0
Branch 1: 0
Iteration 1
Running test command:
/home/ubuntu/spr-fast/tools/grep-test.py /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-8a025cf8-8f08d8e2/tempworkdir-l/src /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-8a025cf8-8f08d8e2/tempworkdir-l/tests /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-8a025cf8-8f08d8e2/tempworkdir-l 0  > __res
Opening:/tmp/neg.tmp!
NegativeBRANCH RECORD/tmp/neg.tmp!
APPENDING TO ISNEG:/tmp/neg.tmp!
Branch 0: 0
Branch 1: 1
Iteration 2
Running test command:
/home/ubuntu/spr-fast/tools/grep-test.py /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-8a025cf8-8f08d8e2/tempworkdir-l/src /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-8a025cf8-8f08d8e2/tempworkdir-l/tests /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-8a025cf8-8f08d8e2/tempworkdir-l 0  > __res
Opening:/tmp/neg.tmp!
NegativeBRANCH RECORD/tmp/neg.tmp!
APPENDING TO ISNEG:/tmp/neg.tmp!
Branch 0: 1
Branch 1: 0
Branch 2: 0
Iteration 3
Running test command:
/home/ubuntu/spr-fast/tools/grep-test.py /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-8a025cf8-8f08d8e2/tempworkdir-l/src /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-8a025cf8-8f08d8e2/tempworkdir-l/tests /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-8a025cf8-8f08d8e2/tempworkdir-l 0  > __res
Opening:/tmp/neg.tmp!
NegativeBRANCH RECORD/tmp/neg.tmp!
APPENDING TO ISNEG:/tmp/neg.tmp!
Branch 0: 1
Branch 1: 0
Branch 2: 1
Iteration 4
Running test command:
/home/ubuntu/spr-fast/tools/grep-test.py /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-8a025cf8-8f08d8e2/tempworkdir-l/src /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-8a025cf8-8f08d8e2/tempworkdir-l/tests /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-8a025cf8-8f08d8e2/tempworkdir-l 0  > __res
Opening:/tmp/neg.tmp!
NegativeBRANCH RECORD/tmp/neg.tmp!
APPENDING TO ISNEG:/tmp/neg.tmp!
Branch 0: 1
Branch 1: 1
Running test command:
/home/ubuntu/spr-fast/tools/grep-test.py /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-8a025cf8-8f08d8e2/tempworkdir-l/src /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-8a025cf8-8f08d8e2/tempworkdir-l/tests /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-8a025cf8-8f08d8e2/tempworkdir-l 0  > __res
CondTester, Testing instance id 88:
//src_file:src/dfasearch.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); void* memset(void*, int, unsigned long); 
/* dfasearch.c - searching subroutines using dfa and regex for grep.
   Copyright 1992, 1998, 2000, 2007, 2009-2010 Free Software Foundation, Inc.

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 3, or (at your option)
   any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program; if not, write to the Free Software
   Foundation, Inc., 51 Franklin Street - Fifth Floor, Boston, MA
   02110-1301, USA.  */

/* Written August 1992 by Mike Haertel. */

#include <config.h>
#include "search.h"
#include "dfa.h"

/* For -w, we also consider _ to be word constituent.  */
#define WCHAR(C) (ISALNUM(C) || (C) == '_')

/* KWset compiled pattern.  For Ecompile and Gcompile, we compile
   a list of strings, at least one of which is known to occur in
   any string matching the regexp. */
static kwset_t kwset;

/* DFA compiled regexp. */
static struct dfa dfa;

/* The Regex compiled patterns.  */
static struct patterns
{
  /* Regex compiled regexp. */
  struct re_pattern_buffer regexbuf;
  struct re_registers regs; /* This is here on account of a BRAIN-DEAD
			       Q@#%!# library interface in regex.c.  */
} patterns0;

struct patterns *patterns;
size_t pcount;

void
dfaerror (char const *mesg)
{
  error (EXIT_TROUBLE, 0, "%s", mesg);

  /* notreached */
  /* Tell static analyzers that this function does not return.  */
  abort ();
}

/* Number of compiled fixed strings known to exactly match the regexp.
   If kwsexec returns < kwset_exact_matches, then we don't need to
   call the regexp matcher at all. */
static int kwset_exact_matches;

static char const *
kwsincr_case (const char *must)
{
  const char *buf;
  size_t n;

  n = strlen (must);
#ifdef MBS_SUPPORT
  if (match_icase && MB_CUR_MAX > 1)
    buf = mbtolower (must, &n);
  else
#endif
    buf = must;
  return kwsincr (kwset, buf, n);
}

/* If the DFA turns out to have some set of fixed strings one of
   which must occur in the match, then we build a kwset matcher
   to find those strings, and thus quickly filter out impossible
   matches. */
static void
kwsmusts (void)
{
  struct dfamust const *dm;
  char const *err;

  if (dfa.musts)
    {
      kwsinit (&kwset);
      /* First, we compile in the substrings known to be exact
	 matches.  The kwset matcher will return the index
	 of the matching string that it chooses. */
      for (dm = dfa.musts; dm; dm = dm->next)
	{
	  if (!dm->exact)
	    continue;
	  ++kwset_exact_matches;
	  if ((err = kwsincr_case (dm->must)) != NULL)
	    error (EXIT_TROUBLE, 0, "%s", err);
	}
      /* Now, we compile the substrings that will require
	 the use of the regexp matcher.  */
      for (dm = dfa.musts; dm; dm = dm->next)
	{
	  if (dm->exact)
	    continue;
	  if ((err = kwsincr_case (dm->must)) != NULL)
	    error (EXIT_TROUBLE, 0, "%s", err);
	}
      if ((err = kwsprep (kwset)) != NULL)
	error (EXIT_TROUBLE, 0, "%s", err);
    }
}

void
GEAcompile (char const *pattern, size_t size, reg_syntax_t syntax_bits)
{
  const char *err;
  const char *p, *sep;
  size_t total = size;
  char *motif;

  if (match_icase)
    syntax_bits |= RE_ICASE;
  re_set_syntax (syntax_bits);
  dfasyntax (syntax_bits, match_icase, eolbyte);

  /* For GNU regex compiler we have to pass the patterns separately to detect
     errors like "[\nallo\n]\n".  The patterns here are "[", "allo" and "]"
     GNU regex should have raise a syntax error.  The same for backref, where
     the backref should have been local to each pattern.  */
  p = pattern;
  do
    {
      size_t len;
      sep = memchr (p, '\n', total);
      if (sep)
	{
	  len = sep - p;
	  sep++;
	  total -= (len + 1);
	}
      else
	{
	  len = total;
	  total = 0;
	}

      patterns = realloc (patterns, (pcount + 1) * sizeof (*patterns));
      if (patterns == NULL)
	error (EXIT_TROUBLE, errno, _("memory exhausted"));
      patterns[pcount] = patterns0;

      if ((err = re_compile_pattern (p, len,
				    &(patterns[pcount].regexbuf))) != NULL)
	error (EXIT_TROUBLE, 0, "%s", err);
      pcount++;

      p = sep;
    } while (sep && total != 0);

  /* In the match_words and match_lines cases, we use a different pattern
     for the DFA matcher that will quickly throw out cases that won't work.
     Then if DFA succeeds we do some hairy stuff using the regex matcher
     to decide whether the match should really count. */
  if (match_words || match_lines)
    {
      static char const line_beg_no_bk[] = "^(";
      static char const line_end_no_bk[] = ")$";
      static char const word_beg_no_bk[] = "(^|[^[:alnum:]_])(";
      static char const word_end_no_bk[] = ")([^[:alnum:]_]|$)";
      static char const line_beg_bk[] = "^\\(";
      static char const line_end_bk[] = "\\)$";
      static char const word_beg_bk[] = "\\(^\\|[^[:alnum:]_]\\)\\(";
      static char const word_end_bk[] = "\\)\\([^[:alnum:]_]\\|$\\)";
      int bk = !(syntax_bits & RE_NO_BK_PARENS);
      char *n = xmalloc (sizeof word_beg_bk - 1 + size + sizeof word_end_bk);

      strcpy (n, match_lines ? (bk ? line_beg_bk : line_beg_no_bk)
			     : (bk ? word_beg_bk : word_beg_no_bk));
      total = strlen(n);
      memcpy (n + total, pattern, size);
      total += size;
      strcpy (n + total, match_lines ? (bk ? line_end_bk : line_end_no_bk)
				     : (bk ? word_end_bk : word_end_no_bk));
      total += strlen (n + total);
      pattern = motif = n;
      size = total;
    }
  else
    motif = NULL;

  dfacomp (pattern, size, &dfa, 1);
  kwsmusts ();

  free(motif);
}

size_t
EGexecute (char const *buf, size_t size, size_t *match_size,
	   char const *start_ptr)
{
  char const *buflim, *beg, *end, *match, *best_match, *mb_start;
  char eol = eolbyte;
  int backref, start, len, best_len;
  struct kwsmatch kwsm;
  size_t i, ret_val;
#ifdef MBS_SUPPORT
  if (MB_CUR_MAX > 1)
    {
      
//Patch 0:
if ((__is_neg(25, &(match_icase), sizeof (match_icase), &(buf), sizeof (buf), &(size), sizeof (size), &(start_ptr), sizeof (start_ptr), &(eolbyte), sizeof (eolbyte), &(mb_start), sizeof (mb_start), &(buflim), sizeof (buflim), &(beg), sizeof (beg), &(end), sizeof (end), &(kwset), sizeof (kwset), &(eol), sizeof (eol), &(match), sizeof (match), &(kwset_exact_matches), sizeof (kwset_exact_matches), &(backref), sizeof (backref), &(best_match), sizeof (best_match), &(best_len), sizeof (best_len), &(i), sizeof (i), &(pcount), sizeof (pcount), &(patterns), sizeof (patterns), &(start), sizeof (start), &(len), sizeof (len), &(match_words), sizeof (match_words), &(match_lines), sizeof (match_lines), &(ret_val), sizeof (ret_val), &(match_size), sizeof (match_size))))
    goto failure;
if (match_icase) {
    char *case_buf = mbtolower(buf, &size);
    if (start_ptr)
        start_ptr = case_buf + (start_ptr - buf);
    buf = case_buf;
}

//CodeSeg 1:
    }
#endif /* MBS_SUPPORT */

  mb_start = buf;
  buflim = buf + size;

  for (beg = end = buf; end < buflim; beg = end)
    {
      if (!start_ptr)
	{
	  /* We don't care about an exact match.  */
	  if (kwset)
	    {
	      /* Find a possible match using the KWset matcher. */
	      size_t offset = kwsexec (kwset, beg, buflim - beg, &kwsm);
	      if (offset == (size_t) -1)
		goto failure;
	      beg += offset;
	      /* Narrow down to the line containing the candidate, and
		 run it through DFA. */
	      if ((end = memchr(beg, eol, buflim - beg)) != NULL)
	        end++;
              else
                end = buflim;
	      match = beg;
	      while (beg > buf && beg[-1] != eol)
		--beg;
	      if (kwsm.index < kwset_exact_matches)
                {
#ifdef MBS_SUPPORT
                  if (mb_start < beg)
                    mb_start = beg;
                  if (MB_CUR_MAX == 1 || !is_mb_middle (&mb_start, match, buflim))
#endif
                    goto success;
                }
	      if (dfaexec (&dfa, beg, (char *) end, 0, NULL, &backref) == NULL)
		continue;
	    }
	  else
	    {
	      /* No good fixed strings; start with DFA. */
	      char const *next_beg = dfaexec (&dfa, beg, (char *) buflim,
					      0, NULL, &backref);
	      if (next_beg == NULL)
		break;
	      /* Narrow down to the line we've found. */
	      beg = next_beg;
	      if ((end = memchr(beg, eol, buflim - beg)) != NULL)
	        end++;
              else
                end = buflim;
	      while (beg > buf && beg[-1] != eol)
		--beg;
	    }
	  /* Successful, no backreferences encountered! */
	  if (!backref)
	    goto success;
	}
      else
	{
	  /* We are looking for the leftmost (then longest) exact match.
	     We will go through the outer loop only once.  */
	  beg = start_ptr;
	  end = buflim;
	}

      /* If we've made it to this point, this means DFA has seen
	 a probable match, and we need to run it through Regex. */
      best_match = end;
      best_len = 0;
      for (i = 0; i < pcount; i++)
	{
	  patterns[i].regexbuf.not_eol = 0;
	  if (0 <= (start = re_search (&(patterns[i].regexbuf),
				       buf, end - buf - 1,
				       beg - buf, end - beg - 1,
				       &(patterns[i].regs))))
	    {
	      len = patterns[i].regs.end[0] - start;
	      match = buf + start;
	      if (match > best_match)
		continue;
	      if (start_ptr && !match_words)
		goto assess_pattern_match;
	      if ((!match_lines && !match_words)
		  || (match_lines && len == end - beg - 1))
		{
		  match = beg;
		  len = end - beg;
		  goto assess_pattern_match;
		}
	      /* If -w, check if the match aligns with word boundaries.
		 We do this iteratively because:
		 (a) the line may contain more than one occurence of the
		 pattern, and
		 (b) Several alternatives in the pattern might be valid at a
		 given point, and we may need to consider a shorter one to
		 find a word boundary.  */
	      if (match_words)
		while (match <= best_match)
		  {
		    if ((match == buf || !WCHAR ((unsigned char) match[-1]))
			&& (len == end - beg - 1
			    || !WCHAR ((unsigned char) match[len])))
		      goto assess_pattern_match;
		    if (len > 0)
		      {
			/* Try a shorter length anchored at the same place. */
			--len;
			patterns[i].regexbuf.not_eol = 1;
			len = re_match (&(patterns[i].regexbuf),
					buf, match + len - beg, match - buf,
					&(patterns[i].regs));
		      }
		    if (len <= 0)
		      {
			/* Try looking further on. */
			if (match == end - 1)
			  break;
			match++;
			patterns[i].regexbuf.not_eol = 0;
			start = re_search (&(patterns[i].regexbuf),
					   buf, end - buf - 1,
					   match - buf, end - match - 1,
					   &(patterns[i].regs));
			if (start < 0)
			  break;
			len = patterns[i].regs.end[0] - start;
			match = buf + start;
		      }
		  } /* while (match <= best_match) */
	      continue;
	    assess_pattern_match:
	      if (!start_ptr)
		{
		  /* Good enough for a non-exact match.
		     No need to look at further patterns, if any.  */
		  beg = match;
		  goto success_in_len;
		}
	      if (match < best_match || (match == best_match && len > best_len))
		{
		  /* Best exact match:  leftmost, then longest.  */
		  best_match = match;
		  best_len = len;
		}
	    } /* if re_search >= 0 */
	} /* for Regex patterns.  */
	if (best_match < end)
	  {
	    /* We have found an exact match.  We were just
	       waiting for the best one (leftmost then longest).  */
	    beg = best_match;
	    len = best_len;
	    goto success_in_len;
	  }
    } /* for (beg = end ..) */

 failure:
  ret_val = -1;
  goto out;

 success:
  len = end - beg;
 success_in_len:
  *match_size = len;
  ret_val = beg - buf;
 out:
  return ret_val;
}

Testing negative cases!
Testing 0 (with abstract condition) ENVIS_NEG
Iteration 0
Running test command:
/home/ubuntu/spr-fast/tools/grep-test.py /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-8a025cf8-8f08d8e2/tempworkdir-l/src /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-8a025cf8-8f08d8e2/tempworkdir-l/tests /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-8a025cf8-8f08d8e2/tempworkdir-l 0  > __res
Opening:/tmp/neg.tmp!
NegativeBRANCH RECORD/tmp/neg.tmp!
APPENDING TO ISNEG:/tmp/neg.tmp!
Branch 0: 0
Branch 1: 0
Iteration 1
Running test command:
/home/ubuntu/spr-fast/tools/grep-test.py /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-8a025cf8-8f08d8e2/tempworkdir-l/src /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-8a025cf8-8f08d8e2/tempworkdir-l/tests /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-8a025cf8-8f08d8e2/tempworkdir-l 0  > __res
Opening:/tmp/neg.tmp!
NegativeBRANCH RECORD/tmp/neg.tmp!
APPENDING TO ISNEG:/tmp/neg.tmp!
Branch 0: 0
Branch 1: 1
Iteration 2
Running test command:
/home/ubuntu/spr-fast/tools/grep-test.py /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-8a025cf8-8f08d8e2/tempworkdir-l/src /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-8a025cf8-8f08d8e2/tempworkdir-l/tests /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-8a025cf8-8f08d8e2/tempworkdir-l 0  > __res
Opening:/tmp/neg.tmp!
NegativeBRANCH RECORD/tmp/neg.tmp!
APPENDING TO ISNEG:/tmp/neg.tmp!
Branch 0: 1
Running test command:
/home/ubuntu/spr-fast/tools/grep-test.py /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-8a025cf8-8f08d8e2/tempworkdir-l/src /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-8a025cf8-8f08d8e2/tempworkdir-l/tests /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-8a025cf8-8f08d8e2/tempworkdir-l 0  > __res
CondTester, Testing instance id 89:
//src_file:src/dfasearch.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); void* memset(void*, int, unsigned long); 
/* dfasearch.c - searching subroutines using dfa and regex for grep.
   Copyright 1992, 1998, 2000, 2007, 2009-2010 Free Software Foundation, Inc.

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 3, or (at your option)
   any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program; if not, write to the Free Software
   Foundation, Inc., 51 Franklin Street - Fifth Floor, Boston, MA
   02110-1301, USA.  */

/* Written August 1992 by Mike Haertel. */

#include <config.h>
#include "search.h"
#include "dfa.h"

/* For -w, we also consider _ to be word constituent.  */
#define WCHAR(C) (ISALNUM(C) || (C) == '_')

/* KWset compiled pattern.  For Ecompile and Gcompile, we compile
   a list of strings, at least one of which is known to occur in
   any string matching the regexp. */
static kwset_t kwset;

/* DFA compiled regexp. */
static struct dfa dfa;

/* The Regex compiled patterns.  */
static struct patterns
{
  /* Regex compiled regexp. */
  struct re_pattern_buffer regexbuf;
  struct re_registers regs; /* This is here on account of a BRAIN-DEAD
			       Q@#%!# library interface in regex.c.  */
} patterns0;

struct patterns *patterns;
size_t pcount;

void
dfaerror (char const *mesg)
{
  error (EXIT_TROUBLE, 0, "%s", mesg);

  /* notreached */
  /* Tell static analyzers that this function does not return.  */
  abort ();
}

/* Number of compiled fixed strings known to exactly match the regexp.
   If kwsexec returns < kwset_exact_matches, then we don't need to
   call the regexp matcher at all. */
static int kwset_exact_matches;

static char const *
kwsincr_case (const char *must)
{
  const char *buf;
  size_t n;

  n = strlen (must);
#ifdef MBS_SUPPORT
  if (match_icase && MB_CUR_MAX > 1)
    buf = mbtolower (must, &n);
  else
#endif
    buf = must;
  return kwsincr (kwset, buf, n);
}

/* If the DFA turns out to have some set of fixed strings one of
   which must occur in the match, then we build a kwset matcher
   to find those strings, and thus quickly filter out impossible
   matches. */
static void
kwsmusts (void)
{
  struct dfamust const *dm;
  char const *err;

  if (dfa.musts)
    {
      kwsinit (&kwset);
      /* First, we compile in the substrings known to be exact
	 matches.  The kwset matcher will return the index
	 of the matching string that it chooses. */
      for (dm = dfa.musts; dm; dm = dm->next)
	{
	  if (!dm->exact)
	    continue;
	  ++kwset_exact_matches;
	  if ((err = kwsincr_case (dm->must)) != NULL)
	    error (EXIT_TROUBLE, 0, "%s", err);
	}
      /* Now, we compile the substrings that will require
	 the use of the regexp matcher.  */
      for (dm = dfa.musts; dm; dm = dm->next)
	{
	  if (dm->exact)
	    continue;
	  if ((err = kwsincr_case (dm->must)) != NULL)
	    error (EXIT_TROUBLE, 0, "%s", err);
	}
      if ((err = kwsprep (kwset)) != NULL)
	error (EXIT_TROUBLE, 0, "%s", err);
    }
}

void
GEAcompile (char const *pattern, size_t size, reg_syntax_t syntax_bits)
{
  const char *err;
  const char *p, *sep;
  size_t total = size;
  char *motif;

  if (match_icase)
    syntax_bits |= RE_ICASE;
  re_set_syntax (syntax_bits);
  dfasyntax (syntax_bits, match_icase, eolbyte);

  /* For GNU regex compiler we have to pass the patterns separately to detect
     errors like "[\nallo\n]\n".  The patterns here are "[", "allo" and "]"
     GNU regex should have raise a syntax error.  The same for backref, where
     the backref should have been local to each pattern.  */
  p = pattern;
  do
    {
      size_t len;
      sep = memchr (p, '\n', total);
      if (sep)
	{
	  len = sep - p;
	  sep++;
	  total -= (len + 1);
	}
      else
	{
	  len = total;
	  total = 0;
	}

      patterns = realloc (patterns, (pcount + 1) * sizeof (*patterns));
      if (patterns == NULL)
	error (EXIT_TROUBLE, errno, _("memory exhausted"));
      patterns[pcount] = patterns0;

      if ((err = re_compile_pattern (p, len,
				    &(patterns[pcount].regexbuf))) != NULL)
	error (EXIT_TROUBLE, 0, "%s", err);
      pcount++;

      p = sep;
    } while (sep && total != 0);

  /* In the match_words and match_lines cases, we use a different pattern
     for the DFA matcher that will quickly throw out cases that won't work.
     Then if DFA succeeds we do some hairy stuff using the regex matcher
     to decide whether the match should really count. */
  if (match_words || match_lines)
    {
      static char const line_beg_no_bk[] = "^(";
      static char const line_end_no_bk[] = ")$";
      static char const word_beg_no_bk[] = "(^|[^[:alnum:]_])(";
      static char const word_end_no_bk[] = ")([^[:alnum:]_]|$)";
      static char const line_beg_bk[] = "^\\(";
      static char const line_end_bk[] = "\\)$";
      static char const word_beg_bk[] = "\\(^\\|[^[:alnum:]_]\\)\\(";
      static char const word_end_bk[] = "\\)\\([^[:alnum:]_]\\|$\\)";
      int bk = !(syntax_bits & RE_NO_BK_PARENS);
      char *n = xmalloc (sizeof word_beg_bk - 1 + size + sizeof word_end_bk);

      strcpy (n, match_lines ? (bk ? line_beg_bk : line_beg_no_bk)
			     : (bk ? word_beg_bk : word_beg_no_bk));
      total = strlen(n);
      memcpy (n + total, pattern, size);
      total += size;
      strcpy (n + total, match_lines ? (bk ? line_end_bk : line_end_no_bk)
				     : (bk ? word_end_bk : word_end_no_bk));
      total += strlen (n + total);
      pattern = motif = n;
      size = total;
    }
  else
    motif = NULL;

  dfacomp (pattern, size, &dfa, 1);
  kwsmusts ();

  free(motif);
}

size_t
EGexecute (char const *buf, size_t size, size_t *match_size,
	   char const *start_ptr)
{
  char const *buflim, *beg, *end, *match, *best_match, *mb_start;
  char eol = eolbyte;
  int backref, start, len, best_len;
  struct kwsmatch kwsm;
  size_t i, ret_val;
#ifdef MBS_SUPPORT
  if (MB_CUR_MAX > 1)
    {
      
//Patch 0:
if ((__is_neg(25, &(match_icase), sizeof (match_icase), &(buf), sizeof (buf), &(size), sizeof (size), &(start_ptr), sizeof (start_ptr), &(eolbyte), sizeof (eolbyte), &(mb_start), sizeof (mb_start), &(buflim), sizeof (buflim), &(beg), sizeof (beg), &(end), sizeof (end), &(kwset), sizeof (kwset), &(eol), sizeof (eol), &(match), sizeof (match), &(kwset_exact_matches), sizeof (kwset_exact_matches), &(backref), sizeof (backref), &(best_match), sizeof (best_match), &(best_len), sizeof (best_len), &(i), sizeof (i), &(pcount), sizeof (pcount), &(patterns), sizeof (patterns), &(start), sizeof (start), &(len), sizeof (len), &(match_words), sizeof (match_words), &(match_lines), sizeof (match_lines), &(ret_val), sizeof (ret_val), &(match_size), sizeof (match_size))))
    goto success;
if (match_icase) {
    char *case_buf = mbtolower(buf, &size);
    if (start_ptr)
        start_ptr = case_buf + (start_ptr - buf);
    buf = case_buf;
}

//CodeSeg 1:
    }
#endif /* MBS_SUPPORT */

  mb_start = buf;
  buflim = buf + size;

  for (beg = end = buf; end < buflim; beg = end)
    {
      if (!start_ptr)
	{
	  /* We don't care about an exact match.  */
	  if (kwset)
	    {
	      /* Find a possible match using the KWset matcher. */
	      size_t offset = kwsexec (kwset, beg, buflim - beg, &kwsm);
	      if (offset == (size_t) -1)
		goto failure;
	      beg += offset;
	      /* Narrow down to the line containing the candidate, and
		 run it through DFA. */
	      if ((end = memchr(beg, eol, buflim - beg)) != NULL)
	        end++;
              else
                end = buflim;
	      match = beg;
	      while (beg > buf && beg[-1] != eol)
		--beg;
	      if (kwsm.index < kwset_exact_matches)
                {
#ifdef MBS_SUPPORT
                  if (mb_start < beg)
                    mb_start = beg;
                  if (MB_CUR_MAX == 1 || !is_mb_middle (&mb_start, match, buflim))
#endif
                    goto success;
                }
	      if (dfaexec (&dfa, beg, (char *) end, 0, NULL, &backref) == NULL)
		continue;
	    }
	  else
	    {
	      /* No good fixed strings; start with DFA. */
	      char const *next_beg = dfaexec (&dfa, beg, (char *) buflim,
					      0, NULL, &backref);
	      if (next_beg == NULL)
		break;
	      /* Narrow down to the line we've found. */
	      beg = next_beg;
	      if ((end = memchr(beg, eol, buflim - beg)) != NULL)
	        end++;
              else
                end = buflim;
	      while (beg > buf && beg[-1] != eol)
		--beg;
	    }
	  /* Successful, no backreferences encountered! */
	  if (!backref)
	    goto success;
	}
      else
	{
	  /* We are looking for the leftmost (then longest) exact match.
	     We will go through the outer loop only once.  */
	  beg = start_ptr;
	  end = buflim;
	}

      /* If we've made it to this point, this means DFA has seen
	 a probable match, and we need to run it through Regex. */
      best_match = end;
      best_len = 0;
      for (i = 0; i < pcount; i++)
	{
	  patterns[i].regexbuf.not_eol = 0;
	  if (0 <= (start = re_search (&(patterns[i].regexbuf),
				       buf, end - buf - 1,
				       beg - buf, end - beg - 1,
				       &(patterns[i].regs))))
	    {
	      len = patterns[i].regs.end[0] - start;
	      match = buf + start;
	      if (match > best_match)
		continue;
	      if (start_ptr && !match_words)
		goto assess_pattern_match;
	      if ((!match_lines && !match_words)
		  || (match_lines && len == end - beg - 1))
		{
		  match = beg;
		  len = end - beg;
		  goto assess_pattern_match;
		}
	      /* If -w, check if the match aligns with word boundaries.
		 We do this iteratively because:
		 (a) the line may contain more than one occurence of the
		 pattern, and
		 (b) Several alternatives in the pattern might be valid at a
		 given point, and we may need to consider a shorter one to
		 find a word boundary.  */
	      if (match_words)
		while (match <= best_match)
		  {
		    if ((match == buf || !WCHAR ((unsigned char) match[-1]))
			&& (len == end - beg - 1
			    || !WCHAR ((unsigned char) match[len])))
		      goto assess_pattern_match;
		    if (len > 0)
		      {
			/* Try a shorter length anchored at the same place. */
			--len;
			patterns[i].regexbuf.not_eol = 1;
			len = re_match (&(patterns[i].regexbuf),
					buf, match + len - beg, match - buf,
					&(patterns[i].regs));
		      }
		    if (len <= 0)
		      {
			/* Try looking further on. */
			if (match == end - 1)
			  break;
			match++;
			patterns[i].regexbuf.not_eol = 0;
			start = re_search (&(patterns[i].regexbuf),
					   buf, end - buf - 1,
					   match - buf, end - match - 1,
					   &(patterns[i].regs));
			if (start < 0)
			  break;
			len = patterns[i].regs.end[0] - start;
			match = buf + start;
		      }
		  } /* while (match <= best_match) */
	      continue;
	    assess_pattern_match:
	      if (!start_ptr)
		{
		  /* Good enough for a non-exact match.
		     No need to look at further patterns, if any.  */
		  beg = match;
		  goto success_in_len;
		}
	      if (match < best_match || (match == best_match && len > best_len))
		{
		  /* Best exact match:  leftmost, then longest.  */
		  best_match = match;
		  best_len = len;
		}
	    } /* if re_search >= 0 */
	} /* for Regex patterns.  */
	if (best_match < end)
	  {
	    /* We have found an exact match.  We were just
	       waiting for the best one (leftmost then longest).  */
	    beg = best_match;
	    len = best_len;
	    goto success_in_len;
	  }
    } /* for (beg = end ..) */

 failure:
  ret_val = -1;
  goto out;

 success:
  len = end - beg;
 success_in_len:
  *match_size = len;
  ret_val = beg - buf;
 out:
  return ret_val;
}

Testing negative cases!
Testing 0 (with abstract condition) ENVIS_NEG
Iteration 0
Running test command:
/home/ubuntu/spr-fast/tools/grep-test.py /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-8a025cf8-8f08d8e2/tempworkdir-l/src /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-8a025cf8-8f08d8e2/tempworkdir-l/tests /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-8a025cf8-8f08d8e2/tempworkdir-l 0  > __res
Opening:/tmp/neg.tmp!
NegativeBRANCH RECORD/tmp/neg.tmp!
APPENDING TO ISNEG:/tmp/neg.tmp!
Branch 0: 0
Branch 1: 0
Iteration 1
Running test command:
/home/ubuntu/spr-fast/tools/grep-test.py /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-8a025cf8-8f08d8e2/tempworkdir-l/src /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-8a025cf8-8f08d8e2/tempworkdir-l/tests /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-8a025cf8-8f08d8e2/tempworkdir-l 0  > __res
Opening:/tmp/neg.tmp!
NegativeBRANCH RECORD/tmp/neg.tmp!
APPENDING TO ISNEG:/tmp/neg.tmp!
Branch 0: 0
Branch 1: 1
Branch 2: 0
Branch 3: 0
Iteration 2
Running test command:
/home/ubuntu/spr-fast/tools/grep-test.py /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-8a025cf8-8f08d8e2/tempworkdir-l/src /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-8a025cf8-8f08d8e2/tempworkdir-l/tests /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-8a025cf8-8f08d8e2/tempworkdir-l 0  > __res
Opening:/tmp/neg.tmp!
NegativeBRANCH RECORD/tmp/neg.tmp!
APPENDING TO ISNEG:/tmp/neg.tmp!
Branch 0: 0
Branch 1: 1
Branch 2: 0
Branch 3: 1
Branch 4: 0
Branch 5: 0
Iteration 3
Running test command:
/home/ubuntu/spr-fast/tools/grep-test.py /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-8a025cf8-8f08d8e2/tempworkdir-l/src /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-8a025cf8-8f08d8e2/tempworkdir-l/tests /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-8a025cf8-8f08d8e2/tempworkdir-l 0  > __res
Opening:/tmp/neg.tmp!
NegativeBRANCH RECORD/tmp/neg.tmp!
APPENDING TO ISNEG:/tmp/neg.tmp!
Branch 0: 0
Branch 1: 1
Branch 2: 0
Branch 3: 1
Branch 4: 0
Branch 5: 1
Branch 6: 0
Branch 7: 0
Iteration 4
Running test command:
/home/ubuntu/spr-fast/tools/grep-test.py /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-8a025cf8-8f08d8e2/tempworkdir-l/src /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-8a025cf8-8f08d8e2/tempworkdir-l/tests /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-8a025cf8-8f08d8e2/tempworkdir-l 0  > __res
Opening:/tmp/neg.tmp!
NegativeBRANCH RECORD/tmp/neg.tmp!
APPENDING TO ISNEG:/tmp/neg.tmp!
Branch 0: 0
Branch 1: 1
Branch 2: 0
Branch 3: 1
Branch 4: 0
Branch 5: 1
Branch 6: 0
Branch 7: 1
Branch 8: 0
Branch 9: 0
Iteration 5
Running test command:
/home/ubuntu/spr-fast/tools/grep-test.py /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-8a025cf8-8f08d8e2/tempworkdir-l/src /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-8a025cf8-8f08d8e2/tempworkdir-l/tests /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-8a025cf8-8f08d8e2/tempworkdir-l 0  > __res
Opening:/tmp/neg.tmp!
NegativeBRANCH RECORD/tmp/neg.tmp!
APPENDING TO ISNEG:/tmp/neg.tmp!
Branch 0: 0
Branch 1: 1
Branch 2: 0
Branch 3: 1
Branch 4: 0
Branch 5: 1
Branch 6: 0
Branch 7: 1
Branch 8: 0
Branch 9: 1
Branch 10: 0
Branch 11: 0
Iteration 6
Running test command:
/home/ubuntu/spr-fast/tools/grep-test.py /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-8a025cf8-8f08d8e2/tempworkdir-l/src /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-8a025cf8-8f08d8e2/tempworkdir-l/tests /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-8a025cf8-8f08d8e2/tempworkdir-l 0  > __res
Opening:/tmp/neg.tmp!
NegativeBRANCH RECORD/tmp/neg.tmp!
APPENDING TO ISNEG:/tmp/neg.tmp!
Branch 0: 0
Branch 1: 1
Branch 2: 0
Branch 3: 1
Branch 4: 0
Branch 5: 1
Branch 6: 0
Branch 7: 1
Branch 8: 0
Branch 9: 1
Branch 10: 0
Branch 11: 1
Branch 12: 0
Branch 13: 0
Iteration 7
Running test command:
/home/ubuntu/spr-fast/tools/grep-test.py /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-8a025cf8-8f08d8e2/tempworkdir-l/src /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-8a025cf8-8f08d8e2/tempworkdir-l/tests /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-8a025cf8-8f08d8e2/tempworkdir-l 0  > __res
Opening:/tmp/neg.tmp!
NegativeBRANCH RECORD/tmp/neg.tmp!
APPENDING TO ISNEG:/tmp/neg.tmp!
Branch 0: 0
Branch 1: 1
Branch 2: 0
Branch 3: 1
Branch 4: 0
Branch 5: 1
Branch 6: 0
Branch 7: 1
Branch 8: 0
Branch 9: 1
Branch 10: 0
Branch 11: 1
Branch 12: 0
Branch 13: 1
Branch 14: 0
Branch 15: 0
Iteration 8
Running test command:
/home/ubuntu/spr-fast/tools/grep-test.py /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-8a025cf8-8f08d8e2/tempworkdir-l/src /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-8a025cf8-8f08d8e2/tempworkdir-l/tests /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-8a025cf8-8f08d8e2/tempworkdir-l 0  > __res
Opening:/tmp/neg.tmp!
NegativeBRANCH RECORD/tmp/neg.tmp!
APPENDING TO ISNEG:/tmp/neg.tmp!
Branch 0: 0
Branch 1: 1
Branch 2: 0
Branch 3: 1
Branch 4: 0
Branch 5: 1
Branch 6: 0
Branch 7: 1
Branch 8: 0
Branch 9: 1
Branch 10: 0
Branch 11: 1
Branch 12: 0
Branch 13: 1
Branch 14: 0
Branch 15: 1
Branch 16: 0
Branch 17: 0
Iteration 9
Running test command:
/home/ubuntu/spr-fast/tools/grep-test.py /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-8a025cf8-8f08d8e2/tempworkdir-l/src /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-8a025cf8-8f08d8e2/tempworkdir-l/tests /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-8a025cf8-8f08d8e2/tempworkdir-l 0  > __res
Opening:/tmp/neg.tmp!
NegativeBRANCH RECORD/tmp/neg.tmp!
APPENDING TO ISNEG:/tmp/neg.tmp!
Branch 0: 0
Branch 1: 1
Branch 2: 0
Branch 3: 1
Branch 4: 0
Branch 5: 1
Branch 6: 0
Branch 7: 1
Branch 8: 0
Branch 9: 1
Branch 10: 0
Branch 11: 1
Branch 12: 0
Branch 13: 1
Branch 14: 0
Branch 15: 1
Branch 16: 0
Branch 17: 1
Branch 18: 0
Branch 19: 0
Running test command:
/home/ubuntu/spr-fast/tools/grep-test.py /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-8a025cf8-8f08d8e2/tempworkdir-l/src /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-8a025cf8-8f08d8e2/tempworkdir-l/tests /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-8a025cf8-8f08d8e2/tempworkdir-l 0  > __res
CondTester, Testing instance id 90:
//src_file:src/dfasearch.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); void* memset(void*, int, unsigned long); 
/* dfasearch.c - searching subroutines using dfa and regex for grep.
   Copyright 1992, 1998, 2000, 2007, 2009-2010 Free Software Foundation, Inc.

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 3, or (at your option)
   any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program; if not, write to the Free Software
   Foundation, Inc., 51 Franklin Street - Fifth Floor, Boston, MA
   02110-1301, USA.  */

/* Written August 1992 by Mike Haertel. */

#include <config.h>
#include "search.h"
#include "dfa.h"

/* For -w, we also consider _ to be word constituent.  */
#define WCHAR(C) (ISALNUM(C) || (C) == '_')

/* KWset compiled pattern.  For Ecompile and Gcompile, we compile
   a list of strings, at least one of which is known to occur in
   any string matching the regexp. */
static kwset_t kwset;

/* DFA compiled regexp. */
static struct dfa dfa;

/* The Regex compiled patterns.  */
static struct patterns
{
  /* Regex compiled regexp. */
  struct re_pattern_buffer regexbuf;
  struct re_registers regs; /* This is here on account of a BRAIN-DEAD
			       Q@#%!# library interface in regex.c.  */
} patterns0;

struct patterns *patterns;
size_t pcount;

void
dfaerror (char const *mesg)
{
  error (EXIT_TROUBLE, 0, "%s", mesg);

  /* notreached */
  /* Tell static analyzers that this function does not return.  */
  abort ();
}

/* Number of compiled fixed strings known to exactly match the regexp.
   If kwsexec returns < kwset_exact_matches, then we don't need to
   call the regexp matcher at all. */
static int kwset_exact_matches;

static char const *
kwsincr_case (const char *must)
{
  const char *buf;
  size_t n;

  n = strlen (must);
#ifdef MBS_SUPPORT
  if (match_icase && MB_CUR_MAX > 1)
    buf = mbtolower (must, &n);
  else
#endif
    buf = must;
  return kwsincr (kwset, buf, n);
}

/* If the DFA turns out to have some set of fixed strings one of
   which must occur in the match, then we build a kwset matcher
   to find those strings, and thus quickly filter out impossible
   matches. */
static void
kwsmusts (void)
{
  struct dfamust const *dm;
  char const *err;

  if (dfa.musts)
    {
      kwsinit (&kwset);
      /* First, we compile in the substrings known to be exact
	 matches.  The kwset matcher will return the index
	 of the matching string that it chooses. */
      for (dm = dfa.musts; dm; dm = dm->next)
	{
	  if (!dm->exact)
	    continue;
	  ++kwset_exact_matches;
	  if ((err = kwsincr_case (dm->must)) != NULL)
	    error (EXIT_TROUBLE, 0, "%s", err);
	}
      /* Now, we compile the substrings that will require
	 the use of the regexp matcher.  */
      for (dm = dfa.musts; dm; dm = dm->next)
	{
	  if (dm->exact)
	    continue;
	  if ((err = kwsincr_case (dm->must)) != NULL)
	    error (EXIT_TROUBLE, 0, "%s", err);
	}
      if ((err = kwsprep (kwset)) != NULL)
	error (EXIT_TROUBLE, 0, "%s", err);
    }
}

void
GEAcompile (char const *pattern, size_t size, reg_syntax_t syntax_bits)
{
  const char *err;
  const char *p, *sep;
  size_t total = size;
  char *motif;

  if (match_icase)
    syntax_bits |= RE_ICASE;
  re_set_syntax (syntax_bits);
  dfasyntax (syntax_bits, match_icase, eolbyte);

  /* For GNU regex compiler we have to pass the patterns separately to detect
     errors like "[\nallo\n]\n".  The patterns here are "[", "allo" and "]"
     GNU regex should have raise a syntax error.  The same for backref, where
     the backref should have been local to each pattern.  */
  p = pattern;
  do
    {
      size_t len;
      sep = memchr (p, '\n', total);
      if (sep)
	{
	  len = sep - p;
	  sep++;
	  total -= (len + 1);
	}
      else
	{
	  len = total;
	  total = 0;
	}

      patterns = realloc (patterns, (pcount + 1) * sizeof (*patterns));
      if (patterns == NULL)
	error (EXIT_TROUBLE, errno, _("memory exhausted"));
      patterns[pcount] = patterns0;

      if ((err = re_compile_pattern (p, len,
				    &(patterns[pcount].regexbuf))) != NULL)
	error (EXIT_TROUBLE, 0, "%s", err);
      pcount++;

      p = sep;
    } while (sep && total != 0);

  /* In the match_words and match_lines cases, we use a different pattern
     for the DFA matcher that will quickly throw out cases that won't work.
     Then if DFA succeeds we do some hairy stuff using the regex matcher
     to decide whether the match should really count. */
  if (match_words || match_lines)
    {
      static char const line_beg_no_bk[] = "^(";
      static char const line_end_no_bk[] = ")$";
      static char const word_beg_no_bk[] = "(^|[^[:alnum:]_])(";
      static char const word_end_no_bk[] = ")([^[:alnum:]_]|$)";
      static char const line_beg_bk[] = "^\\(";
      static char const line_end_bk[] = "\\)$";
      static char const word_beg_bk[] = "\\(^\\|[^[:alnum:]_]\\)\\(";
      static char const word_end_bk[] = "\\)\\([^[:alnum:]_]\\|$\\)";
      int bk = !(syntax_bits & RE_NO_BK_PARENS);
      char *n = xmalloc (sizeof word_beg_bk - 1 + size + sizeof word_end_bk);

      strcpy (n, match_lines ? (bk ? line_beg_bk : line_beg_no_bk)
			     : (bk ? word_beg_bk : word_beg_no_bk));
      total = strlen(n);
      memcpy (n + total, pattern, size);
      total += size;
      strcpy (n + total, match_lines ? (bk ? line_end_bk : line_end_no_bk)
				     : (bk ? word_end_bk : word_end_no_bk));
      total += strlen (n + total);
      pattern = motif = n;
      size = total;
    }
  else
    motif = NULL;

  dfacomp (pattern, size, &dfa, 1);
  kwsmusts ();

  free(motif);
}

size_t
EGexecute (char const *buf, size_t size, size_t *match_size,
	   char const *start_ptr)
{
  char const *buflim, *beg, *end, *match, *best_match, *mb_start;
  char eol = eolbyte;
  int backref, start, len, best_len;
  struct kwsmatch kwsm;
  size_t i, ret_val;
#ifdef MBS_SUPPORT
  if (MB_CUR_MAX > 1)
    {
      
//Patch 0:
if ((__is_neg(25, &(match_icase), sizeof (match_icase), &(buf), sizeof (buf), &(size), sizeof (size), &(start_ptr), sizeof (start_ptr), &(eolbyte), sizeof (eolbyte), &(mb_start), sizeof (mb_start), &(buflim), sizeof (buflim), &(beg), sizeof (beg), &(end), sizeof (end), &(kwset), sizeof (kwset), &(eol), sizeof (eol), &(match), sizeof (match), &(kwset_exact_matches), sizeof (kwset_exact_matches), &(backref), sizeof (backref), &(best_match), sizeof (best_match), &(best_len), sizeof (best_len), &(i), sizeof (i), &(pcount), sizeof (pcount), &(patterns), sizeof (patterns), &(start), sizeof (start), &(len), sizeof (len), &(match_words), sizeof (match_words), &(match_lines), sizeof (match_lines), &(ret_val), sizeof (ret_val), &(match_size), sizeof (match_size))))
    goto success_in_len;
if (match_icase) {
    char *case_buf = mbtolower(buf, &size);
    if (start_ptr)
        start_ptr = case_buf + (start_ptr - buf);
    buf = case_buf;
}

//CodeSeg 1:
    }
#endif /* MBS_SUPPORT */

  mb_start = buf;
  buflim = buf + size;

  for (beg = end = buf; end < buflim; beg = end)
    {
      if (!start_ptr)
	{
	  /* We don't care about an exact match.  */
	  if (kwset)
	    {
	      /* Find a possible match using the KWset matcher. */
	      size_t offset = kwsexec (kwset, beg, buflim - beg, &kwsm);
	      if (offset == (size_t) -1)
		goto failure;
	      beg += offset;
	      /* Narrow down to the line containing the candidate, and
		 run it through DFA. */
	      if ((end = memchr(beg, eol, buflim - beg)) != NULL)
	        end++;
              else
                end = buflim;
	      match = beg;
	      while (beg > buf && beg[-1] != eol)
		--beg;
	      if (kwsm.index < kwset_exact_matches)
                {
#ifdef MBS_SUPPORT
                  if (mb_start < beg)
                    mb_start = beg;
                  if (MB_CUR_MAX == 1 || !is_mb_middle (&mb_start, match, buflim))
#endif
                    goto success;
                }
	      if (dfaexec (&dfa, beg, (char *) end, 0, NULL, &backref) == NULL)
		continue;
	    }
	  else
	    {
	      /* No good fixed strings; start with DFA. */
	      char const *next_beg = dfaexec (&dfa, beg, (char *) buflim,
					      0, NULL, &backref);
	      if (next_beg == NULL)
		break;
	      /* Narrow down to the line we've found. */
	      beg = next_beg;
	      if ((end = memchr(beg, eol, buflim - beg)) != NULL)
	        end++;
              else
                end = buflim;
	      while (beg > buf && beg[-1] != eol)
		--beg;
	    }
	  /* Successful, no backreferences encountered! */
	  if (!backref)
	    goto success;
	}
      else
	{
	  /* We are looking for the leftmost (then longest) exact match.
	     We will go through the outer loop only once.  */
	  beg = start_ptr;
	  end = buflim;
	}

      /* If we've made it to this point, this means DFA has seen
	 a probable match, and we need to run it through Regex. */
      best_match = end;
      best_len = 0;
      for (i = 0; i < pcount; i++)
	{
	  patterns[i].regexbuf.not_eol = 0;
	  if (0 <= (start = re_search (&(patterns[i].regexbuf),
				       buf, end - buf - 1,
				       beg - buf, end - beg - 1,
				       &(patterns[i].regs))))
	    {
	      len = patterns[i].regs.end[0] - start;
	      match = buf + start;
	      if (match > best_match)
		continue;
	      if (start_ptr && !match_words)
		goto assess_pattern_match;
	      if ((!match_lines && !match_words)
		  || (match_lines && len == end - beg - 1))
		{
		  match = beg;
		  len = end - beg;
		  goto assess_pattern_match;
		}
	      /* If -w, check if the match aligns with word boundaries.
		 We do this iteratively because:
		 (a) the line may contain more than one occurence of the
		 pattern, and
		 (b) Several alternatives in the pattern might be valid at a
		 given point, and we may need to consider a shorter one to
		 find a word boundary.  */
	      if (match_words)
		while (match <= best_match)
		  {
		    if ((match == buf || !WCHAR ((unsigned char) match[-1]))
			&& (len == end - beg - 1
			    || !WCHAR ((unsigned char) match[len])))
		      goto assess_pattern_match;
		    if (len > 0)
		      {
			/* Try a shorter length anchored at the same place. */
			--len;
			patterns[i].regexbuf.not_eol = 1;
			len = re_match (&(patterns[i].regexbuf),
					buf, match + len - beg, match - buf,
					&(patterns[i].regs));
		      }
		    if (len <= 0)
		      {
			/* Try looking further on. */
			if (match == end - 1)
			  break;
			match++;
			patterns[i].regexbuf.not_eol = 0;
			start = re_search (&(patterns[i].regexbuf),
					   buf, end - buf - 1,
					   match - buf, end - match - 1,
					   &(patterns[i].regs));
			if (start < 0)
			  break;
			len = patterns[i].regs.end[0] - start;
			match = buf + start;
		      }
		  } /* while (match <= best_match) */
	      continue;
	    assess_pattern_match:
	      if (!start_ptr)
		{
		  /* Good enough for a non-exact match.
		     No need to look at further patterns, if any.  */
		  beg = match;
		  goto success_in_len;
		}
	      if (match < best_match || (match == best_match && len > best_len))
		{
		  /* Best exact match:  leftmost, then longest.  */
		  best_match = match;
		  best_len = len;
		}
	    } /* if re_search >= 0 */
	} /* for Regex patterns.  */
	if (best_match < end)
	  {
	    /* We have found an exact match.  We were just
	       waiting for the best one (leftmost then longest).  */
	    beg = best_match;
	    len = best_len;
	    goto success_in_len;
	  }
    } /* for (beg = end ..) */

 failure:
  ret_val = -1;
  goto out;

 success:
  len = end - beg;
 success_in_len:
  *match_size = len;
  ret_val = beg - buf;
 out:
  return ret_val;
}

Testing negative cases!
Testing 0 (with abstract condition) ENVIS_NEG
Iteration 0
Running test command:
/home/ubuntu/spr-fast/tools/grep-test.py /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-8a025cf8-8f08d8e2/tempworkdir-l/src /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-8a025cf8-8f08d8e2/tempworkdir-l/tests /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-8a025cf8-8f08d8e2/tempworkdir-l 0  > __res
Opening:/tmp/neg.tmp!
NegativeBRANCH RECORD/tmp/neg.tmp!
APPENDING TO ISNEG:/tmp/neg.tmp!
Branch 0: 0
Branch 1: 0
Iteration 1
Running test command:
/home/ubuntu/spr-fast/tools/grep-test.py /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-8a025cf8-8f08d8e2/tempworkdir-l/src /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-8a025cf8-8f08d8e2/tempworkdir-l/tests /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-8a025cf8-8f08d8e2/tempworkdir-l 0  > __res
Opening:/tmp/neg.tmp!
NegativeBRANCH RECORD/tmp/neg.tmp!
APPENDING TO ISNEG:/tmp/neg.tmp!
Branch 0: 0
Branch 1: 1
Branch 2: 0
Iteration 2
Running test command:
/home/ubuntu/spr-fast/tools/grep-test.py /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-8a025cf8-8f08d8e2/tempworkdir-l/src /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-8a025cf8-8f08d8e2/tempworkdir-l/tests /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-8a025cf8-8f08d8e2/tempworkdir-l 0  > __res
Opening:/tmp/neg.tmp!
NegativeBRANCH RECORD/tmp/neg.tmp!
APPENDING TO ISNEG:/tmp/neg.tmp!
Branch 0: 0
Branch 1: 1
Branch 2: 1
Branch 3: 0
Iteration 3
Running test command:
/home/ubuntu/spr-fast/tools/grep-test.py /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-8a025cf8-8f08d8e2/tempworkdir-l/src /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-8a025cf8-8f08d8e2/tempworkdir-l/tests /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-8a025cf8-8f08d8e2/tempworkdir-l 0  > __res
Opening:/tmp/neg.tmp!
NegativeBRANCH RECORD/tmp/neg.tmp!
APPENDING TO ISNEG:/tmp/neg.tmp!
Branch 0: 0
Branch 1: 1
Branch 2: 1
Branch 3: 1
Branch 4: 0
Iteration 4
Running test command:
/home/ubuntu/spr-fast/tools/grep-test.py /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-8a025cf8-8f08d8e2/tempworkdir-l/src /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-8a025cf8-8f08d8e2/tempworkdir-l/tests /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-8a025cf8-8f08d8e2/tempworkdir-l 0  > __res
Opening:/tmp/neg.tmp!
NegativeBRANCH RECORD/tmp/neg.tmp!
APPENDING TO ISNEG:/tmp/neg.tmp!
Branch 0: 0
Branch 1: 1
Branch 2: 1
Branch 3: 1
Branch 4: 1
Branch 5: 0
Iteration 5
Running test command:
/home/ubuntu/spr-fast/tools/grep-test.py /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-8a025cf8-8f08d8e2/tempworkdir-l/src /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-8a025cf8-8f08d8e2/tempworkdir-l/tests /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-8a025cf8-8f08d8e2/tempworkdir-l 0  > __res
Opening:/tmp/neg.tmp!
NegativeBRANCH RECORD/tmp/neg.tmp!
APPENDING TO ISNEG:/tmp/neg.tmp!
Branch 0: 0
Branch 1: 1
Branch 2: 1
Branch 3: 1
Branch 4: 1
Branch 5: 1
Branch 6: 0
Iteration 6
Running test command:
/home/ubuntu/spr-fast/tools/grep-test.py /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-8a025cf8-8f08d8e2/tempworkdir-l/src /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-8a025cf8-8f08d8e2/tempworkdir-l/tests /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-8a025cf8-8f08d8e2/tempworkdir-l 0  > __res
Opening:/tmp/neg.tmp!
NegativeBRANCH RECORD/tmp/neg.tmp!
APPENDING TO ISNEG:/tmp/neg.tmp!
Branch 0: 0
Branch 1: 1
Branch 2: 1
Branch 3: 1
Branch 4: 1
Branch 5: 1
Branch 6: 1
Branch 7: 0
Iteration 7
Running test command:
/home/ubuntu/spr-fast/tools/grep-test.py /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-8a025cf8-8f08d8e2/tempworkdir-l/src /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-8a025cf8-8f08d8e2/tempworkdir-l/tests /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-8a025cf8-8f08d8e2/tempworkdir-l 0  > __res
Opening:/tmp/neg.tmp!
NegativeBRANCH RECORD/tmp/neg.tmp!
APPENDING TO ISNEG:/tmp/neg.tmp!
Branch 0: 0
Branch 1: 1
Branch 2: 1
Branch 3: 1
Branch 4: 1
Branch 5: 1
Branch 6: 1
Branch 7: 1
Branch 8: 0
Iteration 8
Running test command:
/home/ubuntu/spr-fast/tools/grep-test.py /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-8a025cf8-8f08d8e2/tempworkdir-l/src /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-8a025cf8-8f08d8e2/tempworkdir-l/tests /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-8a025cf8-8f08d8e2/tempworkdir-l 0  > __res
Opening:/tmp/neg.tmp!
NegativeBRANCH RECORD/tmp/neg.tmp!
APPENDING TO ISNEG:/tmp/neg.tmp!
Branch 0: 0
Branch 1: 1
Branch 2: 1
Branch 3: 1
Branch 4: 1
Branch 5: 1
Branch 6: 1
Branch 7: 1
Branch 8: 1
Branch 9: 0
Iteration 9
Running test command:
/home/ubuntu/spr-fast/tools/grep-test.py /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-8a025cf8-8f08d8e2/tempworkdir-l/src /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-8a025cf8-8f08d8e2/tempworkdir-l/tests /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-8a025cf8-8f08d8e2/tempworkdir-l 0  > __res
Opening:/tmp/neg.tmp!
NegativeBRANCH RECORD/tmp/neg.tmp!
APPENDING TO ISNEG:/tmp/neg.tmp!
Branch 0: 0
Branch 1: 1
Branch 2: 1
Branch 3: 1
Branch 4: 1
Branch 5: 1
Branch 6: 1
Branch 7: 1
Branch 8: 1
Branch 9: 1
Branch 10: 0
Running test command:
/home/ubuntu/spr-fast/tools/grep-test.py /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-8a025cf8-8f08d8e2/tempworkdir-l/src /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-8a025cf8-8f08d8e2/tempworkdir-l/tests /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-8a025cf8-8f08d8e2/tempworkdir-l 0  > __res
CondTester, Testing instance id 91:
//src_file:src/dfasearch.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); void* memset(void*, int, unsigned long); 
/* dfasearch.c - searching subroutines using dfa and regex for grep.
   Copyright 1992, 1998, 2000, 2007, 2009-2010 Free Software Foundation, Inc.

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 3, or (at your option)
   any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program; if not, write to the Free Software
   Foundation, Inc., 51 Franklin Street - Fifth Floor, Boston, MA
   02110-1301, USA.  */

/* Written August 1992 by Mike Haertel. */

#include <config.h>
#include "search.h"
#include "dfa.h"

/* For -w, we also consider _ to be word constituent.  */
#define WCHAR(C) (ISALNUM(C) || (C) == '_')

/* KWset compiled pattern.  For Ecompile and Gcompile, we compile
   a list of strings, at least one of which is known to occur in
   any string matching the regexp. */
static kwset_t kwset;

/* DFA compiled regexp. */
static struct dfa dfa;

/* The Regex compiled patterns.  */
static struct patterns
{
  /* Regex compiled regexp. */
  struct re_pattern_buffer regexbuf;
  struct re_registers regs; /* This is here on account of a BRAIN-DEAD
			       Q@#%!# library interface in regex.c.  */
} patterns0;

struct patterns *patterns;
size_t pcount;

void
dfaerror (char const *mesg)
{
  error (EXIT_TROUBLE, 0, "%s", mesg);

  /* notreached */
  /* Tell static analyzers that this function does not return.  */
  abort ();
}

/* Number of compiled fixed strings known to exactly match the regexp.
   If kwsexec returns < kwset_exact_matches, then we don't need to
   call the regexp matcher at all. */
static int kwset_exact_matches;

static char const *
kwsincr_case (const char *must)
{
  const char *buf;
  size_t n;

  n = strlen (must);
#ifdef MBS_SUPPORT
  if (match_icase && MB_CUR_MAX > 1)
    buf = mbtolower (must, &n);
  else
#endif
    buf = must;
  return kwsincr (kwset, buf, n);
}

/* If the DFA turns out to have some set of fixed strings one of
   which must occur in the match, then we build a kwset matcher
   to find those strings, and thus quickly filter out impossible
   matches. */
static void
kwsmusts (void)
{
  struct dfamust const *dm;
  char const *err;

  if (dfa.musts)
    {
      kwsinit (&kwset);
      /* First, we compile in the substrings known to be exact
	 matches.  The kwset matcher will return the index
	 of the matching string that it chooses. */
      for (dm = dfa.musts; dm; dm = dm->next)
	{
	  if (!dm->exact)
	    continue;
	  ++kwset_exact_matches;
	  if ((err = kwsincr_case (dm->must)) != NULL)
	    error (EXIT_TROUBLE, 0, "%s", err);
	}
      /* Now, we compile the substrings that will require
	 the use of the regexp matcher.  */
      for (dm = dfa.musts; dm; dm = dm->next)
	{
	  if (dm->exact)
	    continue;
	  if ((err = kwsincr_case (dm->must)) != NULL)
	    error (EXIT_TROUBLE, 0, "%s", err);
	}
      if ((err = kwsprep (kwset)) != NULL)
	error (EXIT_TROUBLE, 0, "%s", err);
    }
}

void
GEAcompile (char const *pattern, size_t size, reg_syntax_t syntax_bits)
{
  const char *err;
  const char *p, *sep;
  size_t total = size;
  char *motif;

  if (match_icase)
    syntax_bits |= RE_ICASE;
  re_set_syntax (syntax_bits);
  dfasyntax (syntax_bits, match_icase, eolbyte);

  /* For GNU regex compiler we have to pass the patterns separately to detect
     errors like "[\nallo\n]\n".  The patterns here are "[", "allo" and "]"
     GNU regex should have raise a syntax error.  The same for backref, where
     the backref should have been local to each pattern.  */
  p = pattern;
  do
    {
      size_t len;
      sep = memchr (p, '\n', total);
      if (sep)
	{
	  len = sep - p;
	  sep++;
	  total -= (len + 1);
	}
      else
	{
	  len = total;
	  total = 0;
	}

      patterns = realloc (patterns, (pcount + 1) * sizeof (*patterns));
      if (patterns == NULL)
	error (EXIT_TROUBLE, errno, _("memory exhausted"));
      patterns[pcount] = patterns0;

      if ((err = re_compile_pattern (p, len,
				    &(patterns[pcount].regexbuf))) != NULL)
	error (EXIT_TROUBLE, 0, "%s", err);
      pcount++;

      p = sep;
    } while (sep && total != 0);

  /* In the match_words and match_lines cases, we use a different pattern
     for the DFA matcher that will quickly throw out cases that won't work.
     Then if DFA succeeds we do some hairy stuff using the regex matcher
     to decide whether the match should really count. */
  if (match_words || match_lines)
    {
      static char const line_beg_no_bk[] = "^(";
      static char const line_end_no_bk[] = ")$";
      static char const word_beg_no_bk[] = "(^|[^[:alnum:]_])(";
      static char const word_end_no_bk[] = ")([^[:alnum:]_]|$)";
      static char const line_beg_bk[] = "^\\(";
      static char const line_end_bk[] = "\\)$";
      static char const word_beg_bk[] = "\\(^\\|[^[:alnum:]_]\\)\\(";
      static char const word_end_bk[] = "\\)\\([^[:alnum:]_]\\|$\\)";
      int bk = !(syntax_bits & RE_NO_BK_PARENS);
      char *n = xmalloc (sizeof word_beg_bk - 1 + size + sizeof word_end_bk);

      strcpy (n, match_lines ? (bk ? line_beg_bk : line_beg_no_bk)
			     : (bk ? word_beg_bk : word_beg_no_bk));
      total = strlen(n);
      memcpy (n + total, pattern, size);
      total += size;
      strcpy (n + total, match_lines ? (bk ? line_end_bk : line_end_no_bk)
				     : (bk ? word_end_bk : word_end_no_bk));
      total += strlen (n + total);
      pattern = motif = n;
      size = total;
    }
  else
    motif = NULL;

  dfacomp (pattern, size, &dfa, 1);
  kwsmusts ();

  free(motif);
}

size_t
EGexecute (char const *buf, size_t size, size_t *match_size,
	   char const *start_ptr)
{
  char const *buflim, *beg, *end, *match, *best_match, *mb_start;
  char eol = eolbyte;
  int backref, start, len, best_len;
  struct kwsmatch kwsm;
  size_t i, ret_val;
#ifdef MBS_SUPPORT
  if (MB_CUR_MAX > 1)
    {
      
//Patch 0:
if ((__is_neg(25, &(match_icase), sizeof (match_icase), &(buf), sizeof (buf), &(size), sizeof (size), &(start_ptr), sizeof (start_ptr), &(eolbyte), sizeof (eolbyte), &(mb_start), sizeof (mb_start), &(buflim), sizeof (buflim), &(beg), sizeof (beg), &(end), sizeof (end), &(kwset), sizeof (kwset), &(eol), sizeof (eol), &(match), sizeof (match), &(kwset_exact_matches), sizeof (kwset_exact_matches), &(backref), sizeof (backref), &(best_match), sizeof (best_match), &(best_len), sizeof (best_len), &(i), sizeof (i), &(pcount), sizeof (pcount), &(patterns), sizeof (patterns), &(start), sizeof (start), &(len), sizeof (len), &(match_words), sizeof (match_words), &(match_lines), sizeof (match_lines), &(ret_val), sizeof (ret_val), &(match_size), sizeof (match_size))))
    goto out;
if (match_icase) {
    char *case_buf = mbtolower(buf, &size);
    if (start_ptr)
        start_ptr = case_buf + (start_ptr - buf);
    buf = case_buf;
}

//CodeSeg 1:
    }
#endif /* MBS_SUPPORT */

  mb_start = buf;
  buflim = buf + size;

  for (beg = end = buf; end < buflim; beg = end)
    {
      if (!start_ptr)
	{
	  /* We don't care about an exact match.  */
	  if (kwset)
	    {
	      /* Find a possible match using the KWset matcher. */
	      size_t offset = kwsexec (kwset, beg, buflim - beg, &kwsm);
	      if (offset == (size_t) -1)
		goto failure;
	      beg += offset;
	      /* Narrow down to the line containing the candidate, and
		 run it through DFA. */
	      if ((end = memchr(beg, eol, buflim - beg)) != NULL)
	        end++;
              else
                end = buflim;
	      match = beg;
	      while (beg > buf && beg[-1] != eol)
		--beg;
	      if (kwsm.index < kwset_exact_matches)
                {
#ifdef MBS_SUPPORT
                  if (mb_start < beg)
                    mb_start = beg;
                  if (MB_CUR_MAX == 1 || !is_mb_middle (&mb_start, match, buflim))
#endif
                    goto success;
                }
	      if (dfaexec (&dfa, beg, (char *) end, 0, NULL, &backref) == NULL)
		continue;
	    }
	  else
	    {
	      /* No good fixed strings; start with DFA. */
	      char const *next_beg = dfaexec (&dfa, beg, (char *) buflim,
					      0, NULL, &backref);
	      if (next_beg == NULL)
		break;
	      /* Narrow down to the line we've found. */
	      beg = next_beg;
	      if ((end = memchr(beg, eol, buflim - beg)) != NULL)
	        end++;
              else
                end = buflim;
	      while (beg > buf && beg[-1] != eol)
		--beg;
	    }
	  /* Successful, no backreferences encountered! */
	  if (!backref)
	    goto success;
	}
      else
	{
	  /* We are looking for the leftmost (then longest) exact match.
	     We will go through the outer loop only once.  */
	  beg = start_ptr;
	  end = buflim;
	}

      /* If we've made it to this point, this means DFA has seen
	 a probable match, and we need to run it through Regex. */
      best_match = end;
      best_len = 0;
      for (i = 0; i < pcount; i++)
	{
	  patterns[i].regexbuf.not_eol = 0;
	  if (0 <= (start = re_search (&(patterns[i].regexbuf),
				       buf, end - buf - 1,
				       beg - buf, end - beg - 1,
				       &(patterns[i].regs))))
	    {
	      len = patterns[i].regs.end[0] - start;
	      match = buf + start;
	      if (match > best_match)
		continue;
	      if (start_ptr && !match_words)
		goto assess_pattern_match;
	      if ((!match_lines && !match_words)
		  || (match_lines && len == end - beg - 1))
		{
		  match = beg;
		  len = end - beg;
		  goto assess_pattern_match;
		}
	      /* If -w, check if the match aligns with word boundaries.
		 We do this iteratively because:
		 (a) the line may contain more than one occurence of the
		 pattern, and
		 (b) Several alternatives in the pattern might be valid at a
		 given point, and we may need to consider a shorter one to
		 find a word boundary.  */
	      if (match_words)
		while (match <= best_match)
		  {
		    if ((match == buf || !WCHAR ((unsigned char) match[-1]))
			&& (len == end - beg - 1
			    || !WCHAR ((unsigned char) match[len])))
		      goto assess_pattern_match;
		    if (len > 0)
		      {
			/* Try a shorter length anchored at the same place. */
			--len;
			patterns[i].regexbuf.not_eol = 1;
			len = re_match (&(patterns[i].regexbuf),
					buf, match + len - beg, match - buf,
					&(patterns[i].regs));
		      }
		    if (len <= 0)
		      {
			/* Try looking further on. */
			if (match == end - 1)
			  break;
			match++;
			patterns[i].regexbuf.not_eol = 0;
			start = re_search (&(patterns[i].regexbuf),
					   buf, end - buf - 1,
					   match - buf, end - match - 1,
					   &(patterns[i].regs));
			if (start < 0)
			  break;
			len = patterns[i].regs.end[0] - start;
			match = buf + start;
		      }
		  } /* while (match <= best_match) */
	      continue;
	    assess_pattern_match:
	      if (!start_ptr)
		{
		  /* Good enough for a non-exact match.
		     No need to look at further patterns, if any.  */
		  beg = match;
		  goto success_in_len;
		}
	      if (match < best_match || (match == best_match && len > best_len))
		{
		  /* Best exact match:  leftmost, then longest.  */
		  best_match = match;
		  best_len = len;
		}
	    } /* if re_search >= 0 */
	} /* for Regex patterns.  */
	if (best_match < end)
	  {
	    /* We have found an exact match.  We were just
	       waiting for the best one (leftmost then longest).  */
	    beg = best_match;
	    len = best_len;
	    goto success_in_len;
	  }
    } /* for (beg = end ..) */

 failure:
  ret_val = -1;
  goto out;

 success:
  len = end - beg;
 success_in_len:
  *match_size = len;
  ret_val = beg - buf;
 out:
  return ret_val;
}

Testing negative cases!
Testing 0 (with abstract condition) ENVIS_NEG
Iteration 0
Running test command:
/home/ubuntu/spr-fast/tools/grep-test.py /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-8a025cf8-8f08d8e2/tempworkdir-l/src /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-8a025cf8-8f08d8e2/tempworkdir-l/tests /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-8a025cf8-8f08d8e2/tempworkdir-l 0  > __res
Opening:/tmp/neg.tmp!
NegativeBRANCH RECORD/tmp/neg.tmp!
APPENDING TO ISNEG:/tmp/neg.tmp!
Branch 0: 0
Branch 1: 0
Iteration 1
Running test command:
/home/ubuntu/spr-fast/tools/grep-test.py /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-8a025cf8-8f08d8e2/tempworkdir-l/src /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-8a025cf8-8f08d8e2/tempworkdir-l/tests /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-8a025cf8-8f08d8e2/tempworkdir-l 0  > __res
Opening:/tmp/neg.tmp!
NegativeBRANCH RECORD/tmp/neg.tmp!
APPENDING TO ISNEG:/tmp/neg.tmp!
Branch 0: 0
Branch 1: 1
Iteration 2
Running test command:
/home/ubuntu/spr-fast/tools/grep-test.py /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-8a025cf8-8f08d8e2/tempworkdir-l/src /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-8a025cf8-8f08d8e2/tempworkdir-l/tests /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-8a025cf8-8f08d8e2/tempworkdir-l 0  > __res
Opening:/tmp/neg.tmp!
NegativeBRANCH RECORD/tmp/neg.tmp!
APPENDING TO ISNEG:/tmp/neg.tmp!
Branch 0: 1
Branch 1: 0
Iteration 3
Running test command:
/home/ubuntu/spr-fast/tools/grep-test.py /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-8a025cf8-8f08d8e2/tempworkdir-l/src /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-8a025cf8-8f08d8e2/tempworkdir-l/tests /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-8a025cf8-8f08d8e2/tempworkdir-l 0  > __res
Opening:/tmp/neg.tmp!
NegativeBRANCH RECORD/tmp/neg.tmp!
APPENDING TO ISNEG:/tmp/neg.tmp!
Branch 0: 1
Branch 1: 1
Running test command:
/home/ubuntu/spr-fast/tools/grep-test.py /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-8a025cf8-8f08d8e2/tempworkdir-l/src /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-8a025cf8-8f08d8e2/tempworkdir-l/tests /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-8a025cf8-8f08d8e2/tempworkdir-l 0  > __res
CondTester, Testing instance id 98:
//src_file:src/dfasearch.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); void* memset(void*, int, unsigned long); 
/* dfasearch.c - searching subroutines using dfa and regex for grep.
   Copyright 1992, 1998, 2000, 2007, 2009-2010 Free Software Foundation, Inc.

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 3, or (at your option)
   any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program; if not, write to the Free Software
   Foundation, Inc., 51 Franklin Street - Fifth Floor, Boston, MA
   02110-1301, USA.  */

/* Written August 1992 by Mike Haertel. */

#include <config.h>
#include "search.h"
#include "dfa.h"

/* For -w, we also consider _ to be word constituent.  */
#define WCHAR(C) (ISALNUM(C) || (C) == '_')

/* KWset compiled pattern.  For Ecompile and Gcompile, we compile
   a list of strings, at least one of which is known to occur in
   any string matching the regexp. */
static kwset_t kwset;

/* DFA compiled regexp. */
static struct dfa dfa;

/* The Regex compiled patterns.  */
static struct patterns
{
  /* Regex compiled regexp. */
  struct re_pattern_buffer regexbuf;
  struct re_registers regs; /* This is here on account of a BRAIN-DEAD
			       Q@#%!# library interface in regex.c.  */
} patterns0;

struct patterns *patterns;
size_t pcount;

void
dfaerror (char const *mesg)
{
  error (EXIT_TROUBLE, 0, "%s", mesg);

  /* notreached */
  /* Tell static analyzers that this function does not return.  */
  abort ();
}

/* Number of compiled fixed strings known to exactly match the regexp.
   If kwsexec returns < kwset_exact_matches, then we don't need to
   call the regexp matcher at all. */
static int kwset_exact_matches;

static char const *
kwsincr_case (const char *must)
{
  const char *buf;
  size_t n;

  n = strlen (must);
#ifdef MBS_SUPPORT
  if (match_icase && MB_CUR_MAX > 1)
    buf = mbtolower (must, &n);
  else
#endif
    buf = must;
  return kwsincr (kwset, buf, n);
}

/* If the DFA turns out to have some set of fixed strings one of
   which must occur in the match, then we build a kwset matcher
   to find those strings, and thus quickly filter out impossible
   matches. */
static void
kwsmusts (void)
{
  struct dfamust const *dm;
  char const *err;

  if (dfa.musts)
    {
      kwsinit (&kwset);
      /* First, we compile in the substrings known to be exact
	 matches.  The kwset matcher will return the index
	 of the matching string that it chooses. */
      for (dm = dfa.musts; dm; dm = dm->next)
	{
	  if (!dm->exact)
	    continue;
	  ++kwset_exact_matches;
	  if ((err = kwsincr_case (dm->must)) != NULL)
	    error (EXIT_TROUBLE, 0, "%s", err);
	}
      /* Now, we compile the substrings that will require
	 the use of the regexp matcher.  */
      for (dm = dfa.musts; dm; dm = dm->next)
	{
	  if (dm->exact)
	    continue;
	  if ((err = kwsincr_case (dm->must)) != NULL)
	    error (EXIT_TROUBLE, 0, "%s", err);
	}
      if ((err = kwsprep (kwset)) != NULL)
	error (EXIT_TROUBLE, 0, "%s", err);
    }
}

void
GEAcompile (char const *pattern, size_t size, reg_syntax_t syntax_bits)
{
  const char *err;
  const char *p, *sep;
  size_t total = size;
  char *motif;

  if (match_icase)
    syntax_bits |= RE_ICASE;
  re_set_syntax (syntax_bits);
  dfasyntax (syntax_bits, match_icase, eolbyte);

  /* For GNU regex compiler we have to pass the patterns separately to detect
     errors like "[\nallo\n]\n".  The patterns here are "[", "allo" and "]"
     GNU regex should have raise a syntax error.  The same for backref, where
     the backref should have been local to each pattern.  */
  p = pattern;
  do
    {
      size_t len;
      sep = memchr (p, '\n', total);
      if (sep)
	{
	  len = sep - p;
	  sep++;
	  total -= (len + 1);
	}
      else
	{
	  len = total;
	  total = 0;
	}

      patterns = realloc (patterns, (pcount + 1) * sizeof (*patterns));
      if (patterns == NULL)
	error (EXIT_TROUBLE, errno, _("memory exhausted"));
      patterns[pcount] = patterns0;

      if ((err = re_compile_pattern (p, len,
				    &(patterns[pcount].regexbuf))) != NULL)
	error (EXIT_TROUBLE, 0, "%s", err);
      pcount++;

      p = sep;
    } while (sep && total != 0);

  /* In the match_words and match_lines cases, we use a different pattern
     for the DFA matcher that will quickly throw out cases that won't work.
     Then if DFA succeeds we do some hairy stuff using the regex matcher
     to decide whether the match should really count. */
  if (match_words || match_lines)
    {
      static char const line_beg_no_bk[] = "^(";
      static char const line_end_no_bk[] = ")$";
      static char const word_beg_no_bk[] = "(^|[^[:alnum:]_])(";
      static char const word_end_no_bk[] = ")([^[:alnum:]_]|$)";
      static char const line_beg_bk[] = "^\\(";
      static char const line_end_bk[] = "\\)$";
      static char const word_beg_bk[] = "\\(^\\|[^[:alnum:]_]\\)\\(";
      static char const word_end_bk[] = "\\)\\([^[:alnum:]_]\\|$\\)";
      int bk = !(syntax_bits & RE_NO_BK_PARENS);
      char *n = xmalloc (sizeof word_beg_bk - 1 + size + sizeof word_end_bk);

      strcpy (n, match_lines ? (bk ? line_beg_bk : line_beg_no_bk)
			     : (bk ? word_beg_bk : word_beg_no_bk));
      total = strlen(n);
      memcpy (n + total, pattern, size);
      total += size;
      strcpy (n + total, match_lines ? (bk ? line_end_bk : line_end_no_bk)
				     : (bk ? word_end_bk : word_end_no_bk));
      total += strlen (n + total);
      pattern = motif = n;
      size = total;
    }
  else
    motif = NULL;

  dfacomp (pattern, size, &dfa, 1);
  kwsmusts ();

  free(motif);
}

size_t
EGexecute (char const *buf, size_t size, size_t *match_size,
	   char const *start_ptr)
{
  char const *buflim, *beg, *end, *match, *best_match, *mb_start;
  char eol = eolbyte;
  int backref, start, len, best_len;
  struct kwsmatch kwsm;
  size_t i, ret_val;
#ifdef MBS_SUPPORT
  if (MB_CUR_MAX > 1)
    {
      
//Patch 0:
if ((__is_neg(25, &(match_icase), sizeof (match_icase), &(buf), sizeof (buf), &(size), sizeof (size), &(start_ptr), sizeof (start_ptr), &(eolbyte), sizeof (eolbyte), &(mb_start), sizeof (mb_start), &(buflim), sizeof (buflim), &(beg), sizeof (beg), &(end), sizeof (end), &(kwset), sizeof (kwset), &(eol), sizeof (eol), &(match), sizeof (match), &(kwset_exact_matches), sizeof (kwset_exact_matches), &(backref), sizeof (backref), &(best_match), sizeof (best_match), &(best_len), sizeof (best_len), &(i), sizeof (i), &(pcount), sizeof (pcount), &(patterns), sizeof (patterns), &(start), sizeof (start), &(len), sizeof (len), &(match_words), sizeof (match_words), &(match_lines), sizeof (match_lines), &(ret_val), sizeof (ret_val), &(match_size), sizeof (match_size))))
    return -1;
if (match_icase) {
    char *case_buf = mbtolower(buf, &size);
    if (start_ptr)
        start_ptr = case_buf + (start_ptr - buf);
    buf = case_buf;
}

//CodeSeg 1:
    }
#endif /* MBS_SUPPORT */

  mb_start = buf;
  buflim = buf + size;

  for (beg = end = buf; end < buflim; beg = end)
    {
      if (!start_ptr)
	{
	  /* We don't care about an exact match.  */
	  if (kwset)
	    {
	      /* Find a possible match using the KWset matcher. */
	      size_t offset = kwsexec (kwset, beg, buflim - beg, &kwsm);
	      if (offset == (size_t) -1)
		goto failure;
	      beg += offset;
	      /* Narrow down to the line containing the candidate, and
		 run it through DFA. */
	      if ((end = memchr(beg, eol, buflim - beg)) != NULL)
	        end++;
              else
                end = buflim;
	      match = beg;
	      while (beg > buf && beg[-1] != eol)
		--beg;
	      if (kwsm.index < kwset_exact_matches)
                {
#ifdef MBS_SUPPORT
                  if (mb_start < beg)
                    mb_start = beg;
                  if (MB_CUR_MAX == 1 || !is_mb_middle (&mb_start, match, buflim))
#endif
                    goto success;
                }
	      if (dfaexec (&dfa, beg, (char *) end, 0, NULL, &backref) == NULL)
		continue;
	    }
	  else
	    {
	      /* No good fixed strings; start with DFA. */
	      char const *next_beg = dfaexec (&dfa, beg, (char *) buflim,
					      0, NULL, &backref);
	      if (next_beg == NULL)
		break;
	      /* Narrow down to the line we've found. */
	      beg = next_beg;
	      if ((end = memchr(beg, eol, buflim - beg)) != NULL)
	        end++;
              else
                end = buflim;
	      while (beg > buf && beg[-1] != eol)
		--beg;
	    }
	  /* Successful, no backreferences encountered! */
	  if (!backref)
	    goto success;
	}
      else
	{
	  /* We are looking for the leftmost (then longest) exact match.
	     We will go through the outer loop only once.  */
	  beg = start_ptr;
	  end = buflim;
	}

      /* If we've made it to this point, this means DFA has seen
	 a probable match, and we need to run it through Regex. */
      best_match = end;
      best_len = 0;
      for (i = 0; i < pcount; i++)
	{
	  patterns[i].regexbuf.not_eol = 0;
	  if (0 <= (start = re_search (&(patterns[i].regexbuf),
				       buf, end - buf - 1,
				       beg - buf, end - beg - 1,
				       &(patterns[i].regs))))
	    {
	      len = patterns[i].regs.end[0] - start;
	      match = buf + start;
	      if (match > best_match)
		continue;
	      if (start_ptr && !match_words)
		goto assess_pattern_match;
	      if ((!match_lines && !match_words)
		  || (match_lines && len == end - beg - 1))
		{
		  match = beg;
		  len = end - beg;
		  goto assess_pattern_match;
		}
	      /* If -w, check if the match aligns with word boundaries.
		 We do this iteratively because:
		 (a) the line may contain more than one occurence of the
		 pattern, and
		 (b) Several alternatives in the pattern might be valid at a
		 given point, and we may need to consider a shorter one to
		 find a word boundary.  */
	      if (match_words)
		while (match <= best_match)
		  {
		    if ((match == buf || !WCHAR ((unsigned char) match[-1]))
			&& (len == end - beg - 1
			    || !WCHAR ((unsigned char) match[len])))
		      goto assess_pattern_match;
		    if (len > 0)
		      {
			/* Try a shorter length anchored at the same place. */
			--len;
			patterns[i].regexbuf.not_eol = 1;
			len = re_match (&(patterns[i].regexbuf),
					buf, match + len - beg, match - buf,
					&(patterns[i].regs));
		      }
		    if (len <= 0)
		      {
			/* Try looking further on. */
			if (match == end - 1)
			  break;
			match++;
			patterns[i].regexbuf.not_eol = 0;
			start = re_search (&(patterns[i].regexbuf),
					   buf, end - buf - 1,
					   match - buf, end - match - 1,
					   &(patterns[i].regs));
			if (start < 0)
			  break;
			len = patterns[i].regs.end[0] - start;
			match = buf + start;
		      }
		  } /* while (match <= best_match) */
	      continue;
	    assess_pattern_match:
	      if (!start_ptr)
		{
		  /* Good enough for a non-exact match.
		     No need to look at further patterns, if any.  */
		  beg = match;
		  goto success_in_len;
		}
	      if (match < best_match || (match == best_match && len > best_len))
		{
		  /* Best exact match:  leftmost, then longest.  */
		  best_match = match;
		  best_len = len;
		}
	    } /* if re_search >= 0 */
	} /* for Regex patterns.  */
	if (best_match < end)
	  {
	    /* We have found an exact match.  We were just
	       waiting for the best one (leftmost then longest).  */
	    beg = best_match;
	    len = best_len;
	    goto success_in_len;
	  }
    } /* for (beg = end ..) */

 failure:
  ret_val = -1;
  goto out;

 success:
  len = end - beg;
 success_in_len:
  *match_size = len;
  ret_val = beg - buf;
 out:
  return ret_val;
}

Testing negative cases!
Testing 0 (with abstract condition) ENVIS_NEG
Iteration 0
Running test command:
/home/ubuntu/spr-fast/tools/grep-test.py /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-8a025cf8-8f08d8e2/tempworkdir-l/src /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-8a025cf8-8f08d8e2/tempworkdir-l/tests /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-8a025cf8-8f08d8e2/tempworkdir-l 0  > __res
Opening:/tmp/neg.tmp!
NegativeBRANCH RECORD/tmp/neg.tmp!
APPENDING TO ISNEG:/tmp/neg.tmp!
Branch 0: 0
Branch 1: 0
Iteration 1
Running test command:
/home/ubuntu/spr-fast/tools/grep-test.py /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-8a025cf8-8f08d8e2/tempworkdir-l/src /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-8a025cf8-8f08d8e2/tempworkdir-l/tests /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-8a025cf8-8f08d8e2/tempworkdir-l 0  > __res
Opening:/tmp/neg.tmp!
NegativeBRANCH RECORD/tmp/neg.tmp!
APPENDING TO ISNEG:/tmp/neg.tmp!
Branch 0: 0
Branch 1: 1
Iteration 2
Running test command:
/home/ubuntu/spr-fast/tools/grep-test.py /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-8a025cf8-8f08d8e2/tempworkdir-l/src /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-8a025cf8-8f08d8e2/tempworkdir-l/tests /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-8a025cf8-8f08d8e2/tempworkdir-l 0  > __res
Opening:/tmp/neg.tmp!
NegativeBRANCH RECORD/tmp/neg.tmp!
APPENDING TO ISNEG:/tmp/neg.tmp!
Branch 0: 1
Running test command:
/home/ubuntu/spr-fast/tools/grep-test.py /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-8a025cf8-8f08d8e2/tempworkdir-l/src /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-8a025cf8-8f08d8e2/tempworkdir-l/tests /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-8a025cf8-8f08d8e2/tempworkdir-l 0  > __res
CondTester, Testing instance id 99:
//src_file:src/dfasearch.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); void* memset(void*, int, unsigned long); 
/* dfasearch.c - searching subroutines using dfa and regex for grep.
   Copyright 1992, 1998, 2000, 2007, 2009-2010 Free Software Foundation, Inc.

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 3, or (at your option)
   any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program; if not, write to the Free Software
   Foundation, Inc., 51 Franklin Street - Fifth Floor, Boston, MA
   02110-1301, USA.  */

/* Written August 1992 by Mike Haertel. */

#include <config.h>
#include "search.h"
#include "dfa.h"

/* For -w, we also consider _ to be word constituent.  */
#define WCHAR(C) (ISALNUM(C) || (C) == '_')

/* KWset compiled pattern.  For Ecompile and Gcompile, we compile
   a list of strings, at least one of which is known to occur in
   any string matching the regexp. */
static kwset_t kwset;

/* DFA compiled regexp. */
static struct dfa dfa;

/* The Regex compiled patterns.  */
static struct patterns
{
  /* Regex compiled regexp. */
  struct re_pattern_buffer regexbuf;
  struct re_registers regs; /* This is here on account of a BRAIN-DEAD
			       Q@#%!# library interface in regex.c.  */
} patterns0;

struct patterns *patterns;
size_t pcount;

void
dfaerror (char const *mesg)
{
  error (EXIT_TROUBLE, 0, "%s", mesg);

  /* notreached */
  /* Tell static analyzers that this function does not return.  */
  abort ();
}

/* Number of compiled fixed strings known to exactly match the regexp.
   If kwsexec returns < kwset_exact_matches, then we don't need to
   call the regexp matcher at all. */
static int kwset_exact_matches;

static char const *
kwsincr_case (const char *must)
{
  const char *buf;
  size_t n;

  n = strlen (must);
#ifdef MBS_SUPPORT
  if (match_icase && MB_CUR_MAX > 1)
    buf = mbtolower (must, &n);
  else
#endif
    buf = must;
  return kwsincr (kwset, buf, n);
}

/* If the DFA turns out to have some set of fixed strings one of
   which must occur in the match, then we build a kwset matcher
   to find those strings, and thus quickly filter out impossible
   matches. */
static void
kwsmusts (void)
{
  struct dfamust const *dm;
  char const *err;

  if (dfa.musts)
    {
      kwsinit (&kwset);
      /* First, we compile in the substrings known to be exact
	 matches.  The kwset matcher will return the index
	 of the matching string that it chooses. */
      for (dm = dfa.musts; dm; dm = dm->next)
	{
	  if (!dm->exact)
	    continue;
	  ++kwset_exact_matches;
	  if ((err = kwsincr_case (dm->must)) != NULL)
	    error (EXIT_TROUBLE, 0, "%s", err);
	}
      /* Now, we compile the substrings that will require
	 the use of the regexp matcher.  */
      for (dm = dfa.musts; dm; dm = dm->next)
	{
	  if (dm->exact)
	    continue;
	  if ((err = kwsincr_case (dm->must)) != NULL)
	    error (EXIT_TROUBLE, 0, "%s", err);
	}
      if ((err = kwsprep (kwset)) != NULL)
	error (EXIT_TROUBLE, 0, "%s", err);
    }
}

void
GEAcompile (char const *pattern, size_t size, reg_syntax_t syntax_bits)
{
  const char *err;
  const char *p, *sep;
  size_t total = size;
  char *motif;

  if (match_icase)
    syntax_bits |= RE_ICASE;
  re_set_syntax (syntax_bits);
  dfasyntax (syntax_bits, match_icase, eolbyte);

  /* For GNU regex compiler we have to pass the patterns separately to detect
     errors like "[\nallo\n]\n".  The patterns here are "[", "allo" and "]"
     GNU regex should have raise a syntax error.  The same for backref, where
     the backref should have been local to each pattern.  */
  p = pattern;
  do
    {
      size_t len;
      sep = memchr (p, '\n', total);
      if (sep)
	{
	  len = sep - p;
	  sep++;
	  total -= (len + 1);
	}
      else
	{
	  len = total;
	  total = 0;
	}

      patterns = realloc (patterns, (pcount + 1) * sizeof (*patterns));
      if (patterns == NULL)
	error (EXIT_TROUBLE, errno, _("memory exhausted"));
      patterns[pcount] = patterns0;

      if ((err = re_compile_pattern (p, len,
				    &(patterns[pcount].regexbuf))) != NULL)
	error (EXIT_TROUBLE, 0, "%s", err);
      pcount++;

      p = sep;
    } while (sep && total != 0);

  /* In the match_words and match_lines cases, we use a different pattern
     for the DFA matcher that will quickly throw out cases that won't work.
     Then if DFA succeeds we do some hairy stuff using the regex matcher
     to decide whether the match should really count. */
  if (match_words || match_lines)
    {
      static char const line_beg_no_bk[] = "^(";
      static char const line_end_no_bk[] = ")$";
      static char const word_beg_no_bk[] = "(^|[^[:alnum:]_])(";
      static char const word_end_no_bk[] = ")([^[:alnum:]_]|$)";
      static char const line_beg_bk[] = "^\\(";
      static char const line_end_bk[] = "\\)$";
      static char const word_beg_bk[] = "\\(^\\|[^[:alnum:]_]\\)\\(";
      static char const word_end_bk[] = "\\)\\([^[:alnum:]_]\\|$\\)";
      int bk = !(syntax_bits & RE_NO_BK_PARENS);
      char *n = xmalloc (sizeof word_beg_bk - 1 + size + sizeof word_end_bk);

      strcpy (n, match_lines ? (bk ? line_beg_bk : line_beg_no_bk)
			     : (bk ? word_beg_bk : word_beg_no_bk));
      total = strlen(n);
      memcpy (n + total, pattern, size);
      total += size;
      strcpy (n + total, match_lines ? (bk ? line_end_bk : line_end_no_bk)
				     : (bk ? word_end_bk : word_end_no_bk));
      total += strlen (n + total);
      pattern = motif = n;
      size = total;
    }
  else
    motif = NULL;

  dfacomp (pattern, size, &dfa, 1);
  kwsmusts ();

  free(motif);
}

size_t
EGexecute (char const *buf, size_t size, size_t *match_size,
	   char const *start_ptr)
{
  char const *buflim, *beg, *end, *match, *best_match, *mb_start;
  char eol = eolbyte;
  int backref, start, len, best_len;
  struct kwsmatch kwsm;
  size_t i, ret_val;
#ifdef MBS_SUPPORT
  if (MB_CUR_MAX > 1)
    {
      
//Patch 0:
if ((__is_neg(25, &(match_icase), sizeof (match_icase), &(buf), sizeof (buf), &(size), sizeof (size), &(start_ptr), sizeof (start_ptr), &(eolbyte), sizeof (eolbyte), &(mb_start), sizeof (mb_start), &(buflim), sizeof (buflim), &(beg), sizeof (beg), &(end), sizeof (end), &(kwset), sizeof (kwset), &(eol), sizeof (eol), &(match), sizeof (match), &(kwset_exact_matches), sizeof (kwset_exact_matches), &(backref), sizeof (backref), &(best_match), sizeof (best_match), &(best_len), sizeof (best_len), &(i), sizeof (i), &(pcount), sizeof (pcount), &(patterns), sizeof (patterns), &(start), sizeof (start), &(len), sizeof (len), &(match_words), sizeof (match_words), &(match_lines), sizeof (match_lines), &(ret_val), sizeof (ret_val), &(match_size), sizeof (match_size))))
    return 0;
if (match_icase) {
    char *case_buf = mbtolower(buf, &size);
    if (start_ptr)
        start_ptr = case_buf + (start_ptr - buf);
    buf = case_buf;
}

//CodeSeg 1:
    }
#endif /* MBS_SUPPORT */

  mb_start = buf;
  buflim = buf + size;

  for (beg = end = buf; end < buflim; beg = end)
    {
      if (!start_ptr)
	{
	  /* We don't care about an exact match.  */
	  if (kwset)
	    {
	      /* Find a possible match using the KWset matcher. */
	      size_t offset = kwsexec (kwset, beg, buflim - beg, &kwsm);
	      if (offset == (size_t) -1)
		goto failure;
	      beg += offset;
	      /* Narrow down to the line containing the candidate, and
		 run it through DFA. */
	      if ((end = memchr(beg, eol, buflim - beg)) != NULL)
	        end++;
              else
                end = buflim;
	      match = beg;
	      while (beg > buf && beg[-1] != eol)
		--beg;
	      if (kwsm.index < kwset_exact_matches)
                {
#ifdef MBS_SUPPORT
                  if (mb_start < beg)
                    mb_start = beg;
                  if (MB_CUR_MAX == 1 || !is_mb_middle (&mb_start, match, buflim))
#endif
                    goto success;
                }
	      if (dfaexec (&dfa, beg, (char *) end, 0, NULL, &backref) == NULL)
		continue;
	    }
	  else
	    {
	      /* No good fixed strings; start with DFA. */
	      char const *next_beg = dfaexec (&dfa, beg, (char *) buflim,
					      0, NULL, &backref);
	      if (next_beg == NULL)
		break;
	      /* Narrow down to the line we've found. */
	      beg = next_beg;
	      if ((end = memchr(beg, eol, buflim - beg)) != NULL)
	        end++;
              else
                end = buflim;
	      while (beg > buf && beg[-1] != eol)
		--beg;
	    }
	  /* Successful, no backreferences encountered! */
	  if (!backref)
	    goto success;
	}
      else
	{
	  /* We are looking for the leftmost (then longest) exact match.
	     We will go through the outer loop only once.  */
	  beg = start_ptr;
	  end = buflim;
	}

      /* If we've made it to this point, this means DFA has seen
	 a probable match, and we need to run it through Regex. */
      best_match = end;
      best_len = 0;
      for (i = 0; i < pcount; i++)
	{
	  patterns[i].regexbuf.not_eol = 0;
	  if (0 <= (start = re_search (&(patterns[i].regexbuf),
				       buf, end - buf - 1,
				       beg - buf, end - beg - 1,
				       &(patterns[i].regs))))
	    {
	      len = patterns[i].regs.end[0] - start;
	      match = buf + start;
	      if (match > best_match)
		continue;
	      if (start_ptr && !match_words)
		goto assess_pattern_match;
	      if ((!match_lines && !match_words)
		  || (match_lines && len == end - beg - 1))
		{
		  match = beg;
		  len = end - beg;
		  goto assess_pattern_match;
		}
	      /* If -w, check if the match aligns with word boundaries.
		 We do this iteratively because:
		 (a) the line may contain more than one occurence of the
		 pattern, and
		 (b) Several alternatives in the pattern might be valid at a
		 given point, and we may need to consider a shorter one to
		 find a word boundary.  */
	      if (match_words)
		while (match <= best_match)
		  {
		    if ((match == buf || !WCHAR ((unsigned char) match[-1]))
			&& (len == end - beg - 1
			    || !WCHAR ((unsigned char) match[len])))
		      goto assess_pattern_match;
		    if (len > 0)
		      {
			/* Try a shorter length anchored at the same place. */
			--len;
			patterns[i].regexbuf.not_eol = 1;
			len = re_match (&(patterns[i].regexbuf),
					buf, match + len - beg, match - buf,
					&(patterns[i].regs));
		      }
		    if (len <= 0)
		      {
			/* Try looking further on. */
			if (match == end - 1)
			  break;
			match++;
			patterns[i].regexbuf.not_eol = 0;
			start = re_search (&(patterns[i].regexbuf),
					   buf, end - buf - 1,
					   match - buf, end - match - 1,
					   &(patterns[i].regs));
			if (start < 0)
			  break;
			len = patterns[i].regs.end[0] - start;
			match = buf + start;
		      }
		  } /* while (match <= best_match) */
	      continue;
	    assess_pattern_match:
	      if (!start_ptr)
		{
		  /* Good enough for a non-exact match.
		     No need to look at further patterns, if any.  */
		  beg = match;
		  goto success_in_len;
		}
	      if (match < best_match || (match == best_match && len > best_len))
		{
		  /* Best exact match:  leftmost, then longest.  */
		  best_match = match;
		  best_len = len;
		}
	    } /* if re_search >= 0 */
	} /* for Regex patterns.  */
	if (best_match < end)
	  {
	    /* We have found an exact match.  We were just
	       waiting for the best one (leftmost then longest).  */
	    beg = best_match;
	    len = best_len;
	    goto success_in_len;
	  }
    } /* for (beg = end ..) */

 failure:
  ret_val = -1;
  goto out;

 success:
  len = end - beg;
 success_in_len:
  *match_size = len;
  ret_val = beg - buf;
 out:
  return ret_val;
}

Testing negative cases!
Testing 0 (with abstract condition) ENVIS_NEG
Iteration 0
Running test command:
/home/ubuntu/spr-fast/tools/grep-test.py /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-8a025cf8-8f08d8e2/tempworkdir-l/src /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-8a025cf8-8f08d8e2/tempworkdir-l/tests /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-8a025cf8-8f08d8e2/tempworkdir-l 0  > __res
Opening:/tmp/neg.tmp!
NegativeBRANCH RECORD/tmp/neg.tmp!
APPENDING TO ISNEG:/tmp/neg.tmp!
Branch 0: 0
Branch 1: 0
Iteration 1
Running test command:
/home/ubuntu/spr-fast/tools/grep-test.py /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-8a025cf8-8f08d8e2/tempworkdir-l/src /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-8a025cf8-8f08d8e2/tempworkdir-l/tests /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-8a025cf8-8f08d8e2/tempworkdir-l 0  > __res
Opening:/tmp/neg.tmp!
NegativeBRANCH RECORD/tmp/neg.tmp!
APPENDING TO ISNEG:/tmp/neg.tmp!
Branch 0: 0
Branch 1: 1
Branch 2: 0
Iteration 2
Running test command:
/home/ubuntu/spr-fast/tools/grep-test.py /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-8a025cf8-8f08d8e2/tempworkdir-l/src /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-8a025cf8-8f08d8e2/tempworkdir-l/tests /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-8a025cf8-8f08d8e2/tempworkdir-l 0  > __res
Opening:/tmp/neg.tmp!
NegativeBRANCH RECORD/tmp/neg.tmp!
APPENDING TO ISNEG:/tmp/neg.tmp!
Branch 0: 0
Branch 1: 1
Branch 2: 1
Branch 3: 0
Iteration 3
Running test command:
/home/ubuntu/spr-fast/tools/grep-test.py /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-8a025cf8-8f08d8e2/tempworkdir-l/src /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-8a025cf8-8f08d8e2/tempworkdir-l/tests /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-8a025cf8-8f08d8e2/tempworkdir-l 0  > __res
Opening:/tmp/neg.tmp!
NegativeBRANCH RECORD/tmp/neg.tmp!
APPENDING TO ISNEG:/tmp/neg.tmp!
Branch 0: 0
Branch 1: 1
Branch 2: 1
Branch 3: 1
Branch 4: 0
Iteration 4
Running test command:
/home/ubuntu/spr-fast/tools/grep-test.py /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-8a025cf8-8f08d8e2/tempworkdir-l/src /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-8a025cf8-8f08d8e2/tempworkdir-l/tests /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-8a025cf8-8f08d8e2/tempworkdir-l 0  > __res
Opening:/tmp/neg.tmp!
NegativeBRANCH RECORD/tmp/neg.tmp!
APPENDING TO ISNEG:/tmp/neg.tmp!
Branch 0: 0
Branch 1: 1
Branch 2: 1
Branch 3: 1
Branch 4: 1
Branch 5: 0
Iteration 5
Running test command:
/home/ubuntu/spr-fast/tools/grep-test.py /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-8a025cf8-8f08d8e2/tempworkdir-l/src /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-8a025cf8-8f08d8e2/tempworkdir-l/tests /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-8a025cf8-8f08d8e2/tempworkdir-l 0  > __res
Opening:/tmp/neg.tmp!
NegativeBRANCH RECORD/tmp/neg.tmp!
APPENDING TO ISNEG:/tmp/neg.tmp!
Branch 0: 0
Branch 1: 1
Branch 2: 1
Branch 3: 1
Branch 4: 1
Branch 5: 1
Branch 6: 0
Iteration 6
Running test command:
/home/ubuntu/spr-fast/tools/grep-test.py /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-8a025cf8-8f08d8e2/tempworkdir-l/src /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-8a025cf8-8f08d8e2/tempworkdir-l/tests /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-8a025cf8-8f08d8e2/tempworkdir-l 0  > __res
Opening:/tmp/neg.tmp!
NegativeBRANCH RECORD/tmp/neg.tmp!
APPENDING TO ISNEG:/tmp/neg.tmp!
Branch 0: 0
Branch 1: 1
Branch 2: 1
Branch 3: 1
Branch 4: 1
Branch 5: 1
Branch 6: 1
Branch 7: 0
Iteration 7
Running test command:
/home/ubuntu/spr-fast/tools/grep-test.py /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-8a025cf8-8f08d8e2/tempworkdir-l/src /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-8a025cf8-8f08d8e2/tempworkdir-l/tests /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-8a025cf8-8f08d8e2/tempworkdir-l 0  > __res
Opening:/tmp/neg.tmp!
NegativeBRANCH RECORD/tmp/neg.tmp!
APPENDING TO ISNEG:/tmp/neg.tmp!
Branch 0: 0
Branch 1: 1
Branch 2: 1
Branch 3: 1
Branch 4: 1
Branch 5: 1
Branch 6: 1
Branch 7: 1
Branch 8: 0
Iteration 8
Running test command:
/home/ubuntu/spr-fast/tools/grep-test.py /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-8a025cf8-8f08d8e2/tempworkdir-l/src /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-8a025cf8-8f08d8e2/tempworkdir-l/tests /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-8a025cf8-8f08d8e2/tempworkdir-l 0  > __res
Opening:/tmp/neg.tmp!
NegativeBRANCH RECORD/tmp/neg.tmp!
APPENDING TO ISNEG:/tmp/neg.tmp!
Branch 0: 0
Branch 1: 1
Branch 2: 1
Branch 3: 1
Branch 4: 1
Branch 5: 1
Branch 6: 1
Branch 7: 1
Branch 8: 1
Branch 9: 0
Iteration 9
Running test command:
/home/ubuntu/spr-fast/tools/grep-test.py /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-8a025cf8-8f08d8e2/tempworkdir-l/src /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-8a025cf8-8f08d8e2/tempworkdir-l/tests /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-8a025cf8-8f08d8e2/tempworkdir-l 0  > __res
Opening:/tmp/neg.tmp!
NegativeBRANCH RECORD/tmp/neg.tmp!
APPENDING TO ISNEG:/tmp/neg.tmp!
Branch 0: 0
Branch 1: 1
Branch 2: 1
Branch 3: 1
Branch 4: 1
Branch 5: 1
Branch 6: 1
Branch 7: 1
Branch 8: 1
Branch 9: 1
Branch 10: 0
Running test command:
/home/ubuntu/spr-fast/tools/grep-test.py /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-8a025cf8-8f08d8e2/tempworkdir-l/src /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-8a025cf8-8f08d8e2/tempworkdir-l/tests /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-8a025cf8-8f08d8e2/tempworkdir-l 0  > __res
CondTester, Testing instance id 100:
//src_file:src/dfasearch.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); void* memset(void*, int, unsigned long); 
/* dfasearch.c - searching subroutines using dfa and regex for grep.
   Copyright 1992, 1998, 2000, 2007, 2009-2010 Free Software Foundation, Inc.

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 3, or (at your option)
   any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program; if not, write to the Free Software
   Foundation, Inc., 51 Franklin Street - Fifth Floor, Boston, MA
   02110-1301, USA.  */

/* Written August 1992 by Mike Haertel. */

#include <config.h>
#include "search.h"
#include "dfa.h"

/* For -w, we also consider _ to be word constituent.  */
#define WCHAR(C) (ISALNUM(C) || (C) == '_')

/* KWset compiled pattern.  For Ecompile and Gcompile, we compile
   a list of strings, at least one of which is known to occur in
   any string matching the regexp. */
static kwset_t kwset;

/* DFA compiled regexp. */
static struct dfa dfa;

/* The Regex compiled patterns.  */
static struct patterns
{
  /* Regex compiled regexp. */
  struct re_pattern_buffer regexbuf;
  struct re_registers regs; /* This is here on account of a BRAIN-DEAD
			       Q@#%!# library interface in regex.c.  */
} patterns0;

struct patterns *patterns;
size_t pcount;

void
dfaerror (char const *mesg)
{
  error (EXIT_TROUBLE, 0, "%s", mesg);

  /* notreached */
  /* Tell static analyzers that this function does not return.  */
  abort ();
}

/* Number of compiled fixed strings known to exactly match the regexp.
   If kwsexec returns < kwset_exact_matches, then we don't need to
   call the regexp matcher at all. */
static int kwset_exact_matches;

static char const *
kwsincr_case (const char *must)
{
  const char *buf;
  size_t n;

  n = strlen (must);
#ifdef MBS_SUPPORT
  if (match_icase && MB_CUR_MAX > 1)
    buf = mbtolower (must, &n);
  else
#endif
    buf = must;
  return kwsincr (kwset, buf, n);
}

/* If the DFA turns out to have some set of fixed strings one of
   which must occur in the match, then we build a kwset matcher
   to find those strings, and thus quickly filter out impossible
   matches. */
static void
kwsmusts (void)
{
  struct dfamust const *dm;
  char const *err;

  if (dfa.musts)
    {
      kwsinit (&kwset);
      /* First, we compile in the substrings known to be exact
	 matches.  The kwset matcher will return the index
	 of the matching string that it chooses. */
      for (dm = dfa.musts; dm; dm = dm->next)
	{
	  if (!dm->exact)
	    continue;
	  ++kwset_exact_matches;
	  if ((err = kwsincr_case (dm->must)) != NULL)
	    error (EXIT_TROUBLE, 0, "%s", err);
	}
      /* Now, we compile the substrings that will require
	 the use of the regexp matcher.  */
      for (dm = dfa.musts; dm; dm = dm->next)
	{
	  if (dm->exact)
	    continue;
	  if ((err = kwsincr_case (dm->must)) != NULL)
	    error (EXIT_TROUBLE, 0, "%s", err);
	}
      if ((err = kwsprep (kwset)) != NULL)
	error (EXIT_TROUBLE, 0, "%s", err);
    }
}

void
GEAcompile (char const *pattern, size_t size, reg_syntax_t syntax_bits)
{
  const char *err;
  const char *p, *sep;
  size_t total = size;
  char *motif;

  if (match_icase)
    syntax_bits |= RE_ICASE;
  re_set_syntax (syntax_bits);
  dfasyntax (syntax_bits, match_icase, eolbyte);

  /* For GNU regex compiler we have to pass the patterns separately to detect
     errors like "[\nallo\n]\n".  The patterns here are "[", "allo" and "]"
     GNU regex should have raise a syntax error.  The same for backref, where
     the backref should have been local to each pattern.  */
  p = pattern;
  do
    {
      size_t len;
      sep = memchr (p, '\n', total);
      if (sep)
	{
	  len = sep - p;
	  sep++;
	  total -= (len + 1);
	}
      else
	{
	  len = total;
	  total = 0;
	}

      patterns = realloc (patterns, (pcount + 1) * sizeof (*patterns));
      if (patterns == NULL)
	error (EXIT_TROUBLE, errno, _("memory exhausted"));
      patterns[pcount] = patterns0;

      if ((err = re_compile_pattern (p, len,
				    &(patterns[pcount].regexbuf))) != NULL)
	error (EXIT_TROUBLE, 0, "%s", err);
      pcount++;

      p = sep;
    } while (sep && total != 0);

  /* In the match_words and match_lines cases, we use a different pattern
     for the DFA matcher that will quickly throw out cases that won't work.
     Then if DFA succeeds we do some hairy stuff using the regex matcher
     to decide whether the match should really count. */
  if (match_words || match_lines)
    {
      static char const line_beg_no_bk[] = "^(";
      static char const line_end_no_bk[] = ")$";
      static char const word_beg_no_bk[] = "(^|[^[:alnum:]_])(";
      static char const word_end_no_bk[] = ")([^[:alnum:]_]|$)";
      static char const line_beg_bk[] = "^\\(";
      static char const line_end_bk[] = "\\)$";
      static char const word_beg_bk[] = "\\(^\\|[^[:alnum:]_]\\)\\(";
      static char const word_end_bk[] = "\\)\\([^[:alnum:]_]\\|$\\)";
      int bk = !(syntax_bits & RE_NO_BK_PARENS);
      char *n = xmalloc (sizeof word_beg_bk - 1 + size + sizeof word_end_bk);

      strcpy (n, match_lines ? (bk ? line_beg_bk : line_beg_no_bk)
			     : (bk ? word_beg_bk : word_beg_no_bk));
      total = strlen(n);
      memcpy (n + total, pattern, size);
      total += size;
      strcpy (n + total, match_lines ? (bk ? line_end_bk : line_end_no_bk)
				     : (bk ? word_end_bk : word_end_no_bk));
      total += strlen (n + total);
      pattern = motif = n;
      size = total;
    }
  else
    motif = NULL;

  dfacomp (pattern, size, &dfa, 1);
  kwsmusts ();

  free(motif);
}

size_t
EGexecute (char const *buf, size_t size, size_t *match_size,
	   char const *start_ptr)
{
  char const *buflim, *beg, *end, *match, *best_match, *mb_start;
  char eol = eolbyte;
  int backref, start, len, best_len;
  struct kwsmatch kwsm;
  size_t i, ret_val;
#ifdef MBS_SUPPORT
  if (MB_CUR_MAX > 1)
    {
      
//Patch 0:
if ((__is_neg(25, &(match_icase), sizeof (match_icase), &(buf), sizeof (buf), &(size), sizeof (size), &(start_ptr), sizeof (start_ptr), &(eolbyte), sizeof (eolbyte), &(mb_start), sizeof (mb_start), &(buflim), sizeof (buflim), &(beg), sizeof (beg), &(end), sizeof (end), &(kwset), sizeof (kwset), &(eol), sizeof (eol), &(match), sizeof (match), &(kwset_exact_matches), sizeof (kwset_exact_matches), &(backref), sizeof (backref), &(best_match), sizeof (best_match), &(best_len), sizeof (best_len), &(i), sizeof (i), &(pcount), sizeof (pcount), &(patterns), sizeof (patterns), &(start), sizeof (start), &(len), sizeof (len), &(match_words), sizeof (match_words), &(match_lines), sizeof (match_lines), &(ret_val), sizeof (ret_val), &(match_size), sizeof (match_size))))
    return 1;
if (match_icase) {
    char *case_buf = mbtolower(buf, &size);
    if (start_ptr)
        start_ptr = case_buf + (start_ptr - buf);
    buf = case_buf;
}

//CodeSeg 1:
    }
#endif /* MBS_SUPPORT */

  mb_start = buf;
  buflim = buf + size;

  for (beg = end = buf; end < buflim; beg = end)
    {
      if (!start_ptr)
	{
	  /* We don't care about an exact match.  */
	  if (kwset)
	    {
	      /* Find a possible match using the KWset matcher. */
	      size_t offset = kwsexec (kwset, beg, buflim - beg, &kwsm);
	      if (offset == (size_t) -1)
		goto failure;
	      beg += offset;
	      /* Narrow down to the line containing the candidate, and
		 run it through DFA. */
	      if ((end = memchr(beg, eol, buflim - beg)) != NULL)
	        end++;
              else
                end = buflim;
	      match = beg;
	      while (beg > buf && beg[-1] != eol)
		--beg;
	      if (kwsm.index < kwset_exact_matches)
                {
#ifdef MBS_SUPPORT
                  if (mb_start < beg)
                    mb_start = beg;
                  if (MB_CUR_MAX == 1 || !is_mb_middle (&mb_start, match, buflim))
#endif
                    goto success;
                }
	      if (dfaexec (&dfa, beg, (char *) end, 0, NULL, &backref) == NULL)
		continue;
	    }
	  else
	    {
	      /* No good fixed strings; start with DFA. */
	      char const *next_beg = dfaexec (&dfa, beg, (char *) buflim,
					      0, NULL, &backref);
	      if (next_beg == NULL)
		break;
	      /* Narrow down to the line we've found. */
	      beg = next_beg;
	      if ((end = memchr(beg, eol, buflim - beg)) != NULL)
	        end++;
              else
                end = buflim;
	      while (beg > buf && beg[-1] != eol)
		--beg;
	    }
	  /* Successful, no backreferences encountered! */
	  if (!backref)
	    goto success;
	}
      else
	{
	  /* We are looking for the leftmost (then longest) exact match.
	     We will go through the outer loop only once.  */
	  beg = start_ptr;
	  end = buflim;
	}

      /* If we've made it to this point, this means DFA has seen
	 a probable match, and we need to run it through Regex. */
      best_match = end;
      best_len = 0;
      for (i = 0; i < pcount; i++)
	{
	  patterns[i].regexbuf.not_eol = 0;
	  if (0 <= (start = re_search (&(patterns[i].regexbuf),
				       buf, end - buf - 1,
				       beg - buf, end - beg - 1,
				       &(patterns[i].regs))))
	    {
	      len = patterns[i].regs.end[0] - start;
	      match = buf + start;
	      if (match > best_match)
		continue;
	      if (start_ptr && !match_words)
		goto assess_pattern_match;
	      if ((!match_lines && !match_words)
		  || (match_lines && len == end - beg - 1))
		{
		  match = beg;
		  len = end - beg;
		  goto assess_pattern_match;
		}
	      /* If -w, check if the match aligns with word boundaries.
		 We do this iteratively because:
		 (a) the line may contain more than one occurence of the
		 pattern, and
		 (b) Several alternatives in the pattern might be valid at a
		 given point, and we may need to consider a shorter one to
		 find a word boundary.  */
	      if (match_words)
		while (match <= best_match)
		  {
		    if ((match == buf || !WCHAR ((unsigned char) match[-1]))
			&& (len == end - beg - 1
			    || !WCHAR ((unsigned char) match[len])))
		      goto assess_pattern_match;
		    if (len > 0)
		      {
			/* Try a shorter length anchored at the same place. */
			--len;
			patterns[i].regexbuf.not_eol = 1;
			len = re_match (&(patterns[i].regexbuf),
					buf, match + len - beg, match - buf,
					&(patterns[i].regs));
		      }
		    if (len <= 0)
		      {
			/* Try looking further on. */
			if (match == end - 1)
			  break;
			match++;
			patterns[i].regexbuf.not_eol = 0;
			start = re_search (&(patterns[i].regexbuf),
					   buf, end - buf - 1,
					   match - buf, end - match - 1,
					   &(patterns[i].regs));
			if (start < 0)
			  break;
			len = patterns[i].regs.end[0] - start;
			match = buf + start;
		      }
		  } /* while (match <= best_match) */
	      continue;
	    assess_pattern_match:
	      if (!start_ptr)
		{
		  /* Good enough for a non-exact match.
		     No need to look at further patterns, if any.  */
		  beg = match;
		  goto success_in_len;
		}
	      if (match < best_match || (match == best_match && len > best_len))
		{
		  /* Best exact match:  leftmost, then longest.  */
		  best_match = match;
		  best_len = len;
		}
	    } /* if re_search >= 0 */
	} /* for Regex patterns.  */
	if (best_match < end)
	  {
	    /* We have found an exact match.  We were just
	       waiting for the best one (leftmost then longest).  */
	    beg = best_match;
	    len = best_len;
	    goto success_in_len;
	  }
    } /* for (beg = end ..) */

 failure:
  ret_val = -1;
  goto out;

 success:
  len = end - beg;
 success_in_len:
  *match_size = len;
  ret_val = beg - buf;
 out:
  return ret_val;
}

Testing negative cases!
Testing 0 (with abstract condition) ENVIS_NEG
Iteration 0
Running test command:
/home/ubuntu/spr-fast/tools/grep-test.py /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-8a025cf8-8f08d8e2/tempworkdir-l/src /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-8a025cf8-8f08d8e2/tempworkdir-l/tests /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-8a025cf8-8f08d8e2/tempworkdir-l 0  > __res
Opening:/tmp/neg.tmp!
NegativeBRANCH RECORD/tmp/neg.tmp!
APPENDING TO ISNEG:/tmp/neg.tmp!
Branch 0: 0
Branch 1: 0
Iteration 1
Running test command:
/home/ubuntu/spr-fast/tools/grep-test.py /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-8a025cf8-8f08d8e2/tempworkdir-l/src /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-8a025cf8-8f08d8e2/tempworkdir-l/tests /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-8a025cf8-8f08d8e2/tempworkdir-l 0  > __res
Opening:/tmp/neg.tmp!
NegativeBRANCH RECORD/tmp/neg.tmp!
APPENDING TO ISNEG:/tmp/neg.tmp!
Branch 0: 0
Branch 1: 1
Branch 2: 0
Iteration 2
Running test command:
/home/ubuntu/spr-fast/tools/grep-test.py /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-8a025cf8-8f08d8e2/tempworkdir-l/src /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-8a025cf8-8f08d8e2/tempworkdir-l/tests /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-8a025cf8-8f08d8e2/tempworkdir-l 0  > __res
Opening:/tmp/neg.tmp!
NegativeBRANCH RECORD/tmp/neg.tmp!
APPENDING TO ISNEG:/tmp/neg.tmp!
Branch 0: 0
Branch 1: 1
Branch 2: 1
Branch 3: 0
Iteration 3
Running test command:
/home/ubuntu/spr-fast/tools/grep-test.py /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-8a025cf8-8f08d8e2/tempworkdir-l/src /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-8a025cf8-8f08d8e2/tempworkdir-l/tests /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-8a025cf8-8f08d8e2/tempworkdir-l 0  > __res
Opening:/tmp/neg.tmp!
NegativeBRANCH RECORD/tmp/neg.tmp!
APPENDING TO ISNEG:/tmp/neg.tmp!
Branch 0: 0
Branch 1: 1
Branch 2: 1
Branch 3: 1
Branch 4: 0
Iteration 4
Running test command:
/home/ubuntu/spr-fast/tools/grep-test.py /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-8a025cf8-8f08d8e2/tempworkdir-l/src /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-8a025cf8-8f08d8e2/tempworkdir-l/tests /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-8a025cf8-8f08d8e2/tempworkdir-l 0  > __res
Opening:/tmp/neg.tmp!
NegativeBRANCH RECORD/tmp/neg.tmp!
APPENDING TO ISNEG:/tmp/neg.tmp!
Branch 0: 0
Branch 1: 1
Branch 2: 1
Branch 3: 1
Branch 4: 1
Branch 5: 0
Iteration 5
Running test command:
/home/ubuntu/spr-fast/tools/grep-test.py /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-8a025cf8-8f08d8e2/tempworkdir-l/src /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-8a025cf8-8f08d8e2/tempworkdir-l/tests /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-8a025cf8-8f08d8e2/tempworkdir-l 0  > __res
Opening:/tmp/neg.tmp!
NegativeBRANCH RECORD/tmp/neg.tmp!
APPENDING TO ISNEG:/tmp/neg.tmp!
Branch 0: 0
Branch 1: 1
Branch 2: 1
Branch 3: 1
Branch 4: 1
Branch 5: 1
Branch 6: 0
Iteration 6
Running test command:
/home/ubuntu/spr-fast/tools/grep-test.py /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-8a025cf8-8f08d8e2/tempworkdir-l/src /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-8a025cf8-8f08d8e2/tempworkdir-l/tests /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-8a025cf8-8f08d8e2/tempworkdir-l 0  > __res
Opening:/tmp/neg.tmp!
NegativeBRANCH RECORD/tmp/neg.tmp!
APPENDING TO ISNEG:/tmp/neg.tmp!
Branch 0: 0
Branch 1: 1
Branch 2: 1
Branch 3: 1
Branch 4: 1
Branch 5: 1
Branch 6: 1
Branch 7: 0
Iteration 7
Running test command:
/home/ubuntu/spr-fast/tools/grep-test.py /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-8a025cf8-8f08d8e2/tempworkdir-l/src /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-8a025cf8-8f08d8e2/tempworkdir-l/tests /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-8a025cf8-8f08d8e2/tempworkdir-l 0  > __res
Opening:/tmp/neg.tmp!
NegativeBRANCH RECORD/tmp/neg.tmp!
APPENDING TO ISNEG:/tmp/neg.tmp!
Branch 0: 0
Branch 1: 1
Branch 2: 1
Branch 3: 1
Branch 4: 1
Branch 5: 1
Branch 6: 1
Branch 7: 1
Branch 8: 0
Iteration 8
Running test command:
/home/ubuntu/spr-fast/tools/grep-test.py /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-8a025cf8-8f08d8e2/tempworkdir-l/src /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-8a025cf8-8f08d8e2/tempworkdir-l/tests /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-8a025cf8-8f08d8e2/tempworkdir-l 0  > __res
Opening:/tmp/neg.tmp!
NegativeBRANCH RECORD/tmp/neg.tmp!
APPENDING TO ISNEG:/tmp/neg.tmp!
Branch 0: 0
Branch 1: 1
Branch 2: 1
Branch 3: 1
Branch 4: 1
Branch 5: 1
Branch 6: 1
Branch 7: 1
Branch 8: 1
Branch 9: 0
Iteration 9
Running test command:
/home/ubuntu/spr-fast/tools/grep-test.py /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-8a025cf8-8f08d8e2/tempworkdir-l/src /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-8a025cf8-8f08d8e2/tempworkdir-l/tests /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-8a025cf8-8f08d8e2/tempworkdir-l 0  > __res
Opening:/tmp/neg.tmp!
NegativeBRANCH RECORD/tmp/neg.tmp!
APPENDING TO ISNEG:/tmp/neg.tmp!
Branch 0: 0
Branch 1: 1
Branch 2: 1
Branch 3: 1
Branch 4: 1
Branch 5: 1
Branch 6: 1
Branch 7: 1
Branch 8: 1
Branch 9: 1
Branch 10: 0
Running test command:
/home/ubuntu/spr-fast/tools/grep-test.py /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-8a025cf8-8f08d8e2/tempworkdir-l/src /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-8a025cf8-8f08d8e2/tempworkdir-l/tests /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-8a025cf8-8f08d8e2/tempworkdir-l 0  > __res
Counter: 102
Batcher Size:91
Preprocess the following candidate with CondTester:
Priority 8746
At location src/dfasearch.c:325
--Src File: src/dfasearch.c
Fragment 0:
if ((__abst_hole(buf, match, beg, end, len, best_match, match_words, i, patterns, match_lines, start_ptr, start, pcount, best_len, buflim, backref, eol, ret_val, match_size, mb_start, kwset_exact_matches, kwset, size, match_icase, eolbyte)))
    return -1;
if ((match == buf || !((1 && ((*__ctype_b_loc())[(int)(((unsigned char)match[-1]))] & (unsigned short)_ISalnum)) || ((unsigned char)match[-1]) == '_')) && (len == end - beg - 1 || !((1 && ((*__ctype_b_loc())[(int)(((unsigned char)match[len]))] & (unsigned short)_ISalnum)) || ((unsigned char)match[len]) == '_')))
    goto assess_pattern_match;


CondTester, a patch instance with id 101:
//src_file:src/dfasearch.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); void* memset(void*, int, unsigned long); 
/* dfasearch.c - searching subroutines using dfa and regex for grep.
   Copyright 1992, 1998, 2000, 2007, 2009-2010 Free Software Foundation, Inc.

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 3, or (at your option)
   any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program; if not, write to the Free Software
   Foundation, Inc., 51 Franklin Street - Fifth Floor, Boston, MA
   02110-1301, USA.  */

/* Written August 1992 by Mike Haertel. */

#include <config.h>
#include "search.h"
#include "dfa.h"

/* For -w, we also consider _ to be word constituent.  */
#define WCHAR(C) (ISALNUM(C) || (C) == '_')

/* KWset compiled pattern.  For Ecompile and Gcompile, we compile
   a list of strings, at least one of which is known to occur in
   any string matching the regexp. */
static kwset_t kwset;

/* DFA compiled regexp. */
static struct dfa dfa;

/* The Regex compiled patterns.  */
static struct patterns
{
  /* Regex compiled regexp. */
  struct re_pattern_buffer regexbuf;
  struct re_registers regs; /* This is here on account of a BRAIN-DEAD
			       Q@#%!# library interface in regex.c.  */
} patterns0;

struct patterns *patterns;
size_t pcount;

void
dfaerror (char const *mesg)
{
  error (EXIT_TROUBLE, 0, "%s", mesg);

  /* notreached */
  /* Tell static analyzers that this function does not return.  */
  abort ();
}

/* Number of compiled fixed strings known to exactly match the regexp.
   If kwsexec returns < kwset_exact_matches, then we don't need to
   call the regexp matcher at all. */
static int kwset_exact_matches;

static char const *
kwsincr_case (const char *must)
{
  const char *buf;
  size_t n;

  n = strlen (must);
#ifdef MBS_SUPPORT
  if (match_icase && MB_CUR_MAX > 1)
    buf = mbtolower (must, &n);
  else
#endif
    buf = must;
  return kwsincr (kwset, buf, n);
}

/* If the DFA turns out to have some set of fixed strings one of
   which must occur in the match, then we build a kwset matcher
   to find those strings, and thus quickly filter out impossible
   matches. */
static void
kwsmusts (void)
{
  struct dfamust const *dm;
  char const *err;

  if (dfa.musts)
    {
      kwsinit (&kwset);
      /* First, we compile in the substrings known to be exact
	 matches.  The kwset matcher will return the index
	 of the matching string that it chooses. */
      for (dm = dfa.musts; dm; dm = dm->next)
	{
	  if (!dm->exact)
	    continue;
	  ++kwset_exact_matches;
	  if ((err = kwsincr_case (dm->must)) != NULL)
	    error (EXIT_TROUBLE, 0, "%s", err);
	}
      /* Now, we compile the substrings that will require
	 the use of the regexp matcher.  */
      for (dm = dfa.musts; dm; dm = dm->next)
	{
	  if (dm->exact)
	    continue;
	  if ((err = kwsincr_case (dm->must)) != NULL)
	    error (EXIT_TROUBLE, 0, "%s", err);
	}
      if ((err = kwsprep (kwset)) != NULL)
	error (EXIT_TROUBLE, 0, "%s", err);
    }
}

void
GEAcompile (char const *pattern, size_t size, reg_syntax_t syntax_bits)
{
  const char *err;
  const char *p, *sep;
  size_t total = size;
  char *motif;

  if (match_icase)
    syntax_bits |= RE_ICASE;
  re_set_syntax (syntax_bits);
  dfasyntax (syntax_bits, match_icase, eolbyte);

  /* For GNU regex compiler we have to pass the patterns separately to detect
     errors like "[\nallo\n]\n".  The patterns here are "[", "allo" and "]"
     GNU regex should have raise a syntax error.  The same for backref, where
     the backref should have been local to each pattern.  */
  p = pattern;
  do
    {
      size_t len;
      sep = memchr (p, '\n', total);
      if (sep)
	{
	  len = sep - p;
	  sep++;
	  total -= (len + 1);
	}
      else
	{
	  len = total;
	  total = 0;
	}

      patterns = realloc (patterns, (pcount + 1) * sizeof (*patterns));
      if (patterns == NULL)
	error (EXIT_TROUBLE, errno, _("memory exhausted"));
      patterns[pcount] = patterns0;

      if ((err = re_compile_pattern (p, len,
				    &(patterns[pcount].regexbuf))) != NULL)
	error (EXIT_TROUBLE, 0, "%s", err);
      pcount++;

      p = sep;
    } while (sep && total != 0);

  /* In the match_words and match_lines cases, we use a different pattern
     for the DFA matcher that will quickly throw out cases that won't work.
     Then if DFA succeeds we do some hairy stuff using the regex matcher
     to decide whether the match should really count. */
  if (match_words || match_lines)
    {
      static char const line_beg_no_bk[] = "^(";
      static char const line_end_no_bk[] = ")$";
      static char const word_beg_no_bk[] = "(^|[^[:alnum:]_])(";
      static char const word_end_no_bk[] = ")([^[:alnum:]_]|$)";
      static char const line_beg_bk[] = "^\\(";
      static char const line_end_bk[] = "\\)$";
      static char const word_beg_bk[] = "\\(^\\|[^[:alnum:]_]\\)\\(";
      static char const word_end_bk[] = "\\)\\([^[:alnum:]_]\\|$\\)";
      int bk = !(syntax_bits & RE_NO_BK_PARENS);
      char *n = xmalloc (sizeof word_beg_bk - 1 + size + sizeof word_end_bk);

      strcpy (n, match_lines ? (bk ? line_beg_bk : line_beg_no_bk)
			     : (bk ? word_beg_bk : word_beg_no_bk));
      total = strlen(n);
      memcpy (n + total, pattern, size);
      total += size;
      strcpy (n + total, match_lines ? (bk ? line_end_bk : line_end_no_bk)
				     : (bk ? word_end_bk : word_end_no_bk));
      total += strlen (n + total);
      pattern = motif = n;
      size = total;
    }
  else
    motif = NULL;

  dfacomp (pattern, size, &dfa, 1);
  kwsmusts ();

  free(motif);
}

size_t
EGexecute (char const *buf, size_t size, size_t *match_size,
	   char const *start_ptr)
{
  char const *buflim, *beg, *end, *match, *best_match, *mb_start;
  char eol = eolbyte;
  int backref, start, len, best_len;
  struct kwsmatch kwsm;
  size_t i, ret_val;
#ifdef MBS_SUPPORT
  if (MB_CUR_MAX > 1)
    {
      if (match_icase)
        {
          /* mbtolower adds a NUL byte at the end.  That will provide
	     space for the sentinel byte dfaexec may add.  */
          char *case_buf = mbtolower (buf, &size);
	  if (start_ptr)
	    start_ptr = case_buf + (start_ptr - buf);
          buf = case_buf;
        }
    }
#endif /* MBS_SUPPORT */

  mb_start = buf;
  buflim = buf + size;

  for (beg = end = buf; end < buflim; beg = end)
    {
      if (!start_ptr)
	{
	  /* We don't care about an exact match.  */
	  if (kwset)
	    {
	      /* Find a possible match using the KWset matcher. */
	      size_t offset = kwsexec (kwset, beg, buflim - beg, &kwsm);
	      if (offset == (size_t) -1)
		goto failure;
	      beg += offset;
	      /* Narrow down to the line containing the candidate, and
		 run it through DFA. */
	      if ((end = memchr(beg, eol, buflim - beg)) != NULL)
	        end++;
              else
                end = buflim;
	      match = beg;
	      while (beg > buf && beg[-1] != eol)
		--beg;
	      if (kwsm.index < kwset_exact_matches)
                {
#ifdef MBS_SUPPORT
                  if (mb_start < beg)
                    mb_start = beg;
                  if (MB_CUR_MAX == 1 || !is_mb_middle (&mb_start, match, buflim))
#endif
                    goto success;
                }
	      if (dfaexec (&dfa, beg, (char *) end, 0, NULL, &backref) == NULL)
		continue;
	    }
	  else
	    {
	      /* No good fixed strings; start with DFA. */
	      char const *next_beg = dfaexec (&dfa, beg, (char *) buflim,
					      0, NULL, &backref);
	      if (next_beg == NULL)
		break;
	      /* Narrow down to the line we've found. */
	      beg = next_beg;
	      if ((end = memchr(beg, eol, buflim - beg)) != NULL)
	        end++;
              else
                end = buflim;
	      while (beg > buf && beg[-1] != eol)
		--beg;
	    }
	  /* Successful, no backreferences encountered! */
	  if (!backref)
	    goto success;
	}
      else
	{
	  /* We are looking for the leftmost (then longest) exact match.
	     We will go through the outer loop only once.  */
	  beg = start_ptr;
	  end = buflim;
	}

      /* If we've made it to this point, this means DFA has seen
	 a probable match, and we need to run it through Regex. */
      best_match = end;
      best_len = 0;
      for (i = 0; i < pcount; i++)
	{
	  patterns[i].regexbuf.not_eol = 0;
	  if (0 <= (start = re_search (&(patterns[i].regexbuf),
				       buf, end - buf - 1,
				       beg - buf, end - beg - 1,
				       &(patterns[i].regs))))
	    {
	      len = patterns[i].regs.end[0] - start;
	      match = buf + start;
	      if (match > best_match)
		continue;
	      if (start_ptr && !match_words)
		goto assess_pattern_match;
	      if ((!match_lines && !match_words)
		  || (match_lines && len == end - beg - 1))
		{
		  match = beg;
		  len = end - beg;
		  goto assess_pattern_match;
		}
	      /* If -w, check if the match aligns with word boundaries.
		 We do this iteratively because:
		 (a) the line may contain more than one occurence of the
		 pattern, and
		 (b) Several alternatives in the pattern might be valid at a
		 given point, and we may need to consider a shorter one to
		 find a word boundary.  */
	      if (match_words)
		while (match <= best_match)
		  {
		    
//Patch 0:
if ((__is_neg(25, &(buf), sizeof (buf), &(match), sizeof (match), &(beg), sizeof (beg), &(end), sizeof (end), &(len), sizeof (len), &(best_match), sizeof (best_match), &(match_words), sizeof (match_words), &(i), sizeof (i), &(patterns), sizeof (patterns), &(match_lines), sizeof (match_lines), &(start_ptr), sizeof (start_ptr), &(start), sizeof (start), &(pcount), sizeof (pcount), &(best_len), sizeof (best_len), &(buflim), sizeof (buflim), &(backref), sizeof (backref), &(eol), sizeof (eol), &(ret_val), sizeof (ret_val), &(match_size), sizeof (match_size), &(mb_start), sizeof (mb_start), &(kwset_exact_matches), sizeof (kwset_exact_matches), &(kwset), sizeof (kwset), &(size), sizeof (size), &(match_icase), sizeof (match_icase), &(eolbyte), sizeof (eolbyte))))
    return -1;
if ((match == buf || !((1 && ((*__ctype_b_loc())[(int)(((unsigned char)match[-1]))] & (unsigned short)_ISalnum)) || ((unsigned char)match[-1]) == '_')) && (len == end - beg - 1 || !((1 && ((*__ctype_b_loc())[(int)(((unsigned char)match[len]))] & (unsigned short)_ISalnum)) || ((unsigned char)match[len]) == '_')))
    goto assess_pattern_match;

//CodeSeg 1:
		    if (len > 0)
		      {
			/* Try a shorter length anchored at the same place. */
			--len;
			patterns[i].regexbuf.not_eol = 1;
			len = re_match (&(patterns[i].regexbuf),
					buf, match + len - beg, match - buf,
					&(patterns[i].regs));
		      }
		    if (len <= 0)
		      {
			/* Try looking further on. */
			if (match == end - 1)
			  break;
			match++;
			patterns[i].regexbuf.not_eol = 0;
			start = re_search (&(patterns[i].regexbuf),
					   buf, end - buf - 1,
					   match - buf, end - match - 1,
					   &(patterns[i].regs));
			if (start < 0)
			  break;
			len = patterns[i].regs.end[0] - start;
			match = buf + start;
		      }
		  } /* while (match <= best_match) */
	      continue;
	    assess_pattern_match:
	      if (!start_ptr)
		{
		  /* Good enough for a non-exact match.
		     No need to look at further patterns, if any.  */
		  beg = match;
		  goto success_in_len;
		}
	      if (match < best_match || (match == best_match && len > best_len))
		{
		  /* Best exact match:  leftmost, then longest.  */
		  best_match = match;
		  best_len = len;
		}
	    } /* if re_search >= 0 */
	} /* for Regex patterns.  */
	if (best_match < end)
	  {
	    /* We have found an exact match.  We were just
	       waiting for the best one (leftmost then longest).  */
	    beg = best_match;
	    len = best_len;
	    goto success_in_len;
	  }
    } /* for (beg = end ..) */

 failure:
  ret_val = -1;
  goto out;

 success:
  len = end - beg;
 success_in_len:
  *match_size = len;
  ret_val = beg - buf;
 out:
  return ret_val;
}

Spawn 1 instances, now Total 102
Counter: 103
Batcher Size:92
Preprocess the following candidate with CondTester:
Priority 8746
At location src/dfasearch.c:325
--Src File: src/dfasearch.c
Fragment 0:
if ((__abst_hole(buf, match, beg, end, len, best_match, match_words, i, patterns, match_lines, start_ptr, start, pcount, best_len, buflim, backref, eol, ret_val, match_size, mb_start, kwset_exact_matches, kwset, size, match_icase, eolbyte)))
    return 0;
if ((match == buf || !((1 && ((*__ctype_b_loc())[(int)(((unsigned char)match[-1]))] & (unsigned short)_ISalnum)) || ((unsigned char)match[-1]) == '_')) && (len == end - beg - 1 || !((1 && ((*__ctype_b_loc())[(int)(((unsigned char)match[len]))] & (unsigned short)_ISalnum)) || ((unsigned char)match[len]) == '_')))
    goto assess_pattern_match;


CondTester, a patch instance with id 102:
//src_file:src/dfasearch.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); void* memset(void*, int, unsigned long); 
/* dfasearch.c - searching subroutines using dfa and regex for grep.
   Copyright 1992, 1998, 2000, 2007, 2009-2010 Free Software Foundation, Inc.

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 3, or (at your option)
   any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program; if not, write to the Free Software
   Foundation, Inc., 51 Franklin Street - Fifth Floor, Boston, MA
   02110-1301, USA.  */

/* Written August 1992 by Mike Haertel. */

#include <config.h>
#include "search.h"
#include "dfa.h"

/* For -w, we also consider _ to be word constituent.  */
#define WCHAR(C) (ISALNUM(C) || (C) == '_')

/* KWset compiled pattern.  For Ecompile and Gcompile, we compile
   a list of strings, at least one of which is known to occur in
   any string matching the regexp. */
static kwset_t kwset;

/* DFA compiled regexp. */
static struct dfa dfa;

/* The Regex compiled patterns.  */
static struct patterns
{
  /* Regex compiled regexp. */
  struct re_pattern_buffer regexbuf;
  struct re_registers regs; /* This is here on account of a BRAIN-DEAD
			       Q@#%!# library interface in regex.c.  */
} patterns0;

struct patterns *patterns;
size_t pcount;

void
dfaerror (char const *mesg)
{
  error (EXIT_TROUBLE, 0, "%s", mesg);

  /* notreached */
  /* Tell static analyzers that this function does not return.  */
  abort ();
}

/* Number of compiled fixed strings known to exactly match the regexp.
   If kwsexec returns < kwset_exact_matches, then we don't need to
   call the regexp matcher at all. */
static int kwset_exact_matches;

static char const *
kwsincr_case (const char *must)
{
  const char *buf;
  size_t n;

  n = strlen (must);
#ifdef MBS_SUPPORT
  if (match_icase && MB_CUR_MAX > 1)
    buf = mbtolower (must, &n);
  else
#endif
    buf = must;
  return kwsincr (kwset, buf, n);
}

/* If the DFA turns out to have some set of fixed strings one of
   which must occur in the match, then we build a kwset matcher
   to find those strings, and thus quickly filter out impossible
   matches. */
static void
kwsmusts (void)
{
  struct dfamust const *dm;
  char const *err;

  if (dfa.musts)
    {
      kwsinit (&kwset);
      /* First, we compile in the substrings known to be exact
	 matches.  The kwset matcher will return the index
	 of the matching string that it chooses. */
      for (dm = dfa.musts; dm; dm = dm->next)
	{
	  if (!dm->exact)
	    continue;
	  ++kwset_exact_matches;
	  if ((err = kwsincr_case (dm->must)) != NULL)
	    error (EXIT_TROUBLE, 0, "%s", err);
	}
      /* Now, we compile the substrings that will require
	 the use of the regexp matcher.  */
      for (dm = dfa.musts; dm; dm = dm->next)
	{
	  if (dm->exact)
	    continue;
	  if ((err = kwsincr_case (dm->must)) != NULL)
	    error (EXIT_TROUBLE, 0, "%s", err);
	}
      if ((err = kwsprep (kwset)) != NULL)
	error (EXIT_TROUBLE, 0, "%s", err);
    }
}

void
GEAcompile (char const *pattern, size_t size, reg_syntax_t syntax_bits)
{
  const char *err;
  const char *p, *sep;
  size_t total = size;
  char *motif;

  if (match_icase)
    syntax_bits |= RE_ICASE;
  re_set_syntax (syntax_bits);
  dfasyntax (syntax_bits, match_icase, eolbyte);

  /* For GNU regex compiler we have to pass the patterns separately to detect
     errors like "[\nallo\n]\n".  The patterns here are "[", "allo" and "]"
     GNU regex should have raise a syntax error.  The same for backref, where
     the backref should have been local to each pattern.  */
  p = pattern;
  do
    {
      size_t len;
      sep = memchr (p, '\n', total);
      if (sep)
	{
	  len = sep - p;
	  sep++;
	  total -= (len + 1);
	}
      else
	{
	  len = total;
	  total = 0;
	}

      patterns = realloc (patterns, (pcount + 1) * sizeof (*patterns));
      if (patterns == NULL)
	error (EXIT_TROUBLE, errno, _("memory exhausted"));
      patterns[pcount] = patterns0;

      if ((err = re_compile_pattern (p, len,
				    &(patterns[pcount].regexbuf))) != NULL)
	error (EXIT_TROUBLE, 0, "%s", err);
      pcount++;

      p = sep;
    } while (sep && total != 0);

  /* In the match_words and match_lines cases, we use a different pattern
     for the DFA matcher that will quickly throw out cases that won't work.
     Then if DFA succeeds we do some hairy stuff using the regex matcher
     to decide whether the match should really count. */
  if (match_words || match_lines)
    {
      static char const line_beg_no_bk[] = "^(";
      static char const line_end_no_bk[] = ")$";
      static char const word_beg_no_bk[] = "(^|[^[:alnum:]_])(";
      static char const word_end_no_bk[] = ")([^[:alnum:]_]|$)";
      static char const line_beg_bk[] = "^\\(";
      static char const line_end_bk[] = "\\)$";
      static char const word_beg_bk[] = "\\(^\\|[^[:alnum:]_]\\)\\(";
      static char const word_end_bk[] = "\\)\\([^[:alnum:]_]\\|$\\)";
      int bk = !(syntax_bits & RE_NO_BK_PARENS);
      char *n = xmalloc (sizeof word_beg_bk - 1 + size + sizeof word_end_bk);

      strcpy (n, match_lines ? (bk ? line_beg_bk : line_beg_no_bk)
			     : (bk ? word_beg_bk : word_beg_no_bk));
      total = strlen(n);
      memcpy (n + total, pattern, size);
      total += size;
      strcpy (n + total, match_lines ? (bk ? line_end_bk : line_end_no_bk)
				     : (bk ? word_end_bk : word_end_no_bk));
      total += strlen (n + total);
      pattern = motif = n;
      size = total;
    }
  else
    motif = NULL;

  dfacomp (pattern, size, &dfa, 1);
  kwsmusts ();

  free(motif);
}

size_t
EGexecute (char const *buf, size_t size, size_t *match_size,
	   char const *start_ptr)
{
  char const *buflim, *beg, *end, *match, *best_match, *mb_start;
  char eol = eolbyte;
  int backref, start, len, best_len;
  struct kwsmatch kwsm;
  size_t i, ret_val;
#ifdef MBS_SUPPORT
  if (MB_CUR_MAX > 1)
    {
      if (match_icase)
        {
          /* mbtolower adds a NUL byte at the end.  That will provide
	     space for the sentinel byte dfaexec may add.  */
          char *case_buf = mbtolower (buf, &size);
	  if (start_ptr)
	    start_ptr = case_buf + (start_ptr - buf);
          buf = case_buf;
        }
    }
#endif /* MBS_SUPPORT */

  mb_start = buf;
  buflim = buf + size;

  for (beg = end = buf; end < buflim; beg = end)
    {
      if (!start_ptr)
	{
	  /* We don't care about an exact match.  */
	  if (kwset)
	    {
	      /* Find a possible match using the KWset matcher. */
	      size_t offset = kwsexec (kwset, beg, buflim - beg, &kwsm);
	      if (offset == (size_t) -1)
		goto failure;
	      beg += offset;
	      /* Narrow down to the line containing the candidate, and
		 run it through DFA. */
	      if ((end = memchr(beg, eol, buflim - beg)) != NULL)
	        end++;
              else
                end = buflim;
	      match = beg;
	      while (beg > buf && beg[-1] != eol)
		--beg;
	      if (kwsm.index < kwset_exact_matches)
                {
#ifdef MBS_SUPPORT
                  if (mb_start < beg)
                    mb_start = beg;
                  if (MB_CUR_MAX == 1 || !is_mb_middle (&mb_start, match, buflim))
#endif
                    goto success;
                }
	      if (dfaexec (&dfa, beg, (char *) end, 0, NULL, &backref) == NULL)
		continue;
	    }
	  else
	    {
	      /* No good fixed strings; start with DFA. */
	      char const *next_beg = dfaexec (&dfa, beg, (char *) buflim,
					      0, NULL, &backref);
	      if (next_beg == NULL)
		break;
	      /* Narrow down to the line we've found. */
	      beg = next_beg;
	      if ((end = memchr(beg, eol, buflim - beg)) != NULL)
	        end++;
              else
                end = buflim;
	      while (beg > buf && beg[-1] != eol)
		--beg;
	    }
	  /* Successful, no backreferences encountered! */
	  if (!backref)
	    goto success;
	}
      else
	{
	  /* We are looking for the leftmost (then longest) exact match.
	     We will go through the outer loop only once.  */
	  beg = start_ptr;
	  end = buflim;
	}

      /* If we've made it to this point, this means DFA has seen
	 a probable match, and we need to run it through Regex. */
      best_match = end;
      best_len = 0;
      for (i = 0; i < pcount; i++)
	{
	  patterns[i].regexbuf.not_eol = 0;
	  if (0 <= (start = re_search (&(patterns[i].regexbuf),
				       buf, end - buf - 1,
				       beg - buf, end - beg - 1,
				       &(patterns[i].regs))))
	    {
	      len = patterns[i].regs.end[0] - start;
	      match = buf + start;
	      if (match > best_match)
		continue;
	      if (start_ptr && !match_words)
		goto assess_pattern_match;
	      if ((!match_lines && !match_words)
		  || (match_lines && len == end - beg - 1))
		{
		  match = beg;
		  len = end - beg;
		  goto assess_pattern_match;
		}
	      /* If -w, check if the match aligns with word boundaries.
		 We do this iteratively because:
		 (a) the line may contain more than one occurence of the
		 pattern, and
		 (b) Several alternatives in the pattern might be valid at a
		 given point, and we may need to consider a shorter one to
		 find a word boundary.  */
	      if (match_words)
		while (match <= best_match)
		  {
		    
//Patch 0:
if ((__is_neg(25, &(buf), sizeof (buf), &(match), sizeof (match), &(beg), sizeof (beg), &(end), sizeof (end), &(len), sizeof (len), &(best_match), sizeof (best_match), &(match_words), sizeof (match_words), &(i), sizeof (i), &(patterns), sizeof (patterns), &(match_lines), sizeof (match_lines), &(start_ptr), sizeof (start_ptr), &(start), sizeof (start), &(pcount), sizeof (pcount), &(best_len), sizeof (best_len), &(buflim), sizeof (buflim), &(backref), sizeof (backref), &(eol), sizeof (eol), &(ret_val), sizeof (ret_val), &(match_size), sizeof (match_size), &(mb_start), sizeof (mb_start), &(kwset_exact_matches), sizeof (kwset_exact_matches), &(kwset), sizeof (kwset), &(size), sizeof (size), &(match_icase), sizeof (match_icase), &(eolbyte), sizeof (eolbyte))))
    return 0;
if ((match == buf || !((1 && ((*__ctype_b_loc())[(int)(((unsigned char)match[-1]))] & (unsigned short)_ISalnum)) || ((unsigned char)match[-1]) == '_')) && (len == end - beg - 1 || !((1 && ((*__ctype_b_loc())[(int)(((unsigned char)match[len]))] & (unsigned short)_ISalnum)) || ((unsigned char)match[len]) == '_')))
    goto assess_pattern_match;

//CodeSeg 1:
		    if (len > 0)
		      {
			/* Try a shorter length anchored at the same place. */
			--len;
			patterns[i].regexbuf.not_eol = 1;
			len = re_match (&(patterns[i].regexbuf),
					buf, match + len - beg, match - buf,
					&(patterns[i].regs));
		      }
		    if (len <= 0)
		      {
			/* Try looking further on. */
			if (match == end - 1)
			  break;
			match++;
			patterns[i].regexbuf.not_eol = 0;
			start = re_search (&(patterns[i].regexbuf),
					   buf, end - buf - 1,
					   match - buf, end - match - 1,
					   &(patterns[i].regs));
			if (start < 0)
			  break;
			len = patterns[i].regs.end[0] - start;
			match = buf + start;
		      }
		  } /* while (match <= best_match) */
	      continue;
	    assess_pattern_match:
	      if (!start_ptr)
		{
		  /* Good enough for a non-exact match.
		     No need to look at further patterns, if any.  */
		  beg = match;
		  goto success_in_len;
		}
	      if (match < best_match || (match == best_match && len > best_len))
		{
		  /* Best exact match:  leftmost, then longest.  */
		  best_match = match;
		  best_len = len;
		}
	    } /* if re_search >= 0 */
	} /* for Regex patterns.  */
	if (best_match < end)
	  {
	    /* We have found an exact match.  We were just
	       waiting for the best one (leftmost then longest).  */
	    beg = best_match;
	    len = best_len;
	    goto success_in_len;
	  }
    } /* for (beg = end ..) */

 failure:
  ret_val = -1;
  goto out;

 success:
  len = end - beg;
 success_in_len:
  *match_size = len;
  ret_val = beg - buf;
 out:
  return ret_val;
}

Spawn 1 instances, now Total 103
a batched test job starts!
Building merged code:
src_file: src/dfasearch.c
full src: int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); void* memset(void*, int, unsigned long); 
/* dfasearch.c - searching subroutines using dfa and regex for grep.
   Copyright 1992, 1998, 2000, 2007, 2009-2010 Free Software Foundation, Inc.

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 3, or (at your option)
   any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program; if not, write to the Free Software
   Foundation, Inc., 51 Franklin Street - Fifth Floor, Boston, MA
   02110-1301, USA.  */

/* Written August 1992 by Mike Haertel. */

#include <config.h>
#include "search.h"
#include "dfa.h"

/* For -w, we also consider _ to be word constituent.  */
#define WCHAR(C) (ISALNUM(C) || (C) == '_')

/* KWset compiled pattern.  For Ecompile and Gcompile, we compile
   a list of strings, at least one of which is known to occur in
   any string matching the regexp. */
static kwset_t kwset;

/* DFA compiled regexp. */
static struct dfa dfa;

/* The Regex compiled patterns.  */
static struct patterns
{
  /* Regex compiled regexp. */
  struct re_pattern_buffer regexbuf;
  struct re_registers regs; /* This is here on account of a BRAIN-DEAD
			       Q@#%!# library interface in regex.c.  */
} patterns0;

struct patterns *patterns;
size_t pcount;

void
dfaerror (char const *mesg)
{
  error (EXIT_TROUBLE, 0, "%s", mesg);

  /* notreached */
  /* Tell static analyzers that this function does not return.  */
  abort ();
}

/* Number of compiled fixed strings known to exactly match the regexp.
   If kwsexec returns < kwset_exact_matches, then we don't need to
   call the regexp matcher at all. */
static int kwset_exact_matches;

static char const *
kwsincr_case (const char *must)
{
  const char *buf;
  size_t n;

  n = strlen (must);
#ifdef MBS_SUPPORT
  if (match_icase && MB_CUR_MAX > 1)
    buf = mbtolower (must, &n);
  else
#endif
    buf = must;
  return kwsincr (kwset, buf, n);
}

/* If the DFA turns out to have some set of fixed strings one of
   which must occur in the match, then we build a kwset matcher
   to find those strings, and thus quickly filter out impossible
   matches. */
static void
kwsmusts (void)
{
  struct dfamust const *dm;
  char const *err;

  if (dfa.musts)
    {
      kwsinit (&kwset);
      /* First, we compile in the substrings known to be exact
	 matches.  The kwset matcher will return the index
	 of the matching string that it chooses. */
      for (dm = dfa.musts; dm; dm = dm->next)
	{
	  if (!dm->exact)
	    continue;
	  ++kwset_exact_matches;
	  if ((err = kwsincr_case (dm->must)) != NULL)
	    error (EXIT_TROUBLE, 0, "%s", err);
	}
      /* Now, we compile the substrings that will require
	 the use of the regexp matcher.  */
      for (dm = dfa.musts; dm; dm = dm->next)
	{
	  if (dm->exact)
	    continue;
	  if ((err = kwsincr_case (dm->must)) != NULL)
	    error (EXIT_TROUBLE, 0, "%s", err);
	}
      if ((err = kwsprep (kwset)) != NULL)
	error (EXIT_TROUBLE, 0, "%s", err);
    }
}

void
GEAcompile (char const *pattern, size_t size, reg_syntax_t syntax_bits)
{
  const char *err;
  const char *p, *sep;
  size_t total = size;
  char *motif;

  if (match_icase)
    syntax_bits |= RE_ICASE;
  re_set_syntax (syntax_bits);
  dfasyntax (syntax_bits, match_icase, eolbyte);

  /* For GNU regex compiler we have to pass the patterns separately to detect
     errors like "[\nallo\n]\n".  The patterns here are "[", "allo" and "]"
     GNU regex should have raise a syntax error.  The same for backref, where
     the backref should have been local to each pattern.  */
  p = pattern;
  do
    {
      size_t len;
      sep = memchr (p, '\n', total);
      if (sep)
	{
	  len = sep - p;
	  sep++;
	  total -= (len + 1);
	}
      else
	{
	  len = total;
	  total = 0;
	}

      patterns = realloc (patterns, (pcount + 1) * sizeof (*patterns));
      if (patterns == NULL)
	error (EXIT_TROUBLE, errno, _("memory exhausted"));
      patterns[pcount] = patterns0;

      if ((err = re_compile_pattern (p, len,
				    &(patterns[pcount].regexbuf))) != NULL)
	error (EXIT_TROUBLE, 0, "%s", err);
      pcount++;

      p = sep;
    } while (sep && total != 0);

  /* In the match_words and match_lines cases, we use a different pattern
     for the DFA matcher that will quickly throw out cases that won't work.
     Then if DFA succeeds we do some hairy stuff using the regex matcher
     to decide whether the match should really count. */
  if (match_words || match_lines)
    {
      static char const line_beg_no_bk[] = "^(";
      static char const line_end_no_bk[] = ")$";
      static char const word_beg_no_bk[] = "(^|[^[:alnum:]_])(";
      static char const word_end_no_bk[] = ")([^[:alnum:]_]|$)";
      static char const line_beg_bk[] = "^\\(";
      static char const line_end_bk[] = "\\)$";
      static char const word_beg_bk[] = "\\(^\\|[^[:alnum:]_]\\)\\(";
      static char const word_end_bk[] = "\\)\\([^[:alnum:]_]\\|$\\)";
      int bk = !(syntax_bits & RE_NO_BK_PARENS);
      char *n = xmalloc (sizeof word_beg_bk - 1 + size + sizeof word_end_bk);

      strcpy (n, match_lines ? (bk ? line_beg_bk : line_beg_no_bk)
			     : (bk ? word_beg_bk : word_beg_no_bk));
      total = strlen(n);
      memcpy (n + total, pattern, size);
      total += size;
      strcpy (n + total, match_lines ? (bk ? line_end_bk : line_end_no_bk)
				     : (bk ? word_end_bk : word_end_no_bk));
      total += strlen (n + total);
      pattern = motif = n;
      size = total;
    }
  else
    motif = NULL;

  dfacomp (pattern, size, &dfa, 1);
  kwsmusts ();

  free(motif);
}

size_t
EGexecute (char const *buf, size_t size, size_t *match_size,
	   char const *start_ptr)
{
  char const *buflim, *beg, *end, *match, *best_match, *mb_start;
  char eol = eolbyte;
  int backref, start, len, best_len;
  struct kwsmatch kwsm;
  size_t i, ret_val;
#ifdef MBS_SUPPORT
  if (MB_CUR_MAX > 1)
    {
      if (match_icase)
        {
          /* mbtolower adds a NUL byte at the end.  That will provide
	     space for the sentinel byte dfaexec may add.  */
          char *case_buf = mbtolower (buf, &size);
	  if (start_ptr)
	    start_ptr = case_buf + (start_ptr - buf);
          buf = case_buf;
        }
    }
#endif /* MBS_SUPPORT */

  mb_start = buf;
  buflim = buf + size;

  for (beg = end = buf; end < buflim; beg = end)
    {
      if (!start_ptr)
	{
	  /* We don't care about an exact match.  */
	  if (kwset)
	    {
	      /* Find a possible match using the KWset matcher. */
	      size_t offset = kwsexec (kwset, beg, buflim - beg, &kwsm);
	      if (offset == (size_t) -1)
		goto failure;
	      beg += offset;
	      /* Narrow down to the line containing the candidate, and
		 run it through DFA. */
	      if ((end = memchr(beg, eol, buflim - beg)) != NULL)
	        end++;
              else
                end = buflim;
	      match = beg;
	      while (beg > buf && beg[-1] != eol)
		--beg;
	      if (kwsm.index < kwset_exact_matches)
                {
#ifdef MBS_SUPPORT
                  if (mb_start < beg)
                    mb_start = beg;
                  if (MB_CUR_MAX == 1 || !is_mb_middle (&mb_start, match, buflim))
#endif
                    goto success;
                }
	      if (dfaexec (&dfa, beg, (char *) end, 0, NULL, &backref) == NULL)
		continue;
	    }
	  else
	    {
	      /* No good fixed strings; start with DFA. */
	      char const *next_beg = dfaexec (&dfa, beg, (char *) buflim,
					      0, NULL, &backref);
	      if (next_beg == NULL)
		break;
	      /* Narrow down to the line we've found. */
	      beg = next_beg;
	      if ((end = memchr(beg, eol, buflim - beg)) != NULL)
	        end++;
              else
                end = buflim;
	      while (beg > buf && beg[-1] != eol)
		--beg;
	    }
	  /* Successful, no backreferences encountered! */
	  if (!backref)
	    goto success;
	}
      else
	{
	  /* We are looking for the leftmost (then longest) exact match.
	     We will go through the outer loop only once.  */
	  beg = start_ptr;
	  end = buflim;
	}

      /* If we've made it to this point, this means DFA has seen
	 a probable match, and we need to run it through Regex. */
      best_match = end;
      best_len = 0;
      for (i = 0; i < pcount; i++)
	{
	  patterns[i].regexbuf.not_eol = 0;
	  if (0 <= (start = re_search (&(patterns[i].regexbuf),
				       buf, end - buf - 1,
				       beg - buf, end - beg - 1,
				       &(patterns[i].regs))))
	    {
	      len = patterns[i].regs.end[0] - start;
	      match = buf + start;
	      if (match > best_match)
		continue;
	      if (start_ptr && !match_words)
		goto assess_pattern_match;
	      if ((!match_lines && !match_words)
		  || (match_lines && len == end - beg - 1))
		{
		  match = beg;
		  len = end - beg;
		  goto assess_pattern_match;
		}
	      /* If -w, check if the match aligns with word boundaries.
		 We do this iteratively because:
		 (a) the line may contain more than one occurence of the
		 pattern, and
		 (b) Several alternatives in the pattern might be valid at a
		 given point, and we may need to consider a shorter one to
		 find a word boundary.  */
	      if (match_words)
		while (match <= best_match)
		  {
		    //prophet generated patch
		    if (__get_mutant()==0) {
		    if (((match == buf || !((1 && ((*__ctype_b_loc())[(int)(((unsigned char)match[-1]))] & (unsigned short)_ISalnum)) || ((unsigned char)match[-1]) == '_')) && (len == end - beg - 1 || !((1 && ((*__ctype_b_loc())[(int)(((unsigned char)match[len]))] & (unsigned short)_ISalnum)) || ((unsigned char)match[len]) == '_'))) && !(__is_neg(25, &(match), sizeof (match), &(len), sizeof (len), &(beg), sizeof (beg), &(end), sizeof (end), &(buf), sizeof (buf), &(best_match), sizeof (best_match), &(match_words), sizeof (match_words), &(i), sizeof (i), &(patterns), sizeof (patterns), &(start), sizeof (start), &(match_lines), sizeof (match_lines), &(start_ptr), sizeof (start_ptr), &(pcount), sizeof (pcount), &(best_len), sizeof (best_len), &(buflim), sizeof (buflim), &(backref), sizeof (backref), &(eol), sizeof (eol), &(ret_val), sizeof (ret_val), &(match_size), sizeof (match_size), &(mb_start), sizeof (mb_start), &(kwset_exact_matches), sizeof (kwset_exact_matches), &(kwset), sizeof (kwset), &(size), sizeof (size), &(match_icase), sizeof (match_icase), &(eolbyte), sizeof (eolbyte))))
		        goto assess_pattern_match;
		    }
		    else if (__get_mutant()==1) {
		    if (((match == buf || !((1 && ((*__ctype_b_loc())[(int)(((unsigned char)match[-1]))] & (unsigned short)_ISalnum)) || ((unsigned char)match[-1]) == '_')) && (len == end - beg - 1 || !((1 && ((*__ctype_b_loc())[(int)(((unsigned char)match[len]))] & (unsigned short)_ISalnum)) || ((unsigned char)match[len]) == '_'))) || (__is_neg(25, &(match), sizeof (match), &(len), sizeof (len), &(beg), sizeof (beg), &(end), sizeof (end), &(buf), sizeof (buf), &(best_match), sizeof (best_match), &(match_words), sizeof (match_words), &(i), sizeof (i), &(patterns), sizeof (patterns), &(start), sizeof (start), &(match_lines), sizeof (match_lines), &(start_ptr), sizeof (start_ptr), &(pcount), sizeof (pcount), &(best_len), sizeof (best_len), &(buflim), sizeof (buflim), &(backref), sizeof (backref), &(eol), sizeof (eol), &(ret_val), sizeof (ret_val), &(match_size), sizeof (match_size), &(mb_start), sizeof (mb_start), &(kwset_exact_matches), sizeof (kwset_exact_matches), &(kwset), sizeof (kwset), &(size), sizeof (size), &(match_icase), sizeof (match_icase), &(eolbyte), sizeof (eolbyte))))
		        goto assess_pattern_match;
		    }
		    else if (__get_mutant()==2) {
		    if ((((match == buf || !((1 && ((*__ctype_b_loc())[(int)(((unsigned char)match[-1]))] & (unsigned short)_ISalnum)) || ((unsigned char)match[-1]) == '_'))) || (__is_neg(25, &(match), sizeof (match), &(len), sizeof (len), &(beg), sizeof (beg), &(end), sizeof (end), &(buf), sizeof (buf), &(best_match), sizeof (best_match), &(match_words), sizeof (match_words), &(i), sizeof (i), &(patterns), sizeof (patterns), &(start), sizeof (start), &(match_lines), sizeof (match_lines), &(start_ptr), sizeof (start_ptr), &(pcount), sizeof (pcount), &(best_len), sizeof (best_len), &(buflim), sizeof (buflim), &(backref), sizeof (backref), &(eol), sizeof (eol), &(ret_val), sizeof (ret_val), &(match_size), sizeof (match_size), &(mb_start), sizeof (mb_start), &(kwset_exact_matches), sizeof (kwset_exact_matches), &(kwset), sizeof (kwset), &(size), sizeof (size), &(match_icase), sizeof (match_icase), &(eolbyte), sizeof (eolbyte)))) && (len == end - beg - 1 || !((1 && ((*__ctype_b_loc())[(int)(((unsigned char)match[len]))] & (unsigned short)_ISalnum)) || ((unsigned char)match[len]) == '_')))
		        goto assess_pattern_match;
		    }
		    else if (__get_mutant()==3) {
		    if ((__is_neg(25, &(buf), sizeof (buf), &(match), sizeof (match), &(beg), sizeof (beg), &(end), sizeof (end), &(len), sizeof (len), &(best_match), sizeof (best_match), &(match_words), sizeof (match_words), &(i), sizeof (i), &(patterns), sizeof (patterns), &(match_lines), sizeof (match_lines), &(start_ptr), sizeof (start_ptr), &(start), sizeof (start), &(pcount), sizeof (pcount), &(best_len), sizeof (best_len), &(buflim), sizeof (buflim), &(backref), sizeof (backref), &(eol), sizeof (eol), &(ret_val), sizeof (ret_val), &(match_size), sizeof (match_size), &(mb_start), sizeof (mb_start), &(kwset_exact_matches), sizeof (kwset_exact_matches), &(kwset), sizeof (kwset), &(size), sizeof (size), &(match_icase), sizeof (match_icase), &(eolbyte), sizeof (eolbyte))))
		        goto assess_pattern_match;
		    if ((match == buf || !((1 && ((*__ctype_b_loc())[(int)(((unsigned char)match[-1]))] & (unsigned short)_ISalnum)) || ((unsigned char)match[-1]) == '_')) && (len == end - beg - 1 || !((1 && ((*__ctype_b_loc())[(int)(((unsigned char)match[len]))] & (unsigned short)_ISalnum)) || ((unsigned char)match[len]) == '_')))
		        goto assess_pattern_match;
		    }
		    else if (__get_mutant()==4) {
		    if ((__is_neg(25, &(buf), sizeof (buf), &(match), sizeof (match), &(beg), sizeof (beg), &(end), sizeof (end), &(len), sizeof (len), &(best_match), sizeof (best_match), &(match_words), sizeof (match_words), &(i), sizeof (i), &(patterns), sizeof (patterns), &(match_lines), sizeof (match_lines), &(start_ptr), sizeof (start_ptr), &(start), sizeof (start), &(pcount), sizeof (pcount), &(best_len), sizeof (best_len), &(buflim), sizeof (buflim), &(backref), sizeof (backref), &(eol), sizeof (eol), &(ret_val), sizeof (ret_val), &(match_size), sizeof (match_size), &(mb_start), sizeof (mb_start), &(kwset_exact_matches), sizeof (kwset_exact_matches), &(kwset), sizeof (kwset), &(size), sizeof (size), &(match_icase), sizeof (match_icase), &(eolbyte), sizeof (eolbyte))))
		        goto failure;
		    if ((match == buf || !((1 && ((*__ctype_b_loc())[(int)(((unsigned char)match[-1]))] & (unsigned short)_ISalnum)) || ((unsigned char)match[-1]) == '_')) && (len == end - beg - 1 || !((1 && ((*__ctype_b_loc())[(int)(((unsigned char)match[len]))] & (unsigned short)_ISalnum)) || ((unsigned char)match[len]) == '_')))
		        goto assess_pattern_match;
		    }
		    else if (__get_mutant()==5) {
		    if ((__is_neg(25, &(buf), sizeof (buf), &(match), sizeof (match), &(beg), sizeof (beg), &(end), sizeof (end), &(len), sizeof (len), &(best_match), sizeof (best_match), &(match_words), sizeof (match_words), &(i), sizeof (i), &(patterns), sizeof (patterns), &(match_lines), sizeof (match_lines), &(start_ptr), sizeof (start_ptr), &(start), sizeof (start), &(pcount), sizeof (pcount), &(best_len), sizeof (best_len), &(buflim), sizeof (buflim), &(backref), sizeof (backref), &(eol), sizeof (eol), &(ret_val), sizeof (ret_val), &(match_size), sizeof (match_size), &(mb_start), sizeof (mb_start), &(kwset_exact_matches), sizeof (kwset_exact_matches), &(kwset), sizeof (kwset), &(size), sizeof (size), &(match_icase), sizeof (match_icase), &(eolbyte), sizeof (eolbyte))))
		        goto success;
		    if ((match == buf || !((1 && ((*__ctype_b_loc())[(int)(((unsigned char)match[-1]))] & (unsigned short)_ISalnum)) || ((unsigned char)match[-1]) == '_')) && (len == end - beg - 1 || !((1 && ((*__ctype_b_loc())[(int)(((unsigned char)match[len]))] & (unsigned short)_ISalnum)) || ((unsigned char)match[len]) == '_')))
		        goto assess_pattern_match;
		    }
		    else if (__get_mutant()==6) {
		    if ((__is_neg(25, &(buf), sizeof (buf), &(match), sizeof (match), &(beg), sizeof (beg), &(end), sizeof (end), &(len), sizeof (len), &(best_match), sizeof (best_match), &(match_words), sizeof (match_words), &(i), sizeof (i), &(patterns), sizeof (patterns), &(match_lines), sizeof (match_lines), &(start_ptr), sizeof (start_ptr), &(start), sizeof (start), &(pcount), sizeof (pcount), &(best_len), sizeof (best_len), &(buflim), sizeof (buflim), &(backref), sizeof (backref), &(eol), sizeof (eol), &(ret_val), sizeof (ret_val), &(match_size), sizeof (match_size), &(mb_start), sizeof (mb_start), &(kwset_exact_matches), sizeof (kwset_exact_matches), &(kwset), sizeof (kwset), &(size), sizeof (size), &(match_icase), sizeof (match_icase), &(eolbyte), sizeof (eolbyte))))
		        goto success_in_len;
		    if ((match == buf || !((1 && ((*__ctype_b_loc())[(int)(((unsigned char)match[-1]))] & (unsigned short)_ISalnum)) || ((unsigned char)match[-1]) == '_')) && (len == end - beg - 1 || !((1 && ((*__ctype_b_loc())[(int)(((unsigned char)match[len]))] & (unsigned short)_ISalnum)) || ((unsigned char)match[len]) == '_')))
		        goto assess_pattern_match;
		    }
		    else if (__get_mutant()==7) {
		    if ((__is_neg(25, &(buf), sizeof (buf), &(match), sizeof (match), &(beg), sizeof (beg), &(end), sizeof (end), &(len), sizeof (len), &(best_match), sizeof (best_match), &(match_words), sizeof (match_words), &(i), sizeof (i), &(patterns), sizeof (patterns), &(match_lines), sizeof (match_lines), &(start_ptr), sizeof (start_ptr), &(start), sizeof (start), &(pcount), sizeof (pcount), &(best_len), sizeof (best_len), &(buflim), sizeof (buflim), &(backref), sizeof (backref), &(eol), sizeof (eol), &(ret_val), sizeof (ret_val), &(match_size), sizeof (match_size), &(mb_start), sizeof (mb_start), &(kwset_exact_matches), sizeof (kwset_exact_matches), &(kwset), sizeof (kwset), &(size), sizeof (size), &(match_icase), sizeof (match_icase), &(eolbyte), sizeof (eolbyte))))
		        goto out;
		    if ((match == buf || !((1 && ((*__ctype_b_loc())[(int)(((unsigned char)match[-1]))] & (unsigned short)_ISalnum)) || ((unsigned char)match[-1]) == '_')) && (len == end - beg - 1 || !((1 && ((*__ctype_b_loc())[(int)(((unsigned char)match[len]))] & (unsigned short)_ISalnum)) || ((unsigned char)match[len]) == '_')))
		        goto assess_pattern_match;
		    }
		    else if (__get_mutant()==8) {
		    if ((__is_neg(25, &(buf), sizeof (buf), &(match), sizeof (match), &(beg), sizeof (beg), &(end), sizeof (end), &(len), sizeof (len), &(best_match), sizeof (best_match), &(match_words), sizeof (match_words), &(i), sizeof (i), &(patterns), sizeof (patterns), &(match_lines), sizeof (match_lines), &(start_ptr), sizeof (start_ptr), &(start), sizeof (start), &(pcount), sizeof (pcount), &(best_len), sizeof (best_len), &(buflim), sizeof (buflim), &(backref), sizeof (backref), &(eol), sizeof (eol), &(ret_val), sizeof (ret_val), &(match_size), sizeof (match_size), &(mb_start), sizeof (mb_start), &(kwset_exact_matches), sizeof (kwset_exact_matches), &(kwset), sizeof (kwset), &(size), sizeof (size), &(match_icase), sizeof (match_icase), &(eolbyte), sizeof (eolbyte))))
		        return -1;
		    if ((match == buf || !((1 && ((*__ctype_b_loc())[(int)(((unsigned char)match[-1]))] & (unsigned short)_ISalnum)) || ((unsigned char)match[-1]) == '_')) && (len == end - beg - 1 || !((1 && ((*__ctype_b_loc())[(int)(((unsigned char)match[len]))] & (unsigned short)_ISalnum)) || ((unsigned char)match[len]) == '_')))
		        goto assess_pattern_match;
		    }
		    else if (__get_mutant()==9) {
		    if ((__is_neg(25, &(buf), sizeof (buf), &(match), sizeof (match), &(beg), sizeof (beg), &(end), sizeof (end), &(len), sizeof (len), &(best_match), sizeof (best_match), &(match_words), sizeof (match_words), &(i), sizeof (i), &(patterns), sizeof (patterns), &(match_lines), sizeof (match_lines), &(start_ptr), sizeof (start_ptr), &(start), sizeof (start), &(pcount), sizeof (pcount), &(best_len), sizeof (best_len), &(buflim), sizeof (buflim), &(backref), sizeof (backref), &(eol), sizeof (eol), &(ret_val), sizeof (ret_val), &(match_size), sizeof (match_size), &(mb_start), sizeof (mb_start), &(kwset_exact_matches), sizeof (kwset_exact_matches), &(kwset), sizeof (kwset), &(size), sizeof (size), &(match_icase), sizeof (match_icase), &(eolbyte), sizeof (eolbyte))))
		        return 0;
		    if ((match == buf || !((1 && ((*__ctype_b_loc())[(int)(((unsigned char)match[-1]))] & (unsigned short)_ISalnum)) || ((unsigned char)match[-1]) == '_')) && (len == end - beg - 1 || !((1 && ((*__ctype_b_loc())[(int)(((unsigned char)match[len]))] & (unsigned short)_ISalnum)) || ((unsigned char)match[len]) == '_')))
		        goto assess_pattern_match;
		    }
		    if (len > 0)
		      {
			/* Try a shorter length anchored at the same place. */
			--len;
			patterns[i].regexbuf.not_eol = 1;
			len = re_match (&(patterns[i].regexbuf),
					buf, match + len - beg, match - buf,
					&(patterns[i].regs));
		      }
		    if (len <= 0)
		      {
			/* Try looking further on. */
			if (match == end - 1)
			  break;
			match++;
			patterns[i].regexbuf.not_eol = 0;
			start = re_search (&(patterns[i].regexbuf),
					   buf, end - buf - 1,
					   match - buf, end - match - 1,
					   &(patterns[i].regs));
			if (start < 0)
			  break;
			len = patterns[i].regs.end[0] - start;
			match = buf + start;
		      }
		  } /* while (match <= best_match) */
	      continue;
	    assess_pattern_match:
	      if (!start_ptr)
		{
		  /* Good enough for a non-exact match.
		     No need to look at further patterns, if any.  */
		  beg = match;
		  goto success_in_len;
		}
	      if (match < best_match || (match == best_match && len > best_len))
		{
		  /* Best exact match:  leftmost, then longest.  */
		  best_match = match;
		  best_len = len;
		}
	    } /* if re_search >= 0 */
	} /* for Regex patterns.  */
	if (best_match < end)
	  {
	    /* We have found an exact match.  We were just
	       waiting for the best one (leftmost then longest).  */
	    beg = best_match;
	    len = best_len;
	    goto success_in_len;
	  }
    } /* for (beg = end ..) */

 failure:
  ret_val = -1;
  goto out;

 success:
  len = end - beg;
 success_in_len:
  *match_size = len;
  ret_val = beg - buf;
 out:
  return ret_val;
}

Building:src at:
/home/ubuntu/spr-fast/tests/corebench/grep/grep-case-8a025cf8-8f08d8e2/tempworkdir-l/srcMerged code building succ, going to invoke tester!
CondTester, Testing instance id 11:
//src_file:src/dfasearch.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); void* memset(void*, int, unsigned long); 
/* dfasearch.c - searching subroutines using dfa and regex for grep.
   Copyright 1992, 1998, 2000, 2007, 2009-2010 Free Software Foundation, Inc.

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 3, or (at your option)
   any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program; if not, write to the Free Software
   Foundation, Inc., 51 Franklin Street - Fifth Floor, Boston, MA
   02110-1301, USA.  */

/* Written August 1992 by Mike Haertel. */

#include <config.h>
#include "search.h"
#include "dfa.h"

/* For -w, we also consider _ to be word constituent.  */
#define WCHAR(C) (ISALNUM(C) || (C) == '_')

/* KWset compiled pattern.  For Ecompile and Gcompile, we compile
   a list of strings, at least one of which is known to occur in
   any string matching the regexp. */
static kwset_t kwset;

/* DFA compiled regexp. */
static struct dfa dfa;

/* The Regex compiled patterns.  */
static struct patterns
{
  /* Regex compiled regexp. */
  struct re_pattern_buffer regexbuf;
  struct re_registers regs; /* This is here on account of a BRAIN-DEAD
			       Q@#%!# library interface in regex.c.  */
} patterns0;

struct patterns *patterns;
size_t pcount;

void
dfaerror (char const *mesg)
{
  error (EXIT_TROUBLE, 0, "%s", mesg);

  /* notreached */
  /* Tell static analyzers that this function does not return.  */
  abort ();
}

/* Number of compiled fixed strings known to exactly match the regexp.
   If kwsexec returns < kwset_exact_matches, then we don't need to
   call the regexp matcher at all. */
static int kwset_exact_matches;

static char const *
kwsincr_case (const char *must)
{
  const char *buf;
  size_t n;

  n = strlen (must);
#ifdef MBS_SUPPORT
  if (match_icase && MB_CUR_MAX > 1)
    buf = mbtolower (must, &n);
  else
#endif
    buf = must;
  return kwsincr (kwset, buf, n);
}

/* If the DFA turns out to have some set of fixed strings one of
   which must occur in the match, then we build a kwset matcher
   to find those strings, and thus quickly filter out impossible
   matches. */
static void
kwsmusts (void)
{
  struct dfamust const *dm;
  char const *err;

  if (dfa.musts)
    {
      kwsinit (&kwset);
      /* First, we compile in the substrings known to be exact
	 matches.  The kwset matcher will return the index
	 of the matching string that it chooses. */
      for (dm = dfa.musts; dm; dm = dm->next)
	{
	  if (!dm->exact)
	    continue;
	  ++kwset_exact_matches;
	  if ((err = kwsincr_case (dm->must)) != NULL)
	    error (EXIT_TROUBLE, 0, "%s", err);
	}
      /* Now, we compile the substrings that will require
	 the use of the regexp matcher.  */
      for (dm = dfa.musts; dm; dm = dm->next)
	{
	  if (dm->exact)
	    continue;
	  if ((err = kwsincr_case (dm->must)) != NULL)
	    error (EXIT_TROUBLE, 0, "%s", err);
	}
      if ((err = kwsprep (kwset)) != NULL)
	error (EXIT_TROUBLE, 0, "%s", err);
    }
}

void
GEAcompile (char const *pattern, size_t size, reg_syntax_t syntax_bits)
{
  const char *err;
  const char *p, *sep;
  size_t total = size;
  char *motif;

  if (match_icase)
    syntax_bits |= RE_ICASE;
  re_set_syntax (syntax_bits);
  dfasyntax (syntax_bits, match_icase, eolbyte);

  /* For GNU regex compiler we have to pass the patterns separately to detect
     errors like "[\nallo\n]\n".  The patterns here are "[", "allo" and "]"
     GNU regex should have raise a syntax error.  The same for backref, where
     the backref should have been local to each pattern.  */
  p = pattern;
  do
    {
      size_t len;
      sep = memchr (p, '\n', total);
      if (sep)
	{
	  len = sep - p;
	  sep++;
	  total -= (len + 1);
	}
      else
	{
	  len = total;
	  total = 0;
	}

      patterns = realloc (patterns, (pcount + 1) * sizeof (*patterns));
      if (patterns == NULL)
	error (EXIT_TROUBLE, errno, _("memory exhausted"));
      patterns[pcount] = patterns0;

      if ((err = re_compile_pattern (p, len,
				    &(patterns[pcount].regexbuf))) != NULL)
	error (EXIT_TROUBLE, 0, "%s", err);
      pcount++;

      p = sep;
    } while (sep && total != 0);

  /* In the match_words and match_lines cases, we use a different pattern
     for the DFA matcher that will quickly throw out cases that won't work.
     Then if DFA succeeds we do some hairy stuff using the regex matcher
     to decide whether the match should really count. */
  if (match_words || match_lines)
    {
      static char const line_beg_no_bk[] = "^(";
      static char const line_end_no_bk[] = ")$";
      static char const word_beg_no_bk[] = "(^|[^[:alnum:]_])(";
      static char const word_end_no_bk[] = ")([^[:alnum:]_]|$)";
      static char const line_beg_bk[] = "^\\(";
      static char const line_end_bk[] = "\\)$";
      static char const word_beg_bk[] = "\\(^\\|[^[:alnum:]_]\\)\\(";
      static char const word_end_bk[] = "\\)\\([^[:alnum:]_]\\|$\\)";
      int bk = !(syntax_bits & RE_NO_BK_PARENS);
      char *n = xmalloc (sizeof word_beg_bk - 1 + size + sizeof word_end_bk);

      strcpy (n, match_lines ? (bk ? line_beg_bk : line_beg_no_bk)
			     : (bk ? word_beg_bk : word_beg_no_bk));
      total = strlen(n);
      memcpy (n + total, pattern, size);
      total += size;
      strcpy (n + total, match_lines ? (bk ? line_end_bk : line_end_no_bk)
				     : (bk ? word_end_bk : word_end_no_bk));
      total += strlen (n + total);
      pattern = motif = n;
      size = total;
    }
  else
    motif = NULL;

  dfacomp (pattern, size, &dfa, 1);
  kwsmusts ();

  free(motif);
}

size_t
EGexecute (char const *buf, size_t size, size_t *match_size,
	   char const *start_ptr)
{
  char const *buflim, *beg, *end, *match, *best_match, *mb_start;
  char eol = eolbyte;
  int backref, start, len, best_len;
  struct kwsmatch kwsm;
  size_t i, ret_val;
#ifdef MBS_SUPPORT
  if (MB_CUR_MAX > 1)
    {
      if (match_icase)
        {
          /* mbtolower adds a NUL byte at the end.  That will provide
	     space for the sentinel byte dfaexec may add.  */
          char *case_buf = mbtolower (buf, &size);
	  if (start_ptr)
	    start_ptr = case_buf + (start_ptr - buf);
          buf = case_buf;
        }
    }
#endif /* MBS_SUPPORT */

  mb_start = buf;
  buflim = buf + size;

  for (beg = end = buf; end < buflim; beg = end)
    {
      if (!start_ptr)
	{
	  /* We don't care about an exact match.  */
	  if (kwset)
	    {
	      /* Find a possible match using the KWset matcher. */
	      size_t offset = kwsexec (kwset, beg, buflim - beg, &kwsm);
	      if (offset == (size_t) -1)
		goto failure;
	      beg += offset;
	      /* Narrow down to the line containing the candidate, and
		 run it through DFA. */
	      if ((end = memchr(beg, eol, buflim - beg)) != NULL)
	        end++;
              else
                end = buflim;
	      match = beg;
	      while (beg > buf && beg[-1] != eol)
		--beg;
	      if (kwsm.index < kwset_exact_matches)
                {
#ifdef MBS_SUPPORT
                  if (mb_start < beg)
                    mb_start = beg;
                  if (MB_CUR_MAX == 1 || !is_mb_middle (&mb_start, match, buflim))
#endif
                    goto success;
                }
	      if (dfaexec (&dfa, beg, (char *) end, 0, NULL, &backref) == NULL)
		continue;
	    }
	  else
	    {
	      /* No good fixed strings; start with DFA. */
	      char const *next_beg = dfaexec (&dfa, beg, (char *) buflim,
					      0, NULL, &backref);
	      if (next_beg == NULL)
		break;
	      /* Narrow down to the line we've found. */
	      beg = next_beg;
	      if ((end = memchr(beg, eol, buflim - beg)) != NULL)
	        end++;
              else
                end = buflim;
	      while (beg > buf && beg[-1] != eol)
		--beg;
	    }
	  /* Successful, no backreferences encountered! */
	  if (!backref)
	    goto success;
	}
      else
	{
	  /* We are looking for the leftmost (then longest) exact match.
	     We will go through the outer loop only once.  */
	  beg = start_ptr;
	  end = buflim;
	}

      /* If we've made it to this point, this means DFA has seen
	 a probable match, and we need to run it through Regex. */
      best_match = end;
      best_len = 0;
      for (i = 0; i < pcount; i++)
	{
	  patterns[i].regexbuf.not_eol = 0;
	  if (0 <= (start = re_search (&(patterns[i].regexbuf),
				       buf, end - buf - 1,
				       beg - buf, end - beg - 1,
				       &(patterns[i].regs))))
	    {
	      len = patterns[i].regs.end[0] - start;
	      match = buf + start;
	      if (match > best_match)
		continue;
	      if (start_ptr && !match_words)
		goto assess_pattern_match;
	      if ((!match_lines && !match_words)
		  || (match_lines && len == end - beg - 1))
		{
		  match = beg;
		  len = end - beg;
		  goto assess_pattern_match;
		}
	      /* If -w, check if the match aligns with word boundaries.
		 We do this iteratively because:
		 (a) the line may contain more than one occurence of the
		 pattern, and
		 (b) Several alternatives in the pattern might be valid at a
		 given point, and we may need to consider a shorter one to
		 find a word boundary.  */
	      if (match_words)
		while (match <= best_match)
		  {
		    
//Patch 0:
if (((match == buf || !((1 && ((*__ctype_b_loc())[(int)(((unsigned char)match[-1]))] & (unsigned short)_ISalnum)) || ((unsigned char)match[-1]) == '_')) && (len == end - beg - 1 || !((1 && ((*__ctype_b_loc())[(int)(((unsigned char)match[len]))] & (unsigned short)_ISalnum)) || ((unsigned char)match[len]) == '_'))) && !(__is_neg(25, &(match), sizeof (match), &(len), sizeof (len), &(beg), sizeof (beg), &(end), sizeof (end), &(buf), sizeof (buf), &(best_match), sizeof (best_match), &(match_words), sizeof (match_words), &(i), sizeof (i), &(patterns), sizeof (patterns), &(start), sizeof (start), &(match_lines), sizeof (match_lines), &(start_ptr), sizeof (start_ptr), &(pcount), sizeof (pcount), &(best_len), sizeof (best_len), &(buflim), sizeof (buflim), &(backref), sizeof (backref), &(eol), sizeof (eol), &(ret_val), sizeof (ret_val), &(match_size), sizeof (match_size), &(mb_start), sizeof (mb_start), &(kwset_exact_matches), sizeof (kwset_exact_matches), &(kwset), sizeof (kwset), &(size), sizeof (size), &(match_icase), sizeof (match_icase), &(eolbyte), sizeof (eolbyte))))
    goto assess_pattern_match;

//CodeSeg 1:
		    if (len > 0)
		      {
			/* Try a shorter length anchored at the same place. */
			--len;
			patterns[i].regexbuf.not_eol = 1;
			len = re_match (&(patterns[i].regexbuf),
					buf, match + len - beg, match - buf,
					&(patterns[i].regs));
		      }
		    if (len <= 0)
		      {
			/* Try looking further on. */
			if (match == end - 1)
			  break;
			match++;
			patterns[i].regexbuf.not_eol = 0;
			start = re_search (&(patterns[i].regexbuf),
					   buf, end - buf - 1,
					   match - buf, end - match - 1,
					   &(patterns[i].regs));
			if (start < 0)
			  break;
			len = patterns[i].regs.end[0] - start;
			match = buf + start;
		      }
		  } /* while (match <= best_match) */
	      continue;
	    assess_pattern_match:
	      if (!start_ptr)
		{
		  /* Good enough for a non-exact match.
		     No need to look at further patterns, if any.  */
		  beg = match;
		  goto success_in_len;
		}
	      if (match < best_match || (match == best_match && len > best_len))
		{
		  /* Best exact match:  leftmost, then longest.  */
		  best_match = match;
		  best_len = len;
		}
	    } /* if re_search >= 0 */
	} /* for Regex patterns.  */
	if (best_match < end)
	  {
	    /* We have found an exact match.  We were just
	       waiting for the best one (leftmost then longest).  */
	    beg = best_match;
	    len = best_len;
	    goto success_in_len;
	  }
    } /* for (beg = end ..) */

 failure:
  ret_val = -1;
  goto out;

 success:
  len = end - beg;
 success_in_len:
  *match_size = len;
  ret_val = beg - buf;
 out:
  return ret_val;
}

Testing negative cases!
Testing 0 (with abstract condition) ENVIS_NEG
Iteration 0
Running test command:
/home/ubuntu/spr-fast/tools/grep-test.py /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-8a025cf8-8f08d8e2/tempworkdir-l/src /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-8a025cf8-8f08d8e2/tempworkdir-l/tests /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-8a025cf8-8f08d8e2/tempworkdir-l 0  > __res
Opening:/tmp/neg.tmp!
NegativeBRANCH RECORD/tmp/neg.tmp!
APPENDING TO ISNEG:/tmp/neg.tmp!
Branch 0: 0
Iteration 1
Running test command:
/home/ubuntu/spr-fast/tools/grep-test.py /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-8a025cf8-8f08d8e2/tempworkdir-l/src /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-8a025cf8-8f08d8e2/tempworkdir-l/tests /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-8a025cf8-8f08d8e2/tempworkdir-l 0  > __res
Opening:/tmp/neg.tmp!
NegativeBRANCH RECORD/tmp/neg.tmp!
APPENDING TO ISNEG:/tmp/neg.tmp!
Branch 0: 1
Running test command:
/home/ubuntu/spr-fast/tools/grep-test.py /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-8a025cf8-8f08d8e2/tempworkdir-l/src /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-8a025cf8-8f08d8e2/tempworkdir-l/tests /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-8a025cf8-8f08d8e2/tempworkdir-l 0  > __res
CondTester, Testing instance id 12:
//src_file:src/dfasearch.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); void* memset(void*, int, unsigned long); 
/* dfasearch.c - searching subroutines using dfa and regex for grep.
   Copyright 1992, 1998, 2000, 2007, 2009-2010 Free Software Foundation, Inc.

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 3, or (at your option)
   any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program; if not, write to the Free Software
   Foundation, Inc., 51 Franklin Street - Fifth Floor, Boston, MA
   02110-1301, USA.  */

/* Written August 1992 by Mike Haertel. */

#include <config.h>
#include "search.h"
#include "dfa.h"

/* For -w, we also consider _ to be word constituent.  */
#define WCHAR(C) (ISALNUM(C) || (C) == '_')

/* KWset compiled pattern.  For Ecompile and Gcompile, we compile
   a list of strings, at least one of which is known to occur in
   any string matching the regexp. */
static kwset_t kwset;

/* DFA compiled regexp. */
static struct dfa dfa;

/* The Regex compiled patterns.  */
static struct patterns
{
  /* Regex compiled regexp. */
  struct re_pattern_buffer regexbuf;
  struct re_registers regs; /* This is here on account of a BRAIN-DEAD
			       Q@#%!# library interface in regex.c.  */
} patterns0;

struct patterns *patterns;
size_t pcount;

void
dfaerror (char const *mesg)
{
  error (EXIT_TROUBLE, 0, "%s", mesg);

  /* notreached */
  /* Tell static analyzers that this function does not return.  */
  abort ();
}

/* Number of compiled fixed strings known to exactly match the regexp.
   If kwsexec returns < kwset_exact_matches, then we don't need to
   call the regexp matcher at all. */
static int kwset_exact_matches;

static char const *
kwsincr_case (const char *must)
{
  const char *buf;
  size_t n;

  n = strlen (must);
#ifdef MBS_SUPPORT
  if (match_icase && MB_CUR_MAX > 1)
    buf = mbtolower (must, &n);
  else
#endif
    buf = must;
  return kwsincr (kwset, buf, n);
}

/* If the DFA turns out to have some set of fixed strings one of
   which must occur in the match, then we build a kwset matcher
   to find those strings, and thus quickly filter out impossible
   matches. */
static void
kwsmusts (void)
{
  struct dfamust const *dm;
  char const *err;

  if (dfa.musts)
    {
      kwsinit (&kwset);
      /* First, we compile in the substrings known to be exact
	 matches.  The kwset matcher will return the index
	 of the matching string that it chooses. */
      for (dm = dfa.musts; dm; dm = dm->next)
	{
	  if (!dm->exact)
	    continue;
	  ++kwset_exact_matches;
	  if ((err = kwsincr_case (dm->must)) != NULL)
	    error (EXIT_TROUBLE, 0, "%s", err);
	}
      /* Now, we compile the substrings that will require
	 the use of the regexp matcher.  */
      for (dm = dfa.musts; dm; dm = dm->next)
	{
	  if (dm->exact)
	    continue;
	  if ((err = kwsincr_case (dm->must)) != NULL)
	    error (EXIT_TROUBLE, 0, "%s", err);
	}
      if ((err = kwsprep (kwset)) != NULL)
	error (EXIT_TROUBLE, 0, "%s", err);
    }
}

void
GEAcompile (char const *pattern, size_t size, reg_syntax_t syntax_bits)
{
  const char *err;
  const char *p, *sep;
  size_t total = size;
  char *motif;

  if (match_icase)
    syntax_bits |= RE_ICASE;
  re_set_syntax (syntax_bits);
  dfasyntax (syntax_bits, match_icase, eolbyte);

  /* For GNU regex compiler we have to pass the patterns separately to detect
     errors like "[\nallo\n]\n".  The patterns here are "[", "allo" and "]"
     GNU regex should have raise a syntax error.  The same for backref, where
     the backref should have been local to each pattern.  */
  p = pattern;
  do
    {
      size_t len;
      sep = memchr (p, '\n', total);
      if (sep)
	{
	  len = sep - p;
	  sep++;
	  total -= (len + 1);
	}
      else
	{
	  len = total;
	  total = 0;
	}

      patterns = realloc (patterns, (pcount + 1) * sizeof (*patterns));
      if (patterns == NULL)
	error (EXIT_TROUBLE, errno, _("memory exhausted"));
      patterns[pcount] = patterns0;

      if ((err = re_compile_pattern (p, len,
				    &(patterns[pcount].regexbuf))) != NULL)
	error (EXIT_TROUBLE, 0, "%s", err);
      pcount++;

      p = sep;
    } while (sep && total != 0);

  /* In the match_words and match_lines cases, we use a different pattern
     for the DFA matcher that will quickly throw out cases that won't work.
     Then if DFA succeeds we do some hairy stuff using the regex matcher
     to decide whether the match should really count. */
  if (match_words || match_lines)
    {
      static char const line_beg_no_bk[] = "^(";
      static char const line_end_no_bk[] = ")$";
      static char const word_beg_no_bk[] = "(^|[^[:alnum:]_])(";
      static char const word_end_no_bk[] = ")([^[:alnum:]_]|$)";
      static char const line_beg_bk[] = "^\\(";
      static char const line_end_bk[] = "\\)$";
      static char const word_beg_bk[] = "\\(^\\|[^[:alnum:]_]\\)\\(";
      static char const word_end_bk[] = "\\)\\([^[:alnum:]_]\\|$\\)";
      int bk = !(syntax_bits & RE_NO_BK_PARENS);
      char *n = xmalloc (sizeof word_beg_bk - 1 + size + sizeof word_end_bk);

      strcpy (n, match_lines ? (bk ? line_beg_bk : line_beg_no_bk)
			     : (bk ? word_beg_bk : word_beg_no_bk));
      total = strlen(n);
      memcpy (n + total, pattern, size);
      total += size;
      strcpy (n + total, match_lines ? (bk ? line_end_bk : line_end_no_bk)
				     : (bk ? word_end_bk : word_end_no_bk));
      total += strlen (n + total);
      pattern = motif = n;
      size = total;
    }
  else
    motif = NULL;

  dfacomp (pattern, size, &dfa, 1);
  kwsmusts ();

  free(motif);
}

size_t
EGexecute (char const *buf, size_t size, size_t *match_size,
	   char const *start_ptr)
{
  char const *buflim, *beg, *end, *match, *best_match, *mb_start;
  char eol = eolbyte;
  int backref, start, len, best_len;
  struct kwsmatch kwsm;
  size_t i, ret_val;
#ifdef MBS_SUPPORT
  if (MB_CUR_MAX > 1)
    {
      if (match_icase)
        {
          /* mbtolower adds a NUL byte at the end.  That will provide
	     space for the sentinel byte dfaexec may add.  */
          char *case_buf = mbtolower (buf, &size);
	  if (start_ptr)
	    start_ptr = case_buf + (start_ptr - buf);
          buf = case_buf;
        }
    }
#endif /* MBS_SUPPORT */

  mb_start = buf;
  buflim = buf + size;

  for (beg = end = buf; end < buflim; beg = end)
    {
      if (!start_ptr)
	{
	  /* We don't care about an exact match.  */
	  if (kwset)
	    {
	      /* Find a possible match using the KWset matcher. */
	      size_t offset = kwsexec (kwset, beg, buflim - beg, &kwsm);
	      if (offset == (size_t) -1)
		goto failure;
	      beg += offset;
	      /* Narrow down to the line containing the candidate, and
		 run it through DFA. */
	      if ((end = memchr(beg, eol, buflim - beg)) != NULL)
	        end++;
              else
                end = buflim;
	      match = beg;
	      while (beg > buf && beg[-1] != eol)
		--beg;
	      if (kwsm.index < kwset_exact_matches)
                {
#ifdef MBS_SUPPORT
                  if (mb_start < beg)
                    mb_start = beg;
                  if (MB_CUR_MAX == 1 || !is_mb_middle (&mb_start, match, buflim))
#endif
                    goto success;
                }
	      if (dfaexec (&dfa, beg, (char *) end, 0, NULL, &backref) == NULL)
		continue;
	    }
	  else
	    {
	      /* No good fixed strings; start with DFA. */
	      char const *next_beg = dfaexec (&dfa, beg, (char *) buflim,
					      0, NULL, &backref);
	      if (next_beg == NULL)
		break;
	      /* Narrow down to the line we've found. */
	      beg = next_beg;
	      if ((end = memchr(beg, eol, buflim - beg)) != NULL)
	        end++;
              else
                end = buflim;
	      while (beg > buf && beg[-1] != eol)
		--beg;
	    }
	  /* Successful, no backreferences encountered! */
	  if (!backref)
	    goto success;
	}
      else
	{
	  /* We are looking for the leftmost (then longest) exact match.
	     We will go through the outer loop only once.  */
	  beg = start_ptr;
	  end = buflim;
	}

      /* If we've made it to this point, this means DFA has seen
	 a probable match, and we need to run it through Regex. */
      best_match = end;
      best_len = 0;
      for (i = 0; i < pcount; i++)
	{
	  patterns[i].regexbuf.not_eol = 0;
	  if (0 <= (start = re_search (&(patterns[i].regexbuf),
				       buf, end - buf - 1,
				       beg - buf, end - beg - 1,
				       &(patterns[i].regs))))
	    {
	      len = patterns[i].regs.end[0] - start;
	      match = buf + start;
	      if (match > best_match)
		continue;
	      if (start_ptr && !match_words)
		goto assess_pattern_match;
	      if ((!match_lines && !match_words)
		  || (match_lines && len == end - beg - 1))
		{
		  match = beg;
		  len = end - beg;
		  goto assess_pattern_match;
		}
	      /* If -w, check if the match aligns with word boundaries.
		 We do this iteratively because:
		 (a) the line may contain more than one occurence of the
		 pattern, and
		 (b) Several alternatives in the pattern might be valid at a
		 given point, and we may need to consider a shorter one to
		 find a word boundary.  */
	      if (match_words)
		while (match <= best_match)
		  {
		    
//Patch 0:
if (((match == buf || !((1 && ((*__ctype_b_loc())[(int)(((unsigned char)match[-1]))] & (unsigned short)_ISalnum)) || ((unsigned char)match[-1]) == '_')) && (len == end - beg - 1 || !((1 && ((*__ctype_b_loc())[(int)(((unsigned char)match[len]))] & (unsigned short)_ISalnum)) || ((unsigned char)match[len]) == '_'))) || (__is_neg(25, &(match), sizeof (match), &(len), sizeof (len), &(beg), sizeof (beg), &(end), sizeof (end), &(buf), sizeof (buf), &(best_match), sizeof (best_match), &(match_words), sizeof (match_words), &(i), sizeof (i), &(patterns), sizeof (patterns), &(start), sizeof (start), &(match_lines), sizeof (match_lines), &(start_ptr), sizeof (start_ptr), &(pcount), sizeof (pcount), &(best_len), sizeof (best_len), &(buflim), sizeof (buflim), &(backref), sizeof (backref), &(eol), sizeof (eol), &(ret_val), sizeof (ret_val), &(match_size), sizeof (match_size), &(mb_start), sizeof (mb_start), &(kwset_exact_matches), sizeof (kwset_exact_matches), &(kwset), sizeof (kwset), &(size), sizeof (size), &(match_icase), sizeof (match_icase), &(eolbyte), sizeof (eolbyte))))
    goto assess_pattern_match;

//CodeSeg 1:
		    if (len > 0)
		      {
			/* Try a shorter length anchored at the same place. */
			--len;
			patterns[i].regexbuf.not_eol = 1;
			len = re_match (&(patterns[i].regexbuf),
					buf, match + len - beg, match - buf,
					&(patterns[i].regs));
		      }
		    if (len <= 0)
		      {
			/* Try looking further on. */
			if (match == end - 1)
			  break;
			match++;
			patterns[i].regexbuf.not_eol = 0;
			start = re_search (&(patterns[i].regexbuf),
					   buf, end - buf - 1,
					   match - buf, end - match - 1,
					   &(patterns[i].regs));
			if (start < 0)
			  break;
			len = patterns[i].regs.end[0] - start;
			match = buf + start;
		      }
		  } /* while (match <= best_match) */
	      continue;
	    assess_pattern_match:
	      if (!start_ptr)
		{
		  /* Good enough for a non-exact match.
		     No need to look at further patterns, if any.  */
		  beg = match;
		  goto success_in_len;
		}
	      if (match < best_match || (match == best_match && len > best_len))
		{
		  /* Best exact match:  leftmost, then longest.  */
		  best_match = match;
		  best_len = len;
		}
	    } /* if re_search >= 0 */
	} /* for Regex patterns.  */
	if (best_match < end)
	  {
	    /* We have found an exact match.  We were just
	       waiting for the best one (leftmost then longest).  */
	    beg = best_match;
	    len = best_len;
	    goto success_in_len;
	  }
    } /* for (beg = end ..) */

 failure:
  ret_val = -1;
  goto out;

 success:
  len = end - beg;
 success_in_len:
  *match_size = len;
  ret_val = beg - buf;
 out:
  return ret_val;
}

Testing negative cases!
Testing 0 (with abstract condition) ENVIS_NEG
Iteration 0
Running test command:
/home/ubuntu/spr-fast/tools/grep-test.py /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-8a025cf8-8f08d8e2/tempworkdir-l/src /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-8a025cf8-8f08d8e2/tempworkdir-l/tests /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-8a025cf8-8f08d8e2/tempworkdir-l 0  > __res
Opening:/tmp/neg.tmp!
NegativeBRANCH RECORD/tmp/neg.tmp!
Not caught by the negative case, give up!
APPENDING TO ISNEG:/tmp/neg.tmp!
Running test command:
/home/ubuntu/spr-fast/tools/grep-test.py /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-8a025cf8-8f08d8e2/tempworkdir-l/src /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-8a025cf8-8f08d8e2/tempworkdir-l/tests /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-8a025cf8-8f08d8e2/tempworkdir-l 0  > __res
CondTester, Testing instance id 13:
//src_file:src/dfasearch.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); void* memset(void*, int, unsigned long); 
/* dfasearch.c - searching subroutines using dfa and regex for grep.
   Copyright 1992, 1998, 2000, 2007, 2009-2010 Free Software Foundation, Inc.

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 3, or (at your option)
   any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program; if not, write to the Free Software
   Foundation, Inc., 51 Franklin Street - Fifth Floor, Boston, MA
   02110-1301, USA.  */

/* Written August 1992 by Mike Haertel. */

#include <config.h>
#include "search.h"
#include "dfa.h"

/* For -w, we also consider _ to be word constituent.  */
#define WCHAR(C) (ISALNUM(C) || (C) == '_')

/* KWset compiled pattern.  For Ecompile and Gcompile, we compile
   a list of strings, at least one of which is known to occur in
   any string matching the regexp. */
static kwset_t kwset;

/* DFA compiled regexp. */
static struct dfa dfa;

/* The Regex compiled patterns.  */
static struct patterns
{
  /* Regex compiled regexp. */
  struct re_pattern_buffer regexbuf;
  struct re_registers regs; /* This is here on account of a BRAIN-DEAD
			       Q@#%!# library interface in regex.c.  */
} patterns0;

struct patterns *patterns;
size_t pcount;

void
dfaerror (char const *mesg)
{
  error (EXIT_TROUBLE, 0, "%s", mesg);

  /* notreached */
  /* Tell static analyzers that this function does not return.  */
  abort ();
}

/* Number of compiled fixed strings known to exactly match the regexp.
   If kwsexec returns < kwset_exact_matches, then we don't need to
   call the regexp matcher at all. */
static int kwset_exact_matches;

static char const *
kwsincr_case (const char *must)
{
  const char *buf;
  size_t n;

  n = strlen (must);
#ifdef MBS_SUPPORT
  if (match_icase && MB_CUR_MAX > 1)
    buf = mbtolower (must, &n);
  else
#endif
    buf = must;
  return kwsincr (kwset, buf, n);
}

/* If the DFA turns out to have some set of fixed strings one of
   which must occur in the match, then we build a kwset matcher
   to find those strings, and thus quickly filter out impossible
   matches. */
static void
kwsmusts (void)
{
  struct dfamust const *dm;
  char const *err;

  if (dfa.musts)
    {
      kwsinit (&kwset);
      /* First, we compile in the substrings known to be exact
	 matches.  The kwset matcher will return the index
	 of the matching string that it chooses. */
      for (dm = dfa.musts; dm; dm = dm->next)
	{
	  if (!dm->exact)
	    continue;
	  ++kwset_exact_matches;
	  if ((err = kwsincr_case (dm->must)) != NULL)
	    error (EXIT_TROUBLE, 0, "%s", err);
	}
      /* Now, we compile the substrings that will require
	 the use of the regexp matcher.  */
      for (dm = dfa.musts; dm; dm = dm->next)
	{
	  if (dm->exact)
	    continue;
	  if ((err = kwsincr_case (dm->must)) != NULL)
	    error (EXIT_TROUBLE, 0, "%s", err);
	}
      if ((err = kwsprep (kwset)) != NULL)
	error (EXIT_TROUBLE, 0, "%s", err);
    }
}

void
GEAcompile (char const *pattern, size_t size, reg_syntax_t syntax_bits)
{
  const char *err;
  const char *p, *sep;
  size_t total = size;
  char *motif;

  if (match_icase)
    syntax_bits |= RE_ICASE;
  re_set_syntax (syntax_bits);
  dfasyntax (syntax_bits, match_icase, eolbyte);

  /* For GNU regex compiler we have to pass the patterns separately to detect
     errors like "[\nallo\n]\n".  The patterns here are "[", "allo" and "]"
     GNU regex should have raise a syntax error.  The same for backref, where
     the backref should have been local to each pattern.  */
  p = pattern;
  do
    {
      size_t len;
      sep = memchr (p, '\n', total);
      if (sep)
	{
	  len = sep - p;
	  sep++;
	  total -= (len + 1);
	}
      else
	{
	  len = total;
	  total = 0;
	}

      patterns = realloc (patterns, (pcount + 1) * sizeof (*patterns));
      if (patterns == NULL)
	error (EXIT_TROUBLE, errno, _("memory exhausted"));
      patterns[pcount] = patterns0;

      if ((err = re_compile_pattern (p, len,
				    &(patterns[pcount].regexbuf))) != NULL)
	error (EXIT_TROUBLE, 0, "%s", err);
      pcount++;

      p = sep;
    } while (sep && total != 0);

  /* In the match_words and match_lines cases, we use a different pattern
     for the DFA matcher that will quickly throw out cases that won't work.
     Then if DFA succeeds we do some hairy stuff using the regex matcher
     to decide whether the match should really count. */
  if (match_words || match_lines)
    {
      static char const line_beg_no_bk[] = "^(";
      static char const line_end_no_bk[] = ")$";
      static char const word_beg_no_bk[] = "(^|[^[:alnum:]_])(";
      static char const word_end_no_bk[] = ")([^[:alnum:]_]|$)";
      static char const line_beg_bk[] = "^\\(";
      static char const line_end_bk[] = "\\)$";
      static char const word_beg_bk[] = "\\(^\\|[^[:alnum:]_]\\)\\(";
      static char const word_end_bk[] = "\\)\\([^[:alnum:]_]\\|$\\)";
      int bk = !(syntax_bits & RE_NO_BK_PARENS);
      char *n = xmalloc (sizeof word_beg_bk - 1 + size + sizeof word_end_bk);

      strcpy (n, match_lines ? (bk ? line_beg_bk : line_beg_no_bk)
			     : (bk ? word_beg_bk : word_beg_no_bk));
      total = strlen(n);
      memcpy (n + total, pattern, size);
      total += size;
      strcpy (n + total, match_lines ? (bk ? line_end_bk : line_end_no_bk)
				     : (bk ? word_end_bk : word_end_no_bk));
      total += strlen (n + total);
      pattern = motif = n;
      size = total;
    }
  else
    motif = NULL;

  dfacomp (pattern, size, &dfa, 1);
  kwsmusts ();

  free(motif);
}

size_t
EGexecute (char const *buf, size_t size, size_t *match_size,
	   char const *start_ptr)
{
  char const *buflim, *beg, *end, *match, *best_match, *mb_start;
  char eol = eolbyte;
  int backref, start, len, best_len;
  struct kwsmatch kwsm;
  size_t i, ret_val;
#ifdef MBS_SUPPORT
  if (MB_CUR_MAX > 1)
    {
      if (match_icase)
        {
          /* mbtolower adds a NUL byte at the end.  That will provide
	     space for the sentinel byte dfaexec may add.  */
          char *case_buf = mbtolower (buf, &size);
	  if (start_ptr)
	    start_ptr = case_buf + (start_ptr - buf);
          buf = case_buf;
        }
    }
#endif /* MBS_SUPPORT */

  mb_start = buf;
  buflim = buf + size;

  for (beg = end = buf; end < buflim; beg = end)
    {
      if (!start_ptr)
	{
	  /* We don't care about an exact match.  */
	  if (kwset)
	    {
	      /* Find a possible match using the KWset matcher. */
	      size_t offset = kwsexec (kwset, beg, buflim - beg, &kwsm);
	      if (offset == (size_t) -1)
		goto failure;
	      beg += offset;
	      /* Narrow down to the line containing the candidate, and
		 run it through DFA. */
	      if ((end = memchr(beg, eol, buflim - beg)) != NULL)
	        end++;
              else
                end = buflim;
	      match = beg;
	      while (beg > buf && beg[-1] != eol)
		--beg;
	      if (kwsm.index < kwset_exact_matches)
                {
#ifdef MBS_SUPPORT
                  if (mb_start < beg)
                    mb_start = beg;
                  if (MB_CUR_MAX == 1 || !is_mb_middle (&mb_start, match, buflim))
#endif
                    goto success;
                }
	      if (dfaexec (&dfa, beg, (char *) end, 0, NULL, &backref) == NULL)
		continue;
	    }
	  else
	    {
	      /* No good fixed strings; start with DFA. */
	      char const *next_beg = dfaexec (&dfa, beg, (char *) buflim,
					      0, NULL, &backref);
	      if (next_beg == NULL)
		break;
	      /* Narrow down to the line we've found. */
	      beg = next_beg;
	      if ((end = memchr(beg, eol, buflim - beg)) != NULL)
	        end++;
              else
                end = buflim;
	      while (beg > buf && beg[-1] != eol)
		--beg;
	    }
	  /* Successful, no backreferences encountered! */
	  if (!backref)
	    goto success;
	}
      else
	{
	  /* We are looking for the leftmost (then longest) exact match.
	     We will go through the outer loop only once.  */
	  beg = start_ptr;
	  end = buflim;
	}

      /* If we've made it to this point, this means DFA has seen
	 a probable match, and we need to run it through Regex. */
      best_match = end;
      best_len = 0;
      for (i = 0; i < pcount; i++)
	{
	  patterns[i].regexbuf.not_eol = 0;
	  if (0 <= (start = re_search (&(patterns[i].regexbuf),
				       buf, end - buf - 1,
				       beg - buf, end - beg - 1,
				       &(patterns[i].regs))))
	    {
	      len = patterns[i].regs.end[0] - start;
	      match = buf + start;
	      if (match > best_match)
		continue;
	      if (start_ptr && !match_words)
		goto assess_pattern_match;
	      if ((!match_lines && !match_words)
		  || (match_lines && len == end - beg - 1))
		{
		  match = beg;
		  len = end - beg;
		  goto assess_pattern_match;
		}
	      /* If -w, check if the match aligns with word boundaries.
		 We do this iteratively because:
		 (a) the line may contain more than one occurence of the
		 pattern, and
		 (b) Several alternatives in the pattern might be valid at a
		 given point, and we may need to consider a shorter one to
		 find a word boundary.  */
	      if (match_words)
		while (match <= best_match)
		  {
		    
//Patch 0:
if ((((match == buf || !((1 && ((*__ctype_b_loc())[(int)(((unsigned char)match[-1]))] & (unsigned short)_ISalnum)) || ((unsigned char)match[-1]) == '_'))) || (__is_neg(25, &(match), sizeof (match), &(len), sizeof (len), &(beg), sizeof (beg), &(end), sizeof (end), &(buf), sizeof (buf), &(best_match), sizeof (best_match), &(match_words), sizeof (match_words), &(i), sizeof (i), &(patterns), sizeof (patterns), &(start), sizeof (start), &(match_lines), sizeof (match_lines), &(start_ptr), sizeof (start_ptr), &(pcount), sizeof (pcount), &(best_len), sizeof (best_len), &(buflim), sizeof (buflim), &(backref), sizeof (backref), &(eol), sizeof (eol), &(ret_val), sizeof (ret_val), &(match_size), sizeof (match_size), &(mb_start), sizeof (mb_start), &(kwset_exact_matches), sizeof (kwset_exact_matches), &(kwset), sizeof (kwset), &(size), sizeof (size), &(match_icase), sizeof (match_icase), &(eolbyte), sizeof (eolbyte)))) && (len == end - beg - 1 || !((1 && ((*__ctype_b_loc())[(int)(((unsigned char)match[len]))] & (unsigned short)_ISalnum)) || ((unsigned char)match[len]) == '_')))
    goto assess_pattern_match;

//CodeSeg 1:
		    if (len > 0)
		      {
			/* Try a shorter length anchored at the same place. */
			--len;
			patterns[i].regexbuf.not_eol = 1;
			len = re_match (&(patterns[i].regexbuf),
					buf, match + len - beg, match - buf,
					&(patterns[i].regs));
		      }
		    if (len <= 0)
		      {
			/* Try looking further on. */
			if (match == end - 1)
			  break;
			match++;
			patterns[i].regexbuf.not_eol = 0;
			start = re_search (&(patterns[i].regexbuf),
					   buf, end - buf - 1,
					   match - buf, end - match - 1,
					   &(patterns[i].regs));
			if (start < 0)
			  break;
			len = patterns[i].regs.end[0] - start;
			match = buf + start;
		      }
		  } /* while (match <= best_match) */
	      continue;
	    assess_pattern_match:
	      if (!start_ptr)
		{
		  /* Good enough for a non-exact match.
		     No need to look at further patterns, if any.  */
		  beg = match;
		  goto success_in_len;
		}
	      if (match < best_match || (match == best_match && len > best_len))
		{
		  /* Best exact match:  leftmost, then longest.  */
		  best_match = match;
		  best_len = len;
		}
	    } /* if re_search >= 0 */
	} /* for Regex patterns.  */
	if (best_match < end)
	  {
	    /* We have found an exact match.  We were just
	       waiting for the best one (leftmost then longest).  */
	    beg = best_match;
	    len = best_len;
	    goto success_in_len;
	  }
    } /* for (beg = end ..) */

 failure:
  ret_val = -1;
  goto out;

 success:
  len = end - beg;
 success_in_len:
  *match_size = len;
  ret_val = beg - buf;
 out:
  return ret_val;
}

Testing negative cases!
Testing 0 (with abstract condition) ENVIS_NEG
Iteration 0
Running test command:
/home/ubuntu/spr-fast/tools/grep-test.py /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-8a025cf8-8f08d8e2/tempworkdir-l/src /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-8a025cf8-8f08d8e2/tempworkdir-l/tests /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-8a025cf8-8f08d8e2/tempworkdir-l 0  > __res
Opening:/tmp/neg.tmp!
NegativeBRANCH RECORD/tmp/neg.tmp!
Not caught by the negative case, give up!
APPENDING TO ISNEG:/tmp/neg.tmp!
Running test command:
/home/ubuntu/spr-fast/tools/grep-test.py /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-8a025cf8-8f08d8e2/tempworkdir-l/src /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-8a025cf8-8f08d8e2/tempworkdir-l/tests /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-8a025cf8-8f08d8e2/tempworkdir-l 0  > __res
CondTester, Testing instance id 92:
//src_file:src/dfasearch.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); void* memset(void*, int, unsigned long); 
/* dfasearch.c - searching subroutines using dfa and regex for grep.
   Copyright 1992, 1998, 2000, 2007, 2009-2010 Free Software Foundation, Inc.

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 3, or (at your option)
   any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program; if not, write to the Free Software
   Foundation, Inc., 51 Franklin Street - Fifth Floor, Boston, MA
   02110-1301, USA.  */

/* Written August 1992 by Mike Haertel. */

#include <config.h>
#include "search.h"
#include "dfa.h"

/* For -w, we also consider _ to be word constituent.  */
#define WCHAR(C) (ISALNUM(C) || (C) == '_')

/* KWset compiled pattern.  For Ecompile and Gcompile, we compile
   a list of strings, at least one of which is known to occur in
   any string matching the regexp. */
static kwset_t kwset;

/* DFA compiled regexp. */
static struct dfa dfa;

/* The Regex compiled patterns.  */
static struct patterns
{
  /* Regex compiled regexp. */
  struct re_pattern_buffer regexbuf;
  struct re_registers regs; /* This is here on account of a BRAIN-DEAD
			       Q@#%!# library interface in regex.c.  */
} patterns0;

struct patterns *patterns;
size_t pcount;

void
dfaerror (char const *mesg)
{
  error (EXIT_TROUBLE, 0, "%s", mesg);

  /* notreached */
  /* Tell static analyzers that this function does not return.  */
  abort ();
}

/* Number of compiled fixed strings known to exactly match the regexp.
   If kwsexec returns < kwset_exact_matches, then we don't need to
   call the regexp matcher at all. */
static int kwset_exact_matches;

static char const *
kwsincr_case (const char *must)
{
  const char *buf;
  size_t n;

  n = strlen (must);
#ifdef MBS_SUPPORT
  if (match_icase && MB_CUR_MAX > 1)
    buf = mbtolower (must, &n);
  else
#endif
    buf = must;
  return kwsincr (kwset, buf, n);
}

/* If the DFA turns out to have some set of fixed strings one of
   which must occur in the match, then we build a kwset matcher
   to find those strings, and thus quickly filter out impossible
   matches. */
static void
kwsmusts (void)
{
  struct dfamust const *dm;
  char const *err;

  if (dfa.musts)
    {
      kwsinit (&kwset);
      /* First, we compile in the substrings known to be exact
	 matches.  The kwset matcher will return the index
	 of the matching string that it chooses. */
      for (dm = dfa.musts; dm; dm = dm->next)
	{
	  if (!dm->exact)
	    continue;
	  ++kwset_exact_matches;
	  if ((err = kwsincr_case (dm->must)) != NULL)
	    error (EXIT_TROUBLE, 0, "%s", err);
	}
      /* Now, we compile the substrings that will require
	 the use of the regexp matcher.  */
      for (dm = dfa.musts; dm; dm = dm->next)
	{
	  if (dm->exact)
	    continue;
	  if ((err = kwsincr_case (dm->must)) != NULL)
	    error (EXIT_TROUBLE, 0, "%s", err);
	}
      if ((err = kwsprep (kwset)) != NULL)
	error (EXIT_TROUBLE, 0, "%s", err);
    }
}

void
GEAcompile (char const *pattern, size_t size, reg_syntax_t syntax_bits)
{
  const char *err;
  const char *p, *sep;
  size_t total = size;
  char *motif;

  if (match_icase)
    syntax_bits |= RE_ICASE;
  re_set_syntax (syntax_bits);
  dfasyntax (syntax_bits, match_icase, eolbyte);

  /* For GNU regex compiler we have to pass the patterns separately to detect
     errors like "[\nallo\n]\n".  The patterns here are "[", "allo" and "]"
     GNU regex should have raise a syntax error.  The same for backref, where
     the backref should have been local to each pattern.  */
  p = pattern;
  do
    {
      size_t len;
      sep = memchr (p, '\n', total);
      if (sep)
	{
	  len = sep - p;
	  sep++;
	  total -= (len + 1);
	}
      else
	{
	  len = total;
	  total = 0;
	}

      patterns = realloc (patterns, (pcount + 1) * sizeof (*patterns));
      if (patterns == NULL)
	error (EXIT_TROUBLE, errno, _("memory exhausted"));
      patterns[pcount] = patterns0;

      if ((err = re_compile_pattern (p, len,
				    &(patterns[pcount].regexbuf))) != NULL)
	error (EXIT_TROUBLE, 0, "%s", err);
      pcount++;

      p = sep;
    } while (sep && total != 0);

  /* In the match_words and match_lines cases, we use a different pattern
     for the DFA matcher that will quickly throw out cases that won't work.
     Then if DFA succeeds we do some hairy stuff using the regex matcher
     to decide whether the match should really count. */
  if (match_words || match_lines)
    {
      static char const line_beg_no_bk[] = "^(";
      static char const line_end_no_bk[] = ")$";
      static char const word_beg_no_bk[] = "(^|[^[:alnum:]_])(";
      static char const word_end_no_bk[] = ")([^[:alnum:]_]|$)";
      static char const line_beg_bk[] = "^\\(";
      static char const line_end_bk[] = "\\)$";
      static char const word_beg_bk[] = "\\(^\\|[^[:alnum:]_]\\)\\(";
      static char const word_end_bk[] = "\\)\\([^[:alnum:]_]\\|$\\)";
      int bk = !(syntax_bits & RE_NO_BK_PARENS);
      char *n = xmalloc (sizeof word_beg_bk - 1 + size + sizeof word_end_bk);

      strcpy (n, match_lines ? (bk ? line_beg_bk : line_beg_no_bk)
			     : (bk ? word_beg_bk : word_beg_no_bk));
      total = strlen(n);
      memcpy (n + total, pattern, size);
      total += size;
      strcpy (n + total, match_lines ? (bk ? line_end_bk : line_end_no_bk)
				     : (bk ? word_end_bk : word_end_no_bk));
      total += strlen (n + total);
      pattern = motif = n;
      size = total;
    }
  else
    motif = NULL;

  dfacomp (pattern, size, &dfa, 1);
  kwsmusts ();

  free(motif);
}

size_t
EGexecute (char const *buf, size_t size, size_t *match_size,
	   char const *start_ptr)
{
  char const *buflim, *beg, *end, *match, *best_match, *mb_start;
  char eol = eolbyte;
  int backref, start, len, best_len;
  struct kwsmatch kwsm;
  size_t i, ret_val;
#ifdef MBS_SUPPORT
  if (MB_CUR_MAX > 1)
    {
      if (match_icase)
        {
          /* mbtolower adds a NUL byte at the end.  That will provide
	     space for the sentinel byte dfaexec may add.  */
          char *case_buf = mbtolower (buf, &size);
	  if (start_ptr)
	    start_ptr = case_buf + (start_ptr - buf);
          buf = case_buf;
        }
    }
#endif /* MBS_SUPPORT */

  mb_start = buf;
  buflim = buf + size;

  for (beg = end = buf; end < buflim; beg = end)
    {
      if (!start_ptr)
	{
	  /* We don't care about an exact match.  */
	  if (kwset)
	    {
	      /* Find a possible match using the KWset matcher. */
	      size_t offset = kwsexec (kwset, beg, buflim - beg, &kwsm);
	      if (offset == (size_t) -1)
		goto failure;
	      beg += offset;
	      /* Narrow down to the line containing the candidate, and
		 run it through DFA. */
	      if ((end = memchr(beg, eol, buflim - beg)) != NULL)
	        end++;
              else
                end = buflim;
	      match = beg;
	      while (beg > buf && beg[-1] != eol)
		--beg;
	      if (kwsm.index < kwset_exact_matches)
                {
#ifdef MBS_SUPPORT
                  if (mb_start < beg)
                    mb_start = beg;
                  if (MB_CUR_MAX == 1 || !is_mb_middle (&mb_start, match, buflim))
#endif
                    goto success;
                }
	      if (dfaexec (&dfa, beg, (char *) end, 0, NULL, &backref) == NULL)
		continue;
	    }
	  else
	    {
	      /* No good fixed strings; start with DFA. */
	      char const *next_beg = dfaexec (&dfa, beg, (char *) buflim,
					      0, NULL, &backref);
	      if (next_beg == NULL)
		break;
	      /* Narrow down to the line we've found. */
	      beg = next_beg;
	      if ((end = memchr(beg, eol, buflim - beg)) != NULL)
	        end++;
              else
                end = buflim;
	      while (beg > buf && beg[-1] != eol)
		--beg;
	    }
	  /* Successful, no backreferences encountered! */
	  if (!backref)
	    goto success;
	}
      else
	{
	  /* We are looking for the leftmost (then longest) exact match.
	     We will go through the outer loop only once.  */
	  beg = start_ptr;
	  end = buflim;
	}

      /* If we've made it to this point, this means DFA has seen
	 a probable match, and we need to run it through Regex. */
      best_match = end;
      best_len = 0;
      for (i = 0; i < pcount; i++)
	{
	  patterns[i].regexbuf.not_eol = 0;
	  if (0 <= (start = re_search (&(patterns[i].regexbuf),
				       buf, end - buf - 1,
				       beg - buf, end - beg - 1,
				       &(patterns[i].regs))))
	    {
	      len = patterns[i].regs.end[0] - start;
	      match = buf + start;
	      if (match > best_match)
		continue;
	      if (start_ptr && !match_words)
		goto assess_pattern_match;
	      if ((!match_lines && !match_words)
		  || (match_lines && len == end - beg - 1))
		{
		  match = beg;
		  len = end - beg;
		  goto assess_pattern_match;
		}
	      /* If -w, check if the match aligns with word boundaries.
		 We do this iteratively because:
		 (a) the line may contain more than one occurence of the
		 pattern, and
		 (b) Several alternatives in the pattern might be valid at a
		 given point, and we may need to consider a shorter one to
		 find a word boundary.  */
	      if (match_words)
		while (match <= best_match)
		  {
		    
//Patch 0:
if ((__is_neg(25, &(buf), sizeof (buf), &(match), sizeof (match), &(beg), sizeof (beg), &(end), sizeof (end), &(len), sizeof (len), &(best_match), sizeof (best_match), &(match_words), sizeof (match_words), &(i), sizeof (i), &(patterns), sizeof (patterns), &(match_lines), sizeof (match_lines), &(start_ptr), sizeof (start_ptr), &(start), sizeof (start), &(pcount), sizeof (pcount), &(best_len), sizeof (best_len), &(buflim), sizeof (buflim), &(backref), sizeof (backref), &(eol), sizeof (eol), &(ret_val), sizeof (ret_val), &(match_size), sizeof (match_size), &(mb_start), sizeof (mb_start), &(kwset_exact_matches), sizeof (kwset_exact_matches), &(kwset), sizeof (kwset), &(size), sizeof (size), &(match_icase), sizeof (match_icase), &(eolbyte), sizeof (eolbyte))))
    goto assess_pattern_match;
if ((match == buf || !((1 && ((*__ctype_b_loc())[(int)(((unsigned char)match[-1]))] & (unsigned short)_ISalnum)) || ((unsigned char)match[-1]) == '_')) && (len == end - beg - 1 || !((1 && ((*__ctype_b_loc())[(int)(((unsigned char)match[len]))] & (unsigned short)_ISalnum)) || ((unsigned char)match[len]) == '_')))
    goto assess_pattern_match;

//CodeSeg 1:
		    if (len > 0)
		      {
			/* Try a shorter length anchored at the same place. */
			--len;
			patterns[i].regexbuf.not_eol = 1;
			len = re_match (&(patterns[i].regexbuf),
					buf, match + len - beg, match - buf,
					&(patterns[i].regs));
		      }
		    if (len <= 0)
		      {
			/* Try looking further on. */
			if (match == end - 1)
			  break;
			match++;
			patterns[i].regexbuf.not_eol = 0;
			start = re_search (&(patterns[i].regexbuf),
					   buf, end - buf - 1,
					   match - buf, end - match - 1,
					   &(patterns[i].regs));
			if (start < 0)
			  break;
			len = patterns[i].regs.end[0] - start;
			match = buf + start;
		      }
		  } /* while (match <= best_match) */
	      continue;
	    assess_pattern_match:
	      if (!start_ptr)
		{
		  /* Good enough for a non-exact match.
		     No need to look at further patterns, if any.  */
		  beg = match;
		  goto success_in_len;
		}
	      if (match < best_match || (match == best_match && len > best_len))
		{
		  /* Best exact match:  leftmost, then longest.  */
		  best_match = match;
		  best_len = len;
		}
	    } /* if re_search >= 0 */
	} /* for Regex patterns.  */
	if (best_match < end)
	  {
	    /* We have found an exact match.  We were just
	       waiting for the best one (leftmost then longest).  */
	    beg = best_match;
	    len = best_len;
	    goto success_in_len;
	  }
    } /* for (beg = end ..) */

 failure:
  ret_val = -1;
  goto out;

 success:
  len = end - beg;
 success_in_len:
  *match_size = len;
  ret_val = beg - buf;
 out:
  return ret_val;
}

Testing negative cases!
Testing 0 (with abstract condition) ENVIS_NEG
Iteration 0
Running test command:
/home/ubuntu/spr-fast/tools/grep-test.py /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-8a025cf8-8f08d8e2/tempworkdir-l/src /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-8a025cf8-8f08d8e2/tempworkdir-l/tests /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-8a025cf8-8f08d8e2/tempworkdir-l 0  > __res
Opening:/tmp/neg.tmp!
NegativeBRANCH RECORD/tmp/neg.tmp!
APPENDING TO ISNEG:/tmp/neg.tmp!
Branch 0: 0
Iteration 1
Running test command:
/home/ubuntu/spr-fast/tools/grep-test.py /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-8a025cf8-8f08d8e2/tempworkdir-l/src /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-8a025cf8-8f08d8e2/tempworkdir-l/tests /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-8a025cf8-8f08d8e2/tempworkdir-l 0  > __res
Opening:/tmp/neg.tmp!
NegativeBRANCH RECORD/tmp/neg.tmp!
APPENDING TO ISNEG:/tmp/neg.tmp!
Branch 0: 1
Running test command:
/home/ubuntu/spr-fast/tools/grep-test.py /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-8a025cf8-8f08d8e2/tempworkdir-l/src /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-8a025cf8-8f08d8e2/tempworkdir-l/tests /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-8a025cf8-8f08d8e2/tempworkdir-l 0  > __res
CondTester, Testing instance id 93:
//src_file:src/dfasearch.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); void* memset(void*, int, unsigned long); 
/* dfasearch.c - searching subroutines using dfa and regex for grep.
   Copyright 1992, 1998, 2000, 2007, 2009-2010 Free Software Foundation, Inc.

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 3, or (at your option)
   any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program; if not, write to the Free Software
   Foundation, Inc., 51 Franklin Street - Fifth Floor, Boston, MA
   02110-1301, USA.  */

/* Written August 1992 by Mike Haertel. */

#include <config.h>
#include "search.h"
#include "dfa.h"

/* For -w, we also consider _ to be word constituent.  */
#define WCHAR(C) (ISALNUM(C) || (C) == '_')

/* KWset compiled pattern.  For Ecompile and Gcompile, we compile
   a list of strings, at least one of which is known to occur in
   any string matching the regexp. */
static kwset_t kwset;

/* DFA compiled regexp. */
static struct dfa dfa;

/* The Regex compiled patterns.  */
static struct patterns
{
  /* Regex compiled regexp. */
  struct re_pattern_buffer regexbuf;
  struct re_registers regs; /* This is here on account of a BRAIN-DEAD
			       Q@#%!# library interface in regex.c.  */
} patterns0;

struct patterns *patterns;
size_t pcount;

void
dfaerror (char const *mesg)
{
  error (EXIT_TROUBLE, 0, "%s", mesg);

  /* notreached */
  /* Tell static analyzers that this function does not return.  */
  abort ();
}

/* Number of compiled fixed strings known to exactly match the regexp.
   If kwsexec returns < kwset_exact_matches, then we don't need to
   call the regexp matcher at all. */
static int kwset_exact_matches;

static char const *
kwsincr_case (const char *must)
{
  const char *buf;
  size_t n;

  n = strlen (must);
#ifdef MBS_SUPPORT
  if (match_icase && MB_CUR_MAX > 1)
    buf = mbtolower (must, &n);
  else
#endif
    buf = must;
  return kwsincr (kwset, buf, n);
}

/* If the DFA turns out to have some set of fixed strings one of
   which must occur in the match, then we build a kwset matcher
   to find those strings, and thus quickly filter out impossible
   matches. */
static void
kwsmusts (void)
{
  struct dfamust const *dm;
  char const *err;

  if (dfa.musts)
    {
      kwsinit (&kwset);
      /* First, we compile in the substrings known to be exact
	 matches.  The kwset matcher will return the index
	 of the matching string that it chooses. */
      for (dm = dfa.musts; dm; dm = dm->next)
	{
	  if (!dm->exact)
	    continue;
	  ++kwset_exact_matches;
	  if ((err = kwsincr_case (dm->must)) != NULL)
	    error (EXIT_TROUBLE, 0, "%s", err);
	}
      /* Now, we compile the substrings that will require
	 the use of the regexp matcher.  */
      for (dm = dfa.musts; dm; dm = dm->next)
	{
	  if (dm->exact)
	    continue;
	  if ((err = kwsincr_case (dm->must)) != NULL)
	    error (EXIT_TROUBLE, 0, "%s", err);
	}
      if ((err = kwsprep (kwset)) != NULL)
	error (EXIT_TROUBLE, 0, "%s", err);
    }
}

void
GEAcompile (char const *pattern, size_t size, reg_syntax_t syntax_bits)
{
  const char *err;
  const char *p, *sep;
  size_t total = size;
  char *motif;

  if (match_icase)
    syntax_bits |= RE_ICASE;
  re_set_syntax (syntax_bits);
  dfasyntax (syntax_bits, match_icase, eolbyte);

  /* For GNU regex compiler we have to pass the patterns separately to detect
     errors like "[\nallo\n]\n".  The patterns here are "[", "allo" and "]"
     GNU regex should have raise a syntax error.  The same for backref, where
     the backref should have been local to each pattern.  */
  p = pattern;
  do
    {
      size_t len;
      sep = memchr (p, '\n', total);
      if (sep)
	{
	  len = sep - p;
	  sep++;
	  total -= (len + 1);
	}
      else
	{
	  len = total;
	  total = 0;
	}

      patterns = realloc (patterns, (pcount + 1) * sizeof (*patterns));
      if (patterns == NULL)
	error (EXIT_TROUBLE, errno, _("memory exhausted"));
      patterns[pcount] = patterns0;

      if ((err = re_compile_pattern (p, len,
				    &(patterns[pcount].regexbuf))) != NULL)
	error (EXIT_TROUBLE, 0, "%s", err);
      pcount++;

      p = sep;
    } while (sep && total != 0);

  /* In the match_words and match_lines cases, we use a different pattern
     for the DFA matcher that will quickly throw out cases that won't work.
     Then if DFA succeeds we do some hairy stuff using the regex matcher
     to decide whether the match should really count. */
  if (match_words || match_lines)
    {
      static char const line_beg_no_bk[] = "^(";
      static char const line_end_no_bk[] = ")$";
      static char const word_beg_no_bk[] = "(^|[^[:alnum:]_])(";
      static char const word_end_no_bk[] = ")([^[:alnum:]_]|$)";
      static char const line_beg_bk[] = "^\\(";
      static char const line_end_bk[] = "\\)$";
      static char const word_beg_bk[] = "\\(^\\|[^[:alnum:]_]\\)\\(";
      static char const word_end_bk[] = "\\)\\([^[:alnum:]_]\\|$\\)";
      int bk = !(syntax_bits & RE_NO_BK_PARENS);
      char *n = xmalloc (sizeof word_beg_bk - 1 + size + sizeof word_end_bk);

      strcpy (n, match_lines ? (bk ? line_beg_bk : line_beg_no_bk)
			     : (bk ? word_beg_bk : word_beg_no_bk));
      total = strlen(n);
      memcpy (n + total, pattern, size);
      total += size;
      strcpy (n + total, match_lines ? (bk ? line_end_bk : line_end_no_bk)
				     : (bk ? word_end_bk : word_end_no_bk));
      total += strlen (n + total);
      pattern = motif = n;
      size = total;
    }
  else
    motif = NULL;

  dfacomp (pattern, size, &dfa, 1);
  kwsmusts ();

  free(motif);
}

size_t
EGexecute (char const *buf, size_t size, size_t *match_size,
	   char const *start_ptr)
{
  char const *buflim, *beg, *end, *match, *best_match, *mb_start;
  char eol = eolbyte;
  int backref, start, len, best_len;
  struct kwsmatch kwsm;
  size_t i, ret_val;
#ifdef MBS_SUPPORT
  if (MB_CUR_MAX > 1)
    {
      if (match_icase)
        {
          /* mbtolower adds a NUL byte at the end.  That will provide
	     space for the sentinel byte dfaexec may add.  */
          char *case_buf = mbtolower (buf, &size);
	  if (start_ptr)
	    start_ptr = case_buf + (start_ptr - buf);
          buf = case_buf;
        }
    }
#endif /* MBS_SUPPORT */

  mb_start = buf;
  buflim = buf + size;

  for (beg = end = buf; end < buflim; beg = end)
    {
      if (!start_ptr)
	{
	  /* We don't care about an exact match.  */
	  if (kwset)
	    {
	      /* Find a possible match using the KWset matcher. */
	      size_t offset = kwsexec (kwset, beg, buflim - beg, &kwsm);
	      if (offset == (size_t) -1)
		goto failure;
	      beg += offset;
	      /* Narrow down to the line containing the candidate, and
		 run it through DFA. */
	      if ((end = memchr(beg, eol, buflim - beg)) != NULL)
	        end++;
              else
                end = buflim;
	      match = beg;
	      while (beg > buf && beg[-1] != eol)
		--beg;
	      if (kwsm.index < kwset_exact_matches)
                {
#ifdef MBS_SUPPORT
                  if (mb_start < beg)
                    mb_start = beg;
                  if (MB_CUR_MAX == 1 || !is_mb_middle (&mb_start, match, buflim))
#endif
                    goto success;
                }
	      if (dfaexec (&dfa, beg, (char *) end, 0, NULL, &backref) == NULL)
		continue;
	    }
	  else
	    {
	      /* No good fixed strings; start with DFA. */
	      char const *next_beg = dfaexec (&dfa, beg, (char *) buflim,
					      0, NULL, &backref);
	      if (next_beg == NULL)
		break;
	      /* Narrow down to the line we've found. */
	      beg = next_beg;
	      if ((end = memchr(beg, eol, buflim - beg)) != NULL)
	        end++;
              else
                end = buflim;
	      while (beg > buf && beg[-1] != eol)
		--beg;
	    }
	  /* Successful, no backreferences encountered! */
	  if (!backref)
	    goto success;
	}
      else
	{
	  /* We are looking for the leftmost (then longest) exact match.
	     We will go through the outer loop only once.  */
	  beg = start_ptr;
	  end = buflim;
	}

      /* If we've made it to this point, this means DFA has seen
	 a probable match, and we need to run it through Regex. */
      best_match = end;
      best_len = 0;
      for (i = 0; i < pcount; i++)
	{
	  patterns[i].regexbuf.not_eol = 0;
	  if (0 <= (start = re_search (&(patterns[i].regexbuf),
				       buf, end - buf - 1,
				       beg - buf, end - beg - 1,
				       &(patterns[i].regs))))
	    {
	      len = patterns[i].regs.end[0] - start;
	      match = buf + start;
	      if (match > best_match)
		continue;
	      if (start_ptr && !match_words)
		goto assess_pattern_match;
	      if ((!match_lines && !match_words)
		  || (match_lines && len == end - beg - 1))
		{
		  match = beg;
		  len = end - beg;
		  goto assess_pattern_match;
		}
	      /* If -w, check if the match aligns with word boundaries.
		 We do this iteratively because:
		 (a) the line may contain more than one occurence of the
		 pattern, and
		 (b) Several alternatives in the pattern might be valid at a
		 given point, and we may need to consider a shorter one to
		 find a word boundary.  */
	      if (match_words)
		while (match <= best_match)
		  {
		    
//Patch 0:
if ((__is_neg(25, &(buf), sizeof (buf), &(match), sizeof (match), &(beg), sizeof (beg), &(end), sizeof (end), &(len), sizeof (len), &(best_match), sizeof (best_match), &(match_words), sizeof (match_words), &(i), sizeof (i), &(patterns), sizeof (patterns), &(match_lines), sizeof (match_lines), &(start_ptr), sizeof (start_ptr), &(start), sizeof (start), &(pcount), sizeof (pcount), &(best_len), sizeof (best_len), &(buflim), sizeof (buflim), &(backref), sizeof (backref), &(eol), sizeof (eol), &(ret_val), sizeof (ret_val), &(match_size), sizeof (match_size), &(mb_start), sizeof (mb_start), &(kwset_exact_matches), sizeof (kwset_exact_matches), &(kwset), sizeof (kwset), &(size), sizeof (size), &(match_icase), sizeof (match_icase), &(eolbyte), sizeof (eolbyte))))
    goto failure;
if ((match == buf || !((1 && ((*__ctype_b_loc())[(int)(((unsigned char)match[-1]))] & (unsigned short)_ISalnum)) || ((unsigned char)match[-1]) == '_')) && (len == end - beg - 1 || !((1 && ((*__ctype_b_loc())[(int)(((unsigned char)match[len]))] & (unsigned short)_ISalnum)) || ((unsigned char)match[len]) == '_')))
    goto assess_pattern_match;

//CodeSeg 1:
		    if (len > 0)
		      {
			/* Try a shorter length anchored at the same place. */
			--len;
			patterns[i].regexbuf.not_eol = 1;
			len = re_match (&(patterns[i].regexbuf),
					buf, match + len - beg, match - buf,
					&(patterns[i].regs));
		      }
		    if (len <= 0)
		      {
			/* Try looking further on. */
			if (match == end - 1)
			  break;
			match++;
			patterns[i].regexbuf.not_eol = 0;
			start = re_search (&(patterns[i].regexbuf),
					   buf, end - buf - 1,
					   match - buf, end - match - 1,
					   &(patterns[i].regs));
			if (start < 0)
			  break;
			len = patterns[i].regs.end[0] - start;
			match = buf + start;
		      }
		  } /* while (match <= best_match) */
	      continue;
	    assess_pattern_match:
	      if (!start_ptr)
		{
		  /* Good enough for a non-exact match.
		     No need to look at further patterns, if any.  */
		  beg = match;
		  goto success_in_len;
		}
	      if (match < best_match || (match == best_match && len > best_len))
		{
		  /* Best exact match:  leftmost, then longest.  */
		  best_match = match;
		  best_len = len;
		}
	    } /* if re_search >= 0 */
	} /* for Regex patterns.  */
	if (best_match < end)
	  {
	    /* We have found an exact match.  We were just
	       waiting for the best one (leftmost then longest).  */
	    beg = best_match;
	    len = best_len;
	    goto success_in_len;
	  }
    } /* for (beg = end ..) */

 failure:
  ret_val = -1;
  goto out;

 success:
  len = end - beg;
 success_in_len:
  *match_size = len;
  ret_val = beg - buf;
 out:
  return ret_val;
}

Testing negative cases!
Testing 0 (with abstract condition) ENVIS_NEG
Iteration 0
Running test command:
/home/ubuntu/spr-fast/tools/grep-test.py /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-8a025cf8-8f08d8e2/tempworkdir-l/src /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-8a025cf8-8f08d8e2/tempworkdir-l/tests /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-8a025cf8-8f08d8e2/tempworkdir-l 0  > __res
Opening:/tmp/neg.tmp!
NegativeBRANCH RECORD/tmp/neg.tmp!
APPENDING TO ISNEG:/tmp/neg.tmp!
Branch 0: 0
Iteration 1
Running test command:
/home/ubuntu/spr-fast/tools/grep-test.py /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-8a025cf8-8f08d8e2/tempworkdir-l/src /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-8a025cf8-8f08d8e2/tempworkdir-l/tests /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-8a025cf8-8f08d8e2/tempworkdir-l 0  > __res
Opening:/tmp/neg.tmp!
NegativeBRANCH RECORD/tmp/neg.tmp!
APPENDING TO ISNEG:/tmp/neg.tmp!
Branch 0: 1
Running test command:
/home/ubuntu/spr-fast/tools/grep-test.py /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-8a025cf8-8f08d8e2/tempworkdir-l/src /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-8a025cf8-8f08d8e2/tempworkdir-l/tests /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-8a025cf8-8f08d8e2/tempworkdir-l 0  > __res
CondTester, Testing instance id 94:
//src_file:src/dfasearch.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); void* memset(void*, int, unsigned long); 
/* dfasearch.c - searching subroutines using dfa and regex for grep.
   Copyright 1992, 1998, 2000, 2007, 2009-2010 Free Software Foundation, Inc.

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 3, or (at your option)
   any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program; if not, write to the Free Software
   Foundation, Inc., 51 Franklin Street - Fifth Floor, Boston, MA
   02110-1301, USA.  */

/* Written August 1992 by Mike Haertel. */

#include <config.h>
#include "search.h"
#include "dfa.h"

/* For -w, we also consider _ to be word constituent.  */
#define WCHAR(C) (ISALNUM(C) || (C) == '_')

/* KWset compiled pattern.  For Ecompile and Gcompile, we compile
   a list of strings, at least one of which is known to occur in
   any string matching the regexp. */
static kwset_t kwset;

/* DFA compiled regexp. */
static struct dfa dfa;

/* The Regex compiled patterns.  */
static struct patterns
{
  /* Regex compiled regexp. */
  struct re_pattern_buffer regexbuf;
  struct re_registers regs; /* This is here on account of a BRAIN-DEAD
			       Q@#%!# library interface in regex.c.  */
} patterns0;

struct patterns *patterns;
size_t pcount;

void
dfaerror (char const *mesg)
{
  error (EXIT_TROUBLE, 0, "%s", mesg);

  /* notreached */
  /* Tell static analyzers that this function does not return.  */
  abort ();
}

/* Number of compiled fixed strings known to exactly match the regexp.
   If kwsexec returns < kwset_exact_matches, then we don't need to
   call the regexp matcher at all. */
static int kwset_exact_matches;

static char const *
kwsincr_case (const char *must)
{
  const char *buf;
  size_t n;

  n = strlen (must);
#ifdef MBS_SUPPORT
  if (match_icase && MB_CUR_MAX > 1)
    buf = mbtolower (must, &n);
  else
#endif
    buf = must;
  return kwsincr (kwset, buf, n);
}

/* If the DFA turns out to have some set of fixed strings one of
   which must occur in the match, then we build a kwset matcher
   to find those strings, and thus quickly filter out impossible
   matches. */
static void
kwsmusts (void)
{
  struct dfamust const *dm;
  char const *err;

  if (dfa.musts)
    {
      kwsinit (&kwset);
      /* First, we compile in the substrings known to be exact
	 matches.  The kwset matcher will return the index
	 of the matching string that it chooses. */
      for (dm = dfa.musts; dm; dm = dm->next)
	{
	  if (!dm->exact)
	    continue;
	  ++kwset_exact_matches;
	  if ((err = kwsincr_case (dm->must)) != NULL)
	    error (EXIT_TROUBLE, 0, "%s", err);
	}
      /* Now, we compile the substrings that will require
	 the use of the regexp matcher.  */
      for (dm = dfa.musts; dm; dm = dm->next)
	{
	  if (dm->exact)
	    continue;
	  if ((err = kwsincr_case (dm->must)) != NULL)
	    error (EXIT_TROUBLE, 0, "%s", err);
	}
      if ((err = kwsprep (kwset)) != NULL)
	error (EXIT_TROUBLE, 0, "%s", err);
    }
}

void
GEAcompile (char const *pattern, size_t size, reg_syntax_t syntax_bits)
{
  const char *err;
  const char *p, *sep;
  size_t total = size;
  char *motif;

  if (match_icase)
    syntax_bits |= RE_ICASE;
  re_set_syntax (syntax_bits);
  dfasyntax (syntax_bits, match_icase, eolbyte);

  /* For GNU regex compiler we have to pass the patterns separately to detect
     errors like "[\nallo\n]\n".  The patterns here are "[", "allo" and "]"
     GNU regex should have raise a syntax error.  The same for backref, where
     the backref should have been local to each pattern.  */
  p = pattern;
  do
    {
      size_t len;
      sep = memchr (p, '\n', total);
      if (sep)
	{
	  len = sep - p;
	  sep++;
	  total -= (len + 1);
	}
      else
	{
	  len = total;
	  total = 0;
	}

      patterns = realloc (patterns, (pcount + 1) * sizeof (*patterns));
      if (patterns == NULL)
	error (EXIT_TROUBLE, errno, _("memory exhausted"));
      patterns[pcount] = patterns0;

      if ((err = re_compile_pattern (p, len,
				    &(patterns[pcount].regexbuf))) != NULL)
	error (EXIT_TROUBLE, 0, "%s", err);
      pcount++;

      p = sep;
    } while (sep && total != 0);

  /* In the match_words and match_lines cases, we use a different pattern
     for the DFA matcher that will quickly throw out cases that won't work.
     Then if DFA succeeds we do some hairy stuff using the regex matcher
     to decide whether the match should really count. */
  if (match_words || match_lines)
    {
      static char const line_beg_no_bk[] = "^(";
      static char const line_end_no_bk[] = ")$";
      static char const word_beg_no_bk[] = "(^|[^[:alnum:]_])(";
      static char const word_end_no_bk[] = ")([^[:alnum:]_]|$)";
      static char const line_beg_bk[] = "^\\(";
      static char const line_end_bk[] = "\\)$";
      static char const word_beg_bk[] = "\\(^\\|[^[:alnum:]_]\\)\\(";
      static char const word_end_bk[] = "\\)\\([^[:alnum:]_]\\|$\\)";
      int bk = !(syntax_bits & RE_NO_BK_PARENS);
      char *n = xmalloc (sizeof word_beg_bk - 1 + size + sizeof word_end_bk);

      strcpy (n, match_lines ? (bk ? line_beg_bk : line_beg_no_bk)
			     : (bk ? word_beg_bk : word_beg_no_bk));
      total = strlen(n);
      memcpy (n + total, pattern, size);
      total += size;
      strcpy (n + total, match_lines ? (bk ? line_end_bk : line_end_no_bk)
				     : (bk ? word_end_bk : word_end_no_bk));
      total += strlen (n + total);
      pattern = motif = n;
      size = total;
    }
  else
    motif = NULL;

  dfacomp (pattern, size, &dfa, 1);
  kwsmusts ();

  free(motif);
}

size_t
EGexecute (char const *buf, size_t size, size_t *match_size,
	   char const *start_ptr)
{
  char const *buflim, *beg, *end, *match, *best_match, *mb_start;
  char eol = eolbyte;
  int backref, start, len, best_len;
  struct kwsmatch kwsm;
  size_t i, ret_val;
#ifdef MBS_SUPPORT
  if (MB_CUR_MAX > 1)
    {
      if (match_icase)
        {
          /* mbtolower adds a NUL byte at the end.  That will provide
	     space for the sentinel byte dfaexec may add.  */
          char *case_buf = mbtolower (buf, &size);
	  if (start_ptr)
	    start_ptr = case_buf + (start_ptr - buf);
          buf = case_buf;
        }
    }
#endif /* MBS_SUPPORT */

  mb_start = buf;
  buflim = buf + size;

  for (beg = end = buf; end < buflim; beg = end)
    {
      if (!start_ptr)
	{
	  /* We don't care about an exact match.  */
	  if (kwset)
	    {
	      /* Find a possible match using the KWset matcher. */
	      size_t offset = kwsexec (kwset, beg, buflim - beg, &kwsm);
	      if (offset == (size_t) -1)
		goto failure;
	      beg += offset;
	      /* Narrow down to the line containing the candidate, and
		 run it through DFA. */
	      if ((end = memchr(beg, eol, buflim - beg)) != NULL)
	        end++;
              else
                end = buflim;
	      match = beg;
	      while (beg > buf && beg[-1] != eol)
		--beg;
	      if (kwsm.index < kwset_exact_matches)
                {
#ifdef MBS_SUPPORT
                  if (mb_start < beg)
                    mb_start = beg;
                  if (MB_CUR_MAX == 1 || !is_mb_middle (&mb_start, match, buflim))
#endif
                    goto success;
                }
	      if (dfaexec (&dfa, beg, (char *) end, 0, NULL, &backref) == NULL)
		continue;
	    }
	  else
	    {
	      /* No good fixed strings; start with DFA. */
	      char const *next_beg = dfaexec (&dfa, beg, (char *) buflim,
					      0, NULL, &backref);
	      if (next_beg == NULL)
		break;
	      /* Narrow down to the line we've found. */
	      beg = next_beg;
	      if ((end = memchr(beg, eol, buflim - beg)) != NULL)
	        end++;
              else
                end = buflim;
	      while (beg > buf && beg[-1] != eol)
		--beg;
	    }
	  /* Successful, no backreferences encountered! */
	  if (!backref)
	    goto success;
	}
      else
	{
	  /* We are looking for the leftmost (then longest) exact match.
	     We will go through the outer loop only once.  */
	  beg = start_ptr;
	  end = buflim;
	}

      /* If we've made it to this point, this means DFA has seen
	 a probable match, and we need to run it through Regex. */
      best_match = end;
      best_len = 0;
      for (i = 0; i < pcount; i++)
	{
	  patterns[i].regexbuf.not_eol = 0;
	  if (0 <= (start = re_search (&(patterns[i].regexbuf),
				       buf, end - buf - 1,
				       beg - buf, end - beg - 1,
				       &(patterns[i].regs))))
	    {
	      len = patterns[i].regs.end[0] - start;
	      match = buf + start;
	      if (match > best_match)
		continue;
	      if (start_ptr && !match_words)
		goto assess_pattern_match;
	      if ((!match_lines && !match_words)
		  || (match_lines && len == end - beg - 1))
		{
		  match = beg;
		  len = end - beg;
		  goto assess_pattern_match;
		}
	      /* If -w, check if the match aligns with word boundaries.
		 We do this iteratively because:
		 (a) the line may contain more than one occurence of the
		 pattern, and
		 (b) Several alternatives in the pattern might be valid at a
		 given point, and we may need to consider a shorter one to
		 find a word boundary.  */
	      if (match_words)
		while (match <= best_match)
		  {
		    
//Patch 0:
if ((__is_neg(25, &(buf), sizeof (buf), &(match), sizeof (match), &(beg), sizeof (beg), &(end), sizeof (end), &(len), sizeof (len), &(best_match), sizeof (best_match), &(match_words), sizeof (match_words), &(i), sizeof (i), &(patterns), sizeof (patterns), &(match_lines), sizeof (match_lines), &(start_ptr), sizeof (start_ptr), &(start), sizeof (start), &(pcount), sizeof (pcount), &(best_len), sizeof (best_len), &(buflim), sizeof (buflim), &(backref), sizeof (backref), &(eol), sizeof (eol), &(ret_val), sizeof (ret_val), &(match_size), sizeof (match_size), &(mb_start), sizeof (mb_start), &(kwset_exact_matches), sizeof (kwset_exact_matches), &(kwset), sizeof (kwset), &(size), sizeof (size), &(match_icase), sizeof (match_icase), &(eolbyte), sizeof (eolbyte))))
    goto success;
if ((match == buf || !((1 && ((*__ctype_b_loc())[(int)(((unsigned char)match[-1]))] & (unsigned short)_ISalnum)) || ((unsigned char)match[-1]) == '_')) && (len == end - beg - 1 || !((1 && ((*__ctype_b_loc())[(int)(((unsigned char)match[len]))] & (unsigned short)_ISalnum)) || ((unsigned char)match[len]) == '_')))
    goto assess_pattern_match;

//CodeSeg 1:
		    if (len > 0)
		      {
			/* Try a shorter length anchored at the same place. */
			--len;
			patterns[i].regexbuf.not_eol = 1;
			len = re_match (&(patterns[i].regexbuf),
					buf, match + len - beg, match - buf,
					&(patterns[i].regs));
		      }
		    if (len <= 0)
		      {
			/* Try looking further on. */
			if (match == end - 1)
			  break;
			match++;
			patterns[i].regexbuf.not_eol = 0;
			start = re_search (&(patterns[i].regexbuf),
					   buf, end - buf - 1,
					   match - buf, end - match - 1,
					   &(patterns[i].regs));
			if (start < 0)
			  break;
			len = patterns[i].regs.end[0] - start;
			match = buf + start;
		      }
		  } /* while (match <= best_match) */
	      continue;
	    assess_pattern_match:
	      if (!start_ptr)
		{
		  /* Good enough for a non-exact match.
		     No need to look at further patterns, if any.  */
		  beg = match;
		  goto success_in_len;
		}
	      if (match < best_match || (match == best_match && len > best_len))
		{
		  /* Best exact match:  leftmost, then longest.  */
		  best_match = match;
		  best_len = len;
		}
	    } /* if re_search >= 0 */
	} /* for Regex patterns.  */
	if (best_match < end)
	  {
	    /* We have found an exact match.  We were just
	       waiting for the best one (leftmost then longest).  */
	    beg = best_match;
	    len = best_len;
	    goto success_in_len;
	  }
    } /* for (beg = end ..) */

 failure:
  ret_val = -1;
  goto out;

 success:
  len = end - beg;
 success_in_len:
  *match_size = len;
  ret_val = beg - buf;
 out:
  return ret_val;
}

Testing negative cases!
Testing 0 (with abstract condition) ENVIS_NEG
Iteration 0
Running test command:
/home/ubuntu/spr-fast/tools/grep-test.py /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-8a025cf8-8f08d8e2/tempworkdir-l/src /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-8a025cf8-8f08d8e2/tempworkdir-l/tests /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-8a025cf8-8f08d8e2/tempworkdir-l 0  > __res
Opening:/tmp/neg.tmp!
NegativeBRANCH RECORD/tmp/neg.tmp!
APPENDING TO ISNEG:/tmp/neg.tmp!
Branch 0: 0
Iteration 1
Running test command:
/home/ubuntu/spr-fast/tools/grep-test.py /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-8a025cf8-8f08d8e2/tempworkdir-l/src /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-8a025cf8-8f08d8e2/tempworkdir-l/tests /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-8a025cf8-8f08d8e2/tempworkdir-l 0  > __res
Opening:/tmp/neg.tmp!
NegativeBRANCH RECORD/tmp/neg.tmp!
APPENDING TO ISNEG:/tmp/neg.tmp!
Branch 0: 1
Passed in iteration!
Passed Negative Cases wiht CondTestder!
Testing positive cases!
Running test command:
/home/ubuntu/spr-fast/tools/grep-test.py /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-8a025cf8-8f08d8e2/tempworkdir-l/src /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-8a025cf8-8f08d8e2/tempworkdir-l/tests /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-8a025cf8-8f08d8e2/tempworkdir-l 11  > __res
Running test command:
/home/ubuntu/spr-fast/tools/grep-test.py /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-8a025cf8-8f08d8e2/tempworkdir-l/src /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-8a025cf8-8f08d8e2/tempworkdir-l/tests /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-8a025cf8-8f08d8e2/tempworkdir-l 14  > __res
Running test command:
/home/ubuntu/spr-fast/tools/grep-test.py /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-8a025cf8-8f08d8e2/tempworkdir-l/src /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-8a025cf8-8f08d8e2/tempworkdir-l/tests /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-8a025cf8-8f08d8e2/tempworkdir-l 17  > __res
Running test command:
/home/ubuntu/spr-fast/tools/grep-test.py /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-8a025cf8-8f08d8e2/tempworkdir-l/src /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-8a025cf8-8f08d8e2/tempworkdir-l/tests /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-8a025cf8-8f08d8e2/tempworkdir-l 22  > __res
Passed Positive Cases
Collect values for post processing!
WRITING TO ISNEG:/tmp/neg.tmp!
Running test command:
/home/ubuntu/spr-fast/tools/grep-test.py /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-8a025cf8-8f08d8e2/tempworkdir-l/src /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-8a025cf8-8f08d8e2/tempworkdir-l/tests /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-8a025cf8-8f08d8e2/tempworkdir-l 0  > __res
Running test command:
/home/ubuntu/spr-fast/tools/grep-test.py /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-8a025cf8-8f08d8e2/tempworkdir-l/src /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-8a025cf8-8f08d8e2/tempworkdir-l/tests /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-8a025cf8-8f08d8e2/tempworkdir-l 11  > __res
Running test command:
/home/ubuntu/spr-fast/tools/grep-test.py /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-8a025cf8-8f08d8e2/tempworkdir-l/src /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-8a025cf8-8f08d8e2/tempworkdir-l/tests /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-8a025cf8-8f08d8e2/tempworkdir-l 14  > __res
Running test command:
/home/ubuntu/spr-fast/tools/grep-test.py /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-8a025cf8-8f08d8e2/tempworkdir-l/src /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-8a025cf8-8f08d8e2/tempworkdir-l/tests /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-8a025cf8-8f08d8e2/tempworkdir-l 17  > __res
Running test command:
/home/ubuntu/spr-fast/tools/grep-test.py /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-8a025cf8-8f08d8e2/tempworkdir-l/src /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-8a025cf8-8f08d8e2/tempworkdir-l/tests /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-8a025cf8-8f08d8e2/tempworkdir-l 22  > __res
Passed!
CondTester, Testing instance id 95:
//src_file:src/dfasearch.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); void* memset(void*, int, unsigned long); 
/* dfasearch.c - searching subroutines using dfa and regex for grep.
   Copyright 1992, 1998, 2000, 2007, 2009-2010 Free Software Foundation, Inc.

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 3, or (at your option)
   any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program; if not, write to the Free Software
   Foundation, Inc., 51 Franklin Street - Fifth Floor, Boston, MA
   02110-1301, USA.  */

/* Written August 1992 by Mike Haertel. */

#include <config.h>
#include "search.h"
#include "dfa.h"

/* For -w, we also consider _ to be word constituent.  */
#define WCHAR(C) (ISALNUM(C) || (C) == '_')

/* KWset compiled pattern.  For Ecompile and Gcompile, we compile
   a list of strings, at least one of which is known to occur in
   any string matching the regexp. */
static kwset_t kwset;

/* DFA compiled regexp. */
static struct dfa dfa;

/* The Regex compiled patterns.  */
static struct patterns
{
  /* Regex compiled regexp. */
  struct re_pattern_buffer regexbuf;
  struct re_registers regs; /* This is here on account of a BRAIN-DEAD
			       Q@#%!# library interface in regex.c.  */
} patterns0;

struct patterns *patterns;
size_t pcount;

void
dfaerror (char const *mesg)
{
  error (EXIT_TROUBLE, 0, "%s", mesg);

  /* notreached */
  /* Tell static analyzers that this function does not return.  */
  abort ();
}

/* Number of compiled fixed strings known to exactly match the regexp.
   If kwsexec returns < kwset_exact_matches, then we don't need to
   call the regexp matcher at all. */
static int kwset_exact_matches;

static char const *
kwsincr_case (const char *must)
{
  const char *buf;
  size_t n;

  n = strlen (must);
#ifdef MBS_SUPPORT
  if (match_icase && MB_CUR_MAX > 1)
    buf = mbtolower (must, &n);
  else
#endif
    buf = must;
  return kwsincr (kwset, buf, n);
}

/* If the DFA turns out to have some set of fixed strings one of
   which must occur in the match, then we build a kwset matcher
   to find those strings, and thus quickly filter out impossible
   matches. */
static void
kwsmusts (void)
{
  struct dfamust const *dm;
  char const *err;

  if (dfa.musts)
    {
      kwsinit (&kwset);
      /* First, we compile in the substrings known to be exact
	 matches.  The kwset matcher will return the index
	 of the matching string that it chooses. */
      for (dm = dfa.musts; dm; dm = dm->next)
	{
	  if (!dm->exact)
	    continue;
	  ++kwset_exact_matches;
	  if ((err = kwsincr_case (dm->must)) != NULL)
	    error (EXIT_TROUBLE, 0, "%s", err);
	}
      /* Now, we compile the substrings that will require
	 the use of the regexp matcher.  */
      for (dm = dfa.musts; dm; dm = dm->next)
	{
	  if (dm->exact)
	    continue;
	  if ((err = kwsincr_case (dm->must)) != NULL)
	    error (EXIT_TROUBLE, 0, "%s", err);
	}
      if ((err = kwsprep (kwset)) != NULL)
	error (EXIT_TROUBLE, 0, "%s", err);
    }
}

void
GEAcompile (char const *pattern, size_t size, reg_syntax_t syntax_bits)
{
  const char *err;
  const char *p, *sep;
  size_t total = size;
  char *motif;

  if (match_icase)
    syntax_bits |= RE_ICASE;
  re_set_syntax (syntax_bits);
  dfasyntax (syntax_bits, match_icase, eolbyte);

  /* For GNU regex compiler we have to pass the patterns separately to detect
     errors like "[\nallo\n]\n".  The patterns here are "[", "allo" and "]"
     GNU regex should have raise a syntax error.  The same for backref, where
     the backref should have been local to each pattern.  */
  p = pattern;
  do
    {
      size_t len;
      sep = memchr (p, '\n', total);
      if (sep)
	{
	  len = sep - p;
	  sep++;
	  total -= (len + 1);
	}
      else
	{
	  len = total;
	  total = 0;
	}

      patterns = realloc (patterns, (pcount + 1) * sizeof (*patterns));
      if (patterns == NULL)
	error (EXIT_TROUBLE, errno, _("memory exhausted"));
      patterns[pcount] = patterns0;

      if ((err = re_compile_pattern (p, len,
				    &(patterns[pcount].regexbuf))) != NULL)
	error (EXIT_TROUBLE, 0, "%s", err);
      pcount++;

      p = sep;
    } while (sep && total != 0);

  /* In the match_words and match_lines cases, we use a different pattern
     for the DFA matcher that will quickly throw out cases that won't work.
     Then if DFA succeeds we do some hairy stuff using the regex matcher
     to decide whether the match should really count. */
  if (match_words || match_lines)
    {
      static char const line_beg_no_bk[] = "^(";
      static char const line_end_no_bk[] = ")$";
      static char const word_beg_no_bk[] = "(^|[^[:alnum:]_])(";
      static char const word_end_no_bk[] = ")([^[:alnum:]_]|$)";
      static char const line_beg_bk[] = "^\\(";
      static char const line_end_bk[] = "\\)$";
      static char const word_beg_bk[] = "\\(^\\|[^[:alnum:]_]\\)\\(";
      static char const word_end_bk[] = "\\)\\([^[:alnum:]_]\\|$\\)";
      int bk = !(syntax_bits & RE_NO_BK_PARENS);
      char *n = xmalloc (sizeof word_beg_bk - 1 + size + sizeof word_end_bk);

      strcpy (n, match_lines ? (bk ? line_beg_bk : line_beg_no_bk)
			     : (bk ? word_beg_bk : word_beg_no_bk));
      total = strlen(n);
      memcpy (n + total, pattern, size);
      total += size;
      strcpy (n + total, match_lines ? (bk ? line_end_bk : line_end_no_bk)
				     : (bk ? word_end_bk : word_end_no_bk));
      total += strlen (n + total);
      pattern = motif = n;
      size = total;
    }
  else
    motif = NULL;

  dfacomp (pattern, size, &dfa, 1);
  kwsmusts ();

  free(motif);
}

size_t
EGexecute (char const *buf, size_t size, size_t *match_size,
	   char const *start_ptr)
{
  char const *buflim, *beg, *end, *match, *best_match, *mb_start;
  char eol = eolbyte;
  int backref, start, len, best_len;
  struct kwsmatch kwsm;
  size_t i, ret_val;
#ifdef MBS_SUPPORT
  if (MB_CUR_MAX > 1)
    {
      if (match_icase)
        {
          /* mbtolower adds a NUL byte at the end.  That will provide
	     space for the sentinel byte dfaexec may add.  */
          char *case_buf = mbtolower (buf, &size);
	  if (start_ptr)
	    start_ptr = case_buf + (start_ptr - buf);
          buf = case_buf;
        }
    }
#endif /* MBS_SUPPORT */

  mb_start = buf;
  buflim = buf + size;

  for (beg = end = buf; end < buflim; beg = end)
    {
      if (!start_ptr)
	{
	  /* We don't care about an exact match.  */
	  if (kwset)
	    {
	      /* Find a possible match using the KWset matcher. */
	      size_t offset = kwsexec (kwset, beg, buflim - beg, &kwsm);
	      if (offset == (size_t) -1)
		goto failure;
	      beg += offset;
	      /* Narrow down to the line containing the candidate, and
		 run it through DFA. */
	      if ((end = memchr(beg, eol, buflim - beg)) != NULL)
	        end++;
              else
                end = buflim;
	      match = beg;
	      while (beg > buf && beg[-1] != eol)
		--beg;
	      if (kwsm.index < kwset_exact_matches)
                {
#ifdef MBS_SUPPORT
                  if (mb_start < beg)
                    mb_start = beg;
                  if (MB_CUR_MAX == 1 || !is_mb_middle (&mb_start, match, buflim))
#endif
                    goto success;
                }
	      if (dfaexec (&dfa, beg, (char *) end, 0, NULL, &backref) == NULL)
		continue;
	    }
	  else
	    {
	      /* No good fixed strings; start with DFA. */
	      char const *next_beg = dfaexec (&dfa, beg, (char *) buflim,
					      0, NULL, &backref);
	      if (next_beg == NULL)
		break;
	      /* Narrow down to the line we've found. */
	      beg = next_beg;
	      if ((end = memchr(beg, eol, buflim - beg)) != NULL)
	        end++;
              else
                end = buflim;
	      while (beg > buf && beg[-1] != eol)
		--beg;
	    }
	  /* Successful, no backreferences encountered! */
	  if (!backref)
	    goto success;
	}
      else
	{
	  /* We are looking for the leftmost (then longest) exact match.
	     We will go through the outer loop only once.  */
	  beg = start_ptr;
	  end = buflim;
	}

      /* If we've made it to this point, this means DFA has seen
	 a probable match, and we need to run it through Regex. */
      best_match = end;
      best_len = 0;
      for (i = 0; i < pcount; i++)
	{
	  patterns[i].regexbuf.not_eol = 0;
	  if (0 <= (start = re_search (&(patterns[i].regexbuf),
				       buf, end - buf - 1,
				       beg - buf, end - beg - 1,
				       &(patterns[i].regs))))
	    {
	      len = patterns[i].regs.end[0] - start;
	      match = buf + start;
	      if (match > best_match)
		continue;
	      if (start_ptr && !match_words)
		goto assess_pattern_match;
	      if ((!match_lines && !match_words)
		  || (match_lines && len == end - beg - 1))
		{
		  match = beg;
		  len = end - beg;
		  goto assess_pattern_match;
		}
	      /* If -w, check if the match aligns with word boundaries.
		 We do this iteratively because:
		 (a) the line may contain more than one occurence of the
		 pattern, and
		 (b) Several alternatives in the pattern might be valid at a
		 given point, and we may need to consider a shorter one to
		 find a word boundary.  */
	      if (match_words)
		while (match <= best_match)
		  {
		    
//Patch 0:
if ((__is_neg(25, &(buf), sizeof (buf), &(match), sizeof (match), &(beg), sizeof (beg), &(end), sizeof (end), &(len), sizeof (len), &(best_match), sizeof (best_match), &(match_words), sizeof (match_words), &(i), sizeof (i), &(patterns), sizeof (patterns), &(match_lines), sizeof (match_lines), &(start_ptr), sizeof (start_ptr), &(start), sizeof (start), &(pcount), sizeof (pcount), &(best_len), sizeof (best_len), &(buflim), sizeof (buflim), &(backref), sizeof (backref), &(eol), sizeof (eol), &(ret_val), sizeof (ret_val), &(match_size), sizeof (match_size), &(mb_start), sizeof (mb_start), &(kwset_exact_matches), sizeof (kwset_exact_matches), &(kwset), sizeof (kwset), &(size), sizeof (size), &(match_icase), sizeof (match_icase), &(eolbyte), sizeof (eolbyte))))
    goto success_in_len;
if ((match == buf || !((1 && ((*__ctype_b_loc())[(int)(((unsigned char)match[-1]))] & (unsigned short)_ISalnum)) || ((unsigned char)match[-1]) == '_')) && (len == end - beg - 1 || !((1 && ((*__ctype_b_loc())[(int)(((unsigned char)match[len]))] & (unsigned short)_ISalnum)) || ((unsigned char)match[len]) == '_')))
    goto assess_pattern_match;

//CodeSeg 1:
		    if (len > 0)
		      {
			/* Try a shorter length anchored at the same place. */
			--len;
			patterns[i].regexbuf.not_eol = 1;
			len = re_match (&(patterns[i].regexbuf),
					buf, match + len - beg, match - buf,
					&(patterns[i].regs));
		      }
		    if (len <= 0)
		      {
			/* Try looking further on. */
			if (match == end - 1)
			  break;
			match++;
			patterns[i].regexbuf.not_eol = 0;
			start = re_search (&(patterns[i].regexbuf),
					   buf, end - buf - 1,
					   match - buf, end - match - 1,
					   &(patterns[i].regs));
			if (start < 0)
			  break;
			len = patterns[i].regs.end[0] - start;
			match = buf + start;
		      }
		  } /* while (match <= best_match) */
	      continue;
	    assess_pattern_match:
	      if (!start_ptr)
		{
		  /* Good enough for a non-exact match.
		     No need to look at further patterns, if any.  */
		  beg = match;
		  goto success_in_len;
		}
	      if (match < best_match || (match == best_match && len > best_len))
		{
		  /* Best exact match:  leftmost, then longest.  */
		  best_match = match;
		  best_len = len;
		}
	    } /* if re_search >= 0 */
	} /* for Regex patterns.  */
	if (best_match < end)
	  {
	    /* We have found an exact match.  We were just
	       waiting for the best one (leftmost then longest).  */
	    beg = best_match;
	    len = best_len;
	    goto success_in_len;
	  }
    } /* for (beg = end ..) */

 failure:
  ret_val = -1;
  goto out;

 success:
  len = end - beg;
 success_in_len:
  *match_size = len;
  ret_val = beg - buf;
 out:
  return ret_val;
}

Testing negative cases!
Testing 0 (with abstract condition) ENVIS_NEG
Iteration 0
Running test command:
/home/ubuntu/spr-fast/tools/grep-test.py /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-8a025cf8-8f08d8e2/tempworkdir-l/src /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-8a025cf8-8f08d8e2/tempworkdir-l/tests /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-8a025cf8-8f08d8e2/tempworkdir-l 0  > __res
Opening:/tmp/neg.tmp!
NegativeBRANCH RECORD/tmp/neg.tmp!
APPENDING TO ISNEG:/tmp/neg.tmp!
Branch 0: 0
Iteration 1
Running test command:
/home/ubuntu/spr-fast/tools/grep-test.py /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-8a025cf8-8f08d8e2/tempworkdir-l/src /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-8a025cf8-8f08d8e2/tempworkdir-l/tests /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-8a025cf8-8f08d8e2/tempworkdir-l 0  > __res
Opening:/tmp/neg.tmp!
NegativeBRANCH RECORD/tmp/neg.tmp!
APPENDING TO ISNEG:/tmp/neg.tmp!
Branch 0: 1
Running test command:
/home/ubuntu/spr-fast/tools/grep-test.py /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-8a025cf8-8f08d8e2/tempworkdir-l/src /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-8a025cf8-8f08d8e2/tempworkdir-l/tests /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-8a025cf8-8f08d8e2/tempworkdir-l 0  > __res
CondTester, Testing instance id 96:
//src_file:src/dfasearch.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); void* memset(void*, int, unsigned long); 
/* dfasearch.c - searching subroutines using dfa and regex for grep.
   Copyright 1992, 1998, 2000, 2007, 2009-2010 Free Software Foundation, Inc.

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 3, or (at your option)
   any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program; if not, write to the Free Software
   Foundation, Inc., 51 Franklin Street - Fifth Floor, Boston, MA
   02110-1301, USA.  */

/* Written August 1992 by Mike Haertel. */

#include <config.h>
#include "search.h"
#include "dfa.h"

/* For -w, we also consider _ to be word constituent.  */
#define WCHAR(C) (ISALNUM(C) || (C) == '_')

/* KWset compiled pattern.  For Ecompile and Gcompile, we compile
   a list of strings, at least one of which is known to occur in
   any string matching the regexp. */
static kwset_t kwset;

/* DFA compiled regexp. */
static struct dfa dfa;

/* The Regex compiled patterns.  */
static struct patterns
{
  /* Regex compiled regexp. */
  struct re_pattern_buffer regexbuf;
  struct re_registers regs; /* This is here on account of a BRAIN-DEAD
			       Q@#%!# library interface in regex.c.  */
} patterns0;

struct patterns *patterns;
size_t pcount;

void
dfaerror (char const *mesg)
{
  error (EXIT_TROUBLE, 0, "%s", mesg);

  /* notreached */
  /* Tell static analyzers that this function does not return.  */
  abort ();
}

/* Number of compiled fixed strings known to exactly match the regexp.
   If kwsexec returns < kwset_exact_matches, then we don't need to
   call the regexp matcher at all. */
static int kwset_exact_matches;

static char const *
kwsincr_case (const char *must)
{
  const char *buf;
  size_t n;

  n = strlen (must);
#ifdef MBS_SUPPORT
  if (match_icase && MB_CUR_MAX > 1)
    buf = mbtolower (must, &n);
  else
#endif
    buf = must;
  return kwsincr (kwset, buf, n);
}

/* If the DFA turns out to have some set of fixed strings one of
   which must occur in the match, then we build a kwset matcher
   to find those strings, and thus quickly filter out impossible
   matches. */
static void
kwsmusts (void)
{
  struct dfamust const *dm;
  char const *err;

  if (dfa.musts)
    {
      kwsinit (&kwset);
      /* First, we compile in the substrings known to be exact
	 matches.  The kwset matcher will return the index
	 of the matching string that it chooses. */
      for (dm = dfa.musts; dm; dm = dm->next)
	{
	  if (!dm->exact)
	    continue;
	  ++kwset_exact_matches;
	  if ((err = kwsincr_case (dm->must)) != NULL)
	    error (EXIT_TROUBLE, 0, "%s", err);
	}
      /* Now, we compile the substrings that will require
	 the use of the regexp matcher.  */
      for (dm = dfa.musts; dm; dm = dm->next)
	{
	  if (dm->exact)
	    continue;
	  if ((err = kwsincr_case (dm->must)) != NULL)
	    error (EXIT_TROUBLE, 0, "%s", err);
	}
      if ((err = kwsprep (kwset)) != NULL)
	error (EXIT_TROUBLE, 0, "%s", err);
    }
}

void
GEAcompile (char const *pattern, size_t size, reg_syntax_t syntax_bits)
{
  const char *err;
  const char *p, *sep;
  size_t total = size;
  char *motif;

  if (match_icase)
    syntax_bits |= RE_ICASE;
  re_set_syntax (syntax_bits);
  dfasyntax (syntax_bits, match_icase, eolbyte);

  /* For GNU regex compiler we have to pass the patterns separately to detect
     errors like "[\nallo\n]\n".  The patterns here are "[", "allo" and "]"
     GNU regex should have raise a syntax error.  The same for backref, where
     the backref should have been local to each pattern.  */
  p = pattern;
  do
    {
      size_t len;
      sep = memchr (p, '\n', total);
      if (sep)
	{
	  len = sep - p;
	  sep++;
	  total -= (len + 1);
	}
      else
	{
	  len = total;
	  total = 0;
	}

      patterns = realloc (patterns, (pcount + 1) * sizeof (*patterns));
      if (patterns == NULL)
	error (EXIT_TROUBLE, errno, _("memory exhausted"));
      patterns[pcount] = patterns0;

      if ((err = re_compile_pattern (p, len,
				    &(patterns[pcount].regexbuf))) != NULL)
	error (EXIT_TROUBLE, 0, "%s", err);
      pcount++;

      p = sep;
    } while (sep && total != 0);

  /* In the match_words and match_lines cases, we use a different pattern
     for the DFA matcher that will quickly throw out cases that won't work.
     Then if DFA succeeds we do some hairy stuff using the regex matcher
     to decide whether the match should really count. */
  if (match_words || match_lines)
    {
      static char const line_beg_no_bk[] = "^(";
      static char const line_end_no_bk[] = ")$";
      static char const word_beg_no_bk[] = "(^|[^[:alnum:]_])(";
      static char const word_end_no_bk[] = ")([^[:alnum:]_]|$)";
      static char const line_beg_bk[] = "^\\(";
      static char const line_end_bk[] = "\\)$";
      static char const word_beg_bk[] = "\\(^\\|[^[:alnum:]_]\\)\\(";
      static char const word_end_bk[] = "\\)\\([^[:alnum:]_]\\|$\\)";
      int bk = !(syntax_bits & RE_NO_BK_PARENS);
      char *n = xmalloc (sizeof word_beg_bk - 1 + size + sizeof word_end_bk);

      strcpy (n, match_lines ? (bk ? line_beg_bk : line_beg_no_bk)
			     : (bk ? word_beg_bk : word_beg_no_bk));
      total = strlen(n);
      memcpy (n + total, pattern, size);
      total += size;
      strcpy (n + total, match_lines ? (bk ? line_end_bk : line_end_no_bk)
				     : (bk ? word_end_bk : word_end_no_bk));
      total += strlen (n + total);
      pattern = motif = n;
      size = total;
    }
  else
    motif = NULL;

  dfacomp (pattern, size, &dfa, 1);
  kwsmusts ();

  free(motif);
}

size_t
EGexecute (char const *buf, size_t size, size_t *match_size,
	   char const *start_ptr)
{
  char const *buflim, *beg, *end, *match, *best_match, *mb_start;
  char eol = eolbyte;
  int backref, start, len, best_len;
  struct kwsmatch kwsm;
  size_t i, ret_val;
#ifdef MBS_SUPPORT
  if (MB_CUR_MAX > 1)
    {
      if (match_icase)
        {
          /* mbtolower adds a NUL byte at the end.  That will provide
	     space for the sentinel byte dfaexec may add.  */
          char *case_buf = mbtolower (buf, &size);
	  if (start_ptr)
	    start_ptr = case_buf + (start_ptr - buf);
          buf = case_buf;
        }
    }
#endif /* MBS_SUPPORT */

  mb_start = buf;
  buflim = buf + size;

  for (beg = end = buf; end < buflim; beg = end)
    {
      if (!start_ptr)
	{
	  /* We don't care about an exact match.  */
	  if (kwset)
	    {
	      /* Find a possible match using the KWset matcher. */
	      size_t offset = kwsexec (kwset, beg, buflim - beg, &kwsm);
	      if (offset == (size_t) -1)
		goto failure;
	      beg += offset;
	      /* Narrow down to the line containing the candidate, and
		 run it through DFA. */
	      if ((end = memchr(beg, eol, buflim - beg)) != NULL)
	        end++;
              else
                end = buflim;
	      match = beg;
	      while (beg > buf && beg[-1] != eol)
		--beg;
	      if (kwsm.index < kwset_exact_matches)
                {
#ifdef MBS_SUPPORT
                  if (mb_start < beg)
                    mb_start = beg;
                  if (MB_CUR_MAX == 1 || !is_mb_middle (&mb_start, match, buflim))
#endif
                    goto success;
                }
	      if (dfaexec (&dfa, beg, (char *) end, 0, NULL, &backref) == NULL)
		continue;
	    }
	  else
	    {
	      /* No good fixed strings; start with DFA. */
	      char const *next_beg = dfaexec (&dfa, beg, (char *) buflim,
					      0, NULL, &backref);
	      if (next_beg == NULL)
		break;
	      /* Narrow down to the line we've found. */
	      beg = next_beg;
	      if ((end = memchr(beg, eol, buflim - beg)) != NULL)
	        end++;
              else
                end = buflim;
	      while (beg > buf && beg[-1] != eol)
		--beg;
	    }
	  /* Successful, no backreferences encountered! */
	  if (!backref)
	    goto success;
	}
      else
	{
	  /* We are looking for the leftmost (then longest) exact match.
	     We will go through the outer loop only once.  */
	  beg = start_ptr;
	  end = buflim;
	}

      /* If we've made it to this point, this means DFA has seen
	 a probable match, and we need to run it through Regex. */
      best_match = end;
      best_len = 0;
      for (i = 0; i < pcount; i++)
	{
	  patterns[i].regexbuf.not_eol = 0;
	  if (0 <= (start = re_search (&(patterns[i].regexbuf),
				       buf, end - buf - 1,
				       beg - buf, end - beg - 1,
				       &(patterns[i].regs))))
	    {
	      len = patterns[i].regs.end[0] - start;
	      match = buf + start;
	      if (match > best_match)
		continue;
	      if (start_ptr && !match_words)
		goto assess_pattern_match;
	      if ((!match_lines && !match_words)
		  || (match_lines && len == end - beg - 1))
		{
		  match = beg;
		  len = end - beg;
		  goto assess_pattern_match;
		}
	      /* If -w, check if the match aligns with word boundaries.
		 We do this iteratively because:
		 (a) the line may contain more than one occurence of the
		 pattern, and
		 (b) Several alternatives in the pattern might be valid at a
		 given point, and we may need to consider a shorter one to
		 find a word boundary.  */
	      if (match_words)
		while (match <= best_match)
		  {
		    
//Patch 0:
if ((__is_neg(25, &(buf), sizeof (buf), &(match), sizeof (match), &(beg), sizeof (beg), &(end), sizeof (end), &(len), sizeof (len), &(best_match), sizeof (best_match), &(match_words), sizeof (match_words), &(i), sizeof (i), &(patterns), sizeof (patterns), &(match_lines), sizeof (match_lines), &(start_ptr), sizeof (start_ptr), &(start), sizeof (start), &(pcount), sizeof (pcount), &(best_len), sizeof (best_len), &(buflim), sizeof (buflim), &(backref), sizeof (backref), &(eol), sizeof (eol), &(ret_val), sizeof (ret_val), &(match_size), sizeof (match_size), &(mb_start), sizeof (mb_start), &(kwset_exact_matches), sizeof (kwset_exact_matches), &(kwset), sizeof (kwset), &(size), sizeof (size), &(match_icase), sizeof (match_icase), &(eolbyte), sizeof (eolbyte))))
    goto out;
if ((match == buf || !((1 && ((*__ctype_b_loc())[(int)(((unsigned char)match[-1]))] & (unsigned short)_ISalnum)) || ((unsigned char)match[-1]) == '_')) && (len == end - beg - 1 || !((1 && ((*__ctype_b_loc())[(int)(((unsigned char)match[len]))] & (unsigned short)_ISalnum)) || ((unsigned char)match[len]) == '_')))
    goto assess_pattern_match;

//CodeSeg 1:
		    if (len > 0)
		      {
			/* Try a shorter length anchored at the same place. */
			--len;
			patterns[i].regexbuf.not_eol = 1;
			len = re_match (&(patterns[i].regexbuf),
					buf, match + len - beg, match - buf,
					&(patterns[i].regs));
		      }
		    if (len <= 0)
		      {
			/* Try looking further on. */
			if (match == end - 1)
			  break;
			match++;
			patterns[i].regexbuf.not_eol = 0;
			start = re_search (&(patterns[i].regexbuf),
					   buf, end - buf - 1,
					   match - buf, end - match - 1,
					   &(patterns[i].regs));
			if (start < 0)
			  break;
			len = patterns[i].regs.end[0] - start;
			match = buf + start;
		      }
		  } /* while (match <= best_match) */
	      continue;
	    assess_pattern_match:
	      if (!start_ptr)
		{
		  /* Good enough for a non-exact match.
		     No need to look at further patterns, if any.  */
		  beg = match;
		  goto success_in_len;
		}
	      if (match < best_match || (match == best_match && len > best_len))
		{
		  /* Best exact match:  leftmost, then longest.  */
		  best_match = match;
		  best_len = len;
		}
	    } /* if re_search >= 0 */
	} /* for Regex patterns.  */
	if (best_match < end)
	  {
	    /* We have found an exact match.  We were just
	       waiting for the best one (leftmost then longest).  */
	    beg = best_match;
	    len = best_len;
	    goto success_in_len;
	  }
    } /* for (beg = end ..) */

 failure:
  ret_val = -1;
  goto out;

 success:
  len = end - beg;
 success_in_len:
  *match_size = len;
  ret_val = beg - buf;
 out:
  return ret_val;
}

Testing negative cases!
Testing 0 (with abstract condition) ENVIS_NEG
Iteration 0
Running test command:
/home/ubuntu/spr-fast/tools/grep-test.py /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-8a025cf8-8f08d8e2/tempworkdir-l/src /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-8a025cf8-8f08d8e2/tempworkdir-l/tests /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-8a025cf8-8f08d8e2/tempworkdir-l 0  > __res
Opening:/tmp/neg.tmp!
NegativeBRANCH RECORD/tmp/neg.tmp!
APPENDING TO ISNEG:/tmp/neg.tmp!
Branch 0: 0
Iteration 1
Running test command:
/home/ubuntu/spr-fast/tools/grep-test.py /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-8a025cf8-8f08d8e2/tempworkdir-l/src /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-8a025cf8-8f08d8e2/tempworkdir-l/tests /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-8a025cf8-8f08d8e2/tempworkdir-l 0  > __res
Opening:/tmp/neg.tmp!
NegativeBRANCH RECORD/tmp/neg.tmp!
APPENDING TO ISNEG:/tmp/neg.tmp!
Branch 0: 1
Running test command:
/home/ubuntu/spr-fast/tools/grep-test.py /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-8a025cf8-8f08d8e2/tempworkdir-l/src /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-8a025cf8-8f08d8e2/tempworkdir-l/tests /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-8a025cf8-8f08d8e2/tempworkdir-l 0  > __res
CondTester, Testing instance id 101:
//src_file:src/dfasearch.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); void* memset(void*, int, unsigned long); 
/* dfasearch.c - searching subroutines using dfa and regex for grep.
   Copyright 1992, 1998, 2000, 2007, 2009-2010 Free Software Foundation, Inc.

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 3, or (at your option)
   any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program; if not, write to the Free Software
   Foundation, Inc., 51 Franklin Street - Fifth Floor, Boston, MA
   02110-1301, USA.  */

/* Written August 1992 by Mike Haertel. */

#include <config.h>
#include "search.h"
#include "dfa.h"

/* For -w, we also consider _ to be word constituent.  */
#define WCHAR(C) (ISALNUM(C) || (C) == '_')

/* KWset compiled pattern.  For Ecompile and Gcompile, we compile
   a list of strings, at least one of which is known to occur in
   any string matching the regexp. */
static kwset_t kwset;

/* DFA compiled regexp. */
static struct dfa dfa;

/* The Regex compiled patterns.  */
static struct patterns
{
  /* Regex compiled regexp. */
  struct re_pattern_buffer regexbuf;
  struct re_registers regs; /* This is here on account of a BRAIN-DEAD
			       Q@#%!# library interface in regex.c.  */
} patterns0;

struct patterns *patterns;
size_t pcount;

void
dfaerror (char const *mesg)
{
  error (EXIT_TROUBLE, 0, "%s", mesg);

  /* notreached */
  /* Tell static analyzers that this function does not return.  */
  abort ();
}

/* Number of compiled fixed strings known to exactly match the regexp.
   If kwsexec returns < kwset_exact_matches, then we don't need to
   call the regexp matcher at all. */
static int kwset_exact_matches;

static char const *
kwsincr_case (const char *must)
{
  const char *buf;
  size_t n;

  n = strlen (must);
#ifdef MBS_SUPPORT
  if (match_icase && MB_CUR_MAX > 1)
    buf = mbtolower (must, &n);
  else
#endif
    buf = must;
  return kwsincr (kwset, buf, n);
}

/* If the DFA turns out to have some set of fixed strings one of
   which must occur in the match, then we build a kwset matcher
   to find those strings, and thus quickly filter out impossible
   matches. */
static void
kwsmusts (void)
{
  struct dfamust const *dm;
  char const *err;

  if (dfa.musts)
    {
      kwsinit (&kwset);
      /* First, we compile in the substrings known to be exact
	 matches.  The kwset matcher will return the index
	 of the matching string that it chooses. */
      for (dm = dfa.musts; dm; dm = dm->next)
	{
	  if (!dm->exact)
	    continue;
	  ++kwset_exact_matches;
	  if ((err = kwsincr_case (dm->must)) != NULL)
	    error (EXIT_TROUBLE, 0, "%s", err);
	}
      /* Now, we compile the substrings that will require
	 the use of the regexp matcher.  */
      for (dm = dfa.musts; dm; dm = dm->next)
	{
	  if (dm->exact)
	    continue;
	  if ((err = kwsincr_case (dm->must)) != NULL)
	    error (EXIT_TROUBLE, 0, "%s", err);
	}
      if ((err = kwsprep (kwset)) != NULL)
	error (EXIT_TROUBLE, 0, "%s", err);
    }
}

void
GEAcompile (char const *pattern, size_t size, reg_syntax_t syntax_bits)
{
  const char *err;
  const char *p, *sep;
  size_t total = size;
  char *motif;

  if (match_icase)
    syntax_bits |= RE_ICASE;
  re_set_syntax (syntax_bits);
  dfasyntax (syntax_bits, match_icase, eolbyte);

  /* For GNU regex compiler we have to pass the patterns separately to detect
     errors like "[\nallo\n]\n".  The patterns here are "[", "allo" and "]"
     GNU regex should have raise a syntax error.  The same for backref, where
     the backref should have been local to each pattern.  */
  p = pattern;
  do
    {
      size_t len;
      sep = memchr (p, '\n', total);
      if (sep)
	{
	  len = sep - p;
	  sep++;
	  total -= (len + 1);
	}
      else
	{
	  len = total;
	  total = 0;
	}

      patterns = realloc (patterns, (pcount + 1) * sizeof (*patterns));
      if (patterns == NULL)
	error (EXIT_TROUBLE, errno, _("memory exhausted"));
      patterns[pcount] = patterns0;

      if ((err = re_compile_pattern (p, len,
				    &(patterns[pcount].regexbuf))) != NULL)
	error (EXIT_TROUBLE, 0, "%s", err);
      pcount++;

      p = sep;
    } while (sep && total != 0);

  /* In the match_words and match_lines cases, we use a different pattern
     for the DFA matcher that will quickly throw out cases that won't work.
     Then if DFA succeeds we do some hairy stuff using the regex matcher
     to decide whether the match should really count. */
  if (match_words || match_lines)
    {
      static char const line_beg_no_bk[] = "^(";
      static char const line_end_no_bk[] = ")$";
      static char const word_beg_no_bk[] = "(^|[^[:alnum:]_])(";
      static char const word_end_no_bk[] = ")([^[:alnum:]_]|$)";
      static char const line_beg_bk[] = "^\\(";
      static char const line_end_bk[] = "\\)$";
      static char const word_beg_bk[] = "\\(^\\|[^[:alnum:]_]\\)\\(";
      static char const word_end_bk[] = "\\)\\([^[:alnum:]_]\\|$\\)";
      int bk = !(syntax_bits & RE_NO_BK_PARENS);
      char *n = xmalloc (sizeof word_beg_bk - 1 + size + sizeof word_end_bk);

      strcpy (n, match_lines ? (bk ? line_beg_bk : line_beg_no_bk)
			     : (bk ? word_beg_bk : word_beg_no_bk));
      total = strlen(n);
      memcpy (n + total, pattern, size);
      total += size;
      strcpy (n + total, match_lines ? (bk ? line_end_bk : line_end_no_bk)
				     : (bk ? word_end_bk : word_end_no_bk));
      total += strlen (n + total);
      pattern = motif = n;
      size = total;
    }
  else
    motif = NULL;

  dfacomp (pattern, size, &dfa, 1);
  kwsmusts ();

  free(motif);
}

size_t
EGexecute (char const *buf, size_t size, size_t *match_size,
	   char const *start_ptr)
{
  char const *buflim, *beg, *end, *match, *best_match, *mb_start;
  char eol = eolbyte;
  int backref, start, len, best_len;
  struct kwsmatch kwsm;
  size_t i, ret_val;
#ifdef MBS_SUPPORT
  if (MB_CUR_MAX > 1)
    {
      if (match_icase)
        {
          /* mbtolower adds a NUL byte at the end.  That will provide
	     space for the sentinel byte dfaexec may add.  */
          char *case_buf = mbtolower (buf, &size);
	  if (start_ptr)
	    start_ptr = case_buf + (start_ptr - buf);
          buf = case_buf;
        }
    }
#endif /* MBS_SUPPORT */

  mb_start = buf;
  buflim = buf + size;

  for (beg = end = buf; end < buflim; beg = end)
    {
      if (!start_ptr)
	{
	  /* We don't care about an exact match.  */
	  if (kwset)
	    {
	      /* Find a possible match using the KWset matcher. */
	      size_t offset = kwsexec (kwset, beg, buflim - beg, &kwsm);
	      if (offset == (size_t) -1)
		goto failure;
	      beg += offset;
	      /* Narrow down to the line containing the candidate, and
		 run it through DFA. */
	      if ((end = memchr(beg, eol, buflim - beg)) != NULL)
	        end++;
              else
                end = buflim;
	      match = beg;
	      while (beg > buf && beg[-1] != eol)
		--beg;
	      if (kwsm.index < kwset_exact_matches)
                {
#ifdef MBS_SUPPORT
                  if (mb_start < beg)
                    mb_start = beg;
                  if (MB_CUR_MAX == 1 || !is_mb_middle (&mb_start, match, buflim))
#endif
                    goto success;
                }
	      if (dfaexec (&dfa, beg, (char *) end, 0, NULL, &backref) == NULL)
		continue;
	    }
	  else
	    {
	      /* No good fixed strings; start with DFA. */
	      char const *next_beg = dfaexec (&dfa, beg, (char *) buflim,
					      0, NULL, &backref);
	      if (next_beg == NULL)
		break;
	      /* Narrow down to the line we've found. */
	      beg = next_beg;
	      if ((end = memchr(beg, eol, buflim - beg)) != NULL)
	        end++;
              else
                end = buflim;
	      while (beg > buf && beg[-1] != eol)
		--beg;
	    }
	  /* Successful, no backreferences encountered! */
	  if (!backref)
	    goto success;
	}
      else
	{
	  /* We are looking for the leftmost (then longest) exact match.
	     We will go through the outer loop only once.  */
	  beg = start_ptr;
	  end = buflim;
	}

      /* If we've made it to this point, this means DFA has seen
	 a probable match, and we need to run it through Regex. */
      best_match = end;
      best_len = 0;
      for (i = 0; i < pcount; i++)
	{
	  patterns[i].regexbuf.not_eol = 0;
	  if (0 <= (start = re_search (&(patterns[i].regexbuf),
				       buf, end - buf - 1,
				       beg - buf, end - beg - 1,
				       &(patterns[i].regs))))
	    {
	      len = patterns[i].regs.end[0] - start;
	      match = buf + start;
	      if (match > best_match)
		continue;
	      if (start_ptr && !match_words)
		goto assess_pattern_match;
	      if ((!match_lines && !match_words)
		  || (match_lines && len == end - beg - 1))
		{
		  match = beg;
		  len = end - beg;
		  goto assess_pattern_match;
		}
	      /* If -w, check if the match aligns with word boundaries.
		 We do this iteratively because:
		 (a) the line may contain more than one occurence of the
		 pattern, and
		 (b) Several alternatives in the pattern might be valid at a
		 given point, and we may need to consider a shorter one to
		 find a word boundary.  */
	      if (match_words)
		while (match <= best_match)
		  {
		    
//Patch 0:
if ((__is_neg(25, &(buf), sizeof (buf), &(match), sizeof (match), &(beg), sizeof (beg), &(end), sizeof (end), &(len), sizeof (len), &(best_match), sizeof (best_match), &(match_words), sizeof (match_words), &(i), sizeof (i), &(patterns), sizeof (patterns), &(match_lines), sizeof (match_lines), &(start_ptr), sizeof (start_ptr), &(start), sizeof (start), &(pcount), sizeof (pcount), &(best_len), sizeof (best_len), &(buflim), sizeof (buflim), &(backref), sizeof (backref), &(eol), sizeof (eol), &(ret_val), sizeof (ret_val), &(match_size), sizeof (match_size), &(mb_start), sizeof (mb_start), &(kwset_exact_matches), sizeof (kwset_exact_matches), &(kwset), sizeof (kwset), &(size), sizeof (size), &(match_icase), sizeof (match_icase), &(eolbyte), sizeof (eolbyte))))
    return -1;
if ((match == buf || !((1 && ((*__ctype_b_loc())[(int)(((unsigned char)match[-1]))] & (unsigned short)_ISalnum)) || ((unsigned char)match[-1]) == '_')) && (len == end - beg - 1 || !((1 && ((*__ctype_b_loc())[(int)(((unsigned char)match[len]))] & (unsigned short)_ISalnum)) || ((unsigned char)match[len]) == '_')))
    goto assess_pattern_match;

//CodeSeg 1:
		    if (len > 0)
		      {
			/* Try a shorter length anchored at the same place. */
			--len;
			patterns[i].regexbuf.not_eol = 1;
			len = re_match (&(patterns[i].regexbuf),
					buf, match + len - beg, match - buf,
					&(patterns[i].regs));
		      }
		    if (len <= 0)
		      {
			/* Try looking further on. */
			if (match == end - 1)
			  break;
			match++;
			patterns[i].regexbuf.not_eol = 0;
			start = re_search (&(patterns[i].regexbuf),
					   buf, end - buf - 1,
					   match - buf, end - match - 1,
					   &(patterns[i].regs));
			if (start < 0)
			  break;
			len = patterns[i].regs.end[0] - start;
			match = buf + start;
		      }
		  } /* while (match <= best_match) */
	      continue;
	    assess_pattern_match:
	      if (!start_ptr)
		{
		  /* Good enough for a non-exact match.
		     No need to look at further patterns, if any.  */
		  beg = match;
		  goto success_in_len;
		}
	      if (match < best_match || (match == best_match && len > best_len))
		{
		  /* Best exact match:  leftmost, then longest.  */
		  best_match = match;
		  best_len = len;
		}
	    } /* if re_search >= 0 */
	} /* for Regex patterns.  */
	if (best_match < end)
	  {
	    /* We have found an exact match.  We were just
	       waiting for the best one (leftmost then longest).  */
	    beg = best_match;
	    len = best_len;
	    goto success_in_len;
	  }
    } /* for (beg = end ..) */

 failure:
  ret_val = -1;
  goto out;

 success:
  len = end - beg;
 success_in_len:
  *match_size = len;
  ret_val = beg - buf;
 out:
  return ret_val;
}

Testing negative cases!
Testing 0 (with abstract condition) ENVIS_NEG
Iteration 0
Running test command:
/home/ubuntu/spr-fast/tools/grep-test.py /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-8a025cf8-8f08d8e2/tempworkdir-l/src /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-8a025cf8-8f08d8e2/tempworkdir-l/tests /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-8a025cf8-8f08d8e2/tempworkdir-l 0  > __res
Opening:/tmp/neg.tmp!
NegativeBRANCH RECORD/tmp/neg.tmp!
APPENDING TO ISNEG:/tmp/neg.tmp!
Branch 0: 0
Iteration 1
Running test command:
/home/ubuntu/spr-fast/tools/grep-test.py /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-8a025cf8-8f08d8e2/tempworkdir-l/src /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-8a025cf8-8f08d8e2/tempworkdir-l/tests /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-8a025cf8-8f08d8e2/tempworkdir-l 0  > __res
Opening:/tmp/neg.tmp!
NegativeBRANCH RECORD/tmp/neg.tmp!
APPENDING TO ISNEG:/tmp/neg.tmp!
Branch 0: 1
Running test command:
/home/ubuntu/spr-fast/tools/grep-test.py /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-8a025cf8-8f08d8e2/tempworkdir-l/src /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-8a025cf8-8f08d8e2/tempworkdir-l/tests /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-8a025cf8-8f08d8e2/tempworkdir-l 0  > __res
CondTester, Testing instance id 102:
//src_file:src/dfasearch.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); void* memset(void*, int, unsigned long); 
/* dfasearch.c - searching subroutines using dfa and regex for grep.
   Copyright 1992, 1998, 2000, 2007, 2009-2010 Free Software Foundation, Inc.

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 3, or (at your option)
   any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program; if not, write to the Free Software
   Foundation, Inc., 51 Franklin Street - Fifth Floor, Boston, MA
   02110-1301, USA.  */

/* Written August 1992 by Mike Haertel. */

#include <config.h>
#include "search.h"
#include "dfa.h"

/* For -w, we also consider _ to be word constituent.  */
#define WCHAR(C) (ISALNUM(C) || (C) == '_')

/* KWset compiled pattern.  For Ecompile and Gcompile, we compile
   a list of strings, at least one of which is known to occur in
   any string matching the regexp. */
static kwset_t kwset;

/* DFA compiled regexp. */
static struct dfa dfa;

/* The Regex compiled patterns.  */
static struct patterns
{
  /* Regex compiled regexp. */
  struct re_pattern_buffer regexbuf;
  struct re_registers regs; /* This is here on account of a BRAIN-DEAD
			       Q@#%!# library interface in regex.c.  */
} patterns0;

struct patterns *patterns;
size_t pcount;

void
dfaerror (char const *mesg)
{
  error (EXIT_TROUBLE, 0, "%s", mesg);

  /* notreached */
  /* Tell static analyzers that this function does not return.  */
  abort ();
}

/* Number of compiled fixed strings known to exactly match the regexp.
   If kwsexec returns < kwset_exact_matches, then we don't need to
   call the regexp matcher at all. */
static int kwset_exact_matches;

static char const *
kwsincr_case (const char *must)
{
  const char *buf;
  size_t n;

  n = strlen (must);
#ifdef MBS_SUPPORT
  if (match_icase && MB_CUR_MAX > 1)
    buf = mbtolower (must, &n);
  else
#endif
    buf = must;
  return kwsincr (kwset, buf, n);
}

/* If the DFA turns out to have some set of fixed strings one of
   which must occur in the match, then we build a kwset matcher
   to find those strings, and thus quickly filter out impossible
   matches. */
static void
kwsmusts (void)
{
  struct dfamust const *dm;
  char const *err;

  if (dfa.musts)
    {
      kwsinit (&kwset);
      /* First, we compile in the substrings known to be exact
	 matches.  The kwset matcher will return the index
	 of the matching string that it chooses. */
      for (dm = dfa.musts; dm; dm = dm->next)
	{
	  if (!dm->exact)
	    continue;
	  ++kwset_exact_matches;
	  if ((err = kwsincr_case (dm->must)) != NULL)
	    error (EXIT_TROUBLE, 0, "%s", err);
	}
      /* Now, we compile the substrings that will require
	 the use of the regexp matcher.  */
      for (dm = dfa.musts; dm; dm = dm->next)
	{
	  if (dm->exact)
	    continue;
	  if ((err = kwsincr_case (dm->must)) != NULL)
	    error (EXIT_TROUBLE, 0, "%s", err);
	}
      if ((err = kwsprep (kwset)) != NULL)
	error (EXIT_TROUBLE, 0, "%s", err);
    }
}

void
GEAcompile (char const *pattern, size_t size, reg_syntax_t syntax_bits)
{
  const char *err;
  const char *p, *sep;
  size_t total = size;
  char *motif;

  if (match_icase)
    syntax_bits |= RE_ICASE;
  re_set_syntax (syntax_bits);
  dfasyntax (syntax_bits, match_icase, eolbyte);

  /* For GNU regex compiler we have to pass the patterns separately to detect
     errors like "[\nallo\n]\n".  The patterns here are "[", "allo" and "]"
     GNU regex should have raise a syntax error.  The same for backref, where
     the backref should have been local to each pattern.  */
  p = pattern;
  do
    {
      size_t len;
      sep = memchr (p, '\n', total);
      if (sep)
	{
	  len = sep - p;
	  sep++;
	  total -= (len + 1);
	}
      else
	{
	  len = total;
	  total = 0;
	}

      patterns = realloc (patterns, (pcount + 1) * sizeof (*patterns));
      if (patterns == NULL)
	error (EXIT_TROUBLE, errno, _("memory exhausted"));
      patterns[pcount] = patterns0;

      if ((err = re_compile_pattern (p, len,
				    &(patterns[pcount].regexbuf))) != NULL)
	error (EXIT_TROUBLE, 0, "%s", err);
      pcount++;

      p = sep;
    } while (sep && total != 0);

  /* In the match_words and match_lines cases, we use a different pattern
     for the DFA matcher that will quickly throw out cases that won't work.
     Then if DFA succeeds we do some hairy stuff using the regex matcher
     to decide whether the match should really count. */
  if (match_words || match_lines)
    {
      static char const line_beg_no_bk[] = "^(";
      static char const line_end_no_bk[] = ")$";
      static char const word_beg_no_bk[] = "(^|[^[:alnum:]_])(";
      static char const word_end_no_bk[] = ")([^[:alnum:]_]|$)";
      static char const line_beg_bk[] = "^\\(";
      static char const line_end_bk[] = "\\)$";
      static char const word_beg_bk[] = "\\(^\\|[^[:alnum:]_]\\)\\(";
      static char const word_end_bk[] = "\\)\\([^[:alnum:]_]\\|$\\)";
      int bk = !(syntax_bits & RE_NO_BK_PARENS);
      char *n = xmalloc (sizeof word_beg_bk - 1 + size + sizeof word_end_bk);

      strcpy (n, match_lines ? (bk ? line_beg_bk : line_beg_no_bk)
			     : (bk ? word_beg_bk : word_beg_no_bk));
      total = strlen(n);
      memcpy (n + total, pattern, size);
      total += size;
      strcpy (n + total, match_lines ? (bk ? line_end_bk : line_end_no_bk)
				     : (bk ? word_end_bk : word_end_no_bk));
      total += strlen (n + total);
      pattern = motif = n;
      size = total;
    }
  else
    motif = NULL;

  dfacomp (pattern, size, &dfa, 1);
  kwsmusts ();

  free(motif);
}

size_t
EGexecute (char const *buf, size_t size, size_t *match_size,
	   char const *start_ptr)
{
  char const *buflim, *beg, *end, *match, *best_match, *mb_start;
  char eol = eolbyte;
  int backref, start, len, best_len;
  struct kwsmatch kwsm;
  size_t i, ret_val;
#ifdef MBS_SUPPORT
  if (MB_CUR_MAX > 1)
    {
      if (match_icase)
        {
          /* mbtolower adds a NUL byte at the end.  That will provide
	     space for the sentinel byte dfaexec may add.  */
          char *case_buf = mbtolower (buf, &size);
	  if (start_ptr)
	    start_ptr = case_buf + (start_ptr - buf);
          buf = case_buf;
        }
    }
#endif /* MBS_SUPPORT */

  mb_start = buf;
  buflim = buf + size;

  for (beg = end = buf; end < buflim; beg = end)
    {
      if (!start_ptr)
	{
	  /* We don't care about an exact match.  */
	  if (kwset)
	    {
	      /* Find a possible match using the KWset matcher. */
	      size_t offset = kwsexec (kwset, beg, buflim - beg, &kwsm);
	      if (offset == (size_t) -1)
		goto failure;
	      beg += offset;
	      /* Narrow down to the line containing the candidate, and
		 run it through DFA. */
	      if ((end = memchr(beg, eol, buflim - beg)) != NULL)
	        end++;
              else
                end = buflim;
	      match = beg;
	      while (beg > buf && beg[-1] != eol)
		--beg;
	      if (kwsm.index < kwset_exact_matches)
                {
#ifdef MBS_SUPPORT
                  if (mb_start < beg)
                    mb_start = beg;
                  if (MB_CUR_MAX == 1 || !is_mb_middle (&mb_start, match, buflim))
#endif
                    goto success;
                }
	      if (dfaexec (&dfa, beg, (char *) end, 0, NULL, &backref) == NULL)
		continue;
	    }
	  else
	    {
	      /* No good fixed strings; start with DFA. */
	      char const *next_beg = dfaexec (&dfa, beg, (char *) buflim,
					      0, NULL, &backref);
	      if (next_beg == NULL)
		break;
	      /* Narrow down to the line we've found. */
	      beg = next_beg;
	      if ((end = memchr(beg, eol, buflim - beg)) != NULL)
	        end++;
              else
                end = buflim;
	      while (beg > buf && beg[-1] != eol)
		--beg;
	    }
	  /* Successful, no backreferences encountered! */
	  if (!backref)
	    goto success;
	}
      else
	{
	  /* We are looking for the leftmost (then longest) exact match.
	     We will go through the outer loop only once.  */
	  beg = start_ptr;
	  end = buflim;
	}

      /* If we've made it to this point, this means DFA has seen
	 a probable match, and we need to run it through Regex. */
      best_match = end;
      best_len = 0;
      for (i = 0; i < pcount; i++)
	{
	  patterns[i].regexbuf.not_eol = 0;
	  if (0 <= (start = re_search (&(patterns[i].regexbuf),
				       buf, end - buf - 1,
				       beg - buf, end - beg - 1,
				       &(patterns[i].regs))))
	    {
	      len = patterns[i].regs.end[0] - start;
	      match = buf + start;
	      if (match > best_match)
		continue;
	      if (start_ptr && !match_words)
		goto assess_pattern_match;
	      if ((!match_lines && !match_words)
		  || (match_lines && len == end - beg - 1))
		{
		  match = beg;
		  len = end - beg;
		  goto assess_pattern_match;
		}
	      /* If -w, check if the match aligns with word boundaries.
		 We do this iteratively because:
		 (a) the line may contain more than one occurence of the
		 pattern, and
		 (b) Several alternatives in the pattern might be valid at a
		 given point, and we may need to consider a shorter one to
		 find a word boundary.  */
	      if (match_words)
		while (match <= best_match)
		  {
		    
//Patch 0:
if ((__is_neg(25, &(buf), sizeof (buf), &(match), sizeof (match), &(beg), sizeof (beg), &(end), sizeof (end), &(len), sizeof (len), &(best_match), sizeof (best_match), &(match_words), sizeof (match_words), &(i), sizeof (i), &(patterns), sizeof (patterns), &(match_lines), sizeof (match_lines), &(start_ptr), sizeof (start_ptr), &(start), sizeof (start), &(pcount), sizeof (pcount), &(best_len), sizeof (best_len), &(buflim), sizeof (buflim), &(backref), sizeof (backref), &(eol), sizeof (eol), &(ret_val), sizeof (ret_val), &(match_size), sizeof (match_size), &(mb_start), sizeof (mb_start), &(kwset_exact_matches), sizeof (kwset_exact_matches), &(kwset), sizeof (kwset), &(size), sizeof (size), &(match_icase), sizeof (match_icase), &(eolbyte), sizeof (eolbyte))))
    return 0;
if ((match == buf || !((1 && ((*__ctype_b_loc())[(int)(((unsigned char)match[-1]))] & (unsigned short)_ISalnum)) || ((unsigned char)match[-1]) == '_')) && (len == end - beg - 1 || !((1 && ((*__ctype_b_loc())[(int)(((unsigned char)match[len]))] & (unsigned short)_ISalnum)) || ((unsigned char)match[len]) == '_')))
    goto assess_pattern_match;

//CodeSeg 1:
		    if (len > 0)
		      {
			/* Try a shorter length anchored at the same place. */
			--len;
			patterns[i].regexbuf.not_eol = 1;
			len = re_match (&(patterns[i].regexbuf),
					buf, match + len - beg, match - buf,
					&(patterns[i].regs));
		      }
		    if (len <= 0)
		      {
			/* Try looking further on. */
			if (match == end - 1)
			  break;
			match++;
			patterns[i].regexbuf.not_eol = 0;
			start = re_search (&(patterns[i].regexbuf),
					   buf, end - buf - 1,
					   match - buf, end - match - 1,
					   &(patterns[i].regs));
			if (start < 0)
			  break;
			len = patterns[i].regs.end[0] - start;
			match = buf + start;
		      }
		  } /* while (match <= best_match) */
	      continue;
	    assess_pattern_match:
	      if (!start_ptr)
		{
		  /* Good enough for a non-exact match.
		     No need to look at further patterns, if any.  */
		  beg = match;
		  goto success_in_len;
		}
	      if (match < best_match || (match == best_match && len > best_len))
		{
		  /* Best exact match:  leftmost, then longest.  */
		  best_match = match;
		  best_len = len;
		}
	    } /* if re_search >= 0 */
	} /* for Regex patterns.  */
	if (best_match < end)
	  {
	    /* We have found an exact match.  We were just
	       waiting for the best one (leftmost then longest).  */
	    beg = best_match;
	    len = best_len;
	    goto success_in_len;
	  }
    } /* for (beg = end ..) */

 failure:
  ret_val = -1;
  goto out;

 success:
  len = end - beg;
 success_in_len:
  *match_size = len;
  ret_val = beg - buf;
 out:
  return ret_val;
}

Testing negative cases!
Testing 0 (with abstract condition) ENVIS_NEG
Iteration 0
Running test command:
/home/ubuntu/spr-fast/tools/grep-test.py /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-8a025cf8-8f08d8e2/tempworkdir-l/src /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-8a025cf8-8f08d8e2/tempworkdir-l/tests /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-8a025cf8-8f08d8e2/tempworkdir-l 0  > __res
Opening:/tmp/neg.tmp!
NegativeBRANCH RECORD/tmp/neg.tmp!
APPENDING TO ISNEG:/tmp/neg.tmp!
Branch 0: 0
Iteration 1
Running test command:
/home/ubuntu/spr-fast/tools/grep-test.py /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-8a025cf8-8f08d8e2/tempworkdir-l/src /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-8a025cf8-8f08d8e2/tempworkdir-l/tests /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-8a025cf8-8f08d8e2/tempworkdir-l 0  > __res
Opening:/tmp/neg.tmp!
NegativeBRANCH RECORD/tmp/neg.tmp!
APPENDING TO ISNEG:/tmp/neg.tmp!
Branch 0: 1
Running test command:
/home/ubuntu/spr-fast/tools/grep-test.py /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-8a025cf8-8f08d8e2/tempworkdir-l/src /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-8a025cf8-8f08d8e2/tempworkdir-l/tests /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-8a025cf8-8f08d8e2/tempworkdir-l 0  > __res
CondTester, Postprocessing instance id 94:
//src_file:src/dfasearch.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); void* memset(void*, int, unsigned long); 
/* dfasearch.c - searching subroutines using dfa and regex for grep.
   Copyright 1992, 1998, 2000, 2007, 2009-2010 Free Software Foundation, Inc.

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 3, or (at your option)
   any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program; if not, write to the Free Software
   Foundation, Inc., 51 Franklin Street - Fifth Floor, Boston, MA
   02110-1301, USA.  */

/* Written August 1992 by Mike Haertel. */

#include <config.h>
#include "search.h"
#include "dfa.h"

/* For -w, we also consider _ to be word constituent.  */
#define WCHAR(C) (ISALNUM(C) || (C) == '_')

/* KWset compiled pattern.  For Ecompile and Gcompile, we compile
   a list of strings, at least one of which is known to occur in
   any string matching the regexp. */
static kwset_t kwset;

/* DFA compiled regexp. */
static struct dfa dfa;

/* The Regex compiled patterns.  */
static struct patterns
{
  /* Regex compiled regexp. */
  struct re_pattern_buffer regexbuf;
  struct re_registers regs; /* This is here on account of a BRAIN-DEAD
			       Q@#%!# library interface in regex.c.  */
} patterns0;

struct patterns *patterns;
size_t pcount;

void
dfaerror (char const *mesg)
{
  error (EXIT_TROUBLE, 0, "%s", mesg);

  /* notreached */
  /* Tell static analyzers that this function does not return.  */
  abort ();
}

/* Number of compiled fixed strings known to exactly match the regexp.
   If kwsexec returns < kwset_exact_matches, then we don't need to
   call the regexp matcher at all. */
static int kwset_exact_matches;

static char const *
kwsincr_case (const char *must)
{
  const char *buf;
  size_t n;

  n = strlen (must);
#ifdef MBS_SUPPORT
  if (match_icase && MB_CUR_MAX > 1)
    buf = mbtolower (must, &n);
  else
#endif
    buf = must;
  return kwsincr (kwset, buf, n);
}

/* If the DFA turns out to have some set of fixed strings one of
   which must occur in the match, then we build a kwset matcher
   to find those strings, and thus quickly filter out impossible
   matches. */
static void
kwsmusts (void)
{
  struct dfamust const *dm;
  char const *err;

  if (dfa.musts)
    {
      kwsinit (&kwset);
      /* First, we compile in the substrings known to be exact
	 matches.  The kwset matcher will return the index
	 of the matching string that it chooses. */
      for (dm = dfa.musts; dm; dm = dm->next)
	{
	  if (!dm->exact)
	    continue;
	  ++kwset_exact_matches;
	  if ((err = kwsincr_case (dm->must)) != NULL)
	    error (EXIT_TROUBLE, 0, "%s", err);
	}
      /* Now, we compile the substrings that will require
	 the use of the regexp matcher.  */
      for (dm = dfa.musts; dm; dm = dm->next)
	{
	  if (dm->exact)
	    continue;
	  if ((err = kwsincr_case (dm->must)) != NULL)
	    error (EXIT_TROUBLE, 0, "%s", err);
	}
      if ((err = kwsprep (kwset)) != NULL)
	error (EXIT_TROUBLE, 0, "%s", err);
    }
}

void
GEAcompile (char const *pattern, size_t size, reg_syntax_t syntax_bits)
{
  const char *err;
  const char *p, *sep;
  size_t total = size;
  char *motif;

  if (match_icase)
    syntax_bits |= RE_ICASE;
  re_set_syntax (syntax_bits);
  dfasyntax (syntax_bits, match_icase, eolbyte);

  /* For GNU regex compiler we have to pass the patterns separately to detect
     errors like "[\nallo\n]\n".  The patterns here are "[", "allo" and "]"
     GNU regex should have raise a syntax error.  The same for backref, where
     the backref should have been local to each pattern.  */
  p = pattern;
  do
    {
      size_t len;
      sep = memchr (p, '\n', total);
      if (sep)
	{
	  len = sep - p;
	  sep++;
	  total -= (len + 1);
	}
      else
	{
	  len = total;
	  total = 0;
	}

      patterns = realloc (patterns, (pcount + 1) * sizeof (*patterns));
      if (patterns == NULL)
	error (EXIT_TROUBLE, errno, _("memory exhausted"));
      patterns[pcount] = patterns0;

      if ((err = re_compile_pattern (p, len,
				    &(patterns[pcount].regexbuf))) != NULL)
	error (EXIT_TROUBLE, 0, "%s", err);
      pcount++;

      p = sep;
    } while (sep && total != 0);

  /* In the match_words and match_lines cases, we use a different pattern
     for the DFA matcher that will quickly throw out cases that won't work.
     Then if DFA succeeds we do some hairy stuff using the regex matcher
     to decide whether the match should really count. */
  if (match_words || match_lines)
    {
      static char const line_beg_no_bk[] = "^(";
      static char const line_end_no_bk[] = ")$";
      static char const word_beg_no_bk[] = "(^|[^[:alnum:]_])(";
      static char const word_end_no_bk[] = ")([^[:alnum:]_]|$)";
      static char const line_beg_bk[] = "^\\(";
      static char const line_end_bk[] = "\\)$";
      static char const word_beg_bk[] = "\\(^\\|[^[:alnum:]_]\\)\\(";
      static char const word_end_bk[] = "\\)\\([^[:alnum:]_]\\|$\\)";
      int bk = !(syntax_bits & RE_NO_BK_PARENS);
      char *n = xmalloc (sizeof word_beg_bk - 1 + size + sizeof word_end_bk);

      strcpy (n, match_lines ? (bk ? line_beg_bk : line_beg_no_bk)
			     : (bk ? word_beg_bk : word_beg_no_bk));
      total = strlen(n);
      memcpy (n + total, pattern, size);
      total += size;
      strcpy (n + total, match_lines ? (bk ? line_end_bk : line_end_no_bk)
				     : (bk ? word_end_bk : word_end_no_bk));
      total += strlen (n + total);
      pattern = motif = n;
      size = total;
    }
  else
    motif = NULL;

  dfacomp (pattern, size, &dfa, 1);
  kwsmusts ();

  free(motif);
}

size_t
EGexecute (char const *buf, size_t size, size_t *match_size,
	   char const *start_ptr)
{
  char const *buflim, *beg, *end, *match, *best_match, *mb_start;
  char eol = eolbyte;
  int backref, start, len, best_len;
  struct kwsmatch kwsm;
  size_t i, ret_val;
#ifdef MBS_SUPPORT
  if (MB_CUR_MAX > 1)
    {
      if (match_icase)
        {
          /* mbtolower adds a NUL byte at the end.  That will provide
	     space for the sentinel byte dfaexec may add.  */
          char *case_buf = mbtolower (buf, &size);
	  if (start_ptr)
	    start_ptr = case_buf + (start_ptr - buf);
          buf = case_buf;
        }
    }
#endif /* MBS_SUPPORT */

  mb_start = buf;
  buflim = buf + size;

  for (beg = end = buf; end < buflim; beg = end)
    {
      if (!start_ptr)
	{
	  /* We don't care about an exact match.  */
	  if (kwset)
	    {
	      /* Find a possible match using the KWset matcher. */
	      size_t offset = kwsexec (kwset, beg, buflim - beg, &kwsm);
	      if (offset == (size_t) -1)
		goto failure;
	      beg += offset;
	      /* Narrow down to the line containing the candidate, and
		 run it through DFA. */
	      if ((end = memchr(beg, eol, buflim - beg)) != NULL)
	        end++;
              else
                end = buflim;
	      match = beg;
	      while (beg > buf && beg[-1] != eol)
		--beg;
	      if (kwsm.index < kwset_exact_matches)
                {
#ifdef MBS_SUPPORT
                  if (mb_start < beg)
                    mb_start = beg;
                  if (MB_CUR_MAX == 1 || !is_mb_middle (&mb_start, match, buflim))
#endif
                    goto success;
                }
	      if (dfaexec (&dfa, beg, (char *) end, 0, NULL, &backref) == NULL)
		continue;
	    }
	  else
	    {
	      /* No good fixed strings; start with DFA. */
	      char const *next_beg = dfaexec (&dfa, beg, (char *) buflim,
					      0, NULL, &backref);
	      if (next_beg == NULL)
		break;
	      /* Narrow down to the line we've found. */
	      beg = next_beg;
	      if ((end = memchr(beg, eol, buflim - beg)) != NULL)
	        end++;
              else
                end = buflim;
	      while (beg > buf && beg[-1] != eol)
		--beg;
	    }
	  /* Successful, no backreferences encountered! */
	  if (!backref)
	    goto success;
	}
      else
	{
	  /* We are looking for the leftmost (then longest) exact match.
	     We will go through the outer loop only once.  */
	  beg = start_ptr;
	  end = buflim;
	}

      /* If we've made it to this point, this means DFA has seen
	 a probable match, and we need to run it through Regex. */
      best_match = end;
      best_len = 0;
      for (i = 0; i < pcount; i++)
	{
	  patterns[i].regexbuf.not_eol = 0;
	  if (0 <= (start = re_search (&(patterns[i].regexbuf),
				       buf, end - buf - 1,
				       beg - buf, end - beg - 1,
				       &(patterns[i].regs))))
	    {
	      len = patterns[i].regs.end[0] - start;
	      match = buf + start;
	      if (match > best_match)
		continue;
	      if (start_ptr && !match_words)
		goto assess_pattern_match;
	      if ((!match_lines && !match_words)
		  || (match_lines && len == end - beg - 1))
		{
		  match = beg;
		  len = end - beg;
		  goto assess_pattern_match;
		}
	      /* If -w, check if the match aligns with word boundaries.
		 We do this iteratively because:
		 (a) the line may contain more than one occurence of the
		 pattern, and
		 (b) Several alternatives in the pattern might be valid at a
		 given point, and we may need to consider a shorter one to
		 find a word boundary.  */
	      if (match_words)
		while (match <= best_match)
		  {
		    
//Patch 0:
if ((__is_neg(25, &(buf), sizeof (buf), &(match), sizeof (match), &(beg), sizeof (beg), &(end), sizeof (end), &(len), sizeof (len), &(best_match), sizeof (best_match), &(match_words), sizeof (match_words), &(i), sizeof (i), &(patterns), sizeof (patterns), &(match_lines), sizeof (match_lines), &(start_ptr), sizeof (start_ptr), &(start), sizeof (start), &(pcount), sizeof (pcount), &(best_len), sizeof (best_len), &(buflim), sizeof (buflim), &(backref), sizeof (backref), &(eol), sizeof (eol), &(ret_val), sizeof (ret_val), &(match_size), sizeof (match_size), &(mb_start), sizeof (mb_start), &(kwset_exact_matches), sizeof (kwset_exact_matches), &(kwset), sizeof (kwset), &(size), sizeof (size), &(match_icase), sizeof (match_icase), &(eolbyte), sizeof (eolbyte))))
    goto success;
if ((match == buf || !((1 && ((*__ctype_b_loc())[(int)(((unsigned char)match[-1]))] & (unsigned short)_ISalnum)) || ((unsigned char)match[-1]) == '_')) && (len == end - beg - 1 || !((1 && ((*__ctype_b_loc())[(int)(((unsigned char)match[len]))] & (unsigned short)_ISalnum)) || ((unsigned char)match[len]) == '_')))
    goto assess_pattern_match;

//CodeSeg 1:
		    if (len > 0)
		      {
			/* Try a shorter length anchored at the same place. */
			--len;
			patterns[i].regexbuf.not_eol = 1;
			len = re_match (&(patterns[i].regexbuf),
					buf, match + len - beg, match - buf,
					&(patterns[i].regs));
		      }
		    if (len <= 0)
		      {
			/* Try looking further on. */
			if (match == end - 1)
			  break;
			match++;
			patterns[i].regexbuf.not_eol = 0;
			start = re_search (&(patterns[i].regexbuf),
					   buf, end - buf - 1,
					   match - buf, end - match - 1,
					   &(patterns[i].regs));
			if (start < 0)
			  break;
			len = patterns[i].regs.end[0] - start;
			match = buf + start;
		      }
		  } /* while (match <= best_match) */
	      continue;
	    assess_pattern_match:
	      if (!start_ptr)
		{
		  /* Good enough for a non-exact match.
		     No need to look at further patterns, if any.  */
		  beg = match;
		  goto success_in_len;
		}
	      if (match < best_match || (match == best_match && len > best_len))
		{
		  /* Best exact match:  leftmost, then longest.  */
		  best_match = match;
		  best_len = len;
		}
	    } /* if re_search >= 0 */
	} /* for Regex patterns.  */
	if (best_match < end)
	  {
	    /* We have found an exact match.  We were just
	       waiting for the best one (leftmost then longest).  */
	    beg = best_match;
	    len = best_len;
	    goto success_in_len;
	  }
    } /* for (beg = end ..) */

 failure:
  ret_val = -1;
  goto out;

 success:
  len = end - beg;
 success_in_len:
  *match_size = len;
  ret_val = beg - buf;
 out:
  return ret_val;
}

Trying a synthesis expr 1
Building:src at:
/home/ubuntu/spr-fast/tests/corebench/grep/grep-case-8a025cf8-8f08d8e2/tempworkdir-l/srcVerifing Negative cases!
Running test command:
/home/ubuntu/spr-fast/tools/grep-test.py /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-8a025cf8-8f08d8e2/tempworkdir-l/src /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-8a025cf8-8f08d8e2/tempworkdir-l/tests /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-8a025cf8-8f08d8e2/tempworkdir-l 0  > __res
Verifying positive cases
Running test command:
/home/ubuntu/spr-fast/tools/grep-test.py /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-8a025cf8-8f08d8e2/tempworkdir-l/src /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-8a025cf8-8f08d8e2/tempworkdir-l/tests /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-8a025cf8-8f08d8e2/tempworkdir-l 11  > __res
Running test command:
/home/ubuntu/spr-fast/tools/grep-test.py /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-8a025cf8-8f08d8e2/tempworkdir-l/src /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-8a025cf8-8f08d8e2/tempworkdir-l/tests /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-8a025cf8-8f08d8e2/tempworkdir-l 14  > __res
Running test command:
/home/ubuntu/spr-fast/tools/grep-test.py /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-8a025cf8-8f08d8e2/tempworkdir-l/src /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-8a025cf8-8f08d8e2/tempworkdir-l/tests /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-8a025cf8-8f08d8e2/tempworkdir-l 17  > __res
Running test command:
/home/ubuntu/spr-fast/tools/grep-test.py /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-8a025cf8-8f08d8e2/tempworkdir-l/src /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-8a025cf8-8f08d8e2/tempworkdir-l/tests /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-8a025cf8-8f08d8e2/tempworkdir-l 22  > __res
Passed Positive Cases
Passed!
Passed with updated best score 8945906.000000
a batched test job starts!
Building merged code:
src_file: src/dfasearch.c
full src: int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); void* memset(void*, int, unsigned long); 
/* dfasearch.c - searching subroutines using dfa and regex for grep.
   Copyright 1992, 1998, 2000, 2007, 2009-2010 Free Software Foundation, Inc.

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 3, or (at your option)
   any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program; if not, write to the Free Software
   Foundation, Inc., 51 Franklin Street - Fifth Floor, Boston, MA
   02110-1301, USA.  */

/* Written August 1992 by Mike Haertel. */

#include <config.h>
#include "search.h"
#include "dfa.h"

/* For -w, we also consider _ to be word constituent.  */
#define WCHAR(C) (ISALNUM(C) || (C) == '_')

/* KWset compiled pattern.  For Ecompile and Gcompile, we compile
   a list of strings, at least one of which is known to occur in
   any string matching the regexp. */
static kwset_t kwset;

/* DFA compiled regexp. */
static struct dfa dfa;

/* The Regex compiled patterns.  */
static struct patterns
{
  /* Regex compiled regexp. */
  struct re_pattern_buffer regexbuf;
  struct re_registers regs; /* This is here on account of a BRAIN-DEAD
			       Q@#%!# library interface in regex.c.  */
} patterns0;

struct patterns *patterns;
size_t pcount;

void
dfaerror (char const *mesg)
{
  error (EXIT_TROUBLE, 0, "%s", mesg);

  /* notreached */
  /* Tell static analyzers that this function does not return.  */
  abort ();
}

/* Number of compiled fixed strings known to exactly match the regexp.
   If kwsexec returns < kwset_exact_matches, then we don't need to
   call the regexp matcher at all. */
static int kwset_exact_matches;

static char const *
kwsincr_case (const char *must)
{
  const char *buf;
  size_t n;

  //prophet generated patch
  if (__get_mutant()==0) {
  if ((__is_neg(5, &(must), sizeof (must), &(n), sizeof (n), &(match_icase), sizeof (match_icase), &(buf), sizeof (buf), &(kwset), sizeof (kwset))))
      return 0;
  n = strlen(must);
  }
#ifdef MBS_SUPPORT
  if (match_icase && MB_CUR_MAX > 1)
    buf = mbtolower (must, &n);
  else
#endif
    buf = must;
  return kwsincr (kwset, buf, n);
}

/* If the DFA turns out to have some set of fixed strings one of
   which must occur in the match, then we build a kwset matcher
   to find those strings, and thus quickly filter out impossible
   matches. */
static void
kwsmusts (void)
{
  struct dfamust const *dm;
  char const *err;

  if (dfa.musts)
    {
      kwsinit (&kwset);
      /* First, we compile in the substrings known to be exact
	 matches.  The kwset matcher will return the index
	 of the matching string that it chooses. */
      for (dm = dfa.musts; dm; dm = dm->next)
	{
	  if (!dm->exact)
	    continue;
	  ++kwset_exact_matches;
	  if ((err = kwsincr_case (dm->must)) != NULL)
	    error (EXIT_TROUBLE, 0, "%s", err);
	}
      /* Now, we compile the substrings that will require
	 the use of the regexp matcher.  */
      for (dm = dfa.musts; dm; dm = dm->next)
	{
	  if (dm->exact)
	    continue;
	  if ((err = kwsincr_case (dm->must)) != NULL)
	    error (EXIT_TROUBLE, 0, "%s", err);
	}
      if ((err = kwsprep (kwset)) != NULL)
	error (EXIT_TROUBLE, 0, "%s", err);
    }
}

void
GEAcompile (char const *pattern, size_t size, reg_syntax_t syntax_bits)
{
  const char *err;
  const char *p, *sep;
  size_t total = size;
  char *motif;

  if (match_icase)
    syntax_bits |= RE_ICASE;
  re_set_syntax (syntax_bits);
  dfasyntax (syntax_bits, match_icase, eolbyte);

  /* For GNU regex compiler we have to pass the patterns separately to detect
     errors like "[\nallo\n]\n".  The patterns here are "[", "allo" and "]"
     GNU regex should have raise a syntax error.  The same for backref, where
     the backref should have been local to each pattern.  */
  p = pattern;
  do
    {
      size_t len;
      sep = memchr (p, '\n', total);
      if (sep)
	{
	  len = sep - p;
	  sep++;
	  total -= (len + 1);
	}
      else
	{
	  len = total;
	  total = 0;
	}

      patterns = realloc (patterns, (pcount + 1) * sizeof (*patterns));
      if (patterns == NULL)
	error (EXIT_TROUBLE, errno, _("memory exhausted"));
      patterns[pcount] = patterns0;

      if ((err = re_compile_pattern (p, len,
				    &(patterns[pcount].regexbuf))) != NULL)
	error (EXIT_TROUBLE, 0, "%s", err);
      pcount++;

      p = sep;
    } while (sep && total != 0);

  /* In the match_words and match_lines cases, we use a different pattern
     for the DFA matcher that will quickly throw out cases that won't work.
     Then if DFA succeeds we do some hairy stuff using the regex matcher
     to decide whether the match should really count. */
  if (match_words || match_lines)
    {
      static char const line_beg_no_bk[] = "^(";
      static char const line_end_no_bk[] = ")$";
      static char const word_beg_no_bk[] = "(^|[^[:alnum:]_])(";
      static char const word_end_no_bk[] = ")([^[:alnum:]_]|$)";
      static char const line_beg_bk[] = "^\\(";
      static char const line_end_bk[] = "\\)$";
      static char const word_beg_bk[] = "\\(^\\|[^[:alnum:]_]\\)\\(";
      static char const word_end_bk[] = "\\)\\([^[:alnum:]_]\\|$\\)";
      int bk = !(syntax_bits & RE_NO_BK_PARENS);
      char *n = xmalloc (sizeof word_beg_bk - 1 + size + sizeof word_end_bk);

      strcpy (n, match_lines ? (bk ? line_beg_bk : line_beg_no_bk)
			     : (bk ? word_beg_bk : word_beg_no_bk));
      total = strlen(n);
      memcpy (n + total, pattern, size);
      total += size;
      strcpy (n + total, match_lines ? (bk ? line_end_bk : line_end_no_bk)
				     : (bk ? word_end_bk : word_end_no_bk));
      total += strlen (n + total);
      pattern = motif = n;
      size = total;
    }
  else
    motif = NULL;

  dfacomp (pattern, size, &dfa, 1);
  kwsmusts ();

  free(motif);
}

size_t
EGexecute (char const *buf, size_t size, size_t *match_size,
	   char const *start_ptr)
{
  char const *buflim, *beg, *end, *match, *best_match, *mb_start;
  char eol = eolbyte;
  int backref, start, len, best_len;
  struct kwsmatch kwsm;
  size_t i, ret_val;
#ifdef MBS_SUPPORT
  if (MB_CUR_MAX > 1)
    {
      if (match_icase)
        {
          /* mbtolower adds a NUL byte at the end.  That will provide
	     space for the sentinel byte dfaexec may add.  */
          char *case_buf = mbtolower (buf, &size);
	  if (start_ptr)
	    start_ptr = case_buf + (start_ptr - buf);
          buf = case_buf;
        }
    }
#endif /* MBS_SUPPORT */

  mb_start = buf;
  buflim = buf + size;

  for (beg = end = buf; end < buflim; beg = end)
    {
      if (!start_ptr)
	{
	  /* We don't care about an exact match.  */
	  if (kwset)
	    {
	      /* Find a possible match using the KWset matcher. */
	      size_t offset = kwsexec (kwset, beg, buflim - beg, &kwsm);
	      if (offset == (size_t) -1)
		goto failure;
	      beg += offset;
	      /* Narrow down to the line containing the candidate, and
		 run it through DFA. */
	      if ((end = memchr(beg, eol, buflim - beg)) != NULL)
	        end++;
              else
                end = buflim;
	      match = beg;
	      while (beg > buf && beg[-1] != eol)
		--beg;
	      if (kwsm.index < kwset_exact_matches)
                {
#ifdef MBS_SUPPORT
                  if (mb_start < beg)
                    mb_start = beg;
                  if (MB_CUR_MAX == 1 || !is_mb_middle (&mb_start, match, buflim))
#endif
                    goto success;
                }
	      if (dfaexec (&dfa, beg, (char *) end, 0, NULL, &backref) == NULL)
		continue;
	    }
	  else
	    {
	      /* No good fixed strings; start with DFA. */
	      char const *next_beg = dfaexec (&dfa, beg, (char *) buflim,
					      0, NULL, &backref);
	      if (next_beg == NULL)
		break;
	      /* Narrow down to the line we've found. */
	      beg = next_beg;
	      if ((end = memchr(beg, eol, buflim - beg)) != NULL)
	        end++;
              else
                end = buflim;
	      while (beg > buf && beg[-1] != eol)
		--beg;
	    }
	  /* Successful, no backreferences encountered! */
	  if (!backref)
	    goto success;
	}
      else
	{
	  /* We are looking for the leftmost (then longest) exact match.
	     We will go through the outer loop only once.  */
	  beg = start_ptr;
	  end = buflim;
	}

      /* If we've made it to this point, this means DFA has seen
	 a probable match, and we need to run it through Regex. */
      best_match = end;
      best_len = 0;
      for (i = 0; i < pcount; i++)
	{
	  patterns[i].regexbuf.not_eol = 0;
	  if (0 <= (start = re_search (&(patterns[i].regexbuf),
				       buf, end - buf - 1,
				       beg - buf, end - beg - 1,
				       &(patterns[i].regs))))
	    {
	      len = patterns[i].regs.end[0] - start;
	      match = buf + start;
	      if (match > best_match)
		continue;
	      if (start_ptr && !match_words)
		goto assess_pattern_match;
	      if ((!match_lines && !match_words)
		  || (match_lines && len == end - beg - 1))
		{
		  match = beg;
		  len = end - beg;
		  goto assess_pattern_match;
		}
	      /* If -w, check if the match aligns with word boundaries.
		 We do this iteratively because:
		 (a) the line may contain more than one occurence of the
		 pattern, and
		 (b) Several alternatives in the pattern might be valid at a
		 given point, and we may need to consider a shorter one to
		 find a word boundary.  */
	      if (match_words)
		while (match <= best_match)
		  {
		    if ((match == buf || !WCHAR ((unsigned char) match[-1]))
			&& (len == end - beg - 1
			    || !WCHAR ((unsigned char) match[len])))
		      goto assess_pattern_match;
		    if (len > 0)
		      {
			/* Try a shorter length anchored at the same place. */
			--len;
			patterns[i].regexbuf.not_eol = 1;
			len = re_match (&(patterns[i].regexbuf),
					buf, match + len - beg, match - buf,
					&(patterns[i].regs));
		      }
		    if (len <= 0)
		      {
			/* Try looking further on. */
			if (match == end - 1)
			  break;
			match++;
			patterns[i].regexbuf.not_eol = 0;
			start = re_search (&(patterns[i].regexbuf),
					   buf, end - buf - 1,
					   match - buf, end - match - 1,
					   &(patterns[i].regs));
			if (start < 0)
			  break;
			len = patterns[i].regs.end[0] - start;
			match = buf + start;
		      }
		  } /* while (match <= best_match) */
	      continue;
	    assess_pattern_match:
	      if (!start_ptr)
		{
		  /* Good enough for a non-exact match.
		     No need to look at further patterns, if any.  */
		  beg = match;
		  goto success_in_len;
		}
	      if (match < best_match || (match == best_match && len > best_len))
		{
		  /* Best exact match:  leftmost, then longest.  */
		  best_match = match;
		  best_len = len;
		}
	    } /* if re_search >= 0 */
	} /* for Regex patterns.  */
	if (best_match < end)
	  {
	    /* We have found an exact match.  We were just
	       waiting for the best one (leftmost then longest).  */
	    beg = best_match;
	    len = best_len;
	    goto success_in_len;
	  }
    } /* for (beg = end ..) */

 failure:
  ret_val = -1;
  goto out;

 success:
  len = end - beg;
 success_in_len:
  *match_size = len;
  ret_val = beg - buf;
 out:
  return ret_val;
}

Building:src at:
/home/ubuntu/spr-fast/tests/corebench/grep/grep-case-8a025cf8-8f08d8e2/tempworkdir-l/srcMerged code building succ, going to invoke tester!
CondTester, Testing instance id 56:
//src_file:src/dfasearch.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); void* memset(void*, int, unsigned long); 
/* dfasearch.c - searching subroutines using dfa and regex for grep.
   Copyright 1992, 1998, 2000, 2007, 2009-2010 Free Software Foundation, Inc.

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 3, or (at your option)
   any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program; if not, write to the Free Software
   Foundation, Inc., 51 Franklin Street - Fifth Floor, Boston, MA
   02110-1301, USA.  */

/* Written August 1992 by Mike Haertel. */

#include <config.h>
#include "search.h"
#include "dfa.h"

/* For -w, we also consider _ to be word constituent.  */
#define WCHAR(C) (ISALNUM(C) || (C) == '_')

/* KWset compiled pattern.  For Ecompile and Gcompile, we compile
   a list of strings, at least one of which is known to occur in
   any string matching the regexp. */
static kwset_t kwset;

/* DFA compiled regexp. */
static struct dfa dfa;

/* The Regex compiled patterns.  */
static struct patterns
{
  /* Regex compiled regexp. */
  struct re_pattern_buffer regexbuf;
  struct re_registers regs; /* This is here on account of a BRAIN-DEAD
			       Q@#%!# library interface in regex.c.  */
} patterns0;

struct patterns *patterns;
size_t pcount;

void
dfaerror (char const *mesg)
{
  error (EXIT_TROUBLE, 0, "%s", mesg);

  /* notreached */
  /* Tell static analyzers that this function does not return.  */
  abort ();
}

/* Number of compiled fixed strings known to exactly match the regexp.
   If kwsexec returns < kwset_exact_matches, then we don't need to
   call the regexp matcher at all. */
static int kwset_exact_matches;

static char const *
kwsincr_case (const char *must)
{
  const char *buf;
  size_t n;

  
//Patch 0:
if ((__is_neg(5, &(must), sizeof (must), &(n), sizeof (n), &(match_icase), sizeof (match_icase), &(buf), sizeof (buf), &(kwset), sizeof (kwset))))
    return 0;
n = strlen(must);

//CodeSeg 1:
#ifdef MBS_SUPPORT
  if (match_icase && MB_CUR_MAX > 1)
    buf = mbtolower (must, &n);
  else
#endif
    buf = must;
  return kwsincr (kwset, buf, n);
}

/* If the DFA turns out to have some set of fixed strings one of
   which must occur in the match, then we build a kwset matcher
   to find those strings, and thus quickly filter out impossible
   matches. */
static void
kwsmusts (void)
{
  struct dfamust const *dm;
  char const *err;

  if (dfa.musts)
    {
      kwsinit (&kwset);
      /* First, we compile in the substrings known to be exact
	 matches.  The kwset matcher will return the index
	 of the matching string that it chooses. */
      for (dm = dfa.musts; dm; dm = dm->next)
	{
	  if (!dm->exact)
	    continue;
	  ++kwset_exact_matches;
	  if ((err = kwsincr_case (dm->must)) != NULL)
	    error (EXIT_TROUBLE, 0, "%s", err);
	}
      /* Now, we compile the substrings that will require
	 the use of the regexp matcher.  */
      for (dm = dfa.musts; dm; dm = dm->next)
	{
	  if (dm->exact)
	    continue;
	  if ((err = kwsincr_case (dm->must)) != NULL)
	    error (EXIT_TROUBLE, 0, "%s", err);
	}
      if ((err = kwsprep (kwset)) != NULL)
	error (EXIT_TROUBLE, 0, "%s", err);
    }
}

void
GEAcompile (char const *pattern, size_t size, reg_syntax_t syntax_bits)
{
  const char *err;
  const char *p, *sep;
  size_t total = size;
  char *motif;

  if (match_icase)
    syntax_bits |= RE_ICASE;
  re_set_syntax (syntax_bits);
  dfasyntax (syntax_bits, match_icase, eolbyte);

  /* For GNU regex compiler we have to pass the patterns separately to detect
     errors like "[\nallo\n]\n".  The patterns here are "[", "allo" and "]"
     GNU regex should have raise a syntax error.  The same for backref, where
     the backref should have been local to each pattern.  */
  p = pattern;
  do
    {
      size_t len;
      sep = memchr (p, '\n', total);
      if (sep)
	{
	  len = sep - p;
	  sep++;
	  total -= (len + 1);
	}
      else
	{
	  len = total;
	  total = 0;
	}

      patterns = realloc (patterns, (pcount + 1) * sizeof (*patterns));
      if (patterns == NULL)
	error (EXIT_TROUBLE, errno, _("memory exhausted"));
      patterns[pcount] = patterns0;

      if ((err = re_compile_pattern (p, len,
				    &(patterns[pcount].regexbuf))) != NULL)
	error (EXIT_TROUBLE, 0, "%s", err);
      pcount++;

      p = sep;
    } while (sep && total != 0);

  /* In the match_words and match_lines cases, we use a different pattern
     for the DFA matcher that will quickly throw out cases that won't work.
     Then if DFA succeeds we do some hairy stuff using the regex matcher
     to decide whether the match should really count. */
  if (match_words || match_lines)
    {
      static char const line_beg_no_bk[] = "^(";
      static char const line_end_no_bk[] = ")$";
      static char const word_beg_no_bk[] = "(^|[^[:alnum:]_])(";
      static char const word_end_no_bk[] = ")([^[:alnum:]_]|$)";
      static char const line_beg_bk[] = "^\\(";
      static char const line_end_bk[] = "\\)$";
      static char const word_beg_bk[] = "\\(^\\|[^[:alnum:]_]\\)\\(";
      static char const word_end_bk[] = "\\)\\([^[:alnum:]_]\\|$\\)";
      int bk = !(syntax_bits & RE_NO_BK_PARENS);
      char *n = xmalloc (sizeof word_beg_bk - 1 + size + sizeof word_end_bk);

      strcpy (n, match_lines ? (bk ? line_beg_bk : line_beg_no_bk)
			     : (bk ? word_beg_bk : word_beg_no_bk));
      total = strlen(n);
      memcpy (n + total, pattern, size);
      total += size;
      strcpy (n + total, match_lines ? (bk ? line_end_bk : line_end_no_bk)
				     : (bk ? word_end_bk : word_end_no_bk));
      total += strlen (n + total);
      pattern = motif = n;
      size = total;
    }
  else
    motif = NULL;

  dfacomp (pattern, size, &dfa, 1);
  kwsmusts ();

  free(motif);
}

size_t
EGexecute (char const *buf, size_t size, size_t *match_size,
	   char const *start_ptr)
{
  char const *buflim, *beg, *end, *match, *best_match, *mb_start;
  char eol = eolbyte;
  int backref, start, len, best_len;
  struct kwsmatch kwsm;
  size_t i, ret_val;
#ifdef MBS_SUPPORT
  if (MB_CUR_MAX > 1)
    {
      if (match_icase)
        {
          /* mbtolower adds a NUL byte at the end.  That will provide
	     space for the sentinel byte dfaexec may add.  */
          char *case_buf = mbtolower (buf, &size);
	  if (start_ptr)
	    start_ptr = case_buf + (start_ptr - buf);
          buf = case_buf;
        }
    }
#endif /* MBS_SUPPORT */

  mb_start = buf;
  buflim = buf + size;

  for (beg = end = buf; end < buflim; beg = end)
    {
      if (!start_ptr)
	{
	  /* We don't care about an exact match.  */
	  if (kwset)
	    {
	      /* Find a possible match using the KWset matcher. */
	      size_t offset = kwsexec (kwset, beg, buflim - beg, &kwsm);
	      if (offset == (size_t) -1)
		goto failure;
	      beg += offset;
	      /* Narrow down to the line containing the candidate, and
		 run it through DFA. */
	      if ((end = memchr(beg, eol, buflim - beg)) != NULL)
	        end++;
              else
                end = buflim;
	      match = beg;
	      while (beg > buf && beg[-1] != eol)
		--beg;
	      if (kwsm.index < kwset_exact_matches)
                {
#ifdef MBS_SUPPORT
                  if (mb_start < beg)
                    mb_start = beg;
                  if (MB_CUR_MAX == 1 || !is_mb_middle (&mb_start, match, buflim))
#endif
                    goto success;
                }
	      if (dfaexec (&dfa, beg, (char *) end, 0, NULL, &backref) == NULL)
		continue;
	    }
	  else
	    {
	      /* No good fixed strings; start with DFA. */
	      char const *next_beg = dfaexec (&dfa, beg, (char *) buflim,
					      0, NULL, &backref);
	      if (next_beg == NULL)
		break;
	      /* Narrow down to the line we've found. */
	      beg = next_beg;
	      if ((end = memchr(beg, eol, buflim - beg)) != NULL)
	        end++;
              else
                end = buflim;
	      while (beg > buf && beg[-1] != eol)
		--beg;
	    }
	  /* Successful, no backreferences encountered! */
	  if (!backref)
	    goto success;
	}
      else
	{
	  /* We are looking for the leftmost (then longest) exact match.
	     We will go through the outer loop only once.  */
	  beg = start_ptr;
	  end = buflim;
	}

      /* If we've made it to this point, this means DFA has seen
	 a probable match, and we need to run it through Regex. */
      best_match = end;
      best_len = 0;
      for (i = 0; i < pcount; i++)
	{
	  patterns[i].regexbuf.not_eol = 0;
	  if (0 <= (start = re_search (&(patterns[i].regexbuf),
				       buf, end - buf - 1,
				       beg - buf, end - beg - 1,
				       &(patterns[i].regs))))
	    {
	      len = patterns[i].regs.end[0] - start;
	      match = buf + start;
	      if (match > best_match)
		continue;
	      if (start_ptr && !match_words)
		goto assess_pattern_match;
	      if ((!match_lines && !match_words)
		  || (match_lines && len == end - beg - 1))
		{
		  match = beg;
		  len = end - beg;
		  goto assess_pattern_match;
		}
	      /* If -w, check if the match aligns with word boundaries.
		 We do this iteratively because:
		 (a) the line may contain more than one occurence of the
		 pattern, and
		 (b) Several alternatives in the pattern might be valid at a
		 given point, and we may need to consider a shorter one to
		 find a word boundary.  */
	      if (match_words)
		while (match <= best_match)
		  {
		    if ((match == buf || !WCHAR ((unsigned char) match[-1]))
			&& (len == end - beg - 1
			    || !WCHAR ((unsigned char) match[len])))
		      goto assess_pattern_match;
		    if (len > 0)
		      {
			/* Try a shorter length anchored at the same place. */
			--len;
			patterns[i].regexbuf.not_eol = 1;
			len = re_match (&(patterns[i].regexbuf),
					buf, match + len - beg, match - buf,
					&(patterns[i].regs));
		      }
		    if (len <= 0)
		      {
			/* Try looking further on. */
			if (match == end - 1)
			  break;
			match++;
			patterns[i].regexbuf.not_eol = 0;
			start = re_search (&(patterns[i].regexbuf),
					   buf, end - buf - 1,
					   match - buf, end - match - 1,
					   &(patterns[i].regs));
			if (start < 0)
			  break;
			len = patterns[i].regs.end[0] - start;
			match = buf + start;
		      }
		  } /* while (match <= best_match) */
	      continue;
	    assess_pattern_match:
	      if (!start_ptr)
		{
		  /* Good enough for a non-exact match.
		     No need to look at further patterns, if any.  */
		  beg = match;
		  goto success_in_len;
		}
	      if (match < best_match || (match == best_match && len > best_len))
		{
		  /* Best exact match:  leftmost, then longest.  */
		  best_match = match;
		  best_len = len;
		}
	    } /* if re_search >= 0 */
	} /* for Regex patterns.  */
	if (best_match < end)
	  {
	    /* We have found an exact match.  We were just
	       waiting for the best one (leftmost then longest).  */
	    beg = best_match;
	    len = best_len;
	    goto success_in_len;
	  }
    } /* for (beg = end ..) */

 failure:
  ret_val = -1;
  goto out;

 success:
  len = end - beg;
 success_in_len:
  *match_size = len;
  ret_val = beg - buf;
 out:
  return ret_val;
}

Testing negative cases!
Testing 0 (with abstract condition) ENVIS_NEG
Iteration 0
Running test command:
/home/ubuntu/spr-fast/tools/grep-test.py /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-8a025cf8-8f08d8e2/tempworkdir-l/src /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-8a025cf8-8f08d8e2/tempworkdir-l/tests /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-8a025cf8-8f08d8e2/tempworkdir-l 0  > __res
Opening:/tmp/neg.tmp!
NegativeBRANCH RECORD/tmp/neg.tmp!
APPENDING TO ISNEG:/tmp/neg.tmp!
Branch 0: 0
Iteration 1
Running test command:
/home/ubuntu/spr-fast/tools/grep-test.py /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-8a025cf8-8f08d8e2/tempworkdir-l/src /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-8a025cf8-8f08d8e2/tempworkdir-l/tests /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-8a025cf8-8f08d8e2/tempworkdir-l 0  > __res
Opening:/tmp/neg.tmp!
NegativeBRANCH RECORD/tmp/neg.tmp!
APPENDING TO ISNEG:/tmp/neg.tmp!
Branch 0: 1
Running test command:
/home/ubuntu/spr-fast/tools/grep-test.py /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-8a025cf8-8f08d8e2/tempworkdir-l/src /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-8a025cf8-8f08d8e2/tempworkdir-l/tests /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-8a025cf8-8f08d8e2/tempworkdir-l 0  > __res
a batched test job starts!
Building merged code:
src_file: src/dfasearch.c
full src: int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); void* memset(void*, int, unsigned long); 
/* dfasearch.c - searching subroutines using dfa and regex for grep.
   Copyright 1992, 1998, 2000, 2007, 2009-2010 Free Software Foundation, Inc.

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 3, or (at your option)
   any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program; if not, write to the Free Software
   Foundation, Inc., 51 Franklin Street - Fifth Floor, Boston, MA
   02110-1301, USA.  */

/* Written August 1992 by Mike Haertel. */

#include <config.h>
#include "search.h"
#include "dfa.h"

/* For -w, we also consider _ to be word constituent.  */
#define WCHAR(C) (ISALNUM(C) || (C) == '_')

/* KWset compiled pattern.  For Ecompile and Gcompile, we compile
   a list of strings, at least one of which is known to occur in
   any string matching the regexp. */
static kwset_t kwset;

/* DFA compiled regexp. */
static struct dfa dfa;

/* The Regex compiled patterns.  */
static struct patterns
{
  /* Regex compiled regexp. */
  struct re_pattern_buffer regexbuf;
  struct re_registers regs; /* This is here on account of a BRAIN-DEAD
			       Q@#%!# library interface in regex.c.  */
} patterns0;

struct patterns *patterns;
size_t pcount;

void
dfaerror (char const *mesg)
{
  error (EXIT_TROUBLE, 0, "%s", mesg);

  /* notreached */
  /* Tell static analyzers that this function does not return.  */
  abort ();
}

/* Number of compiled fixed strings known to exactly match the regexp.
   If kwsexec returns < kwset_exact_matches, then we don't need to
   call the regexp matcher at all. */
static int kwset_exact_matches;

static char const *
kwsincr_case (const char *must)
{
  const char *buf;
  size_t n;

  n = strlen (must);
#ifdef MBS_SUPPORT
  //prophet generated patch
  if (__get_mutant()==0) {
  if ((match_icase && (__ctype_get_mb_cur_max()) > 1) && !(__is_neg(5, &(match_icase), sizeof (match_icase), &(must), sizeof (must), &(buf), sizeof (buf), &(n), sizeof (n), &(kwset), sizeof (kwset))))
      buf = mbtolower(must, &n);
  else
      buf = must;
  }
  else if (__get_mutant()==1) {
  if ((match_icase && (__ctype_get_mb_cur_max()) > 1) || (__is_neg(5, &(match_icase), sizeof (match_icase), &(must), sizeof (must), &(buf), sizeof (buf), &(n), sizeof (n), &(kwset), sizeof (kwset))))
      buf = mbtolower(must, &n);
  else
      buf = must;
  }
  else if (__get_mutant()==2) {
  if (((match_icase) || (__is_neg(5, &(match_icase), sizeof (match_icase), &(must), sizeof (must), &(buf), sizeof (buf), &(n), sizeof (n), &(kwset), sizeof (kwset)))) && (__ctype_get_mb_cur_max()) > 1)
      buf = mbtolower(must, &n);
  else
      buf = must;
  }
  return kwsincr (kwset, buf, n);
}

/* If the DFA turns out to have some set of fixed strings one of
   which must occur in the match, then we build a kwset matcher
   to find those strings, and thus quickly filter out impossible
   matches. */
static void
kwsmusts (void)
{
  struct dfamust const *dm;
  char const *err;

  if (dfa.musts)
    {
      kwsinit (&kwset);
      /* First, we compile in the substrings known to be exact
	 matches.  The kwset matcher will return the index
	 of the matching string that it chooses. */
      for (dm = dfa.musts; dm; dm = dm->next)
	{
	  if (!dm->exact)
	    continue;
	  ++kwset_exact_matches;
	  if ((err = kwsincr_case (dm->must)) != NULL)
	    error (EXIT_TROUBLE, 0, "%s", err);
	}
      /* Now, we compile the substrings that will require
	 the use of the regexp matcher.  */
      for (dm = dfa.musts; dm; dm = dm->next)
	{
	  if (dm->exact)
	    continue;
	  if ((err = kwsincr_case (dm->must)) != NULL)
	    error (EXIT_TROUBLE, 0, "%s", err);
	}
      if ((err = kwsprep (kwset)) != NULL)
	error (EXIT_TROUBLE, 0, "%s", err);
    }
}

void
GEAcompile (char const *pattern, size_t size, reg_syntax_t syntax_bits)
{
  const char *err;
  const char *p, *sep;
  size_t total = size;
  char *motif;

  if (match_icase)
    syntax_bits |= RE_ICASE;
  re_set_syntax (syntax_bits);
  dfasyntax (syntax_bits, match_icase, eolbyte);

  /* For GNU regex compiler we have to pass the patterns separately to detect
     errors like "[\nallo\n]\n".  The patterns here are "[", "allo" and "]"
     GNU regex should have raise a syntax error.  The same for backref, where
     the backref should have been local to each pattern.  */
  p = pattern;
  do
    {
      size_t len;
      sep = memchr (p, '\n', total);
      if (sep)
	{
	  len = sep - p;
	  sep++;
	  total -= (len + 1);
	}
      else
	{
	  len = total;
	  total = 0;
	}

      patterns = realloc (patterns, (pcount + 1) * sizeof (*patterns));
      if (patterns == NULL)
	error (EXIT_TROUBLE, errno, _("memory exhausted"));
      patterns[pcount] = patterns0;

      if ((err = re_compile_pattern (p, len,
				    &(patterns[pcount].regexbuf))) != NULL)
	error (EXIT_TROUBLE, 0, "%s", err);
      pcount++;

      p = sep;
    } while (sep && total != 0);

  /* In the match_words and match_lines cases, we use a different pattern
     for the DFA matcher that will quickly throw out cases that won't work.
     Then if DFA succeeds we do some hairy stuff using the regex matcher
     to decide whether the match should really count. */
  if (match_words || match_lines)
    {
      static char const line_beg_no_bk[] = "^(";
      static char const line_end_no_bk[] = ")$";
      static char const word_beg_no_bk[] = "(^|[^[:alnum:]_])(";
      static char const word_end_no_bk[] = ")([^[:alnum:]_]|$)";
      static char const line_beg_bk[] = "^\\(";
      static char const line_end_bk[] = "\\)$";
      static char const word_beg_bk[] = "\\(^\\|[^[:alnum:]_]\\)\\(";
      static char const word_end_bk[] = "\\)\\([^[:alnum:]_]\\|$\\)";
      int bk = !(syntax_bits & RE_NO_BK_PARENS);
      char *n = xmalloc (sizeof word_beg_bk - 1 + size + sizeof word_end_bk);

      strcpy (n, match_lines ? (bk ? line_beg_bk : line_beg_no_bk)
			     : (bk ? word_beg_bk : word_beg_no_bk));
      total = strlen(n);
      memcpy (n + total, pattern, size);
      total += size;
      strcpy (n + total, match_lines ? (bk ? line_end_bk : line_end_no_bk)
				     : (bk ? word_end_bk : word_end_no_bk));
      total += strlen (n + total);
      pattern = motif = n;
      size = total;
    }
  else
    motif = NULL;

  dfacomp (pattern, size, &dfa, 1);
  kwsmusts ();

  free(motif);
}

size_t
EGexecute (char const *buf, size_t size, size_t *match_size,
	   char const *start_ptr)
{
  char const *buflim, *beg, *end, *match, *best_match, *mb_start;
  char eol = eolbyte;
  int backref, start, len, best_len;
  struct kwsmatch kwsm;
  size_t i, ret_val;
#ifdef MBS_SUPPORT
  if (MB_CUR_MAX > 1)
    {
      if (match_icase)
        {
          /* mbtolower adds a NUL byte at the end.  That will provide
	     space for the sentinel byte dfaexec may add.  */
          char *case_buf = mbtolower (buf, &size);
	  if (start_ptr)
	    start_ptr = case_buf + (start_ptr - buf);
          buf = case_buf;
        }
    }
#endif /* MBS_SUPPORT */

  mb_start = buf;
  buflim = buf + size;

  for (beg = end = buf; end < buflim; beg = end)
    {
      if (!start_ptr)
	{
	  /* We don't care about an exact match.  */
	  if (kwset)
	    {
	      /* Find a possible match using the KWset matcher. */
	      size_t offset = kwsexec (kwset, beg, buflim - beg, &kwsm);
	      if (offset == (size_t) -1)
		goto failure;
	      beg += offset;
	      /* Narrow down to the line containing the candidate, and
		 run it through DFA. */
	      if ((end = memchr(beg, eol, buflim - beg)) != NULL)
	        end++;
              else
                end = buflim;
	      match = beg;
	      while (beg > buf && beg[-1] != eol)
		--beg;
	      if (kwsm.index < kwset_exact_matches)
                {
#ifdef MBS_SUPPORT
                  if (mb_start < beg)
                    mb_start = beg;
                  if (MB_CUR_MAX == 1 || !is_mb_middle (&mb_start, match, buflim))
#endif
                    goto success;
                }
	      if (dfaexec (&dfa, beg, (char *) end, 0, NULL, &backref) == NULL)
		continue;
	    }
	  else
	    {
	      /* No good fixed strings; start with DFA. */
	      char const *next_beg = dfaexec (&dfa, beg, (char *) buflim,
					      0, NULL, &backref);
	      if (next_beg == NULL)
		break;
	      /* Narrow down to the line we've found. */
	      beg = next_beg;
	      if ((end = memchr(beg, eol, buflim - beg)) != NULL)
	        end++;
              else
                end = buflim;
	      while (beg > buf && beg[-1] != eol)
		--beg;
	    }
	  /* Successful, no backreferences encountered! */
	  if (!backref)
	    goto success;
	}
      else
	{
	  /* We are looking for the leftmost (then longest) exact match.
	     We will go through the outer loop only once.  */
	  beg = start_ptr;
	  end = buflim;
	}

      /* If we've made it to this point, this means DFA has seen
	 a probable match, and we need to run it through Regex. */
      best_match = end;
      best_len = 0;
      for (i = 0; i < pcount; i++)
	{
	  patterns[i].regexbuf.not_eol = 0;
	  if (0 <= (start = re_search (&(patterns[i].regexbuf),
				       buf, end - buf - 1,
				       beg - buf, end - beg - 1,
				       &(patterns[i].regs))))
	    {
	      len = patterns[i].regs.end[0] - start;
	      match = buf + start;
	      if (match > best_match)
		continue;
	      if (start_ptr && !match_words)
		goto assess_pattern_match;
	      if ((!match_lines && !match_words)
		  || (match_lines && len == end - beg - 1))
		{
		  match = beg;
		  len = end - beg;
		  goto assess_pattern_match;
		}
	      /* If -w, check if the match aligns with word boundaries.
		 We do this iteratively because:
		 (a) the line may contain more than one occurence of the
		 pattern, and
		 (b) Several alternatives in the pattern might be valid at a
		 given point, and we may need to consider a shorter one to
		 find a word boundary.  */
	      if (match_words)
		while (match <= best_match)
		  {
		    if ((match == buf || !WCHAR ((unsigned char) match[-1]))
			&& (len == end - beg - 1
			    || !WCHAR ((unsigned char) match[len])))
		      goto assess_pattern_match;
		    if (len > 0)
		      {
			/* Try a shorter length anchored at the same place. */
			--len;
			patterns[i].regexbuf.not_eol = 1;
			len = re_match (&(patterns[i].regexbuf),
					buf, match + len - beg, match - buf,
					&(patterns[i].regs));
		      }
		    if (len <= 0)
		      {
			/* Try looking further on. */
			if (match == end - 1)
			  break;
			match++;
			patterns[i].regexbuf.not_eol = 0;
			start = re_search (&(patterns[i].regexbuf),
					   buf, end - buf - 1,
					   match - buf, end - match - 1,
					   &(patterns[i].regs));
			if (start < 0)
			  break;
			len = patterns[i].regs.end[0] - start;
			match = buf + start;
		      }
		  } /* while (match <= best_match) */
	      continue;
	    assess_pattern_match:
	      if (!start_ptr)
		{
		  /* Good enough for a non-exact match.
		     No need to look at further patterns, if any.  */
		  beg = match;
		  goto success_in_len;
		}
	      if (match < best_match || (match == best_match && len > best_len))
		{
		  /* Best exact match:  leftmost, then longest.  */
		  best_match = match;
		  best_len = len;
		}
	    } /* if re_search >= 0 */
	} /* for Regex patterns.  */
	if (best_match < end)
	  {
	    /* We have found an exact match.  We were just
	       waiting for the best one (leftmost then longest).  */
	    beg = best_match;
	    len = best_len;
	    goto success_in_len;
	  }
    } /* for (beg = end ..) */

 failure:
  ret_val = -1;
  goto out;

 success:
  len = end - beg;
 success_in_len:
  *match_size = len;
  ret_val = beg - buf;
 out:
  return ret_val;
}

Building:src at:
/home/ubuntu/spr-fast/tests/corebench/grep/grep-case-8a025cf8-8f08d8e2/tempworkdir-l/srcMerged code building failed! Going to build saperately!
Building:src at:
/home/ubuntu/spr-fast/tests/corebench/grep/grep-case-8a025cf8-8f08d8e2/tempworkdir-l/srcSingle building for Tester 0x42e68c0 id 0 failed as well!
Building:src at:
/home/ubuntu/spr-fast/tests/corebench/grep/grep-case-8a025cf8-8f08d8e2/tempworkdir-l/srcSingle building for Tester 0x42e68c0 id 28 failed as well!
Building:src at:
/home/ubuntu/spr-fast/tests/corebench/grep/grep-case-8a025cf8-8f08d8e2/tempworkdir-l/srcSingle building for Tester 0x42e68c0 id 40 failed as well!
a batched test job starts!
Building merged code:
src_file: src/dfasearch.c
full src: int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); void* memset(void*, int, unsigned long); 
/* dfasearch.c - searching subroutines using dfa and regex for grep.
   Copyright 1992, 1998, 2000, 2007, 2009-2010 Free Software Foundation, Inc.

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 3, or (at your option)
   any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program; if not, write to the Free Software
   Foundation, Inc., 51 Franklin Street - Fifth Floor, Boston, MA
   02110-1301, USA.  */

/* Written August 1992 by Mike Haertel. */

#include <config.h>
#include "search.h"
#include "dfa.h"

/* For -w, we also consider _ to be word constituent.  */
#define WCHAR(C) (ISALNUM(C) || (C) == '_')

/* KWset compiled pattern.  For Ecompile and Gcompile, we compile
   a list of strings, at least one of which is known to occur in
   any string matching the regexp. */
static kwset_t kwset;

/* DFA compiled regexp. */
static struct dfa dfa;

/* The Regex compiled patterns.  */
static struct patterns
{
  /* Regex compiled regexp. */
  struct re_pattern_buffer regexbuf;
  struct re_registers regs; /* This is here on account of a BRAIN-DEAD
			       Q@#%!# library interface in regex.c.  */
} patterns0;

struct patterns *patterns;
size_t pcount;

void
dfaerror (char const *mesg)
{
  error (EXIT_TROUBLE, 0, "%s", mesg);

  /* notreached */
  /* Tell static analyzers that this function does not return.  */
  abort ();
}

/* Number of compiled fixed strings known to exactly match the regexp.
   If kwsexec returns < kwset_exact_matches, then we don't need to
   call the regexp matcher at all. */
static int kwset_exact_matches;

static char const *
kwsincr_case (const char *must)
{
  const char *buf;
  size_t n;

  n = strlen (must);
#ifdef MBS_SUPPORT
  if (match_icase && MB_CUR_MAX > 1)
    buf = mbtolower (must, &n);
  else
#endif
    buf = must;
  return kwsincr (kwset, buf, n);
}

/* If the DFA turns out to have some set of fixed strings one of
   which must occur in the match, then we build a kwset matcher
   to find those strings, and thus quickly filter out impossible
   matches. */
static void
kwsmusts (void)
{
  struct dfamust const *dm;
  char const *err;

  //prophet generated patch
  if (__get_mutant()==0) {
  if ((dfa.musts) && !(__is_neg(60, &(dfa.musts), sizeof (dfa.musts), &(dfa.musts), sizeof (dfa.musts), &(kwset), sizeof (kwset), &(dm), sizeof (dm), &(kwset_exact_matches), sizeof (kwset_exact_matches), &(err), sizeof (err), &(dfa.charclasses), sizeof (dfa.charclasses), &(dfa.cindex), sizeof (dfa.cindex), &(dfa.calloc), sizeof (dfa.calloc), &(dfa.tokens), sizeof (dfa.tokens), &(dfa.tindex), sizeof (dfa.tindex), &(dfa.talloc), sizeof (dfa.talloc), &(dfa.depth), sizeof (dfa.depth), &(dfa.nleaves), sizeof (dfa.nleaves), &(dfa.nregexps), sizeof (dfa.nregexps), &(dfa.mb_cur_max), sizeof (dfa.mb_cur_max), &(dfa.nmultibyte_prop), sizeof (dfa.nmultibyte_prop), &(dfa.multibyte_prop), sizeof (dfa.multibyte_prop), &(dfa.mbcsets), sizeof (dfa.mbcsets), &(dfa.nmbcsets), sizeof (dfa.nmbcsets), &(dfa.mbcsets_alloc), sizeof (dfa.mbcsets_alloc), &(dfa.states), sizeof (dfa.states), &(dfa.sindex), sizeof (dfa.sindex), &(dfa.salloc), sizeof (dfa.salloc), &(dfa.follows), sizeof (dfa.follows), &(dfa.searchflag), sizeof (dfa.searchflag), &(dfa.tralloc), sizeof (dfa.tralloc), &(dfa.trcount), sizeof (dfa.trcount), &(dfa.trans), sizeof (dfa.trans), &(dfa.realtrans), sizeof (dfa.realtrans), &(dfa.fails), sizeof (dfa.fails), &(dfa.success), sizeof (dfa.success), &(dfa.newlines), sizeof (dfa.newlines), &(dfa.charclasses), sizeof (dfa.charclasses), &(dfa.cindex), sizeof (dfa.cindex), &(dfa.calloc), sizeof (dfa.calloc), &(dfa.tokens), sizeof (dfa.tokens), &(dfa.tindex), sizeof (dfa.tindex), &(dfa.talloc), sizeof (dfa.talloc), &(dfa.depth), sizeof (dfa.depth), &(dfa.nleaves), sizeof (dfa.nleaves), &(dfa.nregexps), sizeof (dfa.nregexps), &(dfa.mb_cur_max), sizeof (dfa.mb_cur_max), &(dfa.nmultibyte_prop), sizeof (dfa.nmultibyte_prop), &(dfa.multibyte_prop), sizeof (dfa.multibyte_prop), &(dfa.mbcsets), sizeof (dfa.mbcsets), &(dfa.nmbcsets), sizeof (dfa.nmbcsets), &(dfa.mbcsets_alloc), sizeof (dfa.mbcsets_alloc), &(dfa.states), sizeof (dfa.states), &(dfa.sindex), sizeof (dfa.sindex), &(dfa.salloc), sizeof (dfa.salloc), &(dfa.follows), sizeof (dfa.follows), &(dfa.searchflag), sizeof (dfa.searchflag), &(dfa.tralloc), sizeof (dfa.tralloc), &(dfa.trcount), sizeof (dfa.trcount), &(dfa.trans), sizeof (dfa.trans), &(dfa.realtrans), sizeof (dfa.realtrans), &(dfa.fails), sizeof (dfa.fails), &(dfa.success), sizeof (dfa.success), &(dfa.newlines), sizeof (dfa.newlines)))) {
      kwsinit(&kwset);
      for (dm = dfa.musts; dm; dm = dm->next) {
          if (!dm->exact)
              continue;
          ++kwset_exact_matches;
          if ((err = kwsincr_case(dm->must)) != ((void *)0))
              error(EXIT_TROUBLE, 0, "%s", err);
      }
      for (dm = dfa.musts; dm; dm = dm->next) {
          if (dm->exact)
              continue;
          if ((err = kwsincr_case(dm->must)) != ((void *)0))
              error(EXIT_TROUBLE, 0, "%s", err);
      }
      if ((err = kwsprep(kwset)) != ((void *)0))
          error(EXIT_TROUBLE, 0, "%s", err);
  }
  }
  else if (__get_mutant()==1) {
  if ((dfa.musts) || (__is_neg(60, &(dfa.musts), sizeof (dfa.musts), &(dfa.musts), sizeof (dfa.musts), &(kwset), sizeof (kwset), &(dm), sizeof (dm), &(kwset_exact_matches), sizeof (kwset_exact_matches), &(err), sizeof (err), &(dfa.charclasses), sizeof (dfa.charclasses), &(dfa.cindex), sizeof (dfa.cindex), &(dfa.calloc), sizeof (dfa.calloc), &(dfa.tokens), sizeof (dfa.tokens), &(dfa.tindex), sizeof (dfa.tindex), &(dfa.talloc), sizeof (dfa.talloc), &(dfa.depth), sizeof (dfa.depth), &(dfa.nleaves), sizeof (dfa.nleaves), &(dfa.nregexps), sizeof (dfa.nregexps), &(dfa.mb_cur_max), sizeof (dfa.mb_cur_max), &(dfa.nmultibyte_prop), sizeof (dfa.nmultibyte_prop), &(dfa.multibyte_prop), sizeof (dfa.multibyte_prop), &(dfa.mbcsets), sizeof (dfa.mbcsets), &(dfa.nmbcsets), sizeof (dfa.nmbcsets), &(dfa.mbcsets_alloc), sizeof (dfa.mbcsets_alloc), &(dfa.states), sizeof (dfa.states), &(dfa.sindex), sizeof (dfa.sindex), &(dfa.salloc), sizeof (dfa.salloc), &(dfa.follows), sizeof (dfa.follows), &(dfa.searchflag), sizeof (dfa.searchflag), &(dfa.tralloc), sizeof (dfa.tralloc), &(dfa.trcount), sizeof (dfa.trcount), &(dfa.trans), sizeof (dfa.trans), &(dfa.realtrans), sizeof (dfa.realtrans), &(dfa.fails), sizeof (dfa.fails), &(dfa.success), sizeof (dfa.success), &(dfa.newlines), sizeof (dfa.newlines), &(dfa.charclasses), sizeof (dfa.charclasses), &(dfa.cindex), sizeof (dfa.cindex), &(dfa.calloc), sizeof (dfa.calloc), &(dfa.tokens), sizeof (dfa.tokens), &(dfa.tindex), sizeof (dfa.tindex), &(dfa.talloc), sizeof (dfa.talloc), &(dfa.depth), sizeof (dfa.depth), &(dfa.nleaves), sizeof (dfa.nleaves), &(dfa.nregexps), sizeof (dfa.nregexps), &(dfa.mb_cur_max), sizeof (dfa.mb_cur_max), &(dfa.nmultibyte_prop), sizeof (dfa.nmultibyte_prop), &(dfa.multibyte_prop), sizeof (dfa.multibyte_prop), &(dfa.mbcsets), sizeof (dfa.mbcsets), &(dfa.nmbcsets), sizeof (dfa.nmbcsets), &(dfa.mbcsets_alloc), sizeof (dfa.mbcsets_alloc), &(dfa.states), sizeof (dfa.states), &(dfa.sindex), sizeof (dfa.sindex), &(dfa.salloc), sizeof (dfa.salloc), &(dfa.follows), sizeof (dfa.follows), &(dfa.searchflag), sizeof (dfa.searchflag), &(dfa.tralloc), sizeof (dfa.tralloc), &(dfa.trcount), sizeof (dfa.trcount), &(dfa.trans), sizeof (dfa.trans), &(dfa.realtrans), sizeof (dfa.realtrans), &(dfa.fails), sizeof (dfa.fails), &(dfa.success), sizeof (dfa.success), &(dfa.newlines), sizeof (dfa.newlines)))) {
      kwsinit(&kwset);
      for (dm = dfa.musts; dm; dm = dm->next) {
          if (!dm->exact)
              continue;
          ++kwset_exact_matches;
          if ((err = kwsincr_case(dm->must)) != ((void *)0))
              error(EXIT_TROUBLE, 0, "%s", err);
      }
      for (dm = dfa.musts; dm; dm = dm->next) {
          if (dm->exact)
              continue;
          if ((err = kwsincr_case(dm->must)) != ((void *)0))
              error(EXIT_TROUBLE, 0, "%s", err);
      }
      if ((err = kwsprep(kwset)) != ((void *)0))
          error(EXIT_TROUBLE, 0, "%s", err);
  }
  }
  else if (__get_mutant()==2) {
  if ((__is_neg(60, &(dfa.musts), sizeof (dfa.musts), &(dfa.musts), sizeof (dfa.musts), &(kwset), sizeof (kwset), &(dm), sizeof (dm), &(kwset_exact_matches), sizeof (kwset_exact_matches), &(err), sizeof (err), &(dfa.charclasses), sizeof (dfa.charclasses), &(dfa.cindex), sizeof (dfa.cindex), &(dfa.calloc), sizeof (dfa.calloc), &(dfa.tokens), sizeof (dfa.tokens), &(dfa.tindex), sizeof (dfa.tindex), &(dfa.talloc), sizeof (dfa.talloc), &(dfa.depth), sizeof (dfa.depth), &(dfa.nleaves), sizeof (dfa.nleaves), &(dfa.nregexps), sizeof (dfa.nregexps), &(dfa.mb_cur_max), sizeof (dfa.mb_cur_max), &(dfa.nmultibyte_prop), sizeof (dfa.nmultibyte_prop), &(dfa.multibyte_prop), sizeof (dfa.multibyte_prop), &(dfa.mbcsets), sizeof (dfa.mbcsets), &(dfa.nmbcsets), sizeof (dfa.nmbcsets), &(dfa.mbcsets_alloc), sizeof (dfa.mbcsets_alloc), &(dfa.states), sizeof (dfa.states), &(dfa.sindex), sizeof (dfa.sindex), &(dfa.salloc), sizeof (dfa.salloc), &(dfa.follows), sizeof (dfa.follows), &(dfa.searchflag), sizeof (dfa.searchflag), &(dfa.tralloc), sizeof (dfa.tralloc), &(dfa.trcount), sizeof (dfa.trcount), &(dfa.trans), sizeof (dfa.trans), &(dfa.realtrans), sizeof (dfa.realtrans), &(dfa.fails), sizeof (dfa.fails), &(dfa.success), sizeof (dfa.success), &(dfa.newlines), sizeof (dfa.newlines), &(dfa.charclasses), sizeof (dfa.charclasses), &(dfa.cindex), sizeof (dfa.cindex), &(dfa.calloc), sizeof (dfa.calloc), &(dfa.tokens), sizeof (dfa.tokens), &(dfa.tindex), sizeof (dfa.tindex), &(dfa.talloc), sizeof (dfa.talloc), &(dfa.depth), sizeof (dfa.depth), &(dfa.nleaves), sizeof (dfa.nleaves), &(dfa.nregexps), sizeof (dfa.nregexps), &(dfa.mb_cur_max), sizeof (dfa.mb_cur_max), &(dfa.nmultibyte_prop), sizeof (dfa.nmultibyte_prop), &(dfa.multibyte_prop), sizeof (dfa.multibyte_prop), &(dfa.mbcsets), sizeof (dfa.mbcsets), &(dfa.nmbcsets), sizeof (dfa.nmbcsets), &(dfa.mbcsets_alloc), sizeof (dfa.mbcsets_alloc), &(dfa.states), sizeof (dfa.states), &(dfa.sindex), sizeof (dfa.sindex), &(dfa.salloc), sizeof (dfa.salloc), &(dfa.follows), sizeof (dfa.follows), &(dfa.searchflag), sizeof (dfa.searchflag), &(dfa.tralloc), sizeof (dfa.tralloc), &(dfa.trcount), sizeof (dfa.trcount), &(dfa.trans), sizeof (dfa.trans), &(dfa.realtrans), sizeof (dfa.realtrans), &(dfa.fails), sizeof (dfa.fails), &(dfa.success), sizeof (dfa.success), &(dfa.newlines), sizeof (dfa.newlines))))
      return;
  if (dfa.musts) {
      kwsinit(&kwset);
      for (dm = dfa.musts; dm; dm = dm->next) {
          if (!dm->exact)
              continue;
          ++kwset_exact_matches;
          if ((err = kwsincr_case(dm->must)) != ((void *)0))
              error(EXIT_TROUBLE, 0, "%s", err);
      }
      for (dm = dfa.musts; dm; dm = dm->next) {
          if (dm->exact)
              continue;
          if ((err = kwsincr_case(dm->must)) != ((void *)0))
              error(EXIT_TROUBLE, 0, "%s", err);
      }
      if ((err = kwsprep(kwset)) != ((void *)0))
          error(EXIT_TROUBLE, 0, "%s", err);
  }
  }
}

void
GEAcompile (char const *pattern, size_t size, reg_syntax_t syntax_bits)
{
  const char *err;
  const char *p, *sep;
  size_t total = size;
  char *motif;

  if (match_icase)
    syntax_bits |= RE_ICASE;
  re_set_syntax (syntax_bits);
  dfasyntax (syntax_bits, match_icase, eolbyte);

  /* For GNU regex compiler we have to pass the patterns separately to detect
     errors like "[\nallo\n]\n".  The patterns here are "[", "allo" and "]"
     GNU regex should have raise a syntax error.  The same for backref, where
     the backref should have been local to each pattern.  */
  p = pattern;
  do
    {
      size_t len;
      sep = memchr (p, '\n', total);
      if (sep)
	{
	  len = sep - p;
	  sep++;
	  total -= (len + 1);
	}
      else
	{
	  len = total;
	  total = 0;
	}

      patterns = realloc (patterns, (pcount + 1) * sizeof (*patterns));
      if (patterns == NULL)
	error (EXIT_TROUBLE, errno, _("memory exhausted"));
      patterns[pcount] = patterns0;

      if ((err = re_compile_pattern (p, len,
				    &(patterns[pcount].regexbuf))) != NULL)
	error (EXIT_TROUBLE, 0, "%s", err);
      pcount++;

      p = sep;
    } while (sep && total != 0);

  /* In the match_words and match_lines cases, we use a different pattern
     for the DFA matcher that will quickly throw out cases that won't work.
     Then if DFA succeeds we do some hairy stuff using the regex matcher
     to decide whether the match should really count. */
  if (match_words || match_lines)
    {
      static char const line_beg_no_bk[] = "^(";
      static char const line_end_no_bk[] = ")$";
      static char const word_beg_no_bk[] = "(^|[^[:alnum:]_])(";
      static char const word_end_no_bk[] = ")([^[:alnum:]_]|$)";
      static char const line_beg_bk[] = "^\\(";
      static char const line_end_bk[] = "\\)$";
      static char const word_beg_bk[] = "\\(^\\|[^[:alnum:]_]\\)\\(";
      static char const word_end_bk[] = "\\)\\([^[:alnum:]_]\\|$\\)";
      int bk = !(syntax_bits & RE_NO_BK_PARENS);
      char *n = xmalloc (sizeof word_beg_bk - 1 + size + sizeof word_end_bk);

      strcpy (n, match_lines ? (bk ? line_beg_bk : line_beg_no_bk)
			     : (bk ? word_beg_bk : word_beg_no_bk));
      total = strlen(n);
      memcpy (n + total, pattern, size);
      total += size;
      strcpy (n + total, match_lines ? (bk ? line_end_bk : line_end_no_bk)
				     : (bk ? word_end_bk : word_end_no_bk));
      total += strlen (n + total);
      pattern = motif = n;
      size = total;
    }
  else
    motif = NULL;

  dfacomp (pattern, size, &dfa, 1);
  kwsmusts ();

  free(motif);
}

size_t
EGexecute (char const *buf, size_t size, size_t *match_size,
	   char const *start_ptr)
{
  char const *buflim, *beg, *end, *match, *best_match, *mb_start;
  char eol = eolbyte;
  int backref, start, len, best_len;
  struct kwsmatch kwsm;
  size_t i, ret_val;
#ifdef MBS_SUPPORT
  if (MB_CUR_MAX > 1)
    {
      if (match_icase)
        {
          /* mbtolower adds a NUL byte at the end.  That will provide
	     space for the sentinel byte dfaexec may add.  */
          char *case_buf = mbtolower (buf, &size);
	  if (start_ptr)
	    start_ptr = case_buf + (start_ptr - buf);
          buf = case_buf;
        }
    }
#endif /* MBS_SUPPORT */

  mb_start = buf;
  buflim = buf + size;

  for (beg = end = buf; end < buflim; beg = end)
    {
      if (!start_ptr)
	{
	  /* We don't care about an exact match.  */
	  if (kwset)
	    {
	      /* Find a possible match using the KWset matcher. */
	      size_t offset = kwsexec (kwset, beg, buflim - beg, &kwsm);
	      if (offset == (size_t) -1)
		goto failure;
	      beg += offset;
	      /* Narrow down to the line containing the candidate, and
		 run it through DFA. */
	      if ((end = memchr(beg, eol, buflim - beg)) != NULL)
	        end++;
              else
                end = buflim;
	      match = beg;
	      while (beg > buf && beg[-1] != eol)
		--beg;
	      if (kwsm.index < kwset_exact_matches)
                {
#ifdef MBS_SUPPORT
                  if (mb_start < beg)
                    mb_start = beg;
                  if (MB_CUR_MAX == 1 || !is_mb_middle (&mb_start, match, buflim))
#endif
                    goto success;
                }
	      if (dfaexec (&dfa, beg, (char *) end, 0, NULL, &backref) == NULL)
		continue;
	    }
	  else
	    {
	      /* No good fixed strings; start with DFA. */
	      char const *next_beg = dfaexec (&dfa, beg, (char *) buflim,
					      0, NULL, &backref);
	      if (next_beg == NULL)
		break;
	      /* Narrow down to the line we've found. */
	      beg = next_beg;
	      if ((end = memchr(beg, eol, buflim - beg)) != NULL)
	        end++;
              else
                end = buflim;
	      while (beg > buf && beg[-1] != eol)
		--beg;
	    }
	  /* Successful, no backreferences encountered! */
	  if (!backref)
	    goto success;
	}
      else
	{
	  /* We are looking for the leftmost (then longest) exact match.
	     We will go through the outer loop only once.  */
	  beg = start_ptr;
	  end = buflim;
	}

      /* If we've made it to this point, this means DFA has seen
	 a probable match, and we need to run it through Regex. */
      best_match = end;
      best_len = 0;
      for (i = 0; i < pcount; i++)
	{
	  patterns[i].regexbuf.not_eol = 0;
	  if (0 <= (start = re_search (&(patterns[i].regexbuf),
				       buf, end - buf - 1,
				       beg - buf, end - beg - 1,
				       &(patterns[i].regs))))
	    {
	      len = patterns[i].regs.end[0] - start;
	      match = buf + start;
	      if (match > best_match)
		continue;
	      if (start_ptr && !match_words)
		goto assess_pattern_match;
	      if ((!match_lines && !match_words)
		  || (match_lines && len == end - beg - 1))
		{
		  match = beg;
		  len = end - beg;
		  goto assess_pattern_match;
		}
	      /* If -w, check if the match aligns with word boundaries.
		 We do this iteratively because:
		 (a) the line may contain more than one occurence of the
		 pattern, and
		 (b) Several alternatives in the pattern might be valid at a
		 given point, and we may need to consider a shorter one to
		 find a word boundary.  */
	      if (match_words)
		while (match <= best_match)
		  {
		    if ((match == buf || !WCHAR ((unsigned char) match[-1]))
			&& (len == end - beg - 1
			    || !WCHAR ((unsigned char) match[len])))
		      goto assess_pattern_match;
		    if (len > 0)
		      {
			/* Try a shorter length anchored at the same place. */
			--len;
			patterns[i].regexbuf.not_eol = 1;
			len = re_match (&(patterns[i].regexbuf),
					buf, match + len - beg, match - buf,
					&(patterns[i].regs));
		      }
		    if (len <= 0)
		      {
			/* Try looking further on. */
			if (match == end - 1)
			  break;
			match++;
			patterns[i].regexbuf.not_eol = 0;
			start = re_search (&(patterns[i].regexbuf),
					   buf, end - buf - 1,
					   match - buf, end - match - 1,
					   &(patterns[i].regs));
			if (start < 0)
			  break;
			len = patterns[i].regs.end[0] - start;
			match = buf + start;
		      }
		  } /* while (match <= best_match) */
	      continue;
	    assess_pattern_match:
	      if (!start_ptr)
		{
		  /* Good enough for a non-exact match.
		     No need to look at further patterns, if any.  */
		  beg = match;
		  goto success_in_len;
		}
	      if (match < best_match || (match == best_match && len > best_len))
		{
		  /* Best exact match:  leftmost, then longest.  */
		  best_match = match;
		  best_len = len;
		}
	    } /* if re_search >= 0 */
	} /* for Regex patterns.  */
	if (best_match < end)
	  {
	    /* We have found an exact match.  We were just
	       waiting for the best one (leftmost then longest).  */
	    beg = best_match;
	    len = best_len;
	    goto success_in_len;
	  }
    } /* for (beg = end ..) */

 failure:
  ret_val = -1;
  goto out;

 success:
  len = end - beg;
 success_in_len:
  *match_size = len;
  ret_val = beg - buf;
 out:
  return ret_val;
}

Building:src at:
/home/ubuntu/spr-fast/tests/corebench/grep/grep-case-8a025cf8-8f08d8e2/tempworkdir-l/srcMerged code building succ, going to invoke tester!
CondTester, Testing instance id 17:
//src_file:src/dfasearch.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); void* memset(void*, int, unsigned long); 
/* dfasearch.c - searching subroutines using dfa and regex for grep.
   Copyright 1992, 1998, 2000, 2007, 2009-2010 Free Software Foundation, Inc.

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 3, or (at your option)
   any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program; if not, write to the Free Software
   Foundation, Inc., 51 Franklin Street - Fifth Floor, Boston, MA
   02110-1301, USA.  */

/* Written August 1992 by Mike Haertel. */

#include <config.h>
#include "search.h"
#include "dfa.h"

/* For -w, we also consider _ to be word constituent.  */
#define WCHAR(C) (ISALNUM(C) || (C) == '_')

/* KWset compiled pattern.  For Ecompile and Gcompile, we compile
   a list of strings, at least one of which is known to occur in
   any string matching the regexp. */
static kwset_t kwset;

/* DFA compiled regexp. */
static struct dfa dfa;

/* The Regex compiled patterns.  */
static struct patterns
{
  /* Regex compiled regexp. */
  struct re_pattern_buffer regexbuf;
  struct re_registers regs; /* This is here on account of a BRAIN-DEAD
			       Q@#%!# library interface in regex.c.  */
} patterns0;

struct patterns *patterns;
size_t pcount;

void
dfaerror (char const *mesg)
{
  error (EXIT_TROUBLE, 0, "%s", mesg);

  /* notreached */
  /* Tell static analyzers that this function does not return.  */
  abort ();
}

/* Number of compiled fixed strings known to exactly match the regexp.
   If kwsexec returns < kwset_exact_matches, then we don't need to
   call the regexp matcher at all. */
static int kwset_exact_matches;

static char const *
kwsincr_case (const char *must)
{
  const char *buf;
  size_t n;

  n = strlen (must);
#ifdef MBS_SUPPORT
  if (match_icase && MB_CUR_MAX > 1)
    buf = mbtolower (must, &n);
  else
#endif
    buf = must;
  return kwsincr (kwset, buf, n);
}

/* If the DFA turns out to have some set of fixed strings one of
   which must occur in the match, then we build a kwset matcher
   to find those strings, and thus quickly filter out impossible
   matches. */
static void
kwsmusts (void)
{
  struct dfamust const *dm;
  char const *err;

  
//Patch 0:
if ((dfa.musts) && !(__is_neg(60, &(dfa.musts), sizeof (dfa.musts), &(dfa.musts), sizeof (dfa.musts), &(kwset), sizeof (kwset), &(dm), sizeof (dm), &(kwset_exact_matches), sizeof (kwset_exact_matches), &(err), sizeof (err), &(dfa.charclasses), sizeof (dfa.charclasses), &(dfa.cindex), sizeof (dfa.cindex), &(dfa.calloc), sizeof (dfa.calloc), &(dfa.tokens), sizeof (dfa.tokens), &(dfa.tindex), sizeof (dfa.tindex), &(dfa.talloc), sizeof (dfa.talloc), &(dfa.depth), sizeof (dfa.depth), &(dfa.nleaves), sizeof (dfa.nleaves), &(dfa.nregexps), sizeof (dfa.nregexps), &(dfa.mb_cur_max), sizeof (dfa.mb_cur_max), &(dfa.nmultibyte_prop), sizeof (dfa.nmultibyte_prop), &(dfa.multibyte_prop), sizeof (dfa.multibyte_prop), &(dfa.mbcsets), sizeof (dfa.mbcsets), &(dfa.nmbcsets), sizeof (dfa.nmbcsets), &(dfa.mbcsets_alloc), sizeof (dfa.mbcsets_alloc), &(dfa.states), sizeof (dfa.states), &(dfa.sindex), sizeof (dfa.sindex), &(dfa.salloc), sizeof (dfa.salloc), &(dfa.follows), sizeof (dfa.follows), &(dfa.searchflag), sizeof (dfa.searchflag), &(dfa.tralloc), sizeof (dfa.tralloc), &(dfa.trcount), sizeof (dfa.trcount), &(dfa.trans), sizeof (dfa.trans), &(dfa.realtrans), sizeof (dfa.realtrans), &(dfa.fails), sizeof (dfa.fails), &(dfa.success), sizeof (dfa.success), &(dfa.newlines), sizeof (dfa.newlines), &(dfa.charclasses), sizeof (dfa.charclasses), &(dfa.cindex), sizeof (dfa.cindex), &(dfa.calloc), sizeof (dfa.calloc), &(dfa.tokens), sizeof (dfa.tokens), &(dfa.tindex), sizeof (dfa.tindex), &(dfa.talloc), sizeof (dfa.talloc), &(dfa.depth), sizeof (dfa.depth), &(dfa.nleaves), sizeof (dfa.nleaves), &(dfa.nregexps), sizeof (dfa.nregexps), &(dfa.mb_cur_max), sizeof (dfa.mb_cur_max), &(dfa.nmultibyte_prop), sizeof (dfa.nmultibyte_prop), &(dfa.multibyte_prop), sizeof (dfa.multibyte_prop), &(dfa.mbcsets), sizeof (dfa.mbcsets), &(dfa.nmbcsets), sizeof (dfa.nmbcsets), &(dfa.mbcsets_alloc), sizeof (dfa.mbcsets_alloc), &(dfa.states), sizeof (dfa.states), &(dfa.sindex), sizeof (dfa.sindex), &(dfa.salloc), sizeof (dfa.salloc), &(dfa.follows), sizeof (dfa.follows), &(dfa.searchflag), sizeof (dfa.searchflag), &(dfa.tralloc), sizeof (dfa.tralloc), &(dfa.trcount), sizeof (dfa.trcount), &(dfa.trans), sizeof (dfa.trans), &(dfa.realtrans), sizeof (dfa.realtrans), &(dfa.fails), sizeof (dfa.fails), &(dfa.success), sizeof (dfa.success), &(dfa.newlines), sizeof (dfa.newlines)))) {
    kwsinit(&kwset);
    for (dm = dfa.musts; dm; dm = dm->next) {
        if (!dm->exact)
            continue;
        ++kwset_exact_matches;
        if ((err = kwsincr_case(dm->must)) != ((void *)0))
            error(EXIT_TROUBLE, 0, "%s", err);
    }
    for (dm = dfa.musts; dm; dm = dm->next) {
        if (dm->exact)
            continue;
        if ((err = kwsincr_case(dm->must)) != ((void *)0))
            error(EXIT_TROUBLE, 0, "%s", err);
    }
    if ((err = kwsprep(kwset)) != ((void *)0))
        error(EXIT_TROUBLE, 0, "%s", err);
}

//CodeSeg 1:
}

void
GEAcompile (char const *pattern, size_t size, reg_syntax_t syntax_bits)
{
  const char *err;
  const char *p, *sep;
  size_t total = size;
  char *motif;

  if (match_icase)
    syntax_bits |= RE_ICASE;
  re_set_syntax (syntax_bits);
  dfasyntax (syntax_bits, match_icase, eolbyte);

  /* For GNU regex compiler we have to pass the patterns separately to detect
     errors like "[\nallo\n]\n".  The patterns here are "[", "allo" and "]"
     GNU regex should have raise a syntax error.  The same for backref, where
     the backref should have been local to each pattern.  */
  p = pattern;
  do
    {
      size_t len;
      sep = memchr (p, '\n', total);
      if (sep)
	{
	  len = sep - p;
	  sep++;
	  total -= (len + 1);
	}
      else
	{
	  len = total;
	  total = 0;
	}

      patterns = realloc (patterns, (pcount + 1) * sizeof (*patterns));
      if (patterns == NULL)
	error (EXIT_TROUBLE, errno, _("memory exhausted"));
      patterns[pcount] = patterns0;

      if ((err = re_compile_pattern (p, len,
				    &(patterns[pcount].regexbuf))) != NULL)
	error (EXIT_TROUBLE, 0, "%s", err);
      pcount++;

      p = sep;
    } while (sep && total != 0);

  /* In the match_words and match_lines cases, we use a different pattern
     for the DFA matcher that will quickly throw out cases that won't work.
     Then if DFA succeeds we do some hairy stuff using the regex matcher
     to decide whether the match should really count. */
  if (match_words || match_lines)
    {
      static char const line_beg_no_bk[] = "^(";
      static char const line_end_no_bk[] = ")$";
      static char const word_beg_no_bk[] = "(^|[^[:alnum:]_])(";
      static char const word_end_no_bk[] = ")([^[:alnum:]_]|$)";
      static char const line_beg_bk[] = "^\\(";
      static char const line_end_bk[] = "\\)$";
      static char const word_beg_bk[] = "\\(^\\|[^[:alnum:]_]\\)\\(";
      static char const word_end_bk[] = "\\)\\([^[:alnum:]_]\\|$\\)";
      int bk = !(syntax_bits & RE_NO_BK_PARENS);
      char *n = xmalloc (sizeof word_beg_bk - 1 + size + sizeof word_end_bk);

      strcpy (n, match_lines ? (bk ? line_beg_bk : line_beg_no_bk)
			     : (bk ? word_beg_bk : word_beg_no_bk));
      total = strlen(n);
      memcpy (n + total, pattern, size);
      total += size;
      strcpy (n + total, match_lines ? (bk ? line_end_bk : line_end_no_bk)
				     : (bk ? word_end_bk : word_end_no_bk));
      total += strlen (n + total);
      pattern = motif = n;
      size = total;
    }
  else
    motif = NULL;

  dfacomp (pattern, size, &dfa, 1);
  kwsmusts ();

  free(motif);
}

size_t
EGexecute (char const *buf, size_t size, size_t *match_size,
	   char const *start_ptr)
{
  char const *buflim, *beg, *end, *match, *best_match, *mb_start;
  char eol = eolbyte;
  int backref, start, len, best_len;
  struct kwsmatch kwsm;
  size_t i, ret_val;
#ifdef MBS_SUPPORT
  if (MB_CUR_MAX > 1)
    {
      if (match_icase)
        {
          /* mbtolower adds a NUL byte at the end.  That will provide
	     space for the sentinel byte dfaexec may add.  */
          char *case_buf = mbtolower (buf, &size);
	  if (start_ptr)
	    start_ptr = case_buf + (start_ptr - buf);
          buf = case_buf;
        }
    }
#endif /* MBS_SUPPORT */

  mb_start = buf;
  buflim = buf + size;

  for (beg = end = buf; end < buflim; beg = end)
    {
      if (!start_ptr)
	{
	  /* We don't care about an exact match.  */
	  if (kwset)
	    {
	      /* Find a possible match using the KWset matcher. */
	      size_t offset = kwsexec (kwset, beg, buflim - beg, &kwsm);
	      if (offset == (size_t) -1)
		goto failure;
	      beg += offset;
	      /* Narrow down to the line containing the candidate, and
		 run it through DFA. */
	      if ((end = memchr(beg, eol, buflim - beg)) != NULL)
	        end++;
              else
                end = buflim;
	      match = beg;
	      while (beg > buf && beg[-1] != eol)
		--beg;
	      if (kwsm.index < kwset_exact_matches)
                {
#ifdef MBS_SUPPORT
                  if (mb_start < beg)
                    mb_start = beg;
                  if (MB_CUR_MAX == 1 || !is_mb_middle (&mb_start, match, buflim))
#endif
                    goto success;
                }
	      if (dfaexec (&dfa, beg, (char *) end, 0, NULL, &backref) == NULL)
		continue;
	    }
	  else
	    {
	      /* No good fixed strings; start with DFA. */
	      char const *next_beg = dfaexec (&dfa, beg, (char *) buflim,
					      0, NULL, &backref);
	      if (next_beg == NULL)
		break;
	      /* Narrow down to the line we've found. */
	      beg = next_beg;
	      if ((end = memchr(beg, eol, buflim - beg)) != NULL)
	        end++;
              else
                end = buflim;
	      while (beg > buf && beg[-1] != eol)
		--beg;
	    }
	  /* Successful, no backreferences encountered! */
	  if (!backref)
	    goto success;
	}
      else
	{
	  /* We are looking for the leftmost (then longest) exact match.
	     We will go through the outer loop only once.  */
	  beg = start_ptr;
	  end = buflim;
	}

      /* If we've made it to this point, this means DFA has seen
	 a probable match, and we need to run it through Regex. */
      best_match = end;
      best_len = 0;
      for (i = 0; i < pcount; i++)
	{
	  patterns[i].regexbuf.not_eol = 0;
	  if (0 <= (start = re_search (&(patterns[i].regexbuf),
				       buf, end - buf - 1,
				       beg - buf, end - beg - 1,
				       &(patterns[i].regs))))
	    {
	      len = patterns[i].regs.end[0] - start;
	      match = buf + start;
	      if (match > best_match)
		continue;
	      if (start_ptr && !match_words)
		goto assess_pattern_match;
	      if ((!match_lines && !match_words)
		  || (match_lines && len == end - beg - 1))
		{
		  match = beg;
		  len = end - beg;
		  goto assess_pattern_match;
		}
	      /* If -w, check if the match aligns with word boundaries.
		 We do this iteratively because:
		 (a) the line may contain more than one occurence of the
		 pattern, and
		 (b) Several alternatives in the pattern might be valid at a
		 given point, and we may need to consider a shorter one to
		 find a word boundary.  */
	      if (match_words)
		while (match <= best_match)
		  {
		    if ((match == buf || !WCHAR ((unsigned char) match[-1]))
			&& (len == end - beg - 1
			    || !WCHAR ((unsigned char) match[len])))
		      goto assess_pattern_match;
		    if (len > 0)
		      {
			/* Try a shorter length anchored at the same place. */
			--len;
			patterns[i].regexbuf.not_eol = 1;
			len = re_match (&(patterns[i].regexbuf),
					buf, match + len - beg, match - buf,
					&(patterns[i].regs));
		      }
		    if (len <= 0)
		      {
			/* Try looking further on. */
			if (match == end - 1)
			  break;
			match++;
			patterns[i].regexbuf.not_eol = 0;
			start = re_search (&(patterns[i].regexbuf),
					   buf, end - buf - 1,
					   match - buf, end - match - 1,
					   &(patterns[i].regs));
			if (start < 0)
			  break;
			len = patterns[i].regs.end[0] - start;
			match = buf + start;
		      }
		  } /* while (match <= best_match) */
	      continue;
	    assess_pattern_match:
	      if (!start_ptr)
		{
		  /* Good enough for a non-exact match.
		     No need to look at further patterns, if any.  */
		  beg = match;
		  goto success_in_len;
		}
	      if (match < best_match || (match == best_match && len > best_len))
		{
		  /* Best exact match:  leftmost, then longest.  */
		  best_match = match;
		  best_len = len;
		}
	    } /* if re_search >= 0 */
	} /* for Regex patterns.  */
	if (best_match < end)
	  {
	    /* We have found an exact match.  We were just
	       waiting for the best one (leftmost then longest).  */
	    beg = best_match;
	    len = best_len;
	    goto success_in_len;
	  }
    } /* for (beg = end ..) */

 failure:
  ret_val = -1;
  goto out;

 success:
  len = end - beg;
 success_in_len:
  *match_size = len;
  ret_val = beg - buf;
 out:
  return ret_val;
}

Testing negative cases!
Testing 0 (with abstract condition) ENVIS_NEG
Iteration 0
Running test command:
/home/ubuntu/spr-fast/tools/grep-test.py /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-8a025cf8-8f08d8e2/tempworkdir-l/src /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-8a025cf8-8f08d8e2/tempworkdir-l/tests /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-8a025cf8-8f08d8e2/tempworkdir-l 0  > __res
Opening:/tmp/neg.tmp!
NegativeBRANCH RECORD/tmp/neg.tmp!
APPENDING TO ISNEG:/tmp/neg.tmp!
Branch 0: 0
Iteration 1
Running test command:
/home/ubuntu/spr-fast/tools/grep-test.py /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-8a025cf8-8f08d8e2/tempworkdir-l/src /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-8a025cf8-8f08d8e2/tempworkdir-l/tests /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-8a025cf8-8f08d8e2/tempworkdir-l 0  > __res
Opening:/tmp/neg.tmp!
NegativeBRANCH RECORD/tmp/neg.tmp!
APPENDING TO ISNEG:/tmp/neg.tmp!
Branch 0: 1
Running test command:
/home/ubuntu/spr-fast/tools/grep-test.py /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-8a025cf8-8f08d8e2/tempworkdir-l/src /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-8a025cf8-8f08d8e2/tempworkdir-l/tests /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-8a025cf8-8f08d8e2/tempworkdir-l 0  > __res
CondTester, Testing instance id 25:
//src_file:src/dfasearch.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); void* memset(void*, int, unsigned long); 
/* dfasearch.c - searching subroutines using dfa and regex for grep.
   Copyright 1992, 1998, 2000, 2007, 2009-2010 Free Software Foundation, Inc.

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 3, or (at your option)
   any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program; if not, write to the Free Software
   Foundation, Inc., 51 Franklin Street - Fifth Floor, Boston, MA
   02110-1301, USA.  */

/* Written August 1992 by Mike Haertel. */

#include <config.h>
#include "search.h"
#include "dfa.h"

/* For -w, we also consider _ to be word constituent.  */
#define WCHAR(C) (ISALNUM(C) || (C) == '_')

/* KWset compiled pattern.  For Ecompile and Gcompile, we compile
   a list of strings, at least one of which is known to occur in
   any string matching the regexp. */
static kwset_t kwset;

/* DFA compiled regexp. */
static struct dfa dfa;

/* The Regex compiled patterns.  */
static struct patterns
{
  /* Regex compiled regexp. */
  struct re_pattern_buffer regexbuf;
  struct re_registers regs; /* This is here on account of a BRAIN-DEAD
			       Q@#%!# library interface in regex.c.  */
} patterns0;

struct patterns *patterns;
size_t pcount;

void
dfaerror (char const *mesg)
{
  error (EXIT_TROUBLE, 0, "%s", mesg);

  /* notreached */
  /* Tell static analyzers that this function does not return.  */
  abort ();
}

/* Number of compiled fixed strings known to exactly match the regexp.
   If kwsexec returns < kwset_exact_matches, then we don't need to
   call the regexp matcher at all. */
static int kwset_exact_matches;

static char const *
kwsincr_case (const char *must)
{
  const char *buf;
  size_t n;

  n = strlen (must);
#ifdef MBS_SUPPORT
  if (match_icase && MB_CUR_MAX > 1)
    buf = mbtolower (must, &n);
  else
#endif
    buf = must;
  return kwsincr (kwset, buf, n);
}

/* If the DFA turns out to have some set of fixed strings one of
   which must occur in the match, then we build a kwset matcher
   to find those strings, and thus quickly filter out impossible
   matches. */
static void
kwsmusts (void)
{
  struct dfamust const *dm;
  char const *err;

  
//Patch 0:
if ((dfa.musts) || (__is_neg(60, &(dfa.musts), sizeof (dfa.musts), &(dfa.musts), sizeof (dfa.musts), &(kwset), sizeof (kwset), &(dm), sizeof (dm), &(kwset_exact_matches), sizeof (kwset_exact_matches), &(err), sizeof (err), &(dfa.charclasses), sizeof (dfa.charclasses), &(dfa.cindex), sizeof (dfa.cindex), &(dfa.calloc), sizeof (dfa.calloc), &(dfa.tokens), sizeof (dfa.tokens), &(dfa.tindex), sizeof (dfa.tindex), &(dfa.talloc), sizeof (dfa.talloc), &(dfa.depth), sizeof (dfa.depth), &(dfa.nleaves), sizeof (dfa.nleaves), &(dfa.nregexps), sizeof (dfa.nregexps), &(dfa.mb_cur_max), sizeof (dfa.mb_cur_max), &(dfa.nmultibyte_prop), sizeof (dfa.nmultibyte_prop), &(dfa.multibyte_prop), sizeof (dfa.multibyte_prop), &(dfa.mbcsets), sizeof (dfa.mbcsets), &(dfa.nmbcsets), sizeof (dfa.nmbcsets), &(dfa.mbcsets_alloc), sizeof (dfa.mbcsets_alloc), &(dfa.states), sizeof (dfa.states), &(dfa.sindex), sizeof (dfa.sindex), &(dfa.salloc), sizeof (dfa.salloc), &(dfa.follows), sizeof (dfa.follows), &(dfa.searchflag), sizeof (dfa.searchflag), &(dfa.tralloc), sizeof (dfa.tralloc), &(dfa.trcount), sizeof (dfa.trcount), &(dfa.trans), sizeof (dfa.trans), &(dfa.realtrans), sizeof (dfa.realtrans), &(dfa.fails), sizeof (dfa.fails), &(dfa.success), sizeof (dfa.success), &(dfa.newlines), sizeof (dfa.newlines), &(dfa.charclasses), sizeof (dfa.charclasses), &(dfa.cindex), sizeof (dfa.cindex), &(dfa.calloc), sizeof (dfa.calloc), &(dfa.tokens), sizeof (dfa.tokens), &(dfa.tindex), sizeof (dfa.tindex), &(dfa.talloc), sizeof (dfa.talloc), &(dfa.depth), sizeof (dfa.depth), &(dfa.nleaves), sizeof (dfa.nleaves), &(dfa.nregexps), sizeof (dfa.nregexps), &(dfa.mb_cur_max), sizeof (dfa.mb_cur_max), &(dfa.nmultibyte_prop), sizeof (dfa.nmultibyte_prop), &(dfa.multibyte_prop), sizeof (dfa.multibyte_prop), &(dfa.mbcsets), sizeof (dfa.mbcsets), &(dfa.nmbcsets), sizeof (dfa.nmbcsets), &(dfa.mbcsets_alloc), sizeof (dfa.mbcsets_alloc), &(dfa.states), sizeof (dfa.states), &(dfa.sindex), sizeof (dfa.sindex), &(dfa.salloc), sizeof (dfa.salloc), &(dfa.follows), sizeof (dfa.follows), &(dfa.searchflag), sizeof (dfa.searchflag), &(dfa.tralloc), sizeof (dfa.tralloc), &(dfa.trcount), sizeof (dfa.trcount), &(dfa.trans), sizeof (dfa.trans), &(dfa.realtrans), sizeof (dfa.realtrans), &(dfa.fails), sizeof (dfa.fails), &(dfa.success), sizeof (dfa.success), &(dfa.newlines), sizeof (dfa.newlines)))) {
    kwsinit(&kwset);
    for (dm = dfa.musts; dm; dm = dm->next) {
        if (!dm->exact)
            continue;
        ++kwset_exact_matches;
        if ((err = kwsincr_case(dm->must)) != ((void *)0))
            error(EXIT_TROUBLE, 0, "%s", err);
    }
    for (dm = dfa.musts; dm; dm = dm->next) {
        if (dm->exact)
            continue;
        if ((err = kwsincr_case(dm->must)) != ((void *)0))
            error(EXIT_TROUBLE, 0, "%s", err);
    }
    if ((err = kwsprep(kwset)) != ((void *)0))
        error(EXIT_TROUBLE, 0, "%s", err);
}

//CodeSeg 1:
}

void
GEAcompile (char const *pattern, size_t size, reg_syntax_t syntax_bits)
{
  const char *err;
  const char *p, *sep;
  size_t total = size;
  char *motif;

  if (match_icase)
    syntax_bits |= RE_ICASE;
  re_set_syntax (syntax_bits);
  dfasyntax (syntax_bits, match_icase, eolbyte);

  /* For GNU regex compiler we have to pass the patterns separately to detect
     errors like "[\nallo\n]\n".  The patterns here are "[", "allo" and "]"
     GNU regex should have raise a syntax error.  The same for backref, where
     the backref should have been local to each pattern.  */
  p = pattern;
  do
    {
      size_t len;
      sep = memchr (p, '\n', total);
      if (sep)
	{
	  len = sep - p;
	  sep++;
	  total -= (len + 1);
	}
      else
	{
	  len = total;
	  total = 0;
	}

      patterns = realloc (patterns, (pcount + 1) * sizeof (*patterns));
      if (patterns == NULL)
	error (EXIT_TROUBLE, errno, _("memory exhausted"));
      patterns[pcount] = patterns0;

      if ((err = re_compile_pattern (p, len,
				    &(patterns[pcount].regexbuf))) != NULL)
	error (EXIT_TROUBLE, 0, "%s", err);
      pcount++;

      p = sep;
    } while (sep && total != 0);

  /* In the match_words and match_lines cases, we use a different pattern
     for the DFA matcher that will quickly throw out cases that won't work.
     Then if DFA succeeds we do some hairy stuff using the regex matcher
     to decide whether the match should really count. */
  if (match_words || match_lines)
    {
      static char const line_beg_no_bk[] = "^(";
      static char const line_end_no_bk[] = ")$";
      static char const word_beg_no_bk[] = "(^|[^[:alnum:]_])(";
      static char const word_end_no_bk[] = ")([^[:alnum:]_]|$)";
      static char const line_beg_bk[] = "^\\(";
      static char const line_end_bk[] = "\\)$";
      static char const word_beg_bk[] = "\\(^\\|[^[:alnum:]_]\\)\\(";
      static char const word_end_bk[] = "\\)\\([^[:alnum:]_]\\|$\\)";
      int bk = !(syntax_bits & RE_NO_BK_PARENS);
      char *n = xmalloc (sizeof word_beg_bk - 1 + size + sizeof word_end_bk);

      strcpy (n, match_lines ? (bk ? line_beg_bk : line_beg_no_bk)
			     : (bk ? word_beg_bk : word_beg_no_bk));
      total = strlen(n);
      memcpy (n + total, pattern, size);
      total += size;
      strcpy (n + total, match_lines ? (bk ? line_end_bk : line_end_no_bk)
				     : (bk ? word_end_bk : word_end_no_bk));
      total += strlen (n + total);
      pattern = motif = n;
      size = total;
    }
  else
    motif = NULL;

  dfacomp (pattern, size, &dfa, 1);
  kwsmusts ();

  free(motif);
}

size_t
EGexecute (char const *buf, size_t size, size_t *match_size,
	   char const *start_ptr)
{
  char const *buflim, *beg, *end, *match, *best_match, *mb_start;
  char eol = eolbyte;
  int backref, start, len, best_len;
  struct kwsmatch kwsm;
  size_t i, ret_val;
#ifdef MBS_SUPPORT
  if (MB_CUR_MAX > 1)
    {
      if (match_icase)
        {
          /* mbtolower adds a NUL byte at the end.  That will provide
	     space for the sentinel byte dfaexec may add.  */
          char *case_buf = mbtolower (buf, &size);
	  if (start_ptr)
	    start_ptr = case_buf + (start_ptr - buf);
          buf = case_buf;
        }
    }
#endif /* MBS_SUPPORT */

  mb_start = buf;
  buflim = buf + size;

  for (beg = end = buf; end < buflim; beg = end)
    {
      if (!start_ptr)
	{
	  /* We don't care about an exact match.  */
	  if (kwset)
	    {
	      /* Find a possible match using the KWset matcher. */
	      size_t offset = kwsexec (kwset, beg, buflim - beg, &kwsm);
	      if (offset == (size_t) -1)
		goto failure;
	      beg += offset;
	      /* Narrow down to the line containing the candidate, and
		 run it through DFA. */
	      if ((end = memchr(beg, eol, buflim - beg)) != NULL)
	        end++;
              else
                end = buflim;
	      match = beg;
	      while (beg > buf && beg[-1] != eol)
		--beg;
	      if (kwsm.index < kwset_exact_matches)
                {
#ifdef MBS_SUPPORT
                  if (mb_start < beg)
                    mb_start = beg;
                  if (MB_CUR_MAX == 1 || !is_mb_middle (&mb_start, match, buflim))
#endif
                    goto success;
                }
	      if (dfaexec (&dfa, beg, (char *) end, 0, NULL, &backref) == NULL)
		continue;
	    }
	  else
	    {
	      /* No good fixed strings; start with DFA. */
	      char const *next_beg = dfaexec (&dfa, beg, (char *) buflim,
					      0, NULL, &backref);
	      if (next_beg == NULL)
		break;
	      /* Narrow down to the line we've found. */
	      beg = next_beg;
	      if ((end = memchr(beg, eol, buflim - beg)) != NULL)
	        end++;
              else
                end = buflim;
	      while (beg > buf && beg[-1] != eol)
		--beg;
	    }
	  /* Successful, no backreferences encountered! */
	  if (!backref)
	    goto success;
	}
      else
	{
	  /* We are looking for the leftmost (then longest) exact match.
	     We will go through the outer loop only once.  */
	  beg = start_ptr;
	  end = buflim;
	}

      /* If we've made it to this point, this means DFA has seen
	 a probable match, and we need to run it through Regex. */
      best_match = end;
      best_len = 0;
      for (i = 0; i < pcount; i++)
	{
	  patterns[i].regexbuf.not_eol = 0;
	  if (0 <= (start = re_search (&(patterns[i].regexbuf),
				       buf, end - buf - 1,
				       beg - buf, end - beg - 1,
				       &(patterns[i].regs))))
	    {
	      len = patterns[i].regs.end[0] - start;
	      match = buf + start;
	      if (match > best_match)
		continue;
	      if (start_ptr && !match_words)
		goto assess_pattern_match;
	      if ((!match_lines && !match_words)
		  || (match_lines && len == end - beg - 1))
		{
		  match = beg;
		  len = end - beg;
		  goto assess_pattern_match;
		}
	      /* If -w, check if the match aligns with word boundaries.
		 We do this iteratively because:
		 (a) the line may contain more than one occurence of the
		 pattern, and
		 (b) Several alternatives in the pattern might be valid at a
		 given point, and we may need to consider a shorter one to
		 find a word boundary.  */
	      if (match_words)
		while (match <= best_match)
		  {
		    if ((match == buf || !WCHAR ((unsigned char) match[-1]))
			&& (len == end - beg - 1
			    || !WCHAR ((unsigned char) match[len])))
		      goto assess_pattern_match;
		    if (len > 0)
		      {
			/* Try a shorter length anchored at the same place. */
			--len;
			patterns[i].regexbuf.not_eol = 1;
			len = re_match (&(patterns[i].regexbuf),
					buf, match + len - beg, match - buf,
					&(patterns[i].regs));
		      }
		    if (len <= 0)
		      {
			/* Try looking further on. */
			if (match == end - 1)
			  break;
			match++;
			patterns[i].regexbuf.not_eol = 0;
			start = re_search (&(patterns[i].regexbuf),
					   buf, end - buf - 1,
					   match - buf, end - match - 1,
					   &(patterns[i].regs));
			if (start < 0)
			  break;
			len = patterns[i].regs.end[0] - start;
			match = buf + start;
		      }
		  } /* while (match <= best_match) */
	      continue;
	    assess_pattern_match:
	      if (!start_ptr)
		{
		  /* Good enough for a non-exact match.
		     No need to look at further patterns, if any.  */
		  beg = match;
		  goto success_in_len;
		}
	      if (match < best_match || (match == best_match && len > best_len))
		{
		  /* Best exact match:  leftmost, then longest.  */
		  best_match = match;
		  best_len = len;
		}
	    } /* if re_search >= 0 */
	} /* for Regex patterns.  */
	if (best_match < end)
	  {
	    /* We have found an exact match.  We were just
	       waiting for the best one (leftmost then longest).  */
	    beg = best_match;
	    len = best_len;
	    goto success_in_len;
	  }
    } /* for (beg = end ..) */

 failure:
  ret_val = -1;
  goto out;

 success:
  len = end - beg;
 success_in_len:
  *match_size = len;
  ret_val = beg - buf;
 out:
  return ret_val;
}

Testing negative cases!
Testing 0 (with abstract condition) ENVIS_NEG
Iteration 0
Running test command:
/home/ubuntu/spr-fast/tools/grep-test.py /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-8a025cf8-8f08d8e2/tempworkdir-l/src /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-8a025cf8-8f08d8e2/tempworkdir-l/tests /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-8a025cf8-8f08d8e2/tempworkdir-l 0  > __res
Opening:/tmp/neg.tmp!
NegativeBRANCH RECORD/tmp/neg.tmp!
Not caught by the negative case, give up!
APPENDING TO ISNEG:/tmp/neg.tmp!
Running test command:
/home/ubuntu/spr-fast/tools/grep-test.py /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-8a025cf8-8f08d8e2/tempworkdir-l/src /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-8a025cf8-8f08d8e2/tempworkdir-l/tests /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-8a025cf8-8f08d8e2/tempworkdir-l 0  > __res
CondTester, Testing instance id 97:
//src_file:src/dfasearch.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); void* memset(void*, int, unsigned long); 
/* dfasearch.c - searching subroutines using dfa and regex for grep.
   Copyright 1992, 1998, 2000, 2007, 2009-2010 Free Software Foundation, Inc.

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 3, or (at your option)
   any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program; if not, write to the Free Software
   Foundation, Inc., 51 Franklin Street - Fifth Floor, Boston, MA
   02110-1301, USA.  */

/* Written August 1992 by Mike Haertel. */

#include <config.h>
#include "search.h"
#include "dfa.h"

/* For -w, we also consider _ to be word constituent.  */
#define WCHAR(C) (ISALNUM(C) || (C) == '_')

/* KWset compiled pattern.  For Ecompile and Gcompile, we compile
   a list of strings, at least one of which is known to occur in
   any string matching the regexp. */
static kwset_t kwset;

/* DFA compiled regexp. */
static struct dfa dfa;

/* The Regex compiled patterns.  */
static struct patterns
{
  /* Regex compiled regexp. */
  struct re_pattern_buffer regexbuf;
  struct re_registers regs; /* This is here on account of a BRAIN-DEAD
			       Q@#%!# library interface in regex.c.  */
} patterns0;

struct patterns *patterns;
size_t pcount;

void
dfaerror (char const *mesg)
{
  error (EXIT_TROUBLE, 0, "%s", mesg);

  /* notreached */
  /* Tell static analyzers that this function does not return.  */
  abort ();
}

/* Number of compiled fixed strings known to exactly match the regexp.
   If kwsexec returns < kwset_exact_matches, then we don't need to
   call the regexp matcher at all. */
static int kwset_exact_matches;

static char const *
kwsincr_case (const char *must)
{
  const char *buf;
  size_t n;

  n = strlen (must);
#ifdef MBS_SUPPORT
  if (match_icase && MB_CUR_MAX > 1)
    buf = mbtolower (must, &n);
  else
#endif
    buf = must;
  return kwsincr (kwset, buf, n);
}

/* If the DFA turns out to have some set of fixed strings one of
   which must occur in the match, then we build a kwset matcher
   to find those strings, and thus quickly filter out impossible
   matches. */
static void
kwsmusts (void)
{
  struct dfamust const *dm;
  char const *err;

  
//Patch 0:
if ((__is_neg(60, &(dfa.musts), sizeof (dfa.musts), &(dfa.musts), sizeof (dfa.musts), &(kwset), sizeof (kwset), &(dm), sizeof (dm), &(kwset_exact_matches), sizeof (kwset_exact_matches), &(err), sizeof (err), &(dfa.charclasses), sizeof (dfa.charclasses), &(dfa.cindex), sizeof (dfa.cindex), &(dfa.calloc), sizeof (dfa.calloc), &(dfa.tokens), sizeof (dfa.tokens), &(dfa.tindex), sizeof (dfa.tindex), &(dfa.talloc), sizeof (dfa.talloc), &(dfa.depth), sizeof (dfa.depth), &(dfa.nleaves), sizeof (dfa.nleaves), &(dfa.nregexps), sizeof (dfa.nregexps), &(dfa.mb_cur_max), sizeof (dfa.mb_cur_max), &(dfa.nmultibyte_prop), sizeof (dfa.nmultibyte_prop), &(dfa.multibyte_prop), sizeof (dfa.multibyte_prop), &(dfa.mbcsets), sizeof (dfa.mbcsets), &(dfa.nmbcsets), sizeof (dfa.nmbcsets), &(dfa.mbcsets_alloc), sizeof (dfa.mbcsets_alloc), &(dfa.states), sizeof (dfa.states), &(dfa.sindex), sizeof (dfa.sindex), &(dfa.salloc), sizeof (dfa.salloc), &(dfa.follows), sizeof (dfa.follows), &(dfa.searchflag), sizeof (dfa.searchflag), &(dfa.tralloc), sizeof (dfa.tralloc), &(dfa.trcount), sizeof (dfa.trcount), &(dfa.trans), sizeof (dfa.trans), &(dfa.realtrans), sizeof (dfa.realtrans), &(dfa.fails), sizeof (dfa.fails), &(dfa.success), sizeof (dfa.success), &(dfa.newlines), sizeof (dfa.newlines), &(dfa.charclasses), sizeof (dfa.charclasses), &(dfa.cindex), sizeof (dfa.cindex), &(dfa.calloc), sizeof (dfa.calloc), &(dfa.tokens), sizeof (dfa.tokens), &(dfa.tindex), sizeof (dfa.tindex), &(dfa.talloc), sizeof (dfa.talloc), &(dfa.depth), sizeof (dfa.depth), &(dfa.nleaves), sizeof (dfa.nleaves), &(dfa.nregexps), sizeof (dfa.nregexps), &(dfa.mb_cur_max), sizeof (dfa.mb_cur_max), &(dfa.nmultibyte_prop), sizeof (dfa.nmultibyte_prop), &(dfa.multibyte_prop), sizeof (dfa.multibyte_prop), &(dfa.mbcsets), sizeof (dfa.mbcsets), &(dfa.nmbcsets), sizeof (dfa.nmbcsets), &(dfa.mbcsets_alloc), sizeof (dfa.mbcsets_alloc), &(dfa.states), sizeof (dfa.states), &(dfa.sindex), sizeof (dfa.sindex), &(dfa.salloc), sizeof (dfa.salloc), &(dfa.follows), sizeof (dfa.follows), &(dfa.searchflag), sizeof (dfa.searchflag), &(dfa.tralloc), sizeof (dfa.tralloc), &(dfa.trcount), sizeof (dfa.trcount), &(dfa.trans), sizeof (dfa.trans), &(dfa.realtrans), sizeof (dfa.realtrans), &(dfa.fails), sizeof (dfa.fails), &(dfa.success), sizeof (dfa.success), &(dfa.newlines), sizeof (dfa.newlines))))
    return;
if (dfa.musts) {
    kwsinit(&kwset);
    for (dm = dfa.musts; dm; dm = dm->next) {
        if (!dm->exact)
            continue;
        ++kwset_exact_matches;
        if ((err = kwsincr_case(dm->must)) != ((void *)0))
            error(EXIT_TROUBLE, 0, "%s", err);
    }
    for (dm = dfa.musts; dm; dm = dm->next) {
        if (dm->exact)
            continue;
        if ((err = kwsincr_case(dm->must)) != ((void *)0))
            error(EXIT_TROUBLE, 0, "%s", err);
    }
    if ((err = kwsprep(kwset)) != ((void *)0))
        error(EXIT_TROUBLE, 0, "%s", err);
}

//CodeSeg 1:
}

void
GEAcompile (char const *pattern, size_t size, reg_syntax_t syntax_bits)
{
  const char *err;
  const char *p, *sep;
  size_t total = size;
  char *motif;

  if (match_icase)
    syntax_bits |= RE_ICASE;
  re_set_syntax (syntax_bits);
  dfasyntax (syntax_bits, match_icase, eolbyte);

  /* For GNU regex compiler we have to pass the patterns separately to detect
     errors like "[\nallo\n]\n".  The patterns here are "[", "allo" and "]"
     GNU regex should have raise a syntax error.  The same for backref, where
     the backref should have been local to each pattern.  */
  p = pattern;
  do
    {
      size_t len;
      sep = memchr (p, '\n', total);
      if (sep)
	{
	  len = sep - p;
	  sep++;
	  total -= (len + 1);
	}
      else
	{
	  len = total;
	  total = 0;
	}

      patterns = realloc (patterns, (pcount + 1) * sizeof (*patterns));
      if (patterns == NULL)
	error (EXIT_TROUBLE, errno, _("memory exhausted"));
      patterns[pcount] = patterns0;

      if ((err = re_compile_pattern (p, len,
				    &(patterns[pcount].regexbuf))) != NULL)
	error (EXIT_TROUBLE, 0, "%s", err);
      pcount++;

      p = sep;
    } while (sep && total != 0);

  /* In the match_words and match_lines cases, we use a different pattern
     for the DFA matcher that will quickly throw out cases that won't work.
     Then if DFA succeeds we do some hairy stuff using the regex matcher
     to decide whether the match should really count. */
  if (match_words || match_lines)
    {
      static char const line_beg_no_bk[] = "^(";
      static char const line_end_no_bk[] = ")$";
      static char const word_beg_no_bk[] = "(^|[^[:alnum:]_])(";
      static char const word_end_no_bk[] = ")([^[:alnum:]_]|$)";
      static char const line_beg_bk[] = "^\\(";
      static char const line_end_bk[] = "\\)$";
      static char const word_beg_bk[] = "\\(^\\|[^[:alnum:]_]\\)\\(";
      static char const word_end_bk[] = "\\)\\([^[:alnum:]_]\\|$\\)";
      int bk = !(syntax_bits & RE_NO_BK_PARENS);
      char *n = xmalloc (sizeof word_beg_bk - 1 + size + sizeof word_end_bk);

      strcpy (n, match_lines ? (bk ? line_beg_bk : line_beg_no_bk)
			     : (bk ? word_beg_bk : word_beg_no_bk));
      total = strlen(n);
      memcpy (n + total, pattern, size);
      total += size;
      strcpy (n + total, match_lines ? (bk ? line_end_bk : line_end_no_bk)
				     : (bk ? word_end_bk : word_end_no_bk));
      total += strlen (n + total);
      pattern = motif = n;
      size = total;
    }
  else
    motif = NULL;

  dfacomp (pattern, size, &dfa, 1);
  kwsmusts ();

  free(motif);
}

size_t
EGexecute (char const *buf, size_t size, size_t *match_size,
	   char const *start_ptr)
{
  char const *buflim, *beg, *end, *match, *best_match, *mb_start;
  char eol = eolbyte;
  int backref, start, len, best_len;
  struct kwsmatch kwsm;
  size_t i, ret_val;
#ifdef MBS_SUPPORT
  if (MB_CUR_MAX > 1)
    {
      if (match_icase)
        {
          /* mbtolower adds a NUL byte at the end.  That will provide
	     space for the sentinel byte dfaexec may add.  */
          char *case_buf = mbtolower (buf, &size);
	  if (start_ptr)
	    start_ptr = case_buf + (start_ptr - buf);
          buf = case_buf;
        }
    }
#endif /* MBS_SUPPORT */

  mb_start = buf;
  buflim = buf + size;

  for (beg = end = buf; end < buflim; beg = end)
    {
      if (!start_ptr)
	{
	  /* We don't care about an exact match.  */
	  if (kwset)
	    {
	      /* Find a possible match using the KWset matcher. */
	      size_t offset = kwsexec (kwset, beg, buflim - beg, &kwsm);
	      if (offset == (size_t) -1)
		goto failure;
	      beg += offset;
	      /* Narrow down to the line containing the candidate, and
		 run it through DFA. */
	      if ((end = memchr(beg, eol, buflim - beg)) != NULL)
	        end++;
              else
                end = buflim;
	      match = beg;
	      while (beg > buf && beg[-1] != eol)
		--beg;
	      if (kwsm.index < kwset_exact_matches)
                {
#ifdef MBS_SUPPORT
                  if (mb_start < beg)
                    mb_start = beg;
                  if (MB_CUR_MAX == 1 || !is_mb_middle (&mb_start, match, buflim))
#endif
                    goto success;
                }
	      if (dfaexec (&dfa, beg, (char *) end, 0, NULL, &backref) == NULL)
		continue;
	    }
	  else
	    {
	      /* No good fixed strings; start with DFA. */
	      char const *next_beg = dfaexec (&dfa, beg, (char *) buflim,
					      0, NULL, &backref);
	      if (next_beg == NULL)
		break;
	      /* Narrow down to the line we've found. */
	      beg = next_beg;
	      if ((end = memchr(beg, eol, buflim - beg)) != NULL)
	        end++;
              else
                end = buflim;
	      while (beg > buf && beg[-1] != eol)
		--beg;
	    }
	  /* Successful, no backreferences encountered! */
	  if (!backref)
	    goto success;
	}
      else
	{
	  /* We are looking for the leftmost (then longest) exact match.
	     We will go through the outer loop only once.  */
	  beg = start_ptr;
	  end = buflim;
	}

      /* If we've made it to this point, this means DFA has seen
	 a probable match, and we need to run it through Regex. */
      best_match = end;
      best_len = 0;
      for (i = 0; i < pcount; i++)
	{
	  patterns[i].regexbuf.not_eol = 0;
	  if (0 <= (start = re_search (&(patterns[i].regexbuf),
				       buf, end - buf - 1,
				       beg - buf, end - beg - 1,
				       &(patterns[i].regs))))
	    {
	      len = patterns[i].regs.end[0] - start;
	      match = buf + start;
	      if (match > best_match)
		continue;
	      if (start_ptr && !match_words)
		goto assess_pattern_match;
	      if ((!match_lines && !match_words)
		  || (match_lines && len == end - beg - 1))
		{
		  match = beg;
		  len = end - beg;
		  goto assess_pattern_match;
		}
	      /* If -w, check if the match aligns with word boundaries.
		 We do this iteratively because:
		 (a) the line may contain more than one occurence of the
		 pattern, and
		 (b) Several alternatives in the pattern might be valid at a
		 given point, and we may need to consider a shorter one to
		 find a word boundary.  */
	      if (match_words)
		while (match <= best_match)
		  {
		    if ((match == buf || !WCHAR ((unsigned char) match[-1]))
			&& (len == end - beg - 1
			    || !WCHAR ((unsigned char) match[len])))
		      goto assess_pattern_match;
		    if (len > 0)
		      {
			/* Try a shorter length anchored at the same place. */
			--len;
			patterns[i].regexbuf.not_eol = 1;
			len = re_match (&(patterns[i].regexbuf),
					buf, match + len - beg, match - buf,
					&(patterns[i].regs));
		      }
		    if (len <= 0)
		      {
			/* Try looking further on. */
			if (match == end - 1)
			  break;
			match++;
			patterns[i].regexbuf.not_eol = 0;
			start = re_search (&(patterns[i].regexbuf),
					   buf, end - buf - 1,
					   match - buf, end - match - 1,
					   &(patterns[i].regs));
			if (start < 0)
			  break;
			len = patterns[i].regs.end[0] - start;
			match = buf + start;
		      }
		  } /* while (match <= best_match) */
	      continue;
	    assess_pattern_match:
	      if (!start_ptr)
		{
		  /* Good enough for a non-exact match.
		     No need to look at further patterns, if any.  */
		  beg = match;
		  goto success_in_len;
		}
	      if (match < best_match || (match == best_match && len > best_len))
		{
		  /* Best exact match:  leftmost, then longest.  */
		  best_match = match;
		  best_len = len;
		}
	    } /* if re_search >= 0 */
	} /* for Regex patterns.  */
	if (best_match < end)
	  {
	    /* We have found an exact match.  We were just
	       waiting for the best one (leftmost then longest).  */
	    beg = best_match;
	    len = best_len;
	    goto success_in_len;
	  }
    } /* for (beg = end ..) */

 failure:
  ret_val = -1;
  goto out;

 success:
  len = end - beg;
 success_in_len:
  *match_size = len;
  ret_val = beg - buf;
 out:
  return ret_val;
}

Testing negative cases!
Testing 0 (with abstract condition) ENVIS_NEG
Iteration 0
Running test command:
/home/ubuntu/spr-fast/tools/grep-test.py /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-8a025cf8-8f08d8e2/tempworkdir-l/src /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-8a025cf8-8f08d8e2/tempworkdir-l/tests /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-8a025cf8-8f08d8e2/tempworkdir-l 0  > __res
Opening:/tmp/neg.tmp!
NegativeBRANCH RECORD/tmp/neg.tmp!
APPENDING TO ISNEG:/tmp/neg.tmp!
Branch 0: 0
Iteration 1
Running test command:
/home/ubuntu/spr-fast/tools/grep-test.py /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-8a025cf8-8f08d8e2/tempworkdir-l/src /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-8a025cf8-8f08d8e2/tempworkdir-l/tests /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-8a025cf8-8f08d8e2/tempworkdir-l 0  > __res
Opening:/tmp/neg.tmp!
NegativeBRANCH RECORD/tmp/neg.tmp!
APPENDING TO ISNEG:/tmp/neg.tmp!
Branch 0: 1
Running test command:
/home/ubuntu/spr-fast/tools/grep-test.py /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-8a025cf8-8f08d8e2/tempworkdir-l/src /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-8a025cf8-8f08d8e2/tempworkdir-l/tests /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-8a025cf8-8f08d8e2/tempworkdir-l 0  > __res
a batched test job starts!
Building merged code:
src_file: src/dfasearch.c
full src: int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); void* memset(void*, int, unsigned long); 
/* dfasearch.c - searching subroutines using dfa and regex for grep.
   Copyright 1992, 1998, 2000, 2007, 2009-2010 Free Software Foundation, Inc.

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 3, or (at your option)
   any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program; if not, write to the Free Software
   Foundation, Inc., 51 Franklin Street - Fifth Floor, Boston, MA
   02110-1301, USA.  */

/* Written August 1992 by Mike Haertel. */

#include <config.h>
#include "search.h"
#include "dfa.h"

/* For -w, we also consider _ to be word constituent.  */
#define WCHAR(C) (ISALNUM(C) || (C) == '_')

/* KWset compiled pattern.  For Ecompile and Gcompile, we compile
   a list of strings, at least one of which is known to occur in
   any string matching the regexp. */
static kwset_t kwset;

/* DFA compiled regexp. */
static struct dfa dfa;

/* The Regex compiled patterns.  */
static struct patterns
{
  /* Regex compiled regexp. */
  struct re_pattern_buffer regexbuf;
  struct re_registers regs; /* This is here on account of a BRAIN-DEAD
			       Q@#%!# library interface in regex.c.  */
} patterns0;

struct patterns *patterns;
size_t pcount;

void
dfaerror (char const *mesg)
{
  error (EXIT_TROUBLE, 0, "%s", mesg);

  /* notreached */
  /* Tell static analyzers that this function does not return.  */
  abort ();
}

/* Number of compiled fixed strings known to exactly match the regexp.
   If kwsexec returns < kwset_exact_matches, then we don't need to
   call the regexp matcher at all. */
static int kwset_exact_matches;

static char const *
kwsincr_case (const char *must)
{
  const char *buf;
  size_t n;

  n = strlen (must);
#ifdef MBS_SUPPORT
  if (match_icase && MB_CUR_MAX > 1)
    buf = mbtolower (must, &n);
  else
#endif
    buf = must;
  return kwsincr (kwset, buf, n);
}

/* If the DFA turns out to have some set of fixed strings one of
   which must occur in the match, then we build a kwset matcher
   to find those strings, and thus quickly filter out impossible
   matches. */
static void
kwsmusts (void)
{
  struct dfamust const *dm;
  char const *err;

  if (dfa.musts)
    {
      kwsinit (&kwset);
      /* First, we compile in the substrings known to be exact
	 matches.  The kwset matcher will return the index
	 of the matching string that it chooses. */
      for (dm = dfa.musts; dm; dm = dm->next)
	{
	  //prophet generated patch
	  if (__get_mutant()==0) {
	  if ((!dm->exact) && !(__is_neg(7, &(dm), sizeof (dm), &(dm->exact), sizeof (dm->exact), &(kwset_exact_matches), sizeof (kwset_exact_matches), &(dm->next), sizeof (dm->next), &(err), sizeof (err), &(dm->must), sizeof (dm->must), &(kwset), sizeof (kwset))))
	      continue;
	  }
	  else if (__get_mutant()==1) {
	  if ((!dm->exact) || (__is_neg(7, &(dm), sizeof (dm), &(dm->exact), sizeof (dm->exact), &(kwset_exact_matches), sizeof (kwset_exact_matches), &(dm->next), sizeof (dm->next), &(err), sizeof (err), &(dm->must), sizeof (dm->must), &(kwset), sizeof (kwset))))
	      continue;
	  }
	  ++kwset_exact_matches;
	  if ((err = kwsincr_case (dm->must)) != NULL)
	    error (EXIT_TROUBLE, 0, "%s", err);
	}
      /* Now, we compile the substrings that will require
	 the use of the regexp matcher.  */
      for (dm = dfa.musts; dm; dm = dm->next)
	{
	  if (dm->exact)
	    continue;
	  if ((err = kwsincr_case (dm->must)) != NULL)
	    error (EXIT_TROUBLE, 0, "%s", err);
	}
      if ((err = kwsprep (kwset)) != NULL)
	error (EXIT_TROUBLE, 0, "%s", err);
    }
}

void
GEAcompile (char const *pattern, size_t size, reg_syntax_t syntax_bits)
{
  const char *err;
  const char *p, *sep;
  size_t total = size;
  char *motif;

  if (match_icase)
    syntax_bits |= RE_ICASE;
  re_set_syntax (syntax_bits);
  dfasyntax (syntax_bits, match_icase, eolbyte);

  /* For GNU regex compiler we have to pass the patterns separately to detect
     errors like "[\nallo\n]\n".  The patterns here are "[", "allo" and "]"
     GNU regex should have raise a syntax error.  The same for backref, where
     the backref should have been local to each pattern.  */
  p = pattern;
  do
    {
      size_t len;
      sep = memchr (p, '\n', total);
      if (sep)
	{
	  len = sep - p;
	  sep++;
	  total -= (len + 1);
	}
      else
	{
	  len = total;
	  total = 0;
	}

      patterns = realloc (patterns, (pcount + 1) * sizeof (*patterns));
      if (patterns == NULL)
	error (EXIT_TROUBLE, errno, _("memory exhausted"));
      patterns[pcount] = patterns0;

      if ((err = re_compile_pattern (p, len,
				    &(patterns[pcount].regexbuf))) != NULL)
	error (EXIT_TROUBLE, 0, "%s", err);
      pcount++;

      p = sep;
    } while (sep && total != 0);

  /* In the match_words and match_lines cases, we use a different pattern
     for the DFA matcher that will quickly throw out cases that won't work.
     Then if DFA succeeds we do some hairy stuff using the regex matcher
     to decide whether the match should really count. */
  if (match_words || match_lines)
    {
      static char const line_beg_no_bk[] = "^(";
      static char const line_end_no_bk[] = ")$";
      static char const word_beg_no_bk[] = "(^|[^[:alnum:]_])(";
      static char const word_end_no_bk[] = ")([^[:alnum:]_]|$)";
      static char const line_beg_bk[] = "^\\(";
      static char const line_end_bk[] = "\\)$";
      static char const word_beg_bk[] = "\\(^\\|[^[:alnum:]_]\\)\\(";
      static char const word_end_bk[] = "\\)\\([^[:alnum:]_]\\|$\\)";
      int bk = !(syntax_bits & RE_NO_BK_PARENS);
      char *n = xmalloc (sizeof word_beg_bk - 1 + size + sizeof word_end_bk);

      strcpy (n, match_lines ? (bk ? line_beg_bk : line_beg_no_bk)
			     : (bk ? word_beg_bk : word_beg_no_bk));
      total = strlen(n);
      memcpy (n + total, pattern, size);
      total += size;
      strcpy (n + total, match_lines ? (bk ? line_end_bk : line_end_no_bk)
				     : (bk ? word_end_bk : word_end_no_bk));
      total += strlen (n + total);
      pattern = motif = n;
      size = total;
    }
  else
    motif = NULL;

  dfacomp (pattern, size, &dfa, 1);
  kwsmusts ();

  free(motif);
}

size_t
EGexecute (char const *buf, size_t size, size_t *match_size,
	   char const *start_ptr)
{
  char const *buflim, *beg, *end, *match, *best_match, *mb_start;
  char eol = eolbyte;
  int backref, start, len, best_len;
  struct kwsmatch kwsm;
  size_t i, ret_val;
#ifdef MBS_SUPPORT
  if (MB_CUR_MAX > 1)
    {
      if (match_icase)
        {
          /* mbtolower adds a NUL byte at the end.  That will provide
	     space for the sentinel byte dfaexec may add.  */
          char *case_buf = mbtolower (buf, &size);
	  if (start_ptr)
	    start_ptr = case_buf + (start_ptr - buf);
          buf = case_buf;
        }
    }
#endif /* MBS_SUPPORT */

  mb_start = buf;
  buflim = buf + size;

  for (beg = end = buf; end < buflim; beg = end)
    {
      if (!start_ptr)
	{
	  /* We don't care about an exact match.  */
	  if (kwset)
	    {
	      /* Find a possible match using the KWset matcher. */
	      size_t offset = kwsexec (kwset, beg, buflim - beg, &kwsm);
	      if (offset == (size_t) -1)
		goto failure;
	      beg += offset;
	      /* Narrow down to the line containing the candidate, and
		 run it through DFA. */
	      if ((end = memchr(beg, eol, buflim - beg)) != NULL)
	        end++;
              else
                end = buflim;
	      match = beg;
	      while (beg > buf && beg[-1] != eol)
		--beg;
	      if (kwsm.index < kwset_exact_matches)
                {
#ifdef MBS_SUPPORT
                  if (mb_start < beg)
                    mb_start = beg;
                  if (MB_CUR_MAX == 1 || !is_mb_middle (&mb_start, match, buflim))
#endif
                    goto success;
                }
	      if (dfaexec (&dfa, beg, (char *) end, 0, NULL, &backref) == NULL)
		continue;
	    }
	  else
	    {
	      /* No good fixed strings; start with DFA. */
	      char const *next_beg = dfaexec (&dfa, beg, (char *) buflim,
					      0, NULL, &backref);
	      if (next_beg == NULL)
		break;
	      /* Narrow down to the line we've found. */
	      beg = next_beg;
	      if ((end = memchr(beg, eol, buflim - beg)) != NULL)
	        end++;
              else
                end = buflim;
	      while (beg > buf && beg[-1] != eol)
		--beg;
	    }
	  /* Successful, no backreferences encountered! */
	  if (!backref)
	    goto success;
	}
      else
	{
	  /* We are looking for the leftmost (then longest) exact match.
	     We will go through the outer loop only once.  */
	  beg = start_ptr;
	  end = buflim;
	}

      /* If we've made it to this point, this means DFA has seen
	 a probable match, and we need to run it through Regex. */
      best_match = end;
      best_len = 0;
      for (i = 0; i < pcount; i++)
	{
	  patterns[i].regexbuf.not_eol = 0;
	  if (0 <= (start = re_search (&(patterns[i].regexbuf),
				       buf, end - buf - 1,
				       beg - buf, end - beg - 1,
				       &(patterns[i].regs))))
	    {
	      len = patterns[i].regs.end[0] - start;
	      match = buf + start;
	      if (match > best_match)
		continue;
	      if (start_ptr && !match_words)
		goto assess_pattern_match;
	      if ((!match_lines && !match_words)
		  || (match_lines && len == end - beg - 1))
		{
		  match = beg;
		  len = end - beg;
		  goto assess_pattern_match;
		}
	      /* If -w, check if the match aligns with word boundaries.
		 We do this iteratively because:
		 (a) the line may contain more than one occurence of the
		 pattern, and
		 (b) Several alternatives in the pattern might be valid at a
		 given point, and we may need to consider a shorter one to
		 find a word boundary.  */
	      if (match_words)
		while (match <= best_match)
		  {
		    if ((match == buf || !WCHAR ((unsigned char) match[-1]))
			&& (len == end - beg - 1
			    || !WCHAR ((unsigned char) match[len])))
		      goto assess_pattern_match;
		    if (len > 0)
		      {
			/* Try a shorter length anchored at the same place. */
			--len;
			patterns[i].regexbuf.not_eol = 1;
			len = re_match (&(patterns[i].regexbuf),
					buf, match + len - beg, match - buf,
					&(patterns[i].regs));
		      }
		    if (len <= 0)
		      {
			/* Try looking further on. */
			if (match == end - 1)
			  break;
			match++;
			patterns[i].regexbuf.not_eol = 0;
			start = re_search (&(patterns[i].regexbuf),
					   buf, end - buf - 1,
					   match - buf, end - match - 1,
					   &(patterns[i].regs));
			if (start < 0)
			  break;
			len = patterns[i].regs.end[0] - start;
			match = buf + start;
		      }
		  } /* while (match <= best_match) */
	      continue;
	    assess_pattern_match:
	      if (!start_ptr)
		{
		  /* Good enough for a non-exact match.
		     No need to look at further patterns, if any.  */
		  beg = match;
		  goto success_in_len;
		}
	      if (match < best_match || (match == best_match && len > best_len))
		{
		  /* Best exact match:  leftmost, then longest.  */
		  best_match = match;
		  best_len = len;
		}
	    } /* if re_search >= 0 */
	} /* for Regex patterns.  */
	if (best_match < end)
	  {
	    /* We have found an exact match.  We were just
	       waiting for the best one (leftmost then longest).  */
	    beg = best_match;
	    len = best_len;
	    goto success_in_len;
	  }
    } /* for (beg = end ..) */

 failure:
  ret_val = -1;
  goto out;

 success:
  len = end - beg;
 success_in_len:
  *match_size = len;
  ret_val = beg - buf;
 out:
  return ret_val;
}

Building:src at:
/home/ubuntu/spr-fast/tests/corebench/grep/grep-case-8a025cf8-8f08d8e2/tempworkdir-l/srcMerged code building succ, going to invoke tester!
CondTester, Testing instance id 41:
//src_file:src/dfasearch.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); void* memset(void*, int, unsigned long); 
/* dfasearch.c - searching subroutines using dfa and regex for grep.
   Copyright 1992, 1998, 2000, 2007, 2009-2010 Free Software Foundation, Inc.

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 3, or (at your option)
   any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program; if not, write to the Free Software
   Foundation, Inc., 51 Franklin Street - Fifth Floor, Boston, MA
   02110-1301, USA.  */

/* Written August 1992 by Mike Haertel. */

#include <config.h>
#include "search.h"
#include "dfa.h"

/* For -w, we also consider _ to be word constituent.  */
#define WCHAR(C) (ISALNUM(C) || (C) == '_')

/* KWset compiled pattern.  For Ecompile and Gcompile, we compile
   a list of strings, at least one of which is known to occur in
   any string matching the regexp. */
static kwset_t kwset;

/* DFA compiled regexp. */
static struct dfa dfa;

/* The Regex compiled patterns.  */
static struct patterns
{
  /* Regex compiled regexp. */
  struct re_pattern_buffer regexbuf;
  struct re_registers regs; /* This is here on account of a BRAIN-DEAD
			       Q@#%!# library interface in regex.c.  */
} patterns0;

struct patterns *patterns;
size_t pcount;

void
dfaerror (char const *mesg)
{
  error (EXIT_TROUBLE, 0, "%s", mesg);

  /* notreached */
  /* Tell static analyzers that this function does not return.  */
  abort ();
}

/* Number of compiled fixed strings known to exactly match the regexp.
   If kwsexec returns < kwset_exact_matches, then we don't need to
   call the regexp matcher at all. */
static int kwset_exact_matches;

static char const *
kwsincr_case (const char *must)
{
  const char *buf;
  size_t n;

  n = strlen (must);
#ifdef MBS_SUPPORT
  if (match_icase && MB_CUR_MAX > 1)
    buf = mbtolower (must, &n);
  else
#endif
    buf = must;
  return kwsincr (kwset, buf, n);
}

/* If the DFA turns out to have some set of fixed strings one of
   which must occur in the match, then we build a kwset matcher
   to find those strings, and thus quickly filter out impossible
   matches. */
static void
kwsmusts (void)
{
  struct dfamust const *dm;
  char const *err;

  if (dfa.musts)
    {
      kwsinit (&kwset);
      /* First, we compile in the substrings known to be exact
	 matches.  The kwset matcher will return the index
	 of the matching string that it chooses. */
      for (dm = dfa.musts; dm; dm = dm->next)
	{
	  
//Patch 0:
if ((!dm->exact) && !(__is_neg(7, &(dm), sizeof (dm), &(dm->exact), sizeof (dm->exact), &(kwset_exact_matches), sizeof (kwset_exact_matches), &(dm->next), sizeof (dm->next), &(err), sizeof (err), &(dm->must), sizeof (dm->must), &(kwset), sizeof (kwset))))
    continue;

//CodeSeg 1:
	  ++kwset_exact_matches;
	  if ((err = kwsincr_case (dm->must)) != NULL)
	    error (EXIT_TROUBLE, 0, "%s", err);
	}
      /* Now, we compile the substrings that will require
	 the use of the regexp matcher.  */
      for (dm = dfa.musts; dm; dm = dm->next)
	{
	  if (dm->exact)
	    continue;
	  if ((err = kwsincr_case (dm->must)) != NULL)
	    error (EXIT_TROUBLE, 0, "%s", err);
	}
      if ((err = kwsprep (kwset)) != NULL)
	error (EXIT_TROUBLE, 0, "%s", err);
    }
}

void
GEAcompile (char const *pattern, size_t size, reg_syntax_t syntax_bits)
{
  const char *err;
  const char *p, *sep;
  size_t total = size;
  char *motif;

  if (match_icase)
    syntax_bits |= RE_ICASE;
  re_set_syntax (syntax_bits);
  dfasyntax (syntax_bits, match_icase, eolbyte);

  /* For GNU regex compiler we have to pass the patterns separately to detect
     errors like "[\nallo\n]\n".  The patterns here are "[", "allo" and "]"
     GNU regex should have raise a syntax error.  The same for backref, where
     the backref should have been local to each pattern.  */
  p = pattern;
  do
    {
      size_t len;
      sep = memchr (p, '\n', total);
      if (sep)
	{
	  len = sep - p;
	  sep++;
	  total -= (len + 1);
	}
      else
	{
	  len = total;
	  total = 0;
	}

      patterns = realloc (patterns, (pcount + 1) * sizeof (*patterns));
      if (patterns == NULL)
	error (EXIT_TROUBLE, errno, _("memory exhausted"));
      patterns[pcount] = patterns0;

      if ((err = re_compile_pattern (p, len,
				    &(patterns[pcount].regexbuf))) != NULL)
	error (EXIT_TROUBLE, 0, "%s", err);
      pcount++;

      p = sep;
    } while (sep && total != 0);

  /* In the match_words and match_lines cases, we use a different pattern
     for the DFA matcher that will quickly throw out cases that won't work.
     Then if DFA succeeds we do some hairy stuff using the regex matcher
     to decide whether the match should really count. */
  if (match_words || match_lines)
    {
      static char const line_beg_no_bk[] = "^(";
      static char const line_end_no_bk[] = ")$";
      static char const word_beg_no_bk[] = "(^|[^[:alnum:]_])(";
      static char const word_end_no_bk[] = ")([^[:alnum:]_]|$)";
      static char const line_beg_bk[] = "^\\(";
      static char const line_end_bk[] = "\\)$";
      static char const word_beg_bk[] = "\\(^\\|[^[:alnum:]_]\\)\\(";
      static char const word_end_bk[] = "\\)\\([^[:alnum:]_]\\|$\\)";
      int bk = !(syntax_bits & RE_NO_BK_PARENS);
      char *n = xmalloc (sizeof word_beg_bk - 1 + size + sizeof word_end_bk);

      strcpy (n, match_lines ? (bk ? line_beg_bk : line_beg_no_bk)
			     : (bk ? word_beg_bk : word_beg_no_bk));
      total = strlen(n);
      memcpy (n + total, pattern, size);
      total += size;
      strcpy (n + total, match_lines ? (bk ? line_end_bk : line_end_no_bk)
				     : (bk ? word_end_bk : word_end_no_bk));
      total += strlen (n + total);
      pattern = motif = n;
      size = total;
    }
  else
    motif = NULL;

  dfacomp (pattern, size, &dfa, 1);
  kwsmusts ();

  free(motif);
}

size_t
EGexecute (char const *buf, size_t size, size_t *match_size,
	   char const *start_ptr)
{
  char const *buflim, *beg, *end, *match, *best_match, *mb_start;
  char eol = eolbyte;
  int backref, start, len, best_len;
  struct kwsmatch kwsm;
  size_t i, ret_val;
#ifdef MBS_SUPPORT
  if (MB_CUR_MAX > 1)
    {
      if (match_icase)
        {
          /* mbtolower adds a NUL byte at the end.  That will provide
	     space for the sentinel byte dfaexec may add.  */
          char *case_buf = mbtolower (buf, &size);
	  if (start_ptr)
	    start_ptr = case_buf + (start_ptr - buf);
          buf = case_buf;
        }
    }
#endif /* MBS_SUPPORT */

  mb_start = buf;
  buflim = buf + size;

  for (beg = end = buf; end < buflim; beg = end)
    {
      if (!start_ptr)
	{
	  /* We don't care about an exact match.  */
	  if (kwset)
	    {
	      /* Find a possible match using the KWset matcher. */
	      size_t offset = kwsexec (kwset, beg, buflim - beg, &kwsm);
	      if (offset == (size_t) -1)
		goto failure;
	      beg += offset;
	      /* Narrow down to the line containing the candidate, and
		 run it through DFA. */
	      if ((end = memchr(beg, eol, buflim - beg)) != NULL)
	        end++;
              else
                end = buflim;
	      match = beg;
	      while (beg > buf && beg[-1] != eol)
		--beg;
	      if (kwsm.index < kwset_exact_matches)
                {
#ifdef MBS_SUPPORT
                  if (mb_start < beg)
                    mb_start = beg;
                  if (MB_CUR_MAX == 1 || !is_mb_middle (&mb_start, match, buflim))
#endif
                    goto success;
                }
	      if (dfaexec (&dfa, beg, (char *) end, 0, NULL, &backref) == NULL)
		continue;
	    }
	  else
	    {
	      /* No good fixed strings; start with DFA. */
	      char const *next_beg = dfaexec (&dfa, beg, (char *) buflim,
					      0, NULL, &backref);
	      if (next_beg == NULL)
		break;
	      /* Narrow down to the line we've found. */
	      beg = next_beg;
	      if ((end = memchr(beg, eol, buflim - beg)) != NULL)
	        end++;
              else
                end = buflim;
	      while (beg > buf && beg[-1] != eol)
		--beg;
	    }
	  /* Successful, no backreferences encountered! */
	  if (!backref)
	    goto success;
	}
      else
	{
	  /* We are looking for the leftmost (then longest) exact match.
	     We will go through the outer loop only once.  */
	  beg = start_ptr;
	  end = buflim;
	}

      /* If we've made it to this point, this means DFA has seen
	 a probable match, and we need to run it through Regex. */
      best_match = end;
      best_len = 0;
      for (i = 0; i < pcount; i++)
	{
	  patterns[i].regexbuf.not_eol = 0;
	  if (0 <= (start = re_search (&(patterns[i].regexbuf),
				       buf, end - buf - 1,
				       beg - buf, end - beg - 1,
				       &(patterns[i].regs))))
	    {
	      len = patterns[i].regs.end[0] - start;
	      match = buf + start;
	      if (match > best_match)
		continue;
	      if (start_ptr && !match_words)
		goto assess_pattern_match;
	      if ((!match_lines && !match_words)
		  || (match_lines && len == end - beg - 1))
		{
		  match = beg;
		  len = end - beg;
		  goto assess_pattern_match;
		}
	      /* If -w, check if the match aligns with word boundaries.
		 We do this iteratively because:
		 (a) the line may contain more than one occurence of the
		 pattern, and
		 (b) Several alternatives in the pattern might be valid at a
		 given point, and we may need to consider a shorter one to
		 find a word boundary.  */
	      if (match_words)
		while (match <= best_match)
		  {
		    if ((match == buf || !WCHAR ((unsigned char) match[-1]))
			&& (len == end - beg - 1
			    || !WCHAR ((unsigned char) match[len])))
		      goto assess_pattern_match;
		    if (len > 0)
		      {
			/* Try a shorter length anchored at the same place. */
			--len;
			patterns[i].regexbuf.not_eol = 1;
			len = re_match (&(patterns[i].regexbuf),
					buf, match + len - beg, match - buf,
					&(patterns[i].regs));
		      }
		    if (len <= 0)
		      {
			/* Try looking further on. */
			if (match == end - 1)
			  break;
			match++;
			patterns[i].regexbuf.not_eol = 0;
			start = re_search (&(patterns[i].regexbuf),
					   buf, end - buf - 1,
					   match - buf, end - match - 1,
					   &(patterns[i].regs));
			if (start < 0)
			  break;
			len = patterns[i].regs.end[0] - start;
			match = buf + start;
		      }
		  } /* while (match <= best_match) */
	      continue;
	    assess_pattern_match:
	      if (!start_ptr)
		{
		  /* Good enough for a non-exact match.
		     No need to look at further patterns, if any.  */
		  beg = match;
		  goto success_in_len;
		}
	      if (match < best_match || (match == best_match && len > best_len))
		{
		  /* Best exact match:  leftmost, then longest.  */
		  best_match = match;
		  best_len = len;
		}
	    } /* if re_search >= 0 */
	} /* for Regex patterns.  */
	if (best_match < end)
	  {
	    /* We have found an exact match.  We were just
	       waiting for the best one (leftmost then longest).  */
	    beg = best_match;
	    len = best_len;
	    goto success_in_len;
	  }
    } /* for (beg = end ..) */

 failure:
  ret_val = -1;
  goto out;

 success:
  len = end - beg;
 success_in_len:
  *match_size = len;
  ret_val = beg - buf;
 out:
  return ret_val;
}

Testing negative cases!
Testing 0 (with abstract condition) ENVIS_NEG
Iteration 0
Running test command:
/home/ubuntu/spr-fast/tools/grep-test.py /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-8a025cf8-8f08d8e2/tempworkdir-l/src /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-8a025cf8-8f08d8e2/tempworkdir-l/tests /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-8a025cf8-8f08d8e2/tempworkdir-l 0  > __res
Opening:/tmp/neg.tmp!
NegativeBRANCH RECORD/tmp/neg.tmp!
APPENDING TO ISNEG:/tmp/neg.tmp!
Branch 0: 0
Iteration 1
Running test command:
/home/ubuntu/spr-fast/tools/grep-test.py /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-8a025cf8-8f08d8e2/tempworkdir-l/src /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-8a025cf8-8f08d8e2/tempworkdir-l/tests /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-8a025cf8-8f08d8e2/tempworkdir-l 0  > __res
Opening:/tmp/neg.tmp!
NegativeBRANCH RECORD/tmp/neg.tmp!
APPENDING TO ISNEG:/tmp/neg.tmp!
Branch 0: 1
Passed in iteration!
Passed Negative Cases wiht CondTestder!
Testing positive cases!
Running test command:
/home/ubuntu/spr-fast/tools/grep-test.py /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-8a025cf8-8f08d8e2/tempworkdir-l/src /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-8a025cf8-8f08d8e2/tempworkdir-l/tests /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-8a025cf8-8f08d8e2/tempworkdir-l 11  > __res
Running test command:
/home/ubuntu/spr-fast/tools/grep-test.py /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-8a025cf8-8f08d8e2/tempworkdir-l/src /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-8a025cf8-8f08d8e2/tempworkdir-l/tests /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-8a025cf8-8f08d8e2/tempworkdir-l 14  > __res
Running test command:
/home/ubuntu/spr-fast/tools/grep-test.py /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-8a025cf8-8f08d8e2/tempworkdir-l/src /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-8a025cf8-8f08d8e2/tempworkdir-l/tests /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-8a025cf8-8f08d8e2/tempworkdir-l 17  > __res
Running test command:
/home/ubuntu/spr-fast/tools/grep-test.py /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-8a025cf8-8f08d8e2/tempworkdir-l/src /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-8a025cf8-8f08d8e2/tempworkdir-l/tests /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-8a025cf8-8f08d8e2/tempworkdir-l 22  > __res
Passed Positive Cases
Collect values for post processing!
WRITING TO ISNEG:/tmp/neg.tmp!
Running test command:
/home/ubuntu/spr-fast/tools/grep-test.py /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-8a025cf8-8f08d8e2/tempworkdir-l/src /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-8a025cf8-8f08d8e2/tempworkdir-l/tests /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-8a025cf8-8f08d8e2/tempworkdir-l 0  > __res
Running test command:
/home/ubuntu/spr-fast/tools/grep-test.py /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-8a025cf8-8f08d8e2/tempworkdir-l/src /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-8a025cf8-8f08d8e2/tempworkdir-l/tests /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-8a025cf8-8f08d8e2/tempworkdir-l 11  > __res
Running test command:
/home/ubuntu/spr-fast/tools/grep-test.py /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-8a025cf8-8f08d8e2/tempworkdir-l/src /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-8a025cf8-8f08d8e2/tempworkdir-l/tests /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-8a025cf8-8f08d8e2/tempworkdir-l 14  > __res
Running test command:
/home/ubuntu/spr-fast/tools/grep-test.py /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-8a025cf8-8f08d8e2/tempworkdir-l/src /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-8a025cf8-8f08d8e2/tempworkdir-l/tests /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-8a025cf8-8f08d8e2/tempworkdir-l 17  > __res
Running test command:
/home/ubuntu/spr-fast/tools/grep-test.py /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-8a025cf8-8f08d8e2/tempworkdir-l/src /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-8a025cf8-8f08d8e2/tempworkdir-l/tests /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-8a025cf8-8f08d8e2/tempworkdir-l 22  > __res
Passed!
CondTester, Testing instance id 51:
//src_file:src/dfasearch.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); void* memset(void*, int, unsigned long); 
/* dfasearch.c - searching subroutines using dfa and regex for grep.
   Copyright 1992, 1998, 2000, 2007, 2009-2010 Free Software Foundation, Inc.

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 3, or (at your option)
   any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program; if not, write to the Free Software
   Foundation, Inc., 51 Franklin Street - Fifth Floor, Boston, MA
   02110-1301, USA.  */

/* Written August 1992 by Mike Haertel. */

#include <config.h>
#include "search.h"
#include "dfa.h"

/* For -w, we also consider _ to be word constituent.  */
#define WCHAR(C) (ISALNUM(C) || (C) == '_')

/* KWset compiled pattern.  For Ecompile and Gcompile, we compile
   a list of strings, at least one of which is known to occur in
   any string matching the regexp. */
static kwset_t kwset;

/* DFA compiled regexp. */
static struct dfa dfa;

/* The Regex compiled patterns.  */
static struct patterns
{
  /* Regex compiled regexp. */
  struct re_pattern_buffer regexbuf;
  struct re_registers regs; /* This is here on account of a BRAIN-DEAD
			       Q@#%!# library interface in regex.c.  */
} patterns0;

struct patterns *patterns;
size_t pcount;

void
dfaerror (char const *mesg)
{
  error (EXIT_TROUBLE, 0, "%s", mesg);

  /* notreached */
  /* Tell static analyzers that this function does not return.  */
  abort ();
}

/* Number of compiled fixed strings known to exactly match the regexp.
   If kwsexec returns < kwset_exact_matches, then we don't need to
   call the regexp matcher at all. */
static int kwset_exact_matches;

static char const *
kwsincr_case (const char *must)
{
  const char *buf;
  size_t n;

  n = strlen (must);
#ifdef MBS_SUPPORT
  if (match_icase && MB_CUR_MAX > 1)
    buf = mbtolower (must, &n);
  else
#endif
    buf = must;
  return kwsincr (kwset, buf, n);
}

/* If the DFA turns out to have some set of fixed strings one of
   which must occur in the match, then we build a kwset matcher
   to find those strings, and thus quickly filter out impossible
   matches. */
static void
kwsmusts (void)
{
  struct dfamust const *dm;
  char const *err;

  if (dfa.musts)
    {
      kwsinit (&kwset);
      /* First, we compile in the substrings known to be exact
	 matches.  The kwset matcher will return the index
	 of the matching string that it chooses. */
      for (dm = dfa.musts; dm; dm = dm->next)
	{
	  
//Patch 0:
if ((!dm->exact) || (__is_neg(7, &(dm), sizeof (dm), &(dm->exact), sizeof (dm->exact), &(kwset_exact_matches), sizeof (kwset_exact_matches), &(dm->next), sizeof (dm->next), &(err), sizeof (err), &(dm->must), sizeof (dm->must), &(kwset), sizeof (kwset))))
    continue;

//CodeSeg 1:
	  ++kwset_exact_matches;
	  if ((err = kwsincr_case (dm->must)) != NULL)
	    error (EXIT_TROUBLE, 0, "%s", err);
	}
      /* Now, we compile the substrings that will require
	 the use of the regexp matcher.  */
      for (dm = dfa.musts; dm; dm = dm->next)
	{
	  if (dm->exact)
	    continue;
	  if ((err = kwsincr_case (dm->must)) != NULL)
	    error (EXIT_TROUBLE, 0, "%s", err);
	}
      if ((err = kwsprep (kwset)) != NULL)
	error (EXIT_TROUBLE, 0, "%s", err);
    }
}

void
GEAcompile (char const *pattern, size_t size, reg_syntax_t syntax_bits)
{
  const char *err;
  const char *p, *sep;
  size_t total = size;
  char *motif;

  if (match_icase)
    syntax_bits |= RE_ICASE;
  re_set_syntax (syntax_bits);
  dfasyntax (syntax_bits, match_icase, eolbyte);

  /* For GNU regex compiler we have to pass the patterns separately to detect
     errors like "[\nallo\n]\n".  The patterns here are "[", "allo" and "]"
     GNU regex should have raise a syntax error.  The same for backref, where
     the backref should have been local to each pattern.  */
  p = pattern;
  do
    {
      size_t len;
      sep = memchr (p, '\n', total);
      if (sep)
	{
	  len = sep - p;
	  sep++;
	  total -= (len + 1);
	}
      else
	{
	  len = total;
	  total = 0;
	}

      patterns = realloc (patterns, (pcount + 1) * sizeof (*patterns));
      if (patterns == NULL)
	error (EXIT_TROUBLE, errno, _("memory exhausted"));
      patterns[pcount] = patterns0;

      if ((err = re_compile_pattern (p, len,
				    &(patterns[pcount].regexbuf))) != NULL)
	error (EXIT_TROUBLE, 0, "%s", err);
      pcount++;

      p = sep;
    } while (sep && total != 0);

  /* In the match_words and match_lines cases, we use a different pattern
     for the DFA matcher that will quickly throw out cases that won't work.
     Then if DFA succeeds we do some hairy stuff using the regex matcher
     to decide whether the match should really count. */
  if (match_words || match_lines)
    {
      static char const line_beg_no_bk[] = "^(";
      static char const line_end_no_bk[] = ")$";
      static char const word_beg_no_bk[] = "(^|[^[:alnum:]_])(";
      static char const word_end_no_bk[] = ")([^[:alnum:]_]|$)";
      static char const line_beg_bk[] = "^\\(";
      static char const line_end_bk[] = "\\)$";
      static char const word_beg_bk[] = "\\(^\\|[^[:alnum:]_]\\)\\(";
      static char const word_end_bk[] = "\\)\\([^[:alnum:]_]\\|$\\)";
      int bk = !(syntax_bits & RE_NO_BK_PARENS);
      char *n = xmalloc (sizeof word_beg_bk - 1 + size + sizeof word_end_bk);

      strcpy (n, match_lines ? (bk ? line_beg_bk : line_beg_no_bk)
			     : (bk ? word_beg_bk : word_beg_no_bk));
      total = strlen(n);
      memcpy (n + total, pattern, size);
      total += size;
      strcpy (n + total, match_lines ? (bk ? line_end_bk : line_end_no_bk)
				     : (bk ? word_end_bk : word_end_no_bk));
      total += strlen (n + total);
      pattern = motif = n;
      size = total;
    }
  else
    motif = NULL;

  dfacomp (pattern, size, &dfa, 1);
  kwsmusts ();

  free(motif);
}

size_t
EGexecute (char const *buf, size_t size, size_t *match_size,
	   char const *start_ptr)
{
  char const *buflim, *beg, *end, *match, *best_match, *mb_start;
  char eol = eolbyte;
  int backref, start, len, best_len;
  struct kwsmatch kwsm;
  size_t i, ret_val;
#ifdef MBS_SUPPORT
  if (MB_CUR_MAX > 1)
    {
      if (match_icase)
        {
          /* mbtolower adds a NUL byte at the end.  That will provide
	     space for the sentinel byte dfaexec may add.  */
          char *case_buf = mbtolower (buf, &size);
	  if (start_ptr)
	    start_ptr = case_buf + (start_ptr - buf);
          buf = case_buf;
        }
    }
#endif /* MBS_SUPPORT */

  mb_start = buf;
  buflim = buf + size;

  for (beg = end = buf; end < buflim; beg = end)
    {
      if (!start_ptr)
	{
	  /* We don't care about an exact match.  */
	  if (kwset)
	    {
	      /* Find a possible match using the KWset matcher. */
	      size_t offset = kwsexec (kwset, beg, buflim - beg, &kwsm);
	      if (offset == (size_t) -1)
		goto failure;
	      beg += offset;
	      /* Narrow down to the line containing the candidate, and
		 run it through DFA. */
	      if ((end = memchr(beg, eol, buflim - beg)) != NULL)
	        end++;
              else
                end = buflim;
	      match = beg;
	      while (beg > buf && beg[-1] != eol)
		--beg;
	      if (kwsm.index < kwset_exact_matches)
                {
#ifdef MBS_SUPPORT
                  if (mb_start < beg)
                    mb_start = beg;
                  if (MB_CUR_MAX == 1 || !is_mb_middle (&mb_start, match, buflim))
#endif
                    goto success;
                }
	      if (dfaexec (&dfa, beg, (char *) end, 0, NULL, &backref) == NULL)
		continue;
	    }
	  else
	    {
	      /* No good fixed strings; start with DFA. */
	      char const *next_beg = dfaexec (&dfa, beg, (char *) buflim,
					      0, NULL, &backref);
	      if (next_beg == NULL)
		break;
	      /* Narrow down to the line we've found. */
	      beg = next_beg;
	      if ((end = memchr(beg, eol, buflim - beg)) != NULL)
	        end++;
              else
                end = buflim;
	      while (beg > buf && beg[-1] != eol)
		--beg;
	    }
	  /* Successful, no backreferences encountered! */
	  if (!backref)
	    goto success;
	}
      else
	{
	  /* We are looking for the leftmost (then longest) exact match.
	     We will go through the outer loop only once.  */
	  beg = start_ptr;
	  end = buflim;
	}

      /* If we've made it to this point, this means DFA has seen
	 a probable match, and we need to run it through Regex. */
      best_match = end;
      best_len = 0;
      for (i = 0; i < pcount; i++)
	{
	  patterns[i].regexbuf.not_eol = 0;
	  if (0 <= (start = re_search (&(patterns[i].regexbuf),
				       buf, end - buf - 1,
				       beg - buf, end - beg - 1,
				       &(patterns[i].regs))))
	    {
	      len = patterns[i].regs.end[0] - start;
	      match = buf + start;
	      if (match > best_match)
		continue;
	      if (start_ptr && !match_words)
		goto assess_pattern_match;
	      if ((!match_lines && !match_words)
		  || (match_lines && len == end - beg - 1))
		{
		  match = beg;
		  len = end - beg;
		  goto assess_pattern_match;
		}
	      /* If -w, check if the match aligns with word boundaries.
		 We do this iteratively because:
		 (a) the line may contain more than one occurence of the
		 pattern, and
		 (b) Several alternatives in the pattern might be valid at a
		 given point, and we may need to consider a shorter one to
		 find a word boundary.  */
	      if (match_words)
		while (match <= best_match)
		  {
		    if ((match == buf || !WCHAR ((unsigned char) match[-1]))
			&& (len == end - beg - 1
			    || !WCHAR ((unsigned char) match[len])))
		      goto assess_pattern_match;
		    if (len > 0)
		      {
			/* Try a shorter length anchored at the same place. */
			--len;
			patterns[i].regexbuf.not_eol = 1;
			len = re_match (&(patterns[i].regexbuf),
					buf, match + len - beg, match - buf,
					&(patterns[i].regs));
		      }
		    if (len <= 0)
		      {
			/* Try looking further on. */
			if (match == end - 1)
			  break;
			match++;
			patterns[i].regexbuf.not_eol = 0;
			start = re_search (&(patterns[i].regexbuf),
					   buf, end - buf - 1,
					   match - buf, end - match - 1,
					   &(patterns[i].regs));
			if (start < 0)
			  break;
			len = patterns[i].regs.end[0] - start;
			match = buf + start;
		      }
		  } /* while (match <= best_match) */
	      continue;
	    assess_pattern_match:
	      if (!start_ptr)
		{
		  /* Good enough for a non-exact match.
		     No need to look at further patterns, if any.  */
		  beg = match;
		  goto success_in_len;
		}
	      if (match < best_match || (match == best_match && len > best_len))
		{
		  /* Best exact match:  leftmost, then longest.  */
		  best_match = match;
		  best_len = len;
		}
	    } /* if re_search >= 0 */
	} /* for Regex patterns.  */
	if (best_match < end)
	  {
	    /* We have found an exact match.  We were just
	       waiting for the best one (leftmost then longest).  */
	    beg = best_match;
	    len = best_len;
	    goto success_in_len;
	  }
    } /* for (beg = end ..) */

 failure:
  ret_val = -1;
  goto out;

 success:
  len = end - beg;
 success_in_len:
  *match_size = len;
  ret_val = beg - buf;
 out:
  return ret_val;
}

Testing negative cases!
Testing 0 (with abstract condition) ENVIS_NEG
Iteration 0
Running test command:
/home/ubuntu/spr-fast/tools/grep-test.py /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-8a025cf8-8f08d8e2/tempworkdir-l/src /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-8a025cf8-8f08d8e2/tempworkdir-l/tests /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-8a025cf8-8f08d8e2/tempworkdir-l 0  > __res
Opening:/tmp/neg.tmp!
NegativeBRANCH RECORD/tmp/neg.tmp!
Not caught by the negative case, give up!
APPENDING TO ISNEG:/tmp/neg.tmp!
Running test command:
/home/ubuntu/spr-fast/tools/grep-test.py /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-8a025cf8-8f08d8e2/tempworkdir-l/src /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-8a025cf8-8f08d8e2/tempworkdir-l/tests /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-8a025cf8-8f08d8e2/tempworkdir-l 0  > __res
CondTester, Postprocessing instance id 41:
//src_file:src/dfasearch.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); void* memset(void*, int, unsigned long); 
/* dfasearch.c - searching subroutines using dfa and regex for grep.
   Copyright 1992, 1998, 2000, 2007, 2009-2010 Free Software Foundation, Inc.

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 3, or (at your option)
   any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program; if not, write to the Free Software
   Foundation, Inc., 51 Franklin Street - Fifth Floor, Boston, MA
   02110-1301, USA.  */

/* Written August 1992 by Mike Haertel. */

#include <config.h>
#include "search.h"
#include "dfa.h"

/* For -w, we also consider _ to be word constituent.  */
#define WCHAR(C) (ISALNUM(C) || (C) == '_')

/* KWset compiled pattern.  For Ecompile and Gcompile, we compile
   a list of strings, at least one of which is known to occur in
   any string matching the regexp. */
static kwset_t kwset;

/* DFA compiled regexp. */
static struct dfa dfa;

/* The Regex compiled patterns.  */
static struct patterns
{
  /* Regex compiled regexp. */
  struct re_pattern_buffer regexbuf;
  struct re_registers regs; /* This is here on account of a BRAIN-DEAD
			       Q@#%!# library interface in regex.c.  */
} patterns0;

struct patterns *patterns;
size_t pcount;

void
dfaerror (char const *mesg)
{
  error (EXIT_TROUBLE, 0, "%s", mesg);

  /* notreached */
  /* Tell static analyzers that this function does not return.  */
  abort ();
}

/* Number of compiled fixed strings known to exactly match the regexp.
   If kwsexec returns < kwset_exact_matches, then we don't need to
   call the regexp matcher at all. */
static int kwset_exact_matches;

static char const *
kwsincr_case (const char *must)
{
  const char *buf;
  size_t n;

  n = strlen (must);
#ifdef MBS_SUPPORT
  if (match_icase && MB_CUR_MAX > 1)
    buf = mbtolower (must, &n);
  else
#endif
    buf = must;
  return kwsincr (kwset, buf, n);
}

/* If the DFA turns out to have some set of fixed strings one of
   which must occur in the match, then we build a kwset matcher
   to find those strings, and thus quickly filter out impossible
   matches. */
static void
kwsmusts (void)
{
  struct dfamust const *dm;
  char const *err;

  if (dfa.musts)
    {
      kwsinit (&kwset);
      /* First, we compile in the substrings known to be exact
	 matches.  The kwset matcher will return the index
	 of the matching string that it chooses. */
      for (dm = dfa.musts; dm; dm = dm->next)
	{
	  
//Patch 0:
if ((!dm->exact) && !(__is_neg(7, &(dm), sizeof (dm), &(dm->exact), sizeof (dm->exact), &(kwset_exact_matches), sizeof (kwset_exact_matches), &(dm->next), sizeof (dm->next), &(err), sizeof (err), &(dm->must), sizeof (dm->must), &(kwset), sizeof (kwset))))
    continue;

//CodeSeg 1:
	  ++kwset_exact_matches;
	  if ((err = kwsincr_case (dm->must)) != NULL)
	    error (EXIT_TROUBLE, 0, "%s", err);
	}
      /* Now, we compile the substrings that will require
	 the use of the regexp matcher.  */
      for (dm = dfa.musts; dm; dm = dm->next)
	{
	  if (dm->exact)
	    continue;
	  if ((err = kwsincr_case (dm->must)) != NULL)
	    error (EXIT_TROUBLE, 0, "%s", err);
	}
      if ((err = kwsprep (kwset)) != NULL)
	error (EXIT_TROUBLE, 0, "%s", err);
    }
}

void
GEAcompile (char const *pattern, size_t size, reg_syntax_t syntax_bits)
{
  const char *err;
  const char *p, *sep;
  size_t total = size;
  char *motif;

  if (match_icase)
    syntax_bits |= RE_ICASE;
  re_set_syntax (syntax_bits);
  dfasyntax (syntax_bits, match_icase, eolbyte);

  /* For GNU regex compiler we have to pass the patterns separately to detect
     errors like "[\nallo\n]\n".  The patterns here are "[", "allo" and "]"
     GNU regex should have raise a syntax error.  The same for backref, where
     the backref should have been local to each pattern.  */
  p = pattern;
  do
    {
      size_t len;
      sep = memchr (p, '\n', total);
      if (sep)
	{
	  len = sep - p;
	  sep++;
	  total -= (len + 1);
	}
      else
	{
	  len = total;
	  total = 0;
	}

      patterns = realloc (patterns, (pcount + 1) * sizeof (*patterns));
      if (patterns == NULL)
	error (EXIT_TROUBLE, errno, _("memory exhausted"));
      patterns[pcount] = patterns0;

      if ((err = re_compile_pattern (p, len,
				    &(patterns[pcount].regexbuf))) != NULL)
	error (EXIT_TROUBLE, 0, "%s", err);
      pcount++;

      p = sep;
    } while (sep && total != 0);

  /* In the match_words and match_lines cases, we use a different pattern
     for the DFA matcher that will quickly throw out cases that won't work.
     Then if DFA succeeds we do some hairy stuff using the regex matcher
     to decide whether the match should really count. */
  if (match_words || match_lines)
    {
      static char const line_beg_no_bk[] = "^(";
      static char const line_end_no_bk[] = ")$";
      static char const word_beg_no_bk[] = "(^|[^[:alnum:]_])(";
      static char const word_end_no_bk[] = ")([^[:alnum:]_]|$)";
      static char const line_beg_bk[] = "^\\(";
      static char const line_end_bk[] = "\\)$";
      static char const word_beg_bk[] = "\\(^\\|[^[:alnum:]_]\\)\\(";
      static char const word_end_bk[] = "\\)\\([^[:alnum:]_]\\|$\\)";
      int bk = !(syntax_bits & RE_NO_BK_PARENS);
      char *n = xmalloc (sizeof word_beg_bk - 1 + size + sizeof word_end_bk);

      strcpy (n, match_lines ? (bk ? line_beg_bk : line_beg_no_bk)
			     : (bk ? word_beg_bk : word_beg_no_bk));
      total = strlen(n);
      memcpy (n + total, pattern, size);
      total += size;
      strcpy (n + total, match_lines ? (bk ? line_end_bk : line_end_no_bk)
				     : (bk ? word_end_bk : word_end_no_bk));
      total += strlen (n + total);
      pattern = motif = n;
      size = total;
    }
  else
    motif = NULL;

  dfacomp (pattern, size, &dfa, 1);
  kwsmusts ();

  free(motif);
}

size_t
EGexecute (char const *buf, size_t size, size_t *match_size,
	   char const *start_ptr)
{
  char const *buflim, *beg, *end, *match, *best_match, *mb_start;
  char eol = eolbyte;
  int backref, start, len, best_len;
  struct kwsmatch kwsm;
  size_t i, ret_val;
#ifdef MBS_SUPPORT
  if (MB_CUR_MAX > 1)
    {
      if (match_icase)
        {
          /* mbtolower adds a NUL byte at the end.  That will provide
	     space for the sentinel byte dfaexec may add.  */
          char *case_buf = mbtolower (buf, &size);
	  if (start_ptr)
	    start_ptr = case_buf + (start_ptr - buf);
          buf = case_buf;
        }
    }
#endif /* MBS_SUPPORT */

  mb_start = buf;
  buflim = buf + size;

  for (beg = end = buf; end < buflim; beg = end)
    {
      if (!start_ptr)
	{
	  /* We don't care about an exact match.  */
	  if (kwset)
	    {
	      /* Find a possible match using the KWset matcher. */
	      size_t offset = kwsexec (kwset, beg, buflim - beg, &kwsm);
	      if (offset == (size_t) -1)
		goto failure;
	      beg += offset;
	      /* Narrow down to the line containing the candidate, and
		 run it through DFA. */
	      if ((end = memchr(beg, eol, buflim - beg)) != NULL)
	        end++;
              else
                end = buflim;
	      match = beg;
	      while (beg > buf && beg[-1] != eol)
		--beg;
	      if (kwsm.index < kwset_exact_matches)
                {
#ifdef MBS_SUPPORT
                  if (mb_start < beg)
                    mb_start = beg;
                  if (MB_CUR_MAX == 1 || !is_mb_middle (&mb_start, match, buflim))
#endif
                    goto success;
                }
	      if (dfaexec (&dfa, beg, (char *) end, 0, NULL, &backref) == NULL)
		continue;
	    }
	  else
	    {
	      /* No good fixed strings; start with DFA. */
	      char const *next_beg = dfaexec (&dfa, beg, (char *) buflim,
					      0, NULL, &backref);
	      if (next_beg == NULL)
		break;
	      /* Narrow down to the line we've found. */
	      beg = next_beg;
	      if ((end = memchr(beg, eol, buflim - beg)) != NULL)
	        end++;
              else
                end = buflim;
	      while (beg > buf && beg[-1] != eol)
		--beg;
	    }
	  /* Successful, no backreferences encountered! */
	  if (!backref)
	    goto success;
	}
      else
	{
	  /* We are looking for the leftmost (then longest) exact match.
	     We will go through the outer loop only once.  */
	  beg = start_ptr;
	  end = buflim;
	}

      /* If we've made it to this point, this means DFA has seen
	 a probable match, and we need to run it through Regex. */
      best_match = end;
      best_len = 0;
      for (i = 0; i < pcount; i++)
	{
	  patterns[i].regexbuf.not_eol = 0;
	  if (0 <= (start = re_search (&(patterns[i].regexbuf),
				       buf, end - buf - 1,
				       beg - buf, end - beg - 1,
				       &(patterns[i].regs))))
	    {
	      len = patterns[i].regs.end[0] - start;
	      match = buf + start;
	      if (match > best_match)
		continue;
	      if (start_ptr && !match_words)
		goto assess_pattern_match;
	      if ((!match_lines && !match_words)
		  || (match_lines && len == end - beg - 1))
		{
		  match = beg;
		  len = end - beg;
		  goto assess_pattern_match;
		}
	      /* If -w, check if the match aligns with word boundaries.
		 We do this iteratively because:
		 (a) the line may contain more than one occurence of the
		 pattern, and
		 (b) Several alternatives in the pattern might be valid at a
		 given point, and we may need to consider a shorter one to
		 find a word boundary.  */
	      if (match_words)
		while (match <= best_match)
		  {
		    if ((match == buf || !WCHAR ((unsigned char) match[-1]))
			&& (len == end - beg - 1
			    || !WCHAR ((unsigned char) match[len])))
		      goto assess_pattern_match;
		    if (len > 0)
		      {
			/* Try a shorter length anchored at the same place. */
			--len;
			patterns[i].regexbuf.not_eol = 1;
			len = re_match (&(patterns[i].regexbuf),
					buf, match + len - beg, match - buf,
					&(patterns[i].regs));
		      }
		    if (len <= 0)
		      {
			/* Try looking further on. */
			if (match == end - 1)
			  break;
			match++;
			patterns[i].regexbuf.not_eol = 0;
			start = re_search (&(patterns[i].regexbuf),
					   buf, end - buf - 1,
					   match - buf, end - match - 1,
					   &(patterns[i].regs));
			if (start < 0)
			  break;
			len = patterns[i].regs.end[0] - start;
			match = buf + start;
		      }
		  } /* while (match <= best_match) */
	      continue;
	    assess_pattern_match:
	      if (!start_ptr)
		{
		  /* Good enough for a non-exact match.
		     No need to look at further patterns, if any.  */
		  beg = match;
		  goto success_in_len;
		}
	      if (match < best_match || (match == best_match && len > best_len))
		{
		  /* Best exact match:  leftmost, then longest.  */
		  best_match = match;
		  best_len = len;
		}
	    } /* if re_search >= 0 */
	} /* for Regex patterns.  */
	if (best_match < end)
	  {
	    /* We have found an exact match.  We were just
	       waiting for the best one (leftmost then longest).  */
	    beg = best_match;
	    len = best_len;
	    goto success_in_len;
	  }
    } /* for (beg = end ..) */

 failure:
  ret_val = -1;
  goto out;

 success:
  len = end - beg;
 success_in_len:
  *match_size = len;
  ret_val = beg - buf;
 out:
  return ret_val;
}

Trying a synthesis expr 1
Building:src at:
/home/ubuntu/spr-fast/tests/corebench/grep/grep-case-8a025cf8-8f08d8e2/tempworkdir-l/srcVerifing Negative cases!
Running test command:
/home/ubuntu/spr-fast/tools/grep-test.py /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-8a025cf8-8f08d8e2/tempworkdir-l/src /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-8a025cf8-8f08d8e2/tempworkdir-l/tests /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-8a025cf8-8f08d8e2/tempworkdir-l 0  > __res
Verifying positive cases
Running test command:
/home/ubuntu/spr-fast/tools/grep-test.py /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-8a025cf8-8f08d8e2/tempworkdir-l/src /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-8a025cf8-8f08d8e2/tempworkdir-l/tests /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-8a025cf8-8f08d8e2/tempworkdir-l 11  > __res
Failed positive case 11
Not passed!
Trying a synthesis expr dm->exact == 0
Building:src at:
/home/ubuntu/spr-fast/tests/corebench/grep/grep-case-8a025cf8-8f08d8e2/tempworkdir-l/srcVerifing Negative cases!
Running test command:
/home/ubuntu/spr-fast/tools/grep-test.py /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-8a025cf8-8f08d8e2/tempworkdir-l/src /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-8a025cf8-8f08d8e2/tempworkdir-l/tests /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-8a025cf8-8f08d8e2/tempworkdir-l 0  > __res
Verifying positive cases
Running test command:
/home/ubuntu/spr-fast/tools/grep-test.py /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-8a025cf8-8f08d8e2/tempworkdir-l/src /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-8a025cf8-8f08d8e2/tempworkdir-l/tests /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-8a025cf8-8f08d8e2/tempworkdir-l 11  > __res
Failed positive case 11
Not passed!
Trying a synthesis expr kwset_exact_matches == 0
Building:src at:
/home/ubuntu/spr-fast/tests/corebench/grep/grep-case-8a025cf8-8f08d8e2/tempworkdir-l/srcVerifing Negative cases!
Running test command:
/home/ubuntu/spr-fast/tools/grep-test.py /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-8a025cf8-8f08d8e2/tempworkdir-l/src /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-8a025cf8-8f08d8e2/tempworkdir-l/tests /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-8a025cf8-8f08d8e2/tempworkdir-l 0  > __res
Verifying positive cases
Running test command:
/home/ubuntu/spr-fast/tools/grep-test.py /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-8a025cf8-8f08d8e2/tempworkdir-l/src /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-8a025cf8-8f08d8e2/tempworkdir-l/tests /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-8a025cf8-8f08d8e2/tempworkdir-l 11  > __res
Failed positive case 11
Not passed!
Trying a synthesis expr dm->next == 0
Building:src at:
/home/ubuntu/spr-fast/tests/corebench/grep/grep-case-8a025cf8-8f08d8e2/tempworkdir-l/srcVerifing Negative cases!
Running test command:
/home/ubuntu/spr-fast/tools/grep-test.py /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-8a025cf8-8f08d8e2/tempworkdir-l/src /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-8a025cf8-8f08d8e2/tempworkdir-l/tests /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-8a025cf8-8f08d8e2/tempworkdir-l 0  > __res
Verifying positive cases
Running test command:
/home/ubuntu/spr-fast/tools/grep-test.py /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-8a025cf8-8f08d8e2/tempworkdir-l/src /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-8a025cf8-8f08d8e2/tempworkdir-l/tests /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-8a025cf8-8f08d8e2/tempworkdir-l 11  > __res
Failed positive case 11
Not passed!
Initial synthesize failed, final attempt
Found a clause! (!dm->exact) 
Final attempt 1/4 with expr int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); void* memset(void*, int, unsigned long); 
/* dfasearch.c - searching subroutines using dfa and regex for grep.
   Copyright 1992, 1998, 2000, 2007, 2009-2010 Free Software Foundation, Inc.

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 3, or (at your option)
   any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program; if not, write to the Free Software
   Foundation, Inc., 51 Franklin Street - Fifth Floor, Boston, MA
   02110-1301, USA.  */

/* Written August 1992 by Mike Haertel. */

#include <config.h>
#include "search.h"
#include "dfa.h"

/* For -w, we also consider _ to be word constituent.  */
#define WCHAR(C) (ISALNUM(C) || (C) == '_')

/* KWset compiled pattern.  For Ecompile and Gcompile, we compile
   a list of strings, at least one of which is known to occur in
   any string matching the regexp. */
static kwset_t kwset;

/* DFA compiled regexp. */
static struct dfa dfa;

/* The Regex compiled patterns.  */
static struct patterns
{
  /* Regex compiled regexp. */
  struct re_pattern_buffer regexbuf;
  struct re_registers regs; /* This is here on account of a BRAIN-DEAD
			       Q@#%!# library interface in regex.c.  */
} patterns0;

struct patterns *patterns;
size_t pcount;

void
dfaerror (char const *mesg)
{
  error (EXIT_TROUBLE, 0, "%s", mesg);

  /* notreached */
  /* Tell static analyzers that this function does not return.  */
  abort ();
}

/* Number of compiled fixed strings known to exactly match the regexp.
   If kwsexec returns < kwset_exact_matches, then we don't need to
   call the regexp matcher at all. */
static int kwset_exact_matches;

static char const *
kwsincr_case (const char *must)
{
  const char *buf;
  size_t n;

  n = strlen (must);
#ifdef MBS_SUPPORT
  if (match_icase && MB_CUR_MAX > 1)
    buf = mbtolower (must, &n);
  else
#endif
    buf = must;
  return kwsincr (kwset, buf, n);
}

/* If the DFA turns out to have some set of fixed strings one of
   which must occur in the match, then we build a kwset matcher
   to find those strings, and thus quickly filter out impossible
   matches. */
static void
kwsmusts (void)
{
  struct dfamust const *dm;
  char const *err;

  if (dfa.musts)
    {
      kwsinit (&kwset);
      /* First, we compile in the substrings known to be exact
	 matches.  The kwset matcher will return the index
	 of the matching string that it chooses. */
      for (dm = dfa.musts; dm; dm = dm->next)
	{
	  //prophet generated patch
	  if ((!dm->exact) && !((!((!dm->exact) ))))
	      continue;
	  ++kwset_exact_matches;
	  if ((err = kwsincr_case (dm->must)) != NULL)
	    error (EXIT_TROUBLE, 0, "%s", err);
	}
      /* Now, we compile the substrings that will require
	 the use of the regexp matcher.  */
      for (dm = dfa.musts; dm; dm = dm->next)
	{
	  if (dm->exact)
	    continue;
	  if ((err = kwsincr_case (dm->must)) != NULL)
	    error (EXIT_TROUBLE, 0, "%s", err);
	}
      if ((err = kwsprep (kwset)) != NULL)
	error (EXIT_TROUBLE, 0, "%s", err);
    }
}

void
GEAcompile (char const *pattern, size_t size, reg_syntax_t syntax_bits)
{
  const char *err;
  const char *p, *sep;
  size_t total = size;
  char *motif;

  if (match_icase)
    syntax_bits |= RE_ICASE;
  re_set_syntax (syntax_bits);
  dfasyntax (syntax_bits, match_icase, eolbyte);

  /* For GNU regex compiler we have to pass the patterns separately to detect
     errors like "[\nallo\n]\n".  The patterns here are "[", "allo" and "]"
     GNU regex should have raise a syntax error.  The same for backref, where
     the backref should have been local to each pattern.  */
  p = pattern;
  do
    {
      size_t len;
      sep = memchr (p, '\n', total);
      if (sep)
	{
	  len = sep - p;
	  sep++;
	  total -= (len + 1);
	}
      else
	{
	  len = total;
	  total = 0;
	}

      patterns = realloc (patterns, (pcount + 1) * sizeof (*patterns));
      if (patterns == NULL)
	error (EXIT_TROUBLE, errno, _("memory exhausted"));
      patterns[pcount] = patterns0;

      if ((err = re_compile_pattern (p, len,
				    &(patterns[pcount].regexbuf))) != NULL)
	error (EXIT_TROUBLE, 0, "%s", err);
      pcount++;

      p = sep;
    } while (sep && total != 0);

  /* In the match_words and match_lines cases, we use a different pattern
     for the DFA matcher that will quickly throw out cases that won't work.
     Then if DFA succeeds we do some hairy stuff using the regex matcher
     to decide whether the match should really count. */
  if (match_words || match_lines)
    {
      static char const line_beg_no_bk[] = "^(";
      static char const line_end_no_bk[] = ")$";
      static char const word_beg_no_bk[] = "(^|[^[:alnum:]_])(";
      static char const word_end_no_bk[] = ")([^[:alnum:]_]|$)";
      static char const line_beg_bk[] = "^\\(";
      static char const line_end_bk[] = "\\)$";
      static char const word_beg_bk[] = "\\(^\\|[^[:alnum:]_]\\)\\(";
      static char const word_end_bk[] = "\\)\\([^[:alnum:]_]\\|$\\)";
      int bk = !(syntax_bits & RE_NO_BK_PARENS);
      char *n = xmalloc (sizeof word_beg_bk - 1 + size + sizeof word_end_bk);

      strcpy (n, match_lines ? (bk ? line_beg_bk : line_beg_no_bk)
			     : (bk ? word_beg_bk : word_beg_no_bk));
      total = strlen(n);
      memcpy (n + total, pattern, size);
      total += size;
      strcpy (n + total, match_lines ? (bk ? line_end_bk : line_end_no_bk)
				     : (bk ? word_end_bk : word_end_no_bk));
      total += strlen (n + total);
      pattern = motif = n;
      size = total;
    }
  else
    motif = NULL;

  dfacomp (pattern, size, &dfa, 1);
  kwsmusts ();

  free(motif);
}

size_t
EGexecute (char const *buf, size_t size, size_t *match_size,
	   char const *start_ptr)
{
  char const *buflim, *beg, *end, *match, *best_match, *mb_start;
  char eol = eolbyte;
  int backref, start, len, best_len;
  struct kwsmatch kwsm;
  size_t i, ret_val;
#ifdef MBS_SUPPORT
  if (MB_CUR_MAX > 1)
    {
      if (match_icase)
        {
          /* mbtolower adds a NUL byte at the end.  That will provide
	     space for the sentinel byte dfaexec may add.  */
          char *case_buf = mbtolower (buf, &size);
	  if (start_ptr)
	    start_ptr = case_buf + (start_ptr - buf);
          buf = case_buf;
        }
    }
#endif /* MBS_SUPPORT */

  mb_start = buf;
  buflim = buf + size;

  for (beg = end = buf; end < buflim; beg = end)
    {
      if (!start_ptr)
	{
	  /* We don't care about an exact match.  */
	  if (kwset)
	    {
	      /* Find a possible match using the KWset matcher. */
	      size_t offset = kwsexec (kwset, beg, buflim - beg, &kwsm);
	      if (offset == (size_t) -1)
		goto failure;
	      beg += offset;
	      /* Narrow down to the line containing the candidate, and
		 run it through DFA. */
	      if ((end = memchr(beg, eol, buflim - beg)) != NULL)
	        end++;
              else
                end = buflim;
	      match = beg;
	      while (beg > buf && beg[-1] != eol)
		--beg;
	      if (kwsm.index < kwset_exact_matches)
                {
#ifdef MBS_SUPPORT
                  if (mb_start < beg)
                    mb_start = beg;
                  if (MB_CUR_MAX == 1 || !is_mb_middle (&mb_start, match, buflim))
#endif
                    goto success;
                }
	      if (dfaexec (&dfa, beg, (char *) end, 0, NULL, &backref) == NULL)
		continue;
	    }
	  else
	    {
	      /* No good fixed strings; start with DFA. */
	      char const *next_beg = dfaexec (&dfa, beg, (char *) buflim,
					      0, NULL, &backref);
	      if (next_beg == NULL)
		break;
	      /* Narrow down to the line we've found. */
	      beg = next_beg;
	      if ((end = memchr(beg, eol, buflim - beg)) != NULL)
	        end++;
              else
                end = buflim;
	      while (beg > buf && beg[-1] != eol)
		--beg;
	    }
	  /* Successful, no backreferences encountered! */
	  if (!backref)
	    goto success;
	}
      else
	{
	  /* We are looking for the leftmost (then longest) exact match.
	     We will go through the outer loop only once.  */
	  beg = start_ptr;
	  end = buflim;
	}

      /* If we've made it to this point, this means DFA has seen
	 a probable match, and we need to run it through Regex. */
      best_match = end;
      best_len = 0;
      for (i = 0; i < pcount; i++)
	{
	  patterns[i].regexbuf.not_eol = 0;
	  if (0 <= (start = re_search (&(patterns[i].regexbuf),
				       buf, end - buf - 1,
				       beg - buf, end - beg - 1,
				       &(patterns[i].regs))))
	    {
	      len = patterns[i].regs.end[0] - start;
	      match = buf + start;
	      if (match > best_match)
		continue;
	      if (start_ptr && !match_words)
		goto assess_pattern_match;
	      if ((!match_lines && !match_words)
		  || (match_lines && len == end - beg - 1))
		{
		  match = beg;
		  len = end - beg;
		  goto assess_pattern_match;
		}
	      /* If -w, check if the match aligns with word boundaries.
		 We do this iteratively because:
		 (a) the line may contain more than one occurence of the
		 pattern, and
		 (b) Several alternatives in the pattern might be valid at a
		 given point, and we may need to consider a shorter one to
		 find a word boundary.  */
	      if (match_words)
		while (match <= best_match)
		  {
		    if ((match == buf || !WCHAR ((unsigned char) match[-1]))
			&& (len == end - beg - 1
			    || !WCHAR ((unsigned char) match[len])))
		      goto assess_pattern_match;
		    if (len > 0)
		      {
			/* Try a shorter length anchored at the same place. */
			--len;
			patterns[i].regexbuf.not_eol = 1;
			len = re_match (&(patterns[i].regexbuf),
					buf, match + len - beg, match - buf,
					&(patterns[i].regs));
		      }
		    if (len <= 0)
		      {
			/* Try looking further on. */
			if (match == end - 1)
			  break;
			match++;
			patterns[i].regexbuf.not_eol = 0;
			start = re_search (&(patterns[i].regexbuf),
					   buf, end - buf - 1,
					   match - buf, end - match - 1,
					   &(patterns[i].regs));
			if (start < 0)
			  break;
			len = patterns[i].regs.end[0] - start;
			match = buf + start;
		      }
		  } /* while (match <= best_match) */
	      continue;
	    assess_pattern_match:
	      if (!start_ptr)
		{
		  /* Good enough for a non-exact match.
		     No need to look at further patterns, if any.  */
		  beg = match;
		  goto success_in_len;
		}
	      if (match < best_match || (match == best_match && len > best_len))
		{
		  /* Best exact match:  leftmost, then longest.  */
		  best_match = match;
		  best_len = len;
		}
	    } /* if re_search >= 0 */
	} /* for Regex patterns.  */
	if (best_match < end)
	  {
	    /* We have found an exact match.  We were just
	       waiting for the best one (leftmost then longest).  */
	    beg = best_match;
	    len = best_len;
	    goto success_in_len;
	  }
    } /* for (beg = end ..) */

 failure:
  ret_val = -1;
  goto out;

 success:
  len = end - beg;
 success_in_len:
  *match_size = len;
  ret_val = beg - buf;
 out:
  return ret_val;
}

Building:src at:
/home/ubuntu/spr-fast/tests/corebench/grep/grep-case-8a025cf8-8f08d8e2/tempworkdir-l/srcTrying Negative cases!
Running test command:
/home/ubuntu/spr-fast/tools/grep-test.py /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-8a025cf8-8f08d8e2/tempworkdir-l/src /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-8a025cf8-8f08d8e2/tempworkdir-l/tests /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-8a025cf8-8f08d8e2/tempworkdir-l 0  > __res
Final attempt 2/4 with expr int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); void* memset(void*, int, unsigned long); 
/* dfasearch.c - searching subroutines using dfa and regex for grep.
   Copyright 1992, 1998, 2000, 2007, 2009-2010 Free Software Foundation, Inc.

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 3, or (at your option)
   any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program; if not, write to the Free Software
   Foundation, Inc., 51 Franklin Street - Fifth Floor, Boston, MA
   02110-1301, USA.  */

/* Written August 1992 by Mike Haertel. */

#include <config.h>
#include "search.h"
#include "dfa.h"

/* For -w, we also consider _ to be word constituent.  */
#define WCHAR(C) (ISALNUM(C) || (C) == '_')

/* KWset compiled pattern.  For Ecompile and Gcompile, we compile
   a list of strings, at least one of which is known to occur in
   any string matching the regexp. */
static kwset_t kwset;

/* DFA compiled regexp. */
static struct dfa dfa;

/* The Regex compiled patterns.  */
static struct patterns
{
  /* Regex compiled regexp. */
  struct re_pattern_buffer regexbuf;
  struct re_registers regs; /* This is here on account of a BRAIN-DEAD
			       Q@#%!# library interface in regex.c.  */
} patterns0;

struct patterns *patterns;
size_t pcount;

void
dfaerror (char const *mesg)
{
  error (EXIT_TROUBLE, 0, "%s", mesg);

  /* notreached */
  /* Tell static analyzers that this function does not return.  */
  abort ();
}

/* Number of compiled fixed strings known to exactly match the regexp.
   If kwsexec returns < kwset_exact_matches, then we don't need to
   call the regexp matcher at all. */
static int kwset_exact_matches;

static char const *
kwsincr_case (const char *must)
{
  const char *buf;
  size_t n;

  n = strlen (must);
#ifdef MBS_SUPPORT
  if (match_icase && MB_CUR_MAX > 1)
    buf = mbtolower (must, &n);
  else
#endif
    buf = must;
  return kwsincr (kwset, buf, n);
}

/* If the DFA turns out to have some set of fixed strings one of
   which must occur in the match, then we build a kwset matcher
   to find those strings, and thus quickly filter out impossible
   matches. */
static void
kwsmusts (void)
{
  struct dfamust const *dm;
  char const *err;

  if (dfa.musts)
    {
      kwsinit (&kwset);
      /* First, we compile in the substrings known to be exact
	 matches.  The kwset matcher will return the index
	 of the matching string that it chooses. */
      for (dm = dfa.musts; dm; dm = dm->next)
	{
	  //prophet generated patch
	  if ((!dm->exact) && !(((!dm->exact) )))
	      continue;
	  ++kwset_exact_matches;
	  if ((err = kwsincr_case (dm->must)) != NULL)
	    error (EXIT_TROUBLE, 0, "%s", err);
	}
      /* Now, we compile the substrings that will require
	 the use of the regexp matcher.  */
      for (dm = dfa.musts; dm; dm = dm->next)
	{
	  if (dm->exact)
	    continue;
	  if ((err = kwsincr_case (dm->must)) != NULL)
	    error (EXIT_TROUBLE, 0, "%s", err);
	}
      if ((err = kwsprep (kwset)) != NULL)
	error (EXIT_TROUBLE, 0, "%s", err);
    }
}

void
GEAcompile (char const *pattern, size_t size, reg_syntax_t syntax_bits)
{
  const char *err;
  const char *p, *sep;
  size_t total = size;
  char *motif;

  if (match_icase)
    syntax_bits |= RE_ICASE;
  re_set_syntax (syntax_bits);
  dfasyntax (syntax_bits, match_icase, eolbyte);

  /* For GNU regex compiler we have to pass the patterns separately to detect
     errors like "[\nallo\n]\n".  The patterns here are "[", "allo" and "]"
     GNU regex should have raise a syntax error.  The same for backref, where
     the backref should have been local to each pattern.  */
  p = pattern;
  do
    {
      size_t len;
      sep = memchr (p, '\n', total);
      if (sep)
	{
	  len = sep - p;
	  sep++;
	  total -= (len + 1);
	}
      else
	{
	  len = total;
	  total = 0;
	}

      patterns = realloc (patterns, (pcount + 1) * sizeof (*patterns));
      if (patterns == NULL)
	error (EXIT_TROUBLE, errno, _("memory exhausted"));
      patterns[pcount] = patterns0;

      if ((err = re_compile_pattern (p, len,
				    &(patterns[pcount].regexbuf))) != NULL)
	error (EXIT_TROUBLE, 0, "%s", err);
      pcount++;

      p = sep;
    } while (sep && total != 0);

  /* In the match_words and match_lines cases, we use a different pattern
     for the DFA matcher that will quickly throw out cases that won't work.
     Then if DFA succeeds we do some hairy stuff using the regex matcher
     to decide whether the match should really count. */
  if (match_words || match_lines)
    {
      static char const line_beg_no_bk[] = "^(";
      static char const line_end_no_bk[] = ")$";
      static char const word_beg_no_bk[] = "(^|[^[:alnum:]_])(";
      static char const word_end_no_bk[] = ")([^[:alnum:]_]|$)";
      static char const line_beg_bk[] = "^\\(";
      static char const line_end_bk[] = "\\)$";
      static char const word_beg_bk[] = "\\(^\\|[^[:alnum:]_]\\)\\(";
      static char const word_end_bk[] = "\\)\\([^[:alnum:]_]\\|$\\)";
      int bk = !(syntax_bits & RE_NO_BK_PARENS);
      char *n = xmalloc (sizeof word_beg_bk - 1 + size + sizeof word_end_bk);

      strcpy (n, match_lines ? (bk ? line_beg_bk : line_beg_no_bk)
			     : (bk ? word_beg_bk : word_beg_no_bk));
      total = strlen(n);
      memcpy (n + total, pattern, size);
      total += size;
      strcpy (n + total, match_lines ? (bk ? line_end_bk : line_end_no_bk)
				     : (bk ? word_end_bk : word_end_no_bk));
      total += strlen (n + total);
      pattern = motif = n;
      size = total;
    }
  else
    motif = NULL;

  dfacomp (pattern, size, &dfa, 1);
  kwsmusts ();

  free(motif);
}

size_t
EGexecute (char const *buf, size_t size, size_t *match_size,
	   char const *start_ptr)
{
  char const *buflim, *beg, *end, *match, *best_match, *mb_start;
  char eol = eolbyte;
  int backref, start, len, best_len;
  struct kwsmatch kwsm;
  size_t i, ret_val;
#ifdef MBS_SUPPORT
  if (MB_CUR_MAX > 1)
    {
      if (match_icase)
        {
          /* mbtolower adds a NUL byte at the end.  That will provide
	     space for the sentinel byte dfaexec may add.  */
          char *case_buf = mbtolower (buf, &size);
	  if (start_ptr)
	    start_ptr = case_buf + (start_ptr - buf);
          buf = case_buf;
        }
    }
#endif /* MBS_SUPPORT */

  mb_start = buf;
  buflim = buf + size;

  for (beg = end = buf; end < buflim; beg = end)
    {
      if (!start_ptr)
	{
	  /* We don't care about an exact match.  */
	  if (kwset)
	    {
	      /* Find a possible match using the KWset matcher. */
	      size_t offset = kwsexec (kwset, beg, buflim - beg, &kwsm);
	      if (offset == (size_t) -1)
		goto failure;
	      beg += offset;
	      /* Narrow down to the line containing the candidate, and
		 run it through DFA. */
	      if ((end = memchr(beg, eol, buflim - beg)) != NULL)
	        end++;
              else
                end = buflim;
	      match = beg;
	      while (beg > buf && beg[-1] != eol)
		--beg;
	      if (kwsm.index < kwset_exact_matches)
                {
#ifdef MBS_SUPPORT
                  if (mb_start < beg)
                    mb_start = beg;
                  if (MB_CUR_MAX == 1 || !is_mb_middle (&mb_start, match, buflim))
#endif
                    goto success;
                }
	      if (dfaexec (&dfa, beg, (char *) end, 0, NULL, &backref) == NULL)
		continue;
	    }
	  else
	    {
	      /* No good fixed strings; start with DFA. */
	      char const *next_beg = dfaexec (&dfa, beg, (char *) buflim,
					      0, NULL, &backref);
	      if (next_beg == NULL)
		break;
	      /* Narrow down to the line we've found. */
	      beg = next_beg;
	      if ((end = memchr(beg, eol, buflim - beg)) != NULL)
	        end++;
              else
                end = buflim;
	      while (beg > buf && beg[-1] != eol)
		--beg;
	    }
	  /* Successful, no backreferences encountered! */
	  if (!backref)
	    goto success;
	}
      else
	{
	  /* We are looking for the leftmost (then longest) exact match.
	     We will go through the outer loop only once.  */
	  beg = start_ptr;
	  end = buflim;
	}

      /* If we've made it to this point, this means DFA has seen
	 a probable match, and we need to run it through Regex. */
      best_match = end;
      best_len = 0;
      for (i = 0; i < pcount; i++)
	{
	  patterns[i].regexbuf.not_eol = 0;
	  if (0 <= (start = re_search (&(patterns[i].regexbuf),
				       buf, end - buf - 1,
				       beg - buf, end - beg - 1,
				       &(patterns[i].regs))))
	    {
	      len = patterns[i].regs.end[0] - start;
	      match = buf + start;
	      if (match > best_match)
		continue;
	      if (start_ptr && !match_words)
		goto assess_pattern_match;
	      if ((!match_lines && !match_words)
		  || (match_lines && len == end - beg - 1))
		{
		  match = beg;
		  len = end - beg;
		  goto assess_pattern_match;
		}
	      /* If -w, check if the match aligns with word boundaries.
		 We do this iteratively because:
		 (a) the line may contain more than one occurence of the
		 pattern, and
		 (b) Several alternatives in the pattern might be valid at a
		 given point, and we may need to consider a shorter one to
		 find a word boundary.  */
	      if (match_words)
		while (match <= best_match)
		  {
		    if ((match == buf || !WCHAR ((unsigned char) match[-1]))
			&& (len == end - beg - 1
			    || !WCHAR ((unsigned char) match[len])))
		      goto assess_pattern_match;
		    if (len > 0)
		      {
			/* Try a shorter length anchored at the same place. */
			--len;
			patterns[i].regexbuf.not_eol = 1;
			len = re_match (&(patterns[i].regexbuf),
					buf, match + len - beg, match - buf,
					&(patterns[i].regs));
		      }
		    if (len <= 0)
		      {
			/* Try looking further on. */
			if (match == end - 1)
			  break;
			match++;
			patterns[i].regexbuf.not_eol = 0;
			start = re_search (&(patterns[i].regexbuf),
					   buf, end - buf - 1,
					   match - buf, end - match - 1,
					   &(patterns[i].regs));
			if (start < 0)
			  break;
			len = patterns[i].regs.end[0] - start;
			match = buf + start;
		      }
		  } /* while (match <= best_match) */
	      continue;
	    assess_pattern_match:
	      if (!start_ptr)
		{
		  /* Good enough for a non-exact match.
		     No need to look at further patterns, if any.  */
		  beg = match;
		  goto success_in_len;
		}
	      if (match < best_match || (match == best_match && len > best_len))
		{
		  /* Best exact match:  leftmost, then longest.  */
		  best_match = match;
		  best_len = len;
		}
	    } /* if re_search >= 0 */
	} /* for Regex patterns.  */
	if (best_match < end)
	  {
	    /* We have found an exact match.  We were just
	       waiting for the best one (leftmost then longest).  */
	    beg = best_match;
	    len = best_len;
	    goto success_in_len;
	  }
    } /* for (beg = end ..) */

 failure:
  ret_val = -1;
  goto out;

 success:
  len = end - beg;
 success_in_len:
  *match_size = len;
  ret_val = beg - buf;
 out:
  return ret_val;
}

Building:src at:
/home/ubuntu/spr-fast/tests/corebench/grep/grep-case-8a025cf8-8f08d8e2/tempworkdir-l/srcTrying Negative cases!
Running test command:
/home/ubuntu/spr-fast/tools/grep-test.py /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-8a025cf8-8f08d8e2/tempworkdir-l/src /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-8a025cf8-8f08d8e2/tempworkdir-l/tests /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-8a025cf8-8f08d8e2/tempworkdir-l 0  > __res
Trying Positive cases!
Running test command:
/home/ubuntu/spr-fast/tools/grep-test.py /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-8a025cf8-8f08d8e2/tempworkdir-l/src /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-8a025cf8-8f08d8e2/tempworkdir-l/tests /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-8a025cf8-8f08d8e2/tempworkdir-l 11 14 17 22  > __res
Final attempt 3/4 with expr int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); void* memset(void*, int, unsigned long); 
/* dfasearch.c - searching subroutines using dfa and regex for grep.
   Copyright 1992, 1998, 2000, 2007, 2009-2010 Free Software Foundation, Inc.

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 3, or (at your option)
   any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program; if not, write to the Free Software
   Foundation, Inc., 51 Franklin Street - Fifth Floor, Boston, MA
   02110-1301, USA.  */

/* Written August 1992 by Mike Haertel. */

#include <config.h>
#include "search.h"
#include "dfa.h"

/* For -w, we also consider _ to be word constituent.  */
#define WCHAR(C) (ISALNUM(C) || (C) == '_')

/* KWset compiled pattern.  For Ecompile and Gcompile, we compile
   a list of strings, at least one of which is known to occur in
   any string matching the regexp. */
static kwset_t kwset;

/* DFA compiled regexp. */
static struct dfa dfa;

/* The Regex compiled patterns.  */
static struct patterns
{
  /* Regex compiled regexp. */
  struct re_pattern_buffer regexbuf;
  struct re_registers regs; /* This is here on account of a BRAIN-DEAD
			       Q@#%!# library interface in regex.c.  */
} patterns0;

struct patterns *patterns;
size_t pcount;

void
dfaerror (char const *mesg)
{
  error (EXIT_TROUBLE, 0, "%s", mesg);

  /* notreached */
  /* Tell static analyzers that this function does not return.  */
  abort ();
}

/* Number of compiled fixed strings known to exactly match the regexp.
   If kwsexec returns < kwset_exact_matches, then we don't need to
   call the regexp matcher at all. */
static int kwset_exact_matches;

static char const *
kwsincr_case (const char *must)
{
  const char *buf;
  size_t n;

  n = strlen (must);
#ifdef MBS_SUPPORT
  if (match_icase && MB_CUR_MAX > 1)
    buf = mbtolower (must, &n);
  else
#endif
    buf = must;
  return kwsincr (kwset, buf, n);
}

/* If the DFA turns out to have some set of fixed strings one of
   which must occur in the match, then we build a kwset matcher
   to find those strings, and thus quickly filter out impossible
   matches. */
static void
kwsmusts (void)
{
  struct dfamust const *dm;
  char const *err;

  if (dfa.musts)
    {
      kwsinit (&kwset);
      /* First, we compile in the substrings known to be exact
	 matches.  The kwset matcher will return the index
	 of the matching string that it chooses. */
      for (dm = dfa.musts; dm; dm = dm->next)
	{
	  //prophet generated patch
	  if ((!dm->exact) && !((0)))
	      continue;
	  ++kwset_exact_matches;
	  if ((err = kwsincr_case (dm->must)) != NULL)
	    error (EXIT_TROUBLE, 0, "%s", err);
	}
      /* Now, we compile the substrings that will require
	 the use of the regexp matcher.  */
      for (dm = dfa.musts; dm; dm = dm->next)
	{
	  if (dm->exact)
	    continue;
	  if ((err = kwsincr_case (dm->must)) != NULL)
	    error (EXIT_TROUBLE, 0, "%s", err);
	}
      if ((err = kwsprep (kwset)) != NULL)
	error (EXIT_TROUBLE, 0, "%s", err);
    }
}

void
GEAcompile (char const *pattern, size_t size, reg_syntax_t syntax_bits)
{
  const char *err;
  const char *p, *sep;
  size_t total = size;
  char *motif;

  if (match_icase)
    syntax_bits |= RE_ICASE;
  re_set_syntax (syntax_bits);
  dfasyntax (syntax_bits, match_icase, eolbyte);

  /* For GNU regex compiler we have to pass the patterns separately to detect
     errors like "[\nallo\n]\n".  The patterns here are "[", "allo" and "]"
     GNU regex should have raise a syntax error.  The same for backref, where
     the backref should have been local to each pattern.  */
  p = pattern;
  do
    {
      size_t len;
      sep = memchr (p, '\n', total);
      if (sep)
	{
	  len = sep - p;
	  sep++;
	  total -= (len + 1);
	}
      else
	{
	  len = total;
	  total = 0;
	}

      patterns = realloc (patterns, (pcount + 1) * sizeof (*patterns));
      if (patterns == NULL)
	error (EXIT_TROUBLE, errno, _("memory exhausted"));
      patterns[pcount] = patterns0;

      if ((err = re_compile_pattern (p, len,
				    &(patterns[pcount].regexbuf))) != NULL)
	error (EXIT_TROUBLE, 0, "%s", err);
      pcount++;

      p = sep;
    } while (sep && total != 0);

  /* In the match_words and match_lines cases, we use a different pattern
     for the DFA matcher that will quickly throw out cases that won't work.
     Then if DFA succeeds we do some hairy stuff using the regex matcher
     to decide whether the match should really count. */
  if (match_words || match_lines)
    {
      static char const line_beg_no_bk[] = "^(";
      static char const line_end_no_bk[] = ")$";
      static char const word_beg_no_bk[] = "(^|[^[:alnum:]_])(";
      static char const word_end_no_bk[] = ")([^[:alnum:]_]|$)";
      static char const line_beg_bk[] = "^\\(";
      static char const line_end_bk[] = "\\)$";
      static char const word_beg_bk[] = "\\(^\\|[^[:alnum:]_]\\)\\(";
      static char const word_end_bk[] = "\\)\\([^[:alnum:]_]\\|$\\)";
      int bk = !(syntax_bits & RE_NO_BK_PARENS);
      char *n = xmalloc (sizeof word_beg_bk - 1 + size + sizeof word_end_bk);

      strcpy (n, match_lines ? (bk ? line_beg_bk : line_beg_no_bk)
			     : (bk ? word_beg_bk : word_beg_no_bk));
      total = strlen(n);
      memcpy (n + total, pattern, size);
      total += size;
      strcpy (n + total, match_lines ? (bk ? line_end_bk : line_end_no_bk)
				     : (bk ? word_end_bk : word_end_no_bk));
      total += strlen (n + total);
      pattern = motif = n;
      size = total;
    }
  else
    motif = NULL;

  dfacomp (pattern, size, &dfa, 1);
  kwsmusts ();

  free(motif);
}

size_t
EGexecute (char const *buf, size_t size, size_t *match_size,
	   char const *start_ptr)
{
  char const *buflim, *beg, *end, *match, *best_match, *mb_start;
  char eol = eolbyte;
  int backref, start, len, best_len;
  struct kwsmatch kwsm;
  size_t i, ret_val;
#ifdef MBS_SUPPORT
  if (MB_CUR_MAX > 1)
    {
      if (match_icase)
        {
          /* mbtolower adds a NUL byte at the end.  That will provide
	     space for the sentinel byte dfaexec may add.  */
          char *case_buf = mbtolower (buf, &size);
	  if (start_ptr)
	    start_ptr = case_buf + (start_ptr - buf);
          buf = case_buf;
        }
    }
#endif /* MBS_SUPPORT */

  mb_start = buf;
  buflim = buf + size;

  for (beg = end = buf; end < buflim; beg = end)
    {
      if (!start_ptr)
	{
	  /* We don't care about an exact match.  */
	  if (kwset)
	    {
	      /* Find a possible match using the KWset matcher. */
	      size_t offset = kwsexec (kwset, beg, buflim - beg, &kwsm);
	      if (offset == (size_t) -1)
		goto failure;
	      beg += offset;
	      /* Narrow down to the line containing the candidate, and
		 run it through DFA. */
	      if ((end = memchr(beg, eol, buflim - beg)) != NULL)
	        end++;
              else
                end = buflim;
	      match = beg;
	      while (beg > buf && beg[-1] != eol)
		--beg;
	      if (kwsm.index < kwset_exact_matches)
                {
#ifdef MBS_SUPPORT
                  if (mb_start < beg)
                    mb_start = beg;
                  if (MB_CUR_MAX == 1 || !is_mb_middle (&mb_start, match, buflim))
#endif
                    goto success;
                }
	      if (dfaexec (&dfa, beg, (char *) end, 0, NULL, &backref) == NULL)
		continue;
	    }
	  else
	    {
	      /* No good fixed strings; start with DFA. */
	      char const *next_beg = dfaexec (&dfa, beg, (char *) buflim,
					      0, NULL, &backref);
	      if (next_beg == NULL)
		break;
	      /* Narrow down to the line we've found. */
	      beg = next_beg;
	      if ((end = memchr(beg, eol, buflim - beg)) != NULL)
	        end++;
              else
                end = buflim;
	      while (beg > buf && beg[-1] != eol)
		--beg;
	    }
	  /* Successful, no backreferences encountered! */
	  if (!backref)
	    goto success;
	}
      else
	{
	  /* We are looking for the leftmost (then longest) exact match.
	     We will go through the outer loop only once.  */
	  beg = start_ptr;
	  end = buflim;
	}

      /* If we've made it to this point, this means DFA has seen
	 a probable match, and we need to run it through Regex. */
      best_match = end;
      best_len = 0;
      for (i = 0; i < pcount; i++)
	{
	  patterns[i].regexbuf.not_eol = 0;
	  if (0 <= (start = re_search (&(patterns[i].regexbuf),
				       buf, end - buf - 1,
				       beg - buf, end - beg - 1,
				       &(patterns[i].regs))))
	    {
	      len = patterns[i].regs.end[0] - start;
	      match = buf + start;
	      if (match > best_match)
		continue;
	      if (start_ptr && !match_words)
		goto assess_pattern_match;
	      if ((!match_lines && !match_words)
		  || (match_lines && len == end - beg - 1))
		{
		  match = beg;
		  len = end - beg;
		  goto assess_pattern_match;
		}
	      /* If -w, check if the match aligns with word boundaries.
		 We do this iteratively because:
		 (a) the line may contain more than one occurence of the
		 pattern, and
		 (b) Several alternatives in the pattern might be valid at a
		 given point, and we may need to consider a shorter one to
		 find a word boundary.  */
	      if (match_words)
		while (match <= best_match)
		  {
		    if ((match == buf || !WCHAR ((unsigned char) match[-1]))
			&& (len == end - beg - 1
			    || !WCHAR ((unsigned char) match[len])))
		      goto assess_pattern_match;
		    if (len > 0)
		      {
			/* Try a shorter length anchored at the same place. */
			--len;
			patterns[i].regexbuf.not_eol = 1;
			len = re_match (&(patterns[i].regexbuf),
					buf, match + len - beg, match - buf,
					&(patterns[i].regs));
		      }
		    if (len <= 0)
		      {
			/* Try looking further on. */
			if (match == end - 1)
			  break;
			match++;
			patterns[i].regexbuf.not_eol = 0;
			start = re_search (&(patterns[i].regexbuf),
					   buf, end - buf - 1,
					   match - buf, end - match - 1,
					   &(patterns[i].regs));
			if (start < 0)
			  break;
			len = patterns[i].regs.end[0] - start;
			match = buf + start;
		      }
		  } /* while (match <= best_match) */
	      continue;
	    assess_pattern_match:
	      if (!start_ptr)
		{
		  /* Good enough for a non-exact match.
		     No need to look at further patterns, if any.  */
		  beg = match;
		  goto success_in_len;
		}
	      if (match < best_match || (match == best_match && len > best_len))
		{
		  /* Best exact match:  leftmost, then longest.  */
		  best_match = match;
		  best_len = len;
		}
	    } /* if re_search >= 0 */
	} /* for Regex patterns.  */
	if (best_match < end)
	  {
	    /* We have found an exact match.  We were just
	       waiting for the best one (leftmost then longest).  */
	    beg = best_match;
	    len = best_len;
	    goto success_in_len;
	  }
    } /* for (beg = end ..) */

 failure:
  ret_val = -1;
  goto out;

 success:
  len = end - beg;
 success_in_len:
  *match_size = len;
  ret_val = beg - buf;
 out:
  return ret_val;
}

Building:src at:
/home/ubuntu/spr-fast/tests/corebench/grep/grep-case-8a025cf8-8f08d8e2/tempworkdir-l/srcTrying Negative cases!
Running test command:
/home/ubuntu/spr-fast/tools/grep-test.py /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-8a025cf8-8f08d8e2/tempworkdir-l/src /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-8a025cf8-8f08d8e2/tempworkdir-l/tests /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-8a025cf8-8f08d8e2/tempworkdir-l 0  > __res
Final attempt 4/4 with expr int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); void* memset(void*, int, unsigned long); 
/* dfasearch.c - searching subroutines using dfa and regex for grep.
   Copyright 1992, 1998, 2000, 2007, 2009-2010 Free Software Foundation, Inc.

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 3, or (at your option)
   any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program; if not, write to the Free Software
   Foundation, Inc., 51 Franklin Street - Fifth Floor, Boston, MA
   02110-1301, USA.  */

/* Written August 1992 by Mike Haertel. */

#include <config.h>
#include "search.h"
#include "dfa.h"

/* For -w, we also consider _ to be word constituent.  */
#define WCHAR(C) (ISALNUM(C) || (C) == '_')

/* KWset compiled pattern.  For Ecompile and Gcompile, we compile
   a list of strings, at least one of which is known to occur in
   any string matching the regexp. */
static kwset_t kwset;

/* DFA compiled regexp. */
static struct dfa dfa;

/* The Regex compiled patterns.  */
static struct patterns
{
  /* Regex compiled regexp. */
  struct re_pattern_buffer regexbuf;
  struct re_registers regs; /* This is here on account of a BRAIN-DEAD
			       Q@#%!# library interface in regex.c.  */
} patterns0;

struct patterns *patterns;
size_t pcount;

void
dfaerror (char const *mesg)
{
  error (EXIT_TROUBLE, 0, "%s", mesg);

  /* notreached */
  /* Tell static analyzers that this function does not return.  */
  abort ();
}

/* Number of compiled fixed strings known to exactly match the regexp.
   If kwsexec returns < kwset_exact_matches, then we don't need to
   call the regexp matcher at all. */
static int kwset_exact_matches;

static char const *
kwsincr_case (const char *must)
{
  const char *buf;
  size_t n;

  n = strlen (must);
#ifdef MBS_SUPPORT
  if (match_icase && MB_CUR_MAX > 1)
    buf = mbtolower (must, &n);
  else
#endif
    buf = must;
  return kwsincr (kwset, buf, n);
}

/* If the DFA turns out to have some set of fixed strings one of
   which must occur in the match, then we build a kwset matcher
   to find those strings, and thus quickly filter out impossible
   matches. */
static void
kwsmusts (void)
{
  struct dfamust const *dm;
  char const *err;

  if (dfa.musts)
    {
      kwsinit (&kwset);
      /* First, we compile in the substrings known to be exact
	 matches.  The kwset matcher will return the index
	 of the matching string that it chooses. */
      for (dm = dfa.musts; dm; dm = dm->next)
	{
	  //prophet generated patch
	  if ((!dm->exact) && !((1)))
	      continue;
	  ++kwset_exact_matches;
	  if ((err = kwsincr_case (dm->must)) != NULL)
	    error (EXIT_TROUBLE, 0, "%s", err);
	}
      /* Now, we compile the substrings that will require
	 the use of the regexp matcher.  */
      for (dm = dfa.musts; dm; dm = dm->next)
	{
	  if (dm->exact)
	    continue;
	  if ((err = kwsincr_case (dm->must)) != NULL)
	    error (EXIT_TROUBLE, 0, "%s", err);
	}
      if ((err = kwsprep (kwset)) != NULL)
	error (EXIT_TROUBLE, 0, "%s", err);
    }
}

void
GEAcompile (char const *pattern, size_t size, reg_syntax_t syntax_bits)
{
  const char *err;
  const char *p, *sep;
  size_t total = size;
  char *motif;

  if (match_icase)
    syntax_bits |= RE_ICASE;
  re_set_syntax (syntax_bits);
  dfasyntax (syntax_bits, match_icase, eolbyte);

  /* For GNU regex compiler we have to pass the patterns separately to detect
     errors like "[\nallo\n]\n".  The patterns here are "[", "allo" and "]"
     GNU regex should have raise a syntax error.  The same for backref, where
     the backref should have been local to each pattern.  */
  p = pattern;
  do
    {
      size_t len;
      sep = memchr (p, '\n', total);
      if (sep)
	{
	  len = sep - p;
	  sep++;
	  total -= (len + 1);
	}
      else
	{
	  len = total;
	  total = 0;
	}

      patterns = realloc (patterns, (pcount + 1) * sizeof (*patterns));
      if (patterns == NULL)
	error (EXIT_TROUBLE, errno, _("memory exhausted"));
      patterns[pcount] = patterns0;

      if ((err = re_compile_pattern (p, len,
				    &(patterns[pcount].regexbuf))) != NULL)
	error (EXIT_TROUBLE, 0, "%s", err);
      pcount++;

      p = sep;
    } while (sep && total != 0);

  /* In the match_words and match_lines cases, we use a different pattern
     for the DFA matcher that will quickly throw out cases that won't work.
     Then if DFA succeeds we do some hairy stuff using the regex matcher
     to decide whether the match should really count. */
  if (match_words || match_lines)
    {
      static char const line_beg_no_bk[] = "^(";
      static char const line_end_no_bk[] = ")$";
      static char const word_beg_no_bk[] = "(^|[^[:alnum:]_])(";
      static char const word_end_no_bk[] = ")([^[:alnum:]_]|$)";
      static char const line_beg_bk[] = "^\\(";
      static char const line_end_bk[] = "\\)$";
      static char const word_beg_bk[] = "\\(^\\|[^[:alnum:]_]\\)\\(";
      static char const word_end_bk[] = "\\)\\([^[:alnum:]_]\\|$\\)";
      int bk = !(syntax_bits & RE_NO_BK_PARENS);
      char *n = xmalloc (sizeof word_beg_bk - 1 + size + sizeof word_end_bk);

      strcpy (n, match_lines ? (bk ? line_beg_bk : line_beg_no_bk)
			     : (bk ? word_beg_bk : word_beg_no_bk));
      total = strlen(n);
      memcpy (n + total, pattern, size);
      total += size;
      strcpy (n + total, match_lines ? (bk ? line_end_bk : line_end_no_bk)
				     : (bk ? word_end_bk : word_end_no_bk));
      total += strlen (n + total);
      pattern = motif = n;
      size = total;
    }
  else
    motif = NULL;

  dfacomp (pattern, size, &dfa, 1);
  kwsmusts ();

  free(motif);
}

size_t
EGexecute (char const *buf, size_t size, size_t *match_size,
	   char const *start_ptr)
{
  char const *buflim, *beg, *end, *match, *best_match, *mb_start;
  char eol = eolbyte;
  int backref, start, len, best_len;
  struct kwsmatch kwsm;
  size_t i, ret_val;
#ifdef MBS_SUPPORT
  if (MB_CUR_MAX > 1)
    {
      if (match_icase)
        {
          /* mbtolower adds a NUL byte at the end.  That will provide
	     space for the sentinel byte dfaexec may add.  */
          char *case_buf = mbtolower (buf, &size);
	  if (start_ptr)
	    start_ptr = case_buf + (start_ptr - buf);
          buf = case_buf;
        }
    }
#endif /* MBS_SUPPORT */

  mb_start = buf;
  buflim = buf + size;

  for (beg = end = buf; end < buflim; beg = end)
    {
      if (!start_ptr)
	{
	  /* We don't care about an exact match.  */
	  if (kwset)
	    {
	      /* Find a possible match using the KWset matcher. */
	      size_t offset = kwsexec (kwset, beg, buflim - beg, &kwsm);
	      if (offset == (size_t) -1)
		goto failure;
	      beg += offset;
	      /* Narrow down to the line containing the candidate, and
		 run it through DFA. */
	      if ((end = memchr(beg, eol, buflim - beg)) != NULL)
	        end++;
              else
                end = buflim;
	      match = beg;
	      while (beg > buf && beg[-1] != eol)
		--beg;
	      if (kwsm.index < kwset_exact_matches)
                {
#ifdef MBS_SUPPORT
                  if (mb_start < beg)
                    mb_start = beg;
                  if (MB_CUR_MAX == 1 || !is_mb_middle (&mb_start, match, buflim))
#endif
                    goto success;
                }
	      if (dfaexec (&dfa, beg, (char *) end, 0, NULL, &backref) == NULL)
		continue;
	    }
	  else
	    {
	      /* No good fixed strings; start with DFA. */
	      char const *next_beg = dfaexec (&dfa, beg, (char *) buflim,
					      0, NULL, &backref);
	      if (next_beg == NULL)
		break;
	      /* Narrow down to the line we've found. */
	      beg = next_beg;
	      if ((end = memchr(beg, eol, buflim - beg)) != NULL)
	        end++;
              else
                end = buflim;
	      while (beg > buf && beg[-1] != eol)
		--beg;
	    }
	  /* Successful, no backreferences encountered! */
	  if (!backref)
	    goto success;
	}
      else
	{
	  /* We are looking for the leftmost (then longest) exact match.
	     We will go through the outer loop only once.  */
	  beg = start_ptr;
	  end = buflim;
	}

      /* If we've made it to this point, this means DFA has seen
	 a probable match, and we need to run it through Regex. */
      best_match = end;
      best_len = 0;
      for (i = 0; i < pcount; i++)
	{
	  patterns[i].regexbuf.not_eol = 0;
	  if (0 <= (start = re_search (&(patterns[i].regexbuf),
				       buf, end - buf - 1,
				       beg - buf, end - beg - 1,
				       &(patterns[i].regs))))
	    {
	      len = patterns[i].regs.end[0] - start;
	      match = buf + start;
	      if (match > best_match)
		continue;
	      if (start_ptr && !match_words)
		goto assess_pattern_match;
	      if ((!match_lines && !match_words)
		  || (match_lines && len == end - beg - 1))
		{
		  match = beg;
		  len = end - beg;
		  goto assess_pattern_match;
		}
	      /* If -w, check if the match aligns with word boundaries.
		 We do this iteratively because:
		 (a) the line may contain more than one occurence of the
		 pattern, and
		 (b) Several alternatives in the pattern might be valid at a
		 given point, and we may need to consider a shorter one to
		 find a word boundary.  */
	      if (match_words)
		while (match <= best_match)
		  {
		    if ((match == buf || !WCHAR ((unsigned char) match[-1]))
			&& (len == end - beg - 1
			    || !WCHAR ((unsigned char) match[len])))
		      goto assess_pattern_match;
		    if (len > 0)
		      {
			/* Try a shorter length anchored at the same place. */
			--len;
			patterns[i].regexbuf.not_eol = 1;
			len = re_match (&(patterns[i].regexbuf),
					buf, match + len - beg, match - buf,
					&(patterns[i].regs));
		      }
		    if (len <= 0)
		      {
			/* Try looking further on. */
			if (match == end - 1)
			  break;
			match++;
			patterns[i].regexbuf.not_eol = 0;
			start = re_search (&(patterns[i].regexbuf),
					   buf, end - buf - 1,
					   match - buf, end - match - 1,
					   &(patterns[i].regs));
			if (start < 0)
			  break;
			len = patterns[i].regs.end[0] - start;
			match = buf + start;
		      }
		  } /* while (match <= best_match) */
	      continue;
	    assess_pattern_match:
	      if (!start_ptr)
		{
		  /* Good enough for a non-exact match.
		     No need to look at further patterns, if any.  */
		  beg = match;
		  goto success_in_len;
		}
	      if (match < best_match || (match == best_match && len > best_len))
		{
		  /* Best exact match:  leftmost, then longest.  */
		  best_match = match;
		  best_len = len;
		}
	    } /* if re_search >= 0 */
	} /* for Regex patterns.  */
	if (best_match < end)
	  {
	    /* We have found an exact match.  We were just
	       waiting for the best one (leftmost then longest).  */
	    beg = best_match;
	    len = best_len;
	    goto success_in_len;
	  }
    } /* for (beg = end ..) */

 failure:
  ret_val = -1;
  goto out;

 success:
  len = end - beg;
 success_in_len:
  *match_size = len;
  ret_val = beg - buf;
 out:
  return ret_val;
}

Building:src at:
/home/ubuntu/spr-fast/tests/corebench/grep/grep-case-8a025cf8-8f08d8e2/tempworkdir-l/srcTrying Negative cases!
Running test command:
/home/ubuntu/spr-fast/tools/grep-test.py /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-8a025cf8-8f08d8e2/tempworkdir-l/src /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-8a025cf8-8f08d8e2/tempworkdir-l/tests /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-8a025cf8-8f08d8e2/tempworkdir-l 0  > __res
Trying Positive cases!
Running test command:
/home/ubuntu/spr-fast/tools/grep-test.py /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-8a025cf8-8f08d8e2/tempworkdir-l/src /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-8a025cf8-8f08d8e2/tempworkdir-l/tests /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-8a025cf8-8f08d8e2/tempworkdir-l 11 14 17 22  > __res
Postprocessing failed!
a batched test job starts!
Building merged code:
src_file: src/dfasearch.c
full src: int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); void* memset(void*, int, unsigned long); 
/* dfasearch.c - searching subroutines using dfa and regex for grep.
   Copyright 1992, 1998, 2000, 2007, 2009-2010 Free Software Foundation, Inc.

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 3, or (at your option)
   any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program; if not, write to the Free Software
   Foundation, Inc., 51 Franklin Street - Fifth Floor, Boston, MA
   02110-1301, USA.  */

/* Written August 1992 by Mike Haertel. */

#include <config.h>
#include "search.h"
#include "dfa.h"

/* For -w, we also consider _ to be word constituent.  */
#define WCHAR(C) (ISALNUM(C) || (C) == '_')

/* KWset compiled pattern.  For Ecompile and Gcompile, we compile
   a list of strings, at least one of which is known to occur in
   any string matching the regexp. */
static kwset_t kwset;

/* DFA compiled regexp. */
static struct dfa dfa;

/* The Regex compiled patterns.  */
static struct patterns
{
  /* Regex compiled regexp. */
  struct re_pattern_buffer regexbuf;
  struct re_registers regs; /* This is here on account of a BRAIN-DEAD
			       Q@#%!# library interface in regex.c.  */
} patterns0;

struct patterns *patterns;
size_t pcount;

void
dfaerror (char const *mesg)
{
  error (EXIT_TROUBLE, 0, "%s", mesg);

  /* notreached */
  /* Tell static analyzers that this function does not return.  */
  abort ();
}

/* Number of compiled fixed strings known to exactly match the regexp.
   If kwsexec returns < kwset_exact_matches, then we don't need to
   call the regexp matcher at all. */
static int kwset_exact_matches;

static char const *
kwsincr_case (const char *must)
{
  const char *buf;
  size_t n;

  n = strlen (must);
#ifdef MBS_SUPPORT
  if (match_icase && MB_CUR_MAX > 1)
    buf = mbtolower (must, &n);
  else
#endif
    buf = must;
  return kwsincr (kwset, buf, n);
}

/* If the DFA turns out to have some set of fixed strings one of
   which must occur in the match, then we build a kwset matcher
   to find those strings, and thus quickly filter out impossible
   matches. */
static void
kwsmusts (void)
{
  struct dfamust const *dm;
  char const *err;

  if (dfa.musts)
    {
      kwsinit (&kwset);
      /* First, we compile in the substrings known to be exact
	 matches.  The kwset matcher will return the index
	 of the matching string that it chooses. */
      for (dm = dfa.musts; dm; dm = dm->next)
	{
	  if (!dm->exact)
	    continue;
	  ++kwset_exact_matches;
	  if ((err = kwsincr_case (dm->must)) != NULL)
	    error (EXIT_TROUBLE, 0, "%s", err);
	}
      /* Now, we compile the substrings that will require
	 the use of the regexp matcher.  */
      for (dm = dfa.musts; dm; dm = dm->next)
	{
	  //prophet generated patch
	  if (__get_mutant()==0) {
	  if ((dm->exact) && !(__is_neg(7, &(dm), sizeof (dm), &(dm->exact), sizeof (dm->exact), &(err), sizeof (err), &(dm->must), sizeof (dm->must), &(dm->next), sizeof (dm->next), &(kwset), sizeof (kwset), &(kwset_exact_matches), sizeof (kwset_exact_matches))))
	      continue;
	  }
	  else if (__get_mutant()==1) {
	  if ((dm->exact) || (__is_neg(7, &(dm), sizeof (dm), &(dm->exact), sizeof (dm->exact), &(err), sizeof (err), &(dm->must), sizeof (dm->must), &(dm->next), sizeof (dm->next), &(kwset), sizeof (kwset), &(kwset_exact_matches), sizeof (kwset_exact_matches))))
	      continue;
	  }
	  if ((err = kwsincr_case (dm->must)) != NULL)
	    error (EXIT_TROUBLE, 0, "%s", err);
	}
      if ((err = kwsprep (kwset)) != NULL)
	error (EXIT_TROUBLE, 0, "%s", err);
    }
}

void
GEAcompile (char const *pattern, size_t size, reg_syntax_t syntax_bits)
{
  const char *err;
  const char *p, *sep;
  size_t total = size;
  char *motif;

  if (match_icase)
    syntax_bits |= RE_ICASE;
  re_set_syntax (syntax_bits);
  dfasyntax (syntax_bits, match_icase, eolbyte);

  /* For GNU regex compiler we have to pass the patterns separately to detect
     errors like "[\nallo\n]\n".  The patterns here are "[", "allo" and "]"
     GNU regex should have raise a syntax error.  The same for backref, where
     the backref should have been local to each pattern.  */
  p = pattern;
  do
    {
      size_t len;
      sep = memchr (p, '\n', total);
      if (sep)
	{
	  len = sep - p;
	  sep++;
	  total -= (len + 1);
	}
      else
	{
	  len = total;
	  total = 0;
	}

      patterns = realloc (patterns, (pcount + 1) * sizeof (*patterns));
      if (patterns == NULL)
	error (EXIT_TROUBLE, errno, _("memory exhausted"));
      patterns[pcount] = patterns0;

      if ((err = re_compile_pattern (p, len,
				    &(patterns[pcount].regexbuf))) != NULL)
	error (EXIT_TROUBLE, 0, "%s", err);
      pcount++;

      p = sep;
    } while (sep && total != 0);

  /* In the match_words and match_lines cases, we use a different pattern
     for the DFA matcher that will quickly throw out cases that won't work.
     Then if DFA succeeds we do some hairy stuff using the regex matcher
     to decide whether the match should really count. */
  if (match_words || match_lines)
    {
      static char const line_beg_no_bk[] = "^(";
      static char const line_end_no_bk[] = ")$";
      static char const word_beg_no_bk[] = "(^|[^[:alnum:]_])(";
      static char const word_end_no_bk[] = ")([^[:alnum:]_]|$)";
      static char const line_beg_bk[] = "^\\(";
      static char const line_end_bk[] = "\\)$";
      static char const word_beg_bk[] = "\\(^\\|[^[:alnum:]_]\\)\\(";
      static char const word_end_bk[] = "\\)\\([^[:alnum:]_]\\|$\\)";
      int bk = !(syntax_bits & RE_NO_BK_PARENS);
      char *n = xmalloc (sizeof word_beg_bk - 1 + size + sizeof word_end_bk);

      strcpy (n, match_lines ? (bk ? line_beg_bk : line_beg_no_bk)
			     : (bk ? word_beg_bk : word_beg_no_bk));
      total = strlen(n);
      memcpy (n + total, pattern, size);
      total += size;
      strcpy (n + total, match_lines ? (bk ? line_end_bk : line_end_no_bk)
				     : (bk ? word_end_bk : word_end_no_bk));
      total += strlen (n + total);
      pattern = motif = n;
      size = total;
    }
  else
    motif = NULL;

  dfacomp (pattern, size, &dfa, 1);
  kwsmusts ();

  free(motif);
}

size_t
EGexecute (char const *buf, size_t size, size_t *match_size,
	   char const *start_ptr)
{
  char const *buflim, *beg, *end, *match, *best_match, *mb_start;
  char eol = eolbyte;
  int backref, start, len, best_len;
  struct kwsmatch kwsm;
  size_t i, ret_val;
#ifdef MBS_SUPPORT
  if (MB_CUR_MAX > 1)
    {
      if (match_icase)
        {
          /* mbtolower adds a NUL byte at the end.  That will provide
	     space for the sentinel byte dfaexec may add.  */
          char *case_buf = mbtolower (buf, &size);
	  if (start_ptr)
	    start_ptr = case_buf + (start_ptr - buf);
          buf = case_buf;
        }
    }
#endif /* MBS_SUPPORT */

  mb_start = buf;
  buflim = buf + size;

  for (beg = end = buf; end < buflim; beg = end)
    {
      if (!start_ptr)
	{
	  /* We don't care about an exact match.  */
	  if (kwset)
	    {
	      /* Find a possible match using the KWset matcher. */
	      size_t offset = kwsexec (kwset, beg, buflim - beg, &kwsm);
	      if (offset == (size_t) -1)
		goto failure;
	      beg += offset;
	      /* Narrow down to the line containing the candidate, and
		 run it through DFA. */
	      if ((end = memchr(beg, eol, buflim - beg)) != NULL)
	        end++;
              else
                end = buflim;
	      match = beg;
	      while (beg > buf && beg[-1] != eol)
		--beg;
	      if (kwsm.index < kwset_exact_matches)
                {
#ifdef MBS_SUPPORT
                  if (mb_start < beg)
                    mb_start = beg;
                  if (MB_CUR_MAX == 1 || !is_mb_middle (&mb_start, match, buflim))
#endif
                    goto success;
                }
	      if (dfaexec (&dfa, beg, (char *) end, 0, NULL, &backref) == NULL)
		continue;
	    }
	  else
	    {
	      /* No good fixed strings; start with DFA. */
	      char const *next_beg = dfaexec (&dfa, beg, (char *) buflim,
					      0, NULL, &backref);
	      if (next_beg == NULL)
		break;
	      /* Narrow down to the line we've found. */
	      beg = next_beg;
	      if ((end = memchr(beg, eol, buflim - beg)) != NULL)
	        end++;
              else
                end = buflim;
	      while (beg > buf && beg[-1] != eol)
		--beg;
	    }
	  /* Successful, no backreferences encountered! */
	  if (!backref)
	    goto success;
	}
      else
	{
	  /* We are looking for the leftmost (then longest) exact match.
	     We will go through the outer loop only once.  */
	  beg = start_ptr;
	  end = buflim;
	}

      /* If we've made it to this point, this means DFA has seen
	 a probable match, and we need to run it through Regex. */
      best_match = end;
      best_len = 0;
      for (i = 0; i < pcount; i++)
	{
	  patterns[i].regexbuf.not_eol = 0;
	  if (0 <= (start = re_search (&(patterns[i].regexbuf),
				       buf, end - buf - 1,
				       beg - buf, end - beg - 1,
				       &(patterns[i].regs))))
	    {
	      len = patterns[i].regs.end[0] - start;
	      match = buf + start;
	      if (match > best_match)
		continue;
	      if (start_ptr && !match_words)
		goto assess_pattern_match;
	      if ((!match_lines && !match_words)
		  || (match_lines && len == end - beg - 1))
		{
		  match = beg;
		  len = end - beg;
		  goto assess_pattern_match;
		}
	      /* If -w, check if the match aligns with word boundaries.
		 We do this iteratively because:
		 (a) the line may contain more than one occurence of the
		 pattern, and
		 (b) Several alternatives in the pattern might be valid at a
		 given point, and we may need to consider a shorter one to
		 find a word boundary.  */
	      if (match_words)
		while (match <= best_match)
		  {
		    if ((match == buf || !WCHAR ((unsigned char) match[-1]))
			&& (len == end - beg - 1
			    || !WCHAR ((unsigned char) match[len])))
		      goto assess_pattern_match;
		    if (len > 0)
		      {
			/* Try a shorter length anchored at the same place. */
			--len;
			patterns[i].regexbuf.not_eol = 1;
			len = re_match (&(patterns[i].regexbuf),
					buf, match + len - beg, match - buf,
					&(patterns[i].regs));
		      }
		    if (len <= 0)
		      {
			/* Try looking further on. */
			if (match == end - 1)
			  break;
			match++;
			patterns[i].regexbuf.not_eol = 0;
			start = re_search (&(patterns[i].regexbuf),
					   buf, end - buf - 1,
					   match - buf, end - match - 1,
					   &(patterns[i].regs));
			if (start < 0)
			  break;
			len = patterns[i].regs.end[0] - start;
			match = buf + start;
		      }
		  } /* while (match <= best_match) */
	      continue;
	    assess_pattern_match:
	      if (!start_ptr)
		{
		  /* Good enough for a non-exact match.
		     No need to look at further patterns, if any.  */
		  beg = match;
		  goto success_in_len;
		}
	      if (match < best_match || (match == best_match && len > best_len))
		{
		  /* Best exact match:  leftmost, then longest.  */
		  best_match = match;
		  best_len = len;
		}
	    } /* if re_search >= 0 */
	} /* for Regex patterns.  */
	if (best_match < end)
	  {
	    /* We have found an exact match.  We were just
	       waiting for the best one (leftmost then longest).  */
	    beg = best_match;
	    len = best_len;
	    goto success_in_len;
	  }
    } /* for (beg = end ..) */

 failure:
  ret_val = -1;
  goto out;

 success:
  len = end - beg;
 success_in_len:
  *match_size = len;
  ret_val = beg - buf;
 out:
  return ret_val;
}

Building:src at:
/home/ubuntu/spr-fast/tests/corebench/grep/grep-case-8a025cf8-8f08d8e2/tempworkdir-l/srcMerged code building succ, going to invoke tester!
CondTester, Testing instance id 29:
//src_file:src/dfasearch.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); void* memset(void*, int, unsigned long); 
/* dfasearch.c - searching subroutines using dfa and regex for grep.
   Copyright 1992, 1998, 2000, 2007, 2009-2010 Free Software Foundation, Inc.

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 3, or (at your option)
   any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program; if not, write to the Free Software
   Foundation, Inc., 51 Franklin Street - Fifth Floor, Boston, MA
   02110-1301, USA.  */

/* Written August 1992 by Mike Haertel. */

#include <config.h>
#include "search.h"
#include "dfa.h"

/* For -w, we also consider _ to be word constituent.  */
#define WCHAR(C) (ISALNUM(C) || (C) == '_')

/* KWset compiled pattern.  For Ecompile and Gcompile, we compile
   a list of strings, at least one of which is known to occur in
   any string matching the regexp. */
static kwset_t kwset;

/* DFA compiled regexp. */
static struct dfa dfa;

/* The Regex compiled patterns.  */
static struct patterns
{
  /* Regex compiled regexp. */
  struct re_pattern_buffer regexbuf;
  struct re_registers regs; /* This is here on account of a BRAIN-DEAD
			       Q@#%!# library interface in regex.c.  */
} patterns0;

struct patterns *patterns;
size_t pcount;

void
dfaerror (char const *mesg)
{
  error (EXIT_TROUBLE, 0, "%s", mesg);

  /* notreached */
  /* Tell static analyzers that this function does not return.  */
  abort ();
}

/* Number of compiled fixed strings known to exactly match the regexp.
   If kwsexec returns < kwset_exact_matches, then we don't need to
   call the regexp matcher at all. */
static int kwset_exact_matches;

static char const *
kwsincr_case (const char *must)
{
  const char *buf;
  size_t n;

  n = strlen (must);
#ifdef MBS_SUPPORT
  if (match_icase && MB_CUR_MAX > 1)
    buf = mbtolower (must, &n);
  else
#endif
    buf = must;
  return kwsincr (kwset, buf, n);
}

/* If the DFA turns out to have some set of fixed strings one of
   which must occur in the match, then we build a kwset matcher
   to find those strings, and thus quickly filter out impossible
   matches. */
static void
kwsmusts (void)
{
  struct dfamust const *dm;
  char const *err;

  if (dfa.musts)
    {
      kwsinit (&kwset);
      /* First, we compile in the substrings known to be exact
	 matches.  The kwset matcher will return the index
	 of the matching string that it chooses. */
      for (dm = dfa.musts; dm; dm = dm->next)
	{
	  if (!dm->exact)
	    continue;
	  ++kwset_exact_matches;
	  if ((err = kwsincr_case (dm->must)) != NULL)
	    error (EXIT_TROUBLE, 0, "%s", err);
	}
      /* Now, we compile the substrings that will require
	 the use of the regexp matcher.  */
      for (dm = dfa.musts; dm; dm = dm->next)
	{
	  
//Patch 0:
if ((dm->exact) && !(__is_neg(7, &(dm), sizeof (dm), &(dm->exact), sizeof (dm->exact), &(err), sizeof (err), &(dm->must), sizeof (dm->must), &(dm->next), sizeof (dm->next), &(kwset), sizeof (kwset), &(kwset_exact_matches), sizeof (kwset_exact_matches))))
    continue;

//CodeSeg 1:
	  if ((err = kwsincr_case (dm->must)) != NULL)
	    error (EXIT_TROUBLE, 0, "%s", err);
	}
      if ((err = kwsprep (kwset)) != NULL)
	error (EXIT_TROUBLE, 0, "%s", err);
    }
}

void
GEAcompile (char const *pattern, size_t size, reg_syntax_t syntax_bits)
{
  const char *err;
  const char *p, *sep;
  size_t total = size;
  char *motif;

  if (match_icase)
    syntax_bits |= RE_ICASE;
  re_set_syntax (syntax_bits);
  dfasyntax (syntax_bits, match_icase, eolbyte);

  /* For GNU regex compiler we have to pass the patterns separately to detect
     errors like "[\nallo\n]\n".  The patterns here are "[", "allo" and "]"
     GNU regex should have raise a syntax error.  The same for backref, where
     the backref should have been local to each pattern.  */
  p = pattern;
  do
    {
      size_t len;
      sep = memchr (p, '\n', total);
      if (sep)
	{
	  len = sep - p;
	  sep++;
	  total -= (len + 1);
	}
      else
	{
	  len = total;
	  total = 0;
	}

      patterns = realloc (patterns, (pcount + 1) * sizeof (*patterns));
      if (patterns == NULL)
	error (EXIT_TROUBLE, errno, _("memory exhausted"));
      patterns[pcount] = patterns0;

      if ((err = re_compile_pattern (p, len,
				    &(patterns[pcount].regexbuf))) != NULL)
	error (EXIT_TROUBLE, 0, "%s", err);
      pcount++;

      p = sep;
    } while (sep && total != 0);

  /* In the match_words and match_lines cases, we use a different pattern
     for the DFA matcher that will quickly throw out cases that won't work.
     Then if DFA succeeds we do some hairy stuff using the regex matcher
     to decide whether the match should really count. */
  if (match_words || match_lines)
    {
      static char const line_beg_no_bk[] = "^(";
      static char const line_end_no_bk[] = ")$";
      static char const word_beg_no_bk[] = "(^|[^[:alnum:]_])(";
      static char const word_end_no_bk[] = ")([^[:alnum:]_]|$)";
      static char const line_beg_bk[] = "^\\(";
      static char const line_end_bk[] = "\\)$";
      static char const word_beg_bk[] = "\\(^\\|[^[:alnum:]_]\\)\\(";
      static char const word_end_bk[] = "\\)\\([^[:alnum:]_]\\|$\\)";
      int bk = !(syntax_bits & RE_NO_BK_PARENS);
      char *n = xmalloc (sizeof word_beg_bk - 1 + size + sizeof word_end_bk);

      strcpy (n, match_lines ? (bk ? line_beg_bk : line_beg_no_bk)
			     : (bk ? word_beg_bk : word_beg_no_bk));
      total = strlen(n);
      memcpy (n + total, pattern, size);
      total += size;
      strcpy (n + total, match_lines ? (bk ? line_end_bk : line_end_no_bk)
				     : (bk ? word_end_bk : word_end_no_bk));
      total += strlen (n + total);
      pattern = motif = n;
      size = total;
    }
  else
    motif = NULL;

  dfacomp (pattern, size, &dfa, 1);
  kwsmusts ();

  free(motif);
}

size_t
EGexecute (char const *buf, size_t size, size_t *match_size,
	   char const *start_ptr)
{
  char const *buflim, *beg, *end, *match, *best_match, *mb_start;
  char eol = eolbyte;
  int backref, start, len, best_len;
  struct kwsmatch kwsm;
  size_t i, ret_val;
#ifdef MBS_SUPPORT
  if (MB_CUR_MAX > 1)
    {
      if (match_icase)
        {
          /* mbtolower adds a NUL byte at the end.  That will provide
	     space for the sentinel byte dfaexec may add.  */
          char *case_buf = mbtolower (buf, &size);
	  if (start_ptr)
	    start_ptr = case_buf + (start_ptr - buf);
          buf = case_buf;
        }
    }
#endif /* MBS_SUPPORT */

  mb_start = buf;
  buflim = buf + size;

  for (beg = end = buf; end < buflim; beg = end)
    {
      if (!start_ptr)
	{
	  /* We don't care about an exact match.  */
	  if (kwset)
	    {
	      /* Find a possible match using the KWset matcher. */
	      size_t offset = kwsexec (kwset, beg, buflim - beg, &kwsm);
	      if (offset == (size_t) -1)
		goto failure;
	      beg += offset;
	      /* Narrow down to the line containing the candidate, and
		 run it through DFA. */
	      if ((end = memchr(beg, eol, buflim - beg)) != NULL)
	        end++;
              else
                end = buflim;
	      match = beg;
	      while (beg > buf && beg[-1] != eol)
		--beg;
	      if (kwsm.index < kwset_exact_matches)
                {
#ifdef MBS_SUPPORT
                  if (mb_start < beg)
                    mb_start = beg;
                  if (MB_CUR_MAX == 1 || !is_mb_middle (&mb_start, match, buflim))
#endif
                    goto success;
                }
	      if (dfaexec (&dfa, beg, (char *) end, 0, NULL, &backref) == NULL)
		continue;
	    }
	  else
	    {
	      /* No good fixed strings; start with DFA. */
	      char const *next_beg = dfaexec (&dfa, beg, (char *) buflim,
					      0, NULL, &backref);
	      if (next_beg == NULL)
		break;
	      /* Narrow down to the line we've found. */
	      beg = next_beg;
	      if ((end = memchr(beg, eol, buflim - beg)) != NULL)
	        end++;
              else
                end = buflim;
	      while (beg > buf && beg[-1] != eol)
		--beg;
	    }
	  /* Successful, no backreferences encountered! */
	  if (!backref)
	    goto success;
	}
      else
	{
	  /* We are looking for the leftmost (then longest) exact match.
	     We will go through the outer loop only once.  */
	  beg = start_ptr;
	  end = buflim;
	}

      /* If we've made it to this point, this means DFA has seen
	 a probable match, and we need to run it through Regex. */
      best_match = end;
      best_len = 0;
      for (i = 0; i < pcount; i++)
	{
	  patterns[i].regexbuf.not_eol = 0;
	  if (0 <= (start = re_search (&(patterns[i].regexbuf),
				       buf, end - buf - 1,
				       beg - buf, end - beg - 1,
				       &(patterns[i].regs))))
	    {
	      len = patterns[i].regs.end[0] - start;
	      match = buf + start;
	      if (match > best_match)
		continue;
	      if (start_ptr && !match_words)
		goto assess_pattern_match;
	      if ((!match_lines && !match_words)
		  || (match_lines && len == end - beg - 1))
		{
		  match = beg;
		  len = end - beg;
		  goto assess_pattern_match;
		}
	      /* If -w, check if the match aligns with word boundaries.
		 We do this iteratively because:
		 (a) the line may contain more than one occurence of the
		 pattern, and
		 (b) Several alternatives in the pattern might be valid at a
		 given point, and we may need to consider a shorter one to
		 find a word boundary.  */
	      if (match_words)
		while (match <= best_match)
		  {
		    if ((match == buf || !WCHAR ((unsigned char) match[-1]))
			&& (len == end - beg - 1
			    || !WCHAR ((unsigned char) match[len])))
		      goto assess_pattern_match;
		    if (len > 0)
		      {
			/* Try a shorter length anchored at the same place. */
			--len;
			patterns[i].regexbuf.not_eol = 1;
			len = re_match (&(patterns[i].regexbuf),
					buf, match + len - beg, match - buf,
					&(patterns[i].regs));
		      }
		    if (len <= 0)
		      {
			/* Try looking further on. */
			if (match == end - 1)
			  break;
			match++;
			patterns[i].regexbuf.not_eol = 0;
			start = re_search (&(patterns[i].regexbuf),
					   buf, end - buf - 1,
					   match - buf, end - match - 1,
					   &(patterns[i].regs));
			if (start < 0)
			  break;
			len = patterns[i].regs.end[0] - start;
			match = buf + start;
		      }
		  } /* while (match <= best_match) */
	      continue;
	    assess_pattern_match:
	      if (!start_ptr)
		{
		  /* Good enough for a non-exact match.
		     No need to look at further patterns, if any.  */
		  beg = match;
		  goto success_in_len;
		}
	      if (match < best_match || (match == best_match && len > best_len))
		{
		  /* Best exact match:  leftmost, then longest.  */
		  best_match = match;
		  best_len = len;
		}
	    } /* if re_search >= 0 */
	} /* for Regex patterns.  */
	if (best_match < end)
	  {
	    /* We have found an exact match.  We were just
	       waiting for the best one (leftmost then longest).  */
	    beg = best_match;
	    len = best_len;
	    goto success_in_len;
	  }
    } /* for (beg = end ..) */

 failure:
  ret_val = -1;
  goto out;

 success:
  len = end - beg;
 success_in_len:
  *match_size = len;
  ret_val = beg - buf;
 out:
  return ret_val;
}

Testing negative cases!
Testing 0 (with abstract condition) ENVIS_NEG
Iteration 0
Running test command:
/home/ubuntu/spr-fast/tools/grep-test.py /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-8a025cf8-8f08d8e2/tempworkdir-l/src /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-8a025cf8-8f08d8e2/tempworkdir-l/tests /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-8a025cf8-8f08d8e2/tempworkdir-l 0  > __res
Opening:/tmp/neg.tmp!
NegativeBRANCH RECORD/tmp/neg.tmp!
Not caught by the negative case, give up!
APPENDING TO ISNEG:/tmp/neg.tmp!
Running test command:
/home/ubuntu/spr-fast/tools/grep-test.py /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-8a025cf8-8f08d8e2/tempworkdir-l/src /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-8a025cf8-8f08d8e2/tempworkdir-l/tests /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-8a025cf8-8f08d8e2/tempworkdir-l 0  > __res
CondTester, Testing instance id 34:
//src_file:src/dfasearch.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); void* memset(void*, int, unsigned long); 
/* dfasearch.c - searching subroutines using dfa and regex for grep.
   Copyright 1992, 1998, 2000, 2007, 2009-2010 Free Software Foundation, Inc.

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 3, or (at your option)
   any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program; if not, write to the Free Software
   Foundation, Inc., 51 Franklin Street - Fifth Floor, Boston, MA
   02110-1301, USA.  */

/* Written August 1992 by Mike Haertel. */

#include <config.h>
#include "search.h"
#include "dfa.h"

/* For -w, we also consider _ to be word constituent.  */
#define WCHAR(C) (ISALNUM(C) || (C) == '_')

/* KWset compiled pattern.  For Ecompile and Gcompile, we compile
   a list of strings, at least one of which is known to occur in
   any string matching the regexp. */
static kwset_t kwset;

/* DFA compiled regexp. */
static struct dfa dfa;

/* The Regex compiled patterns.  */
static struct patterns
{
  /* Regex compiled regexp. */
  struct re_pattern_buffer regexbuf;
  struct re_registers regs; /* This is here on account of a BRAIN-DEAD
			       Q@#%!# library interface in regex.c.  */
} patterns0;

struct patterns *patterns;
size_t pcount;

void
dfaerror (char const *mesg)
{
  error (EXIT_TROUBLE, 0, "%s", mesg);

  /* notreached */
  /* Tell static analyzers that this function does not return.  */
  abort ();
}

/* Number of compiled fixed strings known to exactly match the regexp.
   If kwsexec returns < kwset_exact_matches, then we don't need to
   call the regexp matcher at all. */
static int kwset_exact_matches;

static char const *
kwsincr_case (const char *must)
{
  const char *buf;
  size_t n;

  n = strlen (must);
#ifdef MBS_SUPPORT
  if (match_icase && MB_CUR_MAX > 1)
    buf = mbtolower (must, &n);
  else
#endif
    buf = must;
  return kwsincr (kwset, buf, n);
}

/* If the DFA turns out to have some set of fixed strings one of
   which must occur in the match, then we build a kwset matcher
   to find those strings, and thus quickly filter out impossible
   matches. */
static void
kwsmusts (void)
{
  struct dfamust const *dm;
  char const *err;

  if (dfa.musts)
    {
      kwsinit (&kwset);
      /* First, we compile in the substrings known to be exact
	 matches.  The kwset matcher will return the index
	 of the matching string that it chooses. */
      for (dm = dfa.musts; dm; dm = dm->next)
	{
	  if (!dm->exact)
	    continue;
	  ++kwset_exact_matches;
	  if ((err = kwsincr_case (dm->must)) != NULL)
	    error (EXIT_TROUBLE, 0, "%s", err);
	}
      /* Now, we compile the substrings that will require
	 the use of the regexp matcher.  */
      for (dm = dfa.musts; dm; dm = dm->next)
	{
	  
//Patch 0:
if ((dm->exact) || (__is_neg(7, &(dm), sizeof (dm), &(dm->exact), sizeof (dm->exact), &(err), sizeof (err), &(dm->must), sizeof (dm->must), &(dm->next), sizeof (dm->next), &(kwset), sizeof (kwset), &(kwset_exact_matches), sizeof (kwset_exact_matches))))
    continue;

//CodeSeg 1:
	  if ((err = kwsincr_case (dm->must)) != NULL)
	    error (EXIT_TROUBLE, 0, "%s", err);
	}
      if ((err = kwsprep (kwset)) != NULL)
	error (EXIT_TROUBLE, 0, "%s", err);
    }
}

void
GEAcompile (char const *pattern, size_t size, reg_syntax_t syntax_bits)
{
  const char *err;
  const char *p, *sep;
  size_t total = size;
  char *motif;

  if (match_icase)
    syntax_bits |= RE_ICASE;
  re_set_syntax (syntax_bits);
  dfasyntax (syntax_bits, match_icase, eolbyte);

  /* For GNU regex compiler we have to pass the patterns separately to detect
     errors like "[\nallo\n]\n".  The patterns here are "[", "allo" and "]"
     GNU regex should have raise a syntax error.  The same for backref, where
     the backref should have been local to each pattern.  */
  p = pattern;
  do
    {
      size_t len;
      sep = memchr (p, '\n', total);
      if (sep)
	{
	  len = sep - p;
	  sep++;
	  total -= (len + 1);
	}
      else
	{
	  len = total;
	  total = 0;
	}

      patterns = realloc (patterns, (pcount + 1) * sizeof (*patterns));
      if (patterns == NULL)
	error (EXIT_TROUBLE, errno, _("memory exhausted"));
      patterns[pcount] = patterns0;

      if ((err = re_compile_pattern (p, len,
				    &(patterns[pcount].regexbuf))) != NULL)
	error (EXIT_TROUBLE, 0, "%s", err);
      pcount++;

      p = sep;
    } while (sep && total != 0);

  /* In the match_words and match_lines cases, we use a different pattern
     for the DFA matcher that will quickly throw out cases that won't work.
     Then if DFA succeeds we do some hairy stuff using the regex matcher
     to decide whether the match should really count. */
  if (match_words || match_lines)
    {
      static char const line_beg_no_bk[] = "^(";
      static char const line_end_no_bk[] = ")$";
      static char const word_beg_no_bk[] = "(^|[^[:alnum:]_])(";
      static char const word_end_no_bk[] = ")([^[:alnum:]_]|$)";
      static char const line_beg_bk[] = "^\\(";
      static char const line_end_bk[] = "\\)$";
      static char const word_beg_bk[] = "\\(^\\|[^[:alnum:]_]\\)\\(";
      static char const word_end_bk[] = "\\)\\([^[:alnum:]_]\\|$\\)";
      int bk = !(syntax_bits & RE_NO_BK_PARENS);
      char *n = xmalloc (sizeof word_beg_bk - 1 + size + sizeof word_end_bk);

      strcpy (n, match_lines ? (bk ? line_beg_bk : line_beg_no_bk)
			     : (bk ? word_beg_bk : word_beg_no_bk));
      total = strlen(n);
      memcpy (n + total, pattern, size);
      total += size;
      strcpy (n + total, match_lines ? (bk ? line_end_bk : line_end_no_bk)
				     : (bk ? word_end_bk : word_end_no_bk));
      total += strlen (n + total);
      pattern = motif = n;
      size = total;
    }
  else
    motif = NULL;

  dfacomp (pattern, size, &dfa, 1);
  kwsmusts ();

  free(motif);
}

size_t
EGexecute (char const *buf, size_t size, size_t *match_size,
	   char const *start_ptr)
{
  char const *buflim, *beg, *end, *match, *best_match, *mb_start;
  char eol = eolbyte;
  int backref, start, len, best_len;
  struct kwsmatch kwsm;
  size_t i, ret_val;
#ifdef MBS_SUPPORT
  if (MB_CUR_MAX > 1)
    {
      if (match_icase)
        {
          /* mbtolower adds a NUL byte at the end.  That will provide
	     space for the sentinel byte dfaexec may add.  */
          char *case_buf = mbtolower (buf, &size);
	  if (start_ptr)
	    start_ptr = case_buf + (start_ptr - buf);
          buf = case_buf;
        }
    }
#endif /* MBS_SUPPORT */

  mb_start = buf;
  buflim = buf + size;

  for (beg = end = buf; end < buflim; beg = end)
    {
      if (!start_ptr)
	{
	  /* We don't care about an exact match.  */
	  if (kwset)
	    {
	      /* Find a possible match using the KWset matcher. */
	      size_t offset = kwsexec (kwset, beg, buflim - beg, &kwsm);
	      if (offset == (size_t) -1)
		goto failure;
	      beg += offset;
	      /* Narrow down to the line containing the candidate, and
		 run it through DFA. */
	      if ((end = memchr(beg, eol, buflim - beg)) != NULL)
	        end++;
              else
                end = buflim;
	      match = beg;
	      while (beg > buf && beg[-1] != eol)
		--beg;
	      if (kwsm.index < kwset_exact_matches)
                {
#ifdef MBS_SUPPORT
                  if (mb_start < beg)
                    mb_start = beg;
                  if (MB_CUR_MAX == 1 || !is_mb_middle (&mb_start, match, buflim))
#endif
                    goto success;
                }
	      if (dfaexec (&dfa, beg, (char *) end, 0, NULL, &backref) == NULL)
		continue;
	    }
	  else
	    {
	      /* No good fixed strings; start with DFA. */
	      char const *next_beg = dfaexec (&dfa, beg, (char *) buflim,
					      0, NULL, &backref);
	      if (next_beg == NULL)
		break;
	      /* Narrow down to the line we've found. */
	      beg = next_beg;
	      if ((end = memchr(beg, eol, buflim - beg)) != NULL)
	        end++;
              else
                end = buflim;
	      while (beg > buf && beg[-1] != eol)
		--beg;
	    }
	  /* Successful, no backreferences encountered! */
	  if (!backref)
	    goto success;
	}
      else
	{
	  /* We are looking for the leftmost (then longest) exact match.
	     We will go through the outer loop only once.  */
	  beg = start_ptr;
	  end = buflim;
	}

      /* If we've made it to this point, this means DFA has seen
	 a probable match, and we need to run it through Regex. */
      best_match = end;
      best_len = 0;
      for (i = 0; i < pcount; i++)
	{
	  patterns[i].regexbuf.not_eol = 0;
	  if (0 <= (start = re_search (&(patterns[i].regexbuf),
				       buf, end - buf - 1,
				       beg - buf, end - beg - 1,
				       &(patterns[i].regs))))
	    {
	      len = patterns[i].regs.end[0] - start;
	      match = buf + start;
	      if (match > best_match)
		continue;
	      if (start_ptr && !match_words)
		goto assess_pattern_match;
	      if ((!match_lines && !match_words)
		  || (match_lines && len == end - beg - 1))
		{
		  match = beg;
		  len = end - beg;
		  goto assess_pattern_match;
		}
	      /* If -w, check if the match aligns with word boundaries.
		 We do this iteratively because:
		 (a) the line may contain more than one occurence of the
		 pattern, and
		 (b) Several alternatives in the pattern might be valid at a
		 given point, and we may need to consider a shorter one to
		 find a word boundary.  */
	      if (match_words)
		while (match <= best_match)
		  {
		    if ((match == buf || !WCHAR ((unsigned char) match[-1]))
			&& (len == end - beg - 1
			    || !WCHAR ((unsigned char) match[len])))
		      goto assess_pattern_match;
		    if (len > 0)
		      {
			/* Try a shorter length anchored at the same place. */
			--len;
			patterns[i].regexbuf.not_eol = 1;
			len = re_match (&(patterns[i].regexbuf),
					buf, match + len - beg, match - buf,
					&(patterns[i].regs));
		      }
		    if (len <= 0)
		      {
			/* Try looking further on. */
			if (match == end - 1)
			  break;
			match++;
			patterns[i].regexbuf.not_eol = 0;
			start = re_search (&(patterns[i].regexbuf),
					   buf, end - buf - 1,
					   match - buf, end - match - 1,
					   &(patterns[i].regs));
			if (start < 0)
			  break;
			len = patterns[i].regs.end[0] - start;
			match = buf + start;
		      }
		  } /* while (match <= best_match) */
	      continue;
	    assess_pattern_match:
	      if (!start_ptr)
		{
		  /* Good enough for a non-exact match.
		     No need to look at further patterns, if any.  */
		  beg = match;
		  goto success_in_len;
		}
	      if (match < best_match || (match == best_match && len > best_len))
		{
		  /* Best exact match:  leftmost, then longest.  */
		  best_match = match;
		  best_len = len;
		}
	    } /* if re_search >= 0 */
	} /* for Regex patterns.  */
	if (best_match < end)
	  {
	    /* We have found an exact match.  We were just
	       waiting for the best one (leftmost then longest).  */
	    beg = best_match;
	    len = best_len;
	    goto success_in_len;
	  }
    } /* for (beg = end ..) */

 failure:
  ret_val = -1;
  goto out;

 success:
  len = end - beg;
 success_in_len:
  *match_size = len;
  ret_val = beg - buf;
 out:
  return ret_val;
}

Testing negative cases!
Testing 0 (with abstract condition) ENVIS_NEG
Iteration 0
Running test command:
/home/ubuntu/spr-fast/tools/grep-test.py /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-8a025cf8-8f08d8e2/tempworkdir-l/src /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-8a025cf8-8f08d8e2/tempworkdir-l/tests /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-8a025cf8-8f08d8e2/tempworkdir-l 0  > __res
Opening:/tmp/neg.tmp!
NegativeBRANCH RECORD/tmp/neg.tmp!
APPENDING TO ISNEG:/tmp/neg.tmp!
Branch 0: 0
Iteration 1
Running test command:
/home/ubuntu/spr-fast/tools/grep-test.py /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-8a025cf8-8f08d8e2/tempworkdir-l/src /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-8a025cf8-8f08d8e2/tempworkdir-l/tests /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-8a025cf8-8f08d8e2/tempworkdir-l 0  > __res
Opening:/tmp/neg.tmp!
NegativeBRANCH RECORD/tmp/neg.tmp!
APPENDING TO ISNEG:/tmp/neg.tmp!
Branch 0: 1
Running test command:
/home/ubuntu/spr-fast/tools/grep-test.py /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-8a025cf8-8f08d8e2/tempworkdir-l/src /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-8a025cf8-8f08d8e2/tempworkdir-l/tests /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-8a025cf8-8f08d8e2/tempworkdir-l 0  > __res
a batched test job starts!
Building merged code:
src_file: src/dfasearch.c
full src: int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); void* memset(void*, int, unsigned long); 
/* dfasearch.c - searching subroutines using dfa and regex for grep.
   Copyright 1992, 1998, 2000, 2007, 2009-2010 Free Software Foundation, Inc.

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 3, or (at your option)
   any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program; if not, write to the Free Software
   Foundation, Inc., 51 Franklin Street - Fifth Floor, Boston, MA
   02110-1301, USA.  */

/* Written August 1992 by Mike Haertel. */

#include <config.h>
#include "search.h"
#include "dfa.h"

/* For -w, we also consider _ to be word constituent.  */
#define WCHAR(C) (ISALNUM(C) || (C) == '_')

/* KWset compiled pattern.  For Ecompile and Gcompile, we compile
   a list of strings, at least one of which is known to occur in
   any string matching the regexp. */
static kwset_t kwset;

/* DFA compiled regexp. */
static struct dfa dfa;

/* The Regex compiled patterns.  */
static struct patterns
{
  /* Regex compiled regexp. */
  struct re_pattern_buffer regexbuf;
  struct re_registers regs; /* This is here on account of a BRAIN-DEAD
			       Q@#%!# library interface in regex.c.  */
} patterns0;

struct patterns *patterns;
size_t pcount;

void
dfaerror (char const *mesg)
{
  error (EXIT_TROUBLE, 0, "%s", mesg);

  /* notreached */
  /* Tell static analyzers that this function does not return.  */
  abort ();
}

/* Number of compiled fixed strings known to exactly match the regexp.
   If kwsexec returns < kwset_exact_matches, then we don't need to
   call the regexp matcher at all. */
static int kwset_exact_matches;

static char const *
kwsincr_case (const char *must)
{
  const char *buf;
  size_t n;

  n = strlen (must);
#ifdef MBS_SUPPORT
  if (match_icase && MB_CUR_MAX > 1)
    buf = mbtolower (must, &n);
  else
#endif
    buf = must;
  return kwsincr (kwset, buf, n);
}

/* If the DFA turns out to have some set of fixed strings one of
   which must occur in the match, then we build a kwset matcher
   to find those strings, and thus quickly filter out impossible
   matches. */
static void
kwsmusts (void)
{
  struct dfamust const *dm;
  char const *err;

  if (dfa.musts)
    {
      kwsinit (&kwset);
      /* First, we compile in the substrings known to be exact
	 matches.  The kwset matcher will return the index
	 of the matching string that it chooses. */
      for (dm = dfa.musts; dm; dm = dm->next)
	{
	  if (!dm->exact)
	    continue;
	  ++kwset_exact_matches;
	  if ((err = kwsincr_case (dm->must)) != NULL)
	    error (EXIT_TROUBLE, 0, "%s", err);
	}
      /* Now, we compile the substrings that will require
	 the use of the regexp matcher.  */
      for (dm = dfa.musts; dm; dm = dm->next)
	{
	  if (dm->exact)
	    continue;
	  //prophet generated patch
	  if (__get_mutant()==0) {
	  if (((err = kwsincr_case(dm->must)) != ((void *)0)) && !(__is_neg(7, &(dm), sizeof (dm), &(err), sizeof (err), &(dm->must), sizeof (dm->must), &(dm->exact), sizeof (dm->exact), &(kwset), sizeof (kwset), &(dm->next), sizeof (dm->next), &(kwset_exact_matches), sizeof (kwset_exact_matches))))
	      error(EXIT_TROUBLE, 0, "%s", err);
	  }
	  else if (__get_mutant()==1) {
	  if (((err = kwsincr_case(dm->must)) != ((void *)0)) || (__is_neg(7, &(dm), sizeof (dm), &(err), sizeof (err), &(dm->must), sizeof (dm->must), &(dm->exact), sizeof (dm->exact), &(kwset), sizeof (kwset), &(dm->next), sizeof (dm->next), &(kwset_exact_matches), sizeof (kwset_exact_matches))))
	      error(EXIT_TROUBLE, 0, "%s", err);
	  }
	}
      if ((err = kwsprep (kwset)) != NULL)
	error (EXIT_TROUBLE, 0, "%s", err);
    }
}

void
GEAcompile (char const *pattern, size_t size, reg_syntax_t syntax_bits)
{
  const char *err;
  const char *p, *sep;
  size_t total = size;
  char *motif;

  if (match_icase)
    syntax_bits |= RE_ICASE;
  re_set_syntax (syntax_bits);
  dfasyntax (syntax_bits, match_icase, eolbyte);

  /* For GNU regex compiler we have to pass the patterns separately to detect
     errors like "[\nallo\n]\n".  The patterns here are "[", "allo" and "]"
     GNU regex should have raise a syntax error.  The same for backref, where
     the backref should have been local to each pattern.  */
  p = pattern;
  do
    {
      size_t len;
      sep = memchr (p, '\n', total);
      if (sep)
	{
	  len = sep - p;
	  sep++;
	  total -= (len + 1);
	}
      else
	{
	  len = total;
	  total = 0;
	}

      patterns = realloc (patterns, (pcount + 1) * sizeof (*patterns));
      if (patterns == NULL)
	error (EXIT_TROUBLE, errno, _("memory exhausted"));
      patterns[pcount] = patterns0;

      if ((err = re_compile_pattern (p, len,
				    &(patterns[pcount].regexbuf))) != NULL)
	error (EXIT_TROUBLE, 0, "%s", err);
      pcount++;

      p = sep;
    } while (sep && total != 0);

  /* In the match_words and match_lines cases, we use a different pattern
     for the DFA matcher that will quickly throw out cases that won't work.
     Then if DFA succeeds we do some hairy stuff using the regex matcher
     to decide whether the match should really count. */
  if (match_words || match_lines)
    {
      static char const line_beg_no_bk[] = "^(";
      static char const line_end_no_bk[] = ")$";
      static char const word_beg_no_bk[] = "(^|[^[:alnum:]_])(";
      static char const word_end_no_bk[] = ")([^[:alnum:]_]|$)";
      static char const line_beg_bk[] = "^\\(";
      static char const line_end_bk[] = "\\)$";
      static char const word_beg_bk[] = "\\(^\\|[^[:alnum:]_]\\)\\(";
      static char const word_end_bk[] = "\\)\\([^[:alnum:]_]\\|$\\)";
      int bk = !(syntax_bits & RE_NO_BK_PARENS);
      char *n = xmalloc (sizeof word_beg_bk - 1 + size + sizeof word_end_bk);

      strcpy (n, match_lines ? (bk ? line_beg_bk : line_beg_no_bk)
			     : (bk ? word_beg_bk : word_beg_no_bk));
      total = strlen(n);
      memcpy (n + total, pattern, size);
      total += size;
      strcpy (n + total, match_lines ? (bk ? line_end_bk : line_end_no_bk)
				     : (bk ? word_end_bk : word_end_no_bk));
      total += strlen (n + total);
      pattern = motif = n;
      size = total;
    }
  else
    motif = NULL;

  dfacomp (pattern, size, &dfa, 1);
  kwsmusts ();

  free(motif);
}

size_t
EGexecute (char const *buf, size_t size, size_t *match_size,
	   char const *start_ptr)
{
  char const *buflim, *beg, *end, *match, *best_match, *mb_start;
  char eol = eolbyte;
  int backref, start, len, best_len;
  struct kwsmatch kwsm;
  size_t i, ret_val;
#ifdef MBS_SUPPORT
  if (MB_CUR_MAX > 1)
    {
      if (match_icase)
        {
          /* mbtolower adds a NUL byte at the end.  That will provide
	     space for the sentinel byte dfaexec may add.  */
          char *case_buf = mbtolower (buf, &size);
	  if (start_ptr)
	    start_ptr = case_buf + (start_ptr - buf);
          buf = case_buf;
        }
    }
#endif /* MBS_SUPPORT */

  mb_start = buf;
  buflim = buf + size;

  for (beg = end = buf; end < buflim; beg = end)
    {
      if (!start_ptr)
	{
	  /* We don't care about an exact match.  */
	  if (kwset)
	    {
	      /* Find a possible match using the KWset matcher. */
	      size_t offset = kwsexec (kwset, beg, buflim - beg, &kwsm);
	      if (offset == (size_t) -1)
		goto failure;
	      beg += offset;
	      /* Narrow down to the line containing the candidate, and
		 run it through DFA. */
	      if ((end = memchr(beg, eol, buflim - beg)) != NULL)
	        end++;
              else
                end = buflim;
	      match = beg;
	      while (beg > buf && beg[-1] != eol)
		--beg;
	      if (kwsm.index < kwset_exact_matches)
                {
#ifdef MBS_SUPPORT
                  if (mb_start < beg)
                    mb_start = beg;
                  if (MB_CUR_MAX == 1 || !is_mb_middle (&mb_start, match, buflim))
#endif
                    goto success;
                }
	      if (dfaexec (&dfa, beg, (char *) end, 0, NULL, &backref) == NULL)
		continue;
	    }
	  else
	    {
	      /* No good fixed strings; start with DFA. */
	      char const *next_beg = dfaexec (&dfa, beg, (char *) buflim,
					      0, NULL, &backref);
	      if (next_beg == NULL)
		break;
	      /* Narrow down to the line we've found. */
	      beg = next_beg;
	      if ((end = memchr(beg, eol, buflim - beg)) != NULL)
	        end++;
              else
                end = buflim;
	      while (beg > buf && beg[-1] != eol)
		--beg;
	    }
	  /* Successful, no backreferences encountered! */
	  if (!backref)
	    goto success;
	}
      else
	{
	  /* We are looking for the leftmost (then longest) exact match.
	     We will go through the outer loop only once.  */
	  beg = start_ptr;
	  end = buflim;
	}

      /* If we've made it to this point, this means DFA has seen
	 a probable match, and we need to run it through Regex. */
      best_match = end;
      best_len = 0;
      for (i = 0; i < pcount; i++)
	{
	  patterns[i].regexbuf.not_eol = 0;
	  if (0 <= (start = re_search (&(patterns[i].regexbuf),
				       buf, end - buf - 1,
				       beg - buf, end - beg - 1,
				       &(patterns[i].regs))))
	    {
	      len = patterns[i].regs.end[0] - start;
	      match = buf + start;
	      if (match > best_match)
		continue;
	      if (start_ptr && !match_words)
		goto assess_pattern_match;
	      if ((!match_lines && !match_words)
		  || (match_lines && len == end - beg - 1))
		{
		  match = beg;
		  len = end - beg;
		  goto assess_pattern_match;
		}
	      /* If -w, check if the match aligns with word boundaries.
		 We do this iteratively because:
		 (a) the line may contain more than one occurence of the
		 pattern, and
		 (b) Several alternatives in the pattern might be valid at a
		 given point, and we may need to consider a shorter one to
		 find a word boundary.  */
	      if (match_words)
		while (match <= best_match)
		  {
		    if ((match == buf || !WCHAR ((unsigned char) match[-1]))
			&& (len == end - beg - 1
			    || !WCHAR ((unsigned char) match[len])))
		      goto assess_pattern_match;
		    if (len > 0)
		      {
			/* Try a shorter length anchored at the same place. */
			--len;
			patterns[i].regexbuf.not_eol = 1;
			len = re_match (&(patterns[i].regexbuf),
					buf, match + len - beg, match - buf,
					&(patterns[i].regs));
		      }
		    if (len <= 0)
		      {
			/* Try looking further on. */
			if (match == end - 1)
			  break;
			match++;
			patterns[i].regexbuf.not_eol = 0;
			start = re_search (&(patterns[i].regexbuf),
					   buf, end - buf - 1,
					   match - buf, end - match - 1,
					   &(patterns[i].regs));
			if (start < 0)
			  break;
			len = patterns[i].regs.end[0] - start;
			match = buf + start;
		      }
		  } /* while (match <= best_match) */
	      continue;
	    assess_pattern_match:
	      if (!start_ptr)
		{
		  /* Good enough for a non-exact match.
		     No need to look at further patterns, if any.  */
		  beg = match;
		  goto success_in_len;
		}
	      if (match < best_match || (match == best_match && len > best_len))
		{
		  /* Best exact match:  leftmost, then longest.  */
		  best_match = match;
		  best_len = len;
		}
	    } /* if re_search >= 0 */
	} /* for Regex patterns.  */
	if (best_match < end)
	  {
	    /* We have found an exact match.  We were just
	       waiting for the best one (leftmost then longest).  */
	    beg = best_match;
	    len = best_len;
	    goto success_in_len;
	  }
    } /* for (beg = end ..) */

 failure:
  ret_val = -1;
  goto out;

 success:
  len = end - beg;
 success_in_len:
  *match_size = len;
  ret_val = beg - buf;
 out:
  return ret_val;
}

Building:src at:
/home/ubuntu/spr-fast/tests/corebench/grep/grep-case-8a025cf8-8f08d8e2/tempworkdir-l/srcMerged code building succ, going to invoke tester!
CondTester, Testing instance id 30:
//src_file:src/dfasearch.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); void* memset(void*, int, unsigned long); 
/* dfasearch.c - searching subroutines using dfa and regex for grep.
   Copyright 1992, 1998, 2000, 2007, 2009-2010 Free Software Foundation, Inc.

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 3, or (at your option)
   any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program; if not, write to the Free Software
   Foundation, Inc., 51 Franklin Street - Fifth Floor, Boston, MA
   02110-1301, USA.  */

/* Written August 1992 by Mike Haertel. */

#include <config.h>
#include "search.h"
#include "dfa.h"

/* For -w, we also consider _ to be word constituent.  */
#define WCHAR(C) (ISALNUM(C) || (C) == '_')

/* KWset compiled pattern.  For Ecompile and Gcompile, we compile
   a list of strings, at least one of which is known to occur in
   any string matching the regexp. */
static kwset_t kwset;

/* DFA compiled regexp. */
static struct dfa dfa;

/* The Regex compiled patterns.  */
static struct patterns
{
  /* Regex compiled regexp. */
  struct re_pattern_buffer regexbuf;
  struct re_registers regs; /* This is here on account of a BRAIN-DEAD
			       Q@#%!# library interface in regex.c.  */
} patterns0;

struct patterns *patterns;
size_t pcount;

void
dfaerror (char const *mesg)
{
  error (EXIT_TROUBLE, 0, "%s", mesg);

  /* notreached */
  /* Tell static analyzers that this function does not return.  */
  abort ();
}

/* Number of compiled fixed strings known to exactly match the regexp.
   If kwsexec returns < kwset_exact_matches, then we don't need to
   call the regexp matcher at all. */
static int kwset_exact_matches;

static char const *
kwsincr_case (const char *must)
{
  const char *buf;
  size_t n;

  n = strlen (must);
#ifdef MBS_SUPPORT
  if (match_icase && MB_CUR_MAX > 1)
    buf = mbtolower (must, &n);
  else
#endif
    buf = must;
  return kwsincr (kwset, buf, n);
}

/* If the DFA turns out to have some set of fixed strings one of
   which must occur in the match, then we build a kwset matcher
   to find those strings, and thus quickly filter out impossible
   matches. */
static void
kwsmusts (void)
{
  struct dfamust const *dm;
  char const *err;

  if (dfa.musts)
    {
      kwsinit (&kwset);
      /* First, we compile in the substrings known to be exact
	 matches.  The kwset matcher will return the index
	 of the matching string that it chooses. */
      for (dm = dfa.musts; dm; dm = dm->next)
	{
	  if (!dm->exact)
	    continue;
	  ++kwset_exact_matches;
	  if ((err = kwsincr_case (dm->must)) != NULL)
	    error (EXIT_TROUBLE, 0, "%s", err);
	}
      /* Now, we compile the substrings that will require
	 the use of the regexp matcher.  */
      for (dm = dfa.musts; dm; dm = dm->next)
	{
	  if (dm->exact)
	    continue;
	  
//Patch 0:
if (((err = kwsincr_case(dm->must)) != ((void *)0)) && !(__is_neg(7, &(dm), sizeof (dm), &(err), sizeof (err), &(dm->must), sizeof (dm->must), &(dm->exact), sizeof (dm->exact), &(kwset), sizeof (kwset), &(dm->next), sizeof (dm->next), &(kwset_exact_matches), sizeof (kwset_exact_matches))))
    error(EXIT_TROUBLE, 0, "%s", err);

//CodeSeg 1:
	}
      if ((err = kwsprep (kwset)) != NULL)
	error (EXIT_TROUBLE, 0, "%s", err);
    }
}

void
GEAcompile (char const *pattern, size_t size, reg_syntax_t syntax_bits)
{
  const char *err;
  const char *p, *sep;
  size_t total = size;
  char *motif;

  if (match_icase)
    syntax_bits |= RE_ICASE;
  re_set_syntax (syntax_bits);
  dfasyntax (syntax_bits, match_icase, eolbyte);

  /* For GNU regex compiler we have to pass the patterns separately to detect
     errors like "[\nallo\n]\n".  The patterns here are "[", "allo" and "]"
     GNU regex should have raise a syntax error.  The same for backref, where
     the backref should have been local to each pattern.  */
  p = pattern;
  do
    {
      size_t len;
      sep = memchr (p, '\n', total);
      if (sep)
	{
	  len = sep - p;
	  sep++;
	  total -= (len + 1);
	}
      else
	{
	  len = total;
	  total = 0;
	}

      patterns = realloc (patterns, (pcount + 1) * sizeof (*patterns));
      if (patterns == NULL)
	error (EXIT_TROUBLE, errno, _("memory exhausted"));
      patterns[pcount] = patterns0;

      if ((err = re_compile_pattern (p, len,
				    &(patterns[pcount].regexbuf))) != NULL)
	error (EXIT_TROUBLE, 0, "%s", err);
      pcount++;

      p = sep;
    } while (sep && total != 0);

  /* In the match_words and match_lines cases, we use a different pattern
     for the DFA matcher that will quickly throw out cases that won't work.
     Then if DFA succeeds we do some hairy stuff using the regex matcher
     to decide whether the match should really count. */
  if (match_words || match_lines)
    {
      static char const line_beg_no_bk[] = "^(";
      static char const line_end_no_bk[] = ")$";
      static char const word_beg_no_bk[] = "(^|[^[:alnum:]_])(";
      static char const word_end_no_bk[] = ")([^[:alnum:]_]|$)";
      static char const line_beg_bk[] = "^\\(";
      static char const line_end_bk[] = "\\)$";
      static char const word_beg_bk[] = "\\(^\\|[^[:alnum:]_]\\)\\(";
      static char const word_end_bk[] = "\\)\\([^[:alnum:]_]\\|$\\)";
      int bk = !(syntax_bits & RE_NO_BK_PARENS);
      char *n = xmalloc (sizeof word_beg_bk - 1 + size + sizeof word_end_bk);

      strcpy (n, match_lines ? (bk ? line_beg_bk : line_beg_no_bk)
			     : (bk ? word_beg_bk : word_beg_no_bk));
      total = strlen(n);
      memcpy (n + total, pattern, size);
      total += size;
      strcpy (n + total, match_lines ? (bk ? line_end_bk : line_end_no_bk)
				     : (bk ? word_end_bk : word_end_no_bk));
      total += strlen (n + total);
      pattern = motif = n;
      size = total;
    }
  else
    motif = NULL;

  dfacomp (pattern, size, &dfa, 1);
  kwsmusts ();

  free(motif);
}

size_t
EGexecute (char const *buf, size_t size, size_t *match_size,
	   char const *start_ptr)
{
  char const *buflim, *beg, *end, *match, *best_match, *mb_start;
  char eol = eolbyte;
  int backref, start, len, best_len;
  struct kwsmatch kwsm;
  size_t i, ret_val;
#ifdef MBS_SUPPORT
  if (MB_CUR_MAX > 1)
    {
      if (match_icase)
        {
          /* mbtolower adds a NUL byte at the end.  That will provide
	     space for the sentinel byte dfaexec may add.  */
          char *case_buf = mbtolower (buf, &size);
	  if (start_ptr)
	    start_ptr = case_buf + (start_ptr - buf);
          buf = case_buf;
        }
    }
#endif /* MBS_SUPPORT */

  mb_start = buf;
  buflim = buf + size;

  for (beg = end = buf; end < buflim; beg = end)
    {
      if (!start_ptr)
	{
	  /* We don't care about an exact match.  */
	  if (kwset)
	    {
	      /* Find a possible match using the KWset matcher. */
	      size_t offset = kwsexec (kwset, beg, buflim - beg, &kwsm);
	      if (offset == (size_t) -1)
		goto failure;
	      beg += offset;
	      /* Narrow down to the line containing the candidate, and
		 run it through DFA. */
	      if ((end = memchr(beg, eol, buflim - beg)) != NULL)
	        end++;
              else
                end = buflim;
	      match = beg;
	      while (beg > buf && beg[-1] != eol)
		--beg;
	      if (kwsm.index < kwset_exact_matches)
                {
#ifdef MBS_SUPPORT
                  if (mb_start < beg)
                    mb_start = beg;
                  if (MB_CUR_MAX == 1 || !is_mb_middle (&mb_start, match, buflim))
#endif
                    goto success;
                }
	      if (dfaexec (&dfa, beg, (char *) end, 0, NULL, &backref) == NULL)
		continue;
	    }
	  else
	    {
	      /* No good fixed strings; start with DFA. */
	      char const *next_beg = dfaexec (&dfa, beg, (char *) buflim,
					      0, NULL, &backref);
	      if (next_beg == NULL)
		break;
	      /* Narrow down to the line we've found. */
	      beg = next_beg;
	      if ((end = memchr(beg, eol, buflim - beg)) != NULL)
	        end++;
              else
                end = buflim;
	      while (beg > buf && beg[-1] != eol)
		--beg;
	    }
	  /* Successful, no backreferences encountered! */
	  if (!backref)
	    goto success;
	}
      else
	{
	  /* We are looking for the leftmost (then longest) exact match.
	     We will go through the outer loop only once.  */
	  beg = start_ptr;
	  end = buflim;
	}

      /* If we've made it to this point, this means DFA has seen
	 a probable match, and we need to run it through Regex. */
      best_match = end;
      best_len = 0;
      for (i = 0; i < pcount; i++)
	{
	  patterns[i].regexbuf.not_eol = 0;
	  if (0 <= (start = re_search (&(patterns[i].regexbuf),
				       buf, end - buf - 1,
				       beg - buf, end - beg - 1,
				       &(patterns[i].regs))))
	    {
	      len = patterns[i].regs.end[0] - start;
	      match = buf + start;
	      if (match > best_match)
		continue;
	      if (start_ptr && !match_words)
		goto assess_pattern_match;
	      if ((!match_lines && !match_words)
		  || (match_lines && len == end - beg - 1))
		{
		  match = beg;
		  len = end - beg;
		  goto assess_pattern_match;
		}
	      /* If -w, check if the match aligns with word boundaries.
		 We do this iteratively because:
		 (a) the line may contain more than one occurence of the
		 pattern, and
		 (b) Several alternatives in the pattern might be valid at a
		 given point, and we may need to consider a shorter one to
		 find a word boundary.  */
	      if (match_words)
		while (match <= best_match)
		  {
		    if ((match == buf || !WCHAR ((unsigned char) match[-1]))
			&& (len == end - beg - 1
			    || !WCHAR ((unsigned char) match[len])))
		      goto assess_pattern_match;
		    if (len > 0)
		      {
			/* Try a shorter length anchored at the same place. */
			--len;
			patterns[i].regexbuf.not_eol = 1;
			len = re_match (&(patterns[i].regexbuf),
					buf, match + len - beg, match - buf,
					&(patterns[i].regs));
		      }
		    if (len <= 0)
		      {
			/* Try looking further on. */
			if (match == end - 1)
			  break;
			match++;
			patterns[i].regexbuf.not_eol = 0;
			start = re_search (&(patterns[i].regexbuf),
					   buf, end - buf - 1,
					   match - buf, end - match - 1,
					   &(patterns[i].regs));
			if (start < 0)
			  break;
			len = patterns[i].regs.end[0] - start;
			match = buf + start;
		      }
		  } /* while (match <= best_match) */
	      continue;
	    assess_pattern_match:
	      if (!start_ptr)
		{
		  /* Good enough for a non-exact match.
		     No need to look at further patterns, if any.  */
		  beg = match;
		  goto success_in_len;
		}
	      if (match < best_match || (match == best_match && len > best_len))
		{
		  /* Best exact match:  leftmost, then longest.  */
		  best_match = match;
		  best_len = len;
		}
	    } /* if re_search >= 0 */
	} /* for Regex patterns.  */
	if (best_match < end)
	  {
	    /* We have found an exact match.  We were just
	       waiting for the best one (leftmost then longest).  */
	    beg = best_match;
	    len = best_len;
	    goto success_in_len;
	  }
    } /* for (beg = end ..) */

 failure:
  ret_val = -1;
  goto out;

 success:
  len = end - beg;
 success_in_len:
  *match_size = len;
  ret_val = beg - buf;
 out:
  return ret_val;
}

Testing negative cases!
Testing 0 (with abstract condition) ENVIS_NEG
Iteration 0
Running test command:
/home/ubuntu/spr-fast/tools/grep-test.py /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-8a025cf8-8f08d8e2/tempworkdir-l/src /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-8a025cf8-8f08d8e2/tempworkdir-l/tests /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-8a025cf8-8f08d8e2/tempworkdir-l 0  > __res
Opening:/tmp/neg.tmp!
NegativeBRANCH RECORD/tmp/neg.tmp!
Not caught by the negative case, give up!
APPENDING TO ISNEG:/tmp/neg.tmp!
Running test command:
/home/ubuntu/spr-fast/tools/grep-test.py /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-8a025cf8-8f08d8e2/tempworkdir-l/src /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-8a025cf8-8f08d8e2/tempworkdir-l/tests /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-8a025cf8-8f08d8e2/tempworkdir-l 0  > __res
CondTester, Testing instance id 31:
//src_file:src/dfasearch.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); void* memset(void*, int, unsigned long); 
/* dfasearch.c - searching subroutines using dfa and regex for grep.
   Copyright 1992, 1998, 2000, 2007, 2009-2010 Free Software Foundation, Inc.

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 3, or (at your option)
   any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program; if not, write to the Free Software
   Foundation, Inc., 51 Franklin Street - Fifth Floor, Boston, MA
   02110-1301, USA.  */

/* Written August 1992 by Mike Haertel. */

#include <config.h>
#include "search.h"
#include "dfa.h"

/* For -w, we also consider _ to be word constituent.  */
#define WCHAR(C) (ISALNUM(C) || (C) == '_')

/* KWset compiled pattern.  For Ecompile and Gcompile, we compile
   a list of strings, at least one of which is known to occur in
   any string matching the regexp. */
static kwset_t kwset;

/* DFA compiled regexp. */
static struct dfa dfa;

/* The Regex compiled patterns.  */
static struct patterns
{
  /* Regex compiled regexp. */
  struct re_pattern_buffer regexbuf;
  struct re_registers regs; /* This is here on account of a BRAIN-DEAD
			       Q@#%!# library interface in regex.c.  */
} patterns0;

struct patterns *patterns;
size_t pcount;

void
dfaerror (char const *mesg)
{
  error (EXIT_TROUBLE, 0, "%s", mesg);

  /* notreached */
  /* Tell static analyzers that this function does not return.  */
  abort ();
}

/* Number of compiled fixed strings known to exactly match the regexp.
   If kwsexec returns < kwset_exact_matches, then we don't need to
   call the regexp matcher at all. */
static int kwset_exact_matches;

static char const *
kwsincr_case (const char *must)
{
  const char *buf;
  size_t n;

  n = strlen (must);
#ifdef MBS_SUPPORT
  if (match_icase && MB_CUR_MAX > 1)
    buf = mbtolower (must, &n);
  else
#endif
    buf = must;
  return kwsincr (kwset, buf, n);
}

/* If the DFA turns out to have some set of fixed strings one of
   which must occur in the match, then we build a kwset matcher
   to find those strings, and thus quickly filter out impossible
   matches. */
static void
kwsmusts (void)
{
  struct dfamust const *dm;
  char const *err;

  if (dfa.musts)
    {
      kwsinit (&kwset);
      /* First, we compile in the substrings known to be exact
	 matches.  The kwset matcher will return the index
	 of the matching string that it chooses. */
      for (dm = dfa.musts; dm; dm = dm->next)
	{
	  if (!dm->exact)
	    continue;
	  ++kwset_exact_matches;
	  if ((err = kwsincr_case (dm->must)) != NULL)
	    error (EXIT_TROUBLE, 0, "%s", err);
	}
      /* Now, we compile the substrings that will require
	 the use of the regexp matcher.  */
      for (dm = dfa.musts; dm; dm = dm->next)
	{
	  if (dm->exact)
	    continue;
	  
//Patch 0:
if (((err = kwsincr_case(dm->must)) != ((void *)0)) || (__is_neg(7, &(dm), sizeof (dm), &(err), sizeof (err), &(dm->must), sizeof (dm->must), &(dm->exact), sizeof (dm->exact), &(kwset), sizeof (kwset), &(dm->next), sizeof (dm->next), &(kwset_exact_matches), sizeof (kwset_exact_matches))))
    error(EXIT_TROUBLE, 0, "%s", err);

//CodeSeg 1:
	}
      if ((err = kwsprep (kwset)) != NULL)
	error (EXIT_TROUBLE, 0, "%s", err);
    }
}

void
GEAcompile (char const *pattern, size_t size, reg_syntax_t syntax_bits)
{
  const char *err;
  const char *p, *sep;
  size_t total = size;
  char *motif;

  if (match_icase)
    syntax_bits |= RE_ICASE;
  re_set_syntax (syntax_bits);
  dfasyntax (syntax_bits, match_icase, eolbyte);

  /* For GNU regex compiler we have to pass the patterns separately to detect
     errors like "[\nallo\n]\n".  The patterns here are "[", "allo" and "]"
     GNU regex should have raise a syntax error.  The same for backref, where
     the backref should have been local to each pattern.  */
  p = pattern;
  do
    {
      size_t len;
      sep = memchr (p, '\n', total);
      if (sep)
	{
	  len = sep - p;
	  sep++;
	  total -= (len + 1);
	}
      else
	{
	  len = total;
	  total = 0;
	}

      patterns = realloc (patterns, (pcount + 1) * sizeof (*patterns));
      if (patterns == NULL)
	error (EXIT_TROUBLE, errno, _("memory exhausted"));
      patterns[pcount] = patterns0;

      if ((err = re_compile_pattern (p, len,
				    &(patterns[pcount].regexbuf))) != NULL)
	error (EXIT_TROUBLE, 0, "%s", err);
      pcount++;

      p = sep;
    } while (sep && total != 0);

  /* In the match_words and match_lines cases, we use a different pattern
     for the DFA matcher that will quickly throw out cases that won't work.
     Then if DFA succeeds we do some hairy stuff using the regex matcher
     to decide whether the match should really count. */
  if (match_words || match_lines)
    {
      static char const line_beg_no_bk[] = "^(";
      static char const line_end_no_bk[] = ")$";
      static char const word_beg_no_bk[] = "(^|[^[:alnum:]_])(";
      static char const word_end_no_bk[] = ")([^[:alnum:]_]|$)";
      static char const line_beg_bk[] = "^\\(";
      static char const line_end_bk[] = "\\)$";
      static char const word_beg_bk[] = "\\(^\\|[^[:alnum:]_]\\)\\(";
      static char const word_end_bk[] = "\\)\\([^[:alnum:]_]\\|$\\)";
      int bk = !(syntax_bits & RE_NO_BK_PARENS);
      char *n = xmalloc (sizeof word_beg_bk - 1 + size + sizeof word_end_bk);

      strcpy (n, match_lines ? (bk ? line_beg_bk : line_beg_no_bk)
			     : (bk ? word_beg_bk : word_beg_no_bk));
      total = strlen(n);
      memcpy (n + total, pattern, size);
      total += size;
      strcpy (n + total, match_lines ? (bk ? line_end_bk : line_end_no_bk)
				     : (bk ? word_end_bk : word_end_no_bk));
      total += strlen (n + total);
      pattern = motif = n;
      size = total;
    }
  else
    motif = NULL;

  dfacomp (pattern, size, &dfa, 1);
  kwsmusts ();

  free(motif);
}

size_t
EGexecute (char const *buf, size_t size, size_t *match_size,
	   char const *start_ptr)
{
  char const *buflim, *beg, *end, *match, *best_match, *mb_start;
  char eol = eolbyte;
  int backref, start, len, best_len;
  struct kwsmatch kwsm;
  size_t i, ret_val;
#ifdef MBS_SUPPORT
  if (MB_CUR_MAX > 1)
    {
      if (match_icase)
        {
          /* mbtolower adds a NUL byte at the end.  That will provide
	     space for the sentinel byte dfaexec may add.  */
          char *case_buf = mbtolower (buf, &size);
	  if (start_ptr)
	    start_ptr = case_buf + (start_ptr - buf);
          buf = case_buf;
        }
    }
#endif /* MBS_SUPPORT */

  mb_start = buf;
  buflim = buf + size;

  for (beg = end = buf; end < buflim; beg = end)
    {
      if (!start_ptr)
	{
	  /* We don't care about an exact match.  */
	  if (kwset)
	    {
	      /* Find a possible match using the KWset matcher. */
	      size_t offset = kwsexec (kwset, beg, buflim - beg, &kwsm);
	      if (offset == (size_t) -1)
		goto failure;
	      beg += offset;
	      /* Narrow down to the line containing the candidate, and
		 run it through DFA. */
	      if ((end = memchr(beg, eol, buflim - beg)) != NULL)
	        end++;
              else
                end = buflim;
	      match = beg;
	      while (beg > buf && beg[-1] != eol)
		--beg;
	      if (kwsm.index < kwset_exact_matches)
                {
#ifdef MBS_SUPPORT
                  if (mb_start < beg)
                    mb_start = beg;
                  if (MB_CUR_MAX == 1 || !is_mb_middle (&mb_start, match, buflim))
#endif
                    goto success;
                }
	      if (dfaexec (&dfa, beg, (char *) end, 0, NULL, &backref) == NULL)
		continue;
	    }
	  else
	    {
	      /* No good fixed strings; start with DFA. */
	      char const *next_beg = dfaexec (&dfa, beg, (char *) buflim,
					      0, NULL, &backref);
	      if (next_beg == NULL)
		break;
	      /* Narrow down to the line we've found. */
	      beg = next_beg;
	      if ((end = memchr(beg, eol, buflim - beg)) != NULL)
	        end++;
              else
                end = buflim;
	      while (beg > buf && beg[-1] != eol)
		--beg;
	    }
	  /* Successful, no backreferences encountered! */
	  if (!backref)
	    goto success;
	}
      else
	{
	  /* We are looking for the leftmost (then longest) exact match.
	     We will go through the outer loop only once.  */
	  beg = start_ptr;
	  end = buflim;
	}

      /* If we've made it to this point, this means DFA has seen
	 a probable match, and we need to run it through Regex. */
      best_match = end;
      best_len = 0;
      for (i = 0; i < pcount; i++)
	{
	  patterns[i].regexbuf.not_eol = 0;
	  if (0 <= (start = re_search (&(patterns[i].regexbuf),
				       buf, end - buf - 1,
				       beg - buf, end - beg - 1,
				       &(patterns[i].regs))))
	    {
	      len = patterns[i].regs.end[0] - start;
	      match = buf + start;
	      if (match > best_match)
		continue;
	      if (start_ptr && !match_words)
		goto assess_pattern_match;
	      if ((!match_lines && !match_words)
		  || (match_lines && len == end - beg - 1))
		{
		  match = beg;
		  len = end - beg;
		  goto assess_pattern_match;
		}
	      /* If -w, check if the match aligns with word boundaries.
		 We do this iteratively because:
		 (a) the line may contain more than one occurence of the
		 pattern, and
		 (b) Several alternatives in the pattern might be valid at a
		 given point, and we may need to consider a shorter one to
		 find a word boundary.  */
	      if (match_words)
		while (match <= best_match)
		  {
		    if ((match == buf || !WCHAR ((unsigned char) match[-1]))
			&& (len == end - beg - 1
			    || !WCHAR ((unsigned char) match[len])))
		      goto assess_pattern_match;
		    if (len > 0)
		      {
			/* Try a shorter length anchored at the same place. */
			--len;
			patterns[i].regexbuf.not_eol = 1;
			len = re_match (&(patterns[i].regexbuf),
					buf, match + len - beg, match - buf,
					&(patterns[i].regs));
		      }
		    if (len <= 0)
		      {
			/* Try looking further on. */
			if (match == end - 1)
			  break;
			match++;
			patterns[i].regexbuf.not_eol = 0;
			start = re_search (&(patterns[i].regexbuf),
					   buf, end - buf - 1,
					   match - buf, end - match - 1,
					   &(patterns[i].regs));
			if (start < 0)
			  break;
			len = patterns[i].regs.end[0] - start;
			match = buf + start;
		      }
		  } /* while (match <= best_match) */
	      continue;
	    assess_pattern_match:
	      if (!start_ptr)
		{
		  /* Good enough for a non-exact match.
		     No need to look at further patterns, if any.  */
		  beg = match;
		  goto success_in_len;
		}
	      if (match < best_match || (match == best_match && len > best_len))
		{
		  /* Best exact match:  leftmost, then longest.  */
		  best_match = match;
		  best_len = len;
		}
	    } /* if re_search >= 0 */
	} /* for Regex patterns.  */
	if (best_match < end)
	  {
	    /* We have found an exact match.  We were just
	       waiting for the best one (leftmost then longest).  */
	    beg = best_match;
	    len = best_len;
	    goto success_in_len;
	  }
    } /* for (beg = end ..) */

 failure:
  ret_val = -1;
  goto out;

 success:
  len = end - beg;
 success_in_len:
  *match_size = len;
  ret_val = beg - buf;
 out:
  return ret_val;
}

Testing negative cases!
Testing 0 (with abstract condition) ENVIS_NEG
Iteration 0
Running test command:
/home/ubuntu/spr-fast/tools/grep-test.py /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-8a025cf8-8f08d8e2/tempworkdir-l/src /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-8a025cf8-8f08d8e2/tempworkdir-l/tests /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-8a025cf8-8f08d8e2/tempworkdir-l 0  > __res
Opening:/tmp/neg.tmp!
NegativeBRANCH RECORD/tmp/neg.tmp!
APPENDING TO ISNEG:/tmp/neg.tmp!
Branch 0: 0
Iteration 1
Running test command:
/home/ubuntu/spr-fast/tools/grep-test.py /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-8a025cf8-8f08d8e2/tempworkdir-l/src /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-8a025cf8-8f08d8e2/tempworkdir-l/tests /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-8a025cf8-8f08d8e2/tempworkdir-l 0  > __res
Opening:/tmp/neg.tmp!
NegativeBRANCH RECORD/tmp/neg.tmp!
APPENDING TO ISNEG:/tmp/neg.tmp!
Branch 0: 1
Running test command:
/home/ubuntu/spr-fast/tools/grep-test.py /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-8a025cf8-8f08d8e2/tempworkdir-l/src /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-8a025cf8-8f08d8e2/tempworkdir-l/tests /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-8a025cf8-8f08d8e2/tempworkdir-l 0  > __res
a batched test job starts!
Building merged code:
src_file: src/dfasearch.c
full src: int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); void* memset(void*, int, unsigned long); 
/* dfasearch.c - searching subroutines using dfa and regex for grep.
   Copyright 1992, 1998, 2000, 2007, 2009-2010 Free Software Foundation, Inc.

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 3, or (at your option)
   any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program; if not, write to the Free Software
   Foundation, Inc., 51 Franklin Street - Fifth Floor, Boston, MA
   02110-1301, USA.  */

/* Written August 1992 by Mike Haertel. */

#include <config.h>
#include "search.h"
#include "dfa.h"

/* For -w, we also consider _ to be word constituent.  */
#define WCHAR(C) (ISALNUM(C) || (C) == '_')

/* KWset compiled pattern.  For Ecompile and Gcompile, we compile
   a list of strings, at least one of which is known to occur in
   any string matching the regexp. */
static kwset_t kwset;

/* DFA compiled regexp. */
static struct dfa dfa;

/* The Regex compiled patterns.  */
static struct patterns
{
  /* Regex compiled regexp. */
  struct re_pattern_buffer regexbuf;
  struct re_registers regs; /* This is here on account of a BRAIN-DEAD
			       Q@#%!# library interface in regex.c.  */
} patterns0;

struct patterns *patterns;
size_t pcount;

void
dfaerror (char const *mesg)
{
  error (EXIT_TROUBLE, 0, "%s", mesg);

  /* notreached */
  /* Tell static analyzers that this function does not return.  */
  abort ();
}

/* Number of compiled fixed strings known to exactly match the regexp.
   If kwsexec returns < kwset_exact_matches, then we don't need to
   call the regexp matcher at all. */
static int kwset_exact_matches;

static char const *
kwsincr_case (const char *must)
{
  const char *buf;
  size_t n;

  n = strlen (must);
#ifdef MBS_SUPPORT
  if (match_icase && MB_CUR_MAX > 1)
    buf = mbtolower (must, &n);
  else
#endif
    buf = must;
  return kwsincr (kwset, buf, n);
}

/* If the DFA turns out to have some set of fixed strings one of
   which must occur in the match, then we build a kwset matcher
   to find those strings, and thus quickly filter out impossible
   matches. */
static void
kwsmusts (void)
{
  struct dfamust const *dm;
  char const *err;

  if (dfa.musts)
    {
      kwsinit (&kwset);
      /* First, we compile in the substrings known to be exact
	 matches.  The kwset matcher will return the index
	 of the matching string that it chooses. */
      for (dm = dfa.musts; dm; dm = dm->next)
	{
	  if (!dm->exact)
	    continue;
	  ++kwset_exact_matches;
	  if ((err = kwsincr_case (dm->must)) != NULL)
	    error (EXIT_TROUBLE, 0, "%s", err);
	}
      /* Now, we compile the substrings that will require
	 the use of the regexp matcher.  */
      for (dm = dfa.musts; dm; dm = dm->next)
	{
	  if (dm->exact)
	    continue;
	  if ((err = kwsincr_case (dm->must)) != NULL)
	    error (EXIT_TROUBLE, 0, "%s", err);
	}
      //prophet generated patch
      if (__get_mutant()==0) {
      if (((err = kwsprep(kwset)) != ((void *)0)) && !(__is_neg(4, &(err), sizeof (err), &(kwset), sizeof (kwset), &(dm), sizeof (dm), &(kwset_exact_matches), sizeof (kwset_exact_matches))))
          error(EXIT_TROUBLE, 0, "%s", err);
      }
      else if (__get_mutant()==1) {
      if (((err = kwsprep(kwset)) != ((void *)0)) || (__is_neg(4, &(err), sizeof (err), &(kwset), sizeof (kwset), &(dm), sizeof (dm), &(kwset_exact_matches), sizeof (kwset_exact_matches))))
          error(EXIT_TROUBLE, 0, "%s", err);
      }
    }
}

void
GEAcompile (char const *pattern, size_t size, reg_syntax_t syntax_bits)
{
  const char *err;
  const char *p, *sep;
  size_t total = size;
  char *motif;

  if (match_icase)
    syntax_bits |= RE_ICASE;
  re_set_syntax (syntax_bits);
  dfasyntax (syntax_bits, match_icase, eolbyte);

  /* For GNU regex compiler we have to pass the patterns separately to detect
     errors like "[\nallo\n]\n".  The patterns here are "[", "allo" and "]"
     GNU regex should have raise a syntax error.  The same for backref, where
     the backref should have been local to each pattern.  */
  p = pattern;
  do
    {
      size_t len;
      sep = memchr (p, '\n', total);
      if (sep)
	{
	  len = sep - p;
	  sep++;
	  total -= (len + 1);
	}
      else
	{
	  len = total;
	  total = 0;
	}

      patterns = realloc (patterns, (pcount + 1) * sizeof (*patterns));
      if (patterns == NULL)
	error (EXIT_TROUBLE, errno, _("memory exhausted"));
      patterns[pcount] = patterns0;

      if ((err = re_compile_pattern (p, len,
				    &(patterns[pcount].regexbuf))) != NULL)
	error (EXIT_TROUBLE, 0, "%s", err);
      pcount++;

      p = sep;
    } while (sep && total != 0);

  /* In the match_words and match_lines cases, we use a different pattern
     for the DFA matcher that will quickly throw out cases that won't work.
     Then if DFA succeeds we do some hairy stuff using the regex matcher
     to decide whether the match should really count. */
  if (match_words || match_lines)
    {
      static char const line_beg_no_bk[] = "^(";
      static char const line_end_no_bk[] = ")$";
      static char const word_beg_no_bk[] = "(^|[^[:alnum:]_])(";
      static char const word_end_no_bk[] = ")([^[:alnum:]_]|$)";
      static char const line_beg_bk[] = "^\\(";
      static char const line_end_bk[] = "\\)$";
      static char const word_beg_bk[] = "\\(^\\|[^[:alnum:]_]\\)\\(";
      static char const word_end_bk[] = "\\)\\([^[:alnum:]_]\\|$\\)";
      int bk = !(syntax_bits & RE_NO_BK_PARENS);
      char *n = xmalloc (sizeof word_beg_bk - 1 + size + sizeof word_end_bk);

      strcpy (n, match_lines ? (bk ? line_beg_bk : line_beg_no_bk)
			     : (bk ? word_beg_bk : word_beg_no_bk));
      total = strlen(n);
      memcpy (n + total, pattern, size);
      total += size;
      strcpy (n + total, match_lines ? (bk ? line_end_bk : line_end_no_bk)
				     : (bk ? word_end_bk : word_end_no_bk));
      total += strlen (n + total);
      pattern = motif = n;
      size = total;
    }
  else
    motif = NULL;

  dfacomp (pattern, size, &dfa, 1);
  kwsmusts ();

  free(motif);
}

size_t
EGexecute (char const *buf, size_t size, size_t *match_size,
	   char const *start_ptr)
{
  char const *buflim, *beg, *end, *match, *best_match, *mb_start;
  char eol = eolbyte;
  int backref, start, len, best_len;
  struct kwsmatch kwsm;
  size_t i, ret_val;
#ifdef MBS_SUPPORT
  if (MB_CUR_MAX > 1)
    {
      if (match_icase)
        {
          /* mbtolower adds a NUL byte at the end.  That will provide
	     space for the sentinel byte dfaexec may add.  */
          char *case_buf = mbtolower (buf, &size);
	  if (start_ptr)
	    start_ptr = case_buf + (start_ptr - buf);
          buf = case_buf;
        }
    }
#endif /* MBS_SUPPORT */

  mb_start = buf;
  buflim = buf + size;

  for (beg = end = buf; end < buflim; beg = end)
    {
      if (!start_ptr)
	{
	  /* We don't care about an exact match.  */
	  if (kwset)
	    {
	      /* Find a possible match using the KWset matcher. */
	      size_t offset = kwsexec (kwset, beg, buflim - beg, &kwsm);
	      if (offset == (size_t) -1)
		goto failure;
	      beg += offset;
	      /* Narrow down to the line containing the candidate, and
		 run it through DFA. */
	      if ((end = memchr(beg, eol, buflim - beg)) != NULL)
	        end++;
              else
                end = buflim;
	      match = beg;
	      while (beg > buf && beg[-1] != eol)
		--beg;
	      if (kwsm.index < kwset_exact_matches)
                {
#ifdef MBS_SUPPORT
                  if (mb_start < beg)
                    mb_start = beg;
                  if (MB_CUR_MAX == 1 || !is_mb_middle (&mb_start, match, buflim))
#endif
                    goto success;
                }
	      if (dfaexec (&dfa, beg, (char *) end, 0, NULL, &backref) == NULL)
		continue;
	    }
	  else
	    {
	      /* No good fixed strings; start with DFA. */
	      char const *next_beg = dfaexec (&dfa, beg, (char *) buflim,
					      0, NULL, &backref);
	      if (next_beg == NULL)
		break;
	      /* Narrow down to the line we've found. */
	      beg = next_beg;
	      if ((end = memchr(beg, eol, buflim - beg)) != NULL)
	        end++;
              else
                end = buflim;
	      while (beg > buf && beg[-1] != eol)
		--beg;
	    }
	  /* Successful, no backreferences encountered! */
	  if (!backref)
	    goto success;
	}
      else
	{
	  /* We are looking for the leftmost (then longest) exact match.
	     We will go through the outer loop only once.  */
	  beg = start_ptr;
	  end = buflim;
	}

      /* If we've made it to this point, this means DFA has seen
	 a probable match, and we need to run it through Regex. */
      best_match = end;
      best_len = 0;
      for (i = 0; i < pcount; i++)
	{
	  patterns[i].regexbuf.not_eol = 0;
	  if (0 <= (start = re_search (&(patterns[i].regexbuf),
				       buf, end - buf - 1,
				       beg - buf, end - beg - 1,
				       &(patterns[i].regs))))
	    {
	      len = patterns[i].regs.end[0] - start;
	      match = buf + start;
	      if (match > best_match)
		continue;
	      if (start_ptr && !match_words)
		goto assess_pattern_match;
	      if ((!match_lines && !match_words)
		  || (match_lines && len == end - beg - 1))
		{
		  match = beg;
		  len = end - beg;
		  goto assess_pattern_match;
		}
	      /* If -w, check if the match aligns with word boundaries.
		 We do this iteratively because:
		 (a) the line may contain more than one occurence of the
		 pattern, and
		 (b) Several alternatives in the pattern might be valid at a
		 given point, and we may need to consider a shorter one to
		 find a word boundary.  */
	      if (match_words)
		while (match <= best_match)
		  {
		    if ((match == buf || !WCHAR ((unsigned char) match[-1]))
			&& (len == end - beg - 1
			    || !WCHAR ((unsigned char) match[len])))
		      goto assess_pattern_match;
		    if (len > 0)
		      {
			/* Try a shorter length anchored at the same place. */
			--len;
			patterns[i].regexbuf.not_eol = 1;
			len = re_match (&(patterns[i].regexbuf),
					buf, match + len - beg, match - buf,
					&(patterns[i].regs));
		      }
		    if (len <= 0)
		      {
			/* Try looking further on. */
			if (match == end - 1)
			  break;
			match++;
			patterns[i].regexbuf.not_eol = 0;
			start = re_search (&(patterns[i].regexbuf),
					   buf, end - buf - 1,
					   match - buf, end - match - 1,
					   &(patterns[i].regs));
			if (start < 0)
			  break;
			len = patterns[i].regs.end[0] - start;
			match = buf + start;
		      }
		  } /* while (match <= best_match) */
	      continue;
	    assess_pattern_match:
	      if (!start_ptr)
		{
		  /* Good enough for a non-exact match.
		     No need to look at further patterns, if any.  */
		  beg = match;
		  goto success_in_len;
		}
	      if (match < best_match || (match == best_match && len > best_len))
		{
		  /* Best exact match:  leftmost, then longest.  */
		  best_match = match;
		  best_len = len;
		}
	    } /* if re_search >= 0 */
	} /* for Regex patterns.  */
	if (best_match < end)
	  {
	    /* We have found an exact match.  We were just
	       waiting for the best one (leftmost then longest).  */
	    beg = best_match;
	    len = best_len;
	    goto success_in_len;
	  }
    } /* for (beg = end ..) */

 failure:
  ret_val = -1;
  goto out;

 success:
  len = end - beg;
 success_in_len:
  *match_size = len;
  ret_val = beg - buf;
 out:
  return ret_val;
}

Building:src at:
/home/ubuntu/spr-fast/tests/corebench/grep/grep-case-8a025cf8-8f08d8e2/tempworkdir-l/srcMerged code building succ, going to invoke tester!
CondTester, Testing instance id 1:
//src_file:src/dfasearch.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); void* memset(void*, int, unsigned long); 
/* dfasearch.c - searching subroutines using dfa and regex for grep.
   Copyright 1992, 1998, 2000, 2007, 2009-2010 Free Software Foundation, Inc.

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 3, or (at your option)
   any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program; if not, write to the Free Software
   Foundation, Inc., 51 Franklin Street - Fifth Floor, Boston, MA
   02110-1301, USA.  */

/* Written August 1992 by Mike Haertel. */

#include <config.h>
#include "search.h"
#include "dfa.h"

/* For -w, we also consider _ to be word constituent.  */
#define WCHAR(C) (ISALNUM(C) || (C) == '_')

/* KWset compiled pattern.  For Ecompile and Gcompile, we compile
   a list of strings, at least one of which is known to occur in
   any string matching the regexp. */
static kwset_t kwset;

/* DFA compiled regexp. */
static struct dfa dfa;

/* The Regex compiled patterns.  */
static struct patterns
{
  /* Regex compiled regexp. */
  struct re_pattern_buffer regexbuf;
  struct re_registers regs; /* This is here on account of a BRAIN-DEAD
			       Q@#%!# library interface in regex.c.  */
} patterns0;

struct patterns *patterns;
size_t pcount;

void
dfaerror (char const *mesg)
{
  error (EXIT_TROUBLE, 0, "%s", mesg);

  /* notreached */
  /* Tell static analyzers that this function does not return.  */
  abort ();
}

/* Number of compiled fixed strings known to exactly match the regexp.
   If kwsexec returns < kwset_exact_matches, then we don't need to
   call the regexp matcher at all. */
static int kwset_exact_matches;

static char const *
kwsincr_case (const char *must)
{
  const char *buf;
  size_t n;

  n = strlen (must);
#ifdef MBS_SUPPORT
  if (match_icase && MB_CUR_MAX > 1)
    buf = mbtolower (must, &n);
  else
#endif
    buf = must;
  return kwsincr (kwset, buf, n);
}

/* If the DFA turns out to have some set of fixed strings one of
   which must occur in the match, then we build a kwset matcher
   to find those strings, and thus quickly filter out impossible
   matches. */
static void
kwsmusts (void)
{
  struct dfamust const *dm;
  char const *err;

  if (dfa.musts)
    {
      kwsinit (&kwset);
      /* First, we compile in the substrings known to be exact
	 matches.  The kwset matcher will return the index
	 of the matching string that it chooses. */
      for (dm = dfa.musts; dm; dm = dm->next)
	{
	  if (!dm->exact)
	    continue;
	  ++kwset_exact_matches;
	  if ((err = kwsincr_case (dm->must)) != NULL)
	    error (EXIT_TROUBLE, 0, "%s", err);
	}
      /* Now, we compile the substrings that will require
	 the use of the regexp matcher.  */
      for (dm = dfa.musts; dm; dm = dm->next)
	{
	  if (dm->exact)
	    continue;
	  if ((err = kwsincr_case (dm->must)) != NULL)
	    error (EXIT_TROUBLE, 0, "%s", err);
	}
      
//Patch 0:
if (((err = kwsprep(kwset)) != ((void *)0)) && !(__is_neg(4, &(err), sizeof (err), &(kwset), sizeof (kwset), &(dm), sizeof (dm), &(kwset_exact_matches), sizeof (kwset_exact_matches))))
    error(EXIT_TROUBLE, 0, "%s", err);

//CodeSeg 1:
    }
}

void
GEAcompile (char const *pattern, size_t size, reg_syntax_t syntax_bits)
{
  const char *err;
  const char *p, *sep;
  size_t total = size;
  char *motif;

  if (match_icase)
    syntax_bits |= RE_ICASE;
  re_set_syntax (syntax_bits);
  dfasyntax (syntax_bits, match_icase, eolbyte);

  /* For GNU regex compiler we have to pass the patterns separately to detect
     errors like "[\nallo\n]\n".  The patterns here are "[", "allo" and "]"
     GNU regex should have raise a syntax error.  The same for backref, where
     the backref should have been local to each pattern.  */
  p = pattern;
  do
    {
      size_t len;
      sep = memchr (p, '\n', total);
      if (sep)
	{
	  len = sep - p;
	  sep++;
	  total -= (len + 1);
	}
      else
	{
	  len = total;
	  total = 0;
	}

      patterns = realloc (patterns, (pcount + 1) * sizeof (*patterns));
      if (patterns == NULL)
	error (EXIT_TROUBLE, errno, _("memory exhausted"));
      patterns[pcount] = patterns0;

      if ((err = re_compile_pattern (p, len,
				    &(patterns[pcount].regexbuf))) != NULL)
	error (EXIT_TROUBLE, 0, "%s", err);
      pcount++;

      p = sep;
    } while (sep && total != 0);

  /* In the match_words and match_lines cases, we use a different pattern
     for the DFA matcher that will quickly throw out cases that won't work.
     Then if DFA succeeds we do some hairy stuff using the regex matcher
     to decide whether the match should really count. */
  if (match_words || match_lines)
    {
      static char const line_beg_no_bk[] = "^(";
      static char const line_end_no_bk[] = ")$";
      static char const word_beg_no_bk[] = "(^|[^[:alnum:]_])(";
      static char const word_end_no_bk[] = ")([^[:alnum:]_]|$)";
      static char const line_beg_bk[] = "^\\(";
      static char const line_end_bk[] = "\\)$";
      static char const word_beg_bk[] = "\\(^\\|[^[:alnum:]_]\\)\\(";
      static char const word_end_bk[] = "\\)\\([^[:alnum:]_]\\|$\\)";
      int bk = !(syntax_bits & RE_NO_BK_PARENS);
      char *n = xmalloc (sizeof word_beg_bk - 1 + size + sizeof word_end_bk);

      strcpy (n, match_lines ? (bk ? line_beg_bk : line_beg_no_bk)
			     : (bk ? word_beg_bk : word_beg_no_bk));
      total = strlen(n);
      memcpy (n + total, pattern, size);
      total += size;
      strcpy (n + total, match_lines ? (bk ? line_end_bk : line_end_no_bk)
				     : (bk ? word_end_bk : word_end_no_bk));
      total += strlen (n + total);
      pattern = motif = n;
      size = total;
    }
  else
    motif = NULL;

  dfacomp (pattern, size, &dfa, 1);
  kwsmusts ();

  free(motif);
}

size_t
EGexecute (char const *buf, size_t size, size_t *match_size,
	   char const *start_ptr)
{
  char const *buflim, *beg, *end, *match, *best_match, *mb_start;
  char eol = eolbyte;
  int backref, start, len, best_len;
  struct kwsmatch kwsm;
  size_t i, ret_val;
#ifdef MBS_SUPPORT
  if (MB_CUR_MAX > 1)
    {
      if (match_icase)
        {
          /* mbtolower adds a NUL byte at the end.  That will provide
	     space for the sentinel byte dfaexec may add.  */
          char *case_buf = mbtolower (buf, &size);
	  if (start_ptr)
	    start_ptr = case_buf + (start_ptr - buf);
          buf = case_buf;
        }
    }
#endif /* MBS_SUPPORT */

  mb_start = buf;
  buflim = buf + size;

  for (beg = end = buf; end < buflim; beg = end)
    {
      if (!start_ptr)
	{
	  /* We don't care about an exact match.  */
	  if (kwset)
	    {
	      /* Find a possible match using the KWset matcher. */
	      size_t offset = kwsexec (kwset, beg, buflim - beg, &kwsm);
	      if (offset == (size_t) -1)
		goto failure;
	      beg += offset;
	      /* Narrow down to the line containing the candidate, and
		 run it through DFA. */
	      if ((end = memchr(beg, eol, buflim - beg)) != NULL)
	        end++;
              else
                end = buflim;
	      match = beg;
	      while (beg > buf && beg[-1] != eol)
		--beg;
	      if (kwsm.index < kwset_exact_matches)
                {
#ifdef MBS_SUPPORT
                  if (mb_start < beg)
                    mb_start = beg;
                  if (MB_CUR_MAX == 1 || !is_mb_middle (&mb_start, match, buflim))
#endif
                    goto success;
                }
	      if (dfaexec (&dfa, beg, (char *) end, 0, NULL, &backref) == NULL)
		continue;
	    }
	  else
	    {
	      /* No good fixed strings; start with DFA. */
	      char const *next_beg = dfaexec (&dfa, beg, (char *) buflim,
					      0, NULL, &backref);
	      if (next_beg == NULL)
		break;
	      /* Narrow down to the line we've found. */
	      beg = next_beg;
	      if ((end = memchr(beg, eol, buflim - beg)) != NULL)
	        end++;
              else
                end = buflim;
	      while (beg > buf && beg[-1] != eol)
		--beg;
	    }
	  /* Successful, no backreferences encountered! */
	  if (!backref)
	    goto success;
	}
      else
	{
	  /* We are looking for the leftmost (then longest) exact match.
	     We will go through the outer loop only once.  */
	  beg = start_ptr;
	  end = buflim;
	}

      /* If we've made it to this point, this means DFA has seen
	 a probable match, and we need to run it through Regex. */
      best_match = end;
      best_len = 0;
      for (i = 0; i < pcount; i++)
	{
	  patterns[i].regexbuf.not_eol = 0;
	  if (0 <= (start = re_search (&(patterns[i].regexbuf),
				       buf, end - buf - 1,
				       beg - buf, end - beg - 1,
				       &(patterns[i].regs))))
	    {
	      len = patterns[i].regs.end[0] - start;
	      match = buf + start;
	      if (match > best_match)
		continue;
	      if (start_ptr && !match_words)
		goto assess_pattern_match;
	      if ((!match_lines && !match_words)
		  || (match_lines && len == end - beg - 1))
		{
		  match = beg;
		  len = end - beg;
		  goto assess_pattern_match;
		}
	      /* If -w, check if the match aligns with word boundaries.
		 We do this iteratively because:
		 (a) the line may contain more than one occurence of the
		 pattern, and
		 (b) Several alternatives in the pattern might be valid at a
		 given point, and we may need to consider a shorter one to
		 find a word boundary.  */
	      if (match_words)
		while (match <= best_match)
		  {
		    if ((match == buf || !WCHAR ((unsigned char) match[-1]))
			&& (len == end - beg - 1
			    || !WCHAR ((unsigned char) match[len])))
		      goto assess_pattern_match;
		    if (len > 0)
		      {
			/* Try a shorter length anchored at the same place. */
			--len;
			patterns[i].regexbuf.not_eol = 1;
			len = re_match (&(patterns[i].regexbuf),
					buf, match + len - beg, match - buf,
					&(patterns[i].regs));
		      }
		    if (len <= 0)
		      {
			/* Try looking further on. */
			if (match == end - 1)
			  break;
			match++;
			patterns[i].regexbuf.not_eol = 0;
			start = re_search (&(patterns[i].regexbuf),
					   buf, end - buf - 1,
					   match - buf, end - match - 1,
					   &(patterns[i].regs));
			if (start < 0)
			  break;
			len = patterns[i].regs.end[0] - start;
			match = buf + start;
		      }
		  } /* while (match <= best_match) */
	      continue;
	    assess_pattern_match:
	      if (!start_ptr)
		{
		  /* Good enough for a non-exact match.
		     No need to look at further patterns, if any.  */
		  beg = match;
		  goto success_in_len;
		}
	      if (match < best_match || (match == best_match && len > best_len))
		{
		  /* Best exact match:  leftmost, then longest.  */
		  best_match = match;
		  best_len = len;
		}
	    } /* if re_search >= 0 */
	} /* for Regex patterns.  */
	if (best_match < end)
	  {
	    /* We have found an exact match.  We were just
	       waiting for the best one (leftmost then longest).  */
	    beg = best_match;
	    len = best_len;
	    goto success_in_len;
	  }
    } /* for (beg = end ..) */

 failure:
  ret_val = -1;
  goto out;

 success:
  len = end - beg;
 success_in_len:
  *match_size = len;
  ret_val = beg - buf;
 out:
  return ret_val;
}

Testing negative cases!
Testing 0 (with abstract condition) ENVIS_NEG
Iteration 0
Running test command:
/home/ubuntu/spr-fast/tools/grep-test.py /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-8a025cf8-8f08d8e2/tempworkdir-l/src /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-8a025cf8-8f08d8e2/tempworkdir-l/tests /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-8a025cf8-8f08d8e2/tempworkdir-l 0  > __res
Opening:/tmp/neg.tmp!
NegativeBRANCH RECORD/tmp/neg.tmp!
Not caught by the negative case, give up!
APPENDING TO ISNEG:/tmp/neg.tmp!
Running test command:
/home/ubuntu/spr-fast/tools/grep-test.py /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-8a025cf8-8f08d8e2/tempworkdir-l/src /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-8a025cf8-8f08d8e2/tempworkdir-l/tests /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-8a025cf8-8f08d8e2/tempworkdir-l 0  > __res
CondTester, Testing instance id 16:
//src_file:src/dfasearch.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); void* memset(void*, int, unsigned long); 
/* dfasearch.c - searching subroutines using dfa and regex for grep.
   Copyright 1992, 1998, 2000, 2007, 2009-2010 Free Software Foundation, Inc.

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 3, or (at your option)
   any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program; if not, write to the Free Software
   Foundation, Inc., 51 Franklin Street - Fifth Floor, Boston, MA
   02110-1301, USA.  */

/* Written August 1992 by Mike Haertel. */

#include <config.h>
#include "search.h"
#include "dfa.h"

/* For -w, we also consider _ to be word constituent.  */
#define WCHAR(C) (ISALNUM(C) || (C) == '_')

/* KWset compiled pattern.  For Ecompile and Gcompile, we compile
   a list of strings, at least one of which is known to occur in
   any string matching the regexp. */
static kwset_t kwset;

/* DFA compiled regexp. */
static struct dfa dfa;

/* The Regex compiled patterns.  */
static struct patterns
{
  /* Regex compiled regexp. */
  struct re_pattern_buffer regexbuf;
  struct re_registers regs; /* This is here on account of a BRAIN-DEAD
			       Q@#%!# library interface in regex.c.  */
} patterns0;

struct patterns *patterns;
size_t pcount;

void
dfaerror (char const *mesg)
{
  error (EXIT_TROUBLE, 0, "%s", mesg);

  /* notreached */
  /* Tell static analyzers that this function does not return.  */
  abort ();
}

/* Number of compiled fixed strings known to exactly match the regexp.
   If kwsexec returns < kwset_exact_matches, then we don't need to
   call the regexp matcher at all. */
static int kwset_exact_matches;

static char const *
kwsincr_case (const char *must)
{
  const char *buf;
  size_t n;

  n = strlen (must);
#ifdef MBS_SUPPORT
  if (match_icase && MB_CUR_MAX > 1)
    buf = mbtolower (must, &n);
  else
#endif
    buf = must;
  return kwsincr (kwset, buf, n);
}

/* If the DFA turns out to have some set of fixed strings one of
   which must occur in the match, then we build a kwset matcher
   to find those strings, and thus quickly filter out impossible
   matches. */
static void
kwsmusts (void)
{
  struct dfamust const *dm;
  char const *err;

  if (dfa.musts)
    {
      kwsinit (&kwset);
      /* First, we compile in the substrings known to be exact
	 matches.  The kwset matcher will return the index
	 of the matching string that it chooses. */
      for (dm = dfa.musts; dm; dm = dm->next)
	{
	  if (!dm->exact)
	    continue;
	  ++kwset_exact_matches;
	  if ((err = kwsincr_case (dm->must)) != NULL)
	    error (EXIT_TROUBLE, 0, "%s", err);
	}
      /* Now, we compile the substrings that will require
	 the use of the regexp matcher.  */
      for (dm = dfa.musts; dm; dm = dm->next)
	{
	  if (dm->exact)
	    continue;
	  if ((err = kwsincr_case (dm->must)) != NULL)
	    error (EXIT_TROUBLE, 0, "%s", err);
	}
      
//Patch 0:
if (((err = kwsprep(kwset)) != ((void *)0)) || (__is_neg(4, &(err), sizeof (err), &(kwset), sizeof (kwset), &(dm), sizeof (dm), &(kwset_exact_matches), sizeof (kwset_exact_matches))))
    error(EXIT_TROUBLE, 0, "%s", err);

//CodeSeg 1:
    }
}

void
GEAcompile (char const *pattern, size_t size, reg_syntax_t syntax_bits)
{
  const char *err;
  const char *p, *sep;
  size_t total = size;
  char *motif;

  if (match_icase)
    syntax_bits |= RE_ICASE;
  re_set_syntax (syntax_bits);
  dfasyntax (syntax_bits, match_icase, eolbyte);

  /* For GNU regex compiler we have to pass the patterns separately to detect
     errors like "[\nallo\n]\n".  The patterns here are "[", "allo" and "]"
     GNU regex should have raise a syntax error.  The same for backref, where
     the backref should have been local to each pattern.  */
  p = pattern;
  do
    {
      size_t len;
      sep = memchr (p, '\n', total);
      if (sep)
	{
	  len = sep - p;
	  sep++;
	  total -= (len + 1);
	}
      else
	{
	  len = total;
	  total = 0;
	}

      patterns = realloc (patterns, (pcount + 1) * sizeof (*patterns));
      if (patterns == NULL)
	error (EXIT_TROUBLE, errno, _("memory exhausted"));
      patterns[pcount] = patterns0;

      if ((err = re_compile_pattern (p, len,
				    &(patterns[pcount].regexbuf))) != NULL)
	error (EXIT_TROUBLE, 0, "%s", err);
      pcount++;

      p = sep;
    } while (sep && total != 0);

  /* In the match_words and match_lines cases, we use a different pattern
     for the DFA matcher that will quickly throw out cases that won't work.
     Then if DFA succeeds we do some hairy stuff using the regex matcher
     to decide whether the match should really count. */
  if (match_words || match_lines)
    {
      static char const line_beg_no_bk[] = "^(";
      static char const line_end_no_bk[] = ")$";
      static char const word_beg_no_bk[] = "(^|[^[:alnum:]_])(";
      static char const word_end_no_bk[] = ")([^[:alnum:]_]|$)";
      static char const line_beg_bk[] = "^\\(";
      static char const line_end_bk[] = "\\)$";
      static char const word_beg_bk[] = "\\(^\\|[^[:alnum:]_]\\)\\(";
      static char const word_end_bk[] = "\\)\\([^[:alnum:]_]\\|$\\)";
      int bk = !(syntax_bits & RE_NO_BK_PARENS);
      char *n = xmalloc (sizeof word_beg_bk - 1 + size + sizeof word_end_bk);

      strcpy (n, match_lines ? (bk ? line_beg_bk : line_beg_no_bk)
			     : (bk ? word_beg_bk : word_beg_no_bk));
      total = strlen(n);
      memcpy (n + total, pattern, size);
      total += size;
      strcpy (n + total, match_lines ? (bk ? line_end_bk : line_end_no_bk)
				     : (bk ? word_end_bk : word_end_no_bk));
      total += strlen (n + total);
      pattern = motif = n;
      size = total;
    }
  else
    motif = NULL;

  dfacomp (pattern, size, &dfa, 1);
  kwsmusts ();

  free(motif);
}

size_t
EGexecute (char const *buf, size_t size, size_t *match_size,
	   char const *start_ptr)
{
  char const *buflim, *beg, *end, *match, *best_match, *mb_start;
  char eol = eolbyte;
  int backref, start, len, best_len;
  struct kwsmatch kwsm;
  size_t i, ret_val;
#ifdef MBS_SUPPORT
  if (MB_CUR_MAX > 1)
    {
      if (match_icase)
        {
          /* mbtolower adds a NUL byte at the end.  That will provide
	     space for the sentinel byte dfaexec may add.  */
          char *case_buf = mbtolower (buf, &size);
	  if (start_ptr)
	    start_ptr = case_buf + (start_ptr - buf);
          buf = case_buf;
        }
    }
#endif /* MBS_SUPPORT */

  mb_start = buf;
  buflim = buf + size;

  for (beg = end = buf; end < buflim; beg = end)
    {
      if (!start_ptr)
	{
	  /* We don't care about an exact match.  */
	  if (kwset)
	    {
	      /* Find a possible match using the KWset matcher. */
	      size_t offset = kwsexec (kwset, beg, buflim - beg, &kwsm);
	      if (offset == (size_t) -1)
		goto failure;
	      beg += offset;
	      /* Narrow down to the line containing the candidate, and
		 run it through DFA. */
	      if ((end = memchr(beg, eol, buflim - beg)) != NULL)
	        end++;
              else
                end = buflim;
	      match = beg;
	      while (beg > buf && beg[-1] != eol)
		--beg;
	      if (kwsm.index < kwset_exact_matches)
                {
#ifdef MBS_SUPPORT
                  if (mb_start < beg)
                    mb_start = beg;
                  if (MB_CUR_MAX == 1 || !is_mb_middle (&mb_start, match, buflim))
#endif
                    goto success;
                }
	      if (dfaexec (&dfa, beg, (char *) end, 0, NULL, &backref) == NULL)
		continue;
	    }
	  else
	    {
	      /* No good fixed strings; start with DFA. */
	      char const *next_beg = dfaexec (&dfa, beg, (char *) buflim,
					      0, NULL, &backref);
	      if (next_beg == NULL)
		break;
	      /* Narrow down to the line we've found. */
	      beg = next_beg;
	      if ((end = memchr(beg, eol, buflim - beg)) != NULL)
	        end++;
              else
                end = buflim;
	      while (beg > buf && beg[-1] != eol)
		--beg;
	    }
	  /* Successful, no backreferences encountered! */
	  if (!backref)
	    goto success;
	}
      else
	{
	  /* We are looking for the leftmost (then longest) exact match.
	     We will go through the outer loop only once.  */
	  beg = start_ptr;
	  end = buflim;
	}

      /* If we've made it to this point, this means DFA has seen
	 a probable match, and we need to run it through Regex. */
      best_match = end;
      best_len = 0;
      for (i = 0; i < pcount; i++)
	{
	  patterns[i].regexbuf.not_eol = 0;
	  if (0 <= (start = re_search (&(patterns[i].regexbuf),
				       buf, end - buf - 1,
				       beg - buf, end - beg - 1,
				       &(patterns[i].regs))))
	    {
	      len = patterns[i].regs.end[0] - start;
	      match = buf + start;
	      if (match > best_match)
		continue;
	      if (start_ptr && !match_words)
		goto assess_pattern_match;
	      if ((!match_lines && !match_words)
		  || (match_lines && len == end - beg - 1))
		{
		  match = beg;
		  len = end - beg;
		  goto assess_pattern_match;
		}
	      /* If -w, check if the match aligns with word boundaries.
		 We do this iteratively because:
		 (a) the line may contain more than one occurence of the
		 pattern, and
		 (b) Several alternatives in the pattern might be valid at a
		 given point, and we may need to consider a shorter one to
		 find a word boundary.  */
	      if (match_words)
		while (match <= best_match)
		  {
		    if ((match == buf || !WCHAR ((unsigned char) match[-1]))
			&& (len == end - beg - 1
			    || !WCHAR ((unsigned char) match[len])))
		      goto assess_pattern_match;
		    if (len > 0)
		      {
			/* Try a shorter length anchored at the same place. */
			--len;
			patterns[i].regexbuf.not_eol = 1;
			len = re_match (&(patterns[i].regexbuf),
					buf, match + len - beg, match - buf,
					&(patterns[i].regs));
		      }
		    if (len <= 0)
		      {
			/* Try looking further on. */
			if (match == end - 1)
			  break;
			match++;
			patterns[i].regexbuf.not_eol = 0;
			start = re_search (&(patterns[i].regexbuf),
					   buf, end - buf - 1,
					   match - buf, end - match - 1,
					   &(patterns[i].regs));
			if (start < 0)
			  break;
			len = patterns[i].regs.end[0] - start;
			match = buf + start;
		      }
		  } /* while (match <= best_match) */
	      continue;
	    assess_pattern_match:
	      if (!start_ptr)
		{
		  /* Good enough for a non-exact match.
		     No need to look at further patterns, if any.  */
		  beg = match;
		  goto success_in_len;
		}
	      if (match < best_match || (match == best_match && len > best_len))
		{
		  /* Best exact match:  leftmost, then longest.  */
		  best_match = match;
		  best_len = len;
		}
	    } /* if re_search >= 0 */
	} /* for Regex patterns.  */
	if (best_match < end)
	  {
	    /* We have found an exact match.  We were just
	       waiting for the best one (leftmost then longest).  */
	    beg = best_match;
	    len = best_len;
	    goto success_in_len;
	  }
    } /* for (beg = end ..) */

 failure:
  ret_val = -1;
  goto out;

 success:
  len = end - beg;
 success_in_len:
  *match_size = len;
  ret_val = beg - buf;
 out:
  return ret_val;
}

Testing negative cases!
Testing 0 (with abstract condition) ENVIS_NEG
Iteration 0
Running test command:
/home/ubuntu/spr-fast/tools/grep-test.py /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-8a025cf8-8f08d8e2/tempworkdir-l/src /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-8a025cf8-8f08d8e2/tempworkdir-l/tests /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-8a025cf8-8f08d8e2/tempworkdir-l 0  > __res
Opening:/tmp/neg.tmp!
NegativeBRANCH RECORD/tmp/neg.tmp!
APPENDING TO ISNEG:/tmp/neg.tmp!
Branch 0: 0
Iteration 1
Running test command:
/home/ubuntu/spr-fast/tools/grep-test.py /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-8a025cf8-8f08d8e2/tempworkdir-l/src /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-8a025cf8-8f08d8e2/tempworkdir-l/tests /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-8a025cf8-8f08d8e2/tempworkdir-l 0  > __res
Opening:/tmp/neg.tmp!
NegativeBRANCH RECORD/tmp/neg.tmp!
APPENDING TO ISNEG:/tmp/neg.tmp!
Branch 0: 1
Running test command:
/home/ubuntu/spr-fast/tools/grep-test.py /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-8a025cf8-8f08d8e2/tempworkdir-l/src /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-8a025cf8-8f08d8e2/tempworkdir-l/tests /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-8a025cf8-8f08d8e2/tempworkdir-l 0  > __res
a batched test job starts!
Building merged code:
src_file: src/dfasearch.c
full src: int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); void* memset(void*, int, unsigned long); 
/* dfasearch.c - searching subroutines using dfa and regex for grep.
   Copyright 1992, 1998, 2000, 2007, 2009-2010 Free Software Foundation, Inc.

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 3, or (at your option)
   any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program; if not, write to the Free Software
   Foundation, Inc., 51 Franklin Street - Fifth Floor, Boston, MA
   02110-1301, USA.  */

/* Written August 1992 by Mike Haertel. */

#include <config.h>
#include "search.h"
#include "dfa.h"

/* For -w, we also consider _ to be word constituent.  */
#define WCHAR(C) (ISALNUM(C) || (C) == '_')

/* KWset compiled pattern.  For Ecompile and Gcompile, we compile
   a list of strings, at least one of which is known to occur in
   any string matching the regexp. */
static kwset_t kwset;

/* DFA compiled regexp. */
static struct dfa dfa;

/* The Regex compiled patterns.  */
static struct patterns
{
  /* Regex compiled regexp. */
  struct re_pattern_buffer regexbuf;
  struct re_registers regs; /* This is here on account of a BRAIN-DEAD
			       Q@#%!# library interface in regex.c.  */
} patterns0;

struct patterns *patterns;
size_t pcount;

void
dfaerror (char const *mesg)
{
  error (EXIT_TROUBLE, 0, "%s", mesg);

  /* notreached */
  /* Tell static analyzers that this function does not return.  */
  abort ();
}

/* Number of compiled fixed strings known to exactly match the regexp.
   If kwsexec returns < kwset_exact_matches, then we don't need to
   call the regexp matcher at all. */
static int kwset_exact_matches;

static char const *
kwsincr_case (const char *must)
{
  const char *buf;
  size_t n;

  n = strlen (must);
#ifdef MBS_SUPPORT
  if (match_icase && MB_CUR_MAX > 1)
    buf = mbtolower (must, &n);
  else
#endif
    buf = must;
  return kwsincr (kwset, buf, n);
}

/* If the DFA turns out to have some set of fixed strings one of
   which must occur in the match, then we build a kwset matcher
   to find those strings, and thus quickly filter out impossible
   matches. */
static void
kwsmusts (void)
{
  struct dfamust const *dm;
  char const *err;

  if (dfa.musts)
    {
      kwsinit (&kwset);
      /* First, we compile in the substrings known to be exact
	 matches.  The kwset matcher will return the index
	 of the matching string that it chooses. */
      for (dm = dfa.musts; dm; dm = dm->next)
	{
	  if (!dm->exact)
	    continue;
	  ++kwset_exact_matches;
	  if ((err = kwsincr_case (dm->must)) != NULL)
	    error (EXIT_TROUBLE, 0, "%s", err);
	}
      /* Now, we compile the substrings that will require
	 the use of the regexp matcher.  */
      for (dm = dfa.musts; dm; dm = dm->next)
	{
	  if (dm->exact)
	    continue;
	  if ((err = kwsincr_case (dm->must)) != NULL)
	    error (EXIT_TROUBLE, 0, "%s", err);
	}
      if ((err = kwsprep (kwset)) != NULL)
	error (EXIT_TROUBLE, 0, "%s", err);
    }
}

void
GEAcompile (char const *pattern, size_t size, reg_syntax_t syntax_bits)
{
  const char *err;
  const char *p, *sep;
  size_t total = size;
  char *motif;

  //prophet generated patch
  if (__get_mutant()==0) {
  if ((match_icase) || (__is_neg(14, &(match_icase), sizeof (match_icase), &(syntax_bits), sizeof (syntax_bits), &(size), sizeof (size), &(eolbyte), sizeof (eolbyte), &(pattern), sizeof (pattern), &(p), sizeof (p), &(sep), sizeof (sep), &(total), sizeof (total), &(patterns), sizeof (patterns), &(pcount), sizeof (pcount), &(err), sizeof (err), &(match_words), sizeof (match_words), &(match_lines), sizeof (match_lines), &(motif), sizeof (motif))))
      syntax_bits |= ((((((((((((((((((((((((unsigned long)1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1);
  }
  else if (__get_mutant()==1) {
  if ((match_icase) && !(__is_neg(14, &(match_icase), sizeof (match_icase), &(syntax_bits), sizeof (syntax_bits), &(size), sizeof (size), &(eolbyte), sizeof (eolbyte), &(pattern), sizeof (pattern), &(p), sizeof (p), &(sep), sizeof (sep), &(total), sizeof (total), &(patterns), sizeof (patterns), &(pcount), sizeof (pcount), &(err), sizeof (err), &(match_words), sizeof (match_words), &(match_lines), sizeof (match_lines), &(motif), sizeof (motif))))
      syntax_bits |= ((((((((((((((((((((((((unsigned long)1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1);
  }
  re_set_syntax (syntax_bits);
  dfasyntax (syntax_bits, match_icase, eolbyte);

  /* For GNU regex compiler we have to pass the patterns separately to detect
     errors like "[\nallo\n]\n".  The patterns here are "[", "allo" and "]"
     GNU regex should have raise a syntax error.  The same for backref, where
     the backref should have been local to each pattern.  */
  p = pattern;
  do
    {
      size_t len;
      sep = memchr (p, '\n', total);
      if (sep)
	{
	  len = sep - p;
	  sep++;
	  total -= (len + 1);
	}
      else
	{
	  len = total;
	  total = 0;
	}

      patterns = realloc (patterns, (pcount + 1) * sizeof (*patterns));
      if (patterns == NULL)
	error (EXIT_TROUBLE, errno, _("memory exhausted"));
      patterns[pcount] = patterns0;

      if ((err = re_compile_pattern (p, len,
				    &(patterns[pcount].regexbuf))) != NULL)
	error (EXIT_TROUBLE, 0, "%s", err);
      pcount++;

      p = sep;
    } while (sep && total != 0);

  /* In the match_words and match_lines cases, we use a different pattern
     for the DFA matcher that will quickly throw out cases that won't work.
     Then if DFA succeeds we do some hairy stuff using the regex matcher
     to decide whether the match should really count. */
  if (match_words || match_lines)
    {
      static char const line_beg_no_bk[] = "^(";
      static char const line_end_no_bk[] = ")$";
      static char const word_beg_no_bk[] = "(^|[^[:alnum:]_])(";
      static char const word_end_no_bk[] = ")([^[:alnum:]_]|$)";
      static char const line_beg_bk[] = "^\\(";
      static char const line_end_bk[] = "\\)$";
      static char const word_beg_bk[] = "\\(^\\|[^[:alnum:]_]\\)\\(";
      static char const word_end_bk[] = "\\)\\([^[:alnum:]_]\\|$\\)";
      int bk = !(syntax_bits & RE_NO_BK_PARENS);
      char *n = xmalloc (sizeof word_beg_bk - 1 + size + sizeof word_end_bk);

      strcpy (n, match_lines ? (bk ? line_beg_bk : line_beg_no_bk)
			     : (bk ? word_beg_bk : word_beg_no_bk));
      total = strlen(n);
      memcpy (n + total, pattern, size);
      total += size;
      strcpy (n + total, match_lines ? (bk ? line_end_bk : line_end_no_bk)
				     : (bk ? word_end_bk : word_end_no_bk));
      total += strlen (n + total);
      pattern = motif = n;
      size = total;
    }
  else
    motif = NULL;

  dfacomp (pattern, size, &dfa, 1);
  kwsmusts ();

  free(motif);
}

size_t
EGexecute (char const *buf, size_t size, size_t *match_size,
	   char const *start_ptr)
{
  char const *buflim, *beg, *end, *match, *best_match, *mb_start;
  char eol = eolbyte;
  int backref, start, len, best_len;
  struct kwsmatch kwsm;
  size_t i, ret_val;
#ifdef MBS_SUPPORT
  if (MB_CUR_MAX > 1)
    {
      if (match_icase)
        {
          /* mbtolower adds a NUL byte at the end.  That will provide
	     space for the sentinel byte dfaexec may add.  */
          char *case_buf = mbtolower (buf, &size);
	  if (start_ptr)
	    start_ptr = case_buf + (start_ptr - buf);
          buf = case_buf;
        }
    }
#endif /* MBS_SUPPORT */

  mb_start = buf;
  buflim = buf + size;

  for (beg = end = buf; end < buflim; beg = end)
    {
      if (!start_ptr)
	{
	  /* We don't care about an exact match.  */
	  if (kwset)
	    {
	      /* Find a possible match using the KWset matcher. */
	      size_t offset = kwsexec (kwset, beg, buflim - beg, &kwsm);
	      if (offset == (size_t) -1)
		goto failure;
	      beg += offset;
	      /* Narrow down to the line containing the candidate, and
		 run it through DFA. */
	      if ((end = memchr(beg, eol, buflim - beg)) != NULL)
	        end++;
              else
                end = buflim;
	      match = beg;
	      while (beg > buf && beg[-1] != eol)
		--beg;
	      if (kwsm.index < kwset_exact_matches)
                {
#ifdef MBS_SUPPORT
                  if (mb_start < beg)
                    mb_start = beg;
                  if (MB_CUR_MAX == 1 || !is_mb_middle (&mb_start, match, buflim))
#endif
                    goto success;
                }
	      if (dfaexec (&dfa, beg, (char *) end, 0, NULL, &backref) == NULL)
		continue;
	    }
	  else
	    {
	      /* No good fixed strings; start with DFA. */
	      char const *next_beg = dfaexec (&dfa, beg, (char *) buflim,
					      0, NULL, &backref);
	      if (next_beg == NULL)
		break;
	      /* Narrow down to the line we've found. */
	      beg = next_beg;
	      if ((end = memchr(beg, eol, buflim - beg)) != NULL)
	        end++;
              else
                end = buflim;
	      while (beg > buf && beg[-1] != eol)
		--beg;
	    }
	  /* Successful, no backreferences encountered! */
	  if (!backref)
	    goto success;
	}
      else
	{
	  /* We are looking for the leftmost (then longest) exact match.
	     We will go through the outer loop only once.  */
	  beg = start_ptr;
	  end = buflim;
	}

      /* If we've made it to this point, this means DFA has seen
	 a probable match, and we need to run it through Regex. */
      best_match = end;
      best_len = 0;
      for (i = 0; i < pcount; i++)
	{
	  patterns[i].regexbuf.not_eol = 0;
	  if (0 <= (start = re_search (&(patterns[i].regexbuf),
				       buf, end - buf - 1,
				       beg - buf, end - beg - 1,
				       &(patterns[i].regs))))
	    {
	      len = patterns[i].regs.end[0] - start;
	      match = buf + start;
	      if (match > best_match)
		continue;
	      if (start_ptr && !match_words)
		goto assess_pattern_match;
	      if ((!match_lines && !match_words)
		  || (match_lines && len == end - beg - 1))
		{
		  match = beg;
		  len = end - beg;
		  goto assess_pattern_match;
		}
	      /* If -w, check if the match aligns with word boundaries.
		 We do this iteratively because:
		 (a) the line may contain more than one occurence of the
		 pattern, and
		 (b) Several alternatives in the pattern might be valid at a
		 given point, and we may need to consider a shorter one to
		 find a word boundary.  */
	      if (match_words)
		while (match <= best_match)
		  {
		    if ((match == buf || !WCHAR ((unsigned char) match[-1]))
			&& (len == end - beg - 1
			    || !WCHAR ((unsigned char) match[len])))
		      goto assess_pattern_match;
		    if (len > 0)
		      {
			/* Try a shorter length anchored at the same place. */
			--len;
			patterns[i].regexbuf.not_eol = 1;
			len = re_match (&(patterns[i].regexbuf),
					buf, match + len - beg, match - buf,
					&(patterns[i].regs));
		      }
		    if (len <= 0)
		      {
			/* Try looking further on. */
			if (match == end - 1)
			  break;
			match++;
			patterns[i].regexbuf.not_eol = 0;
			start = re_search (&(patterns[i].regexbuf),
					   buf, end - buf - 1,
					   match - buf, end - match - 1,
					   &(patterns[i].regs));
			if (start < 0)
			  break;
			len = patterns[i].regs.end[0] - start;
			match = buf + start;
		      }
		  } /* while (match <= best_match) */
	      continue;
	    assess_pattern_match:
	      if (!start_ptr)
		{
		  /* Good enough for a non-exact match.
		     No need to look at further patterns, if any.  */
		  beg = match;
		  goto success_in_len;
		}
	      if (match < best_match || (match == best_match && len > best_len))
		{
		  /* Best exact match:  leftmost, then longest.  */
		  best_match = match;
		  best_len = len;
		}
	    } /* if re_search >= 0 */
	} /* for Regex patterns.  */
	if (best_match < end)
	  {
	    /* We have found an exact match.  We were just
	       waiting for the best one (leftmost then longest).  */
	    beg = best_match;
	    len = best_len;
	    goto success_in_len;
	  }
    } /* for (beg = end ..) */

 failure:
  ret_val = -1;
  goto out;

 success:
  len = end - beg;
 success_in_len:
  *match_size = len;
  ret_val = beg - buf;
 out:
  return ret_val;
}

Building:src at:
/home/ubuntu/spr-fast/tests/corebench/grep/grep-case-8a025cf8-8f08d8e2/tempworkdir-l/srcMerged code building succ, going to invoke tester!
CondTester, Testing instance id 35:
//src_file:src/dfasearch.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); void* memset(void*, int, unsigned long); 
/* dfasearch.c - searching subroutines using dfa and regex for grep.
   Copyright 1992, 1998, 2000, 2007, 2009-2010 Free Software Foundation, Inc.

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 3, or (at your option)
   any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program; if not, write to the Free Software
   Foundation, Inc., 51 Franklin Street - Fifth Floor, Boston, MA
   02110-1301, USA.  */

/* Written August 1992 by Mike Haertel. */

#include <config.h>
#include "search.h"
#include "dfa.h"

/* For -w, we also consider _ to be word constituent.  */
#define WCHAR(C) (ISALNUM(C) || (C) == '_')

/* KWset compiled pattern.  For Ecompile and Gcompile, we compile
   a list of strings, at least one of which is known to occur in
   any string matching the regexp. */
static kwset_t kwset;

/* DFA compiled regexp. */
static struct dfa dfa;

/* The Regex compiled patterns.  */
static struct patterns
{
  /* Regex compiled regexp. */
  struct re_pattern_buffer regexbuf;
  struct re_registers regs; /* This is here on account of a BRAIN-DEAD
			       Q@#%!# library interface in regex.c.  */
} patterns0;

struct patterns *patterns;
size_t pcount;

void
dfaerror (char const *mesg)
{
  error (EXIT_TROUBLE, 0, "%s", mesg);

  /* notreached */
  /* Tell static analyzers that this function does not return.  */
  abort ();
}

/* Number of compiled fixed strings known to exactly match the regexp.
   If kwsexec returns < kwset_exact_matches, then we don't need to
   call the regexp matcher at all. */
static int kwset_exact_matches;

static char const *
kwsincr_case (const char *must)
{
  const char *buf;
  size_t n;

  n = strlen (must);
#ifdef MBS_SUPPORT
  if (match_icase && MB_CUR_MAX > 1)
    buf = mbtolower (must, &n);
  else
#endif
    buf = must;
  return kwsincr (kwset, buf, n);
}

/* If the DFA turns out to have some set of fixed strings one of
   which must occur in the match, then we build a kwset matcher
   to find those strings, and thus quickly filter out impossible
   matches. */
static void
kwsmusts (void)
{
  struct dfamust const *dm;
  char const *err;

  if (dfa.musts)
    {
      kwsinit (&kwset);
      /* First, we compile in the substrings known to be exact
	 matches.  The kwset matcher will return the index
	 of the matching string that it chooses. */
      for (dm = dfa.musts; dm; dm = dm->next)
	{
	  if (!dm->exact)
	    continue;
	  ++kwset_exact_matches;
	  if ((err = kwsincr_case (dm->must)) != NULL)
	    error (EXIT_TROUBLE, 0, "%s", err);
	}
      /* Now, we compile the substrings that will require
	 the use of the regexp matcher.  */
      for (dm = dfa.musts; dm; dm = dm->next)
	{
	  if (dm->exact)
	    continue;
	  if ((err = kwsincr_case (dm->must)) != NULL)
	    error (EXIT_TROUBLE, 0, "%s", err);
	}
      if ((err = kwsprep (kwset)) != NULL)
	error (EXIT_TROUBLE, 0, "%s", err);
    }
}

void
GEAcompile (char const *pattern, size_t size, reg_syntax_t syntax_bits)
{
  const char *err;
  const char *p, *sep;
  size_t total = size;
  char *motif;

  
//Patch 0:
if ((match_icase) || (__is_neg(14, &(match_icase), sizeof (match_icase), &(syntax_bits), sizeof (syntax_bits), &(size), sizeof (size), &(eolbyte), sizeof (eolbyte), &(pattern), sizeof (pattern), &(p), sizeof (p), &(sep), sizeof (sep), &(total), sizeof (total), &(patterns), sizeof (patterns), &(pcount), sizeof (pcount), &(err), sizeof (err), &(match_words), sizeof (match_words), &(match_lines), sizeof (match_lines), &(motif), sizeof (motif))))
    syntax_bits |= ((((((((((((((((((((((((unsigned long)1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1);

//CodeSeg 1:
  re_set_syntax (syntax_bits);
  dfasyntax (syntax_bits, match_icase, eolbyte);

  /* For GNU regex compiler we have to pass the patterns separately to detect
     errors like "[\nallo\n]\n".  The patterns here are "[", "allo" and "]"
     GNU regex should have raise a syntax error.  The same for backref, where
     the backref should have been local to each pattern.  */
  p = pattern;
  do
    {
      size_t len;
      sep = memchr (p, '\n', total);
      if (sep)
	{
	  len = sep - p;
	  sep++;
	  total -= (len + 1);
	}
      else
	{
	  len = total;
	  total = 0;
	}

      patterns = realloc (patterns, (pcount + 1) * sizeof (*patterns));
      if (patterns == NULL)
	error (EXIT_TROUBLE, errno, _("memory exhausted"));
      patterns[pcount] = patterns0;

      if ((err = re_compile_pattern (p, len,
				    &(patterns[pcount].regexbuf))) != NULL)
	error (EXIT_TROUBLE, 0, "%s", err);
      pcount++;

      p = sep;
    } while (sep && total != 0);

  /* In the match_words and match_lines cases, we use a different pattern
     for the DFA matcher that will quickly throw out cases that won't work.
     Then if DFA succeeds we do some hairy stuff using the regex matcher
     to decide whether the match should really count. */
  if (match_words || match_lines)
    {
      static char const line_beg_no_bk[] = "^(";
      static char const line_end_no_bk[] = ")$";
      static char const word_beg_no_bk[] = "(^|[^[:alnum:]_])(";
      static char const word_end_no_bk[] = ")([^[:alnum:]_]|$)";
      static char const line_beg_bk[] = "^\\(";
      static char const line_end_bk[] = "\\)$";
      static char const word_beg_bk[] = "\\(^\\|[^[:alnum:]_]\\)\\(";
      static char const word_end_bk[] = "\\)\\([^[:alnum:]_]\\|$\\)";
      int bk = !(syntax_bits & RE_NO_BK_PARENS);
      char *n = xmalloc (sizeof word_beg_bk - 1 + size + sizeof word_end_bk);

      strcpy (n, match_lines ? (bk ? line_beg_bk : line_beg_no_bk)
			     : (bk ? word_beg_bk : word_beg_no_bk));
      total = strlen(n);
      memcpy (n + total, pattern, size);
      total += size;
      strcpy (n + total, match_lines ? (bk ? line_end_bk : line_end_no_bk)
				     : (bk ? word_end_bk : word_end_no_bk));
      total += strlen (n + total);
      pattern = motif = n;
      size = total;
    }
  else
    motif = NULL;

  dfacomp (pattern, size, &dfa, 1);
  kwsmusts ();

  free(motif);
}

size_t
EGexecute (char const *buf, size_t size, size_t *match_size,
	   char const *start_ptr)
{
  char const *buflim, *beg, *end, *match, *best_match, *mb_start;
  char eol = eolbyte;
  int backref, start, len, best_len;
  struct kwsmatch kwsm;
  size_t i, ret_val;
#ifdef MBS_SUPPORT
  if (MB_CUR_MAX > 1)
    {
      if (match_icase)
        {
          /* mbtolower adds a NUL byte at the end.  That will provide
	     space for the sentinel byte dfaexec may add.  */
          char *case_buf = mbtolower (buf, &size);
	  if (start_ptr)
	    start_ptr = case_buf + (start_ptr - buf);
          buf = case_buf;
        }
    }
#endif /* MBS_SUPPORT */

  mb_start = buf;
  buflim = buf + size;

  for (beg = end = buf; end < buflim; beg = end)
    {
      if (!start_ptr)
	{
	  /* We don't care about an exact match.  */
	  if (kwset)
	    {
	      /* Find a possible match using the KWset matcher. */
	      size_t offset = kwsexec (kwset, beg, buflim - beg, &kwsm);
	      if (offset == (size_t) -1)
		goto failure;
	      beg += offset;
	      /* Narrow down to the line containing the candidate, and
		 run it through DFA. */
	      if ((end = memchr(beg, eol, buflim - beg)) != NULL)
	        end++;
              else
                end = buflim;
	      match = beg;
	      while (beg > buf && beg[-1] != eol)
		--beg;
	      if (kwsm.index < kwset_exact_matches)
                {
#ifdef MBS_SUPPORT
                  if (mb_start < beg)
                    mb_start = beg;
                  if (MB_CUR_MAX == 1 || !is_mb_middle (&mb_start, match, buflim))
#endif
                    goto success;
                }
	      if (dfaexec (&dfa, beg, (char *) end, 0, NULL, &backref) == NULL)
		continue;
	    }
	  else
	    {
	      /* No good fixed strings; start with DFA. */
	      char const *next_beg = dfaexec (&dfa, beg, (char *) buflim,
					      0, NULL, &backref);
	      if (next_beg == NULL)
		break;
	      /* Narrow down to the line we've found. */
	      beg = next_beg;
	      if ((end = memchr(beg, eol, buflim - beg)) != NULL)
	        end++;
              else
                end = buflim;
	      while (beg > buf && beg[-1] != eol)
		--beg;
	    }
	  /* Successful, no backreferences encountered! */
	  if (!backref)
	    goto success;
	}
      else
	{
	  /* We are looking for the leftmost (then longest) exact match.
	     We will go through the outer loop only once.  */
	  beg = start_ptr;
	  end = buflim;
	}

      /* If we've made it to this point, this means DFA has seen
	 a probable match, and we need to run it through Regex. */
      best_match = end;
      best_len = 0;
      for (i = 0; i < pcount; i++)
	{
	  patterns[i].regexbuf.not_eol = 0;
	  if (0 <= (start = re_search (&(patterns[i].regexbuf),
				       buf, end - buf - 1,
				       beg - buf, end - beg - 1,
				       &(patterns[i].regs))))
	    {
	      len = patterns[i].regs.end[0] - start;
	      match = buf + start;
	      if (match > best_match)
		continue;
	      if (start_ptr && !match_words)
		goto assess_pattern_match;
	      if ((!match_lines && !match_words)
		  || (match_lines && len == end - beg - 1))
		{
		  match = beg;
		  len = end - beg;
		  goto assess_pattern_match;
		}
	      /* If -w, check if the match aligns with word boundaries.
		 We do this iteratively because:
		 (a) the line may contain more than one occurence of the
		 pattern, and
		 (b) Several alternatives in the pattern might be valid at a
		 given point, and we may need to consider a shorter one to
		 find a word boundary.  */
	      if (match_words)
		while (match <= best_match)
		  {
		    if ((match == buf || !WCHAR ((unsigned char) match[-1]))
			&& (len == end - beg - 1
			    || !WCHAR ((unsigned char) match[len])))
		      goto assess_pattern_match;
		    if (len > 0)
		      {
			/* Try a shorter length anchored at the same place. */
			--len;
			patterns[i].regexbuf.not_eol = 1;
			len = re_match (&(patterns[i].regexbuf),
					buf, match + len - beg, match - buf,
					&(patterns[i].regs));
		      }
		    if (len <= 0)
		      {
			/* Try looking further on. */
			if (match == end - 1)
			  break;
			match++;
			patterns[i].regexbuf.not_eol = 0;
			start = re_search (&(patterns[i].regexbuf),
					   buf, end - buf - 1,
					   match - buf, end - match - 1,
					   &(patterns[i].regs));
			if (start < 0)
			  break;
			len = patterns[i].regs.end[0] - start;
			match = buf + start;
		      }
		  } /* while (match <= best_match) */
	      continue;
	    assess_pattern_match:
	      if (!start_ptr)
		{
		  /* Good enough for a non-exact match.
		     No need to look at further patterns, if any.  */
		  beg = match;
		  goto success_in_len;
		}
	      if (match < best_match || (match == best_match && len > best_len))
		{
		  /* Best exact match:  leftmost, then longest.  */
		  best_match = match;
		  best_len = len;
		}
	    } /* if re_search >= 0 */
	} /* for Regex patterns.  */
	if (best_match < end)
	  {
	    /* We have found an exact match.  We were just
	       waiting for the best one (leftmost then longest).  */
	    beg = best_match;
	    len = best_len;
	    goto success_in_len;
	  }
    } /* for (beg = end ..) */

 failure:
  ret_val = -1;
  goto out;

 success:
  len = end - beg;
 success_in_len:
  *match_size = len;
  ret_val = beg - buf;
 out:
  return ret_val;
}

Testing negative cases!
Testing 0 (with abstract condition) ENVIS_NEG
Iteration 0
Running test command:
/home/ubuntu/spr-fast/tools/grep-test.py /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-8a025cf8-8f08d8e2/tempworkdir-l/src /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-8a025cf8-8f08d8e2/tempworkdir-l/tests /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-8a025cf8-8f08d8e2/tempworkdir-l 0  > __res
Opening:/tmp/neg.tmp!
NegativeBRANCH RECORD/tmp/neg.tmp!
APPENDING TO ISNEG:/tmp/neg.tmp!
Branch 0: 0
Iteration 1
Running test command:
/home/ubuntu/spr-fast/tools/grep-test.py /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-8a025cf8-8f08d8e2/tempworkdir-l/src /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-8a025cf8-8f08d8e2/tempworkdir-l/tests /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-8a025cf8-8f08d8e2/tempworkdir-l 0  > __res
Opening:/tmp/neg.tmp!
NegativeBRANCH RECORD/tmp/neg.tmp!
APPENDING TO ISNEG:/tmp/neg.tmp!
Branch 0: 1
Running test command:
/home/ubuntu/spr-fast/tools/grep-test.py /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-8a025cf8-8f08d8e2/tempworkdir-l/src /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-8a025cf8-8f08d8e2/tempworkdir-l/tests /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-8a025cf8-8f08d8e2/tempworkdir-l 0  > __res
CondTester, Testing instance id 42:
//src_file:src/dfasearch.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); void* memset(void*, int, unsigned long); 
/* dfasearch.c - searching subroutines using dfa and regex for grep.
   Copyright 1992, 1998, 2000, 2007, 2009-2010 Free Software Foundation, Inc.

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 3, or (at your option)
   any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program; if not, write to the Free Software
   Foundation, Inc., 51 Franklin Street - Fifth Floor, Boston, MA
   02110-1301, USA.  */

/* Written August 1992 by Mike Haertel. */

#include <config.h>
#include "search.h"
#include "dfa.h"

/* For -w, we also consider _ to be word constituent.  */
#define WCHAR(C) (ISALNUM(C) || (C) == '_')

/* KWset compiled pattern.  For Ecompile and Gcompile, we compile
   a list of strings, at least one of which is known to occur in
   any string matching the regexp. */
static kwset_t kwset;

/* DFA compiled regexp. */
static struct dfa dfa;

/* The Regex compiled patterns.  */
static struct patterns
{
  /* Regex compiled regexp. */
  struct re_pattern_buffer regexbuf;
  struct re_registers regs; /* This is here on account of a BRAIN-DEAD
			       Q@#%!# library interface in regex.c.  */
} patterns0;

struct patterns *patterns;
size_t pcount;

void
dfaerror (char const *mesg)
{
  error (EXIT_TROUBLE, 0, "%s", mesg);

  /* notreached */
  /* Tell static analyzers that this function does not return.  */
  abort ();
}

/* Number of compiled fixed strings known to exactly match the regexp.
   If kwsexec returns < kwset_exact_matches, then we don't need to
   call the regexp matcher at all. */
static int kwset_exact_matches;

static char const *
kwsincr_case (const char *must)
{
  const char *buf;
  size_t n;

  n = strlen (must);
#ifdef MBS_SUPPORT
  if (match_icase && MB_CUR_MAX > 1)
    buf = mbtolower (must, &n);
  else
#endif
    buf = must;
  return kwsincr (kwset, buf, n);
}

/* If the DFA turns out to have some set of fixed strings one of
   which must occur in the match, then we build a kwset matcher
   to find those strings, and thus quickly filter out impossible
   matches. */
static void
kwsmusts (void)
{
  struct dfamust const *dm;
  char const *err;

  if (dfa.musts)
    {
      kwsinit (&kwset);
      /* First, we compile in the substrings known to be exact
	 matches.  The kwset matcher will return the index
	 of the matching string that it chooses. */
      for (dm = dfa.musts; dm; dm = dm->next)
	{
	  if (!dm->exact)
	    continue;
	  ++kwset_exact_matches;
	  if ((err = kwsincr_case (dm->must)) != NULL)
	    error (EXIT_TROUBLE, 0, "%s", err);
	}
      /* Now, we compile the substrings that will require
	 the use of the regexp matcher.  */
      for (dm = dfa.musts; dm; dm = dm->next)
	{
	  if (dm->exact)
	    continue;
	  if ((err = kwsincr_case (dm->must)) != NULL)
	    error (EXIT_TROUBLE, 0, "%s", err);
	}
      if ((err = kwsprep (kwset)) != NULL)
	error (EXIT_TROUBLE, 0, "%s", err);
    }
}

void
GEAcompile (char const *pattern, size_t size, reg_syntax_t syntax_bits)
{
  const char *err;
  const char *p, *sep;
  size_t total = size;
  char *motif;

  
//Patch 0:
if ((match_icase) && !(__is_neg(14, &(match_icase), sizeof (match_icase), &(syntax_bits), sizeof (syntax_bits), &(size), sizeof (size), &(eolbyte), sizeof (eolbyte), &(pattern), sizeof (pattern), &(p), sizeof (p), &(sep), sizeof (sep), &(total), sizeof (total), &(patterns), sizeof (patterns), &(pcount), sizeof (pcount), &(err), sizeof (err), &(match_words), sizeof (match_words), &(match_lines), sizeof (match_lines), &(motif), sizeof (motif))))
    syntax_bits |= ((((((((((((((((((((((((unsigned long)1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1);

//CodeSeg 1:
  re_set_syntax (syntax_bits);
  dfasyntax (syntax_bits, match_icase, eolbyte);

  /* For GNU regex compiler we have to pass the patterns separately to detect
     errors like "[\nallo\n]\n".  The patterns here are "[", "allo" and "]"
     GNU regex should have raise a syntax error.  The same for backref, where
     the backref should have been local to each pattern.  */
  p = pattern;
  do
    {
      size_t len;
      sep = memchr (p, '\n', total);
      if (sep)
	{
	  len = sep - p;
	  sep++;
	  total -= (len + 1);
	}
      else
	{
	  len = total;
	  total = 0;
	}

      patterns = realloc (patterns, (pcount + 1) * sizeof (*patterns));
      if (patterns == NULL)
	error (EXIT_TROUBLE, errno, _("memory exhausted"));
      patterns[pcount] = patterns0;

      if ((err = re_compile_pattern (p, len,
				    &(patterns[pcount].regexbuf))) != NULL)
	error (EXIT_TROUBLE, 0, "%s", err);
      pcount++;

      p = sep;
    } while (sep && total != 0);

  /* In the match_words and match_lines cases, we use a different pattern
     for the DFA matcher that will quickly throw out cases that won't work.
     Then if DFA succeeds we do some hairy stuff using the regex matcher
     to decide whether the match should really count. */
  if (match_words || match_lines)
    {
      static char const line_beg_no_bk[] = "^(";
      static char const line_end_no_bk[] = ")$";
      static char const word_beg_no_bk[] = "(^|[^[:alnum:]_])(";
      static char const word_end_no_bk[] = ")([^[:alnum:]_]|$)";
      static char const line_beg_bk[] = "^\\(";
      static char const line_end_bk[] = "\\)$";
      static char const word_beg_bk[] = "\\(^\\|[^[:alnum:]_]\\)\\(";
      static char const word_end_bk[] = "\\)\\([^[:alnum:]_]\\|$\\)";
      int bk = !(syntax_bits & RE_NO_BK_PARENS);
      char *n = xmalloc (sizeof word_beg_bk - 1 + size + sizeof word_end_bk);

      strcpy (n, match_lines ? (bk ? line_beg_bk : line_beg_no_bk)
			     : (bk ? word_beg_bk : word_beg_no_bk));
      total = strlen(n);
      memcpy (n + total, pattern, size);
      total += size;
      strcpy (n + total, match_lines ? (bk ? line_end_bk : line_end_no_bk)
				     : (bk ? word_end_bk : word_end_no_bk));
      total += strlen (n + total);
      pattern = motif = n;
      size = total;
    }
  else
    motif = NULL;

  dfacomp (pattern, size, &dfa, 1);
  kwsmusts ();

  free(motif);
}

size_t
EGexecute (char const *buf, size_t size, size_t *match_size,
	   char const *start_ptr)
{
  char const *buflim, *beg, *end, *match, *best_match, *mb_start;
  char eol = eolbyte;
  int backref, start, len, best_len;
  struct kwsmatch kwsm;
  size_t i, ret_val;
#ifdef MBS_SUPPORT
  if (MB_CUR_MAX > 1)
    {
      if (match_icase)
        {
          /* mbtolower adds a NUL byte at the end.  That will provide
	     space for the sentinel byte dfaexec may add.  */
          char *case_buf = mbtolower (buf, &size);
	  if (start_ptr)
	    start_ptr = case_buf + (start_ptr - buf);
          buf = case_buf;
        }
    }
#endif /* MBS_SUPPORT */

  mb_start = buf;
  buflim = buf + size;

  for (beg = end = buf; end < buflim; beg = end)
    {
      if (!start_ptr)
	{
	  /* We don't care about an exact match.  */
	  if (kwset)
	    {
	      /* Find a possible match using the KWset matcher. */
	      size_t offset = kwsexec (kwset, beg, buflim - beg, &kwsm);
	      if (offset == (size_t) -1)
		goto failure;
	      beg += offset;
	      /* Narrow down to the line containing the candidate, and
		 run it through DFA. */
	      if ((end = memchr(beg, eol, buflim - beg)) != NULL)
	        end++;
              else
                end = buflim;
	      match = beg;
	      while (beg > buf && beg[-1] != eol)
		--beg;
	      if (kwsm.index < kwset_exact_matches)
                {
#ifdef MBS_SUPPORT
                  if (mb_start < beg)
                    mb_start = beg;
                  if (MB_CUR_MAX == 1 || !is_mb_middle (&mb_start, match, buflim))
#endif
                    goto success;
                }
	      if (dfaexec (&dfa, beg, (char *) end, 0, NULL, &backref) == NULL)
		continue;
	    }
	  else
	    {
	      /* No good fixed strings; start with DFA. */
	      char const *next_beg = dfaexec (&dfa, beg, (char *) buflim,
					      0, NULL, &backref);
	      if (next_beg == NULL)
		break;
	      /* Narrow down to the line we've found. */
	      beg = next_beg;
	      if ((end = memchr(beg, eol, buflim - beg)) != NULL)
	        end++;
              else
                end = buflim;
	      while (beg > buf && beg[-1] != eol)
		--beg;
	    }
	  /* Successful, no backreferences encountered! */
	  if (!backref)
	    goto success;
	}
      else
	{
	  /* We are looking for the leftmost (then longest) exact match.
	     We will go through the outer loop only once.  */
	  beg = start_ptr;
	  end = buflim;
	}

      /* If we've made it to this point, this means DFA has seen
	 a probable match, and we need to run it through Regex. */
      best_match = end;
      best_len = 0;
      for (i = 0; i < pcount; i++)
	{
	  patterns[i].regexbuf.not_eol = 0;
	  if (0 <= (start = re_search (&(patterns[i].regexbuf),
				       buf, end - buf - 1,
				       beg - buf, end - beg - 1,
				       &(patterns[i].regs))))
	    {
	      len = patterns[i].regs.end[0] - start;
	      match = buf + start;
	      if (match > best_match)
		continue;
	      if (start_ptr && !match_words)
		goto assess_pattern_match;
	      if ((!match_lines && !match_words)
		  || (match_lines && len == end - beg - 1))
		{
		  match = beg;
		  len = end - beg;
		  goto assess_pattern_match;
		}
	      /* If -w, check if the match aligns with word boundaries.
		 We do this iteratively because:
		 (a) the line may contain more than one occurence of the
		 pattern, and
		 (b) Several alternatives in the pattern might be valid at a
		 given point, and we may need to consider a shorter one to
		 find a word boundary.  */
	      if (match_words)
		while (match <= best_match)
		  {
		    if ((match == buf || !WCHAR ((unsigned char) match[-1]))
			&& (len == end - beg - 1
			    || !WCHAR ((unsigned char) match[len])))
		      goto assess_pattern_match;
		    if (len > 0)
		      {
			/* Try a shorter length anchored at the same place. */
			--len;
			patterns[i].regexbuf.not_eol = 1;
			len = re_match (&(patterns[i].regexbuf),
					buf, match + len - beg, match - buf,
					&(patterns[i].regs));
		      }
		    if (len <= 0)
		      {
			/* Try looking further on. */
			if (match == end - 1)
			  break;
			match++;
			patterns[i].regexbuf.not_eol = 0;
			start = re_search (&(patterns[i].regexbuf),
					   buf, end - buf - 1,
					   match - buf, end - match - 1,
					   &(patterns[i].regs));
			if (start < 0)
			  break;
			len = patterns[i].regs.end[0] - start;
			match = buf + start;
		      }
		  } /* while (match <= best_match) */
	      continue;
	    assess_pattern_match:
	      if (!start_ptr)
		{
		  /* Good enough for a non-exact match.
		     No need to look at further patterns, if any.  */
		  beg = match;
		  goto success_in_len;
		}
	      if (match < best_match || (match == best_match && len > best_len))
		{
		  /* Best exact match:  leftmost, then longest.  */
		  best_match = match;
		  best_len = len;
		}
	    } /* if re_search >= 0 */
	} /* for Regex patterns.  */
	if (best_match < end)
	  {
	    /* We have found an exact match.  We were just
	       waiting for the best one (leftmost then longest).  */
	    beg = best_match;
	    len = best_len;
	    goto success_in_len;
	  }
    } /* for (beg = end ..) */

 failure:
  ret_val = -1;
  goto out;

 success:
  len = end - beg;
 success_in_len:
  *match_size = len;
  ret_val = beg - buf;
 out:
  return ret_val;
}

Testing negative cases!
Testing 0 (with abstract condition) ENVIS_NEG
Iteration 0
Running test command:
/home/ubuntu/spr-fast/tools/grep-test.py /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-8a025cf8-8f08d8e2/tempworkdir-l/src /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-8a025cf8-8f08d8e2/tempworkdir-l/tests /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-8a025cf8-8f08d8e2/tempworkdir-l 0  > __res
Opening:/tmp/neg.tmp!
NegativeBRANCH RECORD/tmp/neg.tmp!
Not caught by the negative case, give up!
APPENDING TO ISNEG:/tmp/neg.tmp!
Running test command:
/home/ubuntu/spr-fast/tools/grep-test.py /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-8a025cf8-8f08d8e2/tempworkdir-l/src /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-8a025cf8-8f08d8e2/tempworkdir-l/tests /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-8a025cf8-8f08d8e2/tempworkdir-l 0  > __res
a batched test job starts!
Building merged code:
src_file: src/dfasearch.c
full src: int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); void* memset(void*, int, unsigned long); 
/* dfasearch.c - searching subroutines using dfa and regex for grep.
   Copyright 1992, 1998, 2000, 2007, 2009-2010 Free Software Foundation, Inc.

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 3, or (at your option)
   any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program; if not, write to the Free Software
   Foundation, Inc., 51 Franklin Street - Fifth Floor, Boston, MA
   02110-1301, USA.  */

/* Written August 1992 by Mike Haertel. */

#include <config.h>
#include "search.h"
#include "dfa.h"

/* For -w, we also consider _ to be word constituent.  */
#define WCHAR(C) (ISALNUM(C) || (C) == '_')

/* KWset compiled pattern.  For Ecompile and Gcompile, we compile
   a list of strings, at least one of which is known to occur in
   any string matching the regexp. */
static kwset_t kwset;

/* DFA compiled regexp. */
static struct dfa dfa;

/* The Regex compiled patterns.  */
static struct patterns
{
  /* Regex compiled regexp. */
  struct re_pattern_buffer regexbuf;
  struct re_registers regs; /* This is here on account of a BRAIN-DEAD
			       Q@#%!# library interface in regex.c.  */
} patterns0;

struct patterns *patterns;
size_t pcount;

void
dfaerror (char const *mesg)
{
  error (EXIT_TROUBLE, 0, "%s", mesg);

  /* notreached */
  /* Tell static analyzers that this function does not return.  */
  abort ();
}

/* Number of compiled fixed strings known to exactly match the regexp.
   If kwsexec returns < kwset_exact_matches, then we don't need to
   call the regexp matcher at all. */
static int kwset_exact_matches;

static char const *
kwsincr_case (const char *must)
{
  const char *buf;
  size_t n;

  n = strlen (must);
#ifdef MBS_SUPPORT
  if (match_icase && MB_CUR_MAX > 1)
    buf = mbtolower (must, &n);
  else
#endif
    buf = must;
  return kwsincr (kwset, buf, n);
}

/* If the DFA turns out to have some set of fixed strings one of
   which must occur in the match, then we build a kwset matcher
   to find those strings, and thus quickly filter out impossible
   matches. */
static void
kwsmusts (void)
{
  struct dfamust const *dm;
  char const *err;

  if (dfa.musts)
    {
      kwsinit (&kwset);
      /* First, we compile in the substrings known to be exact
	 matches.  The kwset matcher will return the index
	 of the matching string that it chooses. */
      for (dm = dfa.musts; dm; dm = dm->next)
	{
	  if (!dm->exact)
	    continue;
	  ++kwset_exact_matches;
	  if ((err = kwsincr_case (dm->must)) != NULL)
	    error (EXIT_TROUBLE, 0, "%s", err);
	}
      /* Now, we compile the substrings that will require
	 the use of the regexp matcher.  */
      for (dm = dfa.musts; dm; dm = dm->next)
	{
	  if (dm->exact)
	    continue;
	  if ((err = kwsincr_case (dm->must)) != NULL)
	    error (EXIT_TROUBLE, 0, "%s", err);
	}
      if ((err = kwsprep (kwset)) != NULL)
	error (EXIT_TROUBLE, 0, "%s", err);
    }
}

void
GEAcompile (char const *pattern, size_t size, reg_syntax_t syntax_bits)
{
  const char *err;
  const char *p, *sep;
  size_t total = size;
  char *motif;

  if (match_icase)
    syntax_bits |= RE_ICASE;
  re_set_syntax (syntax_bits);
  dfasyntax (syntax_bits, match_icase, eolbyte);

  /* For GNU regex compiler we have to pass the patterns separately to detect
     errors like "[\nallo\n]\n".  The patterns here are "[", "allo" and "]"
     GNU regex should have raise a syntax error.  The same for backref, where
     the backref should have been local to each pattern.  */
  p = pattern;
  do
    {
      size_t len;
      sep = memchr (p, '\n', total);
      //prophet generated patch
      if (__get_mutant()==0) {
      if ((sep) && !(__is_neg(15, &(sep), sizeof (sep), &(p), sizeof (p), &(total), sizeof (total), &(len), sizeof (len), &(pattern), sizeof (pattern), &(syntax_bits), sizeof (syntax_bits), &(match_icase), sizeof (match_icase), &(eolbyte), sizeof (eolbyte), &(patterns), sizeof (patterns), &(pcount), sizeof (pcount), &(size), sizeof (size), &(err), sizeof (err), &(match_words), sizeof (match_words), &(match_lines), sizeof (match_lines), &(motif), sizeof (motif)))) {
          len = sep - p;
          sep++;
          total -= (len + 1);
      } else {
          len = total;
          total = 0;
      }
      }
      else if (__get_mutant()==1) {
      if ((sep) || (__is_neg(15, &(sep), sizeof (sep), &(p), sizeof (p), &(total), sizeof (total), &(len), sizeof (len), &(pattern), sizeof (pattern), &(syntax_bits), sizeof (syntax_bits), &(match_icase), sizeof (match_icase), &(eolbyte), sizeof (eolbyte), &(patterns), sizeof (patterns), &(pcount), sizeof (pcount), &(size), sizeof (size), &(err), sizeof (err), &(match_words), sizeof (match_words), &(match_lines), sizeof (match_lines), &(motif), sizeof (motif)))) {
          len = sep - p;
          sep++;
          total -= (len + 1);
      } else {
          len = total;
          total = 0;
      }
      }

      patterns = realloc (patterns, (pcount + 1) * sizeof (*patterns));
      if (patterns == NULL)
	error (EXIT_TROUBLE, errno, _("memory exhausted"));
      patterns[pcount] = patterns0;

      if ((err = re_compile_pattern (p, len,
				    &(patterns[pcount].regexbuf))) != NULL)
	error (EXIT_TROUBLE, 0, "%s", err);
      pcount++;

      p = sep;
    } while (sep && total != 0);

  /* In the match_words and match_lines cases, we use a different pattern
     for the DFA matcher that will quickly throw out cases that won't work.
     Then if DFA succeeds we do some hairy stuff using the regex matcher
     to decide whether the match should really count. */
  if (match_words || match_lines)
    {
      static char const line_beg_no_bk[] = "^(";
      static char const line_end_no_bk[] = ")$";
      static char const word_beg_no_bk[] = "(^|[^[:alnum:]_])(";
      static char const word_end_no_bk[] = ")([^[:alnum:]_]|$)";
      static char const line_beg_bk[] = "^\\(";
      static char const line_end_bk[] = "\\)$";
      static char const word_beg_bk[] = "\\(^\\|[^[:alnum:]_]\\)\\(";
      static char const word_end_bk[] = "\\)\\([^[:alnum:]_]\\|$\\)";
      int bk = !(syntax_bits & RE_NO_BK_PARENS);
      char *n = xmalloc (sizeof word_beg_bk - 1 + size + sizeof word_end_bk);

      strcpy (n, match_lines ? (bk ? line_beg_bk : line_beg_no_bk)
			     : (bk ? word_beg_bk : word_beg_no_bk));
      total = strlen(n);
      memcpy (n + total, pattern, size);
      total += size;
      strcpy (n + total, match_lines ? (bk ? line_end_bk : line_end_no_bk)
				     : (bk ? word_end_bk : word_end_no_bk));
      total += strlen (n + total);
      pattern = motif = n;
      size = total;
    }
  else
    motif = NULL;

  dfacomp (pattern, size, &dfa, 1);
  kwsmusts ();

  free(motif);
}

size_t
EGexecute (char const *buf, size_t size, size_t *match_size,
	   char const *start_ptr)
{
  char const *buflim, *beg, *end, *match, *best_match, *mb_start;
  char eol = eolbyte;
  int backref, start, len, best_len;
  struct kwsmatch kwsm;
  size_t i, ret_val;
#ifdef MBS_SUPPORT
  if (MB_CUR_MAX > 1)
    {
      if (match_icase)
        {
          /* mbtolower adds a NUL byte at the end.  That will provide
	     space for the sentinel byte dfaexec may add.  */
          char *case_buf = mbtolower (buf, &size);
	  if (start_ptr)
	    start_ptr = case_buf + (start_ptr - buf);
          buf = case_buf;
        }
    }
#endif /* MBS_SUPPORT */

  mb_start = buf;
  buflim = buf + size;

  for (beg = end = buf; end < buflim; beg = end)
    {
      if (!start_ptr)
	{
	  /* We don't care about an exact match.  */
	  if (kwset)
	    {
	      /* Find a possible match using the KWset matcher. */
	      size_t offset = kwsexec (kwset, beg, buflim - beg, &kwsm);
	      if (offset == (size_t) -1)
		goto failure;
	      beg += offset;
	      /* Narrow down to the line containing the candidate, and
		 run it through DFA. */
	      if ((end = memchr(beg, eol, buflim - beg)) != NULL)
	        end++;
              else
                end = buflim;
	      match = beg;
	      while (beg > buf && beg[-1] != eol)
		--beg;
	      if (kwsm.index < kwset_exact_matches)
                {
#ifdef MBS_SUPPORT
                  if (mb_start < beg)
                    mb_start = beg;
                  if (MB_CUR_MAX == 1 || !is_mb_middle (&mb_start, match, buflim))
#endif
                    goto success;
                }
	      if (dfaexec (&dfa, beg, (char *) end, 0, NULL, &backref) == NULL)
		continue;
	    }
	  else
	    {
	      /* No good fixed strings; start with DFA. */
	      char const *next_beg = dfaexec (&dfa, beg, (char *) buflim,
					      0, NULL, &backref);
	      if (next_beg == NULL)
		break;
	      /* Narrow down to the line we've found. */
	      beg = next_beg;
	      if ((end = memchr(beg, eol, buflim - beg)) != NULL)
	        end++;
              else
                end = buflim;
	      while (beg > buf && beg[-1] != eol)
		--beg;
	    }
	  /* Successful, no backreferences encountered! */
	  if (!backref)
	    goto success;
	}
      else
	{
	  /* We are looking for the leftmost (then longest) exact match.
	     We will go through the outer loop only once.  */
	  beg = start_ptr;
	  end = buflim;
	}

      /* If we've made it to this point, this means DFA has seen
	 a probable match, and we need to run it through Regex. */
      best_match = end;
      best_len = 0;
      for (i = 0; i < pcount; i++)
	{
	  patterns[i].regexbuf.not_eol = 0;
	  if (0 <= (start = re_search (&(patterns[i].regexbuf),
				       buf, end - buf - 1,
				       beg - buf, end - beg - 1,
				       &(patterns[i].regs))))
	    {
	      len = patterns[i].regs.end[0] - start;
	      match = buf + start;
	      if (match > best_match)
		continue;
	      if (start_ptr && !match_words)
		goto assess_pattern_match;
	      if ((!match_lines && !match_words)
		  || (match_lines && len == end - beg - 1))
		{
		  match = beg;
		  len = end - beg;
		  goto assess_pattern_match;
		}
	      /* If -w, check if the match aligns with word boundaries.
		 We do this iteratively because:
		 (a) the line may contain more than one occurence of the
		 pattern, and
		 (b) Several alternatives in the pattern might be valid at a
		 given point, and we may need to consider a shorter one to
		 find a word boundary.  */
	      if (match_words)
		while (match <= best_match)
		  {
		    if ((match == buf || !WCHAR ((unsigned char) match[-1]))
			&& (len == end - beg - 1
			    || !WCHAR ((unsigned char) match[len])))
		      goto assess_pattern_match;
		    if (len > 0)
		      {
			/* Try a shorter length anchored at the same place. */
			--len;
			patterns[i].regexbuf.not_eol = 1;
			len = re_match (&(patterns[i].regexbuf),
					buf, match + len - beg, match - buf,
					&(patterns[i].regs));
		      }
		    if (len <= 0)
		      {
			/* Try looking further on. */
			if (match == end - 1)
			  break;
			match++;
			patterns[i].regexbuf.not_eol = 0;
			start = re_search (&(patterns[i].regexbuf),
					   buf, end - buf - 1,
					   match - buf, end - match - 1,
					   &(patterns[i].regs));
			if (start < 0)
			  break;
			len = patterns[i].regs.end[0] - start;
			match = buf + start;
		      }
		  } /* while (match <= best_match) */
	      continue;
	    assess_pattern_match:
	      if (!start_ptr)
		{
		  /* Good enough for a non-exact match.
		     No need to look at further patterns, if any.  */
		  beg = match;
		  goto success_in_len;
		}
	      if (match < best_match || (match == best_match && len > best_len))
		{
		  /* Best exact match:  leftmost, then longest.  */
		  best_match = match;
		  best_len = len;
		}
	    } /* if re_search >= 0 */
	} /* for Regex patterns.  */
	if (best_match < end)
	  {
	    /* We have found an exact match.  We were just
	       waiting for the best one (leftmost then longest).  */
	    beg = best_match;
	    len = best_len;
	    goto success_in_len;
	  }
    } /* for (beg = end ..) */

 failure:
  ret_val = -1;
  goto out;

 success:
  len = end - beg;
 success_in_len:
  *match_size = len;
  ret_val = beg - buf;
 out:
  return ret_val;
}

Building:src at:
/home/ubuntu/spr-fast/tests/corebench/grep/grep-case-8a025cf8-8f08d8e2/tempworkdir-l/srcMerged code building succ, going to invoke tester!
CondTester, Testing instance id 32:
//src_file:src/dfasearch.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); void* memset(void*, int, unsigned long); 
/* dfasearch.c - searching subroutines using dfa and regex for grep.
   Copyright 1992, 1998, 2000, 2007, 2009-2010 Free Software Foundation, Inc.

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 3, or (at your option)
   any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program; if not, write to the Free Software
   Foundation, Inc., 51 Franklin Street - Fifth Floor, Boston, MA
   02110-1301, USA.  */

/* Written August 1992 by Mike Haertel. */

#include <config.h>
#include "search.h"
#include "dfa.h"

/* For -w, we also consider _ to be word constituent.  */
#define WCHAR(C) (ISALNUM(C) || (C) == '_')

/* KWset compiled pattern.  For Ecompile and Gcompile, we compile
   a list of strings, at least one of which is known to occur in
   any string matching the regexp. */
static kwset_t kwset;

/* DFA compiled regexp. */
static struct dfa dfa;

/* The Regex compiled patterns.  */
static struct patterns
{
  /* Regex compiled regexp. */
  struct re_pattern_buffer regexbuf;
  struct re_registers regs; /* This is here on account of a BRAIN-DEAD
			       Q@#%!# library interface in regex.c.  */
} patterns0;

struct patterns *patterns;
size_t pcount;

void
dfaerror (char const *mesg)
{
  error (EXIT_TROUBLE, 0, "%s", mesg);

  /* notreached */
  /* Tell static analyzers that this function does not return.  */
  abort ();
}

/* Number of compiled fixed strings known to exactly match the regexp.
   If kwsexec returns < kwset_exact_matches, then we don't need to
   call the regexp matcher at all. */
static int kwset_exact_matches;

static char const *
kwsincr_case (const char *must)
{
  const char *buf;
  size_t n;

  n = strlen (must);
#ifdef MBS_SUPPORT
  if (match_icase && MB_CUR_MAX > 1)
    buf = mbtolower (must, &n);
  else
#endif
    buf = must;
  return kwsincr (kwset, buf, n);
}

/* If the DFA turns out to have some set of fixed strings one of
   which must occur in the match, then we build a kwset matcher
   to find those strings, and thus quickly filter out impossible
   matches. */
static void
kwsmusts (void)
{
  struct dfamust const *dm;
  char const *err;

  if (dfa.musts)
    {
      kwsinit (&kwset);
      /* First, we compile in the substrings known to be exact
	 matches.  The kwset matcher will return the index
	 of the matching string that it chooses. */
      for (dm = dfa.musts; dm; dm = dm->next)
	{
	  if (!dm->exact)
	    continue;
	  ++kwset_exact_matches;
	  if ((err = kwsincr_case (dm->must)) != NULL)
	    error (EXIT_TROUBLE, 0, "%s", err);
	}
      /* Now, we compile the substrings that will require
	 the use of the regexp matcher.  */
      for (dm = dfa.musts; dm; dm = dm->next)
	{
	  if (dm->exact)
	    continue;
	  if ((err = kwsincr_case (dm->must)) != NULL)
	    error (EXIT_TROUBLE, 0, "%s", err);
	}
      if ((err = kwsprep (kwset)) != NULL)
	error (EXIT_TROUBLE, 0, "%s", err);
    }
}

void
GEAcompile (char const *pattern, size_t size, reg_syntax_t syntax_bits)
{
  const char *err;
  const char *p, *sep;
  size_t total = size;
  char *motif;

  if (match_icase)
    syntax_bits |= RE_ICASE;
  re_set_syntax (syntax_bits);
  dfasyntax (syntax_bits, match_icase, eolbyte);

  /* For GNU regex compiler we have to pass the patterns separately to detect
     errors like "[\nallo\n]\n".  The patterns here are "[", "allo" and "]"
     GNU regex should have raise a syntax error.  The same for backref, where
     the backref should have been local to each pattern.  */
  p = pattern;
  do
    {
      size_t len;
      sep = memchr (p, '\n', total);
      
//Patch 0:
if ((sep) && !(__is_neg(15, &(sep), sizeof (sep), &(p), sizeof (p), &(total), sizeof (total), &(len), sizeof (len), &(pattern), sizeof (pattern), &(syntax_bits), sizeof (syntax_bits), &(match_icase), sizeof (match_icase), &(eolbyte), sizeof (eolbyte), &(patterns), sizeof (patterns), &(pcount), sizeof (pcount), &(size), sizeof (size), &(err), sizeof (err), &(match_words), sizeof (match_words), &(match_lines), sizeof (match_lines), &(motif), sizeof (motif)))) {
    len = sep - p;
    sep++;
    total -= (len + 1);
} else {
    len = total;
    total = 0;
}

//CodeSeg 1:

      patterns = realloc (patterns, (pcount + 1) * sizeof (*patterns));
      if (patterns == NULL)
	error (EXIT_TROUBLE, errno, _("memory exhausted"));
      patterns[pcount] = patterns0;

      if ((err = re_compile_pattern (p, len,
				    &(patterns[pcount].regexbuf))) != NULL)
	error (EXIT_TROUBLE, 0, "%s", err);
      pcount++;

      p = sep;
    } while (sep && total != 0);

  /* In the match_words and match_lines cases, we use a different pattern
     for the DFA matcher that will quickly throw out cases that won't work.
     Then if DFA succeeds we do some hairy stuff using the regex matcher
     to decide whether the match should really count. */
  if (match_words || match_lines)
    {
      static char const line_beg_no_bk[] = "^(";
      static char const line_end_no_bk[] = ")$";
      static char const word_beg_no_bk[] = "(^|[^[:alnum:]_])(";
      static char const word_end_no_bk[] = ")([^[:alnum:]_]|$)";
      static char const line_beg_bk[] = "^\\(";
      static char const line_end_bk[] = "\\)$";
      static char const word_beg_bk[] = "\\(^\\|[^[:alnum:]_]\\)\\(";
      static char const word_end_bk[] = "\\)\\([^[:alnum:]_]\\|$\\)";
      int bk = !(syntax_bits & RE_NO_BK_PARENS);
      char *n = xmalloc (sizeof word_beg_bk - 1 + size + sizeof word_end_bk);

      strcpy (n, match_lines ? (bk ? line_beg_bk : line_beg_no_bk)
			     : (bk ? word_beg_bk : word_beg_no_bk));
      total = strlen(n);
      memcpy (n + total, pattern, size);
      total += size;
      strcpy (n + total, match_lines ? (bk ? line_end_bk : line_end_no_bk)
				     : (bk ? word_end_bk : word_end_no_bk));
      total += strlen (n + total);
      pattern = motif = n;
      size = total;
    }
  else
    motif = NULL;

  dfacomp (pattern, size, &dfa, 1);
  kwsmusts ();

  free(motif);
}

size_t
EGexecute (char const *buf, size_t size, size_t *match_size,
	   char const *start_ptr)
{
  char const *buflim, *beg, *end, *match, *best_match, *mb_start;
  char eol = eolbyte;
  int backref, start, len, best_len;
  struct kwsmatch kwsm;
  size_t i, ret_val;
#ifdef MBS_SUPPORT
  if (MB_CUR_MAX > 1)
    {
      if (match_icase)
        {
          /* mbtolower adds a NUL byte at the end.  That will provide
	     space for the sentinel byte dfaexec may add.  */
          char *case_buf = mbtolower (buf, &size);
	  if (start_ptr)
	    start_ptr = case_buf + (start_ptr - buf);
          buf = case_buf;
        }
    }
#endif /* MBS_SUPPORT */

  mb_start = buf;
  buflim = buf + size;

  for (beg = end = buf; end < buflim; beg = end)
    {
      if (!start_ptr)
	{
	  /* We don't care about an exact match.  */
	  if (kwset)
	    {
	      /* Find a possible match using the KWset matcher. */
	      size_t offset = kwsexec (kwset, beg, buflim - beg, &kwsm);
	      if (offset == (size_t) -1)
		goto failure;
	      beg += offset;
	      /* Narrow down to the line containing the candidate, and
		 run it through DFA. */
	      if ((end = memchr(beg, eol, buflim - beg)) != NULL)
	        end++;
              else
                end = buflim;
	      match = beg;
	      while (beg > buf && beg[-1] != eol)
		--beg;
	      if (kwsm.index < kwset_exact_matches)
                {
#ifdef MBS_SUPPORT
                  if (mb_start < beg)
                    mb_start = beg;
                  if (MB_CUR_MAX == 1 || !is_mb_middle (&mb_start, match, buflim))
#endif
                    goto success;
                }
	      if (dfaexec (&dfa, beg, (char *) end, 0, NULL, &backref) == NULL)
		continue;
	    }
	  else
	    {
	      /* No good fixed strings; start with DFA. */
	      char const *next_beg = dfaexec (&dfa, beg, (char *) buflim,
					      0, NULL, &backref);
	      if (next_beg == NULL)
		break;
	      /* Narrow down to the line we've found. */
	      beg = next_beg;
	      if ((end = memchr(beg, eol, buflim - beg)) != NULL)
	        end++;
              else
                end = buflim;
	      while (beg > buf && beg[-1] != eol)
		--beg;
	    }
	  /* Successful, no backreferences encountered! */
	  if (!backref)
	    goto success;
	}
      else
	{
	  /* We are looking for the leftmost (then longest) exact match.
	     We will go through the outer loop only once.  */
	  beg = start_ptr;
	  end = buflim;
	}

      /* If we've made it to this point, this means DFA has seen
	 a probable match, and we need to run it through Regex. */
      best_match = end;
      best_len = 0;
      for (i = 0; i < pcount; i++)
	{
	  patterns[i].regexbuf.not_eol = 0;
	  if (0 <= (start = re_search (&(patterns[i].regexbuf),
				       buf, end - buf - 1,
				       beg - buf, end - beg - 1,
				       &(patterns[i].regs))))
	    {
	      len = patterns[i].regs.end[0] - start;
	      match = buf + start;
	      if (match > best_match)
		continue;
	      if (start_ptr && !match_words)
		goto assess_pattern_match;
	      if ((!match_lines && !match_words)
		  || (match_lines && len == end - beg - 1))
		{
		  match = beg;
		  len = end - beg;
		  goto assess_pattern_match;
		}
	      /* If -w, check if the match aligns with word boundaries.
		 We do this iteratively because:
		 (a) the line may contain more than one occurence of the
		 pattern, and
		 (b) Several alternatives in the pattern might be valid at a
		 given point, and we may need to consider a shorter one to
		 find a word boundary.  */
	      if (match_words)
		while (match <= best_match)
		  {
		    if ((match == buf || !WCHAR ((unsigned char) match[-1]))
			&& (len == end - beg - 1
			    || !WCHAR ((unsigned char) match[len])))
		      goto assess_pattern_match;
		    if (len > 0)
		      {
			/* Try a shorter length anchored at the same place. */
			--len;
			patterns[i].regexbuf.not_eol = 1;
			len = re_match (&(patterns[i].regexbuf),
					buf, match + len - beg, match - buf,
					&(patterns[i].regs));
		      }
		    if (len <= 0)
		      {
			/* Try looking further on. */
			if (match == end - 1)
			  break;
			match++;
			patterns[i].regexbuf.not_eol = 0;
			start = re_search (&(patterns[i].regexbuf),
					   buf, end - buf - 1,
					   match - buf, end - match - 1,
					   &(patterns[i].regs));
			if (start < 0)
			  break;
			len = patterns[i].regs.end[0] - start;
			match = buf + start;
		      }
		  } /* while (match <= best_match) */
	      continue;
	    assess_pattern_match:
	      if (!start_ptr)
		{
		  /* Good enough for a non-exact match.
		     No need to look at further patterns, if any.  */
		  beg = match;
		  goto success_in_len;
		}
	      if (match < best_match || (match == best_match && len > best_len))
		{
		  /* Best exact match:  leftmost, then longest.  */
		  best_match = match;
		  best_len = len;
		}
	    } /* if re_search >= 0 */
	} /* for Regex patterns.  */
	if (best_match < end)
	  {
	    /* We have found an exact match.  We were just
	       waiting for the best one (leftmost then longest).  */
	    beg = best_match;
	    len = best_len;
	    goto success_in_len;
	  }
    } /* for (beg = end ..) */

 failure:
  ret_val = -1;
  goto out;

 success:
  len = end - beg;
 success_in_len:
  *match_size = len;
  ret_val = beg - buf;
 out:
  return ret_val;
}

Testing negative cases!
Testing 0 (with abstract condition) ENVIS_NEG
Iteration 0
Running test command:
/home/ubuntu/spr-fast/tools/grep-test.py /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-8a025cf8-8f08d8e2/tempworkdir-l/src /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-8a025cf8-8f08d8e2/tempworkdir-l/tests /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-8a025cf8-8f08d8e2/tempworkdir-l 0  > __res
Opening:/tmp/neg.tmp!
NegativeBRANCH RECORD/tmp/neg.tmp!
Not caught by the negative case, give up!
APPENDING TO ISNEG:/tmp/neg.tmp!
Running test command:
/home/ubuntu/spr-fast/tools/grep-test.py /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-8a025cf8-8f08d8e2/tempworkdir-l/src /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-8a025cf8-8f08d8e2/tempworkdir-l/tests /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-8a025cf8-8f08d8e2/tempworkdir-l 0  > __res
CondTester, Testing instance id 33:
//src_file:src/dfasearch.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); void* memset(void*, int, unsigned long); 
/* dfasearch.c - searching subroutines using dfa and regex for grep.
   Copyright 1992, 1998, 2000, 2007, 2009-2010 Free Software Foundation, Inc.

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 3, or (at your option)
   any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program; if not, write to the Free Software
   Foundation, Inc., 51 Franklin Street - Fifth Floor, Boston, MA
   02110-1301, USA.  */

/* Written August 1992 by Mike Haertel. */

#include <config.h>
#include "search.h"
#include "dfa.h"

/* For -w, we also consider _ to be word constituent.  */
#define WCHAR(C) (ISALNUM(C) || (C) == '_')

/* KWset compiled pattern.  For Ecompile and Gcompile, we compile
   a list of strings, at least one of which is known to occur in
   any string matching the regexp. */
static kwset_t kwset;

/* DFA compiled regexp. */
static struct dfa dfa;

/* The Regex compiled patterns.  */
static struct patterns
{
  /* Regex compiled regexp. */
  struct re_pattern_buffer regexbuf;
  struct re_registers regs; /* This is here on account of a BRAIN-DEAD
			       Q@#%!# library interface in regex.c.  */
} patterns0;

struct patterns *patterns;
size_t pcount;

void
dfaerror (char const *mesg)
{
  error (EXIT_TROUBLE, 0, "%s", mesg);

  /* notreached */
  /* Tell static analyzers that this function does not return.  */
  abort ();
}

/* Number of compiled fixed strings known to exactly match the regexp.
   If kwsexec returns < kwset_exact_matches, then we don't need to
   call the regexp matcher at all. */
static int kwset_exact_matches;

static char const *
kwsincr_case (const char *must)
{
  const char *buf;
  size_t n;

  n = strlen (must);
#ifdef MBS_SUPPORT
  if (match_icase && MB_CUR_MAX > 1)
    buf = mbtolower (must, &n);
  else
#endif
    buf = must;
  return kwsincr (kwset, buf, n);
}

/* If the DFA turns out to have some set of fixed strings one of
   which must occur in the match, then we build a kwset matcher
   to find those strings, and thus quickly filter out impossible
   matches. */
static void
kwsmusts (void)
{
  struct dfamust const *dm;
  char const *err;

  if (dfa.musts)
    {
      kwsinit (&kwset);
      /* First, we compile in the substrings known to be exact
	 matches.  The kwset matcher will return the index
	 of the matching string that it chooses. */
      for (dm = dfa.musts; dm; dm = dm->next)
	{
	  if (!dm->exact)
	    continue;
	  ++kwset_exact_matches;
	  if ((err = kwsincr_case (dm->must)) != NULL)
	    error (EXIT_TROUBLE, 0, "%s", err);
	}
      /* Now, we compile the substrings that will require
	 the use of the regexp matcher.  */
      for (dm = dfa.musts; dm; dm = dm->next)
	{
	  if (dm->exact)
	    continue;
	  if ((err = kwsincr_case (dm->must)) != NULL)
	    error (EXIT_TROUBLE, 0, "%s", err);
	}
      if ((err = kwsprep (kwset)) != NULL)
	error (EXIT_TROUBLE, 0, "%s", err);
    }
}

void
GEAcompile (char const *pattern, size_t size, reg_syntax_t syntax_bits)
{
  const char *err;
  const char *p, *sep;
  size_t total = size;
  char *motif;

  if (match_icase)
    syntax_bits |= RE_ICASE;
  re_set_syntax (syntax_bits);
  dfasyntax (syntax_bits, match_icase, eolbyte);

  /* For GNU regex compiler we have to pass the patterns separately to detect
     errors like "[\nallo\n]\n".  The patterns here are "[", "allo" and "]"
     GNU regex should have raise a syntax error.  The same for backref, where
     the backref should have been local to each pattern.  */
  p = pattern;
  do
    {
      size_t len;
      sep = memchr (p, '\n', total);
      
//Patch 0:
if ((sep) || (__is_neg(15, &(sep), sizeof (sep), &(p), sizeof (p), &(total), sizeof (total), &(len), sizeof (len), &(pattern), sizeof (pattern), &(syntax_bits), sizeof (syntax_bits), &(match_icase), sizeof (match_icase), &(eolbyte), sizeof (eolbyte), &(patterns), sizeof (patterns), &(pcount), sizeof (pcount), &(size), sizeof (size), &(err), sizeof (err), &(match_words), sizeof (match_words), &(match_lines), sizeof (match_lines), &(motif), sizeof (motif)))) {
    len = sep - p;
    sep++;
    total -= (len + 1);
} else {
    len = total;
    total = 0;
}

//CodeSeg 1:

      patterns = realloc (patterns, (pcount + 1) * sizeof (*patterns));
      if (patterns == NULL)
	error (EXIT_TROUBLE, errno, _("memory exhausted"));
      patterns[pcount] = patterns0;

      if ((err = re_compile_pattern (p, len,
				    &(patterns[pcount].regexbuf))) != NULL)
	error (EXIT_TROUBLE, 0, "%s", err);
      pcount++;

      p = sep;
    } while (sep && total != 0);

  /* In the match_words and match_lines cases, we use a different pattern
     for the DFA matcher that will quickly throw out cases that won't work.
     Then if DFA succeeds we do some hairy stuff using the regex matcher
     to decide whether the match should really count. */
  if (match_words || match_lines)
    {
      static char const line_beg_no_bk[] = "^(";
      static char const line_end_no_bk[] = ")$";
      static char const word_beg_no_bk[] = "(^|[^[:alnum:]_])(";
      static char const word_end_no_bk[] = ")([^[:alnum:]_]|$)";
      static char const line_beg_bk[] = "^\\(";
      static char const line_end_bk[] = "\\)$";
      static char const word_beg_bk[] = "\\(^\\|[^[:alnum:]_]\\)\\(";
      static char const word_end_bk[] = "\\)\\([^[:alnum:]_]\\|$\\)";
      int bk = !(syntax_bits & RE_NO_BK_PARENS);
      char *n = xmalloc (sizeof word_beg_bk - 1 + size + sizeof word_end_bk);

      strcpy (n, match_lines ? (bk ? line_beg_bk : line_beg_no_bk)
			     : (bk ? word_beg_bk : word_beg_no_bk));
      total = strlen(n);
      memcpy (n + total, pattern, size);
      total += size;
      strcpy (n + total, match_lines ? (bk ? line_end_bk : line_end_no_bk)
				     : (bk ? word_end_bk : word_end_no_bk));
      total += strlen (n + total);
      pattern = motif = n;
      size = total;
    }
  else
    motif = NULL;

  dfacomp (pattern, size, &dfa, 1);
  kwsmusts ();

  free(motif);
}

size_t
EGexecute (char const *buf, size_t size, size_t *match_size,
	   char const *start_ptr)
{
  char const *buflim, *beg, *end, *match, *best_match, *mb_start;
  char eol = eolbyte;
  int backref, start, len, best_len;
  struct kwsmatch kwsm;
  size_t i, ret_val;
#ifdef MBS_SUPPORT
  if (MB_CUR_MAX > 1)
    {
      if (match_icase)
        {
          /* mbtolower adds a NUL byte at the end.  That will provide
	     space for the sentinel byte dfaexec may add.  */
          char *case_buf = mbtolower (buf, &size);
	  if (start_ptr)
	    start_ptr = case_buf + (start_ptr - buf);
          buf = case_buf;
        }
    }
#endif /* MBS_SUPPORT */

  mb_start = buf;
  buflim = buf + size;

  for (beg = end = buf; end < buflim; beg = end)
    {
      if (!start_ptr)
	{
	  /* We don't care about an exact match.  */
	  if (kwset)
	    {
	      /* Find a possible match using the KWset matcher. */
	      size_t offset = kwsexec (kwset, beg, buflim - beg, &kwsm);
	      if (offset == (size_t) -1)
		goto failure;
	      beg += offset;
	      /* Narrow down to the line containing the candidate, and
		 run it through DFA. */
	      if ((end = memchr(beg, eol, buflim - beg)) != NULL)
	        end++;
              else
                end = buflim;
	      match = beg;
	      while (beg > buf && beg[-1] != eol)
		--beg;
	      if (kwsm.index < kwset_exact_matches)
                {
#ifdef MBS_SUPPORT
                  if (mb_start < beg)
                    mb_start = beg;
                  if (MB_CUR_MAX == 1 || !is_mb_middle (&mb_start, match, buflim))
#endif
                    goto success;
                }
	      if (dfaexec (&dfa, beg, (char *) end, 0, NULL, &backref) == NULL)
		continue;
	    }
	  else
	    {
	      /* No good fixed strings; start with DFA. */
	      char const *next_beg = dfaexec (&dfa, beg, (char *) buflim,
					      0, NULL, &backref);
	      if (next_beg == NULL)
		break;
	      /* Narrow down to the line we've found. */
	      beg = next_beg;
	      if ((end = memchr(beg, eol, buflim - beg)) != NULL)
	        end++;
              else
                end = buflim;
	      while (beg > buf && beg[-1] != eol)
		--beg;
	    }
	  /* Successful, no backreferences encountered! */
	  if (!backref)
	    goto success;
	}
      else
	{
	  /* We are looking for the leftmost (then longest) exact match.
	     We will go through the outer loop only once.  */
	  beg = start_ptr;
	  end = buflim;
	}

      /* If we've made it to this point, this means DFA has seen
	 a probable match, and we need to run it through Regex. */
      best_match = end;
      best_len = 0;
      for (i = 0; i < pcount; i++)
	{
	  patterns[i].regexbuf.not_eol = 0;
	  if (0 <= (start = re_search (&(patterns[i].regexbuf),
				       buf, end - buf - 1,
				       beg - buf, end - beg - 1,
				       &(patterns[i].regs))))
	    {
	      len = patterns[i].regs.end[0] - start;
	      match = buf + start;
	      if (match > best_match)
		continue;
	      if (start_ptr && !match_words)
		goto assess_pattern_match;
	      if ((!match_lines && !match_words)
		  || (match_lines && len == end - beg - 1))
		{
		  match = beg;
		  len = end - beg;
		  goto assess_pattern_match;
		}
	      /* If -w, check if the match aligns with word boundaries.
		 We do this iteratively because:
		 (a) the line may contain more than one occurence of the
		 pattern, and
		 (b) Several alternatives in the pattern might be valid at a
		 given point, and we may need to consider a shorter one to
		 find a word boundary.  */
	      if (match_words)
		while (match <= best_match)
		  {
		    if ((match == buf || !WCHAR ((unsigned char) match[-1]))
			&& (len == end - beg - 1
			    || !WCHAR ((unsigned char) match[len])))
		      goto assess_pattern_match;
		    if (len > 0)
		      {
			/* Try a shorter length anchored at the same place. */
			--len;
			patterns[i].regexbuf.not_eol = 1;
			len = re_match (&(patterns[i].regexbuf),
					buf, match + len - beg, match - buf,
					&(patterns[i].regs));
		      }
		    if (len <= 0)
		      {
			/* Try looking further on. */
			if (match == end - 1)
			  break;
			match++;
			patterns[i].regexbuf.not_eol = 0;
			start = re_search (&(patterns[i].regexbuf),
					   buf, end - buf - 1,
					   match - buf, end - match - 1,
					   &(patterns[i].regs));
			if (start < 0)
			  break;
			len = patterns[i].regs.end[0] - start;
			match = buf + start;
		      }
		  } /* while (match <= best_match) */
	      continue;
	    assess_pattern_match:
	      if (!start_ptr)
		{
		  /* Good enough for a non-exact match.
		     No need to look at further patterns, if any.  */
		  beg = match;
		  goto success_in_len;
		}
	      if (match < best_match || (match == best_match && len > best_len))
		{
		  /* Best exact match:  leftmost, then longest.  */
		  best_match = match;
		  best_len = len;
		}
	    } /* if re_search >= 0 */
	} /* for Regex patterns.  */
	if (best_match < end)
	  {
	    /* We have found an exact match.  We were just
	       waiting for the best one (leftmost then longest).  */
	    beg = best_match;
	    len = best_len;
	    goto success_in_len;
	  }
    } /* for (beg = end ..) */

 failure:
  ret_val = -1;
  goto out;

 success:
  len = end - beg;
 success_in_len:
  *match_size = len;
  ret_val = beg - buf;
 out:
  return ret_val;
}

Testing negative cases!
Testing 0 (with abstract condition) ENVIS_NEG
Iteration 0
Running test command:
/home/ubuntu/spr-fast/tools/grep-test.py /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-8a025cf8-8f08d8e2/tempworkdir-l/src /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-8a025cf8-8f08d8e2/tempworkdir-l/tests /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-8a025cf8-8f08d8e2/tempworkdir-l 0  > __res
Opening:/tmp/neg.tmp!
NegativeBRANCH RECORD/tmp/neg.tmp!
APPENDING TO ISNEG:/tmp/neg.tmp!
Branch 0: 0
Iteration 1
Running test command:
/home/ubuntu/spr-fast/tools/grep-test.py /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-8a025cf8-8f08d8e2/tempworkdir-l/src /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-8a025cf8-8f08d8e2/tempworkdir-l/tests /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-8a025cf8-8f08d8e2/tempworkdir-l 0  > __res
Opening:/tmp/neg.tmp!
NegativeBRANCH RECORD/tmp/neg.tmp!
APPENDING TO ISNEG:/tmp/neg.tmp!
Branch 0: 1
Running test command:
/home/ubuntu/spr-fast/tools/grep-test.py /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-8a025cf8-8f08d8e2/tempworkdir-l/src /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-8a025cf8-8f08d8e2/tempworkdir-l/tests /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-8a025cf8-8f08d8e2/tempworkdir-l 0  > __res
a batched test job starts!
Building merged code:
src_file: src/dfasearch.c
full src: int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); void* memset(void*, int, unsigned long); 
/* dfasearch.c - searching subroutines using dfa and regex for grep.
   Copyright 1992, 1998, 2000, 2007, 2009-2010 Free Software Foundation, Inc.

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 3, or (at your option)
   any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program; if not, write to the Free Software
   Foundation, Inc., 51 Franklin Street - Fifth Floor, Boston, MA
   02110-1301, USA.  */

/* Written August 1992 by Mike Haertel. */

#include <config.h>
#include "search.h"
#include "dfa.h"

/* For -w, we also consider _ to be word constituent.  */
#define WCHAR(C) (ISALNUM(C) || (C) == '_')

/* KWset compiled pattern.  For Ecompile and Gcompile, we compile
   a list of strings, at least one of which is known to occur in
   any string matching the regexp. */
static kwset_t kwset;

/* DFA compiled regexp. */
static struct dfa dfa;

/* The Regex compiled patterns.  */
static struct patterns
{
  /* Regex compiled regexp. */
  struct re_pattern_buffer regexbuf;
  struct re_registers regs; /* This is here on account of a BRAIN-DEAD
			       Q@#%!# library interface in regex.c.  */
} patterns0;

struct patterns *patterns;
size_t pcount;

void
dfaerror (char const *mesg)
{
  error (EXIT_TROUBLE, 0, "%s", mesg);

  /* notreached */
  /* Tell static analyzers that this function does not return.  */
  abort ();
}

/* Number of compiled fixed strings known to exactly match the regexp.
   If kwsexec returns < kwset_exact_matches, then we don't need to
   call the regexp matcher at all. */
static int kwset_exact_matches;

static char const *
kwsincr_case (const char *must)
{
  const char *buf;
  size_t n;

  n = strlen (must);
#ifdef MBS_SUPPORT
  if (match_icase && MB_CUR_MAX > 1)
    buf = mbtolower (must, &n);
  else
#endif
    buf = must;
  return kwsincr (kwset, buf, n);
}

/* If the DFA turns out to have some set of fixed strings one of
   which must occur in the match, then we build a kwset matcher
   to find those strings, and thus quickly filter out impossible
   matches. */
static void
kwsmusts (void)
{
  struct dfamust const *dm;
  char const *err;

  if (dfa.musts)
    {
      kwsinit (&kwset);
      /* First, we compile in the substrings known to be exact
	 matches.  The kwset matcher will return the index
	 of the matching string that it chooses. */
      for (dm = dfa.musts; dm; dm = dm->next)
	{
	  if (!dm->exact)
	    continue;
	  ++kwset_exact_matches;
	  if ((err = kwsincr_case (dm->must)) != NULL)
	    error (EXIT_TROUBLE, 0, "%s", err);
	}
      /* Now, we compile the substrings that will require
	 the use of the regexp matcher.  */
      for (dm = dfa.musts; dm; dm = dm->next)
	{
	  if (dm->exact)
	    continue;
	  if ((err = kwsincr_case (dm->must)) != NULL)
	    error (EXIT_TROUBLE, 0, "%s", err);
	}
      if ((err = kwsprep (kwset)) != NULL)
	error (EXIT_TROUBLE, 0, "%s", err);
    }
}

void
GEAcompile (char const *pattern, size_t size, reg_syntax_t syntax_bits)
{
  const char *err;
  const char *p, *sep;
  size_t total = size;
  char *motif;

  if (match_icase)
    syntax_bits |= RE_ICASE;
  re_set_syntax (syntax_bits);
  dfasyntax (syntax_bits, match_icase, eolbyte);

  /* For GNU regex compiler we have to pass the patterns separately to detect
     errors like "[\nallo\n]\n".  The patterns here are "[", "allo" and "]"
     GNU regex should have raise a syntax error.  The same for backref, where
     the backref should have been local to each pattern.  */
  p = pattern;
  do
    {
      size_t len;
      sep = memchr (p, '\n', total);
      if (sep)
	{
	  len = sep - p;
	  sep++;
	  total -= (len + 1);
	}
      else
	{
	  len = total;
	  total = 0;
	}

      patterns = realloc (patterns, (pcount + 1) * sizeof (*patterns));
      //prophet generated patch
      if (__get_mutant()==0) {
      if ((patterns == ((void *)0)) && !(__is_neg(15, &(patterns), sizeof (patterns), &(pcount), sizeof (pcount), &(err), sizeof (err), &(p), sizeof (p), &(total), sizeof (total), &(len), sizeof (len), &(sep), sizeof (sep), &(match_words), sizeof (match_words), &(match_lines), sizeof (match_lines), &(pattern), sizeof (pattern), &(syntax_bits), sizeof (syntax_bits), &(match_icase), sizeof (match_icase), &(eolbyte), sizeof (eolbyte), &(size), sizeof (size), &(motif), sizeof (motif))))
          error(EXIT_TROUBLE, (*__errno_location()), dcgettext(((void *)0), "memory exhausted", 5));
      }
      else if (__get_mutant()==1) {
      if ((patterns == ((void *)0)) || (__is_neg(15, &(patterns), sizeof (patterns), &(pcount), sizeof (pcount), &(err), sizeof (err), &(p), sizeof (p), &(total), sizeof (total), &(len), sizeof (len), &(sep), sizeof (sep), &(match_words), sizeof (match_words), &(match_lines), sizeof (match_lines), &(pattern), sizeof (pattern), &(syntax_bits), sizeof (syntax_bits), &(match_icase), sizeof (match_icase), &(eolbyte), sizeof (eolbyte), &(size), sizeof (size), &(motif), sizeof (motif))))
          error(EXIT_TROUBLE, (*__errno_location()), dcgettext(((void *)0), "memory exhausted", 5));
      }
      patterns[pcount] = patterns0;

      if ((err = re_compile_pattern (p, len,
				    &(patterns[pcount].regexbuf))) != NULL)
	error (EXIT_TROUBLE, 0, "%s", err);
      pcount++;

      p = sep;
    } while (sep && total != 0);

  /* In the match_words and match_lines cases, we use a different pattern
     for the DFA matcher that will quickly throw out cases that won't work.
     Then if DFA succeeds we do some hairy stuff using the regex matcher
     to decide whether the match should really count. */
  if (match_words || match_lines)
    {
      static char const line_beg_no_bk[] = "^(";
      static char const line_end_no_bk[] = ")$";
      static char const word_beg_no_bk[] = "(^|[^[:alnum:]_])(";
      static char const word_end_no_bk[] = ")([^[:alnum:]_]|$)";
      static char const line_beg_bk[] = "^\\(";
      static char const line_end_bk[] = "\\)$";
      static char const word_beg_bk[] = "\\(^\\|[^[:alnum:]_]\\)\\(";
      static char const word_end_bk[] = "\\)\\([^[:alnum:]_]\\|$\\)";
      int bk = !(syntax_bits & RE_NO_BK_PARENS);
      char *n = xmalloc (sizeof word_beg_bk - 1 + size + sizeof word_end_bk);

      strcpy (n, match_lines ? (bk ? line_beg_bk : line_beg_no_bk)
			     : (bk ? word_beg_bk : word_beg_no_bk));
      total = strlen(n);
      memcpy (n + total, pattern, size);
      total += size;
      strcpy (n + total, match_lines ? (bk ? line_end_bk : line_end_no_bk)
				     : (bk ? word_end_bk : word_end_no_bk));
      total += strlen (n + total);
      pattern = motif = n;
      size = total;
    }
  else
    motif = NULL;

  dfacomp (pattern, size, &dfa, 1);
  kwsmusts ();

  free(motif);
}

size_t
EGexecute (char const *buf, size_t size, size_t *match_size,
	   char const *start_ptr)
{
  char const *buflim, *beg, *end, *match, *best_match, *mb_start;
  char eol = eolbyte;
  int backref, start, len, best_len;
  struct kwsmatch kwsm;
  size_t i, ret_val;
#ifdef MBS_SUPPORT
  if (MB_CUR_MAX > 1)
    {
      if (match_icase)
        {
          /* mbtolower adds a NUL byte at the end.  That will provide
	     space for the sentinel byte dfaexec may add.  */
          char *case_buf = mbtolower (buf, &size);
	  if (start_ptr)
	    start_ptr = case_buf + (start_ptr - buf);
          buf = case_buf;
        }
    }
#endif /* MBS_SUPPORT */

  mb_start = buf;
  buflim = buf + size;

  for (beg = end = buf; end < buflim; beg = end)
    {
      if (!start_ptr)
	{
	  /* We don't care about an exact match.  */
	  if (kwset)
	    {
	      /* Find a possible match using the KWset matcher. */
	      size_t offset = kwsexec (kwset, beg, buflim - beg, &kwsm);
	      if (offset == (size_t) -1)
		goto failure;
	      beg += offset;
	      /* Narrow down to the line containing the candidate, and
		 run it through DFA. */
	      if ((end = memchr(beg, eol, buflim - beg)) != NULL)
	        end++;
              else
                end = buflim;
	      match = beg;
	      while (beg > buf && beg[-1] != eol)
		--beg;
	      if (kwsm.index < kwset_exact_matches)
                {
#ifdef MBS_SUPPORT
                  if (mb_start < beg)
                    mb_start = beg;
                  if (MB_CUR_MAX == 1 || !is_mb_middle (&mb_start, match, buflim))
#endif
                    goto success;
                }
	      if (dfaexec (&dfa, beg, (char *) end, 0, NULL, &backref) == NULL)
		continue;
	    }
	  else
	    {
	      /* No good fixed strings; start with DFA. */
	      char const *next_beg = dfaexec (&dfa, beg, (char *) buflim,
					      0, NULL, &backref);
	      if (next_beg == NULL)
		break;
	      /* Narrow down to the line we've found. */
	      beg = next_beg;
	      if ((end = memchr(beg, eol, buflim - beg)) != NULL)
	        end++;
              else
                end = buflim;
	      while (beg > buf && beg[-1] != eol)
		--beg;
	    }
	  /* Successful, no backreferences encountered! */
	  if (!backref)
	    goto success;
	}
      else
	{
	  /* We are looking for the leftmost (then longest) exact match.
	     We will go through the outer loop only once.  */
	  beg = start_ptr;
	  end = buflim;
	}

      /* If we've made it to this point, this means DFA has seen
	 a probable match, and we need to run it through Regex. */
      best_match = end;
      best_len = 0;
      for (i = 0; i < pcount; i++)
	{
	  patterns[i].regexbuf.not_eol = 0;
	  if (0 <= (start = re_search (&(patterns[i].regexbuf),
				       buf, end - buf - 1,
				       beg - buf, end - beg - 1,
				       &(patterns[i].regs))))
	    {
	      len = patterns[i].regs.end[0] - start;
	      match = buf + start;
	      if (match > best_match)
		continue;
	      if (start_ptr && !match_words)
		goto assess_pattern_match;
	      if ((!match_lines && !match_words)
		  || (match_lines && len == end - beg - 1))
		{
		  match = beg;
		  len = end - beg;
		  goto assess_pattern_match;
		}
	      /* If -w, check if the match aligns with word boundaries.
		 We do this iteratively because:
		 (a) the line may contain more than one occurence of the
		 pattern, and
		 (b) Several alternatives in the pattern might be valid at a
		 given point, and we may need to consider a shorter one to
		 find a word boundary.  */
	      if (match_words)
		while (match <= best_match)
		  {
		    if ((match == buf || !WCHAR ((unsigned char) match[-1]))
			&& (len == end - beg - 1
			    || !WCHAR ((unsigned char) match[len])))
		      goto assess_pattern_match;
		    if (len > 0)
		      {
			/* Try a shorter length anchored at the same place. */
			--len;
			patterns[i].regexbuf.not_eol = 1;
			len = re_match (&(patterns[i].regexbuf),
					buf, match + len - beg, match - buf,
					&(patterns[i].regs));
		      }
		    if (len <= 0)
		      {
			/* Try looking further on. */
			if (match == end - 1)
			  break;
			match++;
			patterns[i].regexbuf.not_eol = 0;
			start = re_search (&(patterns[i].regexbuf),
					   buf, end - buf - 1,
					   match - buf, end - match - 1,
					   &(patterns[i].regs));
			if (start < 0)
			  break;
			len = patterns[i].regs.end[0] - start;
			match = buf + start;
		      }
		  } /* while (match <= best_match) */
	      continue;
	    assess_pattern_match:
	      if (!start_ptr)
		{
		  /* Good enough for a non-exact match.
		     No need to look at further patterns, if any.  */
		  beg = match;
		  goto success_in_len;
		}
	      if (match < best_match || (match == best_match && len > best_len))
		{
		  /* Best exact match:  leftmost, then longest.  */
		  best_match = match;
		  best_len = len;
		}
	    } /* if re_search >= 0 */
	} /* for Regex patterns.  */
	if (best_match < end)
	  {
	    /* We have found an exact match.  We were just
	       waiting for the best one (leftmost then longest).  */
	    beg = best_match;
	    len = best_len;
	    goto success_in_len;
	  }
    } /* for (beg = end ..) */

 failure:
  ret_val = -1;
  goto out;

 success:
  len = end - beg;
 success_in_len:
  *match_size = len;
  ret_val = beg - buf;
 out:
  return ret_val;
}

Building:src at:
/home/ubuntu/spr-fast/tests/corebench/grep/grep-case-8a025cf8-8f08d8e2/tempworkdir-l/srcMerged code building succ, going to invoke tester!
CondTester, Testing instance id 18:
//src_file:src/dfasearch.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); void* memset(void*, int, unsigned long); 
/* dfasearch.c - searching subroutines using dfa and regex for grep.
   Copyright 1992, 1998, 2000, 2007, 2009-2010 Free Software Foundation, Inc.

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 3, or (at your option)
   any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program; if not, write to the Free Software
   Foundation, Inc., 51 Franklin Street - Fifth Floor, Boston, MA
   02110-1301, USA.  */

/* Written August 1992 by Mike Haertel. */

#include <config.h>
#include "search.h"
#include "dfa.h"

/* For -w, we also consider _ to be word constituent.  */
#define WCHAR(C) (ISALNUM(C) || (C) == '_')

/* KWset compiled pattern.  For Ecompile and Gcompile, we compile
   a list of strings, at least one of which is known to occur in
   any string matching the regexp. */
static kwset_t kwset;

/* DFA compiled regexp. */
static struct dfa dfa;

/* The Regex compiled patterns.  */
static struct patterns
{
  /* Regex compiled regexp. */
  struct re_pattern_buffer regexbuf;
  struct re_registers regs; /* This is here on account of a BRAIN-DEAD
			       Q@#%!# library interface in regex.c.  */
} patterns0;

struct patterns *patterns;
size_t pcount;

void
dfaerror (char const *mesg)
{
  error (EXIT_TROUBLE, 0, "%s", mesg);

  /* notreached */
  /* Tell static analyzers that this function does not return.  */
  abort ();
}

/* Number of compiled fixed strings known to exactly match the regexp.
   If kwsexec returns < kwset_exact_matches, then we don't need to
   call the regexp matcher at all. */
static int kwset_exact_matches;

static char const *
kwsincr_case (const char *must)
{
  const char *buf;
  size_t n;

  n = strlen (must);
#ifdef MBS_SUPPORT
  if (match_icase && MB_CUR_MAX > 1)
    buf = mbtolower (must, &n);
  else
#endif
    buf = must;
  return kwsincr (kwset, buf, n);
}

/* If the DFA turns out to have some set of fixed strings one of
   which must occur in the match, then we build a kwset matcher
   to find those strings, and thus quickly filter out impossible
   matches. */
static void
kwsmusts (void)
{
  struct dfamust const *dm;
  char const *err;

  if (dfa.musts)
    {
      kwsinit (&kwset);
      /* First, we compile in the substrings known to be exact
	 matches.  The kwset matcher will return the index
	 of the matching string that it chooses. */
      for (dm = dfa.musts; dm; dm = dm->next)
	{
	  if (!dm->exact)
	    continue;
	  ++kwset_exact_matches;
	  if ((err = kwsincr_case (dm->must)) != NULL)
	    error (EXIT_TROUBLE, 0, "%s", err);
	}
      /* Now, we compile the substrings that will require
	 the use of the regexp matcher.  */
      for (dm = dfa.musts; dm; dm = dm->next)
	{
	  if (dm->exact)
	    continue;
	  if ((err = kwsincr_case (dm->must)) != NULL)
	    error (EXIT_TROUBLE, 0, "%s", err);
	}
      if ((err = kwsprep (kwset)) != NULL)
	error (EXIT_TROUBLE, 0, "%s", err);
    }
}

void
GEAcompile (char const *pattern, size_t size, reg_syntax_t syntax_bits)
{
  const char *err;
  const char *p, *sep;
  size_t total = size;
  char *motif;

  if (match_icase)
    syntax_bits |= RE_ICASE;
  re_set_syntax (syntax_bits);
  dfasyntax (syntax_bits, match_icase, eolbyte);

  /* For GNU regex compiler we have to pass the patterns separately to detect
     errors like "[\nallo\n]\n".  The patterns here are "[", "allo" and "]"
     GNU regex should have raise a syntax error.  The same for backref, where
     the backref should have been local to each pattern.  */
  p = pattern;
  do
    {
      size_t len;
      sep = memchr (p, '\n', total);
      if (sep)
	{
	  len = sep - p;
	  sep++;
	  total -= (len + 1);
	}
      else
	{
	  len = total;
	  total = 0;
	}

      patterns = realloc (patterns, (pcount + 1) * sizeof (*patterns));
      
//Patch 0:
if ((patterns == ((void *)0)) && !(__is_neg(15, &(patterns), sizeof (patterns), &(pcount), sizeof (pcount), &(err), sizeof (err), &(p), sizeof (p), &(total), sizeof (total), &(len), sizeof (len), &(sep), sizeof (sep), &(match_words), sizeof (match_words), &(match_lines), sizeof (match_lines), &(pattern), sizeof (pattern), &(syntax_bits), sizeof (syntax_bits), &(match_icase), sizeof (match_icase), &(eolbyte), sizeof (eolbyte), &(size), sizeof (size), &(motif), sizeof (motif))))
    error(EXIT_TROUBLE, (*__errno_location()), dcgettext(((void *)0), "memory exhausted", 5));

//CodeSeg 1:
      patterns[pcount] = patterns0;

      if ((err = re_compile_pattern (p, len,
				    &(patterns[pcount].regexbuf))) != NULL)
	error (EXIT_TROUBLE, 0, "%s", err);
      pcount++;

      p = sep;
    } while (sep && total != 0);

  /* In the match_words and match_lines cases, we use a different pattern
     for the DFA matcher that will quickly throw out cases that won't work.
     Then if DFA succeeds we do some hairy stuff using the regex matcher
     to decide whether the match should really count. */
  if (match_words || match_lines)
    {
      static char const line_beg_no_bk[] = "^(";
      static char const line_end_no_bk[] = ")$";
      static char const word_beg_no_bk[] = "(^|[^[:alnum:]_])(";
      static char const word_end_no_bk[] = ")([^[:alnum:]_]|$)";
      static char const line_beg_bk[] = "^\\(";
      static char const line_end_bk[] = "\\)$";
      static char const word_beg_bk[] = "\\(^\\|[^[:alnum:]_]\\)\\(";
      static char const word_end_bk[] = "\\)\\([^[:alnum:]_]\\|$\\)";
      int bk = !(syntax_bits & RE_NO_BK_PARENS);
      char *n = xmalloc (sizeof word_beg_bk - 1 + size + sizeof word_end_bk);

      strcpy (n, match_lines ? (bk ? line_beg_bk : line_beg_no_bk)
			     : (bk ? word_beg_bk : word_beg_no_bk));
      total = strlen(n);
      memcpy (n + total, pattern, size);
      total += size;
      strcpy (n + total, match_lines ? (bk ? line_end_bk : line_end_no_bk)
				     : (bk ? word_end_bk : word_end_no_bk));
      total += strlen (n + total);
      pattern = motif = n;
      size = total;
    }
  else
    motif = NULL;

  dfacomp (pattern, size, &dfa, 1);
  kwsmusts ();

  free(motif);
}

size_t
EGexecute (char const *buf, size_t size, size_t *match_size,
	   char const *start_ptr)
{
  char const *buflim, *beg, *end, *match, *best_match, *mb_start;
  char eol = eolbyte;
  int backref, start, len, best_len;
  struct kwsmatch kwsm;
  size_t i, ret_val;
#ifdef MBS_SUPPORT
  if (MB_CUR_MAX > 1)
    {
      if (match_icase)
        {
          /* mbtolower adds a NUL byte at the end.  That will provide
	     space for the sentinel byte dfaexec may add.  */
          char *case_buf = mbtolower (buf, &size);
	  if (start_ptr)
	    start_ptr = case_buf + (start_ptr - buf);
          buf = case_buf;
        }
    }
#endif /* MBS_SUPPORT */

  mb_start = buf;
  buflim = buf + size;

  for (beg = end = buf; end < buflim; beg = end)
    {
      if (!start_ptr)
	{
	  /* We don't care about an exact match.  */
	  if (kwset)
	    {
	      /* Find a possible match using the KWset matcher. */
	      size_t offset = kwsexec (kwset, beg, buflim - beg, &kwsm);
	      if (offset == (size_t) -1)
		goto failure;
	      beg += offset;
	      /* Narrow down to the line containing the candidate, and
		 run it through DFA. */
	      if ((end = memchr(beg, eol, buflim - beg)) != NULL)
	        end++;
              else
                end = buflim;
	      match = beg;
	      while (beg > buf && beg[-1] != eol)
		--beg;
	      if (kwsm.index < kwset_exact_matches)
                {
#ifdef MBS_SUPPORT
                  if (mb_start < beg)
                    mb_start = beg;
                  if (MB_CUR_MAX == 1 || !is_mb_middle (&mb_start, match, buflim))
#endif
                    goto success;
                }
	      if (dfaexec (&dfa, beg, (char *) end, 0, NULL, &backref) == NULL)
		continue;
	    }
	  else
	    {
	      /* No good fixed strings; start with DFA. */
	      char const *next_beg = dfaexec (&dfa, beg, (char *) buflim,
					      0, NULL, &backref);
	      if (next_beg == NULL)
		break;
	      /* Narrow down to the line we've found. */
	      beg = next_beg;
	      if ((end = memchr(beg, eol, buflim - beg)) != NULL)
	        end++;
              else
                end = buflim;
	      while (beg > buf && beg[-1] != eol)
		--beg;
	    }
	  /* Successful, no backreferences encountered! */
	  if (!backref)
	    goto success;
	}
      else
	{
	  /* We are looking for the leftmost (then longest) exact match.
	     We will go through the outer loop only once.  */
	  beg = start_ptr;
	  end = buflim;
	}

      /* If we've made it to this point, this means DFA has seen
	 a probable match, and we need to run it through Regex. */
      best_match = end;
      best_len = 0;
      for (i = 0; i < pcount; i++)
	{
	  patterns[i].regexbuf.not_eol = 0;
	  if (0 <= (start = re_search (&(patterns[i].regexbuf),
				       buf, end - buf - 1,
				       beg - buf, end - beg - 1,
				       &(patterns[i].regs))))
	    {
	      len = patterns[i].regs.end[0] - start;
	      match = buf + start;
	      if (match > best_match)
		continue;
	      if (start_ptr && !match_words)
		goto assess_pattern_match;
	      if ((!match_lines && !match_words)
		  || (match_lines && len == end - beg - 1))
		{
		  match = beg;
		  len = end - beg;
		  goto assess_pattern_match;
		}
	      /* If -w, check if the match aligns with word boundaries.
		 We do this iteratively because:
		 (a) the line may contain more than one occurence of the
		 pattern, and
		 (b) Several alternatives in the pattern might be valid at a
		 given point, and we may need to consider a shorter one to
		 find a word boundary.  */
	      if (match_words)
		while (match <= best_match)
		  {
		    if ((match == buf || !WCHAR ((unsigned char) match[-1]))
			&& (len == end - beg - 1
			    || !WCHAR ((unsigned char) match[len])))
		      goto assess_pattern_match;
		    if (len > 0)
		      {
			/* Try a shorter length anchored at the same place. */
			--len;
			patterns[i].regexbuf.not_eol = 1;
			len = re_match (&(patterns[i].regexbuf),
					buf, match + len - beg, match - buf,
					&(patterns[i].regs));
		      }
		    if (len <= 0)
		      {
			/* Try looking further on. */
			if (match == end - 1)
			  break;
			match++;
			patterns[i].regexbuf.not_eol = 0;
			start = re_search (&(patterns[i].regexbuf),
					   buf, end - buf - 1,
					   match - buf, end - match - 1,
					   &(patterns[i].regs));
			if (start < 0)
			  break;
			len = patterns[i].regs.end[0] - start;
			match = buf + start;
		      }
		  } /* while (match <= best_match) */
	      continue;
	    assess_pattern_match:
	      if (!start_ptr)
		{
		  /* Good enough for a non-exact match.
		     No need to look at further patterns, if any.  */
		  beg = match;
		  goto success_in_len;
		}
	      if (match < best_match || (match == best_match && len > best_len))
		{
		  /* Best exact match:  leftmost, then longest.  */
		  best_match = match;
		  best_len = len;
		}
	    } /* if re_search >= 0 */
	} /* for Regex patterns.  */
	if (best_match < end)
	  {
	    /* We have found an exact match.  We were just
	       waiting for the best one (leftmost then longest).  */
	    beg = best_match;
	    len = best_len;
	    goto success_in_len;
	  }
    } /* for (beg = end ..) */

 failure:
  ret_val = -1;
  goto out;

 success:
  len = end - beg;
 success_in_len:
  *match_size = len;
  ret_val = beg - buf;
 out:
  return ret_val;
}

Testing negative cases!
Testing 0 (with abstract condition) ENVIS_NEG
Iteration 0
Running test command:
/home/ubuntu/spr-fast/tools/grep-test.py /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-8a025cf8-8f08d8e2/tempworkdir-l/src /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-8a025cf8-8f08d8e2/tempworkdir-l/tests /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-8a025cf8-8f08d8e2/tempworkdir-l 0  > __res
Opening:/tmp/neg.tmp!
NegativeBRANCH RECORD/tmp/neg.tmp!
Not caught by the negative case, give up!
APPENDING TO ISNEG:/tmp/neg.tmp!
Running test command:
/home/ubuntu/spr-fast/tools/grep-test.py /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-8a025cf8-8f08d8e2/tempworkdir-l/src /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-8a025cf8-8f08d8e2/tempworkdir-l/tests /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-8a025cf8-8f08d8e2/tempworkdir-l 0  > __res
CondTester, Testing instance id 21:
//src_file:src/dfasearch.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); void* memset(void*, int, unsigned long); 
/* dfasearch.c - searching subroutines using dfa and regex for grep.
   Copyright 1992, 1998, 2000, 2007, 2009-2010 Free Software Foundation, Inc.

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 3, or (at your option)
   any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program; if not, write to the Free Software
   Foundation, Inc., 51 Franklin Street - Fifth Floor, Boston, MA
   02110-1301, USA.  */

/* Written August 1992 by Mike Haertel. */

#include <config.h>
#include "search.h"
#include "dfa.h"

/* For -w, we also consider _ to be word constituent.  */
#define WCHAR(C) (ISALNUM(C) || (C) == '_')

/* KWset compiled pattern.  For Ecompile and Gcompile, we compile
   a list of strings, at least one of which is known to occur in
   any string matching the regexp. */
static kwset_t kwset;

/* DFA compiled regexp. */
static struct dfa dfa;

/* The Regex compiled patterns.  */
static struct patterns
{
  /* Regex compiled regexp. */
  struct re_pattern_buffer regexbuf;
  struct re_registers regs; /* This is here on account of a BRAIN-DEAD
			       Q@#%!# library interface in regex.c.  */
} patterns0;

struct patterns *patterns;
size_t pcount;

void
dfaerror (char const *mesg)
{
  error (EXIT_TROUBLE, 0, "%s", mesg);

  /* notreached */
  /* Tell static analyzers that this function does not return.  */
  abort ();
}

/* Number of compiled fixed strings known to exactly match the regexp.
   If kwsexec returns < kwset_exact_matches, then we don't need to
   call the regexp matcher at all. */
static int kwset_exact_matches;

static char const *
kwsincr_case (const char *must)
{
  const char *buf;
  size_t n;

  n = strlen (must);
#ifdef MBS_SUPPORT
  if (match_icase && MB_CUR_MAX > 1)
    buf = mbtolower (must, &n);
  else
#endif
    buf = must;
  return kwsincr (kwset, buf, n);
}

/* If the DFA turns out to have some set of fixed strings one of
   which must occur in the match, then we build a kwset matcher
   to find those strings, and thus quickly filter out impossible
   matches. */
static void
kwsmusts (void)
{
  struct dfamust const *dm;
  char const *err;

  if (dfa.musts)
    {
      kwsinit (&kwset);
      /* First, we compile in the substrings known to be exact
	 matches.  The kwset matcher will return the index
	 of the matching string that it chooses. */
      for (dm = dfa.musts; dm; dm = dm->next)
	{
	  if (!dm->exact)
	    continue;
	  ++kwset_exact_matches;
	  if ((err = kwsincr_case (dm->must)) != NULL)
	    error (EXIT_TROUBLE, 0, "%s", err);
	}
      /* Now, we compile the substrings that will require
	 the use of the regexp matcher.  */
      for (dm = dfa.musts; dm; dm = dm->next)
	{
	  if (dm->exact)
	    continue;
	  if ((err = kwsincr_case (dm->must)) != NULL)
	    error (EXIT_TROUBLE, 0, "%s", err);
	}
      if ((err = kwsprep (kwset)) != NULL)
	error (EXIT_TROUBLE, 0, "%s", err);
    }
}

void
GEAcompile (char const *pattern, size_t size, reg_syntax_t syntax_bits)
{
  const char *err;
  const char *p, *sep;
  size_t total = size;
  char *motif;

  if (match_icase)
    syntax_bits |= RE_ICASE;
  re_set_syntax (syntax_bits);
  dfasyntax (syntax_bits, match_icase, eolbyte);

  /* For GNU regex compiler we have to pass the patterns separately to detect
     errors like "[\nallo\n]\n".  The patterns here are "[", "allo" and "]"
     GNU regex should have raise a syntax error.  The same for backref, where
     the backref should have been local to each pattern.  */
  p = pattern;
  do
    {
      size_t len;
      sep = memchr (p, '\n', total);
      if (sep)
	{
	  len = sep - p;
	  sep++;
	  total -= (len + 1);
	}
      else
	{
	  len = total;
	  total = 0;
	}

      patterns = realloc (patterns, (pcount + 1) * sizeof (*patterns));
      
//Patch 0:
if ((patterns == ((void *)0)) || (__is_neg(15, &(patterns), sizeof (patterns), &(pcount), sizeof (pcount), &(err), sizeof (err), &(p), sizeof (p), &(total), sizeof (total), &(len), sizeof (len), &(sep), sizeof (sep), &(match_words), sizeof (match_words), &(match_lines), sizeof (match_lines), &(pattern), sizeof (pattern), &(syntax_bits), sizeof (syntax_bits), &(match_icase), sizeof (match_icase), &(eolbyte), sizeof (eolbyte), &(size), sizeof (size), &(motif), sizeof (motif))))
    error(EXIT_TROUBLE, (*__errno_location()), dcgettext(((void *)0), "memory exhausted", 5));

//CodeSeg 1:
      patterns[pcount] = patterns0;

      if ((err = re_compile_pattern (p, len,
				    &(patterns[pcount].regexbuf))) != NULL)
	error (EXIT_TROUBLE, 0, "%s", err);
      pcount++;

      p = sep;
    } while (sep && total != 0);

  /* In the match_words and match_lines cases, we use a different pattern
     for the DFA matcher that will quickly throw out cases that won't work.
     Then if DFA succeeds we do some hairy stuff using the regex matcher
     to decide whether the match should really count. */
  if (match_words || match_lines)
    {
      static char const line_beg_no_bk[] = "^(";
      static char const line_end_no_bk[] = ")$";
      static char const word_beg_no_bk[] = "(^|[^[:alnum:]_])(";
      static char const word_end_no_bk[] = ")([^[:alnum:]_]|$)";
      static char const line_beg_bk[] = "^\\(";
      static char const line_end_bk[] = "\\)$";
      static char const word_beg_bk[] = "\\(^\\|[^[:alnum:]_]\\)\\(";
      static char const word_end_bk[] = "\\)\\([^[:alnum:]_]\\|$\\)";
      int bk = !(syntax_bits & RE_NO_BK_PARENS);
      char *n = xmalloc (sizeof word_beg_bk - 1 + size + sizeof word_end_bk);

      strcpy (n, match_lines ? (bk ? line_beg_bk : line_beg_no_bk)
			     : (bk ? word_beg_bk : word_beg_no_bk));
      total = strlen(n);
      memcpy (n + total, pattern, size);
      total += size;
      strcpy (n + total, match_lines ? (bk ? line_end_bk : line_end_no_bk)
				     : (bk ? word_end_bk : word_end_no_bk));
      total += strlen (n + total);
      pattern = motif = n;
      size = total;
    }
  else
    motif = NULL;

  dfacomp (pattern, size, &dfa, 1);
  kwsmusts ();

  free(motif);
}

size_t
EGexecute (char const *buf, size_t size, size_t *match_size,
	   char const *start_ptr)
{
  char const *buflim, *beg, *end, *match, *best_match, *mb_start;
  char eol = eolbyte;
  int backref, start, len, best_len;
  struct kwsmatch kwsm;
  size_t i, ret_val;
#ifdef MBS_SUPPORT
  if (MB_CUR_MAX > 1)
    {
      if (match_icase)
        {
          /* mbtolower adds a NUL byte at the end.  That will provide
	     space for the sentinel byte dfaexec may add.  */
          char *case_buf = mbtolower (buf, &size);
	  if (start_ptr)
	    start_ptr = case_buf + (start_ptr - buf);
          buf = case_buf;
        }
    }
#endif /* MBS_SUPPORT */

  mb_start = buf;
  buflim = buf + size;

  for (beg = end = buf; end < buflim; beg = end)
    {
      if (!start_ptr)
	{
	  /* We don't care about an exact match.  */
	  if (kwset)
	    {
	      /* Find a possible match using the KWset matcher. */
	      size_t offset = kwsexec (kwset, beg, buflim - beg, &kwsm);
	      if (offset == (size_t) -1)
		goto failure;
	      beg += offset;
	      /* Narrow down to the line containing the candidate, and
		 run it through DFA. */
	      if ((end = memchr(beg, eol, buflim - beg)) != NULL)
	        end++;
              else
                end = buflim;
	      match = beg;
	      while (beg > buf && beg[-1] != eol)
		--beg;
	      if (kwsm.index < kwset_exact_matches)
                {
#ifdef MBS_SUPPORT
                  if (mb_start < beg)
                    mb_start = beg;
                  if (MB_CUR_MAX == 1 || !is_mb_middle (&mb_start, match, buflim))
#endif
                    goto success;
                }
	      if (dfaexec (&dfa, beg, (char *) end, 0, NULL, &backref) == NULL)
		continue;
	    }
	  else
	    {
	      /* No good fixed strings; start with DFA. */
	      char const *next_beg = dfaexec (&dfa, beg, (char *) buflim,
					      0, NULL, &backref);
	      if (next_beg == NULL)
		break;
	      /* Narrow down to the line we've found. */
	      beg = next_beg;
	      if ((end = memchr(beg, eol, buflim - beg)) != NULL)
	        end++;
              else
                end = buflim;
	      while (beg > buf && beg[-1] != eol)
		--beg;
	    }
	  /* Successful, no backreferences encountered! */
	  if (!backref)
	    goto success;
	}
      else
	{
	  /* We are looking for the leftmost (then longest) exact match.
	     We will go through the outer loop only once.  */
	  beg = start_ptr;
	  end = buflim;
	}

      /* If we've made it to this point, this means DFA has seen
	 a probable match, and we need to run it through Regex. */
      best_match = end;
      best_len = 0;
      for (i = 0; i < pcount; i++)
	{
	  patterns[i].regexbuf.not_eol = 0;
	  if (0 <= (start = re_search (&(patterns[i].regexbuf),
				       buf, end - buf - 1,
				       beg - buf, end - beg - 1,
				       &(patterns[i].regs))))
	    {
	      len = patterns[i].regs.end[0] - start;
	      match = buf + start;
	      if (match > best_match)
		continue;
	      if (start_ptr && !match_words)
		goto assess_pattern_match;
	      if ((!match_lines && !match_words)
		  || (match_lines && len == end - beg - 1))
		{
		  match = beg;
		  len = end - beg;
		  goto assess_pattern_match;
		}
	      /* If -w, check if the match aligns with word boundaries.
		 We do this iteratively because:
		 (a) the line may contain more than one occurence of the
		 pattern, and
		 (b) Several alternatives in the pattern might be valid at a
		 given point, and we may need to consider a shorter one to
		 find a word boundary.  */
	      if (match_words)
		while (match <= best_match)
		  {
		    if ((match == buf || !WCHAR ((unsigned char) match[-1]))
			&& (len == end - beg - 1
			    || !WCHAR ((unsigned char) match[len])))
		      goto assess_pattern_match;
		    if (len > 0)
		      {
			/* Try a shorter length anchored at the same place. */
			--len;
			patterns[i].regexbuf.not_eol = 1;
			len = re_match (&(patterns[i].regexbuf),
					buf, match + len - beg, match - buf,
					&(patterns[i].regs));
		      }
		    if (len <= 0)
		      {
			/* Try looking further on. */
			if (match == end - 1)
			  break;
			match++;
			patterns[i].regexbuf.not_eol = 0;
			start = re_search (&(patterns[i].regexbuf),
					   buf, end - buf - 1,
					   match - buf, end - match - 1,
					   &(patterns[i].regs));
			if (start < 0)
			  break;
			len = patterns[i].regs.end[0] - start;
			match = buf + start;
		      }
		  } /* while (match <= best_match) */
	      continue;
	    assess_pattern_match:
	      if (!start_ptr)
		{
		  /* Good enough for a non-exact match.
		     No need to look at further patterns, if any.  */
		  beg = match;
		  goto success_in_len;
		}
	      if (match < best_match || (match == best_match && len > best_len))
		{
		  /* Best exact match:  leftmost, then longest.  */
		  best_match = match;
		  best_len = len;
		}
	    } /* if re_search >= 0 */
	} /* for Regex patterns.  */
	if (best_match < end)
	  {
	    /* We have found an exact match.  We were just
	       waiting for the best one (leftmost then longest).  */
	    beg = best_match;
	    len = best_len;
	    goto success_in_len;
	  }
    } /* for (beg = end ..) */

 failure:
  ret_val = -1;
  goto out;

 success:
  len = end - beg;
 success_in_len:
  *match_size = len;
  ret_val = beg - buf;
 out:
  return ret_val;
}

Testing negative cases!
Testing 0 (with abstract condition) ENVIS_NEG
Iteration 0
Running test command:
/home/ubuntu/spr-fast/tools/grep-test.py /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-8a025cf8-8f08d8e2/tempworkdir-l/src /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-8a025cf8-8f08d8e2/tempworkdir-l/tests /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-8a025cf8-8f08d8e2/tempworkdir-l 0  > __res
Opening:/tmp/neg.tmp!
NegativeBRANCH RECORD/tmp/neg.tmp!
APPENDING TO ISNEG:/tmp/neg.tmp!
Branch 0: 0
Iteration 1
Running test command:
/home/ubuntu/spr-fast/tools/grep-test.py /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-8a025cf8-8f08d8e2/tempworkdir-l/src /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-8a025cf8-8f08d8e2/tempworkdir-l/tests /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-8a025cf8-8f08d8e2/tempworkdir-l 0  > __res
Opening:/tmp/neg.tmp!
NegativeBRANCH RECORD/tmp/neg.tmp!
APPENDING TO ISNEG:/tmp/neg.tmp!
Branch 0: 1
Running test command:
/home/ubuntu/spr-fast/tools/grep-test.py /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-8a025cf8-8f08d8e2/tempworkdir-l/src /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-8a025cf8-8f08d8e2/tempworkdir-l/tests /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-8a025cf8-8f08d8e2/tempworkdir-l 0  > __res
a batched test job starts!
Building merged code:
src_file: src/dfasearch.c
full src: int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); void* memset(void*, int, unsigned long); 
/* dfasearch.c - searching subroutines using dfa and regex for grep.
   Copyright 1992, 1998, 2000, 2007, 2009-2010 Free Software Foundation, Inc.

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 3, or (at your option)
   any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program; if not, write to the Free Software
   Foundation, Inc., 51 Franklin Street - Fifth Floor, Boston, MA
   02110-1301, USA.  */

/* Written August 1992 by Mike Haertel. */

#include <config.h>
#include "search.h"
#include "dfa.h"

/* For -w, we also consider _ to be word constituent.  */
#define WCHAR(C) (ISALNUM(C) || (C) == '_')

/* KWset compiled pattern.  For Ecompile and Gcompile, we compile
   a list of strings, at least one of which is known to occur in
   any string matching the regexp. */
static kwset_t kwset;

/* DFA compiled regexp. */
static struct dfa dfa;

/* The Regex compiled patterns.  */
static struct patterns
{
  /* Regex compiled regexp. */
  struct re_pattern_buffer regexbuf;
  struct re_registers regs; /* This is here on account of a BRAIN-DEAD
			       Q@#%!# library interface in regex.c.  */
} patterns0;

struct patterns *patterns;
size_t pcount;

void
dfaerror (char const *mesg)
{
  error (EXIT_TROUBLE, 0, "%s", mesg);

  /* notreached */
  /* Tell static analyzers that this function does not return.  */
  abort ();
}

/* Number of compiled fixed strings known to exactly match the regexp.
   If kwsexec returns < kwset_exact_matches, then we don't need to
   call the regexp matcher at all. */
static int kwset_exact_matches;

static char const *
kwsincr_case (const char *must)
{
  const char *buf;
  size_t n;

  n = strlen (must);
#ifdef MBS_SUPPORT
  if (match_icase && MB_CUR_MAX > 1)
    buf = mbtolower (must, &n);
  else
#endif
    buf = must;
  return kwsincr (kwset, buf, n);
}

/* If the DFA turns out to have some set of fixed strings one of
   which must occur in the match, then we build a kwset matcher
   to find those strings, and thus quickly filter out impossible
   matches. */
static void
kwsmusts (void)
{
  struct dfamust const *dm;
  char const *err;

  if (dfa.musts)
    {
      kwsinit (&kwset);
      /* First, we compile in the substrings known to be exact
	 matches.  The kwset matcher will return the index
	 of the matching string that it chooses. */
      for (dm = dfa.musts; dm; dm = dm->next)
	{
	  if (!dm->exact)
	    continue;
	  ++kwset_exact_matches;
	  if ((err = kwsincr_case (dm->must)) != NULL)
	    error (EXIT_TROUBLE, 0, "%s", err);
	}
      /* Now, we compile the substrings that will require
	 the use of the regexp matcher.  */
      for (dm = dfa.musts; dm; dm = dm->next)
	{
	  if (dm->exact)
	    continue;
	  if ((err = kwsincr_case (dm->must)) != NULL)
	    error (EXIT_TROUBLE, 0, "%s", err);
	}
      if ((err = kwsprep (kwset)) != NULL)
	error (EXIT_TROUBLE, 0, "%s", err);
    }
}

void
GEAcompile (char const *pattern, size_t size, reg_syntax_t syntax_bits)
{
  const char *err;
  const char *p, *sep;
  size_t total = size;
  char *motif;

  if (match_icase)
    syntax_bits |= RE_ICASE;
  re_set_syntax (syntax_bits);
  dfasyntax (syntax_bits, match_icase, eolbyte);

  /* For GNU regex compiler we have to pass the patterns separately to detect
     errors like "[\nallo\n]\n".  The patterns here are "[", "allo" and "]"
     GNU regex should have raise a syntax error.  The same for backref, where
     the backref should have been local to each pattern.  */
  p = pattern;
  do
    {
      size_t len;
      sep = memchr (p, '\n', total);
      if (sep)
	{
	  len = sep - p;
	  sep++;
	  total -= (len + 1);
	}
      else
	{
	  len = total;
	  total = 0;
	}

      patterns = realloc (patterns, (pcount + 1) * sizeof (*patterns));
      if (patterns == NULL)
	error (EXIT_TROUBLE, errno, _("memory exhausted"));
      patterns[pcount] = patterns0;

      //prophet generated patch
      if (__get_mutant()==0) {
      if (((err = rpl_re_compile_pattern(p, len, &(patterns[pcount].regexbuf))) != ((void *)0)) && !(__is_neg(29, &(patterns), sizeof (patterns), &(pcount), sizeof (pcount), &(err), sizeof (err), &(p), sizeof (p), &(len), sizeof (len), &(sep), sizeof (sep), &(total), sizeof (total), &(match_words), sizeof (match_words), &(match_lines), sizeof (match_lines), &(syntax_bits), sizeof (syntax_bits), &(size), sizeof (size), &(pattern), sizeof (pattern), &(match_icase), sizeof (match_icase), &(eolbyte), sizeof (eolbyte), &(motif), sizeof (motif), &(patterns[pcount].regexbuf.buffer), sizeof (patterns[pcount].regexbuf.buffer), &(patterns[pcount].regexbuf.allocated), sizeof (patterns[pcount].regexbuf.allocated), &(patterns[pcount].regexbuf.used), sizeof (patterns[pcount].regexbuf.used), &(patterns[pcount].regexbuf.syntax), sizeof (patterns[pcount].regexbuf.syntax), &(patterns[pcount].regexbuf.fastmap), sizeof (patterns[pcount].regexbuf.fastmap), &(patterns[pcount].regexbuf.translate), sizeof (patterns[pcount].regexbuf.translate), &(patterns[pcount].regexbuf.re_nsub), sizeof (patterns[pcount].regexbuf.re_nsub), &(patterns[pcount].regexbuf.can_be_null), sizeof (patterns[pcount].regexbuf.can_be_null), &(patterns[pcount].regexbuf.regs_allocated), sizeof (patterns[pcount].regexbuf.regs_allocated), &(patterns[pcount].regexbuf.fastmap_accurate), sizeof (patterns[pcount].regexbuf.fastmap_accurate), &(patterns[pcount].regexbuf.no_sub), sizeof (patterns[pcount].regexbuf.no_sub), &(patterns[pcount].regexbuf.not_bol), sizeof (patterns[pcount].regexbuf.not_bol), &(patterns[pcount].regexbuf.not_eol), sizeof (patterns[pcount].regexbuf.not_eol), &(patterns[pcount].regexbuf.newline_anchor), sizeof (patterns[pcount].regexbuf.newline_anchor))))
          error(EXIT_TROUBLE, 0, "%s", err);
      }
      else if (__get_mutant()==1) {
      if (((err = rpl_re_compile_pattern(p, len, &(patterns[pcount].regexbuf))) != ((void *)0)) || (__is_neg(29, &(patterns), sizeof (patterns), &(pcount), sizeof (pcount), &(err), sizeof (err), &(p), sizeof (p), &(len), sizeof (len), &(sep), sizeof (sep), &(total), sizeof (total), &(match_words), sizeof (match_words), &(match_lines), sizeof (match_lines), &(syntax_bits), sizeof (syntax_bits), &(size), sizeof (size), &(pattern), sizeof (pattern), &(match_icase), sizeof (match_icase), &(eolbyte), sizeof (eolbyte), &(motif), sizeof (motif), &(patterns[pcount].regexbuf.buffer), sizeof (patterns[pcount].regexbuf.buffer), &(patterns[pcount].regexbuf.allocated), sizeof (patterns[pcount].regexbuf.allocated), &(patterns[pcount].regexbuf.used), sizeof (patterns[pcount].regexbuf.used), &(patterns[pcount].regexbuf.syntax), sizeof (patterns[pcount].regexbuf.syntax), &(patterns[pcount].regexbuf.fastmap), sizeof (patterns[pcount].regexbuf.fastmap), &(patterns[pcount].regexbuf.translate), sizeof (patterns[pcount].regexbuf.translate), &(patterns[pcount].regexbuf.re_nsub), sizeof (patterns[pcount].regexbuf.re_nsub), &(patterns[pcount].regexbuf.can_be_null), sizeof (patterns[pcount].regexbuf.can_be_null), &(patterns[pcount].regexbuf.regs_allocated), sizeof (patterns[pcount].regexbuf.regs_allocated), &(patterns[pcount].regexbuf.fastmap_accurate), sizeof (patterns[pcount].regexbuf.fastmap_accurate), &(patterns[pcount].regexbuf.no_sub), sizeof (patterns[pcount].regexbuf.no_sub), &(patterns[pcount].regexbuf.not_bol), sizeof (patterns[pcount].regexbuf.not_bol), &(patterns[pcount].regexbuf.not_eol), sizeof (patterns[pcount].regexbuf.not_eol), &(patterns[pcount].regexbuf.newline_anchor), sizeof (patterns[pcount].regexbuf.newline_anchor))))
          error(EXIT_TROUBLE, 0, "%s", err);
      }
      pcount++;

      p = sep;
    } while (sep && total != 0);

  /* In the match_words and match_lines cases, we use a different pattern
     for the DFA matcher that will quickly throw out cases that won't work.
     Then if DFA succeeds we do some hairy stuff using the regex matcher
     to decide whether the match should really count. */
  if (match_words || match_lines)
    {
      static char const line_beg_no_bk[] = "^(";
      static char const line_end_no_bk[] = ")$";
      static char const word_beg_no_bk[] = "(^|[^[:alnum:]_])(";
      static char const word_end_no_bk[] = ")([^[:alnum:]_]|$)";
      static char const line_beg_bk[] = "^\\(";
      static char const line_end_bk[] = "\\)$";
      static char const word_beg_bk[] = "\\(^\\|[^[:alnum:]_]\\)\\(";
      static char const word_end_bk[] = "\\)\\([^[:alnum:]_]\\|$\\)";
      int bk = !(syntax_bits & RE_NO_BK_PARENS);
      char *n = xmalloc (sizeof word_beg_bk - 1 + size + sizeof word_end_bk);

      strcpy (n, match_lines ? (bk ? line_beg_bk : line_beg_no_bk)
			     : (bk ? word_beg_bk : word_beg_no_bk));
      total = strlen(n);
      memcpy (n + total, pattern, size);
      total += size;
      strcpy (n + total, match_lines ? (bk ? line_end_bk : line_end_no_bk)
				     : (bk ? word_end_bk : word_end_no_bk));
      total += strlen (n + total);
      pattern = motif = n;
      size = total;
    }
  else
    motif = NULL;

  dfacomp (pattern, size, &dfa, 1);
  kwsmusts ();

  free(motif);
}

size_t
EGexecute (char const *buf, size_t size, size_t *match_size,
	   char const *start_ptr)
{
  char const *buflim, *beg, *end, *match, *best_match, *mb_start;
  char eol = eolbyte;
  int backref, start, len, best_len;
  struct kwsmatch kwsm;
  size_t i, ret_val;
#ifdef MBS_SUPPORT
  if (MB_CUR_MAX > 1)
    {
      if (match_icase)
        {
          /* mbtolower adds a NUL byte at the end.  That will provide
	     space for the sentinel byte dfaexec may add.  */
          char *case_buf = mbtolower (buf, &size);
	  if (start_ptr)
	    start_ptr = case_buf + (start_ptr - buf);
          buf = case_buf;
        }
    }
#endif /* MBS_SUPPORT */

  mb_start = buf;
  buflim = buf + size;

  for (beg = end = buf; end < buflim; beg = end)
    {
      if (!start_ptr)
	{
	  /* We don't care about an exact match.  */
	  if (kwset)
	    {
	      /* Find a possible match using the KWset matcher. */
	      size_t offset = kwsexec (kwset, beg, buflim - beg, &kwsm);
	      if (offset == (size_t) -1)
		goto failure;
	      beg += offset;
	      /* Narrow down to the line containing the candidate, and
		 run it through DFA. */
	      if ((end = memchr(beg, eol, buflim - beg)) != NULL)
	        end++;
              else
                end = buflim;
	      match = beg;
	      while (beg > buf && beg[-1] != eol)
		--beg;
	      if (kwsm.index < kwset_exact_matches)
                {
#ifdef MBS_SUPPORT
                  if (mb_start < beg)
                    mb_start = beg;
                  if (MB_CUR_MAX == 1 || !is_mb_middle (&mb_start, match, buflim))
#endif
                    goto success;
                }
	      if (dfaexec (&dfa, beg, (char *) end, 0, NULL, &backref) == NULL)
		continue;
	    }
	  else
	    {
	      /* No good fixed strings; start with DFA. */
	      char const *next_beg = dfaexec (&dfa, beg, (char *) buflim,
					      0, NULL, &backref);
	      if (next_beg == NULL)
		break;
	      /* Narrow down to the line we've found. */
	      beg = next_beg;
	      if ((end = memchr(beg, eol, buflim - beg)) != NULL)
	        end++;
              else
                end = buflim;
	      while (beg > buf && beg[-1] != eol)
		--beg;
	    }
	  /* Successful, no backreferences encountered! */
	  if (!backref)
	    goto success;
	}
      else
	{
	  /* We are looking for the leftmost (then longest) exact match.
	     We will go through the outer loop only once.  */
	  beg = start_ptr;
	  end = buflim;
	}

      /* If we've made it to this point, this means DFA has seen
	 a probable match, and we need to run it through Regex. */
      best_match = end;
      best_len = 0;
      for (i = 0; i < pcount; i++)
	{
	  patterns[i].regexbuf.not_eol = 0;
	  if (0 <= (start = re_search (&(patterns[i].regexbuf),
				       buf, end - buf - 1,
				       beg - buf, end - beg - 1,
				       &(patterns[i].regs))))
	    {
	      len = patterns[i].regs.end[0] - start;
	      match = buf + start;
	      if (match > best_match)
		continue;
	      if (start_ptr && !match_words)
		goto assess_pattern_match;
	      if ((!match_lines && !match_words)
		  || (match_lines && len == end - beg - 1))
		{
		  match = beg;
		  len = end - beg;
		  goto assess_pattern_match;
		}
	      /* If -w, check if the match aligns with word boundaries.
		 We do this iteratively because:
		 (a) the line may contain more than one occurence of the
		 pattern, and
		 (b) Several alternatives in the pattern might be valid at a
		 given point, and we may need to consider a shorter one to
		 find a word boundary.  */
	      if (match_words)
		while (match <= best_match)
		  {
		    if ((match == buf || !WCHAR ((unsigned char) match[-1]))
			&& (len == end - beg - 1
			    || !WCHAR ((unsigned char) match[len])))
		      goto assess_pattern_match;
		    if (len > 0)
		      {
			/* Try a shorter length anchored at the same place. */
			--len;
			patterns[i].regexbuf.not_eol = 1;
			len = re_match (&(patterns[i].regexbuf),
					buf, match + len - beg, match - buf,
					&(patterns[i].regs));
		      }
		    if (len <= 0)
		      {
			/* Try looking further on. */
			if (match == end - 1)
			  break;
			match++;
			patterns[i].regexbuf.not_eol = 0;
			start = re_search (&(patterns[i].regexbuf),
					   buf, end - buf - 1,
					   match - buf, end - match - 1,
					   &(patterns[i].regs));
			if (start < 0)
			  break;
			len = patterns[i].regs.end[0] - start;
			match = buf + start;
		      }
		  } /* while (match <= best_match) */
	      continue;
	    assess_pattern_match:
	      if (!start_ptr)
		{
		  /* Good enough for a non-exact match.
		     No need to look at further patterns, if any.  */
		  beg = match;
		  goto success_in_len;
		}
	      if (match < best_match || (match == best_match && len > best_len))
		{
		  /* Best exact match:  leftmost, then longest.  */
		  best_match = match;
		  best_len = len;
		}
	    } /* if re_search >= 0 */
	} /* for Regex patterns.  */
	if (best_match < end)
	  {
	    /* We have found an exact match.  We were just
	       waiting for the best one (leftmost then longest).  */
	    beg = best_match;
	    len = best_len;
	    goto success_in_len;
	  }
    } /* for (beg = end ..) */

 failure:
  ret_val = -1;
  goto out;

 success:
  len = end - beg;
 success_in_len:
  *match_size = len;
  ret_val = beg - buf;
 out:
  return ret_val;
}

Building:src at:
/home/ubuntu/spr-fast/tests/corebench/grep/grep-case-8a025cf8-8f08d8e2/tempworkdir-l/srcMerged code building failed! Going to build saperately!
Building:src at:
/home/ubuntu/spr-fast/tests/corebench/grep/grep-case-8a025cf8-8f08d8e2/tempworkdir-l/srcSingle building for Tester 0x42e68c0 id 2 failed as well!
Building:src at:
/home/ubuntu/spr-fast/tests/corebench/grep/grep-case-8a025cf8-8f08d8e2/tempworkdir-l/srcSingle building for Tester 0x42e68c0 id 3 failed as well!
a batched test job starts!
Building merged code:
src_file: src/dfasearch.c
full src: int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); void* memset(void*, int, unsigned long); 
/* dfasearch.c - searching subroutines using dfa and regex for grep.
   Copyright 1992, 1998, 2000, 2007, 2009-2010 Free Software Foundation, Inc.

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 3, or (at your option)
   any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program; if not, write to the Free Software
   Foundation, Inc., 51 Franklin Street - Fifth Floor, Boston, MA
   02110-1301, USA.  */

/* Written August 1992 by Mike Haertel. */

#include <config.h>
#include "search.h"
#include "dfa.h"

/* For -w, we also consider _ to be word constituent.  */
#define WCHAR(C) (ISALNUM(C) || (C) == '_')

/* KWset compiled pattern.  For Ecompile and Gcompile, we compile
   a list of strings, at least one of which is known to occur in
   any string matching the regexp. */
static kwset_t kwset;

/* DFA compiled regexp. */
static struct dfa dfa;

/* The Regex compiled patterns.  */
static struct patterns
{
  /* Regex compiled regexp. */
  struct re_pattern_buffer regexbuf;
  struct re_registers regs; /* This is here on account of a BRAIN-DEAD
			       Q@#%!# library interface in regex.c.  */
} patterns0;

struct patterns *patterns;
size_t pcount;

void
dfaerror (char const *mesg)
{
  error (EXIT_TROUBLE, 0, "%s", mesg);

  /* notreached */
  /* Tell static analyzers that this function does not return.  */
  abort ();
}

/* Number of compiled fixed strings known to exactly match the regexp.
   If kwsexec returns < kwset_exact_matches, then we don't need to
   call the regexp matcher at all. */
static int kwset_exact_matches;

static char const *
kwsincr_case (const char *must)
{
  const char *buf;
  size_t n;

  n = strlen (must);
#ifdef MBS_SUPPORT
  if (match_icase && MB_CUR_MAX > 1)
    buf = mbtolower (must, &n);
  else
#endif
    buf = must;
  return kwsincr (kwset, buf, n);
}

/* If the DFA turns out to have some set of fixed strings one of
   which must occur in the match, then we build a kwset matcher
   to find those strings, and thus quickly filter out impossible
   matches. */
static void
kwsmusts (void)
{
  struct dfamust const *dm;
  char const *err;

  if (dfa.musts)
    {
      kwsinit (&kwset);
      /* First, we compile in the substrings known to be exact
	 matches.  The kwset matcher will return the index
	 of the matching string that it chooses. */
      for (dm = dfa.musts; dm; dm = dm->next)
	{
	  if (!dm->exact)
	    continue;
	  ++kwset_exact_matches;
	  if ((err = kwsincr_case (dm->must)) != NULL)
	    error (EXIT_TROUBLE, 0, "%s", err);
	}
      /* Now, we compile the substrings that will require
	 the use of the regexp matcher.  */
      for (dm = dfa.musts; dm; dm = dm->next)
	{
	  if (dm->exact)
	    continue;
	  if ((err = kwsincr_case (dm->must)) != NULL)
	    error (EXIT_TROUBLE, 0, "%s", err);
	}
      if ((err = kwsprep (kwset)) != NULL)
	error (EXIT_TROUBLE, 0, "%s", err);
    }
}

void
GEAcompile (char const *pattern, size_t size, reg_syntax_t syntax_bits)
{
  const char *err;
  const char *p, *sep;
  size_t total = size;
  char *motif;

  if (match_icase)
    syntax_bits |= RE_ICASE;
  re_set_syntax (syntax_bits);
  dfasyntax (syntax_bits, match_icase, eolbyte);

  /* For GNU regex compiler we have to pass the patterns separately to detect
     errors like "[\nallo\n]\n".  The patterns here are "[", "allo" and "]"
     GNU regex should have raise a syntax error.  The same for backref, where
     the backref should have been local to each pattern.  */
  p = pattern;
  do
    {
      size_t len;
      sep = memchr (p, '\n', total);
      if (sep)
	{
	  len = sep - p;
	  sep++;
	  total -= (len + 1);
	}
      else
	{
	  len = total;
	  total = 0;
	}

      patterns = realloc (patterns, (pcount + 1) * sizeof (*patterns));
      if (patterns == NULL)
	error (EXIT_TROUBLE, errno, _("memory exhausted"));
      patterns[pcount] = patterns0;

      if ((err = re_compile_pattern (p, len,
				    &(patterns[pcount].regexbuf))) != NULL)
	error (EXIT_TROUBLE, 0, "%s", err);
      pcount++;

      p = sep;
    } while (sep && total != 0);

  /* In the match_words and match_lines cases, we use a different pattern
     for the DFA matcher that will quickly throw out cases that won't work.
     Then if DFA succeeds we do some hairy stuff using the regex matcher
     to decide whether the match should really count. */
  //prophet generated patch
  if (__get_mutant()==0) {
  if ((match_words || match_lines) && !(__is_neg(14, &(match_words), sizeof (match_words), &(match_lines), sizeof (match_lines), &(sep), sizeof (sep), &(total), sizeof (total), &(p), sizeof (p), &(pcount), sizeof (pcount), &(syntax_bits), sizeof (syntax_bits), &(err), sizeof (err), &(size), sizeof (size), &(patterns), sizeof (patterns), &(pattern), sizeof (pattern), &(motif), sizeof (motif), &(match_icase), sizeof (match_icase), &(eolbyte), sizeof (eolbyte)))) {
      static const char line_beg_no_bk[] = "^(";
      static const char line_end_no_bk[] = ")$";
      static const char word_beg_no_bk[] = "(^|[^[:alnum:]_])(";
      static const char word_end_no_bk[] = ")([^[:alnum:]_]|$)";
      static const char line_beg_bk[] = "^\\(";
      static const char line_end_bk[] = "\\)$";
      static const char word_beg_bk[] = "\\(^\\|[^[:alnum:]_]\\)\\(";
      static const char word_end_bk[] = "\\)\\([^[:alnum:]_]\\|$\\)";
      int bk = !(syntax_bits & (((((((((((((((unsigned long)1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1));
      char *n = xmalloc(sizeof word_beg_bk - 1 + size + sizeof word_end_bk);
      strcpy(n, match_lines ? (bk ? line_beg_bk : line_beg_no_bk) : (bk ? word_beg_bk : word_beg_no_bk));
      total = strlen(n);
      memcpy(n + total, pattern, size);
      total += size;
      strcpy(n + total, match_lines ? (bk ? line_end_bk : line_end_no_bk) : (bk ? word_end_bk : word_end_no_bk));
      total += strlen(n + total);
      pattern = motif = n;
      size = total;
  } else
      motif = ((void *)0);
  }
  else if (__get_mutant()==1) {
  if ((match_words || match_lines) || (__is_neg(14, &(match_words), sizeof (match_words), &(match_lines), sizeof (match_lines), &(sep), sizeof (sep), &(total), sizeof (total), &(p), sizeof (p), &(pcount), sizeof (pcount), &(syntax_bits), sizeof (syntax_bits), &(err), sizeof (err), &(size), sizeof (size), &(patterns), sizeof (patterns), &(pattern), sizeof (pattern), &(motif), sizeof (motif), &(match_icase), sizeof (match_icase), &(eolbyte), sizeof (eolbyte)))) {
      static const char line_beg_no_bk[] = "^(";
      static const char line_end_no_bk[] = ")$";
      static const char word_beg_no_bk[] = "(^|[^[:alnum:]_])(";
      static const char word_end_no_bk[] = ")([^[:alnum:]_]|$)";
      static const char line_beg_bk[] = "^\\(";
      static const char line_end_bk[] = "\\)$";
      static const char word_beg_bk[] = "\\(^\\|[^[:alnum:]_]\\)\\(";
      static const char word_end_bk[] = "\\)\\([^[:alnum:]_]\\|$\\)";
      int bk = !(syntax_bits & (((((((((((((((unsigned long)1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1));
      char *n = xmalloc(sizeof word_beg_bk - 1 + size + sizeof word_end_bk);
      strcpy(n, match_lines ? (bk ? line_beg_bk : line_beg_no_bk) : (bk ? word_beg_bk : word_beg_no_bk));
      total = strlen(n);
      memcpy(n + total, pattern, size);
      total += size;
      strcpy(n + total, match_lines ? (bk ? line_end_bk : line_end_no_bk) : (bk ? word_end_bk : word_end_no_bk));
      total += strlen(n + total);
      pattern = motif = n;
      size = total;
  } else
      motif = ((void *)0);
  }

  dfacomp (pattern, size, &dfa, 1);
  kwsmusts ();

  free(motif);
}

size_t
EGexecute (char const *buf, size_t size, size_t *match_size,
	   char const *start_ptr)
{
  char const *buflim, *beg, *end, *match, *best_match, *mb_start;
  char eol = eolbyte;
  int backref, start, len, best_len;
  struct kwsmatch kwsm;
  size_t i, ret_val;
#ifdef MBS_SUPPORT
  if (MB_CUR_MAX > 1)
    {
      if (match_icase)
        {
          /* mbtolower adds a NUL byte at the end.  That will provide
	     space for the sentinel byte dfaexec may add.  */
          char *case_buf = mbtolower (buf, &size);
	  if (start_ptr)
	    start_ptr = case_buf + (start_ptr - buf);
          buf = case_buf;
        }
    }
#endif /* MBS_SUPPORT */

  mb_start = buf;
  buflim = buf + size;

  for (beg = end = buf; end < buflim; beg = end)
    {
      if (!start_ptr)
	{
	  /* We don't care about an exact match.  */
	  if (kwset)
	    {
	      /* Find a possible match using the KWset matcher. */
	      size_t offset = kwsexec (kwset, beg, buflim - beg, &kwsm);
	      if (offset == (size_t) -1)
		goto failure;
	      beg += offset;
	      /* Narrow down to the line containing the candidate, and
		 run it through DFA. */
	      if ((end = memchr(beg, eol, buflim - beg)) != NULL)
	        end++;
              else
                end = buflim;
	      match = beg;
	      while (beg > buf && beg[-1] != eol)
		--beg;
	      if (kwsm.index < kwset_exact_matches)
                {
#ifdef MBS_SUPPORT
                  if (mb_start < beg)
                    mb_start = beg;
                  if (MB_CUR_MAX == 1 || !is_mb_middle (&mb_start, match, buflim))
#endif
                    goto success;
                }
	      if (dfaexec (&dfa, beg, (char *) end, 0, NULL, &backref) == NULL)
		continue;
	    }
	  else
	    {
	      /* No good fixed strings; start with DFA. */
	      char const *next_beg = dfaexec (&dfa, beg, (char *) buflim,
					      0, NULL, &backref);
	      if (next_beg == NULL)
		break;
	      /* Narrow down to the line we've found. */
	      beg = next_beg;
	      if ((end = memchr(beg, eol, buflim - beg)) != NULL)
	        end++;
              else
                end = buflim;
	      while (beg > buf && beg[-1] != eol)
		--beg;
	    }
	  /* Successful, no backreferences encountered! */
	  if (!backref)
	    goto success;
	}
      else
	{
	  /* We are looking for the leftmost (then longest) exact match.
	     We will go through the outer loop only once.  */
	  beg = start_ptr;
	  end = buflim;
	}

      /* If we've made it to this point, this means DFA has seen
	 a probable match, and we need to run it through Regex. */
      best_match = end;
      best_len = 0;
      for (i = 0; i < pcount; i++)
	{
	  patterns[i].regexbuf.not_eol = 0;
	  if (0 <= (start = re_search (&(patterns[i].regexbuf),
				       buf, end - buf - 1,
				       beg - buf, end - beg - 1,
				       &(patterns[i].regs))))
	    {
	      len = patterns[i].regs.end[0] - start;
	      match = buf + start;
	      if (match > best_match)
		continue;
	      if (start_ptr && !match_words)
		goto assess_pattern_match;
	      if ((!match_lines && !match_words)
		  || (match_lines && len == end - beg - 1))
		{
		  match = beg;
		  len = end - beg;
		  goto assess_pattern_match;
		}
	      /* If -w, check if the match aligns with word boundaries.
		 We do this iteratively because:
		 (a) the line may contain more than one occurence of the
		 pattern, and
		 (b) Several alternatives in the pattern might be valid at a
		 given point, and we may need to consider a shorter one to
		 find a word boundary.  */
	      if (match_words)
		while (match <= best_match)
		  {
		    if ((match == buf || !WCHAR ((unsigned char) match[-1]))
			&& (len == end - beg - 1
			    || !WCHAR ((unsigned char) match[len])))
		      goto assess_pattern_match;
		    if (len > 0)
		      {
			/* Try a shorter length anchored at the same place. */
			--len;
			patterns[i].regexbuf.not_eol = 1;
			len = re_match (&(patterns[i].regexbuf),
					buf, match + len - beg, match - buf,
					&(patterns[i].regs));
		      }
		    if (len <= 0)
		      {
			/* Try looking further on. */
			if (match == end - 1)
			  break;
			match++;
			patterns[i].regexbuf.not_eol = 0;
			start = re_search (&(patterns[i].regexbuf),
					   buf, end - buf - 1,
					   match - buf, end - match - 1,
					   &(patterns[i].regs));
			if (start < 0)
			  break;
			len = patterns[i].regs.end[0] - start;
			match = buf + start;
		      }
		  } /* while (match <= best_match) */
	      continue;
	    assess_pattern_match:
	      if (!start_ptr)
		{
		  /* Good enough for a non-exact match.
		     No need to look at further patterns, if any.  */
		  beg = match;
		  goto success_in_len;
		}
	      if (match < best_match || (match == best_match && len > best_len))
		{
		  /* Best exact match:  leftmost, then longest.  */
		  best_match = match;
		  best_len = len;
		}
	    } /* if re_search >= 0 */
	} /* for Regex patterns.  */
	if (best_match < end)
	  {
	    /* We have found an exact match.  We were just
	       waiting for the best one (leftmost then longest).  */
	    beg = best_match;
	    len = best_len;
	    goto success_in_len;
	  }
    } /* for (beg = end ..) */

 failure:
  ret_val = -1;
  goto out;

 success:
  len = end - beg;
 success_in_len:
  *match_size = len;
  ret_val = beg - buf;
 out:
  return ret_val;
}

Building:src at:
/home/ubuntu/spr-fast/tests/corebench/grep/grep-case-8a025cf8-8f08d8e2/tempworkdir-l/srcMerged code building succ, going to invoke tester!
CondTester, Testing instance id 4:
//src_file:src/dfasearch.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); void* memset(void*, int, unsigned long); 
/* dfasearch.c - searching subroutines using dfa and regex for grep.
   Copyright 1992, 1998, 2000, 2007, 2009-2010 Free Software Foundation, Inc.

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 3, or (at your option)
   any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program; if not, write to the Free Software
   Foundation, Inc., 51 Franklin Street - Fifth Floor, Boston, MA
   02110-1301, USA.  */

/* Written August 1992 by Mike Haertel. */

#include <config.h>
#include "search.h"
#include "dfa.h"

/* For -w, we also consider _ to be word constituent.  */
#define WCHAR(C) (ISALNUM(C) || (C) == '_')

/* KWset compiled pattern.  For Ecompile and Gcompile, we compile
   a list of strings, at least one of which is known to occur in
   any string matching the regexp. */
static kwset_t kwset;

/* DFA compiled regexp. */
static struct dfa dfa;

/* The Regex compiled patterns.  */
static struct patterns
{
  /* Regex compiled regexp. */
  struct re_pattern_buffer regexbuf;
  struct re_registers regs; /* This is here on account of a BRAIN-DEAD
			       Q@#%!# library interface in regex.c.  */
} patterns0;

struct patterns *patterns;
size_t pcount;

void
dfaerror (char const *mesg)
{
  error (EXIT_TROUBLE, 0, "%s", mesg);

  /* notreached */
  /* Tell static analyzers that this function does not return.  */
  abort ();
}

/* Number of compiled fixed strings known to exactly match the regexp.
   If kwsexec returns < kwset_exact_matches, then we don't need to
   call the regexp matcher at all. */
static int kwset_exact_matches;

static char const *
kwsincr_case (const char *must)
{
  const char *buf;
  size_t n;

  n = strlen (must);
#ifdef MBS_SUPPORT
  if (match_icase && MB_CUR_MAX > 1)
    buf = mbtolower (must, &n);
  else
#endif
    buf = must;
  return kwsincr (kwset, buf, n);
}

/* If the DFA turns out to have some set of fixed strings one of
   which must occur in the match, then we build a kwset matcher
   to find those strings, and thus quickly filter out impossible
   matches. */
static void
kwsmusts (void)
{
  struct dfamust const *dm;
  char const *err;

  if (dfa.musts)
    {
      kwsinit (&kwset);
      /* First, we compile in the substrings known to be exact
	 matches.  The kwset matcher will return the index
	 of the matching string that it chooses. */
      for (dm = dfa.musts; dm; dm = dm->next)
	{
	  if (!dm->exact)
	    continue;
	  ++kwset_exact_matches;
	  if ((err = kwsincr_case (dm->must)) != NULL)
	    error (EXIT_TROUBLE, 0, "%s", err);
	}
      /* Now, we compile the substrings that will require
	 the use of the regexp matcher.  */
      for (dm = dfa.musts; dm; dm = dm->next)
	{
	  if (dm->exact)
	    continue;
	  if ((err = kwsincr_case (dm->must)) != NULL)
	    error (EXIT_TROUBLE, 0, "%s", err);
	}
      if ((err = kwsprep (kwset)) != NULL)
	error (EXIT_TROUBLE, 0, "%s", err);
    }
}

void
GEAcompile (char const *pattern, size_t size, reg_syntax_t syntax_bits)
{
  const char *err;
  const char *p, *sep;
  size_t total = size;
  char *motif;

  if (match_icase)
    syntax_bits |= RE_ICASE;
  re_set_syntax (syntax_bits);
  dfasyntax (syntax_bits, match_icase, eolbyte);

  /* For GNU regex compiler we have to pass the patterns separately to detect
     errors like "[\nallo\n]\n".  The patterns here are "[", "allo" and "]"
     GNU regex should have raise a syntax error.  The same for backref, where
     the backref should have been local to each pattern.  */
  p = pattern;
  do
    {
      size_t len;
      sep = memchr (p, '\n', total);
      if (sep)
	{
	  len = sep - p;
	  sep++;
	  total -= (len + 1);
	}
      else
	{
	  len = total;
	  total = 0;
	}

      patterns = realloc (patterns, (pcount + 1) * sizeof (*patterns));
      if (patterns == NULL)
	error (EXIT_TROUBLE, errno, _("memory exhausted"));
      patterns[pcount] = patterns0;

      if ((err = re_compile_pattern (p, len,
				    &(patterns[pcount].regexbuf))) != NULL)
	error (EXIT_TROUBLE, 0, "%s", err);
      pcount++;

      p = sep;
    } while (sep && total != 0);

  /* In the match_words and match_lines cases, we use a different pattern
     for the DFA matcher that will quickly throw out cases that won't work.
     Then if DFA succeeds we do some hairy stuff using the regex matcher
     to decide whether the match should really count. */
  
//Patch 0:
if ((match_words || match_lines) && !(__is_neg(14, &(match_words), sizeof (match_words), &(match_lines), sizeof (match_lines), &(sep), sizeof (sep), &(total), sizeof (total), &(p), sizeof (p), &(pcount), sizeof (pcount), &(syntax_bits), sizeof (syntax_bits), &(err), sizeof (err), &(size), sizeof (size), &(patterns), sizeof (patterns), &(pattern), sizeof (pattern), &(motif), sizeof (motif), &(match_icase), sizeof (match_icase), &(eolbyte), sizeof (eolbyte)))) {
    static const char line_beg_no_bk[] = "^(";
    static const char line_end_no_bk[] = ")$";
    static const char word_beg_no_bk[] = "(^|[^[:alnum:]_])(";
    static const char word_end_no_bk[] = ")([^[:alnum:]_]|$)";
    static const char line_beg_bk[] = "^\\(";
    static const char line_end_bk[] = "\\)$";
    static const char word_beg_bk[] = "\\(^\\|[^[:alnum:]_]\\)\\(";
    static const char word_end_bk[] = "\\)\\([^[:alnum:]_]\\|$\\)";
    int bk = !(syntax_bits & (((((((((((((((unsigned long)1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1));
    char *n = xmalloc(sizeof word_beg_bk - 1 + size + sizeof word_end_bk);
    strcpy(n, match_lines ? (bk ? line_beg_bk : line_beg_no_bk) : (bk ? word_beg_bk : word_beg_no_bk));
    total = strlen(n);
    memcpy(n + total, pattern, size);
    total += size;
    strcpy(n + total, match_lines ? (bk ? line_end_bk : line_end_no_bk) : (bk ? word_end_bk : word_end_no_bk));
    total += strlen(n + total);
    pattern = motif = n;
    size = total;
} else
    motif = ((void *)0);

//CodeSeg 1:

  dfacomp (pattern, size, &dfa, 1);
  kwsmusts ();

  free(motif);
}

size_t
EGexecute (char const *buf, size_t size, size_t *match_size,
	   char const *start_ptr)
{
  char const *buflim, *beg, *end, *match, *best_match, *mb_start;
  char eol = eolbyte;
  int backref, start, len, best_len;
  struct kwsmatch kwsm;
  size_t i, ret_val;
#ifdef MBS_SUPPORT
  if (MB_CUR_MAX > 1)
    {
      if (match_icase)
        {
          /* mbtolower adds a NUL byte at the end.  That will provide
	     space for the sentinel byte dfaexec may add.  */
          char *case_buf = mbtolower (buf, &size);
	  if (start_ptr)
	    start_ptr = case_buf + (start_ptr - buf);
          buf = case_buf;
        }
    }
#endif /* MBS_SUPPORT */

  mb_start = buf;
  buflim = buf + size;

  for (beg = end = buf; end < buflim; beg = end)
    {
      if (!start_ptr)
	{
	  /* We don't care about an exact match.  */
	  if (kwset)
	    {
	      /* Find a possible match using the KWset matcher. */
	      size_t offset = kwsexec (kwset, beg, buflim - beg, &kwsm);
	      if (offset == (size_t) -1)
		goto failure;
	      beg += offset;
	      /* Narrow down to the line containing the candidate, and
		 run it through DFA. */
	      if ((end = memchr(beg, eol, buflim - beg)) != NULL)
	        end++;
              else
                end = buflim;
	      match = beg;
	      while (beg > buf && beg[-1] != eol)
		--beg;
	      if (kwsm.index < kwset_exact_matches)
                {
#ifdef MBS_SUPPORT
                  if (mb_start < beg)
                    mb_start = beg;
                  if (MB_CUR_MAX == 1 || !is_mb_middle (&mb_start, match, buflim))
#endif
                    goto success;
                }
	      if (dfaexec (&dfa, beg, (char *) end, 0, NULL, &backref) == NULL)
		continue;
	    }
	  else
	    {
	      /* No good fixed strings; start with DFA. */
	      char const *next_beg = dfaexec (&dfa, beg, (char *) buflim,
					      0, NULL, &backref);
	      if (next_beg == NULL)
		break;
	      /* Narrow down to the line we've found. */
	      beg = next_beg;
	      if ((end = memchr(beg, eol, buflim - beg)) != NULL)
	        end++;
              else
                end = buflim;
	      while (beg > buf && beg[-1] != eol)
		--beg;
	    }
	  /* Successful, no backreferences encountered! */
	  if (!backref)
	    goto success;
	}
      else
	{
	  /* We are looking for the leftmost (then longest) exact match.
	     We will go through the outer loop only once.  */
	  beg = start_ptr;
	  end = buflim;
	}

      /* If we've made it to this point, this means DFA has seen
	 a probable match, and we need to run it through Regex. */
      best_match = end;
      best_len = 0;
      for (i = 0; i < pcount; i++)
	{
	  patterns[i].regexbuf.not_eol = 0;
	  if (0 <= (start = re_search (&(patterns[i].regexbuf),
				       buf, end - buf - 1,
				       beg - buf, end - beg - 1,
				       &(patterns[i].regs))))
	    {
	      len = patterns[i].regs.end[0] - start;
	      match = buf + start;
	      if (match > best_match)
		continue;
	      if (start_ptr && !match_words)
		goto assess_pattern_match;
	      if ((!match_lines && !match_words)
		  || (match_lines && len == end - beg - 1))
		{
		  match = beg;
		  len = end - beg;
		  goto assess_pattern_match;
		}
	      /* If -w, check if the match aligns with word boundaries.
		 We do this iteratively because:
		 (a) the line may contain more than one occurence of the
		 pattern, and
		 (b) Several alternatives in the pattern might be valid at a
		 given point, and we may need to consider a shorter one to
		 find a word boundary.  */
	      if (match_words)
		while (match <= best_match)
		  {
		    if ((match == buf || !WCHAR ((unsigned char) match[-1]))
			&& (len == end - beg - 1
			    || !WCHAR ((unsigned char) match[len])))
		      goto assess_pattern_match;
		    if (len > 0)
		      {
			/* Try a shorter length anchored at the same place. */
			--len;
			patterns[i].regexbuf.not_eol = 1;
			len = re_match (&(patterns[i].regexbuf),
					buf, match + len - beg, match - buf,
					&(patterns[i].regs));
		      }
		    if (len <= 0)
		      {
			/* Try looking further on. */
			if (match == end - 1)
			  break;
			match++;
			patterns[i].regexbuf.not_eol = 0;
			start = re_search (&(patterns[i].regexbuf),
					   buf, end - buf - 1,
					   match - buf, end - match - 1,
					   &(patterns[i].regs));
			if (start < 0)
			  break;
			len = patterns[i].regs.end[0] - start;
			match = buf + start;
		      }
		  } /* while (match <= best_match) */
	      continue;
	    assess_pattern_match:
	      if (!start_ptr)
		{
		  /* Good enough for a non-exact match.
		     No need to look at further patterns, if any.  */
		  beg = match;
		  goto success_in_len;
		}
	      if (match < best_match || (match == best_match && len > best_len))
		{
		  /* Best exact match:  leftmost, then longest.  */
		  best_match = match;
		  best_len = len;
		}
	    } /* if re_search >= 0 */
	} /* for Regex patterns.  */
	if (best_match < end)
	  {
	    /* We have found an exact match.  We were just
	       waiting for the best one (leftmost then longest).  */
	    beg = best_match;
	    len = best_len;
	    goto success_in_len;
	  }
    } /* for (beg = end ..) */

 failure:
  ret_val = -1;
  goto out;

 success:
  len = end - beg;
 success_in_len:
  *match_size = len;
  ret_val = beg - buf;
 out:
  return ret_val;
}

Testing negative cases!
Testing 0 (with abstract condition) ENVIS_NEG
Iteration 0
Running test command:
/home/ubuntu/spr-fast/tools/grep-test.py /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-8a025cf8-8f08d8e2/tempworkdir-l/src /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-8a025cf8-8f08d8e2/tempworkdir-l/tests /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-8a025cf8-8f08d8e2/tempworkdir-l 0  > __res
Opening:/tmp/neg.tmp!
NegativeBRANCH RECORD/tmp/neg.tmp!
APPENDING TO ISNEG:/tmp/neg.tmp!
Branch 0: 0
Iteration 1
Running test command:
/home/ubuntu/spr-fast/tools/grep-test.py /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-8a025cf8-8f08d8e2/tempworkdir-l/src /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-8a025cf8-8f08d8e2/tempworkdir-l/tests /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-8a025cf8-8f08d8e2/tempworkdir-l 0  > __res
Opening:/tmp/neg.tmp!
NegativeBRANCH RECORD/tmp/neg.tmp!
APPENDING TO ISNEG:/tmp/neg.tmp!
Branch 0: 1
Running test command:
/home/ubuntu/spr-fast/tools/grep-test.py /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-8a025cf8-8f08d8e2/tempworkdir-l/src /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-8a025cf8-8f08d8e2/tempworkdir-l/tests /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-8a025cf8-8f08d8e2/tempworkdir-l 0  > __res
CondTester, Testing instance id 7:
//src_file:src/dfasearch.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); void* memset(void*, int, unsigned long); 
/* dfasearch.c - searching subroutines using dfa and regex for grep.
   Copyright 1992, 1998, 2000, 2007, 2009-2010 Free Software Foundation, Inc.

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 3, or (at your option)
   any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program; if not, write to the Free Software
   Foundation, Inc., 51 Franklin Street - Fifth Floor, Boston, MA
   02110-1301, USA.  */

/* Written August 1992 by Mike Haertel. */

#include <config.h>
#include "search.h"
#include "dfa.h"

/* For -w, we also consider _ to be word constituent.  */
#define WCHAR(C) (ISALNUM(C) || (C) == '_')

/* KWset compiled pattern.  For Ecompile and Gcompile, we compile
   a list of strings, at least one of which is known to occur in
   any string matching the regexp. */
static kwset_t kwset;

/* DFA compiled regexp. */
static struct dfa dfa;

/* The Regex compiled patterns.  */
static struct patterns
{
  /* Regex compiled regexp. */
  struct re_pattern_buffer regexbuf;
  struct re_registers regs; /* This is here on account of a BRAIN-DEAD
			       Q@#%!# library interface in regex.c.  */
} patterns0;

struct patterns *patterns;
size_t pcount;

void
dfaerror (char const *mesg)
{
  error (EXIT_TROUBLE, 0, "%s", mesg);

  /* notreached */
  /* Tell static analyzers that this function does not return.  */
  abort ();
}

/* Number of compiled fixed strings known to exactly match the regexp.
   If kwsexec returns < kwset_exact_matches, then we don't need to
   call the regexp matcher at all. */
static int kwset_exact_matches;

static char const *
kwsincr_case (const char *must)
{
  const char *buf;
  size_t n;

  n = strlen (must);
#ifdef MBS_SUPPORT
  if (match_icase && MB_CUR_MAX > 1)
    buf = mbtolower (must, &n);
  else
#endif
    buf = must;
  return kwsincr (kwset, buf, n);
}

/* If the DFA turns out to have some set of fixed strings one of
   which must occur in the match, then we build a kwset matcher
   to find those strings, and thus quickly filter out impossible
   matches. */
static void
kwsmusts (void)
{
  struct dfamust const *dm;
  char const *err;

  if (dfa.musts)
    {
      kwsinit (&kwset);
      /* First, we compile in the substrings known to be exact
	 matches.  The kwset matcher will return the index
	 of the matching string that it chooses. */
      for (dm = dfa.musts; dm; dm = dm->next)
	{
	  if (!dm->exact)
	    continue;
	  ++kwset_exact_matches;
	  if ((err = kwsincr_case (dm->must)) != NULL)
	    error (EXIT_TROUBLE, 0, "%s", err);
	}
      /* Now, we compile the substrings that will require
	 the use of the regexp matcher.  */
      for (dm = dfa.musts; dm; dm = dm->next)
	{
	  if (dm->exact)
	    continue;
	  if ((err = kwsincr_case (dm->must)) != NULL)
	    error (EXIT_TROUBLE, 0, "%s", err);
	}
      if ((err = kwsprep (kwset)) != NULL)
	error (EXIT_TROUBLE, 0, "%s", err);
    }
}

void
GEAcompile (char const *pattern, size_t size, reg_syntax_t syntax_bits)
{
  const char *err;
  const char *p, *sep;
  size_t total = size;
  char *motif;

  if (match_icase)
    syntax_bits |= RE_ICASE;
  re_set_syntax (syntax_bits);
  dfasyntax (syntax_bits, match_icase, eolbyte);

  /* For GNU regex compiler we have to pass the patterns separately to detect
     errors like "[\nallo\n]\n".  The patterns here are "[", "allo" and "]"
     GNU regex should have raise a syntax error.  The same for backref, where
     the backref should have been local to each pattern.  */
  p = pattern;
  do
    {
      size_t len;
      sep = memchr (p, '\n', total);
      if (sep)
	{
	  len = sep - p;
	  sep++;
	  total -= (len + 1);
	}
      else
	{
	  len = total;
	  total = 0;
	}

      patterns = realloc (patterns, (pcount + 1) * sizeof (*patterns));
      if (patterns == NULL)
	error (EXIT_TROUBLE, errno, _("memory exhausted"));
      patterns[pcount] = patterns0;

      if ((err = re_compile_pattern (p, len,
				    &(patterns[pcount].regexbuf))) != NULL)
	error (EXIT_TROUBLE, 0, "%s", err);
      pcount++;

      p = sep;
    } while (sep && total != 0);

  /* In the match_words and match_lines cases, we use a different pattern
     for the DFA matcher that will quickly throw out cases that won't work.
     Then if DFA succeeds we do some hairy stuff using the regex matcher
     to decide whether the match should really count. */
  
//Patch 0:
if ((match_words || match_lines) || (__is_neg(14, &(match_words), sizeof (match_words), &(match_lines), sizeof (match_lines), &(sep), sizeof (sep), &(total), sizeof (total), &(p), sizeof (p), &(pcount), sizeof (pcount), &(syntax_bits), sizeof (syntax_bits), &(err), sizeof (err), &(size), sizeof (size), &(patterns), sizeof (patterns), &(pattern), sizeof (pattern), &(motif), sizeof (motif), &(match_icase), sizeof (match_icase), &(eolbyte), sizeof (eolbyte)))) {
    static const char line_beg_no_bk[] = "^(";
    static const char line_end_no_bk[] = ")$";
    static const char word_beg_no_bk[] = "(^|[^[:alnum:]_])(";
    static const char word_end_no_bk[] = ")([^[:alnum:]_]|$)";
    static const char line_beg_bk[] = "^\\(";
    static const char line_end_bk[] = "\\)$";
    static const char word_beg_bk[] = "\\(^\\|[^[:alnum:]_]\\)\\(";
    static const char word_end_bk[] = "\\)\\([^[:alnum:]_]\\|$\\)";
    int bk = !(syntax_bits & (((((((((((((((unsigned long)1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1));
    char *n = xmalloc(sizeof word_beg_bk - 1 + size + sizeof word_end_bk);
    strcpy(n, match_lines ? (bk ? line_beg_bk : line_beg_no_bk) : (bk ? word_beg_bk : word_beg_no_bk));
    total = strlen(n);
    memcpy(n + total, pattern, size);
    total += size;
    strcpy(n + total, match_lines ? (bk ? line_end_bk : line_end_no_bk) : (bk ? word_end_bk : word_end_no_bk));
    total += strlen(n + total);
    pattern = motif = n;
    size = total;
} else
    motif = ((void *)0);

//CodeSeg 1:

  dfacomp (pattern, size, &dfa, 1);
  kwsmusts ();

  free(motif);
}

size_t
EGexecute (char const *buf, size_t size, size_t *match_size,
	   char const *start_ptr)
{
  char const *buflim, *beg, *end, *match, *best_match, *mb_start;
  char eol = eolbyte;
  int backref, start, len, best_len;
  struct kwsmatch kwsm;
  size_t i, ret_val;
#ifdef MBS_SUPPORT
  if (MB_CUR_MAX > 1)
    {
      if (match_icase)
        {
          /* mbtolower adds a NUL byte at the end.  That will provide
	     space for the sentinel byte dfaexec may add.  */
          char *case_buf = mbtolower (buf, &size);
	  if (start_ptr)
	    start_ptr = case_buf + (start_ptr - buf);
          buf = case_buf;
        }
    }
#endif /* MBS_SUPPORT */

  mb_start = buf;
  buflim = buf + size;

  for (beg = end = buf; end < buflim; beg = end)
    {
      if (!start_ptr)
	{
	  /* We don't care about an exact match.  */
	  if (kwset)
	    {
	      /* Find a possible match using the KWset matcher. */
	      size_t offset = kwsexec (kwset, beg, buflim - beg, &kwsm);
	      if (offset == (size_t) -1)
		goto failure;
	      beg += offset;
	      /* Narrow down to the line containing the candidate, and
		 run it through DFA. */
	      if ((end = memchr(beg, eol, buflim - beg)) != NULL)
	        end++;
              else
                end = buflim;
	      match = beg;
	      while (beg > buf && beg[-1] != eol)
		--beg;
	      if (kwsm.index < kwset_exact_matches)
                {
#ifdef MBS_SUPPORT
                  if (mb_start < beg)
                    mb_start = beg;
                  if (MB_CUR_MAX == 1 || !is_mb_middle (&mb_start, match, buflim))
#endif
                    goto success;
                }
	      if (dfaexec (&dfa, beg, (char *) end, 0, NULL, &backref) == NULL)
		continue;
	    }
	  else
	    {
	      /* No good fixed strings; start with DFA. */
	      char const *next_beg = dfaexec (&dfa, beg, (char *) buflim,
					      0, NULL, &backref);
	      if (next_beg == NULL)
		break;
	      /* Narrow down to the line we've found. */
	      beg = next_beg;
	      if ((end = memchr(beg, eol, buflim - beg)) != NULL)
	        end++;
              else
                end = buflim;
	      while (beg > buf && beg[-1] != eol)
		--beg;
	    }
	  /* Successful, no backreferences encountered! */
	  if (!backref)
	    goto success;
	}
      else
	{
	  /* We are looking for the leftmost (then longest) exact match.
	     We will go through the outer loop only once.  */
	  beg = start_ptr;
	  end = buflim;
	}

      /* If we've made it to this point, this means DFA has seen
	 a probable match, and we need to run it through Regex. */
      best_match = end;
      best_len = 0;
      for (i = 0; i < pcount; i++)
	{
	  patterns[i].regexbuf.not_eol = 0;
	  if (0 <= (start = re_search (&(patterns[i].regexbuf),
				       buf, end - buf - 1,
				       beg - buf, end - beg - 1,
				       &(patterns[i].regs))))
	    {
	      len = patterns[i].regs.end[0] - start;
	      match = buf + start;
	      if (match > best_match)
		continue;
	      if (start_ptr && !match_words)
		goto assess_pattern_match;
	      if ((!match_lines && !match_words)
		  || (match_lines && len == end - beg - 1))
		{
		  match = beg;
		  len = end - beg;
		  goto assess_pattern_match;
		}
	      /* If -w, check if the match aligns with word boundaries.
		 We do this iteratively because:
		 (a) the line may contain more than one occurence of the
		 pattern, and
		 (b) Several alternatives in the pattern might be valid at a
		 given point, and we may need to consider a shorter one to
		 find a word boundary.  */
	      if (match_words)
		while (match <= best_match)
		  {
		    if ((match == buf || !WCHAR ((unsigned char) match[-1]))
			&& (len == end - beg - 1
			    || !WCHAR ((unsigned char) match[len])))
		      goto assess_pattern_match;
		    if (len > 0)
		      {
			/* Try a shorter length anchored at the same place. */
			--len;
			patterns[i].regexbuf.not_eol = 1;
			len = re_match (&(patterns[i].regexbuf),
					buf, match + len - beg, match - buf,
					&(patterns[i].regs));
		      }
		    if (len <= 0)
		      {
			/* Try looking further on. */
			if (match == end - 1)
			  break;
			match++;
			patterns[i].regexbuf.not_eol = 0;
			start = re_search (&(patterns[i].regexbuf),
					   buf, end - buf - 1,
					   match - buf, end - match - 1,
					   &(patterns[i].regs));
			if (start < 0)
			  break;
			len = patterns[i].regs.end[0] - start;
			match = buf + start;
		      }
		  } /* while (match <= best_match) */
	      continue;
	    assess_pattern_match:
	      if (!start_ptr)
		{
		  /* Good enough for a non-exact match.
		     No need to look at further patterns, if any.  */
		  beg = match;
		  goto success_in_len;
		}
	      if (match < best_match || (match == best_match && len > best_len))
		{
		  /* Best exact match:  leftmost, then longest.  */
		  best_match = match;
		  best_len = len;
		}
	    } /* if re_search >= 0 */
	} /* for Regex patterns.  */
	if (best_match < end)
	  {
	    /* We have found an exact match.  We were just
	       waiting for the best one (leftmost then longest).  */
	    beg = best_match;
	    len = best_len;
	    goto success_in_len;
	  }
    } /* for (beg = end ..) */

 failure:
  ret_val = -1;
  goto out;

 success:
  len = end - beg;
 success_in_len:
  *match_size = len;
  ret_val = beg - buf;
 out:
  return ret_val;
}

Testing negative cases!
Testing 0 (with abstract condition) ENVIS_NEG
Iteration 0
Running test command:
/home/ubuntu/spr-fast/tools/grep-test.py /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-8a025cf8-8f08d8e2/tempworkdir-l/src /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-8a025cf8-8f08d8e2/tempworkdir-l/tests /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-8a025cf8-8f08d8e2/tempworkdir-l 0  > __res
Opening:/tmp/neg.tmp!
NegativeBRANCH RECORD/tmp/neg.tmp!
Not caught by the negative case, give up!
APPENDING TO ISNEG:/tmp/neg.tmp!
Running test command:
/home/ubuntu/spr-fast/tools/grep-test.py /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-8a025cf8-8f08d8e2/tempworkdir-l/src /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-8a025cf8-8f08d8e2/tempworkdir-l/tests /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-8a025cf8-8f08d8e2/tempworkdir-l 0  > __res
a batched test job starts!
Building merged code:
src_file: src/dfasearch.c
full src: int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); void* memset(void*, int, unsigned long); 
/* dfasearch.c - searching subroutines using dfa and regex for grep.
   Copyright 1992, 1998, 2000, 2007, 2009-2010 Free Software Foundation, Inc.

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 3, or (at your option)
   any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program; if not, write to the Free Software
   Foundation, Inc., 51 Franklin Street - Fifth Floor, Boston, MA
   02110-1301, USA.  */

/* Written August 1992 by Mike Haertel. */

#include <config.h>
#include "search.h"
#include "dfa.h"

/* For -w, we also consider _ to be word constituent.  */
#define WCHAR(C) (ISALNUM(C) || (C) == '_')

/* KWset compiled pattern.  For Ecompile and Gcompile, we compile
   a list of strings, at least one of which is known to occur in
   any string matching the regexp. */
static kwset_t kwset;

/* DFA compiled regexp. */
static struct dfa dfa;

/* The Regex compiled patterns.  */
static struct patterns
{
  /* Regex compiled regexp. */
  struct re_pattern_buffer regexbuf;
  struct re_registers regs; /* This is here on account of a BRAIN-DEAD
			       Q@#%!# library interface in regex.c.  */
} patterns0;

struct patterns *patterns;
size_t pcount;

void
dfaerror (char const *mesg)
{
  error (EXIT_TROUBLE, 0, "%s", mesg);

  /* notreached */
  /* Tell static analyzers that this function does not return.  */
  abort ();
}

/* Number of compiled fixed strings known to exactly match the regexp.
   If kwsexec returns < kwset_exact_matches, then we don't need to
   call the regexp matcher at all. */
static int kwset_exact_matches;

static char const *
kwsincr_case (const char *must)
{
  const char *buf;
  size_t n;

  n = strlen (must);
#ifdef MBS_SUPPORT
  if (match_icase && MB_CUR_MAX > 1)
    buf = mbtolower (must, &n);
  else
#endif
    buf = must;
  return kwsincr (kwset, buf, n);
}

/* If the DFA turns out to have some set of fixed strings one of
   which must occur in the match, then we build a kwset matcher
   to find those strings, and thus quickly filter out impossible
   matches. */
static void
kwsmusts (void)
{
  struct dfamust const *dm;
  char const *err;

  if (dfa.musts)
    {
      kwsinit (&kwset);
      /* First, we compile in the substrings known to be exact
	 matches.  The kwset matcher will return the index
	 of the matching string that it chooses. */
      for (dm = dfa.musts; dm; dm = dm->next)
	{
	  if (!dm->exact)
	    continue;
	  ++kwset_exact_matches;
	  if ((err = kwsincr_case (dm->must)) != NULL)
	    error (EXIT_TROUBLE, 0, "%s", err);
	}
      /* Now, we compile the substrings that will require
	 the use of the regexp matcher.  */
      for (dm = dfa.musts; dm; dm = dm->next)
	{
	  if (dm->exact)
	    continue;
	  if ((err = kwsincr_case (dm->must)) != NULL)
	    error (EXIT_TROUBLE, 0, "%s", err);
	}
      if ((err = kwsprep (kwset)) != NULL)
	error (EXIT_TROUBLE, 0, "%s", err);
    }
}

void
GEAcompile (char const *pattern, size_t size, reg_syntax_t syntax_bits)
{
  const char *err;
  const char *p, *sep;
  size_t total = size;
  char *motif;

  if (match_icase)
    syntax_bits |= RE_ICASE;
  re_set_syntax (syntax_bits);
  dfasyntax (syntax_bits, match_icase, eolbyte);

  /* For GNU regex compiler we have to pass the patterns separately to detect
     errors like "[\nallo\n]\n".  The patterns here are "[", "allo" and "]"
     GNU regex should have raise a syntax error.  The same for backref, where
     the backref should have been local to each pattern.  */
  p = pattern;
  do
    {
      size_t len;
      sep = memchr (p, '\n', total);
      if (sep)
	{
	  len = sep - p;
	  sep++;
	  total -= (len + 1);
	}
      else
	{
	  len = total;
	  total = 0;
	}

      patterns = realloc (patterns, (pcount + 1) * sizeof (*patterns));
      if (patterns == NULL)
	error (EXIT_TROUBLE, errno, _("memory exhausted"));
      patterns[pcount] = patterns0;

      if ((err = re_compile_pattern (p, len,
				    &(patterns[pcount].regexbuf))) != NULL)
	error (EXIT_TROUBLE, 0, "%s", err);
      pcount++;

      p = sep;
    } while (sep && total != 0);

  /* In the match_words and match_lines cases, we use a different pattern
     for the DFA matcher that will quickly throw out cases that won't work.
     Then if DFA succeeds we do some hairy stuff using the regex matcher
     to decide whether the match should really count. */
  if (match_words || match_lines)
    {
      static char const line_beg_no_bk[] = "^(";
      static char const line_end_no_bk[] = ")$";
      static char const word_beg_no_bk[] = "(^|[^[:alnum:]_])(";
      static char const word_end_no_bk[] = ")([^[:alnum:]_]|$)";
      static char const line_beg_bk[] = "^\\(";
      static char const line_end_bk[] = "\\)$";
      static char const word_beg_bk[] = "\\(^\\|[^[:alnum:]_]\\)\\(";
      static char const word_end_bk[] = "\\)\\([^[:alnum:]_]\\|$\\)";
      int bk = !(syntax_bits & RE_NO_BK_PARENS);
      char *n = xmalloc (sizeof word_beg_bk - 1 + size + sizeof word_end_bk);

      strcpy (n, match_lines ? (bk ? line_beg_bk : line_beg_no_bk)
			     : (bk ? word_beg_bk : word_beg_no_bk));
      total = strlen(n);
      memcpy (n + total, pattern, size);
      total += size;
      strcpy (n + total, match_lines ? (bk ? line_end_bk : line_end_no_bk)
				     : (bk ? word_end_bk : word_end_no_bk));
      total += strlen (n + total);
      pattern = motif = n;
      size = total;
    }
  else
    motif = NULL;

  dfacomp (pattern, size, &dfa, 1);
  kwsmusts ();

  free(motif);
}

size_t
EGexecute (char const *buf, size_t size, size_t *match_size,
	   char const *start_ptr)
{
  char const *buflim, *beg, *end, *match, *best_match, *mb_start;
  char eol = eolbyte;
  int backref, start, len, best_len;
  struct kwsmatch kwsm;
  size_t i, ret_val;
#ifdef MBS_SUPPORT
  //prophet generated patch
  if (__get_mutant()==0) {
  if (((__ctype_get_mb_cur_max()) > 1) && !(__is_neg(25, &(match_icase), sizeof (match_icase), &(eolbyte), sizeof (eolbyte), &(buf), sizeof (buf), &(size), sizeof (size), &(start_ptr), sizeof (start_ptr), &(mb_start), sizeof (mb_start), &(buflim), sizeof (buflim), &(beg), sizeof (beg), &(end), sizeof (end), &(kwset), sizeof (kwset), &(eol), sizeof (eol), &(match), sizeof (match), &(kwset_exact_matches), sizeof (kwset_exact_matches), &(backref), sizeof (backref), &(best_match), sizeof (best_match), &(best_len), sizeof (best_len), &(i), sizeof (i), &(pcount), sizeof (pcount), &(patterns), sizeof (patterns), &(start), sizeof (start), &(len), sizeof (len), &(match_words), sizeof (match_words), &(match_lines), sizeof (match_lines), &(ret_val), sizeof (ret_val), &(match_size), sizeof (match_size)))) {
      if (match_icase) {
          char *case_buf = mbtolower(buf, &size);
          if (start_ptr)
              start_ptr = case_buf + (start_ptr - buf);
          buf = case_buf;
      }
  }
  }
  else if (__get_mutant()==1) {
  if (((__ctype_get_mb_cur_max()) > 1) || (__is_neg(25, &(match_icase), sizeof (match_icase), &(eolbyte), sizeof (eolbyte), &(buf), sizeof (buf), &(size), sizeof (size), &(start_ptr), sizeof (start_ptr), &(mb_start), sizeof (mb_start), &(buflim), sizeof (buflim), &(beg), sizeof (beg), &(end), sizeof (end), &(kwset), sizeof (kwset), &(eol), sizeof (eol), &(match), sizeof (match), &(kwset_exact_matches), sizeof (kwset_exact_matches), &(backref), sizeof (backref), &(best_match), sizeof (best_match), &(best_len), sizeof (best_len), &(i), sizeof (i), &(pcount), sizeof (pcount), &(patterns), sizeof (patterns), &(start), sizeof (start), &(len), sizeof (len), &(match_words), sizeof (match_words), &(match_lines), sizeof (match_lines), &(ret_val), sizeof (ret_val), &(match_size), sizeof (match_size)))) {
      if (match_icase) {
          char *case_buf = mbtolower(buf, &size);
          if (start_ptr)
              start_ptr = case_buf + (start_ptr - buf);
          buf = case_buf;
      }
  }
  }
  else if (__get_mutant()==2) {
  if ((__is_neg(25, &(match_icase), sizeof (match_icase), &(eolbyte), sizeof (eolbyte), &(buf), sizeof (buf), &(size), sizeof (size), &(start_ptr), sizeof (start_ptr), &(mb_start), sizeof (mb_start), &(buflim), sizeof (buflim), &(beg), sizeof (beg), &(end), sizeof (end), &(kwset), sizeof (kwset), &(eol), sizeof (eol), &(match), sizeof (match), &(kwset_exact_matches), sizeof (kwset_exact_matches), &(backref), sizeof (backref), &(best_match), sizeof (best_match), &(best_len), sizeof (best_len), &(i), sizeof (i), &(pcount), sizeof (pcount), &(patterns), sizeof (patterns), &(start), sizeof (start), &(len), sizeof (len), &(match_words), sizeof (match_words), &(match_lines), sizeof (match_lines), &(ret_val), sizeof (ret_val), &(match_size), sizeof (match_size))))
      return -1;
  if ((__ctype_get_mb_cur_max()) > 1) {
      if (match_icase) {
          char *case_buf = mbtolower(buf, &size);
          if (start_ptr)
              start_ptr = case_buf + (start_ptr - buf);
          buf = case_buf;
      }
  }
  }
  else if (__get_mutant()==3) {
  if ((__is_neg(25, &(match_icase), sizeof (match_icase), &(eolbyte), sizeof (eolbyte), &(buf), sizeof (buf), &(size), sizeof (size), &(start_ptr), sizeof (start_ptr), &(mb_start), sizeof (mb_start), &(buflim), sizeof (buflim), &(beg), sizeof (beg), &(end), sizeof (end), &(kwset), sizeof (kwset), &(eol), sizeof (eol), &(match), sizeof (match), &(kwset_exact_matches), sizeof (kwset_exact_matches), &(backref), sizeof (backref), &(best_match), sizeof (best_match), &(best_len), sizeof (best_len), &(i), sizeof (i), &(pcount), sizeof (pcount), &(patterns), sizeof (patterns), &(start), sizeof (start), &(len), sizeof (len), &(match_words), sizeof (match_words), &(match_lines), sizeof (match_lines), &(ret_val), sizeof (ret_val), &(match_size), sizeof (match_size))))
      return 0;
  if ((__ctype_get_mb_cur_max()) > 1) {
      if (match_icase) {
          char *case_buf = mbtolower(buf, &size);
          if (start_ptr)
              start_ptr = case_buf + (start_ptr - buf);
          buf = case_buf;
      }
  }
  }
  else if (__get_mutant()==4) {
  if ((__is_neg(25, &(match_icase), sizeof (match_icase), &(eolbyte), sizeof (eolbyte), &(buf), sizeof (buf), &(size), sizeof (size), &(start_ptr), sizeof (start_ptr), &(mb_start), sizeof (mb_start), &(buflim), sizeof (buflim), &(beg), sizeof (beg), &(end), sizeof (end), &(kwset), sizeof (kwset), &(eol), sizeof (eol), &(match), sizeof (match), &(kwset_exact_matches), sizeof (kwset_exact_matches), &(backref), sizeof (backref), &(best_match), sizeof (best_match), &(best_len), sizeof (best_len), &(i), sizeof (i), &(pcount), sizeof (pcount), &(patterns), sizeof (patterns), &(start), sizeof (start), &(len), sizeof (len), &(match_words), sizeof (match_words), &(match_lines), sizeof (match_lines), &(ret_val), sizeof (ret_val), &(match_size), sizeof (match_size))))
      return 1;
  if ((__ctype_get_mb_cur_max()) > 1) {
      if (match_icase) {
          char *case_buf = mbtolower(buf, &size);
          if (start_ptr)
              start_ptr = case_buf + (start_ptr - buf);
          buf = case_buf;
      }
  }
  }
#endif /* MBS_SUPPORT */

  mb_start = buf;
  buflim = buf + size;

  for (beg = end = buf; end < buflim; beg = end)
    {
      if (!start_ptr)
	{
	  /* We don't care about an exact match.  */
	  if (kwset)
	    {
	      /* Find a possible match using the KWset matcher. */
	      size_t offset = kwsexec (kwset, beg, buflim - beg, &kwsm);
	      if (offset == (size_t) -1)
		goto failure;
	      beg += offset;
	      /* Narrow down to the line containing the candidate, and
		 run it through DFA. */
	      if ((end = memchr(beg, eol, buflim - beg)) != NULL)
	        end++;
              else
                end = buflim;
	      match = beg;
	      while (beg > buf && beg[-1] != eol)
		--beg;
	      if (kwsm.index < kwset_exact_matches)
                {
#ifdef MBS_SUPPORT
                  if (mb_start < beg)
                    mb_start = beg;
                  if (MB_CUR_MAX == 1 || !is_mb_middle (&mb_start, match, buflim))
#endif
                    goto success;
                }
	      if (dfaexec (&dfa, beg, (char *) end, 0, NULL, &backref) == NULL)
		continue;
	    }
	  else
	    {
	      /* No good fixed strings; start with DFA. */
	      char const *next_beg = dfaexec (&dfa, beg, (char *) buflim,
					      0, NULL, &backref);
	      if (next_beg == NULL)
		break;
	      /* Narrow down to the line we've found. */
	      beg = next_beg;
	      if ((end = memchr(beg, eol, buflim - beg)) != NULL)
	        end++;
              else
                end = buflim;
	      while (beg > buf && beg[-1] != eol)
		--beg;
	    }
	  /* Successful, no backreferences encountered! */
	  if (!backref)
	    goto success;
	}
      else
	{
	  /* We are looking for the leftmost (then longest) exact match.
	     We will go through the outer loop only once.  */
	  beg = start_ptr;
	  end = buflim;
	}

      /* If we've made it to this point, this means DFA has seen
	 a probable match, and we need to run it through Regex. */
      best_match = end;
      best_len = 0;
      for (i = 0; i < pcount; i++)
	{
	  patterns[i].regexbuf.not_eol = 0;
	  if (0 <= (start = re_search (&(patterns[i].regexbuf),
				       buf, end - buf - 1,
				       beg - buf, end - beg - 1,
				       &(patterns[i].regs))))
	    {
	      len = patterns[i].regs.end[0] - start;
	      match = buf + start;
	      if (match > best_match)
		continue;
	      if (start_ptr && !match_words)
		goto assess_pattern_match;
	      if ((!match_lines && !match_words)
		  || (match_lines && len == end - beg - 1))
		{
		  match = beg;
		  len = end - beg;
		  goto assess_pattern_match;
		}
	      /* If -w, check if the match aligns with word boundaries.
		 We do this iteratively because:
		 (a) the line may contain more than one occurence of the
		 pattern, and
		 (b) Several alternatives in the pattern might be valid at a
		 given point, and we may need to consider a shorter one to
		 find a word boundary.  */
	      if (match_words)
		while (match <= best_match)
		  {
		    if ((match == buf || !WCHAR ((unsigned char) match[-1]))
			&& (len == end - beg - 1
			    || !WCHAR ((unsigned char) match[len])))
		      goto assess_pattern_match;
		    if (len > 0)
		      {
			/* Try a shorter length anchored at the same place. */
			--len;
			patterns[i].regexbuf.not_eol = 1;
			len = re_match (&(patterns[i].regexbuf),
					buf, match + len - beg, match - buf,
					&(patterns[i].regs));
		      }
		    if (len <= 0)
		      {
			/* Try looking further on. */
			if (match == end - 1)
			  break;
			match++;
			patterns[i].regexbuf.not_eol = 0;
			start = re_search (&(patterns[i].regexbuf),
					   buf, end - buf - 1,
					   match - buf, end - match - 1,
					   &(patterns[i].regs));
			if (start < 0)
			  break;
			len = patterns[i].regs.end[0] - start;
			match = buf + start;
		      }
		  } /* while (match <= best_match) */
	      continue;
	    assess_pattern_match:
	      if (!start_ptr)
		{
		  /* Good enough for a non-exact match.
		     No need to look at further patterns, if any.  */
		  beg = match;
		  goto success_in_len;
		}
	      if (match < best_match || (match == best_match && len > best_len))
		{
		  /* Best exact match:  leftmost, then longest.  */
		  best_match = match;
		  best_len = len;
		}
	    } /* if re_search >= 0 */
	} /* for Regex patterns.  */
	if (best_match < end)
	  {
	    /* We have found an exact match.  We were just
	       waiting for the best one (leftmost then longest).  */
	    beg = best_match;
	    len = best_len;
	    goto success_in_len;
	  }
    } /* for (beg = end ..) */

 failure:
  ret_val = -1;
  goto out;

 success:
  len = end - beg;
 success_in_len:
  *match_size = len;
  ret_val = beg - buf;
 out:
  return ret_val;
}

Building:src at:
/home/ubuntu/spr-fast/tests/corebench/grep/grep-case-8a025cf8-8f08d8e2/tempworkdir-l/srcMerged code building succ, going to invoke tester!
CondTester, Testing instance id 38:
//src_file:src/dfasearch.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); void* memset(void*, int, unsigned long); 
/* dfasearch.c - searching subroutines using dfa and regex for grep.
   Copyright 1992, 1998, 2000, 2007, 2009-2010 Free Software Foundation, Inc.

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 3, or (at your option)
   any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program; if not, write to the Free Software
   Foundation, Inc., 51 Franklin Street - Fifth Floor, Boston, MA
   02110-1301, USA.  */

/* Written August 1992 by Mike Haertel. */

#include <config.h>
#include "search.h"
#include "dfa.h"

/* For -w, we also consider _ to be word constituent.  */
#define WCHAR(C) (ISALNUM(C) || (C) == '_')

/* KWset compiled pattern.  For Ecompile and Gcompile, we compile
   a list of strings, at least one of which is known to occur in
   any string matching the regexp. */
static kwset_t kwset;

/* DFA compiled regexp. */
static struct dfa dfa;

/* The Regex compiled patterns.  */
static struct patterns
{
  /* Regex compiled regexp. */
  struct re_pattern_buffer regexbuf;
  struct re_registers regs; /* This is here on account of a BRAIN-DEAD
			       Q@#%!# library interface in regex.c.  */
} patterns0;

struct patterns *patterns;
size_t pcount;

void
dfaerror (char const *mesg)
{
  error (EXIT_TROUBLE, 0, "%s", mesg);

  /* notreached */
  /* Tell static analyzers that this function does not return.  */
  abort ();
}

/* Number of compiled fixed strings known to exactly match the regexp.
   If kwsexec returns < kwset_exact_matches, then we don't need to
   call the regexp matcher at all. */
static int kwset_exact_matches;

static char const *
kwsincr_case (const char *must)
{
  const char *buf;
  size_t n;

  n = strlen (must);
#ifdef MBS_SUPPORT
  if (match_icase && MB_CUR_MAX > 1)
    buf = mbtolower (must, &n);
  else
#endif
    buf = must;
  return kwsincr (kwset, buf, n);
}

/* If the DFA turns out to have some set of fixed strings one of
   which must occur in the match, then we build a kwset matcher
   to find those strings, and thus quickly filter out impossible
   matches. */
static void
kwsmusts (void)
{
  struct dfamust const *dm;
  char const *err;

  if (dfa.musts)
    {
      kwsinit (&kwset);
      /* First, we compile in the substrings known to be exact
	 matches.  The kwset matcher will return the index
	 of the matching string that it chooses. */
      for (dm = dfa.musts; dm; dm = dm->next)
	{
	  if (!dm->exact)
	    continue;
	  ++kwset_exact_matches;
	  if ((err = kwsincr_case (dm->must)) != NULL)
	    error (EXIT_TROUBLE, 0, "%s", err);
	}
      /* Now, we compile the substrings that will require
	 the use of the regexp matcher.  */
      for (dm = dfa.musts; dm; dm = dm->next)
	{
	  if (dm->exact)
	    continue;
	  if ((err = kwsincr_case (dm->must)) != NULL)
	    error (EXIT_TROUBLE, 0, "%s", err);
	}
      if ((err = kwsprep (kwset)) != NULL)
	error (EXIT_TROUBLE, 0, "%s", err);
    }
}

void
GEAcompile (char const *pattern, size_t size, reg_syntax_t syntax_bits)
{
  const char *err;
  const char *p, *sep;
  size_t total = size;
  char *motif;

  if (match_icase)
    syntax_bits |= RE_ICASE;
  re_set_syntax (syntax_bits);
  dfasyntax (syntax_bits, match_icase, eolbyte);

  /* For GNU regex compiler we have to pass the patterns separately to detect
     errors like "[\nallo\n]\n".  The patterns here are "[", "allo" and "]"
     GNU regex should have raise a syntax error.  The same for backref, where
     the backref should have been local to each pattern.  */
  p = pattern;
  do
    {
      size_t len;
      sep = memchr (p, '\n', total);
      if (sep)
	{
	  len = sep - p;
	  sep++;
	  total -= (len + 1);
	}
      else
	{
	  len = total;
	  total = 0;
	}

      patterns = realloc (patterns, (pcount + 1) * sizeof (*patterns));
      if (patterns == NULL)
	error (EXIT_TROUBLE, errno, _("memory exhausted"));
      patterns[pcount] = patterns0;

      if ((err = re_compile_pattern (p, len,
				    &(patterns[pcount].regexbuf))) != NULL)
	error (EXIT_TROUBLE, 0, "%s", err);
      pcount++;

      p = sep;
    } while (sep && total != 0);

  /* In the match_words and match_lines cases, we use a different pattern
     for the DFA matcher that will quickly throw out cases that won't work.
     Then if DFA succeeds we do some hairy stuff using the regex matcher
     to decide whether the match should really count. */
  if (match_words || match_lines)
    {
      static char const line_beg_no_bk[] = "^(";
      static char const line_end_no_bk[] = ")$";
      static char const word_beg_no_bk[] = "(^|[^[:alnum:]_])(";
      static char const word_end_no_bk[] = ")([^[:alnum:]_]|$)";
      static char const line_beg_bk[] = "^\\(";
      static char const line_end_bk[] = "\\)$";
      static char const word_beg_bk[] = "\\(^\\|[^[:alnum:]_]\\)\\(";
      static char const word_end_bk[] = "\\)\\([^[:alnum:]_]\\|$\\)";
      int bk = !(syntax_bits & RE_NO_BK_PARENS);
      char *n = xmalloc (sizeof word_beg_bk - 1 + size + sizeof word_end_bk);

      strcpy (n, match_lines ? (bk ? line_beg_bk : line_beg_no_bk)
			     : (bk ? word_beg_bk : word_beg_no_bk));
      total = strlen(n);
      memcpy (n + total, pattern, size);
      total += size;
      strcpy (n + total, match_lines ? (bk ? line_end_bk : line_end_no_bk)
				     : (bk ? word_end_bk : word_end_no_bk));
      total += strlen (n + total);
      pattern = motif = n;
      size = total;
    }
  else
    motif = NULL;

  dfacomp (pattern, size, &dfa, 1);
  kwsmusts ();

  free(motif);
}

size_t
EGexecute (char const *buf, size_t size, size_t *match_size,
	   char const *start_ptr)
{
  char const *buflim, *beg, *end, *match, *best_match, *mb_start;
  char eol = eolbyte;
  int backref, start, len, best_len;
  struct kwsmatch kwsm;
  size_t i, ret_val;
#ifdef MBS_SUPPORT
  
//Patch 0:
if (((__ctype_get_mb_cur_max()) > 1) && !(__is_neg(25, &(match_icase), sizeof (match_icase), &(eolbyte), sizeof (eolbyte), &(buf), sizeof (buf), &(size), sizeof (size), &(start_ptr), sizeof (start_ptr), &(mb_start), sizeof (mb_start), &(buflim), sizeof (buflim), &(beg), sizeof (beg), &(end), sizeof (end), &(kwset), sizeof (kwset), &(eol), sizeof (eol), &(match), sizeof (match), &(kwset_exact_matches), sizeof (kwset_exact_matches), &(backref), sizeof (backref), &(best_match), sizeof (best_match), &(best_len), sizeof (best_len), &(i), sizeof (i), &(pcount), sizeof (pcount), &(patterns), sizeof (patterns), &(start), sizeof (start), &(len), sizeof (len), &(match_words), sizeof (match_words), &(match_lines), sizeof (match_lines), &(ret_val), sizeof (ret_val), &(match_size), sizeof (match_size)))) {
    if (match_icase) {
        char *case_buf = mbtolower(buf, &size);
        if (start_ptr)
            start_ptr = case_buf + (start_ptr - buf);
        buf = case_buf;
    }
}

//CodeSeg 1:
#endif /* MBS_SUPPORT */

  mb_start = buf;
  buflim = buf + size;

  for (beg = end = buf; end < buflim; beg = end)
    {
      if (!start_ptr)
	{
	  /* We don't care about an exact match.  */
	  if (kwset)
	    {
	      /* Find a possible match using the KWset matcher. */
	      size_t offset = kwsexec (kwset, beg, buflim - beg, &kwsm);
	      if (offset == (size_t) -1)
		goto failure;
	      beg += offset;
	      /* Narrow down to the line containing the candidate, and
		 run it through DFA. */
	      if ((end = memchr(beg, eol, buflim - beg)) != NULL)
	        end++;
              else
                end = buflim;
	      match = beg;
	      while (beg > buf && beg[-1] != eol)
		--beg;
	      if (kwsm.index < kwset_exact_matches)
                {
#ifdef MBS_SUPPORT
                  if (mb_start < beg)
                    mb_start = beg;
                  if (MB_CUR_MAX == 1 || !is_mb_middle (&mb_start, match, buflim))
#endif
                    goto success;
                }
	      if (dfaexec (&dfa, beg, (char *) end, 0, NULL, &backref) == NULL)
		continue;
	    }
	  else
	    {
	      /* No good fixed strings; start with DFA. */
	      char const *next_beg = dfaexec (&dfa, beg, (char *) buflim,
					      0, NULL, &backref);
	      if (next_beg == NULL)
		break;
	      /* Narrow down to the line we've found. */
	      beg = next_beg;
	      if ((end = memchr(beg, eol, buflim - beg)) != NULL)
	        end++;
              else
                end = buflim;
	      while (beg > buf && beg[-1] != eol)
		--beg;
	    }
	  /* Successful, no backreferences encountered! */
	  if (!backref)
	    goto success;
	}
      else
	{
	  /* We are looking for the leftmost (then longest) exact match.
	     We will go through the outer loop only once.  */
	  beg = start_ptr;
	  end = buflim;
	}

      /* If we've made it to this point, this means DFA has seen
	 a probable match, and we need to run it through Regex. */
      best_match = end;
      best_len = 0;
      for (i = 0; i < pcount; i++)
	{
	  patterns[i].regexbuf.not_eol = 0;
	  if (0 <= (start = re_search (&(patterns[i].regexbuf),
				       buf, end - buf - 1,
				       beg - buf, end - beg - 1,
				       &(patterns[i].regs))))
	    {
	      len = patterns[i].regs.end[0] - start;
	      match = buf + start;
	      if (match > best_match)
		continue;
	      if (start_ptr && !match_words)
		goto assess_pattern_match;
	      if ((!match_lines && !match_words)
		  || (match_lines && len == end - beg - 1))
		{
		  match = beg;
		  len = end - beg;
		  goto assess_pattern_match;
		}
	      /* If -w, check if the match aligns with word boundaries.
		 We do this iteratively because:
		 (a) the line may contain more than one occurence of the
		 pattern, and
		 (b) Several alternatives in the pattern might be valid at a
		 given point, and we may need to consider a shorter one to
		 find a word boundary.  */
	      if (match_words)
		while (match <= best_match)
		  {
		    if ((match == buf || !WCHAR ((unsigned char) match[-1]))
			&& (len == end - beg - 1
			    || !WCHAR ((unsigned char) match[len])))
		      goto assess_pattern_match;
		    if (len > 0)
		      {
			/* Try a shorter length anchored at the same place. */
			--len;
			patterns[i].regexbuf.not_eol = 1;
			len = re_match (&(patterns[i].regexbuf),
					buf, match + len - beg, match - buf,
					&(patterns[i].regs));
		      }
		    if (len <= 0)
		      {
			/* Try looking further on. */
			if (match == end - 1)
			  break;
			match++;
			patterns[i].regexbuf.not_eol = 0;
			start = re_search (&(patterns[i].regexbuf),
					   buf, end - buf - 1,
					   match - buf, end - match - 1,
					   &(patterns[i].regs));
			if (start < 0)
			  break;
			len = patterns[i].regs.end[0] - start;
			match = buf + start;
		      }
		  } /* while (match <= best_match) */
	      continue;
	    assess_pattern_match:
	      if (!start_ptr)
		{
		  /* Good enough for a non-exact match.
		     No need to look at further patterns, if any.  */
		  beg = match;
		  goto success_in_len;
		}
	      if (match < best_match || (match == best_match && len > best_len))
		{
		  /* Best exact match:  leftmost, then longest.  */
		  best_match = match;
		  best_len = len;
		}
	    } /* if re_search >= 0 */
	} /* for Regex patterns.  */
	if (best_match < end)
	  {
	    /* We have found an exact match.  We were just
	       waiting for the best one (leftmost then longest).  */
	    beg = best_match;
	    len = best_len;
	    goto success_in_len;
	  }
    } /* for (beg = end ..) */

 failure:
  ret_val = -1;
  goto out;

 success:
  len = end - beg;
 success_in_len:
  *match_size = len;
  ret_val = beg - buf;
 out:
  return ret_val;
}

Testing negative cases!
Testing 0 (with abstract condition) ENVIS_NEG
Iteration 0
Running test command:
/home/ubuntu/spr-fast/tools/grep-test.py /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-8a025cf8-8f08d8e2/tempworkdir-l/src /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-8a025cf8-8f08d8e2/tempworkdir-l/tests /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-8a025cf8-8f08d8e2/tempworkdir-l 0  > __res
Opening:/tmp/neg.tmp!
NegativeBRANCH RECORD/tmp/neg.tmp!
APPENDING TO ISNEG:/tmp/neg.tmp!
Branch 0: 0
Branch 1: 0
Iteration 1
Running test command:
/home/ubuntu/spr-fast/tools/grep-test.py /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-8a025cf8-8f08d8e2/tempworkdir-l/src /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-8a025cf8-8f08d8e2/tempworkdir-l/tests /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-8a025cf8-8f08d8e2/tempworkdir-l 0  > __res
Opening:/tmp/neg.tmp!
NegativeBRANCH RECORD/tmp/neg.tmp!
APPENDING TO ISNEG:/tmp/neg.tmp!
Branch 0: 0
Branch 1: 1
Iteration 2
Running test command:
/home/ubuntu/spr-fast/tools/grep-test.py /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-8a025cf8-8f08d8e2/tempworkdir-l/src /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-8a025cf8-8f08d8e2/tempworkdir-l/tests /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-8a025cf8-8f08d8e2/tempworkdir-l 0  > __res
Opening:/tmp/neg.tmp!
NegativeBRANCH RECORD/tmp/neg.tmp!
APPENDING TO ISNEG:/tmp/neg.tmp!
Branch 0: 1
Branch 1: 0
Iteration 3
Running test command:
/home/ubuntu/spr-fast/tools/grep-test.py /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-8a025cf8-8f08d8e2/tempworkdir-l/src /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-8a025cf8-8f08d8e2/tempworkdir-l/tests /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-8a025cf8-8f08d8e2/tempworkdir-l 0  > __res
Opening:/tmp/neg.tmp!
NegativeBRANCH RECORD/tmp/neg.tmp!
APPENDING TO ISNEG:/tmp/neg.tmp!
Branch 0: 1
Branch 1: 1
Running test command:
/home/ubuntu/spr-fast/tools/grep-test.py /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-8a025cf8-8f08d8e2/tempworkdir-l/src /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-8a025cf8-8f08d8e2/tempworkdir-l/tests /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-8a025cf8-8f08d8e2/tempworkdir-l 0  > __res
CondTester, Testing instance id 39:
//src_file:src/dfasearch.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); void* memset(void*, int, unsigned long); 
/* dfasearch.c - searching subroutines using dfa and regex for grep.
   Copyright 1992, 1998, 2000, 2007, 2009-2010 Free Software Foundation, Inc.

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 3, or (at your option)
   any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program; if not, write to the Free Software
   Foundation, Inc., 51 Franklin Street - Fifth Floor, Boston, MA
   02110-1301, USA.  */

/* Written August 1992 by Mike Haertel. */

#include <config.h>
#include "search.h"
#include "dfa.h"

/* For -w, we also consider _ to be word constituent.  */
#define WCHAR(C) (ISALNUM(C) || (C) == '_')

/* KWset compiled pattern.  For Ecompile and Gcompile, we compile
   a list of strings, at least one of which is known to occur in
   any string matching the regexp. */
static kwset_t kwset;

/* DFA compiled regexp. */
static struct dfa dfa;

/* The Regex compiled patterns.  */
static struct patterns
{
  /* Regex compiled regexp. */
  struct re_pattern_buffer regexbuf;
  struct re_registers regs; /* This is here on account of a BRAIN-DEAD
			       Q@#%!# library interface in regex.c.  */
} patterns0;

struct patterns *patterns;
size_t pcount;

void
dfaerror (char const *mesg)
{
  error (EXIT_TROUBLE, 0, "%s", mesg);

  /* notreached */
  /* Tell static analyzers that this function does not return.  */
  abort ();
}

/* Number of compiled fixed strings known to exactly match the regexp.
   If kwsexec returns < kwset_exact_matches, then we don't need to
   call the regexp matcher at all. */
static int kwset_exact_matches;

static char const *
kwsincr_case (const char *must)
{
  const char *buf;
  size_t n;

  n = strlen (must);
#ifdef MBS_SUPPORT
  if (match_icase && MB_CUR_MAX > 1)
    buf = mbtolower (must, &n);
  else
#endif
    buf = must;
  return kwsincr (kwset, buf, n);
}

/* If the DFA turns out to have some set of fixed strings one of
   which must occur in the match, then we build a kwset matcher
   to find those strings, and thus quickly filter out impossible
   matches. */
static void
kwsmusts (void)
{
  struct dfamust const *dm;
  char const *err;

  if (dfa.musts)
    {
      kwsinit (&kwset);
      /* First, we compile in the substrings known to be exact
	 matches.  The kwset matcher will return the index
	 of the matching string that it chooses. */
      for (dm = dfa.musts; dm; dm = dm->next)
	{
	  if (!dm->exact)
	    continue;
	  ++kwset_exact_matches;
	  if ((err = kwsincr_case (dm->must)) != NULL)
	    error (EXIT_TROUBLE, 0, "%s", err);
	}
      /* Now, we compile the substrings that will require
	 the use of the regexp matcher.  */
      for (dm = dfa.musts; dm; dm = dm->next)
	{
	  if (dm->exact)
	    continue;
	  if ((err = kwsincr_case (dm->must)) != NULL)
	    error (EXIT_TROUBLE, 0, "%s", err);
	}
      if ((err = kwsprep (kwset)) != NULL)
	error (EXIT_TROUBLE, 0, "%s", err);
    }
}

void
GEAcompile (char const *pattern, size_t size, reg_syntax_t syntax_bits)
{
  const char *err;
  const char *p, *sep;
  size_t total = size;
  char *motif;

  if (match_icase)
    syntax_bits |= RE_ICASE;
  re_set_syntax (syntax_bits);
  dfasyntax (syntax_bits, match_icase, eolbyte);

  /* For GNU regex compiler we have to pass the patterns separately to detect
     errors like "[\nallo\n]\n".  The patterns here are "[", "allo" and "]"
     GNU regex should have raise a syntax error.  The same for backref, where
     the backref should have been local to each pattern.  */
  p = pattern;
  do
    {
      size_t len;
      sep = memchr (p, '\n', total);
      if (sep)
	{
	  len = sep - p;
	  sep++;
	  total -= (len + 1);
	}
      else
	{
	  len = total;
	  total = 0;
	}

      patterns = realloc (patterns, (pcount + 1) * sizeof (*patterns));
      if (patterns == NULL)
	error (EXIT_TROUBLE, errno, _("memory exhausted"));
      patterns[pcount] = patterns0;

      if ((err = re_compile_pattern (p, len,
				    &(patterns[pcount].regexbuf))) != NULL)
	error (EXIT_TROUBLE, 0, "%s", err);
      pcount++;

      p = sep;
    } while (sep && total != 0);

  /* In the match_words and match_lines cases, we use a different pattern
     for the DFA matcher that will quickly throw out cases that won't work.
     Then if DFA succeeds we do some hairy stuff using the regex matcher
     to decide whether the match should really count. */
  if (match_words || match_lines)
    {
      static char const line_beg_no_bk[] = "^(";
      static char const line_end_no_bk[] = ")$";
      static char const word_beg_no_bk[] = "(^|[^[:alnum:]_])(";
      static char const word_end_no_bk[] = ")([^[:alnum:]_]|$)";
      static char const line_beg_bk[] = "^\\(";
      static char const line_end_bk[] = "\\)$";
      static char const word_beg_bk[] = "\\(^\\|[^[:alnum:]_]\\)\\(";
      static char const word_end_bk[] = "\\)\\([^[:alnum:]_]\\|$\\)";
      int bk = !(syntax_bits & RE_NO_BK_PARENS);
      char *n = xmalloc (sizeof word_beg_bk - 1 + size + sizeof word_end_bk);

      strcpy (n, match_lines ? (bk ? line_beg_bk : line_beg_no_bk)
			     : (bk ? word_beg_bk : word_beg_no_bk));
      total = strlen(n);
      memcpy (n + total, pattern, size);
      total += size;
      strcpy (n + total, match_lines ? (bk ? line_end_bk : line_end_no_bk)
				     : (bk ? word_end_bk : word_end_no_bk));
      total += strlen (n + total);
      pattern = motif = n;
      size = total;
    }
  else
    motif = NULL;

  dfacomp (pattern, size, &dfa, 1);
  kwsmusts ();

  free(motif);
}

size_t
EGexecute (char const *buf, size_t size, size_t *match_size,
	   char const *start_ptr)
{
  char const *buflim, *beg, *end, *match, *best_match, *mb_start;
  char eol = eolbyte;
  int backref, start, len, best_len;
  struct kwsmatch kwsm;
  size_t i, ret_val;
#ifdef MBS_SUPPORT
  
//Patch 0:
if (((__ctype_get_mb_cur_max()) > 1) || (__is_neg(25, &(match_icase), sizeof (match_icase), &(eolbyte), sizeof (eolbyte), &(buf), sizeof (buf), &(size), sizeof (size), &(start_ptr), sizeof (start_ptr), &(mb_start), sizeof (mb_start), &(buflim), sizeof (buflim), &(beg), sizeof (beg), &(end), sizeof (end), &(kwset), sizeof (kwset), &(eol), sizeof (eol), &(match), sizeof (match), &(kwset_exact_matches), sizeof (kwset_exact_matches), &(backref), sizeof (backref), &(best_match), sizeof (best_match), &(best_len), sizeof (best_len), &(i), sizeof (i), &(pcount), sizeof (pcount), &(patterns), sizeof (patterns), &(start), sizeof (start), &(len), sizeof (len), &(match_words), sizeof (match_words), &(match_lines), sizeof (match_lines), &(ret_val), sizeof (ret_val), &(match_size), sizeof (match_size)))) {
    if (match_icase) {
        char *case_buf = mbtolower(buf, &size);
        if (start_ptr)
            start_ptr = case_buf + (start_ptr - buf);
        buf = case_buf;
    }
}

//CodeSeg 1:
#endif /* MBS_SUPPORT */

  mb_start = buf;
  buflim = buf + size;

  for (beg = end = buf; end < buflim; beg = end)
    {
      if (!start_ptr)
	{
	  /* We don't care about an exact match.  */
	  if (kwset)
	    {
	      /* Find a possible match using the KWset matcher. */
	      size_t offset = kwsexec (kwset, beg, buflim - beg, &kwsm);
	      if (offset == (size_t) -1)
		goto failure;
	      beg += offset;
	      /* Narrow down to the line containing the candidate, and
		 run it through DFA. */
	      if ((end = memchr(beg, eol, buflim - beg)) != NULL)
	        end++;
              else
                end = buflim;
	      match = beg;
	      while (beg > buf && beg[-1] != eol)
		--beg;
	      if (kwsm.index < kwset_exact_matches)
                {
#ifdef MBS_SUPPORT
                  if (mb_start < beg)
                    mb_start = beg;
                  if (MB_CUR_MAX == 1 || !is_mb_middle (&mb_start, match, buflim))
#endif
                    goto success;
                }
	      if (dfaexec (&dfa, beg, (char *) end, 0, NULL, &backref) == NULL)
		continue;
	    }
	  else
	    {
	      /* No good fixed strings; start with DFA. */
	      char const *next_beg = dfaexec (&dfa, beg, (char *) buflim,
					      0, NULL, &backref);
	      if (next_beg == NULL)
		break;
	      /* Narrow down to the line we've found. */
	      beg = next_beg;
	      if ((end = memchr(beg, eol, buflim - beg)) != NULL)
	        end++;
              else
                end = buflim;
	      while (beg > buf && beg[-1] != eol)
		--beg;
	    }
	  /* Successful, no backreferences encountered! */
	  if (!backref)
	    goto success;
	}
      else
	{
	  /* We are looking for the leftmost (then longest) exact match.
	     We will go through the outer loop only once.  */
	  beg = start_ptr;
	  end = buflim;
	}

      /* If we've made it to this point, this means DFA has seen
	 a probable match, and we need to run it through Regex. */
      best_match = end;
      best_len = 0;
      for (i = 0; i < pcount; i++)
	{
	  patterns[i].regexbuf.not_eol = 0;
	  if (0 <= (start = re_search (&(patterns[i].regexbuf),
				       buf, end - buf - 1,
				       beg - buf, end - beg - 1,
				       &(patterns[i].regs))))
	    {
	      len = patterns[i].regs.end[0] - start;
	      match = buf + start;
	      if (match > best_match)
		continue;
	      if (start_ptr && !match_words)
		goto assess_pattern_match;
	      if ((!match_lines && !match_words)
		  || (match_lines && len == end - beg - 1))
		{
		  match = beg;
		  len = end - beg;
		  goto assess_pattern_match;
		}
	      /* If -w, check if the match aligns with word boundaries.
		 We do this iteratively because:
		 (a) the line may contain more than one occurence of the
		 pattern, and
		 (b) Several alternatives in the pattern might be valid at a
		 given point, and we may need to consider a shorter one to
		 find a word boundary.  */
	      if (match_words)
		while (match <= best_match)
		  {
		    if ((match == buf || !WCHAR ((unsigned char) match[-1]))
			&& (len == end - beg - 1
			    || !WCHAR ((unsigned char) match[len])))
		      goto assess_pattern_match;
		    if (len > 0)
		      {
			/* Try a shorter length anchored at the same place. */
			--len;
			patterns[i].regexbuf.not_eol = 1;
			len = re_match (&(patterns[i].regexbuf),
					buf, match + len - beg, match - buf,
					&(patterns[i].regs));
		      }
		    if (len <= 0)
		      {
			/* Try looking further on. */
			if (match == end - 1)
			  break;
			match++;
			patterns[i].regexbuf.not_eol = 0;
			start = re_search (&(patterns[i].regexbuf),
					   buf, end - buf - 1,
					   match - buf, end - match - 1,
					   &(patterns[i].regs));
			if (start < 0)
			  break;
			len = patterns[i].regs.end[0] - start;
			match = buf + start;
		      }
		  } /* while (match <= best_match) */
	      continue;
	    assess_pattern_match:
	      if (!start_ptr)
		{
		  /* Good enough for a non-exact match.
		     No need to look at further patterns, if any.  */
		  beg = match;
		  goto success_in_len;
		}
	      if (match < best_match || (match == best_match && len > best_len))
		{
		  /* Best exact match:  leftmost, then longest.  */
		  best_match = match;
		  best_len = len;
		}
	    } /* if re_search >= 0 */
	} /* for Regex patterns.  */
	if (best_match < end)
	  {
	    /* We have found an exact match.  We were just
	       waiting for the best one (leftmost then longest).  */
	    beg = best_match;
	    len = best_len;
	    goto success_in_len;
	  }
    } /* for (beg = end ..) */

 failure:
  ret_val = -1;
  goto out;

 success:
  len = end - beg;
 success_in_len:
  *match_size = len;
  ret_val = beg - buf;
 out:
  return ret_val;
}

Testing negative cases!
Testing 0 (with abstract condition) ENVIS_NEG
Iteration 0
Running test command:
/home/ubuntu/spr-fast/tools/grep-test.py /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-8a025cf8-8f08d8e2/tempworkdir-l/src /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-8a025cf8-8f08d8e2/tempworkdir-l/tests /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-8a025cf8-8f08d8e2/tempworkdir-l 0  > __res
Opening:/tmp/neg.tmp!
NegativeBRANCH RECORD/tmp/neg.tmp!
Not caught by the negative case, give up!
APPENDING TO ISNEG:/tmp/neg.tmp!
Running test command:
/home/ubuntu/spr-fast/tools/grep-test.py /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-8a025cf8-8f08d8e2/tempworkdir-l/src /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-8a025cf8-8f08d8e2/tempworkdir-l/tests /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-8a025cf8-8f08d8e2/tempworkdir-l 0  > __res
CondTester, Testing instance id 75:
//src_file:src/dfasearch.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); void* memset(void*, int, unsigned long); 
/* dfasearch.c - searching subroutines using dfa and regex for grep.
   Copyright 1992, 1998, 2000, 2007, 2009-2010 Free Software Foundation, Inc.

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 3, or (at your option)
   any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program; if not, write to the Free Software
   Foundation, Inc., 51 Franklin Street - Fifth Floor, Boston, MA
   02110-1301, USA.  */

/* Written August 1992 by Mike Haertel. */

#include <config.h>
#include "search.h"
#include "dfa.h"

/* For -w, we also consider _ to be word constituent.  */
#define WCHAR(C) (ISALNUM(C) || (C) == '_')

/* KWset compiled pattern.  For Ecompile and Gcompile, we compile
   a list of strings, at least one of which is known to occur in
   any string matching the regexp. */
static kwset_t kwset;

/* DFA compiled regexp. */
static struct dfa dfa;

/* The Regex compiled patterns.  */
static struct patterns
{
  /* Regex compiled regexp. */
  struct re_pattern_buffer regexbuf;
  struct re_registers regs; /* This is here on account of a BRAIN-DEAD
			       Q@#%!# library interface in regex.c.  */
} patterns0;

struct patterns *patterns;
size_t pcount;

void
dfaerror (char const *mesg)
{
  error (EXIT_TROUBLE, 0, "%s", mesg);

  /* notreached */
  /* Tell static analyzers that this function does not return.  */
  abort ();
}

/* Number of compiled fixed strings known to exactly match the regexp.
   If kwsexec returns < kwset_exact_matches, then we don't need to
   call the regexp matcher at all. */
static int kwset_exact_matches;

static char const *
kwsincr_case (const char *must)
{
  const char *buf;
  size_t n;

  n = strlen (must);
#ifdef MBS_SUPPORT
  if (match_icase && MB_CUR_MAX > 1)
    buf = mbtolower (must, &n);
  else
#endif
    buf = must;
  return kwsincr (kwset, buf, n);
}

/* If the DFA turns out to have some set of fixed strings one of
   which must occur in the match, then we build a kwset matcher
   to find those strings, and thus quickly filter out impossible
   matches. */
static void
kwsmusts (void)
{
  struct dfamust const *dm;
  char const *err;

  if (dfa.musts)
    {
      kwsinit (&kwset);
      /* First, we compile in the substrings known to be exact
	 matches.  The kwset matcher will return the index
	 of the matching string that it chooses. */
      for (dm = dfa.musts; dm; dm = dm->next)
	{
	  if (!dm->exact)
	    continue;
	  ++kwset_exact_matches;
	  if ((err = kwsincr_case (dm->must)) != NULL)
	    error (EXIT_TROUBLE, 0, "%s", err);
	}
      /* Now, we compile the substrings that will require
	 the use of the regexp matcher.  */
      for (dm = dfa.musts; dm; dm = dm->next)
	{
	  if (dm->exact)
	    continue;
	  if ((err = kwsincr_case (dm->must)) != NULL)
	    error (EXIT_TROUBLE, 0, "%s", err);
	}
      if ((err = kwsprep (kwset)) != NULL)
	error (EXIT_TROUBLE, 0, "%s", err);
    }
}

void
GEAcompile (char const *pattern, size_t size, reg_syntax_t syntax_bits)
{
  const char *err;
  const char *p, *sep;
  size_t total = size;
  char *motif;

  if (match_icase)
    syntax_bits |= RE_ICASE;
  re_set_syntax (syntax_bits);
  dfasyntax (syntax_bits, match_icase, eolbyte);

  /* For GNU regex compiler we have to pass the patterns separately to detect
     errors like "[\nallo\n]\n".  The patterns here are "[", "allo" and "]"
     GNU regex should have raise a syntax error.  The same for backref, where
     the backref should have been local to each pattern.  */
  p = pattern;
  do
    {
      size_t len;
      sep = memchr (p, '\n', total);
      if (sep)
	{
	  len = sep - p;
	  sep++;
	  total -= (len + 1);
	}
      else
	{
	  len = total;
	  total = 0;
	}

      patterns = realloc (patterns, (pcount + 1) * sizeof (*patterns));
      if (patterns == NULL)
	error (EXIT_TROUBLE, errno, _("memory exhausted"));
      patterns[pcount] = patterns0;

      if ((err = re_compile_pattern (p, len,
				    &(patterns[pcount].regexbuf))) != NULL)
	error (EXIT_TROUBLE, 0, "%s", err);
      pcount++;

      p = sep;
    } while (sep && total != 0);

  /* In the match_words and match_lines cases, we use a different pattern
     for the DFA matcher that will quickly throw out cases that won't work.
     Then if DFA succeeds we do some hairy stuff using the regex matcher
     to decide whether the match should really count. */
  if (match_words || match_lines)
    {
      static char const line_beg_no_bk[] = "^(";
      static char const line_end_no_bk[] = ")$";
      static char const word_beg_no_bk[] = "(^|[^[:alnum:]_])(";
      static char const word_end_no_bk[] = ")([^[:alnum:]_]|$)";
      static char const line_beg_bk[] = "^\\(";
      static char const line_end_bk[] = "\\)$";
      static char const word_beg_bk[] = "\\(^\\|[^[:alnum:]_]\\)\\(";
      static char const word_end_bk[] = "\\)\\([^[:alnum:]_]\\|$\\)";
      int bk = !(syntax_bits & RE_NO_BK_PARENS);
      char *n = xmalloc (sizeof word_beg_bk - 1 + size + sizeof word_end_bk);

      strcpy (n, match_lines ? (bk ? line_beg_bk : line_beg_no_bk)
			     : (bk ? word_beg_bk : word_beg_no_bk));
      total = strlen(n);
      memcpy (n + total, pattern, size);
      total += size;
      strcpy (n + total, match_lines ? (bk ? line_end_bk : line_end_no_bk)
				     : (bk ? word_end_bk : word_end_no_bk));
      total += strlen (n + total);
      pattern = motif = n;
      size = total;
    }
  else
    motif = NULL;

  dfacomp (pattern, size, &dfa, 1);
  kwsmusts ();

  free(motif);
}

size_t
EGexecute (char const *buf, size_t size, size_t *match_size,
	   char const *start_ptr)
{
  char const *buflim, *beg, *end, *match, *best_match, *mb_start;
  char eol = eolbyte;
  int backref, start, len, best_len;
  struct kwsmatch kwsm;
  size_t i, ret_val;
#ifdef MBS_SUPPORT
  
//Patch 0:
if ((__is_neg(25, &(match_icase), sizeof (match_icase), &(eolbyte), sizeof (eolbyte), &(buf), sizeof (buf), &(size), sizeof (size), &(start_ptr), sizeof (start_ptr), &(mb_start), sizeof (mb_start), &(buflim), sizeof (buflim), &(beg), sizeof (beg), &(end), sizeof (end), &(kwset), sizeof (kwset), &(eol), sizeof (eol), &(match), sizeof (match), &(kwset_exact_matches), sizeof (kwset_exact_matches), &(backref), sizeof (backref), &(best_match), sizeof (best_match), &(best_len), sizeof (best_len), &(i), sizeof (i), &(pcount), sizeof (pcount), &(patterns), sizeof (patterns), &(start), sizeof (start), &(len), sizeof (len), &(match_words), sizeof (match_words), &(match_lines), sizeof (match_lines), &(ret_val), sizeof (ret_val), &(match_size), sizeof (match_size))))
    return -1;
if ((__ctype_get_mb_cur_max()) > 1) {
    if (match_icase) {
        char *case_buf = mbtolower(buf, &size);
        if (start_ptr)
            start_ptr = case_buf + (start_ptr - buf);
        buf = case_buf;
    }
}

//CodeSeg 1:
#endif /* MBS_SUPPORT */

  mb_start = buf;
  buflim = buf + size;

  for (beg = end = buf; end < buflim; beg = end)
    {
      if (!start_ptr)
	{
	  /* We don't care about an exact match.  */
	  if (kwset)
	    {
	      /* Find a possible match using the KWset matcher. */
	      size_t offset = kwsexec (kwset, beg, buflim - beg, &kwsm);
	      if (offset == (size_t) -1)
		goto failure;
	      beg += offset;
	      /* Narrow down to the line containing the candidate, and
		 run it through DFA. */
	      if ((end = memchr(beg, eol, buflim - beg)) != NULL)
	        end++;
              else
                end = buflim;
	      match = beg;
	      while (beg > buf && beg[-1] != eol)
		--beg;
	      if (kwsm.index < kwset_exact_matches)
                {
#ifdef MBS_SUPPORT
                  if (mb_start < beg)
                    mb_start = beg;
                  if (MB_CUR_MAX == 1 || !is_mb_middle (&mb_start, match, buflim))
#endif
                    goto success;
                }
	      if (dfaexec (&dfa, beg, (char *) end, 0, NULL, &backref) == NULL)
		continue;
	    }
	  else
	    {
	      /* No good fixed strings; start with DFA. */
	      char const *next_beg = dfaexec (&dfa, beg, (char *) buflim,
					      0, NULL, &backref);
	      if (next_beg == NULL)
		break;
	      /* Narrow down to the line we've found. */
	      beg = next_beg;
	      if ((end = memchr(beg, eol, buflim - beg)) != NULL)
	        end++;
              else
                end = buflim;
	      while (beg > buf && beg[-1] != eol)
		--beg;
	    }
	  /* Successful, no backreferences encountered! */
	  if (!backref)
	    goto success;
	}
      else
	{
	  /* We are looking for the leftmost (then longest) exact match.
	     We will go through the outer loop only once.  */
	  beg = start_ptr;
	  end = buflim;
	}

      /* If we've made it to this point, this means DFA has seen
	 a probable match, and we need to run it through Regex. */
      best_match = end;
      best_len = 0;
      for (i = 0; i < pcount; i++)
	{
	  patterns[i].regexbuf.not_eol = 0;
	  if (0 <= (start = re_search (&(patterns[i].regexbuf),
				       buf, end - buf - 1,
				       beg - buf, end - beg - 1,
				       &(patterns[i].regs))))
	    {
	      len = patterns[i].regs.end[0] - start;
	      match = buf + start;
	      if (match > best_match)
		continue;
	      if (start_ptr && !match_words)
		goto assess_pattern_match;
	      if ((!match_lines && !match_words)
		  || (match_lines && len == end - beg - 1))
		{
		  match = beg;
		  len = end - beg;
		  goto assess_pattern_match;
		}
	      /* If -w, check if the match aligns with word boundaries.
		 We do this iteratively because:
		 (a) the line may contain more than one occurence of the
		 pattern, and
		 (b) Several alternatives in the pattern might be valid at a
		 given point, and we may need to consider a shorter one to
		 find a word boundary.  */
	      if (match_words)
		while (match <= best_match)
		  {
		    if ((match == buf || !WCHAR ((unsigned char) match[-1]))
			&& (len == end - beg - 1
			    || !WCHAR ((unsigned char) match[len])))
		      goto assess_pattern_match;
		    if (len > 0)
		      {
			/* Try a shorter length anchored at the same place. */
			--len;
			patterns[i].regexbuf.not_eol = 1;
			len = re_match (&(patterns[i].regexbuf),
					buf, match + len - beg, match - buf,
					&(patterns[i].regs));
		      }
		    if (len <= 0)
		      {
			/* Try looking further on. */
			if (match == end - 1)
			  break;
			match++;
			patterns[i].regexbuf.not_eol = 0;
			start = re_search (&(patterns[i].regexbuf),
					   buf, end - buf - 1,
					   match - buf, end - match - 1,
					   &(patterns[i].regs));
			if (start < 0)
			  break;
			len = patterns[i].regs.end[0] - start;
			match = buf + start;
		      }
		  } /* while (match <= best_match) */
	      continue;
	    assess_pattern_match:
	      if (!start_ptr)
		{
		  /* Good enough for a non-exact match.
		     No need to look at further patterns, if any.  */
		  beg = match;
		  goto success_in_len;
		}
	      if (match < best_match || (match == best_match && len > best_len))
		{
		  /* Best exact match:  leftmost, then longest.  */
		  best_match = match;
		  best_len = len;
		}
	    } /* if re_search >= 0 */
	} /* for Regex patterns.  */
	if (best_match < end)
	  {
	    /* We have found an exact match.  We were just
	       waiting for the best one (leftmost then longest).  */
	    beg = best_match;
	    len = best_len;
	    goto success_in_len;
	  }
    } /* for (beg = end ..) */

 failure:
  ret_val = -1;
  goto out;

 success:
  len = end - beg;
 success_in_len:
  *match_size = len;
  ret_val = beg - buf;
 out:
  return ret_val;
}

Testing negative cases!
Testing 0 (with abstract condition) ENVIS_NEG
Iteration 0
Running test command:
/home/ubuntu/spr-fast/tools/grep-test.py /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-8a025cf8-8f08d8e2/tempworkdir-l/src /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-8a025cf8-8f08d8e2/tempworkdir-l/tests /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-8a025cf8-8f08d8e2/tempworkdir-l 0  > __res
Opening:/tmp/neg.tmp!
NegativeBRANCH RECORD/tmp/neg.tmp!
APPENDING TO ISNEG:/tmp/neg.tmp!
Branch 0: 0
Branch 1: 0
Iteration 1
Running test command:
/home/ubuntu/spr-fast/tools/grep-test.py /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-8a025cf8-8f08d8e2/tempworkdir-l/src /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-8a025cf8-8f08d8e2/tempworkdir-l/tests /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-8a025cf8-8f08d8e2/tempworkdir-l 0  > __res
Opening:/tmp/neg.tmp!
NegativeBRANCH RECORD/tmp/neg.tmp!
APPENDING TO ISNEG:/tmp/neg.tmp!
Branch 0: 0
Branch 1: 1
Iteration 2
Running test command:
/home/ubuntu/spr-fast/tools/grep-test.py /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-8a025cf8-8f08d8e2/tempworkdir-l/src /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-8a025cf8-8f08d8e2/tempworkdir-l/tests /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-8a025cf8-8f08d8e2/tempworkdir-l 0  > __res
Opening:/tmp/neg.tmp!
NegativeBRANCH RECORD/tmp/neg.tmp!
APPENDING TO ISNEG:/tmp/neg.tmp!
Branch 0: 1
Running test command:
/home/ubuntu/spr-fast/tools/grep-test.py /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-8a025cf8-8f08d8e2/tempworkdir-l/src /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-8a025cf8-8f08d8e2/tempworkdir-l/tests /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-8a025cf8-8f08d8e2/tempworkdir-l 0  > __res
CondTester, Testing instance id 76:
//src_file:src/dfasearch.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); void* memset(void*, int, unsigned long); 
/* dfasearch.c - searching subroutines using dfa and regex for grep.
   Copyright 1992, 1998, 2000, 2007, 2009-2010 Free Software Foundation, Inc.

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 3, or (at your option)
   any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program; if not, write to the Free Software
   Foundation, Inc., 51 Franklin Street - Fifth Floor, Boston, MA
   02110-1301, USA.  */

/* Written August 1992 by Mike Haertel. */

#include <config.h>
#include "search.h"
#include "dfa.h"

/* For -w, we also consider _ to be word constituent.  */
#define WCHAR(C) (ISALNUM(C) || (C) == '_')

/* KWset compiled pattern.  For Ecompile and Gcompile, we compile
   a list of strings, at least one of which is known to occur in
   any string matching the regexp. */
static kwset_t kwset;

/* DFA compiled regexp. */
static struct dfa dfa;

/* The Regex compiled patterns.  */
static struct patterns
{
  /* Regex compiled regexp. */
  struct re_pattern_buffer regexbuf;
  struct re_registers regs; /* This is here on account of a BRAIN-DEAD
			       Q@#%!# library interface in regex.c.  */
} patterns0;

struct patterns *patterns;
size_t pcount;

void
dfaerror (char const *mesg)
{
  error (EXIT_TROUBLE, 0, "%s", mesg);

  /* notreached */
  /* Tell static analyzers that this function does not return.  */
  abort ();
}

/* Number of compiled fixed strings known to exactly match the regexp.
   If kwsexec returns < kwset_exact_matches, then we don't need to
   call the regexp matcher at all. */
static int kwset_exact_matches;

static char const *
kwsincr_case (const char *must)
{
  const char *buf;
  size_t n;

  n = strlen (must);
#ifdef MBS_SUPPORT
  if (match_icase && MB_CUR_MAX > 1)
    buf = mbtolower (must, &n);
  else
#endif
    buf = must;
  return kwsincr (kwset, buf, n);
}

/* If the DFA turns out to have some set of fixed strings one of
   which must occur in the match, then we build a kwset matcher
   to find those strings, and thus quickly filter out impossible
   matches. */
static void
kwsmusts (void)
{
  struct dfamust const *dm;
  char const *err;

  if (dfa.musts)
    {
      kwsinit (&kwset);
      /* First, we compile in the substrings known to be exact
	 matches.  The kwset matcher will return the index
	 of the matching string that it chooses. */
      for (dm = dfa.musts; dm; dm = dm->next)
	{
	  if (!dm->exact)
	    continue;
	  ++kwset_exact_matches;
	  if ((err = kwsincr_case (dm->must)) != NULL)
	    error (EXIT_TROUBLE, 0, "%s", err);
	}
      /* Now, we compile the substrings that will require
	 the use of the regexp matcher.  */
      for (dm = dfa.musts; dm; dm = dm->next)
	{
	  if (dm->exact)
	    continue;
	  if ((err = kwsincr_case (dm->must)) != NULL)
	    error (EXIT_TROUBLE, 0, "%s", err);
	}
      if ((err = kwsprep (kwset)) != NULL)
	error (EXIT_TROUBLE, 0, "%s", err);
    }
}

void
GEAcompile (char const *pattern, size_t size, reg_syntax_t syntax_bits)
{
  const char *err;
  const char *p, *sep;
  size_t total = size;
  char *motif;

  if (match_icase)
    syntax_bits |= RE_ICASE;
  re_set_syntax (syntax_bits);
  dfasyntax (syntax_bits, match_icase, eolbyte);

  /* For GNU regex compiler we have to pass the patterns separately to detect
     errors like "[\nallo\n]\n".  The patterns here are "[", "allo" and "]"
     GNU regex should have raise a syntax error.  The same for backref, where
     the backref should have been local to each pattern.  */
  p = pattern;
  do
    {
      size_t len;
      sep = memchr (p, '\n', total);
      if (sep)
	{
	  len = sep - p;
	  sep++;
	  total -= (len + 1);
	}
      else
	{
	  len = total;
	  total = 0;
	}

      patterns = realloc (patterns, (pcount + 1) * sizeof (*patterns));
      if (patterns == NULL)
	error (EXIT_TROUBLE, errno, _("memory exhausted"));
      patterns[pcount] = patterns0;

      if ((err = re_compile_pattern (p, len,
				    &(patterns[pcount].regexbuf))) != NULL)
	error (EXIT_TROUBLE, 0, "%s", err);
      pcount++;

      p = sep;
    } while (sep && total != 0);

  /* In the match_words and match_lines cases, we use a different pattern
     for the DFA matcher that will quickly throw out cases that won't work.
     Then if DFA succeeds we do some hairy stuff using the regex matcher
     to decide whether the match should really count. */
  if (match_words || match_lines)
    {
      static char const line_beg_no_bk[] = "^(";
      static char const line_end_no_bk[] = ")$";
      static char const word_beg_no_bk[] = "(^|[^[:alnum:]_])(";
      static char const word_end_no_bk[] = ")([^[:alnum:]_]|$)";
      static char const line_beg_bk[] = "^\\(";
      static char const line_end_bk[] = "\\)$";
      static char const word_beg_bk[] = "\\(^\\|[^[:alnum:]_]\\)\\(";
      static char const word_end_bk[] = "\\)\\([^[:alnum:]_]\\|$\\)";
      int bk = !(syntax_bits & RE_NO_BK_PARENS);
      char *n = xmalloc (sizeof word_beg_bk - 1 + size + sizeof word_end_bk);

      strcpy (n, match_lines ? (bk ? line_beg_bk : line_beg_no_bk)
			     : (bk ? word_beg_bk : word_beg_no_bk));
      total = strlen(n);
      memcpy (n + total, pattern, size);
      total += size;
      strcpy (n + total, match_lines ? (bk ? line_end_bk : line_end_no_bk)
				     : (bk ? word_end_bk : word_end_no_bk));
      total += strlen (n + total);
      pattern = motif = n;
      size = total;
    }
  else
    motif = NULL;

  dfacomp (pattern, size, &dfa, 1);
  kwsmusts ();

  free(motif);
}

size_t
EGexecute (char const *buf, size_t size, size_t *match_size,
	   char const *start_ptr)
{
  char const *buflim, *beg, *end, *match, *best_match, *mb_start;
  char eol = eolbyte;
  int backref, start, len, best_len;
  struct kwsmatch kwsm;
  size_t i, ret_val;
#ifdef MBS_SUPPORT
  
//Patch 0:
if ((__is_neg(25, &(match_icase), sizeof (match_icase), &(eolbyte), sizeof (eolbyte), &(buf), sizeof (buf), &(size), sizeof (size), &(start_ptr), sizeof (start_ptr), &(mb_start), sizeof (mb_start), &(buflim), sizeof (buflim), &(beg), sizeof (beg), &(end), sizeof (end), &(kwset), sizeof (kwset), &(eol), sizeof (eol), &(match), sizeof (match), &(kwset_exact_matches), sizeof (kwset_exact_matches), &(backref), sizeof (backref), &(best_match), sizeof (best_match), &(best_len), sizeof (best_len), &(i), sizeof (i), &(pcount), sizeof (pcount), &(patterns), sizeof (patterns), &(start), sizeof (start), &(len), sizeof (len), &(match_words), sizeof (match_words), &(match_lines), sizeof (match_lines), &(ret_val), sizeof (ret_val), &(match_size), sizeof (match_size))))
    return 0;
if ((__ctype_get_mb_cur_max()) > 1) {
    if (match_icase) {
        char *case_buf = mbtolower(buf, &size);
        if (start_ptr)
            start_ptr = case_buf + (start_ptr - buf);
        buf = case_buf;
    }
}

//CodeSeg 1:
#endif /* MBS_SUPPORT */

  mb_start = buf;
  buflim = buf + size;

  for (beg = end = buf; end < buflim; beg = end)
    {
      if (!start_ptr)
	{
	  /* We don't care about an exact match.  */
	  if (kwset)
	    {
	      /* Find a possible match using the KWset matcher. */
	      size_t offset = kwsexec (kwset, beg, buflim - beg, &kwsm);
	      if (offset == (size_t) -1)
		goto failure;
	      beg += offset;
	      /* Narrow down to the line containing the candidate, and
		 run it through DFA. */
	      if ((end = memchr(beg, eol, buflim - beg)) != NULL)
	        end++;
              else
                end = buflim;
	      match = beg;
	      while (beg > buf && beg[-1] != eol)
		--beg;
	      if (kwsm.index < kwset_exact_matches)
                {
#ifdef MBS_SUPPORT
                  if (mb_start < beg)
                    mb_start = beg;
                  if (MB_CUR_MAX == 1 || !is_mb_middle (&mb_start, match, buflim))
#endif
                    goto success;
                }
	      if (dfaexec (&dfa, beg, (char *) end, 0, NULL, &backref) == NULL)
		continue;
	    }
	  else
	    {
	      /* No good fixed strings; start with DFA. */
	      char const *next_beg = dfaexec (&dfa, beg, (char *) buflim,
					      0, NULL, &backref);
	      if (next_beg == NULL)
		break;
	      /* Narrow down to the line we've found. */
	      beg = next_beg;
	      if ((end = memchr(beg, eol, buflim - beg)) != NULL)
	        end++;
              else
                end = buflim;
	      while (beg > buf && beg[-1] != eol)
		--beg;
	    }
	  /* Successful, no backreferences encountered! */
	  if (!backref)
	    goto success;
	}
      else
	{
	  /* We are looking for the leftmost (then longest) exact match.
	     We will go through the outer loop only once.  */
	  beg = start_ptr;
	  end = buflim;
	}

      /* If we've made it to this point, this means DFA has seen
	 a probable match, and we need to run it through Regex. */
      best_match = end;
      best_len = 0;
      for (i = 0; i < pcount; i++)
	{
	  patterns[i].regexbuf.not_eol = 0;
	  if (0 <= (start = re_search (&(patterns[i].regexbuf),
				       buf, end - buf - 1,
				       beg - buf, end - beg - 1,
				       &(patterns[i].regs))))
	    {
	      len = patterns[i].regs.end[0] - start;
	      match = buf + start;
	      if (match > best_match)
		continue;
	      if (start_ptr && !match_words)
		goto assess_pattern_match;
	      if ((!match_lines && !match_words)
		  || (match_lines && len == end - beg - 1))
		{
		  match = beg;
		  len = end - beg;
		  goto assess_pattern_match;
		}
	      /* If -w, check if the match aligns with word boundaries.
		 We do this iteratively because:
		 (a) the line may contain more than one occurence of the
		 pattern, and
		 (b) Several alternatives in the pattern might be valid at a
		 given point, and we may need to consider a shorter one to
		 find a word boundary.  */
	      if (match_words)
		while (match <= best_match)
		  {
		    if ((match == buf || !WCHAR ((unsigned char) match[-1]))
			&& (len == end - beg - 1
			    || !WCHAR ((unsigned char) match[len])))
		      goto assess_pattern_match;
		    if (len > 0)
		      {
			/* Try a shorter length anchored at the same place. */
			--len;
			patterns[i].regexbuf.not_eol = 1;
			len = re_match (&(patterns[i].regexbuf),
					buf, match + len - beg, match - buf,
					&(patterns[i].regs));
		      }
		    if (len <= 0)
		      {
			/* Try looking further on. */
			if (match == end - 1)
			  break;
			match++;
			patterns[i].regexbuf.not_eol = 0;
			start = re_search (&(patterns[i].regexbuf),
					   buf, end - buf - 1,
					   match - buf, end - match - 1,
					   &(patterns[i].regs));
			if (start < 0)
			  break;
			len = patterns[i].regs.end[0] - start;
			match = buf + start;
		      }
		  } /* while (match <= best_match) */
	      continue;
	    assess_pattern_match:
	      if (!start_ptr)
		{
		  /* Good enough for a non-exact match.
		     No need to look at further patterns, if any.  */
		  beg = match;
		  goto success_in_len;
		}
	      if (match < best_match || (match == best_match && len > best_len))
		{
		  /* Best exact match:  leftmost, then longest.  */
		  best_match = match;
		  best_len = len;
		}
	    } /* if re_search >= 0 */
	} /* for Regex patterns.  */
	if (best_match < end)
	  {
	    /* We have found an exact match.  We were just
	       waiting for the best one (leftmost then longest).  */
	    beg = best_match;
	    len = best_len;
	    goto success_in_len;
	  }
    } /* for (beg = end ..) */

 failure:
  ret_val = -1;
  goto out;

 success:
  len = end - beg;
 success_in_len:
  *match_size = len;
  ret_val = beg - buf;
 out:
  return ret_val;
}

Testing negative cases!
Testing 0 (with abstract condition) ENVIS_NEG
Iteration 0
Running test command:
/home/ubuntu/spr-fast/tools/grep-test.py /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-8a025cf8-8f08d8e2/tempworkdir-l/src /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-8a025cf8-8f08d8e2/tempworkdir-l/tests /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-8a025cf8-8f08d8e2/tempworkdir-l 0  > __res
Opening:/tmp/neg.tmp!
NegativeBRANCH RECORD/tmp/neg.tmp!
APPENDING TO ISNEG:/tmp/neg.tmp!
Branch 0: 0
Branch 1: 0
Iteration 1
Running test command:
/home/ubuntu/spr-fast/tools/grep-test.py /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-8a025cf8-8f08d8e2/tempworkdir-l/src /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-8a025cf8-8f08d8e2/tempworkdir-l/tests /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-8a025cf8-8f08d8e2/tempworkdir-l 0  > __res
Opening:/tmp/neg.tmp!
NegativeBRANCH RECORD/tmp/neg.tmp!
APPENDING TO ISNEG:/tmp/neg.tmp!
Branch 0: 0
Branch 1: 1
Branch 2: 0
Iteration 2
Running test command:
/home/ubuntu/spr-fast/tools/grep-test.py /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-8a025cf8-8f08d8e2/tempworkdir-l/src /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-8a025cf8-8f08d8e2/tempworkdir-l/tests /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-8a025cf8-8f08d8e2/tempworkdir-l 0  > __res
Opening:/tmp/neg.tmp!
NegativeBRANCH RECORD/tmp/neg.tmp!
APPENDING TO ISNEG:/tmp/neg.tmp!
Branch 0: 0
Branch 1: 1
Branch 2: 1
Branch 3: 0
Iteration 3
Running test command:
/home/ubuntu/spr-fast/tools/grep-test.py /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-8a025cf8-8f08d8e2/tempworkdir-l/src /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-8a025cf8-8f08d8e2/tempworkdir-l/tests /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-8a025cf8-8f08d8e2/tempworkdir-l 0  > __res
Opening:/tmp/neg.tmp!
NegativeBRANCH RECORD/tmp/neg.tmp!
APPENDING TO ISNEG:/tmp/neg.tmp!
Branch 0: 0
Branch 1: 1
Branch 2: 1
Branch 3: 1
Branch 4: 0
Iteration 4
Running test command:
/home/ubuntu/spr-fast/tools/grep-test.py /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-8a025cf8-8f08d8e2/tempworkdir-l/src /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-8a025cf8-8f08d8e2/tempworkdir-l/tests /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-8a025cf8-8f08d8e2/tempworkdir-l 0  > __res
Opening:/tmp/neg.tmp!
NegativeBRANCH RECORD/tmp/neg.tmp!
APPENDING TO ISNEG:/tmp/neg.tmp!
Branch 0: 0
Branch 1: 1
Branch 2: 1
Branch 3: 1
Branch 4: 1
Branch 5: 0
Iteration 5
Running test command:
/home/ubuntu/spr-fast/tools/grep-test.py /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-8a025cf8-8f08d8e2/tempworkdir-l/src /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-8a025cf8-8f08d8e2/tempworkdir-l/tests /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-8a025cf8-8f08d8e2/tempworkdir-l 0  > __res
Opening:/tmp/neg.tmp!
NegativeBRANCH RECORD/tmp/neg.tmp!
APPENDING TO ISNEG:/tmp/neg.tmp!
Branch 0: 0
Branch 1: 1
Branch 2: 1
Branch 3: 1
Branch 4: 1
Branch 5: 1
Branch 6: 0
Iteration 6
Running test command:
/home/ubuntu/spr-fast/tools/grep-test.py /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-8a025cf8-8f08d8e2/tempworkdir-l/src /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-8a025cf8-8f08d8e2/tempworkdir-l/tests /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-8a025cf8-8f08d8e2/tempworkdir-l 0  > __res
Opening:/tmp/neg.tmp!
NegativeBRANCH RECORD/tmp/neg.tmp!
APPENDING TO ISNEG:/tmp/neg.tmp!
Branch 0: 0
Branch 1: 1
Branch 2: 1
Branch 3: 1
Branch 4: 1
Branch 5: 1
Branch 6: 1
Branch 7: 0
Iteration 7
Running test command:
/home/ubuntu/spr-fast/tools/grep-test.py /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-8a025cf8-8f08d8e2/tempworkdir-l/src /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-8a025cf8-8f08d8e2/tempworkdir-l/tests /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-8a025cf8-8f08d8e2/tempworkdir-l 0  > __res
Opening:/tmp/neg.tmp!
NegativeBRANCH RECORD/tmp/neg.tmp!
APPENDING TO ISNEG:/tmp/neg.tmp!
Branch 0: 0
Branch 1: 1
Branch 2: 1
Branch 3: 1
Branch 4: 1
Branch 5: 1
Branch 6: 1
Branch 7: 1
Branch 8: 0
Iteration 8
Running test command:
/home/ubuntu/spr-fast/tools/grep-test.py /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-8a025cf8-8f08d8e2/tempworkdir-l/src /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-8a025cf8-8f08d8e2/tempworkdir-l/tests /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-8a025cf8-8f08d8e2/tempworkdir-l 0  > __res
Opening:/tmp/neg.tmp!
NegativeBRANCH RECORD/tmp/neg.tmp!
APPENDING TO ISNEG:/tmp/neg.tmp!
Branch 0: 0
Branch 1: 1
Branch 2: 1
Branch 3: 1
Branch 4: 1
Branch 5: 1
Branch 6: 1
Branch 7: 1
Branch 8: 1
Branch 9: 0
Iteration 9
Running test command:
/home/ubuntu/spr-fast/tools/grep-test.py /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-8a025cf8-8f08d8e2/tempworkdir-l/src /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-8a025cf8-8f08d8e2/tempworkdir-l/tests /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-8a025cf8-8f08d8e2/tempworkdir-l 0  > __res
Opening:/tmp/neg.tmp!
NegativeBRANCH RECORD/tmp/neg.tmp!
APPENDING TO ISNEG:/tmp/neg.tmp!
Branch 0: 0
Branch 1: 1
Branch 2: 1
Branch 3: 1
Branch 4: 1
Branch 5: 1
Branch 6: 1
Branch 7: 1
Branch 8: 1
Branch 9: 1
Branch 10: 0
Running test command:
/home/ubuntu/spr-fast/tools/grep-test.py /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-8a025cf8-8f08d8e2/tempworkdir-l/src /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-8a025cf8-8f08d8e2/tempworkdir-l/tests /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-8a025cf8-8f08d8e2/tempworkdir-l 0  > __res
CondTester, Testing instance id 77:
//src_file:src/dfasearch.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); void* memset(void*, int, unsigned long); 
/* dfasearch.c - searching subroutines using dfa and regex for grep.
   Copyright 1992, 1998, 2000, 2007, 2009-2010 Free Software Foundation, Inc.

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 3, or (at your option)
   any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program; if not, write to the Free Software
   Foundation, Inc., 51 Franklin Street - Fifth Floor, Boston, MA
   02110-1301, USA.  */

/* Written August 1992 by Mike Haertel. */

#include <config.h>
#include "search.h"
#include "dfa.h"

/* For -w, we also consider _ to be word constituent.  */
#define WCHAR(C) (ISALNUM(C) || (C) == '_')

/* KWset compiled pattern.  For Ecompile and Gcompile, we compile
   a list of strings, at least one of which is known to occur in
   any string matching the regexp. */
static kwset_t kwset;

/* DFA compiled regexp. */
static struct dfa dfa;

/* The Regex compiled patterns.  */
static struct patterns
{
  /* Regex compiled regexp. */
  struct re_pattern_buffer regexbuf;
  struct re_registers regs; /* This is here on account of a BRAIN-DEAD
			       Q@#%!# library interface in regex.c.  */
} patterns0;

struct patterns *patterns;
size_t pcount;

void
dfaerror (char const *mesg)
{
  error (EXIT_TROUBLE, 0, "%s", mesg);

  /* notreached */
  /* Tell static analyzers that this function does not return.  */
  abort ();
}

/* Number of compiled fixed strings known to exactly match the regexp.
   If kwsexec returns < kwset_exact_matches, then we don't need to
   call the regexp matcher at all. */
static int kwset_exact_matches;

static char const *
kwsincr_case (const char *must)
{
  const char *buf;
  size_t n;

  n = strlen (must);
#ifdef MBS_SUPPORT
  if (match_icase && MB_CUR_MAX > 1)
    buf = mbtolower (must, &n);
  else
#endif
    buf = must;
  return kwsincr (kwset, buf, n);
}

/* If the DFA turns out to have some set of fixed strings one of
   which must occur in the match, then we build a kwset matcher
   to find those strings, and thus quickly filter out impossible
   matches. */
static void
kwsmusts (void)
{
  struct dfamust const *dm;
  char const *err;

  if (dfa.musts)
    {
      kwsinit (&kwset);
      /* First, we compile in the substrings known to be exact
	 matches.  The kwset matcher will return the index
	 of the matching string that it chooses. */
      for (dm = dfa.musts; dm; dm = dm->next)
	{
	  if (!dm->exact)
	    continue;
	  ++kwset_exact_matches;
	  if ((err = kwsincr_case (dm->must)) != NULL)
	    error (EXIT_TROUBLE, 0, "%s", err);
	}
      /* Now, we compile the substrings that will require
	 the use of the regexp matcher.  */
      for (dm = dfa.musts; dm; dm = dm->next)
	{
	  if (dm->exact)
	    continue;
	  if ((err = kwsincr_case (dm->must)) != NULL)
	    error (EXIT_TROUBLE, 0, "%s", err);
	}
      if ((err = kwsprep (kwset)) != NULL)
	error (EXIT_TROUBLE, 0, "%s", err);
    }
}

void
GEAcompile (char const *pattern, size_t size, reg_syntax_t syntax_bits)
{
  const char *err;
  const char *p, *sep;
  size_t total = size;
  char *motif;

  if (match_icase)
    syntax_bits |= RE_ICASE;
  re_set_syntax (syntax_bits);
  dfasyntax (syntax_bits, match_icase, eolbyte);

  /* For GNU regex compiler we have to pass the patterns separately to detect
     errors like "[\nallo\n]\n".  The patterns here are "[", "allo" and "]"
     GNU regex should have raise a syntax error.  The same for backref, where
     the backref should have been local to each pattern.  */
  p = pattern;
  do
    {
      size_t len;
      sep = memchr (p, '\n', total);
      if (sep)
	{
	  len = sep - p;
	  sep++;
	  total -= (len + 1);
	}
      else
	{
	  len = total;
	  total = 0;
	}

      patterns = realloc (patterns, (pcount + 1) * sizeof (*patterns));
      if (patterns == NULL)
	error (EXIT_TROUBLE, errno, _("memory exhausted"));
      patterns[pcount] = patterns0;

      if ((err = re_compile_pattern (p, len,
				    &(patterns[pcount].regexbuf))) != NULL)
	error (EXIT_TROUBLE, 0, "%s", err);
      pcount++;

      p = sep;
    } while (sep && total != 0);

  /* In the match_words and match_lines cases, we use a different pattern
     for the DFA matcher that will quickly throw out cases that won't work.
     Then if DFA succeeds we do some hairy stuff using the regex matcher
     to decide whether the match should really count. */
  if (match_words || match_lines)
    {
      static char const line_beg_no_bk[] = "^(";
      static char const line_end_no_bk[] = ")$";
      static char const word_beg_no_bk[] = "(^|[^[:alnum:]_])(";
      static char const word_end_no_bk[] = ")([^[:alnum:]_]|$)";
      static char const line_beg_bk[] = "^\\(";
      static char const line_end_bk[] = "\\)$";
      static char const word_beg_bk[] = "\\(^\\|[^[:alnum:]_]\\)\\(";
      static char const word_end_bk[] = "\\)\\([^[:alnum:]_]\\|$\\)";
      int bk = !(syntax_bits & RE_NO_BK_PARENS);
      char *n = xmalloc (sizeof word_beg_bk - 1 + size + sizeof word_end_bk);

      strcpy (n, match_lines ? (bk ? line_beg_bk : line_beg_no_bk)
			     : (bk ? word_beg_bk : word_beg_no_bk));
      total = strlen(n);
      memcpy (n + total, pattern, size);
      total += size;
      strcpy (n + total, match_lines ? (bk ? line_end_bk : line_end_no_bk)
				     : (bk ? word_end_bk : word_end_no_bk));
      total += strlen (n + total);
      pattern = motif = n;
      size = total;
    }
  else
    motif = NULL;

  dfacomp (pattern, size, &dfa, 1);
  kwsmusts ();

  free(motif);
}

size_t
EGexecute (char const *buf, size_t size, size_t *match_size,
	   char const *start_ptr)
{
  char const *buflim, *beg, *end, *match, *best_match, *mb_start;
  char eol = eolbyte;
  int backref, start, len, best_len;
  struct kwsmatch kwsm;
  size_t i, ret_val;
#ifdef MBS_SUPPORT
  
//Patch 0:
if ((__is_neg(25, &(match_icase), sizeof (match_icase), &(eolbyte), sizeof (eolbyte), &(buf), sizeof (buf), &(size), sizeof (size), &(start_ptr), sizeof (start_ptr), &(mb_start), sizeof (mb_start), &(buflim), sizeof (buflim), &(beg), sizeof (beg), &(end), sizeof (end), &(kwset), sizeof (kwset), &(eol), sizeof (eol), &(match), sizeof (match), &(kwset_exact_matches), sizeof (kwset_exact_matches), &(backref), sizeof (backref), &(best_match), sizeof (best_match), &(best_len), sizeof (best_len), &(i), sizeof (i), &(pcount), sizeof (pcount), &(patterns), sizeof (patterns), &(start), sizeof (start), &(len), sizeof (len), &(match_words), sizeof (match_words), &(match_lines), sizeof (match_lines), &(ret_val), sizeof (ret_val), &(match_size), sizeof (match_size))))
    return 1;
if ((__ctype_get_mb_cur_max()) > 1) {
    if (match_icase) {
        char *case_buf = mbtolower(buf, &size);
        if (start_ptr)
            start_ptr = case_buf + (start_ptr - buf);
        buf = case_buf;
    }
}

//CodeSeg 1:
#endif /* MBS_SUPPORT */

  mb_start = buf;
  buflim = buf + size;

  for (beg = end = buf; end < buflim; beg = end)
    {
      if (!start_ptr)
	{
	  /* We don't care about an exact match.  */
	  if (kwset)
	    {
	      /* Find a possible match using the KWset matcher. */
	      size_t offset = kwsexec (kwset, beg, buflim - beg, &kwsm);
	      if (offset == (size_t) -1)
		goto failure;
	      beg += offset;
	      /* Narrow down to the line containing the candidate, and
		 run it through DFA. */
	      if ((end = memchr(beg, eol, buflim - beg)) != NULL)
	        end++;
              else
                end = buflim;
	      match = beg;
	      while (beg > buf && beg[-1] != eol)
		--beg;
	      if (kwsm.index < kwset_exact_matches)
                {
#ifdef MBS_SUPPORT
                  if (mb_start < beg)
                    mb_start = beg;
                  if (MB_CUR_MAX == 1 || !is_mb_middle (&mb_start, match, buflim))
#endif
                    goto success;
                }
	      if (dfaexec (&dfa, beg, (char *) end, 0, NULL, &backref) == NULL)
		continue;
	    }
	  else
	    {
	      /* No good fixed strings; start with DFA. */
	      char const *next_beg = dfaexec (&dfa, beg, (char *) buflim,
					      0, NULL, &backref);
	      if (next_beg == NULL)
		break;
	      /* Narrow down to the line we've found. */
	      beg = next_beg;
	      if ((end = memchr(beg, eol, buflim - beg)) != NULL)
	        end++;
              else
                end = buflim;
	      while (beg > buf && beg[-1] != eol)
		--beg;
	    }
	  /* Successful, no backreferences encountered! */
	  if (!backref)
	    goto success;
	}
      else
	{
	  /* We are looking for the leftmost (then longest) exact match.
	     We will go through the outer loop only once.  */
	  beg = start_ptr;
	  end = buflim;
	}

      /* If we've made it to this point, this means DFA has seen
	 a probable match, and we need to run it through Regex. */
      best_match = end;
      best_len = 0;
      for (i = 0; i < pcount; i++)
	{
	  patterns[i].regexbuf.not_eol = 0;
	  if (0 <= (start = re_search (&(patterns[i].regexbuf),
				       buf, end - buf - 1,
				       beg - buf, end - beg - 1,
				       &(patterns[i].regs))))
	    {
	      len = patterns[i].regs.end[0] - start;
	      match = buf + start;
	      if (match > best_match)
		continue;
	      if (start_ptr && !match_words)
		goto assess_pattern_match;
	      if ((!match_lines && !match_words)
		  || (match_lines && len == end - beg - 1))
		{
		  match = beg;
		  len = end - beg;
		  goto assess_pattern_match;
		}
	      /* If -w, check if the match aligns with word boundaries.
		 We do this iteratively because:
		 (a) the line may contain more than one occurence of the
		 pattern, and
		 (b) Several alternatives in the pattern might be valid at a
		 given point, and we may need to consider a shorter one to
		 find a word boundary.  */
	      if (match_words)
		while (match <= best_match)
		  {
		    if ((match == buf || !WCHAR ((unsigned char) match[-1]))
			&& (len == end - beg - 1
			    || !WCHAR ((unsigned char) match[len])))
		      goto assess_pattern_match;
		    if (len > 0)
		      {
			/* Try a shorter length anchored at the same place. */
			--len;
			patterns[i].regexbuf.not_eol = 1;
			len = re_match (&(patterns[i].regexbuf),
					buf, match + len - beg, match - buf,
					&(patterns[i].regs));
		      }
		    if (len <= 0)
		      {
			/* Try looking further on. */
			if (match == end - 1)
			  break;
			match++;
			patterns[i].regexbuf.not_eol = 0;
			start = re_search (&(patterns[i].regexbuf),
					   buf, end - buf - 1,
					   match - buf, end - match - 1,
					   &(patterns[i].regs));
			if (start < 0)
			  break;
			len = patterns[i].regs.end[0] - start;
			match = buf + start;
		      }
		  } /* while (match <= best_match) */
	      continue;
	    assess_pattern_match:
	      if (!start_ptr)
		{
		  /* Good enough for a non-exact match.
		     No need to look at further patterns, if any.  */
		  beg = match;
		  goto success_in_len;
		}
	      if (match < best_match || (match == best_match && len > best_len))
		{
		  /* Best exact match:  leftmost, then longest.  */
		  best_match = match;
		  best_len = len;
		}
	    } /* if re_search >= 0 */
	} /* for Regex patterns.  */
	if (best_match < end)
	  {
	    /* We have found an exact match.  We were just
	       waiting for the best one (leftmost then longest).  */
	    beg = best_match;
	    len = best_len;
	    goto success_in_len;
	  }
    } /* for (beg = end ..) */

 failure:
  ret_val = -1;
  goto out;

 success:
  len = end - beg;
 success_in_len:
  *match_size = len;
  ret_val = beg - buf;
 out:
  return ret_val;
}

Testing negative cases!
Testing 0 (with abstract condition) ENVIS_NEG
Iteration 0
Running test command:
/home/ubuntu/spr-fast/tools/grep-test.py /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-8a025cf8-8f08d8e2/tempworkdir-l/src /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-8a025cf8-8f08d8e2/tempworkdir-l/tests /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-8a025cf8-8f08d8e2/tempworkdir-l 0  > __res
Opening:/tmp/neg.tmp!
NegativeBRANCH RECORD/tmp/neg.tmp!
APPENDING TO ISNEG:/tmp/neg.tmp!
Branch 0: 0
Branch 1: 0
Iteration 1
Running test command:
/home/ubuntu/spr-fast/tools/grep-test.py /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-8a025cf8-8f08d8e2/tempworkdir-l/src /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-8a025cf8-8f08d8e2/tempworkdir-l/tests /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-8a025cf8-8f08d8e2/tempworkdir-l 0  > __res
Opening:/tmp/neg.tmp!
NegativeBRANCH RECORD/tmp/neg.tmp!
APPENDING TO ISNEG:/tmp/neg.tmp!
Branch 0: 0
Branch 1: 1
Branch 2: 0
Iteration 2
Running test command:
/home/ubuntu/spr-fast/tools/grep-test.py /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-8a025cf8-8f08d8e2/tempworkdir-l/src /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-8a025cf8-8f08d8e2/tempworkdir-l/tests /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-8a025cf8-8f08d8e2/tempworkdir-l 0  > __res
Opening:/tmp/neg.tmp!
NegativeBRANCH RECORD/tmp/neg.tmp!
APPENDING TO ISNEG:/tmp/neg.tmp!
Branch 0: 0
Branch 1: 1
Branch 2: 1
Branch 3: 0
Iteration 3
Running test command:
/home/ubuntu/spr-fast/tools/grep-test.py /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-8a025cf8-8f08d8e2/tempworkdir-l/src /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-8a025cf8-8f08d8e2/tempworkdir-l/tests /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-8a025cf8-8f08d8e2/tempworkdir-l 0  > __res
Opening:/tmp/neg.tmp!
NegativeBRANCH RECORD/tmp/neg.tmp!
APPENDING TO ISNEG:/tmp/neg.tmp!
Branch 0: 0
Branch 1: 1
Branch 2: 1
Branch 3: 1
Branch 4: 0
Iteration 4
Running test command:
/home/ubuntu/spr-fast/tools/grep-test.py /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-8a025cf8-8f08d8e2/tempworkdir-l/src /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-8a025cf8-8f08d8e2/tempworkdir-l/tests /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-8a025cf8-8f08d8e2/tempworkdir-l 0  > __res
Opening:/tmp/neg.tmp!
NegativeBRANCH RECORD/tmp/neg.tmp!
APPENDING TO ISNEG:/tmp/neg.tmp!
Branch 0: 0
Branch 1: 1
Branch 2: 1
Branch 3: 1
Branch 4: 1
Branch 5: 0
Iteration 5
Running test command:
/home/ubuntu/spr-fast/tools/grep-test.py /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-8a025cf8-8f08d8e2/tempworkdir-l/src /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-8a025cf8-8f08d8e2/tempworkdir-l/tests /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-8a025cf8-8f08d8e2/tempworkdir-l 0  > __res
Opening:/tmp/neg.tmp!
NegativeBRANCH RECORD/tmp/neg.tmp!
APPENDING TO ISNEG:/tmp/neg.tmp!
Branch 0: 0
Branch 1: 1
Branch 2: 1
Branch 3: 1
Branch 4: 1
Branch 5: 1
Branch 6: 0
Iteration 6
Running test command:
/home/ubuntu/spr-fast/tools/grep-test.py /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-8a025cf8-8f08d8e2/tempworkdir-l/src /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-8a025cf8-8f08d8e2/tempworkdir-l/tests /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-8a025cf8-8f08d8e2/tempworkdir-l 0  > __res
Opening:/tmp/neg.tmp!
NegativeBRANCH RECORD/tmp/neg.tmp!
APPENDING TO ISNEG:/tmp/neg.tmp!
Branch 0: 0
Branch 1: 1
Branch 2: 1
Branch 3: 1
Branch 4: 1
Branch 5: 1
Branch 6: 1
Branch 7: 0
Iteration 7
Running test command:
/home/ubuntu/spr-fast/tools/grep-test.py /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-8a025cf8-8f08d8e2/tempworkdir-l/src /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-8a025cf8-8f08d8e2/tempworkdir-l/tests /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-8a025cf8-8f08d8e2/tempworkdir-l 0  > __res
Opening:/tmp/neg.tmp!
NegativeBRANCH RECORD/tmp/neg.tmp!
APPENDING TO ISNEG:/tmp/neg.tmp!
Branch 0: 0
Branch 1: 1
Branch 2: 1
Branch 3: 1
Branch 4: 1
Branch 5: 1
Branch 6: 1
Branch 7: 1
Branch 8: 0
Iteration 8
Running test command:
/home/ubuntu/spr-fast/tools/grep-test.py /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-8a025cf8-8f08d8e2/tempworkdir-l/src /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-8a025cf8-8f08d8e2/tempworkdir-l/tests /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-8a025cf8-8f08d8e2/tempworkdir-l 0  > __res
Opening:/tmp/neg.tmp!
NegativeBRANCH RECORD/tmp/neg.tmp!
APPENDING TO ISNEG:/tmp/neg.tmp!
Branch 0: 0
Branch 1: 1
Branch 2: 1
Branch 3: 1
Branch 4: 1
Branch 5: 1
Branch 6: 1
Branch 7: 1
Branch 8: 1
Branch 9: 0
Iteration 9
Running test command:
/home/ubuntu/spr-fast/tools/grep-test.py /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-8a025cf8-8f08d8e2/tempworkdir-l/src /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-8a025cf8-8f08d8e2/tempworkdir-l/tests /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-8a025cf8-8f08d8e2/tempworkdir-l 0  > __res
Opening:/tmp/neg.tmp!
NegativeBRANCH RECORD/tmp/neg.tmp!
APPENDING TO ISNEG:/tmp/neg.tmp!
Branch 0: 0
Branch 1: 1
Branch 2: 1
Branch 3: 1
Branch 4: 1
Branch 5: 1
Branch 6: 1
Branch 7: 1
Branch 8: 1
Branch 9: 1
Branch 10: 0
Running test command:
/home/ubuntu/spr-fast/tools/grep-test.py /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-8a025cf8-8f08d8e2/tempworkdir-l/src /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-8a025cf8-8f08d8e2/tempworkdir-l/tests /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-8a025cf8-8f08d8e2/tempworkdir-l 0  > __res
a batched test job starts!
Building merged code:
src_file: src/dfasearch.c
full src: int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); void* memset(void*, int, unsigned long); 
/* dfasearch.c - searching subroutines using dfa and regex for grep.
   Copyright 1992, 1998, 2000, 2007, 2009-2010 Free Software Foundation, Inc.

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 3, or (at your option)
   any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program; if not, write to the Free Software
   Foundation, Inc., 51 Franklin Street - Fifth Floor, Boston, MA
   02110-1301, USA.  */

/* Written August 1992 by Mike Haertel. */

#include <config.h>
#include "search.h"
#include "dfa.h"

/* For -w, we also consider _ to be word constituent.  */
#define WCHAR(C) (ISALNUM(C) || (C) == '_')

/* KWset compiled pattern.  For Ecompile and Gcompile, we compile
   a list of strings, at least one of which is known to occur in
   any string matching the regexp. */
static kwset_t kwset;

/* DFA compiled regexp. */
static struct dfa dfa;

/* The Regex compiled patterns.  */
static struct patterns
{
  /* Regex compiled regexp. */
  struct re_pattern_buffer regexbuf;
  struct re_registers regs; /* This is here on account of a BRAIN-DEAD
			       Q@#%!# library interface in regex.c.  */
} patterns0;

struct patterns *patterns;
size_t pcount;

void
dfaerror (char const *mesg)
{
  error (EXIT_TROUBLE, 0, "%s", mesg);

  /* notreached */
  /* Tell static analyzers that this function does not return.  */
  abort ();
}

/* Number of compiled fixed strings known to exactly match the regexp.
   If kwsexec returns < kwset_exact_matches, then we don't need to
   call the regexp matcher at all. */
static int kwset_exact_matches;

static char const *
kwsincr_case (const char *must)
{
  const char *buf;
  size_t n;

  n = strlen (must);
#ifdef MBS_SUPPORT
  if (match_icase && MB_CUR_MAX > 1)
    buf = mbtolower (must, &n);
  else
#endif
    buf = must;
  return kwsincr (kwset, buf, n);
}

/* If the DFA turns out to have some set of fixed strings one of
   which must occur in the match, then we build a kwset matcher
   to find those strings, and thus quickly filter out impossible
   matches. */
static void
kwsmusts (void)
{
  struct dfamust const *dm;
  char const *err;

  if (dfa.musts)
    {
      kwsinit (&kwset);
      /* First, we compile in the substrings known to be exact
	 matches.  The kwset matcher will return the index
	 of the matching string that it chooses. */
      for (dm = dfa.musts; dm; dm = dm->next)
	{
	  if (!dm->exact)
	    continue;
	  ++kwset_exact_matches;
	  if ((err = kwsincr_case (dm->must)) != NULL)
	    error (EXIT_TROUBLE, 0, "%s", err);
	}
      /* Now, we compile the substrings that will require
	 the use of the regexp matcher.  */
      for (dm = dfa.musts; dm; dm = dm->next)
	{
	  if (dm->exact)
	    continue;
	  if ((err = kwsincr_case (dm->must)) != NULL)
	    error (EXIT_TROUBLE, 0, "%s", err);
	}
      if ((err = kwsprep (kwset)) != NULL)
	error (EXIT_TROUBLE, 0, "%s", err);
    }
}

void
GEAcompile (char const *pattern, size_t size, reg_syntax_t syntax_bits)
{
  const char *err;
  const char *p, *sep;
  size_t total = size;
  char *motif;

  if (match_icase)
    syntax_bits |= RE_ICASE;
  re_set_syntax (syntax_bits);
  dfasyntax (syntax_bits, match_icase, eolbyte);

  /* For GNU regex compiler we have to pass the patterns separately to detect
     errors like "[\nallo\n]\n".  The patterns here are "[", "allo" and "]"
     GNU regex should have raise a syntax error.  The same for backref, where
     the backref should have been local to each pattern.  */
  p = pattern;
  do
    {
      size_t len;
      sep = memchr (p, '\n', total);
      if (sep)
	{
	  len = sep - p;
	  sep++;
	  total -= (len + 1);
	}
      else
	{
	  len = total;
	  total = 0;
	}

      patterns = realloc (patterns, (pcount + 1) * sizeof (*patterns));
      if (patterns == NULL)
	error (EXIT_TROUBLE, errno, _("memory exhausted"));
      patterns[pcount] = patterns0;

      if ((err = re_compile_pattern (p, len,
				    &(patterns[pcount].regexbuf))) != NULL)
	error (EXIT_TROUBLE, 0, "%s", err);
      pcount++;

      p = sep;
    } while (sep && total != 0);

  /* In the match_words and match_lines cases, we use a different pattern
     for the DFA matcher that will quickly throw out cases that won't work.
     Then if DFA succeeds we do some hairy stuff using the regex matcher
     to decide whether the match should really count. */
  if (match_words || match_lines)
    {
      static char const line_beg_no_bk[] = "^(";
      static char const line_end_no_bk[] = ")$";
      static char const word_beg_no_bk[] = "(^|[^[:alnum:]_])(";
      static char const word_end_no_bk[] = ")([^[:alnum:]_]|$)";
      static char const line_beg_bk[] = "^\\(";
      static char const line_end_bk[] = "\\)$";
      static char const word_beg_bk[] = "\\(^\\|[^[:alnum:]_]\\)\\(";
      static char const word_end_bk[] = "\\)\\([^[:alnum:]_]\\|$\\)";
      int bk = !(syntax_bits & RE_NO_BK_PARENS);
      char *n = xmalloc (sizeof word_beg_bk - 1 + size + sizeof word_end_bk);

      strcpy (n, match_lines ? (bk ? line_beg_bk : line_beg_no_bk)
			     : (bk ? word_beg_bk : word_beg_no_bk));
      total = strlen(n);
      memcpy (n + total, pattern, size);
      total += size;
      strcpy (n + total, match_lines ? (bk ? line_end_bk : line_end_no_bk)
				     : (bk ? word_end_bk : word_end_no_bk));
      total += strlen (n + total);
      pattern = motif = n;
      size = total;
    }
  else
    motif = NULL;

  dfacomp (pattern, size, &dfa, 1);
  kwsmusts ();

  free(motif);
}

size_t
EGexecute (char const *buf, size_t size, size_t *match_size,
	   char const *start_ptr)
{
  char const *buflim, *beg, *end, *match, *best_match, *mb_start;
  char eol = eolbyte;
  int backref, start, len, best_len;
  struct kwsmatch kwsm;
  size_t i, ret_val;
#ifdef MBS_SUPPORT
  if (MB_CUR_MAX > 1)
    {
      if (match_icase)
        {
          /* mbtolower adds a NUL byte at the end.  That will provide
	     space for the sentinel byte dfaexec may add.  */
          char *case_buf = mbtolower (buf, &size);
	  if (start_ptr)
	    start_ptr = case_buf + (start_ptr - buf);
          buf = case_buf;
        }
    }
#endif /* MBS_SUPPORT */

  mb_start = buf;
  buflim = buf + size;

  for (beg = end = buf; end < buflim; beg = end)
    {
      //prophet generated patch
      if (__get_mutant()==0) {
      if ((!start_ptr) && !(__is_neg(25, &(start_ptr), sizeof (start_ptr), &(buf), sizeof (buf), &(buflim), sizeof (buflim), &(beg), sizeof (beg), &(end), sizeof (end), &(kwset), sizeof (kwset), &(size), sizeof (size), &(mb_start), sizeof (mb_start), &(eol), sizeof (eol), &(match), sizeof (match), &(match_icase), sizeof (match_icase), &(kwset_exact_matches), sizeof (kwset_exact_matches), &(eolbyte), sizeof (eolbyte), &(backref), sizeof (backref), &(best_match), sizeof (best_match), &(best_len), sizeof (best_len), &(i), sizeof (i), &(pcount), sizeof (pcount), &(patterns), sizeof (patterns), &(start), sizeof (start), &(len), sizeof (len), &(match_words), sizeof (match_words), &(match_lines), sizeof (match_lines), &(ret_val), sizeof (ret_val), &(match_size), sizeof (match_size)))) {
          if (kwset) {
              size_t offset = kwsexec(kwset, beg, buflim - beg, &kwsm);
              if (offset == (size_t)-1)
                  goto failure;
              beg += offset;
              if ((end = memchr(beg, eol, buflim - beg)) != ((void *)0))
                  end++;
              else
                  end = buflim;
              match = beg;
              while (beg > buf && beg[-1] != eol)
                  --beg;
              if (kwsm.index < kwset_exact_matches) {
                  if (mb_start < beg)
                      mb_start = beg;
                  if ((__ctype_get_mb_cur_max()) == 1 || !is_mb_middle(&mb_start, match, buflim))
                      goto success;
              }
              if (dfaexec(&dfa, beg, (char *)end, 0, ((void *)0), &backref) == ((void *)0))
                  continue;
          } else {
              const char *next_beg = dfaexec(&dfa, beg, (char *)buflim, 0, ((void *)0), &backref);
              if (next_beg == ((void *)0))
                  break;
              beg = next_beg;
              if ((end = memchr(beg, eol, buflim - beg)) != ((void *)0))
                  end++;
              else
                  end = buflim;
              while (beg > buf && beg[-1] != eol)
                  --beg;
          }
          if (!backref)
              goto success;
      } else {
          beg = start_ptr;
          end = buflim;
      }
      }
      else if (__get_mutant()==1) {
      if ((!start_ptr) || (__is_neg(25, &(start_ptr), sizeof (start_ptr), &(buf), sizeof (buf), &(buflim), sizeof (buflim), &(beg), sizeof (beg), &(end), sizeof (end), &(kwset), sizeof (kwset), &(size), sizeof (size), &(mb_start), sizeof (mb_start), &(eol), sizeof (eol), &(match), sizeof (match), &(match_icase), sizeof (match_icase), &(kwset_exact_matches), sizeof (kwset_exact_matches), &(eolbyte), sizeof (eolbyte), &(backref), sizeof (backref), &(best_match), sizeof (best_match), &(best_len), sizeof (best_len), &(i), sizeof (i), &(pcount), sizeof (pcount), &(patterns), sizeof (patterns), &(start), sizeof (start), &(len), sizeof (len), &(match_words), sizeof (match_words), &(match_lines), sizeof (match_lines), &(ret_val), sizeof (ret_val), &(match_size), sizeof (match_size)))) {
          if (kwset) {
              size_t offset = kwsexec(kwset, beg, buflim - beg, &kwsm);
              if (offset == (size_t)-1)
                  goto failure;
              beg += offset;
              if ((end = memchr(beg, eol, buflim - beg)) != ((void *)0))
                  end++;
              else
                  end = buflim;
              match = beg;
              while (beg > buf && beg[-1] != eol)
                  --beg;
              if (kwsm.index < kwset_exact_matches) {
                  if (mb_start < beg)
                      mb_start = beg;
                  if ((__ctype_get_mb_cur_max()) == 1 || !is_mb_middle(&mb_start, match, buflim))
                      goto success;
              }
              if (dfaexec(&dfa, beg, (char *)end, 0, ((void *)0), &backref) == ((void *)0))
                  continue;
          } else {
              const char *next_beg = dfaexec(&dfa, beg, (char *)buflim, 0, ((void *)0), &backref);
              if (next_beg == ((void *)0))
                  break;
              beg = next_beg;
              if ((end = memchr(beg, eol, buflim - beg)) != ((void *)0))
                  end++;
              else
                  end = buflim;
              while (beg > buf && beg[-1] != eol)
                  --beg;
          }
          if (!backref)
              goto success;
      } else {
          beg = start_ptr;
          end = buflim;
      }
      }

      /* If we've made it to this point, this means DFA has seen
	 a probable match, and we need to run it through Regex. */
      best_match = end;
      best_len = 0;
      for (i = 0; i < pcount; i++)
	{
	  patterns[i].regexbuf.not_eol = 0;
	  if (0 <= (start = re_search (&(patterns[i].regexbuf),
				       buf, end - buf - 1,
				       beg - buf, end - beg - 1,
				       &(patterns[i].regs))))
	    {
	      len = patterns[i].regs.end[0] - start;
	      match = buf + start;
	      if (match > best_match)
		continue;
	      if (start_ptr && !match_words)
		goto assess_pattern_match;
	      if ((!match_lines && !match_words)
		  || (match_lines && len == end - beg - 1))
		{
		  match = beg;
		  len = end - beg;
		  goto assess_pattern_match;
		}
	      /* If -w, check if the match aligns with word boundaries.
		 We do this iteratively because:
		 (a) the line may contain more than one occurence of the
		 pattern, and
		 (b) Several alternatives in the pattern might be valid at a
		 given point, and we may need to consider a shorter one to
		 find a word boundary.  */
	      if (match_words)
		while (match <= best_match)
		  {
		    if ((match == buf || !WCHAR ((unsigned char) match[-1]))
			&& (len == end - beg - 1
			    || !WCHAR ((unsigned char) match[len])))
		      goto assess_pattern_match;
		    if (len > 0)
		      {
			/* Try a shorter length anchored at the same place. */
			--len;
			patterns[i].regexbuf.not_eol = 1;
			len = re_match (&(patterns[i].regexbuf),
					buf, match + len - beg, match - buf,
					&(patterns[i].regs));
		      }
		    if (len <= 0)
		      {
			/* Try looking further on. */
			if (match == end - 1)
			  break;
			match++;
			patterns[i].regexbuf.not_eol = 0;
			start = re_search (&(patterns[i].regexbuf),
					   buf, end - buf - 1,
					   match - buf, end - match - 1,
					   &(patterns[i].regs));
			if (start < 0)
			  break;
			len = patterns[i].regs.end[0] - start;
			match = buf + start;
		      }
		  } /* while (match <= best_match) */
	      continue;
	    assess_pattern_match:
	      if (!start_ptr)
		{
		  /* Good enough for a non-exact match.
		     No need to look at further patterns, if any.  */
		  beg = match;
		  goto success_in_len;
		}
	      if (match < best_match || (match == best_match && len > best_len))
		{
		  /* Best exact match:  leftmost, then longest.  */
		  best_match = match;
		  best_len = len;
		}
	    } /* if re_search >= 0 */
	} /* for Regex patterns.  */
	if (best_match < end)
	  {
	    /* We have found an exact match.  We were just
	       waiting for the best one (leftmost then longest).  */
	    beg = best_match;
	    len = best_len;
	    goto success_in_len;
	  }
    } /* for (beg = end ..) */

 failure:
  ret_val = -1;
  goto out;

 success:
  len = end - beg;
 success_in_len:
  *match_size = len;
  ret_val = beg - buf;
 out:
  return ret_val;
}

Building:src at:
/home/ubuntu/spr-fast/tests/corebench/grep/grep-case-8a025cf8-8f08d8e2/tempworkdir-l/srcMerged code building succ, going to invoke tester!
CondTester, Testing instance id 45:
//src_file:src/dfasearch.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); void* memset(void*, int, unsigned long); 
/* dfasearch.c - searching subroutines using dfa and regex for grep.
   Copyright 1992, 1998, 2000, 2007, 2009-2010 Free Software Foundation, Inc.

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 3, or (at your option)
   any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program; if not, write to the Free Software
   Foundation, Inc., 51 Franklin Street - Fifth Floor, Boston, MA
   02110-1301, USA.  */

/* Written August 1992 by Mike Haertel. */

#include <config.h>
#include "search.h"
#include "dfa.h"

/* For -w, we also consider _ to be word constituent.  */
#define WCHAR(C) (ISALNUM(C) || (C) == '_')

/* KWset compiled pattern.  For Ecompile and Gcompile, we compile
   a list of strings, at least one of which is known to occur in
   any string matching the regexp. */
static kwset_t kwset;

/* DFA compiled regexp. */
static struct dfa dfa;

/* The Regex compiled patterns.  */
static struct patterns
{
  /* Regex compiled regexp. */
  struct re_pattern_buffer regexbuf;
  struct re_registers regs; /* This is here on account of a BRAIN-DEAD
			       Q@#%!# library interface in regex.c.  */
} patterns0;

struct patterns *patterns;
size_t pcount;

void
dfaerror (char const *mesg)
{
  error (EXIT_TROUBLE, 0, "%s", mesg);

  /* notreached */
  /* Tell static analyzers that this function does not return.  */
  abort ();
}

/* Number of compiled fixed strings known to exactly match the regexp.
   If kwsexec returns < kwset_exact_matches, then we don't need to
   call the regexp matcher at all. */
static int kwset_exact_matches;

static char const *
kwsincr_case (const char *must)
{
  const char *buf;
  size_t n;

  n = strlen (must);
#ifdef MBS_SUPPORT
  if (match_icase && MB_CUR_MAX > 1)
    buf = mbtolower (must, &n);
  else
#endif
    buf = must;
  return kwsincr (kwset, buf, n);
}

/* If the DFA turns out to have some set of fixed strings one of
   which must occur in the match, then we build a kwset matcher
   to find those strings, and thus quickly filter out impossible
   matches. */
static void
kwsmusts (void)
{
  struct dfamust const *dm;
  char const *err;

  if (dfa.musts)
    {
      kwsinit (&kwset);
      /* First, we compile in the substrings known to be exact
	 matches.  The kwset matcher will return the index
	 of the matching string that it chooses. */
      for (dm = dfa.musts; dm; dm = dm->next)
	{
	  if (!dm->exact)
	    continue;
	  ++kwset_exact_matches;
	  if ((err = kwsincr_case (dm->must)) != NULL)
	    error (EXIT_TROUBLE, 0, "%s", err);
	}
      /* Now, we compile the substrings that will require
	 the use of the regexp matcher.  */
      for (dm = dfa.musts; dm; dm = dm->next)
	{
	  if (dm->exact)
	    continue;
	  if ((err = kwsincr_case (dm->must)) != NULL)
	    error (EXIT_TROUBLE, 0, "%s", err);
	}
      if ((err = kwsprep (kwset)) != NULL)
	error (EXIT_TROUBLE, 0, "%s", err);
    }
}

void
GEAcompile (char const *pattern, size_t size, reg_syntax_t syntax_bits)
{
  const char *err;
  const char *p, *sep;
  size_t total = size;
  char *motif;

  if (match_icase)
    syntax_bits |= RE_ICASE;
  re_set_syntax (syntax_bits);
  dfasyntax (syntax_bits, match_icase, eolbyte);

  /* For GNU regex compiler we have to pass the patterns separately to detect
     errors like "[\nallo\n]\n".  The patterns here are "[", "allo" and "]"
     GNU regex should have raise a syntax error.  The same for backref, where
     the backref should have been local to each pattern.  */
  p = pattern;
  do
    {
      size_t len;
      sep = memchr (p, '\n', total);
      if (sep)
	{
	  len = sep - p;
	  sep++;
	  total -= (len + 1);
	}
      else
	{
	  len = total;
	  total = 0;
	}

      patterns = realloc (patterns, (pcount + 1) * sizeof (*patterns));
      if (patterns == NULL)
	error (EXIT_TROUBLE, errno, _("memory exhausted"));
      patterns[pcount] = patterns0;

      if ((err = re_compile_pattern (p, len,
				    &(patterns[pcount].regexbuf))) != NULL)
	error (EXIT_TROUBLE, 0, "%s", err);
      pcount++;

      p = sep;
    } while (sep && total != 0);

  /* In the match_words and match_lines cases, we use a different pattern
     for the DFA matcher that will quickly throw out cases that won't work.
     Then if DFA succeeds we do some hairy stuff using the regex matcher
     to decide whether the match should really count. */
  if (match_words || match_lines)
    {
      static char const line_beg_no_bk[] = "^(";
      static char const line_end_no_bk[] = ")$";
      static char const word_beg_no_bk[] = "(^|[^[:alnum:]_])(";
      static char const word_end_no_bk[] = ")([^[:alnum:]_]|$)";
      static char const line_beg_bk[] = "^\\(";
      static char const line_end_bk[] = "\\)$";
      static char const word_beg_bk[] = "\\(^\\|[^[:alnum:]_]\\)\\(";
      static char const word_end_bk[] = "\\)\\([^[:alnum:]_]\\|$\\)";
      int bk = !(syntax_bits & RE_NO_BK_PARENS);
      char *n = xmalloc (sizeof word_beg_bk - 1 + size + sizeof word_end_bk);

      strcpy (n, match_lines ? (bk ? line_beg_bk : line_beg_no_bk)
			     : (bk ? word_beg_bk : word_beg_no_bk));
      total = strlen(n);
      memcpy (n + total, pattern, size);
      total += size;
      strcpy (n + total, match_lines ? (bk ? line_end_bk : line_end_no_bk)
				     : (bk ? word_end_bk : word_end_no_bk));
      total += strlen (n + total);
      pattern = motif = n;
      size = total;
    }
  else
    motif = NULL;

  dfacomp (pattern, size, &dfa, 1);
  kwsmusts ();

  free(motif);
}

size_t
EGexecute (char const *buf, size_t size, size_t *match_size,
	   char const *start_ptr)
{
  char const *buflim, *beg, *end, *match, *best_match, *mb_start;
  char eol = eolbyte;
  int backref, start, len, best_len;
  struct kwsmatch kwsm;
  size_t i, ret_val;
#ifdef MBS_SUPPORT
  if (MB_CUR_MAX > 1)
    {
      if (match_icase)
        {
          /* mbtolower adds a NUL byte at the end.  That will provide
	     space for the sentinel byte dfaexec may add.  */
          char *case_buf = mbtolower (buf, &size);
	  if (start_ptr)
	    start_ptr = case_buf + (start_ptr - buf);
          buf = case_buf;
        }
    }
#endif /* MBS_SUPPORT */

  mb_start = buf;
  buflim = buf + size;

  for (beg = end = buf; end < buflim; beg = end)
    {
      
//Patch 0:
if ((!start_ptr) && !(__is_neg(25, &(start_ptr), sizeof (start_ptr), &(buf), sizeof (buf), &(buflim), sizeof (buflim), &(beg), sizeof (beg), &(end), sizeof (end), &(kwset), sizeof (kwset), &(size), sizeof (size), &(mb_start), sizeof (mb_start), &(eol), sizeof (eol), &(match), sizeof (match), &(match_icase), sizeof (match_icase), &(kwset_exact_matches), sizeof (kwset_exact_matches), &(eolbyte), sizeof (eolbyte), &(backref), sizeof (backref), &(best_match), sizeof (best_match), &(best_len), sizeof (best_len), &(i), sizeof (i), &(pcount), sizeof (pcount), &(patterns), sizeof (patterns), &(start), sizeof (start), &(len), sizeof (len), &(match_words), sizeof (match_words), &(match_lines), sizeof (match_lines), &(ret_val), sizeof (ret_val), &(match_size), sizeof (match_size)))) {
    if (kwset) {
        size_t offset = kwsexec(kwset, beg, buflim - beg, &kwsm);
        if (offset == (size_t)-1)
            goto failure;
        beg += offset;
        if ((end = memchr(beg, eol, buflim - beg)) != ((void *)0))
            end++;
        else
            end = buflim;
        match = beg;
        while (beg > buf && beg[-1] != eol)
            --beg;
        if (kwsm.index < kwset_exact_matches) {
            if (mb_start < beg)
                mb_start = beg;
            if ((__ctype_get_mb_cur_max()) == 1 || !is_mb_middle(&mb_start, match, buflim))
                goto success;
        }
        if (dfaexec(&dfa, beg, (char *)end, 0, ((void *)0), &backref) == ((void *)0))
            continue;
    } else {
        const char *next_beg = dfaexec(&dfa, beg, (char *)buflim, 0, ((void *)0), &backref);
        if (next_beg == ((void *)0))
            break;
        beg = next_beg;
        if ((end = memchr(beg, eol, buflim - beg)) != ((void *)0))
            end++;
        else
            end = buflim;
        while (beg > buf && beg[-1] != eol)
            --beg;
    }
    if (!backref)
        goto success;
} else {
    beg = start_ptr;
    end = buflim;
}

//CodeSeg 1:

      /* If we've made it to this point, this means DFA has seen
	 a probable match, and we need to run it through Regex. */
      best_match = end;
      best_len = 0;
      for (i = 0; i < pcount; i++)
	{
	  patterns[i].regexbuf.not_eol = 0;
	  if (0 <= (start = re_search (&(patterns[i].regexbuf),
				       buf, end - buf - 1,
				       beg - buf, end - beg - 1,
				       &(patterns[i].regs))))
	    {
	      len = patterns[i].regs.end[0] - start;
	      match = buf + start;
	      if (match > best_match)
		continue;
	      if (start_ptr && !match_words)
		goto assess_pattern_match;
	      if ((!match_lines && !match_words)
		  || (match_lines && len == end - beg - 1))
		{
		  match = beg;
		  len = end - beg;
		  goto assess_pattern_match;
		}
	      /* If -w, check if the match aligns with word boundaries.
		 We do this iteratively because:
		 (a) the line may contain more than one occurence of the
		 pattern, and
		 (b) Several alternatives in the pattern might be valid at a
		 given point, and we may need to consider a shorter one to
		 find a word boundary.  */
	      if (match_words)
		while (match <= best_match)
		  {
		    if ((match == buf || !WCHAR ((unsigned char) match[-1]))
			&& (len == end - beg - 1
			    || !WCHAR ((unsigned char) match[len])))
		      goto assess_pattern_match;
		    if (len > 0)
		      {
			/* Try a shorter length anchored at the same place. */
			--len;
			patterns[i].regexbuf.not_eol = 1;
			len = re_match (&(patterns[i].regexbuf),
					buf, match + len - beg, match - buf,
					&(patterns[i].regs));
		      }
		    if (len <= 0)
		      {
			/* Try looking further on. */
			if (match == end - 1)
			  break;
			match++;
			patterns[i].regexbuf.not_eol = 0;
			start = re_search (&(patterns[i].regexbuf),
					   buf, end - buf - 1,
					   match - buf, end - match - 1,
					   &(patterns[i].regs));
			if (start < 0)
			  break;
			len = patterns[i].regs.end[0] - start;
			match = buf + start;
		      }
		  } /* while (match <= best_match) */
	      continue;
	    assess_pattern_match:
	      if (!start_ptr)
		{
		  /* Good enough for a non-exact match.
		     No need to look at further patterns, if any.  */
		  beg = match;
		  goto success_in_len;
		}
	      if (match < best_match || (match == best_match && len > best_len))
		{
		  /* Best exact match:  leftmost, then longest.  */
		  best_match = match;
		  best_len = len;
		}
	    } /* if re_search >= 0 */
	} /* for Regex patterns.  */
	if (best_match < end)
	  {
	    /* We have found an exact match.  We were just
	       waiting for the best one (leftmost then longest).  */
	    beg = best_match;
	    len = best_len;
	    goto success_in_len;
	  }
    } /* for (beg = end ..) */

 failure:
  ret_val = -1;
  goto out;

 success:
  len = end - beg;
 success_in_len:
  *match_size = len;
  ret_val = beg - buf;
 out:
  return ret_val;
}

Testing negative cases!
Testing 0 (with abstract condition) ENVIS_NEG
Iteration 0
Running test command:
/home/ubuntu/spr-fast/tools/grep-test.py /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-8a025cf8-8f08d8e2/tempworkdir-l/src /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-8a025cf8-8f08d8e2/tempworkdir-l/tests /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-8a025cf8-8f08d8e2/tempworkdir-l 0  > __res
Opening:/tmp/neg.tmp!
NegativeBRANCH RECORD/tmp/neg.tmp!
APPENDING TO ISNEG:/tmp/neg.tmp!
Branch 0: 0
Branch 1: 0
Iteration 1
Running test command:
/home/ubuntu/spr-fast/tools/grep-test.py /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-8a025cf8-8f08d8e2/tempworkdir-l/src /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-8a025cf8-8f08d8e2/tempworkdir-l/tests /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-8a025cf8-8f08d8e2/tempworkdir-l 0  > __res
Opening:/tmp/neg.tmp!
NegativeBRANCH RECORD/tmp/neg.tmp!
APPENDING TO ISNEG:/tmp/neg.tmp!
Branch 0: 0
Branch 1: 1
Iteration 2
Running test command:
/home/ubuntu/spr-fast/tools/grep-test.py /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-8a025cf8-8f08d8e2/tempworkdir-l/src /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-8a025cf8-8f08d8e2/tempworkdir-l/tests /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-8a025cf8-8f08d8e2/tempworkdir-l 0  > __res
Opening:/tmp/neg.tmp!
NegativeBRANCH RECORD/tmp/neg.tmp!
APPENDING TO ISNEG:/tmp/neg.tmp!
Branch 0: 1
Running test command:
/home/ubuntu/spr-fast/tools/grep-test.py /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-8a025cf8-8f08d8e2/tempworkdir-l/src /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-8a025cf8-8f08d8e2/tempworkdir-l/tests /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-8a025cf8-8f08d8e2/tempworkdir-l 0  > __res
CondTester, Testing instance id 46:
//src_file:src/dfasearch.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); void* memset(void*, int, unsigned long); 
/* dfasearch.c - searching subroutines using dfa and regex for grep.
   Copyright 1992, 1998, 2000, 2007, 2009-2010 Free Software Foundation, Inc.

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 3, or (at your option)
   any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program; if not, write to the Free Software
   Foundation, Inc., 51 Franklin Street - Fifth Floor, Boston, MA
   02110-1301, USA.  */

/* Written August 1992 by Mike Haertel. */

#include <config.h>
#include "search.h"
#include "dfa.h"

/* For -w, we also consider _ to be word constituent.  */
#define WCHAR(C) (ISALNUM(C) || (C) == '_')

/* KWset compiled pattern.  For Ecompile and Gcompile, we compile
   a list of strings, at least one of which is known to occur in
   any string matching the regexp. */
static kwset_t kwset;

/* DFA compiled regexp. */
static struct dfa dfa;

/* The Regex compiled patterns.  */
static struct patterns
{
  /* Regex compiled regexp. */
  struct re_pattern_buffer regexbuf;
  struct re_registers regs; /* This is here on account of a BRAIN-DEAD
			       Q@#%!# library interface in regex.c.  */
} patterns0;

struct patterns *patterns;
size_t pcount;

void
dfaerror (char const *mesg)
{
  error (EXIT_TROUBLE, 0, "%s", mesg);

  /* notreached */
  /* Tell static analyzers that this function does not return.  */
  abort ();
}

/* Number of compiled fixed strings known to exactly match the regexp.
   If kwsexec returns < kwset_exact_matches, then we don't need to
   call the regexp matcher at all. */
static int kwset_exact_matches;

static char const *
kwsincr_case (const char *must)
{
  const char *buf;
  size_t n;

  n = strlen (must);
#ifdef MBS_SUPPORT
  if (match_icase && MB_CUR_MAX > 1)
    buf = mbtolower (must, &n);
  else
#endif
    buf = must;
  return kwsincr (kwset, buf, n);
}

/* If the DFA turns out to have some set of fixed strings one of
   which must occur in the match, then we build a kwset matcher
   to find those strings, and thus quickly filter out impossible
   matches. */
static void
kwsmusts (void)
{
  struct dfamust const *dm;
  char const *err;

  if (dfa.musts)
    {
      kwsinit (&kwset);
      /* First, we compile in the substrings known to be exact
	 matches.  The kwset matcher will return the index
	 of the matching string that it chooses. */
      for (dm = dfa.musts; dm; dm = dm->next)
	{
	  if (!dm->exact)
	    continue;
	  ++kwset_exact_matches;
	  if ((err = kwsincr_case (dm->must)) != NULL)
	    error (EXIT_TROUBLE, 0, "%s", err);
	}
      /* Now, we compile the substrings that will require
	 the use of the regexp matcher.  */
      for (dm = dfa.musts; dm; dm = dm->next)
	{
	  if (dm->exact)
	    continue;
	  if ((err = kwsincr_case (dm->must)) != NULL)
	    error (EXIT_TROUBLE, 0, "%s", err);
	}
      if ((err = kwsprep (kwset)) != NULL)
	error (EXIT_TROUBLE, 0, "%s", err);
    }
}

void
GEAcompile (char const *pattern, size_t size, reg_syntax_t syntax_bits)
{
  const char *err;
  const char *p, *sep;
  size_t total = size;
  char *motif;

  if (match_icase)
    syntax_bits |= RE_ICASE;
  re_set_syntax (syntax_bits);
  dfasyntax (syntax_bits, match_icase, eolbyte);

  /* For GNU regex compiler we have to pass the patterns separately to detect
     errors like "[\nallo\n]\n".  The patterns here are "[", "allo" and "]"
     GNU regex should have raise a syntax error.  The same for backref, where
     the backref should have been local to each pattern.  */
  p = pattern;
  do
    {
      size_t len;
      sep = memchr (p, '\n', total);
      if (sep)
	{
	  len = sep - p;
	  sep++;
	  total -= (len + 1);
	}
      else
	{
	  len = total;
	  total = 0;
	}

      patterns = realloc (patterns, (pcount + 1) * sizeof (*patterns));
      if (patterns == NULL)
	error (EXIT_TROUBLE, errno, _("memory exhausted"));
      patterns[pcount] = patterns0;

      if ((err = re_compile_pattern (p, len,
				    &(patterns[pcount].regexbuf))) != NULL)
	error (EXIT_TROUBLE, 0, "%s", err);
      pcount++;

      p = sep;
    } while (sep && total != 0);

  /* In the match_words and match_lines cases, we use a different pattern
     for the DFA matcher that will quickly throw out cases that won't work.
     Then if DFA succeeds we do some hairy stuff using the regex matcher
     to decide whether the match should really count. */
  if (match_words || match_lines)
    {
      static char const line_beg_no_bk[] = "^(";
      static char const line_end_no_bk[] = ")$";
      static char const word_beg_no_bk[] = "(^|[^[:alnum:]_])(";
      static char const word_end_no_bk[] = ")([^[:alnum:]_]|$)";
      static char const line_beg_bk[] = "^\\(";
      static char const line_end_bk[] = "\\)$";
      static char const word_beg_bk[] = "\\(^\\|[^[:alnum:]_]\\)\\(";
      static char const word_end_bk[] = "\\)\\([^[:alnum:]_]\\|$\\)";
      int bk = !(syntax_bits & RE_NO_BK_PARENS);
      char *n = xmalloc (sizeof word_beg_bk - 1 + size + sizeof word_end_bk);

      strcpy (n, match_lines ? (bk ? line_beg_bk : line_beg_no_bk)
			     : (bk ? word_beg_bk : word_beg_no_bk));
      total = strlen(n);
      memcpy (n + total, pattern, size);
      total += size;
      strcpy (n + total, match_lines ? (bk ? line_end_bk : line_end_no_bk)
				     : (bk ? word_end_bk : word_end_no_bk));
      total += strlen (n + total);
      pattern = motif = n;
      size = total;
    }
  else
    motif = NULL;

  dfacomp (pattern, size, &dfa, 1);
  kwsmusts ();

  free(motif);
}

size_t
EGexecute (char const *buf, size_t size, size_t *match_size,
	   char const *start_ptr)
{
  char const *buflim, *beg, *end, *match, *best_match, *mb_start;
  char eol = eolbyte;
  int backref, start, len, best_len;
  struct kwsmatch kwsm;
  size_t i, ret_val;
#ifdef MBS_SUPPORT
  if (MB_CUR_MAX > 1)
    {
      if (match_icase)
        {
          /* mbtolower adds a NUL byte at the end.  That will provide
	     space for the sentinel byte dfaexec may add.  */
          char *case_buf = mbtolower (buf, &size);
	  if (start_ptr)
	    start_ptr = case_buf + (start_ptr - buf);
          buf = case_buf;
        }
    }
#endif /* MBS_SUPPORT */

  mb_start = buf;
  buflim = buf + size;

  for (beg = end = buf; end < buflim; beg = end)
    {
      
//Patch 0:
if ((!start_ptr) || (__is_neg(25, &(start_ptr), sizeof (start_ptr), &(buf), sizeof (buf), &(buflim), sizeof (buflim), &(beg), sizeof (beg), &(end), sizeof (end), &(kwset), sizeof (kwset), &(size), sizeof (size), &(mb_start), sizeof (mb_start), &(eol), sizeof (eol), &(match), sizeof (match), &(match_icase), sizeof (match_icase), &(kwset_exact_matches), sizeof (kwset_exact_matches), &(eolbyte), sizeof (eolbyte), &(backref), sizeof (backref), &(best_match), sizeof (best_match), &(best_len), sizeof (best_len), &(i), sizeof (i), &(pcount), sizeof (pcount), &(patterns), sizeof (patterns), &(start), sizeof (start), &(len), sizeof (len), &(match_words), sizeof (match_words), &(match_lines), sizeof (match_lines), &(ret_val), sizeof (ret_val), &(match_size), sizeof (match_size)))) {
    if (kwset) {
        size_t offset = kwsexec(kwset, beg, buflim - beg, &kwsm);
        if (offset == (size_t)-1)
            goto failure;
        beg += offset;
        if ((end = memchr(beg, eol, buflim - beg)) != ((void *)0))
            end++;
        else
            end = buflim;
        match = beg;
        while (beg > buf && beg[-1] != eol)
            --beg;
        if (kwsm.index < kwset_exact_matches) {
            if (mb_start < beg)
                mb_start = beg;
            if ((__ctype_get_mb_cur_max()) == 1 || !is_mb_middle(&mb_start, match, buflim))
                goto success;
        }
        if (dfaexec(&dfa, beg, (char *)end, 0, ((void *)0), &backref) == ((void *)0))
            continue;
    } else {
        const char *next_beg = dfaexec(&dfa, beg, (char *)buflim, 0, ((void *)0), &backref);
        if (next_beg == ((void *)0))
            break;
        beg = next_beg;
        if ((end = memchr(beg, eol, buflim - beg)) != ((void *)0))
            end++;
        else
            end = buflim;
        while (beg > buf && beg[-1] != eol)
            --beg;
    }
    if (!backref)
        goto success;
} else {
    beg = start_ptr;
    end = buflim;
}

//CodeSeg 1:

      /* If we've made it to this point, this means DFA has seen
	 a probable match, and we need to run it through Regex. */
      best_match = end;
      best_len = 0;
      for (i = 0; i < pcount; i++)
	{
	  patterns[i].regexbuf.not_eol = 0;
	  if (0 <= (start = re_search (&(patterns[i].regexbuf),
				       buf, end - buf - 1,
				       beg - buf, end - beg - 1,
				       &(patterns[i].regs))))
	    {
	      len = patterns[i].regs.end[0] - start;
	      match = buf + start;
	      if (match > best_match)
		continue;
	      if (start_ptr && !match_words)
		goto assess_pattern_match;
	      if ((!match_lines && !match_words)
		  || (match_lines && len == end - beg - 1))
		{
		  match = beg;
		  len = end - beg;
		  goto assess_pattern_match;
		}
	      /* If -w, check if the match aligns with word boundaries.
		 We do this iteratively because:
		 (a) the line may contain more than one occurence of the
		 pattern, and
		 (b) Several alternatives in the pattern might be valid at a
		 given point, and we may need to consider a shorter one to
		 find a word boundary.  */
	      if (match_words)
		while (match <= best_match)
		  {
		    if ((match == buf || !WCHAR ((unsigned char) match[-1]))
			&& (len == end - beg - 1
			    || !WCHAR ((unsigned char) match[len])))
		      goto assess_pattern_match;
		    if (len > 0)
		      {
			/* Try a shorter length anchored at the same place. */
			--len;
			patterns[i].regexbuf.not_eol = 1;
			len = re_match (&(patterns[i].regexbuf),
					buf, match + len - beg, match - buf,
					&(patterns[i].regs));
		      }
		    if (len <= 0)
		      {
			/* Try looking further on. */
			if (match == end - 1)
			  break;
			match++;
			patterns[i].regexbuf.not_eol = 0;
			start = re_search (&(patterns[i].regexbuf),
					   buf, end - buf - 1,
					   match - buf, end - match - 1,
					   &(patterns[i].regs));
			if (start < 0)
			  break;
			len = patterns[i].regs.end[0] - start;
			match = buf + start;
		      }
		  } /* while (match <= best_match) */
	      continue;
	    assess_pattern_match:
	      if (!start_ptr)
		{
		  /* Good enough for a non-exact match.
		     No need to look at further patterns, if any.  */
		  beg = match;
		  goto success_in_len;
		}
	      if (match < best_match || (match == best_match && len > best_len))
		{
		  /* Best exact match:  leftmost, then longest.  */
		  best_match = match;
		  best_len = len;
		}
	    } /* if re_search >= 0 */
	} /* for Regex patterns.  */
	if (best_match < end)
	  {
	    /* We have found an exact match.  We were just
	       waiting for the best one (leftmost then longest).  */
	    beg = best_match;
	    len = best_len;
	    goto success_in_len;
	  }
    } /* for (beg = end ..) */

 failure:
  ret_val = -1;
  goto out;

 success:
  len = end - beg;
 success_in_len:
  *match_size = len;
  ret_val = beg - buf;
 out:
  return ret_val;
}

Testing negative cases!
Testing 0 (with abstract condition) ENVIS_NEG
Iteration 0
Running test command:
/home/ubuntu/spr-fast/tools/grep-test.py /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-8a025cf8-8f08d8e2/tempworkdir-l/src /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-8a025cf8-8f08d8e2/tempworkdir-l/tests /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-8a025cf8-8f08d8e2/tempworkdir-l 0  > __res
Opening:/tmp/neg.tmp!
NegativeBRANCH RECORD/tmp/neg.tmp!
Not caught by the negative case, give up!
APPENDING TO ISNEG:/tmp/neg.tmp!
Running test command:
/home/ubuntu/spr-fast/tools/grep-test.py /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-8a025cf8-8f08d8e2/tempworkdir-l/src /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-8a025cf8-8f08d8e2/tempworkdir-l/tests /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-8a025cf8-8f08d8e2/tempworkdir-l 0  > __res
a batched test job starts!
Building merged code:
src_file: src/dfasearch.c
full src: int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); void* memset(void*, int, unsigned long); 
/* dfasearch.c - searching subroutines using dfa and regex for grep.
   Copyright 1992, 1998, 2000, 2007, 2009-2010 Free Software Foundation, Inc.

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 3, or (at your option)
   any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program; if not, write to the Free Software
   Foundation, Inc., 51 Franklin Street - Fifth Floor, Boston, MA
   02110-1301, USA.  */

/* Written August 1992 by Mike Haertel. */

#include <config.h>
#include "search.h"
#include "dfa.h"

/* For -w, we also consider _ to be word constituent.  */
#define WCHAR(C) (ISALNUM(C) || (C) == '_')

/* KWset compiled pattern.  For Ecompile and Gcompile, we compile
   a list of strings, at least one of which is known to occur in
   any string matching the regexp. */
static kwset_t kwset;

/* DFA compiled regexp. */
static struct dfa dfa;

/* The Regex compiled patterns.  */
static struct patterns
{
  /* Regex compiled regexp. */
  struct re_pattern_buffer regexbuf;
  struct re_registers regs; /* This is here on account of a BRAIN-DEAD
			       Q@#%!# library interface in regex.c.  */
} patterns0;

struct patterns *patterns;
size_t pcount;

void
dfaerror (char const *mesg)
{
  error (EXIT_TROUBLE, 0, "%s", mesg);

  /* notreached */
  /* Tell static analyzers that this function does not return.  */
  abort ();
}

/* Number of compiled fixed strings known to exactly match the regexp.
   If kwsexec returns < kwset_exact_matches, then we don't need to
   call the regexp matcher at all. */
static int kwset_exact_matches;

static char const *
kwsincr_case (const char *must)
{
  const char *buf;
  size_t n;

  n = strlen (must);
#ifdef MBS_SUPPORT
  if (match_icase && MB_CUR_MAX > 1)
    buf = mbtolower (must, &n);
  else
#endif
    buf = must;
  return kwsincr (kwset, buf, n);
}

/* If the DFA turns out to have some set of fixed strings one of
   which must occur in the match, then we build a kwset matcher
   to find those strings, and thus quickly filter out impossible
   matches. */
static void
kwsmusts (void)
{
  struct dfamust const *dm;
  char const *err;

  if (dfa.musts)
    {
      kwsinit (&kwset);
      /* First, we compile in the substrings known to be exact
	 matches.  The kwset matcher will return the index
	 of the matching string that it chooses. */
      for (dm = dfa.musts; dm; dm = dm->next)
	{
	  if (!dm->exact)
	    continue;
	  ++kwset_exact_matches;
	  if ((err = kwsincr_case (dm->must)) != NULL)
	    error (EXIT_TROUBLE, 0, "%s", err);
	}
      /* Now, we compile the substrings that will require
	 the use of the regexp matcher.  */
      for (dm = dfa.musts; dm; dm = dm->next)
	{
	  if (dm->exact)
	    continue;
	  if ((err = kwsincr_case (dm->must)) != NULL)
	    error (EXIT_TROUBLE, 0, "%s", err);
	}
      if ((err = kwsprep (kwset)) != NULL)
	error (EXIT_TROUBLE, 0, "%s", err);
    }
}

void
GEAcompile (char const *pattern, size_t size, reg_syntax_t syntax_bits)
{
  const char *err;
  const char *p, *sep;
  size_t total = size;
  char *motif;

  if (match_icase)
    syntax_bits |= RE_ICASE;
  re_set_syntax (syntax_bits);
  dfasyntax (syntax_bits, match_icase, eolbyte);

  /* For GNU regex compiler we have to pass the patterns separately to detect
     errors like "[\nallo\n]\n".  The patterns here are "[", "allo" and "]"
     GNU regex should have raise a syntax error.  The same for backref, where
     the backref should have been local to each pattern.  */
  p = pattern;
  do
    {
      size_t len;
      sep = memchr (p, '\n', total);
      if (sep)
	{
	  len = sep - p;
	  sep++;
	  total -= (len + 1);
	}
      else
	{
	  len = total;
	  total = 0;
	}

      patterns = realloc (patterns, (pcount + 1) * sizeof (*patterns));
      if (patterns == NULL)
	error (EXIT_TROUBLE, errno, _("memory exhausted"));
      patterns[pcount] = patterns0;

      if ((err = re_compile_pattern (p, len,
				    &(patterns[pcount].regexbuf))) != NULL)
	error (EXIT_TROUBLE, 0, "%s", err);
      pcount++;

      p = sep;
    } while (sep && total != 0);

  /* In the match_words and match_lines cases, we use a different pattern
     for the DFA matcher that will quickly throw out cases that won't work.
     Then if DFA succeeds we do some hairy stuff using the regex matcher
     to decide whether the match should really count. */
  if (match_words || match_lines)
    {
      static char const line_beg_no_bk[] = "^(";
      static char const line_end_no_bk[] = ")$";
      static char const word_beg_no_bk[] = "(^|[^[:alnum:]_])(";
      static char const word_end_no_bk[] = ")([^[:alnum:]_]|$)";
      static char const line_beg_bk[] = "^\\(";
      static char const line_end_bk[] = "\\)$";
      static char const word_beg_bk[] = "\\(^\\|[^[:alnum:]_]\\)\\(";
      static char const word_end_bk[] = "\\)\\([^[:alnum:]_]\\|$\\)";
      int bk = !(syntax_bits & RE_NO_BK_PARENS);
      char *n = xmalloc (sizeof word_beg_bk - 1 + size + sizeof word_end_bk);

      strcpy (n, match_lines ? (bk ? line_beg_bk : line_beg_no_bk)
			     : (bk ? word_beg_bk : word_beg_no_bk));
      total = strlen(n);
      memcpy (n + total, pattern, size);
      total += size;
      strcpy (n + total, match_lines ? (bk ? line_end_bk : line_end_no_bk)
				     : (bk ? word_end_bk : word_end_no_bk));
      total += strlen (n + total);
      pattern = motif = n;
      size = total;
    }
  else
    motif = NULL;

  dfacomp (pattern, size, &dfa, 1);
  kwsmusts ();

  free(motif);
}

size_t
EGexecute (char const *buf, size_t size, size_t *match_size,
	   char const *start_ptr)
{
  char const *buflim, *beg, *end, *match, *best_match, *mb_start;
  char eol = eolbyte;
  int backref, start, len, best_len;
  struct kwsmatch kwsm;
  size_t i, ret_val;
#ifdef MBS_SUPPORT
  if (MB_CUR_MAX > 1)
    {
      if (match_icase)
        {
          /* mbtolower adds a NUL byte at the end.  That will provide
	     space for the sentinel byte dfaexec may add.  */
          char *case_buf = mbtolower (buf, &size);
	  if (start_ptr)
	    start_ptr = case_buf + (start_ptr - buf);
          buf = case_buf;
        }
    }
#endif /* MBS_SUPPORT */

  mb_start = buf;
  buflim = buf + size;

  for (beg = end = buf; end < buflim; beg = end)
    {
      if (!start_ptr)
	{
	  /* We don't care about an exact match.  */
	  //prophet generated patch
	  if (__get_mutant()==0) {
	  if ((kwset) && !(__is_neg(25, &(kwset), sizeof (kwset), &(start_ptr), sizeof (start_ptr), &(buflim), sizeof (buflim), &(beg), sizeof (beg), &(buf), sizeof (buf), &(end), sizeof (end), &(size), sizeof (size), &(mb_start), sizeof (mb_start), &(eol), sizeof (eol), &(match), sizeof (match), &(kwset_exact_matches), sizeof (kwset_exact_matches), &(match_icase), sizeof (match_icase), &(backref), sizeof (backref), &(eolbyte), sizeof (eolbyte), &(best_match), sizeof (best_match), &(best_len), sizeof (best_len), &(i), sizeof (i), &(pcount), sizeof (pcount), &(patterns), sizeof (patterns), &(start), sizeof (start), &(len), sizeof (len), &(match_words), sizeof (match_words), &(match_lines), sizeof (match_lines), &(ret_val), sizeof (ret_val), &(match_size), sizeof (match_size)))) {
	      size_t offset = kwsexec(kwset, beg, buflim - beg, &kwsm);
	      if (offset == (size_t)-1)
	          goto failure;
	      beg += offset;
	      if ((end = memchr(beg, eol, buflim - beg)) != ((void *)0))
	          end++;
	      else
	          end = buflim;
	      match = beg;
	      while (beg > buf && beg[-1] != eol)
	          --beg;
	      if (kwsm.index < kwset_exact_matches) {
	          if (mb_start < beg)
	              mb_start = beg;
	          if ((__ctype_get_mb_cur_max()) == 1 || !is_mb_middle(&mb_start, match, buflim))
	              goto success;
	      }
	      if (dfaexec(&dfa, beg, (char *)end, 0, ((void *)0), &backref) == ((void *)0))
	          continue;
	  } else {
	      const char *next_beg = dfaexec(&dfa, beg, (char *)buflim, 0, ((void *)0), &backref);
	      if (next_beg == ((void *)0))
	          break;
	      beg = next_beg;
	      if ((end = memchr(beg, eol, buflim - beg)) != ((void *)0))
	          end++;
	      else
	          end = buflim;
	      while (beg > buf && beg[-1] != eol)
	          --beg;
	  }
	  }
	  else if (__get_mutant()==1) {
	  if ((kwset) || (__is_neg(25, &(kwset), sizeof (kwset), &(start_ptr), sizeof (start_ptr), &(buflim), sizeof (buflim), &(beg), sizeof (beg), &(buf), sizeof (buf), &(end), sizeof (end), &(size), sizeof (size), &(mb_start), sizeof (mb_start), &(eol), sizeof (eol), &(match), sizeof (match), &(kwset_exact_matches), sizeof (kwset_exact_matches), &(match_icase), sizeof (match_icase), &(backref), sizeof (backref), &(eolbyte), sizeof (eolbyte), &(best_match), sizeof (best_match), &(best_len), sizeof (best_len), &(i), sizeof (i), &(pcount), sizeof (pcount), &(patterns), sizeof (patterns), &(start), sizeof (start), &(len), sizeof (len), &(match_words), sizeof (match_words), &(match_lines), sizeof (match_lines), &(ret_val), sizeof (ret_val), &(match_size), sizeof (match_size)))) {
	      size_t offset = kwsexec(kwset, beg, buflim - beg, &kwsm);
	      if (offset == (size_t)-1)
	          goto failure;
	      beg += offset;
	      if ((end = memchr(beg, eol, buflim - beg)) != ((void *)0))
	          end++;
	      else
	          end = buflim;
	      match = beg;
	      while (beg > buf && beg[-1] != eol)
	          --beg;
	      if (kwsm.index < kwset_exact_matches) {
	          if (mb_start < beg)
	              mb_start = beg;
	          if ((__ctype_get_mb_cur_max()) == 1 || !is_mb_middle(&mb_start, match, buflim))
	              goto success;
	      }
	      if (dfaexec(&dfa, beg, (char *)end, 0, ((void *)0), &backref) == ((void *)0))
	          continue;
	  } else {
	      const char *next_beg = dfaexec(&dfa, beg, (char *)buflim, 0, ((void *)0), &backref);
	      if (next_beg == ((void *)0))
	          break;
	      beg = next_beg;
	      if ((end = memchr(beg, eol, buflim - beg)) != ((void *)0))
	          end++;
	      else
	          end = buflim;
	      while (beg > buf && beg[-1] != eol)
	          --beg;
	  }
	  }
	  /* Successful, no backreferences encountered! */
	  if (!backref)
	    goto success;
	}
      else
	{
	  /* We are looking for the leftmost (then longest) exact match.
	     We will go through the outer loop only once.  */
	  beg = start_ptr;
	  end = buflim;
	}

      /* If we've made it to this point, this means DFA has seen
	 a probable match, and we need to run it through Regex. */
      best_match = end;
      best_len = 0;
      for (i = 0; i < pcount; i++)
	{
	  patterns[i].regexbuf.not_eol = 0;
	  if (0 <= (start = re_search (&(patterns[i].regexbuf),
				       buf, end - buf - 1,
				       beg - buf, end - beg - 1,
				       &(patterns[i].regs))))
	    {
	      len = patterns[i].regs.end[0] - start;
	      match = buf + start;
	      if (match > best_match)
		continue;
	      if (start_ptr && !match_words)
		goto assess_pattern_match;
	      if ((!match_lines && !match_words)
		  || (match_lines && len == end - beg - 1))
		{
		  match = beg;
		  len = end - beg;
		  goto assess_pattern_match;
		}
	      /* If -w, check if the match aligns with word boundaries.
		 We do this iteratively because:
		 (a) the line may contain more than one occurence of the
		 pattern, and
		 (b) Several alternatives in the pattern might be valid at a
		 given point, and we may need to consider a shorter one to
		 find a word boundary.  */
	      if (match_words)
		while (match <= best_match)
		  {
		    if ((match == buf || !WCHAR ((unsigned char) match[-1]))
			&& (len == end - beg - 1
			    || !WCHAR ((unsigned char) match[len])))
		      goto assess_pattern_match;
		    if (len > 0)
		      {
			/* Try a shorter length anchored at the same place. */
			--len;
			patterns[i].regexbuf.not_eol = 1;
			len = re_match (&(patterns[i].regexbuf),
					buf, match + len - beg, match - buf,
					&(patterns[i].regs));
		      }
		    if (len <= 0)
		      {
			/* Try looking further on. */
			if (match == end - 1)
			  break;
			match++;
			patterns[i].regexbuf.not_eol = 0;
			start = re_search (&(patterns[i].regexbuf),
					   buf, end - buf - 1,
					   match - buf, end - match - 1,
					   &(patterns[i].regs));
			if (start < 0)
			  break;
			len = patterns[i].regs.end[0] - start;
			match = buf + start;
		      }
		  } /* while (match <= best_match) */
	      continue;
	    assess_pattern_match:
	      if (!start_ptr)
		{
		  /* Good enough for a non-exact match.
		     No need to look at further patterns, if any.  */
		  beg = match;
		  goto success_in_len;
		}
	      if (match < best_match || (match == best_match && len > best_len))
		{
		  /* Best exact match:  leftmost, then longest.  */
		  best_match = match;
		  best_len = len;
		}
	    } /* if re_search >= 0 */
	} /* for Regex patterns.  */
	if (best_match < end)
	  {
	    /* We have found an exact match.  We were just
	       waiting for the best one (leftmost then longest).  */
	    beg = best_match;
	    len = best_len;
	    goto success_in_len;
	  }
    } /* for (beg = end ..) */

 failure:
  ret_val = -1;
  goto out;

 success:
  len = end - beg;
 success_in_len:
  *match_size = len;
  ret_val = beg - buf;
 out:
  return ret_val;
}

Building:src at:
/home/ubuntu/spr-fast/tests/corebench/grep/grep-case-8a025cf8-8f08d8e2/tempworkdir-l/srcMerged code building succ, going to invoke tester!
CondTester, Testing instance id 49:
//src_file:src/dfasearch.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); void* memset(void*, int, unsigned long); 
/* dfasearch.c - searching subroutines using dfa and regex for grep.
   Copyright 1992, 1998, 2000, 2007, 2009-2010 Free Software Foundation, Inc.

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 3, or (at your option)
   any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program; if not, write to the Free Software
   Foundation, Inc., 51 Franklin Street - Fifth Floor, Boston, MA
   02110-1301, USA.  */

/* Written August 1992 by Mike Haertel. */

#include <config.h>
#include "search.h"
#include "dfa.h"

/* For -w, we also consider _ to be word constituent.  */
#define WCHAR(C) (ISALNUM(C) || (C) == '_')

/* KWset compiled pattern.  For Ecompile and Gcompile, we compile
   a list of strings, at least one of which is known to occur in
   any string matching the regexp. */
static kwset_t kwset;

/* DFA compiled regexp. */
static struct dfa dfa;

/* The Regex compiled patterns.  */
static struct patterns
{
  /* Regex compiled regexp. */
  struct re_pattern_buffer regexbuf;
  struct re_registers regs; /* This is here on account of a BRAIN-DEAD
			       Q@#%!# library interface in regex.c.  */
} patterns0;

struct patterns *patterns;
size_t pcount;

void
dfaerror (char const *mesg)
{
  error (EXIT_TROUBLE, 0, "%s", mesg);

  /* notreached */
  /* Tell static analyzers that this function does not return.  */
  abort ();
}

/* Number of compiled fixed strings known to exactly match the regexp.
   If kwsexec returns < kwset_exact_matches, then we don't need to
   call the regexp matcher at all. */
static int kwset_exact_matches;

static char const *
kwsincr_case (const char *must)
{
  const char *buf;
  size_t n;

  n = strlen (must);
#ifdef MBS_SUPPORT
  if (match_icase && MB_CUR_MAX > 1)
    buf = mbtolower (must, &n);
  else
#endif
    buf = must;
  return kwsincr (kwset, buf, n);
}

/* If the DFA turns out to have some set of fixed strings one of
   which must occur in the match, then we build a kwset matcher
   to find those strings, and thus quickly filter out impossible
   matches. */
static void
kwsmusts (void)
{
  struct dfamust const *dm;
  char const *err;

  if (dfa.musts)
    {
      kwsinit (&kwset);
      /* First, we compile in the substrings known to be exact
	 matches.  The kwset matcher will return the index
	 of the matching string that it chooses. */
      for (dm = dfa.musts; dm; dm = dm->next)
	{
	  if (!dm->exact)
	    continue;
	  ++kwset_exact_matches;
	  if ((err = kwsincr_case (dm->must)) != NULL)
	    error (EXIT_TROUBLE, 0, "%s", err);
	}
      /* Now, we compile the substrings that will require
	 the use of the regexp matcher.  */
      for (dm = dfa.musts; dm; dm = dm->next)
	{
	  if (dm->exact)
	    continue;
	  if ((err = kwsincr_case (dm->must)) != NULL)
	    error (EXIT_TROUBLE, 0, "%s", err);
	}
      if ((err = kwsprep (kwset)) != NULL)
	error (EXIT_TROUBLE, 0, "%s", err);
    }
}

void
GEAcompile (char const *pattern, size_t size, reg_syntax_t syntax_bits)
{
  const char *err;
  const char *p, *sep;
  size_t total = size;
  char *motif;

  if (match_icase)
    syntax_bits |= RE_ICASE;
  re_set_syntax (syntax_bits);
  dfasyntax (syntax_bits, match_icase, eolbyte);

  /* For GNU regex compiler we have to pass the patterns separately to detect
     errors like "[\nallo\n]\n".  The patterns here are "[", "allo" and "]"
     GNU regex should have raise a syntax error.  The same for backref, where
     the backref should have been local to each pattern.  */
  p = pattern;
  do
    {
      size_t len;
      sep = memchr (p, '\n', total);
      if (sep)
	{
	  len = sep - p;
	  sep++;
	  total -= (len + 1);
	}
      else
	{
	  len = total;
	  total = 0;
	}

      patterns = realloc (patterns, (pcount + 1) * sizeof (*patterns));
      if (patterns == NULL)
	error (EXIT_TROUBLE, errno, _("memory exhausted"));
      patterns[pcount] = patterns0;

      if ((err = re_compile_pattern (p, len,
				    &(patterns[pcount].regexbuf))) != NULL)
	error (EXIT_TROUBLE, 0, "%s", err);
      pcount++;

      p = sep;
    } while (sep && total != 0);

  /* In the match_words and match_lines cases, we use a different pattern
     for the DFA matcher that will quickly throw out cases that won't work.
     Then if DFA succeeds we do some hairy stuff using the regex matcher
     to decide whether the match should really count. */
  if (match_words || match_lines)
    {
      static char const line_beg_no_bk[] = "^(";
      static char const line_end_no_bk[] = ")$";
      static char const word_beg_no_bk[] = "(^|[^[:alnum:]_])(";
      static char const word_end_no_bk[] = ")([^[:alnum:]_]|$)";
      static char const line_beg_bk[] = "^\\(";
      static char const line_end_bk[] = "\\)$";
      static char const word_beg_bk[] = "\\(^\\|[^[:alnum:]_]\\)\\(";
      static char const word_end_bk[] = "\\)\\([^[:alnum:]_]\\|$\\)";
      int bk = !(syntax_bits & RE_NO_BK_PARENS);
      char *n = xmalloc (sizeof word_beg_bk - 1 + size + sizeof word_end_bk);

      strcpy (n, match_lines ? (bk ? line_beg_bk : line_beg_no_bk)
			     : (bk ? word_beg_bk : word_beg_no_bk));
      total = strlen(n);
      memcpy (n + total, pattern, size);
      total += size;
      strcpy (n + total, match_lines ? (bk ? line_end_bk : line_end_no_bk)
				     : (bk ? word_end_bk : word_end_no_bk));
      total += strlen (n + total);
      pattern = motif = n;
      size = total;
    }
  else
    motif = NULL;

  dfacomp (pattern, size, &dfa, 1);
  kwsmusts ();

  free(motif);
}

size_t
EGexecute (char const *buf, size_t size, size_t *match_size,
	   char const *start_ptr)
{
  char const *buflim, *beg, *end, *match, *best_match, *mb_start;
  char eol = eolbyte;
  int backref, start, len, best_len;
  struct kwsmatch kwsm;
  size_t i, ret_val;
#ifdef MBS_SUPPORT
  if (MB_CUR_MAX > 1)
    {
      if (match_icase)
        {
          /* mbtolower adds a NUL byte at the end.  That will provide
	     space for the sentinel byte dfaexec may add.  */
          char *case_buf = mbtolower (buf, &size);
	  if (start_ptr)
	    start_ptr = case_buf + (start_ptr - buf);
          buf = case_buf;
        }
    }
#endif /* MBS_SUPPORT */

  mb_start = buf;
  buflim = buf + size;

  for (beg = end = buf; end < buflim; beg = end)
    {
      if (!start_ptr)
	{
	  /* We don't care about an exact match.  */
	  
//Patch 0:
if ((kwset) && !(__is_neg(25, &(kwset), sizeof (kwset), &(start_ptr), sizeof (start_ptr), &(buflim), sizeof (buflim), &(beg), sizeof (beg), &(buf), sizeof (buf), &(end), sizeof (end), &(size), sizeof (size), &(mb_start), sizeof (mb_start), &(eol), sizeof (eol), &(match), sizeof (match), &(kwset_exact_matches), sizeof (kwset_exact_matches), &(match_icase), sizeof (match_icase), &(backref), sizeof (backref), &(eolbyte), sizeof (eolbyte), &(best_match), sizeof (best_match), &(best_len), sizeof (best_len), &(i), sizeof (i), &(pcount), sizeof (pcount), &(patterns), sizeof (patterns), &(start), sizeof (start), &(len), sizeof (len), &(match_words), sizeof (match_words), &(match_lines), sizeof (match_lines), &(ret_val), sizeof (ret_val), &(match_size), sizeof (match_size)))) {
    size_t offset = kwsexec(kwset, beg, buflim - beg, &kwsm);
    if (offset == (size_t)-1)
        goto failure;
    beg += offset;
    if ((end = memchr(beg, eol, buflim - beg)) != ((void *)0))
        end++;
    else
        end = buflim;
    match = beg;
    while (beg > buf && beg[-1] != eol)
        --beg;
    if (kwsm.index < kwset_exact_matches) {
        if (mb_start < beg)
            mb_start = beg;
        if ((__ctype_get_mb_cur_max()) == 1 || !is_mb_middle(&mb_start, match, buflim))
            goto success;
    }
    if (dfaexec(&dfa, beg, (char *)end, 0, ((void *)0), &backref) == ((void *)0))
        continue;
} else {
    const char *next_beg = dfaexec(&dfa, beg, (char *)buflim, 0, ((void *)0), &backref);
    if (next_beg == ((void *)0))
        break;
    beg = next_beg;
    if ((end = memchr(beg, eol, buflim - beg)) != ((void *)0))
        end++;
    else
        end = buflim;
    while (beg > buf && beg[-1] != eol)
        --beg;
}

//CodeSeg 1:
	  /* Successful, no backreferences encountered! */
	  if (!backref)
	    goto success;
	}
      else
	{
	  /* We are looking for the leftmost (then longest) exact match.
	     We will go through the outer loop only once.  */
	  beg = start_ptr;
	  end = buflim;
	}

      /* If we've made it to this point, this means DFA has seen
	 a probable match, and we need to run it through Regex. */
      best_match = end;
      best_len = 0;
      for (i = 0; i < pcount; i++)
	{
	  patterns[i].regexbuf.not_eol = 0;
	  if (0 <= (start = re_search (&(patterns[i].regexbuf),
				       buf, end - buf - 1,
				       beg - buf, end - beg - 1,
				       &(patterns[i].regs))))
	    {
	      len = patterns[i].regs.end[0] - start;
	      match = buf + start;
	      if (match > best_match)
		continue;
	      if (start_ptr && !match_words)
		goto assess_pattern_match;
	      if ((!match_lines && !match_words)
		  || (match_lines && len == end - beg - 1))
		{
		  match = beg;
		  len = end - beg;
		  goto assess_pattern_match;
		}
	      /* If -w, check if the match aligns with word boundaries.
		 We do this iteratively because:
		 (a) the line may contain more than one occurence of the
		 pattern, and
		 (b) Several alternatives in the pattern might be valid at a
		 given point, and we may need to consider a shorter one to
		 find a word boundary.  */
	      if (match_words)
		while (match <= best_match)
		  {
		    if ((match == buf || !WCHAR ((unsigned char) match[-1]))
			&& (len == end - beg - 1
			    || !WCHAR ((unsigned char) match[len])))
		      goto assess_pattern_match;
		    if (len > 0)
		      {
			/* Try a shorter length anchored at the same place. */
			--len;
			patterns[i].regexbuf.not_eol = 1;
			len = re_match (&(patterns[i].regexbuf),
					buf, match + len - beg, match - buf,
					&(patterns[i].regs));
		      }
		    if (len <= 0)
		      {
			/* Try looking further on. */
			if (match == end - 1)
			  break;
			match++;
			patterns[i].regexbuf.not_eol = 0;
			start = re_search (&(patterns[i].regexbuf),
					   buf, end - buf - 1,
					   match - buf, end - match - 1,
					   &(patterns[i].regs));
			if (start < 0)
			  break;
			len = patterns[i].regs.end[0] - start;
			match = buf + start;
		      }
		  } /* while (match <= best_match) */
	      continue;
	    assess_pattern_match:
	      if (!start_ptr)
		{
		  /* Good enough for a non-exact match.
		     No need to look at further patterns, if any.  */
		  beg = match;
		  goto success_in_len;
		}
	      if (match < best_match || (match == best_match && len > best_len))
		{
		  /* Best exact match:  leftmost, then longest.  */
		  best_match = match;
		  best_len = len;
		}
	    } /* if re_search >= 0 */
	} /* for Regex patterns.  */
	if (best_match < end)
	  {
	    /* We have found an exact match.  We were just
	       waiting for the best one (leftmost then longest).  */
	    beg = best_match;
	    len = best_len;
	    goto success_in_len;
	  }
    } /* for (beg = end ..) */

 failure:
  ret_val = -1;
  goto out;

 success:
  len = end - beg;
 success_in_len:
  *match_size = len;
  ret_val = beg - buf;
 out:
  return ret_val;
}

Testing negative cases!
Testing 0 (with abstract condition) ENVIS_NEG
Iteration 0
Running test command:
/home/ubuntu/spr-fast/tools/grep-test.py /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-8a025cf8-8f08d8e2/tempworkdir-l/src /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-8a025cf8-8f08d8e2/tempworkdir-l/tests /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-8a025cf8-8f08d8e2/tempworkdir-l 0  > __res
Opening:/tmp/neg.tmp!
NegativeBRANCH RECORD/tmp/neg.tmp!
APPENDING TO ISNEG:/tmp/neg.tmp!
Branch 0: 0
Branch 1: 0
Iteration 1
Running test command:
/home/ubuntu/spr-fast/tools/grep-test.py /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-8a025cf8-8f08d8e2/tempworkdir-l/src /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-8a025cf8-8f08d8e2/tempworkdir-l/tests /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-8a025cf8-8f08d8e2/tempworkdir-l 0  > __res
Opening:/tmp/neg.tmp!
NegativeBRANCH RECORD/tmp/neg.tmp!
APPENDING TO ISNEG:/tmp/neg.tmp!
Branch 0: 0
Branch 1: 1
Iteration 2
Running test command:
/home/ubuntu/spr-fast/tools/grep-test.py /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-8a025cf8-8f08d8e2/tempworkdir-l/src /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-8a025cf8-8f08d8e2/tempworkdir-l/tests /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-8a025cf8-8f08d8e2/tempworkdir-l 0  > __res
Opening:/tmp/neg.tmp!
NegativeBRANCH RECORD/tmp/neg.tmp!
APPENDING TO ISNEG:/tmp/neg.tmp!
Branch 0: 1
Branch 1: 0
Iteration 3
Running test command:
/home/ubuntu/spr-fast/tools/grep-test.py /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-8a025cf8-8f08d8e2/tempworkdir-l/src /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-8a025cf8-8f08d8e2/tempworkdir-l/tests /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-8a025cf8-8f08d8e2/tempworkdir-l 0  > __res
Opening:/tmp/neg.tmp!
NegativeBRANCH RECORD/tmp/neg.tmp!
APPENDING TO ISNEG:/tmp/neg.tmp!
Branch 0: 1
Branch 1: 1
Running test command:
/home/ubuntu/spr-fast/tools/grep-test.py /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-8a025cf8-8f08d8e2/tempworkdir-l/src /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-8a025cf8-8f08d8e2/tempworkdir-l/tests /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-8a025cf8-8f08d8e2/tempworkdir-l 0  > __res
CondTester, Testing instance id 50:
//src_file:src/dfasearch.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); void* memset(void*, int, unsigned long); 
/* dfasearch.c - searching subroutines using dfa and regex for grep.
   Copyright 1992, 1998, 2000, 2007, 2009-2010 Free Software Foundation, Inc.

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 3, or (at your option)
   any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program; if not, write to the Free Software
   Foundation, Inc., 51 Franklin Street - Fifth Floor, Boston, MA
   02110-1301, USA.  */

/* Written August 1992 by Mike Haertel. */

#include <config.h>
#include "search.h"
#include "dfa.h"

/* For -w, we also consider _ to be word constituent.  */
#define WCHAR(C) (ISALNUM(C) || (C) == '_')

/* KWset compiled pattern.  For Ecompile and Gcompile, we compile
   a list of strings, at least one of which is known to occur in
   any string matching the regexp. */
static kwset_t kwset;

/* DFA compiled regexp. */
static struct dfa dfa;

/* The Regex compiled patterns.  */
static struct patterns
{
  /* Regex compiled regexp. */
  struct re_pattern_buffer regexbuf;
  struct re_registers regs; /* This is here on account of a BRAIN-DEAD
			       Q@#%!# library interface in regex.c.  */
} patterns0;

struct patterns *patterns;
size_t pcount;

void
dfaerror (char const *mesg)
{
  error (EXIT_TROUBLE, 0, "%s", mesg);

  /* notreached */
  /* Tell static analyzers that this function does not return.  */
  abort ();
}

/* Number of compiled fixed strings known to exactly match the regexp.
   If kwsexec returns < kwset_exact_matches, then we don't need to
   call the regexp matcher at all. */
static int kwset_exact_matches;

static char const *
kwsincr_case (const char *must)
{
  const char *buf;
  size_t n;

  n = strlen (must);
#ifdef MBS_SUPPORT
  if (match_icase && MB_CUR_MAX > 1)
    buf = mbtolower (must, &n);
  else
#endif
    buf = must;
  return kwsincr (kwset, buf, n);
}

/* If the DFA turns out to have some set of fixed strings one of
   which must occur in the match, then we build a kwset matcher
   to find those strings, and thus quickly filter out impossible
   matches. */
static void
kwsmusts (void)
{
  struct dfamust const *dm;
  char const *err;

  if (dfa.musts)
    {
      kwsinit (&kwset);
      /* First, we compile in the substrings known to be exact
	 matches.  The kwset matcher will return the index
	 of the matching string that it chooses. */
      for (dm = dfa.musts; dm; dm = dm->next)
	{
	  if (!dm->exact)
	    continue;
	  ++kwset_exact_matches;
	  if ((err = kwsincr_case (dm->must)) != NULL)
	    error (EXIT_TROUBLE, 0, "%s", err);
	}
      /* Now, we compile the substrings that will require
	 the use of the regexp matcher.  */
      for (dm = dfa.musts; dm; dm = dm->next)
	{
	  if (dm->exact)
	    continue;
	  if ((err = kwsincr_case (dm->must)) != NULL)
	    error (EXIT_TROUBLE, 0, "%s", err);
	}
      if ((err = kwsprep (kwset)) != NULL)
	error (EXIT_TROUBLE, 0, "%s", err);
    }
}

void
GEAcompile (char const *pattern, size_t size, reg_syntax_t syntax_bits)
{
  const char *err;
  const char *p, *sep;
  size_t total = size;
  char *motif;

  if (match_icase)
    syntax_bits |= RE_ICASE;
  re_set_syntax (syntax_bits);
  dfasyntax (syntax_bits, match_icase, eolbyte);

  /* For GNU regex compiler we have to pass the patterns separately to detect
     errors like "[\nallo\n]\n".  The patterns here are "[", "allo" and "]"
     GNU regex should have raise a syntax error.  The same for backref, where
     the backref should have been local to each pattern.  */
  p = pattern;
  do
    {
      size_t len;
      sep = memchr (p, '\n', total);
      if (sep)
	{
	  len = sep - p;
	  sep++;
	  total -= (len + 1);
	}
      else
	{
	  len = total;
	  total = 0;
	}

      patterns = realloc (patterns, (pcount + 1) * sizeof (*patterns));
      if (patterns == NULL)
	error (EXIT_TROUBLE, errno, _("memory exhausted"));
      patterns[pcount] = patterns0;

      if ((err = re_compile_pattern (p, len,
				    &(patterns[pcount].regexbuf))) != NULL)
	error (EXIT_TROUBLE, 0, "%s", err);
      pcount++;

      p = sep;
    } while (sep && total != 0);

  /* In the match_words and match_lines cases, we use a different pattern
     for the DFA matcher that will quickly throw out cases that won't work.
     Then if DFA succeeds we do some hairy stuff using the regex matcher
     to decide whether the match should really count. */
  if (match_words || match_lines)
    {
      static char const line_beg_no_bk[] = "^(";
      static char const line_end_no_bk[] = ")$";
      static char const word_beg_no_bk[] = "(^|[^[:alnum:]_])(";
      static char const word_end_no_bk[] = ")([^[:alnum:]_]|$)";
      static char const line_beg_bk[] = "^\\(";
      static char const line_end_bk[] = "\\)$";
      static char const word_beg_bk[] = "\\(^\\|[^[:alnum:]_]\\)\\(";
      static char const word_end_bk[] = "\\)\\([^[:alnum:]_]\\|$\\)";
      int bk = !(syntax_bits & RE_NO_BK_PARENS);
      char *n = xmalloc (sizeof word_beg_bk - 1 + size + sizeof word_end_bk);

      strcpy (n, match_lines ? (bk ? line_beg_bk : line_beg_no_bk)
			     : (bk ? word_beg_bk : word_beg_no_bk));
      total = strlen(n);
      memcpy (n + total, pattern, size);
      total += size;
      strcpy (n + total, match_lines ? (bk ? line_end_bk : line_end_no_bk)
				     : (bk ? word_end_bk : word_end_no_bk));
      total += strlen (n + total);
      pattern = motif = n;
      size = total;
    }
  else
    motif = NULL;

  dfacomp (pattern, size, &dfa, 1);
  kwsmusts ();

  free(motif);
}

size_t
EGexecute (char const *buf, size_t size, size_t *match_size,
	   char const *start_ptr)
{
  char const *buflim, *beg, *end, *match, *best_match, *mb_start;
  char eol = eolbyte;
  int backref, start, len, best_len;
  struct kwsmatch kwsm;
  size_t i, ret_val;
#ifdef MBS_SUPPORT
  if (MB_CUR_MAX > 1)
    {
      if (match_icase)
        {
          /* mbtolower adds a NUL byte at the end.  That will provide
	     space for the sentinel byte dfaexec may add.  */
          char *case_buf = mbtolower (buf, &size);
	  if (start_ptr)
	    start_ptr = case_buf + (start_ptr - buf);
          buf = case_buf;
        }
    }
#endif /* MBS_SUPPORT */

  mb_start = buf;
  buflim = buf + size;

  for (beg = end = buf; end < buflim; beg = end)
    {
      if (!start_ptr)
	{
	  /* We don't care about an exact match.  */
	  
//Patch 0:
if ((kwset) || (__is_neg(25, &(kwset), sizeof (kwset), &(start_ptr), sizeof (start_ptr), &(buflim), sizeof (buflim), &(beg), sizeof (beg), &(buf), sizeof (buf), &(end), sizeof (end), &(size), sizeof (size), &(mb_start), sizeof (mb_start), &(eol), sizeof (eol), &(match), sizeof (match), &(kwset_exact_matches), sizeof (kwset_exact_matches), &(match_icase), sizeof (match_icase), &(backref), sizeof (backref), &(eolbyte), sizeof (eolbyte), &(best_match), sizeof (best_match), &(best_len), sizeof (best_len), &(i), sizeof (i), &(pcount), sizeof (pcount), &(patterns), sizeof (patterns), &(start), sizeof (start), &(len), sizeof (len), &(match_words), sizeof (match_words), &(match_lines), sizeof (match_lines), &(ret_val), sizeof (ret_val), &(match_size), sizeof (match_size)))) {
    size_t offset = kwsexec(kwset, beg, buflim - beg, &kwsm);
    if (offset == (size_t)-1)
        goto failure;
    beg += offset;
    if ((end = memchr(beg, eol, buflim - beg)) != ((void *)0))
        end++;
    else
        end = buflim;
    match = beg;
    while (beg > buf && beg[-1] != eol)
        --beg;
    if (kwsm.index < kwset_exact_matches) {
        if (mb_start < beg)
            mb_start = beg;
        if ((__ctype_get_mb_cur_max()) == 1 || !is_mb_middle(&mb_start, match, buflim))
            goto success;
    }
    if (dfaexec(&dfa, beg, (char *)end, 0, ((void *)0), &backref) == ((void *)0))
        continue;
} else {
    const char *next_beg = dfaexec(&dfa, beg, (char *)buflim, 0, ((void *)0), &backref);
    if (next_beg == ((void *)0))
        break;
    beg = next_beg;
    if ((end = memchr(beg, eol, buflim - beg)) != ((void *)0))
        end++;
    else
        end = buflim;
    while (beg > buf && beg[-1] != eol)
        --beg;
}

//CodeSeg 1:
	  /* Successful, no backreferences encountered! */
	  if (!backref)
	    goto success;
	}
      else
	{
	  /* We are looking for the leftmost (then longest) exact match.
	     We will go through the outer loop only once.  */
	  beg = start_ptr;
	  end = buflim;
	}

      /* If we've made it to this point, this means DFA has seen
	 a probable match, and we need to run it through Regex. */
      best_match = end;
      best_len = 0;
      for (i = 0; i < pcount; i++)
	{
	  patterns[i].regexbuf.not_eol = 0;
	  if (0 <= (start = re_search (&(patterns[i].regexbuf),
				       buf, end - buf - 1,
				       beg - buf, end - beg - 1,
				       &(patterns[i].regs))))
	    {
	      len = patterns[i].regs.end[0] - start;
	      match = buf + start;
	      if (match > best_match)
		continue;
	      if (start_ptr && !match_words)
		goto assess_pattern_match;
	      if ((!match_lines && !match_words)
		  || (match_lines && len == end - beg - 1))
		{
		  match = beg;
		  len = end - beg;
		  goto assess_pattern_match;
		}
	      /* If -w, check if the match aligns with word boundaries.
		 We do this iteratively because:
		 (a) the line may contain more than one occurence of the
		 pattern, and
		 (b) Several alternatives in the pattern might be valid at a
		 given point, and we may need to consider a shorter one to
		 find a word boundary.  */
	      if (match_words)
		while (match <= best_match)
		  {
		    if ((match == buf || !WCHAR ((unsigned char) match[-1]))
			&& (len == end - beg - 1
			    || !WCHAR ((unsigned char) match[len])))
		      goto assess_pattern_match;
		    if (len > 0)
		      {
			/* Try a shorter length anchored at the same place. */
			--len;
			patterns[i].regexbuf.not_eol = 1;
			len = re_match (&(patterns[i].regexbuf),
					buf, match + len - beg, match - buf,
					&(patterns[i].regs));
		      }
		    if (len <= 0)
		      {
			/* Try looking further on. */
			if (match == end - 1)
			  break;
			match++;
			patterns[i].regexbuf.not_eol = 0;
			start = re_search (&(patterns[i].regexbuf),
					   buf, end - buf - 1,
					   match - buf, end - match - 1,
					   &(patterns[i].regs));
			if (start < 0)
			  break;
			len = patterns[i].regs.end[0] - start;
			match = buf + start;
		      }
		  } /* while (match <= best_match) */
	      continue;
	    assess_pattern_match:
	      if (!start_ptr)
		{
		  /* Good enough for a non-exact match.
		     No need to look at further patterns, if any.  */
		  beg = match;
		  goto success_in_len;
		}
	      if (match < best_match || (match == best_match && len > best_len))
		{
		  /* Best exact match:  leftmost, then longest.  */
		  best_match = match;
		  best_len = len;
		}
	    } /* if re_search >= 0 */
	} /* for Regex patterns.  */
	if (best_match < end)
	  {
	    /* We have found an exact match.  We were just
	       waiting for the best one (leftmost then longest).  */
	    beg = best_match;
	    len = best_len;
	    goto success_in_len;
	  }
    } /* for (beg = end ..) */

 failure:
  ret_val = -1;
  goto out;

 success:
  len = end - beg;
 success_in_len:
  *match_size = len;
  ret_val = beg - buf;
 out:
  return ret_val;
}

Testing negative cases!
Testing 0 (with abstract condition) ENVIS_NEG
Iteration 0
Running test command:
/home/ubuntu/spr-fast/tools/grep-test.py /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-8a025cf8-8f08d8e2/tempworkdir-l/src /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-8a025cf8-8f08d8e2/tempworkdir-l/tests /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-8a025cf8-8f08d8e2/tempworkdir-l 0  > __res
Opening:/tmp/neg.tmp!
NegativeBRANCH RECORD/tmp/neg.tmp!
Not caught by the negative case, give up!
APPENDING TO ISNEG:/tmp/neg.tmp!
Running test command:
/home/ubuntu/spr-fast/tools/grep-test.py /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-8a025cf8-8f08d8e2/tempworkdir-l/src /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-8a025cf8-8f08d8e2/tempworkdir-l/tests /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-8a025cf8-8f08d8e2/tempworkdir-l 0  > __res
a batched test job starts!
Building merged code:
src_file: src/dfasearch.c
full src: int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); void* memset(void*, int, unsigned long); 
/* dfasearch.c - searching subroutines using dfa and regex for grep.
   Copyright 1992, 1998, 2000, 2007, 2009-2010 Free Software Foundation, Inc.

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 3, or (at your option)
   any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program; if not, write to the Free Software
   Foundation, Inc., 51 Franklin Street - Fifth Floor, Boston, MA
   02110-1301, USA.  */

/* Written August 1992 by Mike Haertel. */

#include <config.h>
#include "search.h"
#include "dfa.h"

/* For -w, we also consider _ to be word constituent.  */
#define WCHAR(C) (ISALNUM(C) || (C) == '_')

/* KWset compiled pattern.  For Ecompile and Gcompile, we compile
   a list of strings, at least one of which is known to occur in
   any string matching the regexp. */
static kwset_t kwset;

/* DFA compiled regexp. */
static struct dfa dfa;

/* The Regex compiled patterns.  */
static struct patterns
{
  /* Regex compiled regexp. */
  struct re_pattern_buffer regexbuf;
  struct re_registers regs; /* This is here on account of a BRAIN-DEAD
			       Q@#%!# library interface in regex.c.  */
} patterns0;

struct patterns *patterns;
size_t pcount;

void
dfaerror (char const *mesg)
{
  error (EXIT_TROUBLE, 0, "%s", mesg);

  /* notreached */
  /* Tell static analyzers that this function does not return.  */
  abort ();
}

/* Number of compiled fixed strings known to exactly match the regexp.
   If kwsexec returns < kwset_exact_matches, then we don't need to
   call the regexp matcher at all. */
static int kwset_exact_matches;

static char const *
kwsincr_case (const char *must)
{
  const char *buf;
  size_t n;

  n = strlen (must);
#ifdef MBS_SUPPORT
  if (match_icase && MB_CUR_MAX > 1)
    buf = mbtolower (must, &n);
  else
#endif
    buf = must;
  return kwsincr (kwset, buf, n);
}

/* If the DFA turns out to have some set of fixed strings one of
   which must occur in the match, then we build a kwset matcher
   to find those strings, and thus quickly filter out impossible
   matches. */
static void
kwsmusts (void)
{
  struct dfamust const *dm;
  char const *err;

  if (dfa.musts)
    {
      kwsinit (&kwset);
      /* First, we compile in the substrings known to be exact
	 matches.  The kwset matcher will return the index
	 of the matching string that it chooses. */
      for (dm = dfa.musts; dm; dm = dm->next)
	{
	  if (!dm->exact)
	    continue;
	  ++kwset_exact_matches;
	  if ((err = kwsincr_case (dm->must)) != NULL)
	    error (EXIT_TROUBLE, 0, "%s", err);
	}
      /* Now, we compile the substrings that will require
	 the use of the regexp matcher.  */
      for (dm = dfa.musts; dm; dm = dm->next)
	{
	  if (dm->exact)
	    continue;
	  if ((err = kwsincr_case (dm->must)) != NULL)
	    error (EXIT_TROUBLE, 0, "%s", err);
	}
      if ((err = kwsprep (kwset)) != NULL)
	error (EXIT_TROUBLE, 0, "%s", err);
    }
}

void
GEAcompile (char const *pattern, size_t size, reg_syntax_t syntax_bits)
{
  const char *err;
  const char *p, *sep;
  size_t total = size;
  char *motif;

  if (match_icase)
    syntax_bits |= RE_ICASE;
  re_set_syntax (syntax_bits);
  dfasyntax (syntax_bits, match_icase, eolbyte);

  /* For GNU regex compiler we have to pass the patterns separately to detect
     errors like "[\nallo\n]\n".  The patterns here are "[", "allo" and "]"
     GNU regex should have raise a syntax error.  The same for backref, where
     the backref should have been local to each pattern.  */
  p = pattern;
  do
    {
      size_t len;
      sep = memchr (p, '\n', total);
      if (sep)
	{
	  len = sep - p;
	  sep++;
	  total -= (len + 1);
	}
      else
	{
	  len = total;
	  total = 0;
	}

      patterns = realloc (patterns, (pcount + 1) * sizeof (*patterns));
      if (patterns == NULL)
	error (EXIT_TROUBLE, errno, _("memory exhausted"));
      patterns[pcount] = patterns0;

      if ((err = re_compile_pattern (p, len,
				    &(patterns[pcount].regexbuf))) != NULL)
	error (EXIT_TROUBLE, 0, "%s", err);
      pcount++;

      p = sep;
    } while (sep && total != 0);

  /* In the match_words and match_lines cases, we use a different pattern
     for the DFA matcher that will quickly throw out cases that won't work.
     Then if DFA succeeds we do some hairy stuff using the regex matcher
     to decide whether the match should really count. */
  if (match_words || match_lines)
    {
      static char const line_beg_no_bk[] = "^(";
      static char const line_end_no_bk[] = ")$";
      static char const word_beg_no_bk[] = "(^|[^[:alnum:]_])(";
      static char const word_end_no_bk[] = ")([^[:alnum:]_]|$)";
      static char const line_beg_bk[] = "^\\(";
      static char const line_end_bk[] = "\\)$";
      static char const word_beg_bk[] = "\\(^\\|[^[:alnum:]_]\\)\\(";
      static char const word_end_bk[] = "\\)\\([^[:alnum:]_]\\|$\\)";
      int bk = !(syntax_bits & RE_NO_BK_PARENS);
      char *n = xmalloc (sizeof word_beg_bk - 1 + size + sizeof word_end_bk);

      strcpy (n, match_lines ? (bk ? line_beg_bk : line_beg_no_bk)
			     : (bk ? word_beg_bk : word_beg_no_bk));
      total = strlen(n);
      memcpy (n + total, pattern, size);
      total += size;
      strcpy (n + total, match_lines ? (bk ? line_end_bk : line_end_no_bk)
				     : (bk ? word_end_bk : word_end_no_bk));
      total += strlen (n + total);
      pattern = motif = n;
      size = total;
    }
  else
    motif = NULL;

  dfacomp (pattern, size, &dfa, 1);
  kwsmusts ();

  free(motif);
}

size_t
EGexecute (char const *buf, size_t size, size_t *match_size,
	   char const *start_ptr)
{
  char const *buflim, *beg, *end, *match, *best_match, *mb_start;
  char eol = eolbyte;
  int backref, start, len, best_len;
  struct kwsmatch kwsm;
  size_t i, ret_val;
#ifdef MBS_SUPPORT
  if (MB_CUR_MAX > 1)
    {
      if (match_icase)
        {
          /* mbtolower adds a NUL byte at the end.  That will provide
	     space for the sentinel byte dfaexec may add.  */
          char *case_buf = mbtolower (buf, &size);
	  if (start_ptr)
	    start_ptr = case_buf + (start_ptr - buf);
          buf = case_buf;
        }
    }
#endif /* MBS_SUPPORT */

  mb_start = buf;
  buflim = buf + size;

  for (beg = end = buf; end < buflim; beg = end)
    {
      if (!start_ptr)
	{
	  /* We don't care about an exact match.  */
	  if (kwset)
	    {
	      /* Find a possible match using the KWset matcher. */
	      size_t offset = kwsexec (kwset, beg, buflim - beg, &kwsm);
	      //prophet generated patch
	      if (__get_mutant()==0) {
	      if ((offset == (size_t)-1) && !(__is_neg(27, &(offset), sizeof (offset), &(buflim), sizeof (buflim), &(beg), sizeof (beg), &(kwset), sizeof (kwset), &(end), sizeof (end), &(eol), sizeof (eol), &(start_ptr), sizeof (start_ptr), &(buf), sizeof (buf), &(match), sizeof (match), &(size), sizeof (size), &(mb_start), sizeof (mb_start), &(kwset_exact_matches), sizeof (kwset_exact_matches), &(kwsm.index), sizeof (kwsm.index), &(backref), sizeof (backref), &(match_icase), sizeof (match_icase), &(eolbyte), sizeof (eolbyte), &(best_match), sizeof (best_match), &(best_len), sizeof (best_len), &(i), sizeof (i), &(pcount), sizeof (pcount), &(patterns), sizeof (patterns), &(start), sizeof (start), &(len), sizeof (len), &(match_words), sizeof (match_words), &(match_lines), sizeof (match_lines), &(ret_val), sizeof (ret_val), &(match_size), sizeof (match_size))))
	          goto failure;
	      }
	      else if (__get_mutant()==1) {
	      if ((offset == (size_t)-1) || (__is_neg(27, &(offset), sizeof (offset), &(buflim), sizeof (buflim), &(beg), sizeof (beg), &(kwset), sizeof (kwset), &(end), sizeof (end), &(eol), sizeof (eol), &(start_ptr), sizeof (start_ptr), &(buf), sizeof (buf), &(match), sizeof (match), &(size), sizeof (size), &(mb_start), sizeof (mb_start), &(kwset_exact_matches), sizeof (kwset_exact_matches), &(kwsm.index), sizeof (kwsm.index), &(backref), sizeof (backref), &(match_icase), sizeof (match_icase), &(eolbyte), sizeof (eolbyte), &(best_match), sizeof (best_match), &(best_len), sizeof (best_len), &(i), sizeof (i), &(pcount), sizeof (pcount), &(patterns), sizeof (patterns), &(start), sizeof (start), &(len), sizeof (len), &(match_words), sizeof (match_words), &(match_lines), sizeof (match_lines), &(ret_val), sizeof (ret_val), &(match_size), sizeof (match_size))))
	          goto failure;
	      }
	      beg += offset;
	      /* Narrow down to the line containing the candidate, and
		 run it through DFA. */
	      if ((end = memchr(beg, eol, buflim - beg)) != NULL)
	        end++;
              else
                end = buflim;
	      match = beg;
	      while (beg > buf && beg[-1] != eol)
		--beg;
	      if (kwsm.index < kwset_exact_matches)
                {
#ifdef MBS_SUPPORT
                  if (mb_start < beg)
                    mb_start = beg;
                  if (MB_CUR_MAX == 1 || !is_mb_middle (&mb_start, match, buflim))
#endif
                    goto success;
                }
	      if (dfaexec (&dfa, beg, (char *) end, 0, NULL, &backref) == NULL)
		continue;
	    }
	  else
	    {
	      /* No good fixed strings; start with DFA. */
	      char const *next_beg = dfaexec (&dfa, beg, (char *) buflim,
					      0, NULL, &backref);
	      if (next_beg == NULL)
		break;
	      /* Narrow down to the line we've found. */
	      beg = next_beg;
	      if ((end = memchr(beg, eol, buflim - beg)) != NULL)
	        end++;
              else
                end = buflim;
	      while (beg > buf && beg[-1] != eol)
		--beg;
	    }
	  /* Successful, no backreferences encountered! */
	  if (!backref)
	    goto success;
	}
      else
	{
	  /* We are looking for the leftmost (then longest) exact match.
	     We will go through the outer loop only once.  */
	  beg = start_ptr;
	  end = buflim;
	}

      /* If we've made it to this point, this means DFA has seen
	 a probable match, and we need to run it through Regex. */
      best_match = end;
      best_len = 0;
      for (i = 0; i < pcount; i++)
	{
	  patterns[i].regexbuf.not_eol = 0;
	  if (0 <= (start = re_search (&(patterns[i].regexbuf),
				       buf, end - buf - 1,
				       beg - buf, end - beg - 1,
				       &(patterns[i].regs))))
	    {
	      len = patterns[i].regs.end[0] - start;
	      match = buf + start;
	      if (match > best_match)
		continue;
	      if (start_ptr && !match_words)
		goto assess_pattern_match;
	      if ((!match_lines && !match_words)
		  || (match_lines && len == end - beg - 1))
		{
		  match = beg;
		  len = end - beg;
		  goto assess_pattern_match;
		}
	      /* If -w, check if the match aligns with word boundaries.
		 We do this iteratively because:
		 (a) the line may contain more than one occurence of the
		 pattern, and
		 (b) Several alternatives in the pattern might be valid at a
		 given point, and we may need to consider a shorter one to
		 find a word boundary.  */
	      if (match_words)
		while (match <= best_match)
		  {
		    if ((match == buf || !WCHAR ((unsigned char) match[-1]))
			&& (len == end - beg - 1
			    || !WCHAR ((unsigned char) match[len])))
		      goto assess_pattern_match;
		    if (len > 0)
		      {
			/* Try a shorter length anchored at the same place. */
			--len;
			patterns[i].regexbuf.not_eol = 1;
			len = re_match (&(patterns[i].regexbuf),
					buf, match + len - beg, match - buf,
					&(patterns[i].regs));
		      }
		    if (len <= 0)
		      {
			/* Try looking further on. */
			if (match == end - 1)
			  break;
			match++;
			patterns[i].regexbuf.not_eol = 0;
			start = re_search (&(patterns[i].regexbuf),
					   buf, end - buf - 1,
					   match - buf, end - match - 1,
					   &(patterns[i].regs));
			if (start < 0)
			  break;
			len = patterns[i].regs.end[0] - start;
			match = buf + start;
		      }
		  } /* while (match <= best_match) */
	      continue;
	    assess_pattern_match:
	      if (!start_ptr)
		{
		  /* Good enough for a non-exact match.
		     No need to look at further patterns, if any.  */
		  beg = match;
		  goto success_in_len;
		}
	      if (match < best_match || (match == best_match && len > best_len))
		{
		  /* Best exact match:  leftmost, then longest.  */
		  best_match = match;
		  best_len = len;
		}
	    } /* if re_search >= 0 */
	} /* for Regex patterns.  */
	if (best_match < end)
	  {
	    /* We have found an exact match.  We were just
	       waiting for the best one (leftmost then longest).  */
	    beg = best_match;
	    len = best_len;
	    goto success_in_len;
	  }
    } /* for (beg = end ..) */

 failure:
  ret_val = -1;
  goto out;

 success:
  len = end - beg;
 success_in_len:
  *match_size = len;
  ret_val = beg - buf;
 out:
  return ret_val;
}

Building:src at:
/home/ubuntu/spr-fast/tests/corebench/grep/grep-case-8a025cf8-8f08d8e2/tempworkdir-l/srcMerged code building succ, going to invoke tester!
CondTester, Testing instance id 5:
//src_file:src/dfasearch.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); void* memset(void*, int, unsigned long); 
/* dfasearch.c - searching subroutines using dfa and regex for grep.
   Copyright 1992, 1998, 2000, 2007, 2009-2010 Free Software Foundation, Inc.

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 3, or (at your option)
   any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program; if not, write to the Free Software
   Foundation, Inc., 51 Franklin Street - Fifth Floor, Boston, MA
   02110-1301, USA.  */

/* Written August 1992 by Mike Haertel. */

#include <config.h>
#include "search.h"
#include "dfa.h"

/* For -w, we also consider _ to be word constituent.  */
#define WCHAR(C) (ISALNUM(C) || (C) == '_')

/* KWset compiled pattern.  For Ecompile and Gcompile, we compile
   a list of strings, at least one of which is known to occur in
   any string matching the regexp. */
static kwset_t kwset;

/* DFA compiled regexp. */
static struct dfa dfa;

/* The Regex compiled patterns.  */
static struct patterns
{
  /* Regex compiled regexp. */
  struct re_pattern_buffer regexbuf;
  struct re_registers regs; /* This is here on account of a BRAIN-DEAD
			       Q@#%!# library interface in regex.c.  */
} patterns0;

struct patterns *patterns;
size_t pcount;

void
dfaerror (char const *mesg)
{
  error (EXIT_TROUBLE, 0, "%s", mesg);

  /* notreached */
  /* Tell static analyzers that this function does not return.  */
  abort ();
}

/* Number of compiled fixed strings known to exactly match the regexp.
   If kwsexec returns < kwset_exact_matches, then we don't need to
   call the regexp matcher at all. */
static int kwset_exact_matches;

static char const *
kwsincr_case (const char *must)
{
  const char *buf;
  size_t n;

  n = strlen (must);
#ifdef MBS_SUPPORT
  if (match_icase && MB_CUR_MAX > 1)
    buf = mbtolower (must, &n);
  else
#endif
    buf = must;
  return kwsincr (kwset, buf, n);
}

/* If the DFA turns out to have some set of fixed strings one of
   which must occur in the match, then we build a kwset matcher
   to find those strings, and thus quickly filter out impossible
   matches. */
static void
kwsmusts (void)
{
  struct dfamust const *dm;
  char const *err;

  if (dfa.musts)
    {
      kwsinit (&kwset);
      /* First, we compile in the substrings known to be exact
	 matches.  The kwset matcher will return the index
	 of the matching string that it chooses. */
      for (dm = dfa.musts; dm; dm = dm->next)
	{
	  if (!dm->exact)
	    continue;
	  ++kwset_exact_matches;
	  if ((err = kwsincr_case (dm->must)) != NULL)
	    error (EXIT_TROUBLE, 0, "%s", err);
	}
      /* Now, we compile the substrings that will require
	 the use of the regexp matcher.  */
      for (dm = dfa.musts; dm; dm = dm->next)
	{
	  if (dm->exact)
	    continue;
	  if ((err = kwsincr_case (dm->must)) != NULL)
	    error (EXIT_TROUBLE, 0, "%s", err);
	}
      if ((err = kwsprep (kwset)) != NULL)
	error (EXIT_TROUBLE, 0, "%s", err);
    }
}

void
GEAcompile (char const *pattern, size_t size, reg_syntax_t syntax_bits)
{
  const char *err;
  const char *p, *sep;
  size_t total = size;
  char *motif;

  if (match_icase)
    syntax_bits |= RE_ICASE;
  re_set_syntax (syntax_bits);
  dfasyntax (syntax_bits, match_icase, eolbyte);

  /* For GNU regex compiler we have to pass the patterns separately to detect
     errors like "[\nallo\n]\n".  The patterns here are "[", "allo" and "]"
     GNU regex should have raise a syntax error.  The same for backref, where
     the backref should have been local to each pattern.  */
  p = pattern;
  do
    {
      size_t len;
      sep = memchr (p, '\n', total);
      if (sep)
	{
	  len = sep - p;
	  sep++;
	  total -= (len + 1);
	}
      else
	{
	  len = total;
	  total = 0;
	}

      patterns = realloc (patterns, (pcount + 1) * sizeof (*patterns));
      if (patterns == NULL)
	error (EXIT_TROUBLE, errno, _("memory exhausted"));
      patterns[pcount] = patterns0;

      if ((err = re_compile_pattern (p, len,
				    &(patterns[pcount].regexbuf))) != NULL)
	error (EXIT_TROUBLE, 0, "%s", err);
      pcount++;

      p = sep;
    } while (sep && total != 0);

  /* In the match_words and match_lines cases, we use a different pattern
     for the DFA matcher that will quickly throw out cases that won't work.
     Then if DFA succeeds we do some hairy stuff using the regex matcher
     to decide whether the match should really count. */
  if (match_words || match_lines)
    {
      static char const line_beg_no_bk[] = "^(";
      static char const line_end_no_bk[] = ")$";
      static char const word_beg_no_bk[] = "(^|[^[:alnum:]_])(";
      static char const word_end_no_bk[] = ")([^[:alnum:]_]|$)";
      static char const line_beg_bk[] = "^\\(";
      static char const line_end_bk[] = "\\)$";
      static char const word_beg_bk[] = "\\(^\\|[^[:alnum:]_]\\)\\(";
      static char const word_end_bk[] = "\\)\\([^[:alnum:]_]\\|$\\)";
      int bk = !(syntax_bits & RE_NO_BK_PARENS);
      char *n = xmalloc (sizeof word_beg_bk - 1 + size + sizeof word_end_bk);

      strcpy (n, match_lines ? (bk ? line_beg_bk : line_beg_no_bk)
			     : (bk ? word_beg_bk : word_beg_no_bk));
      total = strlen(n);
      memcpy (n + total, pattern, size);
      total += size;
      strcpy (n + total, match_lines ? (bk ? line_end_bk : line_end_no_bk)
				     : (bk ? word_end_bk : word_end_no_bk));
      total += strlen (n + total);
      pattern = motif = n;
      size = total;
    }
  else
    motif = NULL;

  dfacomp (pattern, size, &dfa, 1);
  kwsmusts ();

  free(motif);
}

size_t
EGexecute (char const *buf, size_t size, size_t *match_size,
	   char const *start_ptr)
{
  char const *buflim, *beg, *end, *match, *best_match, *mb_start;
  char eol = eolbyte;
  int backref, start, len, best_len;
  struct kwsmatch kwsm;
  size_t i, ret_val;
#ifdef MBS_SUPPORT
  if (MB_CUR_MAX > 1)
    {
      if (match_icase)
        {
          /* mbtolower adds a NUL byte at the end.  That will provide
	     space for the sentinel byte dfaexec may add.  */
          char *case_buf = mbtolower (buf, &size);
	  if (start_ptr)
	    start_ptr = case_buf + (start_ptr - buf);
          buf = case_buf;
        }
    }
#endif /* MBS_SUPPORT */

  mb_start = buf;
  buflim = buf + size;

  for (beg = end = buf; end < buflim; beg = end)
    {
      if (!start_ptr)
	{
	  /* We don't care about an exact match.  */
	  if (kwset)
	    {
	      /* Find a possible match using the KWset matcher. */
	      size_t offset = kwsexec (kwset, beg, buflim - beg, &kwsm);
	      
//Patch 0:
if ((offset == (size_t)-1) && !(__is_neg(27, &(offset), sizeof (offset), &(buflim), sizeof (buflim), &(beg), sizeof (beg), &(kwset), sizeof (kwset), &(end), sizeof (end), &(eol), sizeof (eol), &(start_ptr), sizeof (start_ptr), &(buf), sizeof (buf), &(match), sizeof (match), &(size), sizeof (size), &(mb_start), sizeof (mb_start), &(kwset_exact_matches), sizeof (kwset_exact_matches), &(kwsm.index), sizeof (kwsm.index), &(backref), sizeof (backref), &(match_icase), sizeof (match_icase), &(eolbyte), sizeof (eolbyte), &(best_match), sizeof (best_match), &(best_len), sizeof (best_len), &(i), sizeof (i), &(pcount), sizeof (pcount), &(patterns), sizeof (patterns), &(start), sizeof (start), &(len), sizeof (len), &(match_words), sizeof (match_words), &(match_lines), sizeof (match_lines), &(ret_val), sizeof (ret_val), &(match_size), sizeof (match_size))))
    goto failure;

//CodeSeg 1:
	      beg += offset;
	      /* Narrow down to the line containing the candidate, and
		 run it through DFA. */
	      if ((end = memchr(beg, eol, buflim - beg)) != NULL)
	        end++;
              else
                end = buflim;
	      match = beg;
	      while (beg > buf && beg[-1] != eol)
		--beg;
	      if (kwsm.index < kwset_exact_matches)
                {
#ifdef MBS_SUPPORT
                  if (mb_start < beg)
                    mb_start = beg;
                  if (MB_CUR_MAX == 1 || !is_mb_middle (&mb_start, match, buflim))
#endif
                    goto success;
                }
	      if (dfaexec (&dfa, beg, (char *) end, 0, NULL, &backref) == NULL)
		continue;
	    }
	  else
	    {
	      /* No good fixed strings; start with DFA. */
	      char const *next_beg = dfaexec (&dfa, beg, (char *) buflim,
					      0, NULL, &backref);
	      if (next_beg == NULL)
		break;
	      /* Narrow down to the line we've found. */
	      beg = next_beg;
	      if ((end = memchr(beg, eol, buflim - beg)) != NULL)
	        end++;
              else
                end = buflim;
	      while (beg > buf && beg[-1] != eol)
		--beg;
	    }
	  /* Successful, no backreferences encountered! */
	  if (!backref)
	    goto success;
	}
      else
	{
	  /* We are looking for the leftmost (then longest) exact match.
	     We will go through the outer loop only once.  */
	  beg = start_ptr;
	  end = buflim;
	}

      /* If we've made it to this point, this means DFA has seen
	 a probable match, and we need to run it through Regex. */
      best_match = end;
      best_len = 0;
      for (i = 0; i < pcount; i++)
	{
	  patterns[i].regexbuf.not_eol = 0;
	  if (0 <= (start = re_search (&(patterns[i].regexbuf),
				       buf, end - buf - 1,
				       beg - buf, end - beg - 1,
				       &(patterns[i].regs))))
	    {
	      len = patterns[i].regs.end[0] - start;
	      match = buf + start;
	      if (match > best_match)
		continue;
	      if (start_ptr && !match_words)
		goto assess_pattern_match;
	      if ((!match_lines && !match_words)
		  || (match_lines && len == end - beg - 1))
		{
		  match = beg;
		  len = end - beg;
		  goto assess_pattern_match;
		}
	      /* If -w, check if the match aligns with word boundaries.
		 We do this iteratively because:
		 (a) the line may contain more than one occurence of the
		 pattern, and
		 (b) Several alternatives in the pattern might be valid at a
		 given point, and we may need to consider a shorter one to
		 find a word boundary.  */
	      if (match_words)
		while (match <= best_match)
		  {
		    if ((match == buf || !WCHAR ((unsigned char) match[-1]))
			&& (len == end - beg - 1
			    || !WCHAR ((unsigned char) match[len])))
		      goto assess_pattern_match;
		    if (len > 0)
		      {
			/* Try a shorter length anchored at the same place. */
			--len;
			patterns[i].regexbuf.not_eol = 1;
			len = re_match (&(patterns[i].regexbuf),
					buf, match + len - beg, match - buf,
					&(patterns[i].regs));
		      }
		    if (len <= 0)
		      {
			/* Try looking further on. */
			if (match == end - 1)
			  break;
			match++;
			patterns[i].regexbuf.not_eol = 0;
			start = re_search (&(patterns[i].regexbuf),
					   buf, end - buf - 1,
					   match - buf, end - match - 1,
					   &(patterns[i].regs));
			if (start < 0)
			  break;
			len = patterns[i].regs.end[0] - start;
			match = buf + start;
		      }
		  } /* while (match <= best_match) */
	      continue;
	    assess_pattern_match:
	      if (!start_ptr)
		{
		  /* Good enough for a non-exact match.
		     No need to look at further patterns, if any.  */
		  beg = match;
		  goto success_in_len;
		}
	      if (match < best_match || (match == best_match && len > best_len))
		{
		  /* Best exact match:  leftmost, then longest.  */
		  best_match = match;
		  best_len = len;
		}
	    } /* if re_search >= 0 */
	} /* for Regex patterns.  */
	if (best_match < end)
	  {
	    /* We have found an exact match.  We were just
	       waiting for the best one (leftmost then longest).  */
	    beg = best_match;
	    len = best_len;
	    goto success_in_len;
	  }
    } /* for (beg = end ..) */

 failure:
  ret_val = -1;
  goto out;

 success:
  len = end - beg;
 success_in_len:
  *match_size = len;
  ret_val = beg - buf;
 out:
  return ret_val;
}

Testing negative cases!
Testing 0 (with abstract condition) ENVIS_NEG
Iteration 0
Running test command:
/home/ubuntu/spr-fast/tools/grep-test.py /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-8a025cf8-8f08d8e2/tempworkdir-l/src /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-8a025cf8-8f08d8e2/tempworkdir-l/tests /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-8a025cf8-8f08d8e2/tempworkdir-l 0  > __res
Opening:/tmp/neg.tmp!
NegativeBRANCH RECORD/tmp/neg.tmp!
APPENDING TO ISNEG:/tmp/neg.tmp!
Branch 0: 0
Iteration 1
Running test command:
/home/ubuntu/spr-fast/tools/grep-test.py /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-8a025cf8-8f08d8e2/tempworkdir-l/src /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-8a025cf8-8f08d8e2/tempworkdir-l/tests /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-8a025cf8-8f08d8e2/tempworkdir-l 0  > __res
Opening:/tmp/neg.tmp!
NegativeBRANCH RECORD/tmp/neg.tmp!
APPENDING TO ISNEG:/tmp/neg.tmp!
Branch 0: 1
Running test command:
/home/ubuntu/spr-fast/tools/grep-test.py /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-8a025cf8-8f08d8e2/tempworkdir-l/src /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-8a025cf8-8f08d8e2/tempworkdir-l/tests /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-8a025cf8-8f08d8e2/tempworkdir-l 0  > __res
CondTester, Testing instance id 6:
//src_file:src/dfasearch.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); void* memset(void*, int, unsigned long); 
/* dfasearch.c - searching subroutines using dfa and regex for grep.
   Copyright 1992, 1998, 2000, 2007, 2009-2010 Free Software Foundation, Inc.

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 3, or (at your option)
   any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program; if not, write to the Free Software
   Foundation, Inc., 51 Franklin Street - Fifth Floor, Boston, MA
   02110-1301, USA.  */

/* Written August 1992 by Mike Haertel. */

#include <config.h>
#include "search.h"
#include "dfa.h"

/* For -w, we also consider _ to be word constituent.  */
#define WCHAR(C) (ISALNUM(C) || (C) == '_')

/* KWset compiled pattern.  For Ecompile and Gcompile, we compile
   a list of strings, at least one of which is known to occur in
   any string matching the regexp. */
static kwset_t kwset;

/* DFA compiled regexp. */
static struct dfa dfa;

/* The Regex compiled patterns.  */
static struct patterns
{
  /* Regex compiled regexp. */
  struct re_pattern_buffer regexbuf;
  struct re_registers regs; /* This is here on account of a BRAIN-DEAD
			       Q@#%!# library interface in regex.c.  */
} patterns0;

struct patterns *patterns;
size_t pcount;

void
dfaerror (char const *mesg)
{
  error (EXIT_TROUBLE, 0, "%s", mesg);

  /* notreached */
  /* Tell static analyzers that this function does not return.  */
  abort ();
}

/* Number of compiled fixed strings known to exactly match the regexp.
   If kwsexec returns < kwset_exact_matches, then we don't need to
   call the regexp matcher at all. */
static int kwset_exact_matches;

static char const *
kwsincr_case (const char *must)
{
  const char *buf;
  size_t n;

  n = strlen (must);
#ifdef MBS_SUPPORT
  if (match_icase && MB_CUR_MAX > 1)
    buf = mbtolower (must, &n);
  else
#endif
    buf = must;
  return kwsincr (kwset, buf, n);
}

/* If the DFA turns out to have some set of fixed strings one of
   which must occur in the match, then we build a kwset matcher
   to find those strings, and thus quickly filter out impossible
   matches. */
static void
kwsmusts (void)
{
  struct dfamust const *dm;
  char const *err;

  if (dfa.musts)
    {
      kwsinit (&kwset);
      /* First, we compile in the substrings known to be exact
	 matches.  The kwset matcher will return the index
	 of the matching string that it chooses. */
      for (dm = dfa.musts; dm; dm = dm->next)
	{
	  if (!dm->exact)
	    continue;
	  ++kwset_exact_matches;
	  if ((err = kwsincr_case (dm->must)) != NULL)
	    error (EXIT_TROUBLE, 0, "%s", err);
	}
      /* Now, we compile the substrings that will require
	 the use of the regexp matcher.  */
      for (dm = dfa.musts; dm; dm = dm->next)
	{
	  if (dm->exact)
	    continue;
	  if ((err = kwsincr_case (dm->must)) != NULL)
	    error (EXIT_TROUBLE, 0, "%s", err);
	}
      if ((err = kwsprep (kwset)) != NULL)
	error (EXIT_TROUBLE, 0, "%s", err);
    }
}

void
GEAcompile (char const *pattern, size_t size, reg_syntax_t syntax_bits)
{
  const char *err;
  const char *p, *sep;
  size_t total = size;
  char *motif;

  if (match_icase)
    syntax_bits |= RE_ICASE;
  re_set_syntax (syntax_bits);
  dfasyntax (syntax_bits, match_icase, eolbyte);

  /* For GNU regex compiler we have to pass the patterns separately to detect
     errors like "[\nallo\n]\n".  The patterns here are "[", "allo" and "]"
     GNU regex should have raise a syntax error.  The same for backref, where
     the backref should have been local to each pattern.  */
  p = pattern;
  do
    {
      size_t len;
      sep = memchr (p, '\n', total);
      if (sep)
	{
	  len = sep - p;
	  sep++;
	  total -= (len + 1);
	}
      else
	{
	  len = total;
	  total = 0;
	}

      patterns = realloc (patterns, (pcount + 1) * sizeof (*patterns));
      if (patterns == NULL)
	error (EXIT_TROUBLE, errno, _("memory exhausted"));
      patterns[pcount] = patterns0;

      if ((err = re_compile_pattern (p, len,
				    &(patterns[pcount].regexbuf))) != NULL)
	error (EXIT_TROUBLE, 0, "%s", err);
      pcount++;

      p = sep;
    } while (sep && total != 0);

  /* In the match_words and match_lines cases, we use a different pattern
     for the DFA matcher that will quickly throw out cases that won't work.
     Then if DFA succeeds we do some hairy stuff using the regex matcher
     to decide whether the match should really count. */
  if (match_words || match_lines)
    {
      static char const line_beg_no_bk[] = "^(";
      static char const line_end_no_bk[] = ")$";
      static char const word_beg_no_bk[] = "(^|[^[:alnum:]_])(";
      static char const word_end_no_bk[] = ")([^[:alnum:]_]|$)";
      static char const line_beg_bk[] = "^\\(";
      static char const line_end_bk[] = "\\)$";
      static char const word_beg_bk[] = "\\(^\\|[^[:alnum:]_]\\)\\(";
      static char const word_end_bk[] = "\\)\\([^[:alnum:]_]\\|$\\)";
      int bk = !(syntax_bits & RE_NO_BK_PARENS);
      char *n = xmalloc (sizeof word_beg_bk - 1 + size + sizeof word_end_bk);

      strcpy (n, match_lines ? (bk ? line_beg_bk : line_beg_no_bk)
			     : (bk ? word_beg_bk : word_beg_no_bk));
      total = strlen(n);
      memcpy (n + total, pattern, size);
      total += size;
      strcpy (n + total, match_lines ? (bk ? line_end_bk : line_end_no_bk)
				     : (bk ? word_end_bk : word_end_no_bk));
      total += strlen (n + total);
      pattern = motif = n;
      size = total;
    }
  else
    motif = NULL;

  dfacomp (pattern, size, &dfa, 1);
  kwsmusts ();

  free(motif);
}

size_t
EGexecute (char const *buf, size_t size, size_t *match_size,
	   char const *start_ptr)
{
  char const *buflim, *beg, *end, *match, *best_match, *mb_start;
  char eol = eolbyte;
  int backref, start, len, best_len;
  struct kwsmatch kwsm;
  size_t i, ret_val;
#ifdef MBS_SUPPORT
  if (MB_CUR_MAX > 1)
    {
      if (match_icase)
        {
          /* mbtolower adds a NUL byte at the end.  That will provide
	     space for the sentinel byte dfaexec may add.  */
          char *case_buf = mbtolower (buf, &size);
	  if (start_ptr)
	    start_ptr = case_buf + (start_ptr - buf);
          buf = case_buf;
        }
    }
#endif /* MBS_SUPPORT */

  mb_start = buf;
  buflim = buf + size;

  for (beg = end = buf; end < buflim; beg = end)
    {
      if (!start_ptr)
	{
	  /* We don't care about an exact match.  */
	  if (kwset)
	    {
	      /* Find a possible match using the KWset matcher. */
	      size_t offset = kwsexec (kwset, beg, buflim - beg, &kwsm);
	      
//Patch 0:
if ((offset == (size_t)-1) || (__is_neg(27, &(offset), sizeof (offset), &(buflim), sizeof (buflim), &(beg), sizeof (beg), &(kwset), sizeof (kwset), &(end), sizeof (end), &(eol), sizeof (eol), &(start_ptr), sizeof (start_ptr), &(buf), sizeof (buf), &(match), sizeof (match), &(size), sizeof (size), &(mb_start), sizeof (mb_start), &(kwset_exact_matches), sizeof (kwset_exact_matches), &(kwsm.index), sizeof (kwsm.index), &(backref), sizeof (backref), &(match_icase), sizeof (match_icase), &(eolbyte), sizeof (eolbyte), &(best_match), sizeof (best_match), &(best_len), sizeof (best_len), &(i), sizeof (i), &(pcount), sizeof (pcount), &(patterns), sizeof (patterns), &(start), sizeof (start), &(len), sizeof (len), &(match_words), sizeof (match_words), &(match_lines), sizeof (match_lines), &(ret_val), sizeof (ret_val), &(match_size), sizeof (match_size))))
    goto failure;

//CodeSeg 1:
	      beg += offset;
	      /* Narrow down to the line containing the candidate, and
		 run it through DFA. */
	      if ((end = memchr(beg, eol, buflim - beg)) != NULL)
	        end++;
              else
                end = buflim;
	      match = beg;
	      while (beg > buf && beg[-1] != eol)
		--beg;
	      if (kwsm.index < kwset_exact_matches)
                {
#ifdef MBS_SUPPORT
                  if (mb_start < beg)
                    mb_start = beg;
                  if (MB_CUR_MAX == 1 || !is_mb_middle (&mb_start, match, buflim))
#endif
                    goto success;
                }
	      if (dfaexec (&dfa, beg, (char *) end, 0, NULL, &backref) == NULL)
		continue;
	    }
	  else
	    {
	      /* No good fixed strings; start with DFA. */
	      char const *next_beg = dfaexec (&dfa, beg, (char *) buflim,
					      0, NULL, &backref);
	      if (next_beg == NULL)
		break;
	      /* Narrow down to the line we've found. */
	      beg = next_beg;
	      if ((end = memchr(beg, eol, buflim - beg)) != NULL)
	        end++;
              else
                end = buflim;
	      while (beg > buf && beg[-1] != eol)
		--beg;
	    }
	  /* Successful, no backreferences encountered! */
	  if (!backref)
	    goto success;
	}
      else
	{
	  /* We are looking for the leftmost (then longest) exact match.
	     We will go through the outer loop only once.  */
	  beg = start_ptr;
	  end = buflim;
	}

      /* If we've made it to this point, this means DFA has seen
	 a probable match, and we need to run it through Regex. */
      best_match = end;
      best_len = 0;
      for (i = 0; i < pcount; i++)
	{
	  patterns[i].regexbuf.not_eol = 0;
	  if (0 <= (start = re_search (&(patterns[i].regexbuf),
				       buf, end - buf - 1,
				       beg - buf, end - beg - 1,
				       &(patterns[i].regs))))
	    {
	      len = patterns[i].regs.end[0] - start;
	      match = buf + start;
	      if (match > best_match)
		continue;
	      if (start_ptr && !match_words)
		goto assess_pattern_match;
	      if ((!match_lines && !match_words)
		  || (match_lines && len == end - beg - 1))
		{
		  match = beg;
		  len = end - beg;
		  goto assess_pattern_match;
		}
	      /* If -w, check if the match aligns with word boundaries.
		 We do this iteratively because:
		 (a) the line may contain more than one occurence of the
		 pattern, and
		 (b) Several alternatives in the pattern might be valid at a
		 given point, and we may need to consider a shorter one to
		 find a word boundary.  */
	      if (match_words)
		while (match <= best_match)
		  {
		    if ((match == buf || !WCHAR ((unsigned char) match[-1]))
			&& (len == end - beg - 1
			    || !WCHAR ((unsigned char) match[len])))
		      goto assess_pattern_match;
		    if (len > 0)
		      {
			/* Try a shorter length anchored at the same place. */
			--len;
			patterns[i].regexbuf.not_eol = 1;
			len = re_match (&(patterns[i].regexbuf),
					buf, match + len - beg, match - buf,
					&(patterns[i].regs));
		      }
		    if (len <= 0)
		      {
			/* Try looking further on. */
			if (match == end - 1)
			  break;
			match++;
			patterns[i].regexbuf.not_eol = 0;
			start = re_search (&(patterns[i].regexbuf),
					   buf, end - buf - 1,
					   match - buf, end - match - 1,
					   &(patterns[i].regs));
			if (start < 0)
			  break;
			len = patterns[i].regs.end[0] - start;
			match = buf + start;
		      }
		  } /* while (match <= best_match) */
	      continue;
	    assess_pattern_match:
	      if (!start_ptr)
		{
		  /* Good enough for a non-exact match.
		     No need to look at further patterns, if any.  */
		  beg = match;
		  goto success_in_len;
		}
	      if (match < best_match || (match == best_match && len > best_len))
		{
		  /* Best exact match:  leftmost, then longest.  */
		  best_match = match;
		  best_len = len;
		}
	    } /* if re_search >= 0 */
	} /* for Regex patterns.  */
	if (best_match < end)
	  {
	    /* We have found an exact match.  We were just
	       waiting for the best one (leftmost then longest).  */
	    beg = best_match;
	    len = best_len;
	    goto success_in_len;
	  }
    } /* for (beg = end ..) */

 failure:
  ret_val = -1;
  goto out;

 success:
  len = end - beg;
 success_in_len:
  *match_size = len;
  ret_val = beg - buf;
 out:
  return ret_val;
}

Testing negative cases!
Testing 0 (with abstract condition) ENVIS_NEG
Iteration 0
Running test command:
/home/ubuntu/spr-fast/tools/grep-test.py /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-8a025cf8-8f08d8e2/tempworkdir-l/src /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-8a025cf8-8f08d8e2/tempworkdir-l/tests /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-8a025cf8-8f08d8e2/tempworkdir-l 0  > __res
Opening:/tmp/neg.tmp!
NegativeBRANCH RECORD/tmp/neg.tmp!
APPENDING TO ISNEG:/tmp/neg.tmp!
Branch 0: 0
Iteration 1
Running test command:
/home/ubuntu/spr-fast/tools/grep-test.py /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-8a025cf8-8f08d8e2/tempworkdir-l/src /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-8a025cf8-8f08d8e2/tempworkdir-l/tests /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-8a025cf8-8f08d8e2/tempworkdir-l 0  > __res
Opening:/tmp/neg.tmp!
NegativeBRANCH RECORD/tmp/neg.tmp!
APPENDING TO ISNEG:/tmp/neg.tmp!
Branch 0: 1
Running test command:
/home/ubuntu/spr-fast/tools/grep-test.py /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-8a025cf8-8f08d8e2/tempworkdir-l/src /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-8a025cf8-8f08d8e2/tempworkdir-l/tests /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-8a025cf8-8f08d8e2/tempworkdir-l 0  > __res
a batched test job starts!
Building merged code:
src_file: src/dfasearch.c
full src: int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); void* memset(void*, int, unsigned long); 
/* dfasearch.c - searching subroutines using dfa and regex for grep.
   Copyright 1992, 1998, 2000, 2007, 2009-2010 Free Software Foundation, Inc.

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 3, or (at your option)
   any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program; if not, write to the Free Software
   Foundation, Inc., 51 Franklin Street - Fifth Floor, Boston, MA
   02110-1301, USA.  */

/* Written August 1992 by Mike Haertel. */

#include <config.h>
#include "search.h"
#include "dfa.h"

/* For -w, we also consider _ to be word constituent.  */
#define WCHAR(C) (ISALNUM(C) || (C) == '_')

/* KWset compiled pattern.  For Ecompile and Gcompile, we compile
   a list of strings, at least one of which is known to occur in
   any string matching the regexp. */
static kwset_t kwset;

/* DFA compiled regexp. */
static struct dfa dfa;

/* The Regex compiled patterns.  */
static struct patterns
{
  /* Regex compiled regexp. */
  struct re_pattern_buffer regexbuf;
  struct re_registers regs; /* This is here on account of a BRAIN-DEAD
			       Q@#%!# library interface in regex.c.  */
} patterns0;

struct patterns *patterns;
size_t pcount;

void
dfaerror (char const *mesg)
{
  error (EXIT_TROUBLE, 0, "%s", mesg);

  /* notreached */
  /* Tell static analyzers that this function does not return.  */
  abort ();
}

/* Number of compiled fixed strings known to exactly match the regexp.
   If kwsexec returns < kwset_exact_matches, then we don't need to
   call the regexp matcher at all. */
static int kwset_exact_matches;

static char const *
kwsincr_case (const char *must)
{
  const char *buf;
  size_t n;

  n = strlen (must);
#ifdef MBS_SUPPORT
  if (match_icase && MB_CUR_MAX > 1)
    buf = mbtolower (must, &n);
  else
#endif
    buf = must;
  return kwsincr (kwset, buf, n);
}

/* If the DFA turns out to have some set of fixed strings one of
   which must occur in the match, then we build a kwset matcher
   to find those strings, and thus quickly filter out impossible
   matches. */
static void
kwsmusts (void)
{
  struct dfamust const *dm;
  char const *err;

  if (dfa.musts)
    {
      kwsinit (&kwset);
      /* First, we compile in the substrings known to be exact
	 matches.  The kwset matcher will return the index
	 of the matching string that it chooses. */
      for (dm = dfa.musts; dm; dm = dm->next)
	{
	  if (!dm->exact)
	    continue;
	  ++kwset_exact_matches;
	  if ((err = kwsincr_case (dm->must)) != NULL)
	    error (EXIT_TROUBLE, 0, "%s", err);
	}
      /* Now, we compile the substrings that will require
	 the use of the regexp matcher.  */
      for (dm = dfa.musts; dm; dm = dm->next)
	{
	  if (dm->exact)
	    continue;
	  if ((err = kwsincr_case (dm->must)) != NULL)
	    error (EXIT_TROUBLE, 0, "%s", err);
	}
      if ((err = kwsprep (kwset)) != NULL)
	error (EXIT_TROUBLE, 0, "%s", err);
    }
}

void
GEAcompile (char const *pattern, size_t size, reg_syntax_t syntax_bits)
{
  const char *err;
  const char *p, *sep;
  size_t total = size;
  char *motif;

  if (match_icase)
    syntax_bits |= RE_ICASE;
  re_set_syntax (syntax_bits);
  dfasyntax (syntax_bits, match_icase, eolbyte);

  /* For GNU regex compiler we have to pass the patterns separately to detect
     errors like "[\nallo\n]\n".  The patterns here are "[", "allo" and "]"
     GNU regex should have raise a syntax error.  The same for backref, where
     the backref should have been local to each pattern.  */
  p = pattern;
  do
    {
      size_t len;
      sep = memchr (p, '\n', total);
      if (sep)
	{
	  len = sep - p;
	  sep++;
	  total -= (len + 1);
	}
      else
	{
	  len = total;
	  total = 0;
	}

      patterns = realloc (patterns, (pcount + 1) * sizeof (*patterns));
      if (patterns == NULL)
	error (EXIT_TROUBLE, errno, _("memory exhausted"));
      patterns[pcount] = patterns0;

      if ((err = re_compile_pattern (p, len,
				    &(patterns[pcount].regexbuf))) != NULL)
	error (EXIT_TROUBLE, 0, "%s", err);
      pcount++;

      p = sep;
    } while (sep && total != 0);

  /* In the match_words and match_lines cases, we use a different pattern
     for the DFA matcher that will quickly throw out cases that won't work.
     Then if DFA succeeds we do some hairy stuff using the regex matcher
     to decide whether the match should really count. */
  if (match_words || match_lines)
    {
      static char const line_beg_no_bk[] = "^(";
      static char const line_end_no_bk[] = ")$";
      static char const word_beg_no_bk[] = "(^|[^[:alnum:]_])(";
      static char const word_end_no_bk[] = ")([^[:alnum:]_]|$)";
      static char const line_beg_bk[] = "^\\(";
      static char const line_end_bk[] = "\\)$";
      static char const word_beg_bk[] = "\\(^\\|[^[:alnum:]_]\\)\\(";
      static char const word_end_bk[] = "\\)\\([^[:alnum:]_]\\|$\\)";
      int bk = !(syntax_bits & RE_NO_BK_PARENS);
      char *n = xmalloc (sizeof word_beg_bk - 1 + size + sizeof word_end_bk);

      strcpy (n, match_lines ? (bk ? line_beg_bk : line_beg_no_bk)
			     : (bk ? word_beg_bk : word_beg_no_bk));
      total = strlen(n);
      memcpy (n + total, pattern, size);
      total += size;
      strcpy (n + total, match_lines ? (bk ? line_end_bk : line_end_no_bk)
				     : (bk ? word_end_bk : word_end_no_bk));
      total += strlen (n + total);
      pattern = motif = n;
      size = total;
    }
  else
    motif = NULL;

  dfacomp (pattern, size, &dfa, 1);
  kwsmusts ();

  free(motif);
}

size_t
EGexecute (char const *buf, size_t size, size_t *match_size,
	   char const *start_ptr)
{
  char const *buflim, *beg, *end, *match, *best_match, *mb_start;
  char eol = eolbyte;
  int backref, start, len, best_len;
  struct kwsmatch kwsm;
  size_t i, ret_val;
#ifdef MBS_SUPPORT
  if (MB_CUR_MAX > 1)
    {
      if (match_icase)
        {
          /* mbtolower adds a NUL byte at the end.  That will provide
	     space for the sentinel byte dfaexec may add.  */
          char *case_buf = mbtolower (buf, &size);
	  if (start_ptr)
	    start_ptr = case_buf + (start_ptr - buf);
          buf = case_buf;
        }
    }
#endif /* MBS_SUPPORT */

  mb_start = buf;
  buflim = buf + size;

  for (beg = end = buf; end < buflim; beg = end)
    {
      if (!start_ptr)
	{
	  /* We don't care about an exact match.  */
	  if (kwset)
	    {
	      /* Find a possible match using the KWset matcher. */
	      size_t offset = kwsexec (kwset, beg, buflim - beg, &kwsm);
	      if (offset == (size_t) -1)
		goto failure;
	      beg += offset;
	      /* Narrow down to the line containing the candidate, and
		 run it through DFA. */
	      //prophet generated patch
	      if (__get_mutant()==0) {
	      if (((end = memchr(beg, eol, buflim - beg)) != ((void *)0)) && !(__is_neg(26, &(buflim), sizeof (buflim), &(beg), sizeof (beg), &(end), sizeof (end), &(eol), sizeof (eol), &(offset), sizeof (offset), &(match), sizeof (match), &(buf), sizeof (buf), &(kwset), sizeof (kwset), &(kwset_exact_matches), sizeof (kwset_exact_matches), &(mb_start), sizeof (mb_start), &(start_ptr), sizeof (start_ptr), &(size), sizeof (size), &(backref), sizeof (backref), &(match_icase), sizeof (match_icase), &(eolbyte), sizeof (eolbyte), &(best_match), sizeof (best_match), &(best_len), sizeof (best_len), &(i), sizeof (i), &(pcount), sizeof (pcount), &(patterns), sizeof (patterns), &(start), sizeof (start), &(len), sizeof (len), &(match_words), sizeof (match_words), &(match_lines), sizeof (match_lines), &(ret_val), sizeof (ret_val), &(match_size), sizeof (match_size))))
	          end++;
	      else
	          end = buflim;
	      }
	      else if (__get_mutant()==1) {
	      if (((end = memchr(beg, eol, buflim - beg)) != ((void *)0)) || (__is_neg(26, &(buflim), sizeof (buflim), &(beg), sizeof (beg), &(end), sizeof (end), &(eol), sizeof (eol), &(offset), sizeof (offset), &(match), sizeof (match), &(buf), sizeof (buf), &(kwset), sizeof (kwset), &(kwset_exact_matches), sizeof (kwset_exact_matches), &(mb_start), sizeof (mb_start), &(start_ptr), sizeof (start_ptr), &(size), sizeof (size), &(backref), sizeof (backref), &(match_icase), sizeof (match_icase), &(eolbyte), sizeof (eolbyte), &(best_match), sizeof (best_match), &(best_len), sizeof (best_len), &(i), sizeof (i), &(pcount), sizeof (pcount), &(patterns), sizeof (patterns), &(start), sizeof (start), &(len), sizeof (len), &(match_words), sizeof (match_words), &(match_lines), sizeof (match_lines), &(ret_val), sizeof (ret_val), &(match_size), sizeof (match_size))))
	          end++;
	      else
	          end = buflim;
	      }
	      match = beg;
	      while (beg > buf && beg[-1] != eol)
		--beg;
	      if (kwsm.index < kwset_exact_matches)
                {
#ifdef MBS_SUPPORT
                  if (mb_start < beg)
                    mb_start = beg;
                  if (MB_CUR_MAX == 1 || !is_mb_middle (&mb_start, match, buflim))
#endif
                    goto success;
                }
	      if (dfaexec (&dfa, beg, (char *) end, 0, NULL, &backref) == NULL)
		continue;
	    }
	  else
	    {
	      /* No good fixed strings; start with DFA. */
	      char const *next_beg = dfaexec (&dfa, beg, (char *) buflim,
					      0, NULL, &backref);
	      if (next_beg == NULL)
		break;
	      /* Narrow down to the line we've found. */
	      beg = next_beg;
	      if ((end = memchr(beg, eol, buflim - beg)) != NULL)
	        end++;
              else
                end = buflim;
	      while (beg > buf && beg[-1] != eol)
		--beg;
	    }
	  /* Successful, no backreferences encountered! */
	  if (!backref)
	    goto success;
	}
      else
	{
	  /* We are looking for the leftmost (then longest) exact match.
	     We will go through the outer loop only once.  */
	  beg = start_ptr;
	  end = buflim;
	}

      /* If we've made it to this point, this means DFA has seen
	 a probable match, and we need to run it through Regex. */
      best_match = end;
      best_len = 0;
      for (i = 0; i < pcount; i++)
	{
	  patterns[i].regexbuf.not_eol = 0;
	  if (0 <= (start = re_search (&(patterns[i].regexbuf),
				       buf, end - buf - 1,
				       beg - buf, end - beg - 1,
				       &(patterns[i].regs))))
	    {
	      len = patterns[i].regs.end[0] - start;
	      match = buf + start;
	      if (match > best_match)
		continue;
	      if (start_ptr && !match_words)
		goto assess_pattern_match;
	      if ((!match_lines && !match_words)
		  || (match_lines && len == end - beg - 1))
		{
		  match = beg;
		  len = end - beg;
		  goto assess_pattern_match;
		}
	      /* If -w, check if the match aligns with word boundaries.
		 We do this iteratively because:
		 (a) the line may contain more than one occurence of the
		 pattern, and
		 (b) Several alternatives in the pattern might be valid at a
		 given point, and we may need to consider a shorter one to
		 find a word boundary.  */
	      if (match_words)
		while (match <= best_match)
		  {
		    if ((match == buf || !WCHAR ((unsigned char) match[-1]))
			&& (len == end - beg - 1
			    || !WCHAR ((unsigned char) match[len])))
		      goto assess_pattern_match;
		    if (len > 0)
		      {
			/* Try a shorter length anchored at the same place. */
			--len;
			patterns[i].regexbuf.not_eol = 1;
			len = re_match (&(patterns[i].regexbuf),
					buf, match + len - beg, match - buf,
					&(patterns[i].regs));
		      }
		    if (len <= 0)
		      {
			/* Try looking further on. */
			if (match == end - 1)
			  break;
			match++;
			patterns[i].regexbuf.not_eol = 0;
			start = re_search (&(patterns[i].regexbuf),
					   buf, end - buf - 1,
					   match - buf, end - match - 1,
					   &(patterns[i].regs));
			if (start < 0)
			  break;
			len = patterns[i].regs.end[0] - start;
			match = buf + start;
		      }
		  } /* while (match <= best_match) */
	      continue;
	    assess_pattern_match:
	      if (!start_ptr)
		{
		  /* Good enough for a non-exact match.
		     No need to look at further patterns, if any.  */
		  beg = match;
		  goto success_in_len;
		}
	      if (match < best_match || (match == best_match && len > best_len))
		{
		  /* Best exact match:  leftmost, then longest.  */
		  best_match = match;
		  best_len = len;
		}
	    } /* if re_search >= 0 */
	} /* for Regex patterns.  */
	if (best_match < end)
	  {
	    /* We have found an exact match.  We were just
	       waiting for the best one (leftmost then longest).  */
	    beg = best_match;
	    len = best_len;
	    goto success_in_len;
	  }
    } /* for (beg = end ..) */

 failure:
  ret_val = -1;
  goto out;

 success:
  len = end - beg;
 success_in_len:
  *match_size = len;
  ret_val = beg - buf;
 out:
  return ret_val;
}

Building:src at:
/home/ubuntu/spr-fast/tests/corebench/grep/grep-case-8a025cf8-8f08d8e2/tempworkdir-l/srcMerged code building succ, going to invoke tester!
CondTester, Testing instance id 54:
//src_file:src/dfasearch.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); void* memset(void*, int, unsigned long); 
/* dfasearch.c - searching subroutines using dfa and regex for grep.
   Copyright 1992, 1998, 2000, 2007, 2009-2010 Free Software Foundation, Inc.

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 3, or (at your option)
   any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program; if not, write to the Free Software
   Foundation, Inc., 51 Franklin Street - Fifth Floor, Boston, MA
   02110-1301, USA.  */

/* Written August 1992 by Mike Haertel. */

#include <config.h>
#include "search.h"
#include "dfa.h"

/* For -w, we also consider _ to be word constituent.  */
#define WCHAR(C) (ISALNUM(C) || (C) == '_')

/* KWset compiled pattern.  For Ecompile and Gcompile, we compile
   a list of strings, at least one of which is known to occur in
   any string matching the regexp. */
static kwset_t kwset;

/* DFA compiled regexp. */
static struct dfa dfa;

/* The Regex compiled patterns.  */
static struct patterns
{
  /* Regex compiled regexp. */
  struct re_pattern_buffer regexbuf;
  struct re_registers regs; /* This is here on account of a BRAIN-DEAD
			       Q@#%!# library interface in regex.c.  */
} patterns0;

struct patterns *patterns;
size_t pcount;

void
dfaerror (char const *mesg)
{
  error (EXIT_TROUBLE, 0, "%s", mesg);

  /* notreached */
  /* Tell static analyzers that this function does not return.  */
  abort ();
}

/* Number of compiled fixed strings known to exactly match the regexp.
   If kwsexec returns < kwset_exact_matches, then we don't need to
   call the regexp matcher at all. */
static int kwset_exact_matches;

static char const *
kwsincr_case (const char *must)
{
  const char *buf;
  size_t n;

  n = strlen (must);
#ifdef MBS_SUPPORT
  if (match_icase && MB_CUR_MAX > 1)
    buf = mbtolower (must, &n);
  else
#endif
    buf = must;
  return kwsincr (kwset, buf, n);
}

/* If the DFA turns out to have some set of fixed strings one of
   which must occur in the match, then we build a kwset matcher
   to find those strings, and thus quickly filter out impossible
   matches. */
static void
kwsmusts (void)
{
  struct dfamust const *dm;
  char const *err;

  if (dfa.musts)
    {
      kwsinit (&kwset);
      /* First, we compile in the substrings known to be exact
	 matches.  The kwset matcher will return the index
	 of the matching string that it chooses. */
      for (dm = dfa.musts; dm; dm = dm->next)
	{
	  if (!dm->exact)
	    continue;
	  ++kwset_exact_matches;
	  if ((err = kwsincr_case (dm->must)) != NULL)
	    error (EXIT_TROUBLE, 0, "%s", err);
	}
      /* Now, we compile the substrings that will require
	 the use of the regexp matcher.  */
      for (dm = dfa.musts; dm; dm = dm->next)
	{
	  if (dm->exact)
	    continue;
	  if ((err = kwsincr_case (dm->must)) != NULL)
	    error (EXIT_TROUBLE, 0, "%s", err);
	}
      if ((err = kwsprep (kwset)) != NULL)
	error (EXIT_TROUBLE, 0, "%s", err);
    }
}

void
GEAcompile (char const *pattern, size_t size, reg_syntax_t syntax_bits)
{
  const char *err;
  const char *p, *sep;
  size_t total = size;
  char *motif;

  if (match_icase)
    syntax_bits |= RE_ICASE;
  re_set_syntax (syntax_bits);
  dfasyntax (syntax_bits, match_icase, eolbyte);

  /* For GNU regex compiler we have to pass the patterns separately to detect
     errors like "[\nallo\n]\n".  The patterns here are "[", "allo" and "]"
     GNU regex should have raise a syntax error.  The same for backref, where
     the backref should have been local to each pattern.  */
  p = pattern;
  do
    {
      size_t len;
      sep = memchr (p, '\n', total);
      if (sep)
	{
	  len = sep - p;
	  sep++;
	  total -= (len + 1);
	}
      else
	{
	  len = total;
	  total = 0;
	}

      patterns = realloc (patterns, (pcount + 1) * sizeof (*patterns));
      if (patterns == NULL)
	error (EXIT_TROUBLE, errno, _("memory exhausted"));
      patterns[pcount] = patterns0;

      if ((err = re_compile_pattern (p, len,
				    &(patterns[pcount].regexbuf))) != NULL)
	error (EXIT_TROUBLE, 0, "%s", err);
      pcount++;

      p = sep;
    } while (sep && total != 0);

  /* In the match_words and match_lines cases, we use a different pattern
     for the DFA matcher that will quickly throw out cases that won't work.
     Then if DFA succeeds we do some hairy stuff using the regex matcher
     to decide whether the match should really count. */
  if (match_words || match_lines)
    {
      static char const line_beg_no_bk[] = "^(";
      static char const line_end_no_bk[] = ")$";
      static char const word_beg_no_bk[] = "(^|[^[:alnum:]_])(";
      static char const word_end_no_bk[] = ")([^[:alnum:]_]|$)";
      static char const line_beg_bk[] = "^\\(";
      static char const line_end_bk[] = "\\)$";
      static char const word_beg_bk[] = "\\(^\\|[^[:alnum:]_]\\)\\(";
      static char const word_end_bk[] = "\\)\\([^[:alnum:]_]\\|$\\)";
      int bk = !(syntax_bits & RE_NO_BK_PARENS);
      char *n = xmalloc (sizeof word_beg_bk - 1 + size + sizeof word_end_bk);

      strcpy (n, match_lines ? (bk ? line_beg_bk : line_beg_no_bk)
			     : (bk ? word_beg_bk : word_beg_no_bk));
      total = strlen(n);
      memcpy (n + total, pattern, size);
      total += size;
      strcpy (n + total, match_lines ? (bk ? line_end_bk : line_end_no_bk)
				     : (bk ? word_end_bk : word_end_no_bk));
      total += strlen (n + total);
      pattern = motif = n;
      size = total;
    }
  else
    motif = NULL;

  dfacomp (pattern, size, &dfa, 1);
  kwsmusts ();

  free(motif);
}

size_t
EGexecute (char const *buf, size_t size, size_t *match_size,
	   char const *start_ptr)
{
  char const *buflim, *beg, *end, *match, *best_match, *mb_start;
  char eol = eolbyte;
  int backref, start, len, best_len;
  struct kwsmatch kwsm;
  size_t i, ret_val;
#ifdef MBS_SUPPORT
  if (MB_CUR_MAX > 1)
    {
      if (match_icase)
        {
          /* mbtolower adds a NUL byte at the end.  That will provide
	     space for the sentinel byte dfaexec may add.  */
          char *case_buf = mbtolower (buf, &size);
	  if (start_ptr)
	    start_ptr = case_buf + (start_ptr - buf);
          buf = case_buf;
        }
    }
#endif /* MBS_SUPPORT */

  mb_start = buf;
  buflim = buf + size;

  for (beg = end = buf; end < buflim; beg = end)
    {
      if (!start_ptr)
	{
	  /* We don't care about an exact match.  */
	  if (kwset)
	    {
	      /* Find a possible match using the KWset matcher. */
	      size_t offset = kwsexec (kwset, beg, buflim - beg, &kwsm);
	      if (offset == (size_t) -1)
		goto failure;
	      beg += offset;
	      /* Narrow down to the line containing the candidate, and
		 run it through DFA. */
	      
//Patch 0:
if (((end = memchr(beg, eol, buflim - beg)) != ((void *)0)) && !(__is_neg(26, &(buflim), sizeof (buflim), &(beg), sizeof (beg), &(end), sizeof (end), &(eol), sizeof (eol), &(offset), sizeof (offset), &(match), sizeof (match), &(buf), sizeof (buf), &(kwset), sizeof (kwset), &(kwset_exact_matches), sizeof (kwset_exact_matches), &(mb_start), sizeof (mb_start), &(start_ptr), sizeof (start_ptr), &(size), sizeof (size), &(backref), sizeof (backref), &(match_icase), sizeof (match_icase), &(eolbyte), sizeof (eolbyte), &(best_match), sizeof (best_match), &(best_len), sizeof (best_len), &(i), sizeof (i), &(pcount), sizeof (pcount), &(patterns), sizeof (patterns), &(start), sizeof (start), &(len), sizeof (len), &(match_words), sizeof (match_words), &(match_lines), sizeof (match_lines), &(ret_val), sizeof (ret_val), &(match_size), sizeof (match_size))))
    end++;
else
    end = buflim;

//CodeSeg 1:
	      match = beg;
	      while (beg > buf && beg[-1] != eol)
		--beg;
	      if (kwsm.index < kwset_exact_matches)
                {
#ifdef MBS_SUPPORT
                  if (mb_start < beg)
                    mb_start = beg;
                  if (MB_CUR_MAX == 1 || !is_mb_middle (&mb_start, match, buflim))
#endif
                    goto success;
                }
	      if (dfaexec (&dfa, beg, (char *) end, 0, NULL, &backref) == NULL)
		continue;
	    }
	  else
	    {
	      /* No good fixed strings; start with DFA. */
	      char const *next_beg = dfaexec (&dfa, beg, (char *) buflim,
					      0, NULL, &backref);
	      if (next_beg == NULL)
		break;
	      /* Narrow down to the line we've found. */
	      beg = next_beg;
	      if ((end = memchr(beg, eol, buflim - beg)) != NULL)
	        end++;
              else
                end = buflim;
	      while (beg > buf && beg[-1] != eol)
		--beg;
	    }
	  /* Successful, no backreferences encountered! */
	  if (!backref)
	    goto success;
	}
      else
	{
	  /* We are looking for the leftmost (then longest) exact match.
	     We will go through the outer loop only once.  */
	  beg = start_ptr;
	  end = buflim;
	}

      /* If we've made it to this point, this means DFA has seen
	 a probable match, and we need to run it through Regex. */
      best_match = end;
      best_len = 0;
      for (i = 0; i < pcount; i++)
	{
	  patterns[i].regexbuf.not_eol = 0;
	  if (0 <= (start = re_search (&(patterns[i].regexbuf),
				       buf, end - buf - 1,
				       beg - buf, end - beg - 1,
				       &(patterns[i].regs))))
	    {
	      len = patterns[i].regs.end[0] - start;
	      match = buf + start;
	      if (match > best_match)
		continue;
	      if (start_ptr && !match_words)
		goto assess_pattern_match;
	      if ((!match_lines && !match_words)
		  || (match_lines && len == end - beg - 1))
		{
		  match = beg;
		  len = end - beg;
		  goto assess_pattern_match;
		}
	      /* If -w, check if the match aligns with word boundaries.
		 We do this iteratively because:
		 (a) the line may contain more than one occurence of the
		 pattern, and
		 (b) Several alternatives in the pattern might be valid at a
		 given point, and we may need to consider a shorter one to
		 find a word boundary.  */
	      if (match_words)
		while (match <= best_match)
		  {
		    if ((match == buf || !WCHAR ((unsigned char) match[-1]))
			&& (len == end - beg - 1
			    || !WCHAR ((unsigned char) match[len])))
		      goto assess_pattern_match;
		    if (len > 0)
		      {
			/* Try a shorter length anchored at the same place. */
			--len;
			patterns[i].regexbuf.not_eol = 1;
			len = re_match (&(patterns[i].regexbuf),
					buf, match + len - beg, match - buf,
					&(patterns[i].regs));
		      }
		    if (len <= 0)
		      {
			/* Try looking further on. */
			if (match == end - 1)
			  break;
			match++;
			patterns[i].regexbuf.not_eol = 0;
			start = re_search (&(patterns[i].regexbuf),
					   buf, end - buf - 1,
					   match - buf, end - match - 1,
					   &(patterns[i].regs));
			if (start < 0)
			  break;
			len = patterns[i].regs.end[0] - start;
			match = buf + start;
		      }
		  } /* while (match <= best_match) */
	      continue;
	    assess_pattern_match:
	      if (!start_ptr)
		{
		  /* Good enough for a non-exact match.
		     No need to look at further patterns, if any.  */
		  beg = match;
		  goto success_in_len;
		}
	      if (match < best_match || (match == best_match && len > best_len))
		{
		  /* Best exact match:  leftmost, then longest.  */
		  best_match = match;
		  best_len = len;
		}
	    } /* if re_search >= 0 */
	} /* for Regex patterns.  */
	if (best_match < end)
	  {
	    /* We have found an exact match.  We were just
	       waiting for the best one (leftmost then longest).  */
	    beg = best_match;
	    len = best_len;
	    goto success_in_len;
	  }
    } /* for (beg = end ..) */

 failure:
  ret_val = -1;
  goto out;

 success:
  len = end - beg;
 success_in_len:
  *match_size = len;
  ret_val = beg - buf;
 out:
  return ret_val;
}

Testing negative cases!
Testing 0 (with abstract condition) ENVIS_NEG
Iteration 0
Running test command:
/home/ubuntu/spr-fast/tools/grep-test.py /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-8a025cf8-8f08d8e2/tempworkdir-l/src /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-8a025cf8-8f08d8e2/tempworkdir-l/tests /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-8a025cf8-8f08d8e2/tempworkdir-l 0  > __res
Opening:/tmp/neg.tmp!
NegativeBRANCH RECORD/tmp/neg.tmp!
APPENDING TO ISNEG:/tmp/neg.tmp!
Branch 0: 0
Iteration 1
Running test command:
/home/ubuntu/spr-fast/tools/grep-test.py /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-8a025cf8-8f08d8e2/tempworkdir-l/src /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-8a025cf8-8f08d8e2/tempworkdir-l/tests /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-8a025cf8-8f08d8e2/tempworkdir-l 0  > __res
Opening:/tmp/neg.tmp!
NegativeBRANCH RECORD/tmp/neg.tmp!
APPENDING TO ISNEG:/tmp/neg.tmp!
Branch 0: 1
Running test command:
/home/ubuntu/spr-fast/tools/grep-test.py /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-8a025cf8-8f08d8e2/tempworkdir-l/src /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-8a025cf8-8f08d8e2/tempworkdir-l/tests /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-8a025cf8-8f08d8e2/tempworkdir-l 0  > __res
CondTester, Testing instance id 55:
//src_file:src/dfasearch.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); void* memset(void*, int, unsigned long); 
/* dfasearch.c - searching subroutines using dfa and regex for grep.
   Copyright 1992, 1998, 2000, 2007, 2009-2010 Free Software Foundation, Inc.

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 3, or (at your option)
   any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program; if not, write to the Free Software
   Foundation, Inc., 51 Franklin Street - Fifth Floor, Boston, MA
   02110-1301, USA.  */

/* Written August 1992 by Mike Haertel. */

#include <config.h>
#include "search.h"
#include "dfa.h"

/* For -w, we also consider _ to be word constituent.  */
#define WCHAR(C) (ISALNUM(C) || (C) == '_')

/* KWset compiled pattern.  For Ecompile and Gcompile, we compile
   a list of strings, at least one of which is known to occur in
   any string matching the regexp. */
static kwset_t kwset;

/* DFA compiled regexp. */
static struct dfa dfa;

/* The Regex compiled patterns.  */
static struct patterns
{
  /* Regex compiled regexp. */
  struct re_pattern_buffer regexbuf;
  struct re_registers regs; /* This is here on account of a BRAIN-DEAD
			       Q@#%!# library interface in regex.c.  */
} patterns0;

struct patterns *patterns;
size_t pcount;

void
dfaerror (char const *mesg)
{
  error (EXIT_TROUBLE, 0, "%s", mesg);

  /* notreached */
  /* Tell static analyzers that this function does not return.  */
  abort ();
}

/* Number of compiled fixed strings known to exactly match the regexp.
   If kwsexec returns < kwset_exact_matches, then we don't need to
   call the regexp matcher at all. */
static int kwset_exact_matches;

static char const *
kwsincr_case (const char *must)
{
  const char *buf;
  size_t n;

  n = strlen (must);
#ifdef MBS_SUPPORT
  if (match_icase && MB_CUR_MAX > 1)
    buf = mbtolower (must, &n);
  else
#endif
    buf = must;
  return kwsincr (kwset, buf, n);
}

/* If the DFA turns out to have some set of fixed strings one of
   which must occur in the match, then we build a kwset matcher
   to find those strings, and thus quickly filter out impossible
   matches. */
static void
kwsmusts (void)
{
  struct dfamust const *dm;
  char const *err;

  if (dfa.musts)
    {
      kwsinit (&kwset);
      /* First, we compile in the substrings known to be exact
	 matches.  The kwset matcher will return the index
	 of the matching string that it chooses. */
      for (dm = dfa.musts; dm; dm = dm->next)
	{
	  if (!dm->exact)
	    continue;
	  ++kwset_exact_matches;
	  if ((err = kwsincr_case (dm->must)) != NULL)
	    error (EXIT_TROUBLE, 0, "%s", err);
	}
      /* Now, we compile the substrings that will require
	 the use of the regexp matcher.  */
      for (dm = dfa.musts; dm; dm = dm->next)
	{
	  if (dm->exact)
	    continue;
	  if ((err = kwsincr_case (dm->must)) != NULL)
	    error (EXIT_TROUBLE, 0, "%s", err);
	}
      if ((err = kwsprep (kwset)) != NULL)
	error (EXIT_TROUBLE, 0, "%s", err);
    }
}

void
GEAcompile (char const *pattern, size_t size, reg_syntax_t syntax_bits)
{
  const char *err;
  const char *p, *sep;
  size_t total = size;
  char *motif;

  if (match_icase)
    syntax_bits |= RE_ICASE;
  re_set_syntax (syntax_bits);
  dfasyntax (syntax_bits, match_icase, eolbyte);

  /* For GNU regex compiler we have to pass the patterns separately to detect
     errors like "[\nallo\n]\n".  The patterns here are "[", "allo" and "]"
     GNU regex should have raise a syntax error.  The same for backref, where
     the backref should have been local to each pattern.  */
  p = pattern;
  do
    {
      size_t len;
      sep = memchr (p, '\n', total);
      if (sep)
	{
	  len = sep - p;
	  sep++;
	  total -= (len + 1);
	}
      else
	{
	  len = total;
	  total = 0;
	}

      patterns = realloc (patterns, (pcount + 1) * sizeof (*patterns));
      if (patterns == NULL)
	error (EXIT_TROUBLE, errno, _("memory exhausted"));
      patterns[pcount] = patterns0;

      if ((err = re_compile_pattern (p, len,
				    &(patterns[pcount].regexbuf))) != NULL)
	error (EXIT_TROUBLE, 0, "%s", err);
      pcount++;

      p = sep;
    } while (sep && total != 0);

  /* In the match_words and match_lines cases, we use a different pattern
     for the DFA matcher that will quickly throw out cases that won't work.
     Then if DFA succeeds we do some hairy stuff using the regex matcher
     to decide whether the match should really count. */
  if (match_words || match_lines)
    {
      static char const line_beg_no_bk[] = "^(";
      static char const line_end_no_bk[] = ")$";
      static char const word_beg_no_bk[] = "(^|[^[:alnum:]_])(";
      static char const word_end_no_bk[] = ")([^[:alnum:]_]|$)";
      static char const line_beg_bk[] = "^\\(";
      static char const line_end_bk[] = "\\)$";
      static char const word_beg_bk[] = "\\(^\\|[^[:alnum:]_]\\)\\(";
      static char const word_end_bk[] = "\\)\\([^[:alnum:]_]\\|$\\)";
      int bk = !(syntax_bits & RE_NO_BK_PARENS);
      char *n = xmalloc (sizeof word_beg_bk - 1 + size + sizeof word_end_bk);

      strcpy (n, match_lines ? (bk ? line_beg_bk : line_beg_no_bk)
			     : (bk ? word_beg_bk : word_beg_no_bk));
      total = strlen(n);
      memcpy (n + total, pattern, size);
      total += size;
      strcpy (n + total, match_lines ? (bk ? line_end_bk : line_end_no_bk)
				     : (bk ? word_end_bk : word_end_no_bk));
      total += strlen (n + total);
      pattern = motif = n;
      size = total;
    }
  else
    motif = NULL;

  dfacomp (pattern, size, &dfa, 1);
  kwsmusts ();

  free(motif);
}

size_t
EGexecute (char const *buf, size_t size, size_t *match_size,
	   char const *start_ptr)
{
  char const *buflim, *beg, *end, *match, *best_match, *mb_start;
  char eol = eolbyte;
  int backref, start, len, best_len;
  struct kwsmatch kwsm;
  size_t i, ret_val;
#ifdef MBS_SUPPORT
  if (MB_CUR_MAX > 1)
    {
      if (match_icase)
        {
          /* mbtolower adds a NUL byte at the end.  That will provide
	     space for the sentinel byte dfaexec may add.  */
          char *case_buf = mbtolower (buf, &size);
	  if (start_ptr)
	    start_ptr = case_buf + (start_ptr - buf);
          buf = case_buf;
        }
    }
#endif /* MBS_SUPPORT */

  mb_start = buf;
  buflim = buf + size;

  for (beg = end = buf; end < buflim; beg = end)
    {
      if (!start_ptr)
	{
	  /* We don't care about an exact match.  */
	  if (kwset)
	    {
	      /* Find a possible match using the KWset matcher. */
	      size_t offset = kwsexec (kwset, beg, buflim - beg, &kwsm);
	      if (offset == (size_t) -1)
		goto failure;
	      beg += offset;
	      /* Narrow down to the line containing the candidate, and
		 run it through DFA. */
	      
//Patch 0:
if (((end = memchr(beg, eol, buflim - beg)) != ((void *)0)) || (__is_neg(26, &(buflim), sizeof (buflim), &(beg), sizeof (beg), &(end), sizeof (end), &(eol), sizeof (eol), &(offset), sizeof (offset), &(match), sizeof (match), &(buf), sizeof (buf), &(kwset), sizeof (kwset), &(kwset_exact_matches), sizeof (kwset_exact_matches), &(mb_start), sizeof (mb_start), &(start_ptr), sizeof (start_ptr), &(size), sizeof (size), &(backref), sizeof (backref), &(match_icase), sizeof (match_icase), &(eolbyte), sizeof (eolbyte), &(best_match), sizeof (best_match), &(best_len), sizeof (best_len), &(i), sizeof (i), &(pcount), sizeof (pcount), &(patterns), sizeof (patterns), &(start), sizeof (start), &(len), sizeof (len), &(match_words), sizeof (match_words), &(match_lines), sizeof (match_lines), &(ret_val), sizeof (ret_val), &(match_size), sizeof (match_size))))
    end++;
else
    end = buflim;

//CodeSeg 1:
	      match = beg;
	      while (beg > buf && beg[-1] != eol)
		--beg;
	      if (kwsm.index < kwset_exact_matches)
                {
#ifdef MBS_SUPPORT
                  if (mb_start < beg)
                    mb_start = beg;
                  if (MB_CUR_MAX == 1 || !is_mb_middle (&mb_start, match, buflim))
#endif
                    goto success;
                }
	      if (dfaexec (&dfa, beg, (char *) end, 0, NULL, &backref) == NULL)
		continue;
	    }
	  else
	    {
	      /* No good fixed strings; start with DFA. */
	      char const *next_beg = dfaexec (&dfa, beg, (char *) buflim,
					      0, NULL, &backref);
	      if (next_beg == NULL)
		break;
	      /* Narrow down to the line we've found. */
	      beg = next_beg;
	      if ((end = memchr(beg, eol, buflim - beg)) != NULL)
	        end++;
              else
                end = buflim;
	      while (beg > buf && beg[-1] != eol)
		--beg;
	    }
	  /* Successful, no backreferences encountered! */
	  if (!backref)
	    goto success;
	}
      else
	{
	  /* We are looking for the leftmost (then longest) exact match.
	     We will go through the outer loop only once.  */
	  beg = start_ptr;
	  end = buflim;
	}

      /* If we've made it to this point, this means DFA has seen
	 a probable match, and we need to run it through Regex. */
      best_match = end;
      best_len = 0;
      for (i = 0; i < pcount; i++)
	{
	  patterns[i].regexbuf.not_eol = 0;
	  if (0 <= (start = re_search (&(patterns[i].regexbuf),
				       buf, end - buf - 1,
				       beg - buf, end - beg - 1,
				       &(patterns[i].regs))))
	    {
	      len = patterns[i].regs.end[0] - start;
	      match = buf + start;
	      if (match > best_match)
		continue;
	      if (start_ptr && !match_words)
		goto assess_pattern_match;
	      if ((!match_lines && !match_words)
		  || (match_lines && len == end - beg - 1))
		{
		  match = beg;
		  len = end - beg;
		  goto assess_pattern_match;
		}
	      /* If -w, check if the match aligns with word boundaries.
		 We do this iteratively because:
		 (a) the line may contain more than one occurence of the
		 pattern, and
		 (b) Several alternatives in the pattern might be valid at a
		 given point, and we may need to consider a shorter one to
		 find a word boundary.  */
	      if (match_words)
		while (match <= best_match)
		  {
		    if ((match == buf || !WCHAR ((unsigned char) match[-1]))
			&& (len == end - beg - 1
			    || !WCHAR ((unsigned char) match[len])))
		      goto assess_pattern_match;
		    if (len > 0)
		      {
			/* Try a shorter length anchored at the same place. */
			--len;
			patterns[i].regexbuf.not_eol = 1;
			len = re_match (&(patterns[i].regexbuf),
					buf, match + len - beg, match - buf,
					&(patterns[i].regs));
		      }
		    if (len <= 0)
		      {
			/* Try looking further on. */
			if (match == end - 1)
			  break;
			match++;
			patterns[i].regexbuf.not_eol = 0;
			start = re_search (&(patterns[i].regexbuf),
					   buf, end - buf - 1,
					   match - buf, end - match - 1,
					   &(patterns[i].regs));
			if (start < 0)
			  break;
			len = patterns[i].regs.end[0] - start;
			match = buf + start;
		      }
		  } /* while (match <= best_match) */
	      continue;
	    assess_pattern_match:
	      if (!start_ptr)
		{
		  /* Good enough for a non-exact match.
		     No need to look at further patterns, if any.  */
		  beg = match;
		  goto success_in_len;
		}
	      if (match < best_match || (match == best_match && len > best_len))
		{
		  /* Best exact match:  leftmost, then longest.  */
		  best_match = match;
		  best_len = len;
		}
	    } /* if re_search >= 0 */
	} /* for Regex patterns.  */
	if (best_match < end)
	  {
	    /* We have found an exact match.  We were just
	       waiting for the best one (leftmost then longest).  */
	    beg = best_match;
	    len = best_len;
	    goto success_in_len;
	  }
    } /* for (beg = end ..) */

 failure:
  ret_val = -1;
  goto out;

 success:
  len = end - beg;
 success_in_len:
  *match_size = len;
  ret_val = beg - buf;
 out:
  return ret_val;
}

Testing negative cases!
Testing 0 (with abstract condition) ENVIS_NEG
Iteration 0
Running test command:
/home/ubuntu/spr-fast/tools/grep-test.py /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-8a025cf8-8f08d8e2/tempworkdir-l/src /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-8a025cf8-8f08d8e2/tempworkdir-l/tests /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-8a025cf8-8f08d8e2/tempworkdir-l 0  > __res
Opening:/tmp/neg.tmp!
NegativeBRANCH RECORD/tmp/neg.tmp!
Not caught by the negative case, give up!
APPENDING TO ISNEG:/tmp/neg.tmp!
Running test command:
/home/ubuntu/spr-fast/tools/grep-test.py /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-8a025cf8-8f08d8e2/tempworkdir-l/src /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-8a025cf8-8f08d8e2/tempworkdir-l/tests /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-8a025cf8-8f08d8e2/tempworkdir-l 0  > __res
a batched test job starts!
Building merged code:
src_file: src/dfasearch.c
full src: int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); void* memset(void*, int, unsigned long); 
/* dfasearch.c - searching subroutines using dfa and regex for grep.
   Copyright 1992, 1998, 2000, 2007, 2009-2010 Free Software Foundation, Inc.

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 3, or (at your option)
   any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program; if not, write to the Free Software
   Foundation, Inc., 51 Franklin Street - Fifth Floor, Boston, MA
   02110-1301, USA.  */

/* Written August 1992 by Mike Haertel. */

#include <config.h>
#include "search.h"
#include "dfa.h"

/* For -w, we also consider _ to be word constituent.  */
#define WCHAR(C) (ISALNUM(C) || (C) == '_')

/* KWset compiled pattern.  For Ecompile and Gcompile, we compile
   a list of strings, at least one of which is known to occur in
   any string matching the regexp. */
static kwset_t kwset;

/* DFA compiled regexp. */
static struct dfa dfa;

/* The Regex compiled patterns.  */
static struct patterns
{
  /* Regex compiled regexp. */
  struct re_pattern_buffer regexbuf;
  struct re_registers regs; /* This is here on account of a BRAIN-DEAD
			       Q@#%!# library interface in regex.c.  */
} patterns0;

struct patterns *patterns;
size_t pcount;

void
dfaerror (char const *mesg)
{
  error (EXIT_TROUBLE, 0, "%s", mesg);

  /* notreached */
  /* Tell static analyzers that this function does not return.  */
  abort ();
}

/* Number of compiled fixed strings known to exactly match the regexp.
   If kwsexec returns < kwset_exact_matches, then we don't need to
   call the regexp matcher at all. */
static int kwset_exact_matches;

static char const *
kwsincr_case (const char *must)
{
  const char *buf;
  size_t n;

  n = strlen (must);
#ifdef MBS_SUPPORT
  if (match_icase && MB_CUR_MAX > 1)
    buf = mbtolower (must, &n);
  else
#endif
    buf = must;
  return kwsincr (kwset, buf, n);
}

/* If the DFA turns out to have some set of fixed strings one of
   which must occur in the match, then we build a kwset matcher
   to find those strings, and thus quickly filter out impossible
   matches. */
static void
kwsmusts (void)
{
  struct dfamust const *dm;
  char const *err;

  if (dfa.musts)
    {
      kwsinit (&kwset);
      /* First, we compile in the substrings known to be exact
	 matches.  The kwset matcher will return the index
	 of the matching string that it chooses. */
      for (dm = dfa.musts; dm; dm = dm->next)
	{
	  if (!dm->exact)
	    continue;
	  ++kwset_exact_matches;
	  if ((err = kwsincr_case (dm->must)) != NULL)
	    error (EXIT_TROUBLE, 0, "%s", err);
	}
      /* Now, we compile the substrings that will require
	 the use of the regexp matcher.  */
      for (dm = dfa.musts; dm; dm = dm->next)
	{
	  if (dm->exact)
	    continue;
	  if ((err = kwsincr_case (dm->must)) != NULL)
	    error (EXIT_TROUBLE, 0, "%s", err);
	}
      if ((err = kwsprep (kwset)) != NULL)
	error (EXIT_TROUBLE, 0, "%s", err);
    }
}

void
GEAcompile (char const *pattern, size_t size, reg_syntax_t syntax_bits)
{
  const char *err;
  const char *p, *sep;
  size_t total = size;
  char *motif;

  if (match_icase)
    syntax_bits |= RE_ICASE;
  re_set_syntax (syntax_bits);
  dfasyntax (syntax_bits, match_icase, eolbyte);

  /* For GNU regex compiler we have to pass the patterns separately to detect
     errors like "[\nallo\n]\n".  The patterns here are "[", "allo" and "]"
     GNU regex should have raise a syntax error.  The same for backref, where
     the backref should have been local to each pattern.  */
  p = pattern;
  do
    {
      size_t len;
      sep = memchr (p, '\n', total);
      if (sep)
	{
	  len = sep - p;
	  sep++;
	  total -= (len + 1);
	}
      else
	{
	  len = total;
	  total = 0;
	}

      patterns = realloc (patterns, (pcount + 1) * sizeof (*patterns));
      if (patterns == NULL)
	error (EXIT_TROUBLE, errno, _("memory exhausted"));
      patterns[pcount] = patterns0;

      if ((err = re_compile_pattern (p, len,
				    &(patterns[pcount].regexbuf))) != NULL)
	error (EXIT_TROUBLE, 0, "%s", err);
      pcount++;

      p = sep;
    } while (sep && total != 0);

  /* In the match_words and match_lines cases, we use a different pattern
     for the DFA matcher that will quickly throw out cases that won't work.
     Then if DFA succeeds we do some hairy stuff using the regex matcher
     to decide whether the match should really count. */
  if (match_words || match_lines)
    {
      static char const line_beg_no_bk[] = "^(";
      static char const line_end_no_bk[] = ")$";
      static char const word_beg_no_bk[] = "(^|[^[:alnum:]_])(";
      static char const word_end_no_bk[] = ")([^[:alnum:]_]|$)";
      static char const line_beg_bk[] = "^\\(";
      static char const line_end_bk[] = "\\)$";
      static char const word_beg_bk[] = "\\(^\\|[^[:alnum:]_]\\)\\(";
      static char const word_end_bk[] = "\\)\\([^[:alnum:]_]\\|$\\)";
      int bk = !(syntax_bits & RE_NO_BK_PARENS);
      char *n = xmalloc (sizeof word_beg_bk - 1 + size + sizeof word_end_bk);

      strcpy (n, match_lines ? (bk ? line_beg_bk : line_beg_no_bk)
			     : (bk ? word_beg_bk : word_beg_no_bk));
      total = strlen(n);
      memcpy (n + total, pattern, size);
      total += size;
      strcpy (n + total, match_lines ? (bk ? line_end_bk : line_end_no_bk)
				     : (bk ? word_end_bk : word_end_no_bk));
      total += strlen (n + total);
      pattern = motif = n;
      size = total;
    }
  else
    motif = NULL;

  dfacomp (pattern, size, &dfa, 1);
  kwsmusts ();

  free(motif);
}

size_t
EGexecute (char const *buf, size_t size, size_t *match_size,
	   char const *start_ptr)
{
  char const *buflim, *beg, *end, *match, *best_match, *mb_start;
  char eol = eolbyte;
  int backref, start, len, best_len;
  struct kwsmatch kwsm;
  size_t i, ret_val;
#ifdef MBS_SUPPORT
  if (MB_CUR_MAX > 1)
    {
      if (match_icase)
        {
          /* mbtolower adds a NUL byte at the end.  That will provide
	     space for the sentinel byte dfaexec may add.  */
          char *case_buf = mbtolower (buf, &size);
	  if (start_ptr)
	    start_ptr = case_buf + (start_ptr - buf);
          buf = case_buf;
        }
    }
#endif /* MBS_SUPPORT */

  mb_start = buf;
  buflim = buf + size;

  for (beg = end = buf; end < buflim; beg = end)
    {
      if (!start_ptr)
	{
	  /* We don't care about an exact match.  */
	  if (kwset)
	    {
	      /* Find a possible match using the KWset matcher. */
	      size_t offset = kwsexec (kwset, beg, buflim - beg, &kwsm);
	      if (offset == (size_t) -1)
		goto failure;
	      beg += offset;
	      /* Narrow down to the line containing the candidate, and
		 run it through DFA. */
	      if ((end = memchr(beg, eol, buflim - beg)) != NULL)
	        end++;
              else
                end = buflim;
	      match = beg;
	      while (beg > buf && beg[-1] != eol)
		--beg;
	      //prophet generated patch
	      if (__get_mutant()==0) {
	      if ((kwsm.index < kwset_exact_matches) && !(__is_neg(27, &(kwset_exact_matches), sizeof (kwset_exact_matches), &(kwsm.index), sizeof (kwsm.index), &(beg), sizeof (beg), &(buf), sizeof (buf), &(eol), sizeof (eol), &(match), sizeof (match), &(mb_start), sizeof (mb_start), &(buflim), sizeof (buflim), &(end), sizeof (end), &(backref), sizeof (backref), &(offset), sizeof (offset), &(kwset), sizeof (kwset), &(start_ptr), sizeof (start_ptr), &(size), sizeof (size), &(match_icase), sizeof (match_icase), &(best_match), sizeof (best_match), &(best_len), sizeof (best_len), &(eolbyte), sizeof (eolbyte), &(i), sizeof (i), &(pcount), sizeof (pcount), &(patterns), sizeof (patterns), &(start), sizeof (start), &(len), sizeof (len), &(match_words), sizeof (match_words), &(match_lines), sizeof (match_lines), &(ret_val), sizeof (ret_val), &(match_size), sizeof (match_size)))) {
	          if (mb_start < beg)
	              mb_start = beg;
	          if ((__ctype_get_mb_cur_max()) == 1 || !is_mb_middle(&mb_start, match, buflim))
	              goto success;
	      }
	      }
	      else if (__get_mutant()==1) {
	      if ((kwsm.index < kwset_exact_matches) || (__is_neg(27, &(kwset_exact_matches), sizeof (kwset_exact_matches), &(kwsm.index), sizeof (kwsm.index), &(beg), sizeof (beg), &(buf), sizeof (buf), &(eol), sizeof (eol), &(match), sizeof (match), &(mb_start), sizeof (mb_start), &(buflim), sizeof (buflim), &(end), sizeof (end), &(backref), sizeof (backref), &(offset), sizeof (offset), &(kwset), sizeof (kwset), &(start_ptr), sizeof (start_ptr), &(size), sizeof (size), &(match_icase), sizeof (match_icase), &(best_match), sizeof (best_match), &(best_len), sizeof (best_len), &(eolbyte), sizeof (eolbyte), &(i), sizeof (i), &(pcount), sizeof (pcount), &(patterns), sizeof (patterns), &(start), sizeof (start), &(len), sizeof (len), &(match_words), sizeof (match_words), &(match_lines), sizeof (match_lines), &(ret_val), sizeof (ret_val), &(match_size), sizeof (match_size)))) {
	          if (mb_start < beg)
	              mb_start = beg;
	          if ((__ctype_get_mb_cur_max()) == 1 || !is_mb_middle(&mb_start, match, buflim))
	              goto success;
	      }
	      }
	      if (dfaexec (&dfa, beg, (char *) end, 0, NULL, &backref) == NULL)
		continue;
	    }
	  else
	    {
	      /* No good fixed strings; start with DFA. */
	      char const *next_beg = dfaexec (&dfa, beg, (char *) buflim,
					      0, NULL, &backref);
	      if (next_beg == NULL)
		break;
	      /* Narrow down to the line we've found. */
	      beg = next_beg;
	      if ((end = memchr(beg, eol, buflim - beg)) != NULL)
	        end++;
              else
                end = buflim;
	      while (beg > buf && beg[-1] != eol)
		--beg;
	    }
	  /* Successful, no backreferences encountered! */
	  if (!backref)
	    goto success;
	}
      else
	{
	  /* We are looking for the leftmost (then longest) exact match.
	     We will go through the outer loop only once.  */
	  beg = start_ptr;
	  end = buflim;
	}

      /* If we've made it to this point, this means DFA has seen
	 a probable match, and we need to run it through Regex. */
      best_match = end;
      best_len = 0;
      for (i = 0; i < pcount; i++)
	{
	  patterns[i].regexbuf.not_eol = 0;
	  if (0 <= (start = re_search (&(patterns[i].regexbuf),
				       buf, end - buf - 1,
				       beg - buf, end - beg - 1,
				       &(patterns[i].regs))))
	    {
	      len = patterns[i].regs.end[0] - start;
	      match = buf + start;
	      if (match > best_match)
		continue;
	      if (start_ptr && !match_words)
		goto assess_pattern_match;
	      if ((!match_lines && !match_words)
		  || (match_lines && len == end - beg - 1))
		{
		  match = beg;
		  len = end - beg;
		  goto assess_pattern_match;
		}
	      /* If -w, check if the match aligns with word boundaries.
		 We do this iteratively because:
		 (a) the line may contain more than one occurence of the
		 pattern, and
		 (b) Several alternatives in the pattern might be valid at a
		 given point, and we may need to consider a shorter one to
		 find a word boundary.  */
	      if (match_words)
		while (match <= best_match)
		  {
		    if ((match == buf || !WCHAR ((unsigned char) match[-1]))
			&& (len == end - beg - 1
			    || !WCHAR ((unsigned char) match[len])))
		      goto assess_pattern_match;
		    if (len > 0)
		      {
			/* Try a shorter length anchored at the same place. */
			--len;
			patterns[i].regexbuf.not_eol = 1;
			len = re_match (&(patterns[i].regexbuf),
					buf, match + len - beg, match - buf,
					&(patterns[i].regs));
		      }
		    if (len <= 0)
		      {
			/* Try looking further on. */
			if (match == end - 1)
			  break;
			match++;
			patterns[i].regexbuf.not_eol = 0;
			start = re_search (&(patterns[i].regexbuf),
					   buf, end - buf - 1,
					   match - buf, end - match - 1,
					   &(patterns[i].regs));
			if (start < 0)
			  break;
			len = patterns[i].regs.end[0] - start;
			match = buf + start;
		      }
		  } /* while (match <= best_match) */
	      continue;
	    assess_pattern_match:
	      if (!start_ptr)
		{
		  /* Good enough for a non-exact match.
		     No need to look at further patterns, if any.  */
		  beg = match;
		  goto success_in_len;
		}
	      if (match < best_match || (match == best_match && len > best_len))
		{
		  /* Best exact match:  leftmost, then longest.  */
		  best_match = match;
		  best_len = len;
		}
	    } /* if re_search >= 0 */
	} /* for Regex patterns.  */
	if (best_match < end)
	  {
	    /* We have found an exact match.  We were just
	       waiting for the best one (leftmost then longest).  */
	    beg = best_match;
	    len = best_len;
	    goto success_in_len;
	  }
    } /* for (beg = end ..) */

 failure:
  ret_val = -1;
  goto out;

 success:
  len = end - beg;
 success_in_len:
  *match_size = len;
  ret_val = beg - buf;
 out:
  return ret_val;
}

Building:src at:
/home/ubuntu/spr-fast/tests/corebench/grep/grep-case-8a025cf8-8f08d8e2/tempworkdir-l/srcMerged code building succ, going to invoke tester!
CondTester, Testing instance id 52:
//src_file:src/dfasearch.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); void* memset(void*, int, unsigned long); 
/* dfasearch.c - searching subroutines using dfa and regex for grep.
   Copyright 1992, 1998, 2000, 2007, 2009-2010 Free Software Foundation, Inc.

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 3, or (at your option)
   any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program; if not, write to the Free Software
   Foundation, Inc., 51 Franklin Street - Fifth Floor, Boston, MA
   02110-1301, USA.  */

/* Written August 1992 by Mike Haertel. */

#include <config.h>
#include "search.h"
#include "dfa.h"

/* For -w, we also consider _ to be word constituent.  */
#define WCHAR(C) (ISALNUM(C) || (C) == '_')

/* KWset compiled pattern.  For Ecompile and Gcompile, we compile
   a list of strings, at least one of which is known to occur in
   any string matching the regexp. */
static kwset_t kwset;

/* DFA compiled regexp. */
static struct dfa dfa;

/* The Regex compiled patterns.  */
static struct patterns
{
  /* Regex compiled regexp. */
  struct re_pattern_buffer regexbuf;
  struct re_registers regs; /* This is here on account of a BRAIN-DEAD
			       Q@#%!# library interface in regex.c.  */
} patterns0;

struct patterns *patterns;
size_t pcount;

void
dfaerror (char const *mesg)
{
  error (EXIT_TROUBLE, 0, "%s", mesg);

  /* notreached */
  /* Tell static analyzers that this function does not return.  */
  abort ();
}

/* Number of compiled fixed strings known to exactly match the regexp.
   If kwsexec returns < kwset_exact_matches, then we don't need to
   call the regexp matcher at all. */
static int kwset_exact_matches;

static char const *
kwsincr_case (const char *must)
{
  const char *buf;
  size_t n;

  n = strlen (must);
#ifdef MBS_SUPPORT
  if (match_icase && MB_CUR_MAX > 1)
    buf = mbtolower (must, &n);
  else
#endif
    buf = must;
  return kwsincr (kwset, buf, n);
}

/* If the DFA turns out to have some set of fixed strings one of
   which must occur in the match, then we build a kwset matcher
   to find those strings, and thus quickly filter out impossible
   matches. */
static void
kwsmusts (void)
{
  struct dfamust const *dm;
  char const *err;

  if (dfa.musts)
    {
      kwsinit (&kwset);
      /* First, we compile in the substrings known to be exact
	 matches.  The kwset matcher will return the index
	 of the matching string that it chooses. */
      for (dm = dfa.musts; dm; dm = dm->next)
	{
	  if (!dm->exact)
	    continue;
	  ++kwset_exact_matches;
	  if ((err = kwsincr_case (dm->must)) != NULL)
	    error (EXIT_TROUBLE, 0, "%s", err);
	}
      /* Now, we compile the substrings that will require
	 the use of the regexp matcher.  */
      for (dm = dfa.musts; dm; dm = dm->next)
	{
	  if (dm->exact)
	    continue;
	  if ((err = kwsincr_case (dm->must)) != NULL)
	    error (EXIT_TROUBLE, 0, "%s", err);
	}
      if ((err = kwsprep (kwset)) != NULL)
	error (EXIT_TROUBLE, 0, "%s", err);
    }
}

void
GEAcompile (char const *pattern, size_t size, reg_syntax_t syntax_bits)
{
  const char *err;
  const char *p, *sep;
  size_t total = size;
  char *motif;

  if (match_icase)
    syntax_bits |= RE_ICASE;
  re_set_syntax (syntax_bits);
  dfasyntax (syntax_bits, match_icase, eolbyte);

  /* For GNU regex compiler we have to pass the patterns separately to detect
     errors like "[\nallo\n]\n".  The patterns here are "[", "allo" and "]"
     GNU regex should have raise a syntax error.  The same for backref, where
     the backref should have been local to each pattern.  */
  p = pattern;
  do
    {
      size_t len;
      sep = memchr (p, '\n', total);
      if (sep)
	{
	  len = sep - p;
	  sep++;
	  total -= (len + 1);
	}
      else
	{
	  len = total;
	  total = 0;
	}

      patterns = realloc (patterns, (pcount + 1) * sizeof (*patterns));
      if (patterns == NULL)
	error (EXIT_TROUBLE, errno, _("memory exhausted"));
      patterns[pcount] = patterns0;

      if ((err = re_compile_pattern (p, len,
				    &(patterns[pcount].regexbuf))) != NULL)
	error (EXIT_TROUBLE, 0, "%s", err);
      pcount++;

      p = sep;
    } while (sep && total != 0);

  /* In the match_words and match_lines cases, we use a different pattern
     for the DFA matcher that will quickly throw out cases that won't work.
     Then if DFA succeeds we do some hairy stuff using the regex matcher
     to decide whether the match should really count. */
  if (match_words || match_lines)
    {
      static char const line_beg_no_bk[] = "^(";
      static char const line_end_no_bk[] = ")$";
      static char const word_beg_no_bk[] = "(^|[^[:alnum:]_])(";
      static char const word_end_no_bk[] = ")([^[:alnum:]_]|$)";
      static char const line_beg_bk[] = "^\\(";
      static char const line_end_bk[] = "\\)$";
      static char const word_beg_bk[] = "\\(^\\|[^[:alnum:]_]\\)\\(";
      static char const word_end_bk[] = "\\)\\([^[:alnum:]_]\\|$\\)";
      int bk = !(syntax_bits & RE_NO_BK_PARENS);
      char *n = xmalloc (sizeof word_beg_bk - 1 + size + sizeof word_end_bk);

      strcpy (n, match_lines ? (bk ? line_beg_bk : line_beg_no_bk)
			     : (bk ? word_beg_bk : word_beg_no_bk));
      total = strlen(n);
      memcpy (n + total, pattern, size);
      total += size;
      strcpy (n + total, match_lines ? (bk ? line_end_bk : line_end_no_bk)
				     : (bk ? word_end_bk : word_end_no_bk));
      total += strlen (n + total);
      pattern = motif = n;
      size = total;
    }
  else
    motif = NULL;

  dfacomp (pattern, size, &dfa, 1);
  kwsmusts ();

  free(motif);
}

size_t
EGexecute (char const *buf, size_t size, size_t *match_size,
	   char const *start_ptr)
{
  char const *buflim, *beg, *end, *match, *best_match, *mb_start;
  char eol = eolbyte;
  int backref, start, len, best_len;
  struct kwsmatch kwsm;
  size_t i, ret_val;
#ifdef MBS_SUPPORT
  if (MB_CUR_MAX > 1)
    {
      if (match_icase)
        {
          /* mbtolower adds a NUL byte at the end.  That will provide
	     space for the sentinel byte dfaexec may add.  */
          char *case_buf = mbtolower (buf, &size);
	  if (start_ptr)
	    start_ptr = case_buf + (start_ptr - buf);
          buf = case_buf;
        }
    }
#endif /* MBS_SUPPORT */

  mb_start = buf;
  buflim = buf + size;

  for (beg = end = buf; end < buflim; beg = end)
    {
      if (!start_ptr)
	{
	  /* We don't care about an exact match.  */
	  if (kwset)
	    {
	      /* Find a possible match using the KWset matcher. */
	      size_t offset = kwsexec (kwset, beg, buflim - beg, &kwsm);
	      if (offset == (size_t) -1)
		goto failure;
	      beg += offset;
	      /* Narrow down to the line containing the candidate, and
		 run it through DFA. */
	      if ((end = memchr(beg, eol, buflim - beg)) != NULL)
	        end++;
              else
                end = buflim;
	      match = beg;
	      while (beg > buf && beg[-1] != eol)
		--beg;
	      
//Patch 0:
if ((kwsm.index < kwset_exact_matches) && !(__is_neg(27, &(kwset_exact_matches), sizeof (kwset_exact_matches), &(kwsm.index), sizeof (kwsm.index), &(beg), sizeof (beg), &(buf), sizeof (buf), &(eol), sizeof (eol), &(match), sizeof (match), &(mb_start), sizeof (mb_start), &(buflim), sizeof (buflim), &(end), sizeof (end), &(backref), sizeof (backref), &(offset), sizeof (offset), &(kwset), sizeof (kwset), &(start_ptr), sizeof (start_ptr), &(size), sizeof (size), &(match_icase), sizeof (match_icase), &(best_match), sizeof (best_match), &(best_len), sizeof (best_len), &(eolbyte), sizeof (eolbyte), &(i), sizeof (i), &(pcount), sizeof (pcount), &(patterns), sizeof (patterns), &(start), sizeof (start), &(len), sizeof (len), &(match_words), sizeof (match_words), &(match_lines), sizeof (match_lines), &(ret_val), sizeof (ret_val), &(match_size), sizeof (match_size)))) {
    if (mb_start < beg)
        mb_start = beg;
    if ((__ctype_get_mb_cur_max()) == 1 || !is_mb_middle(&mb_start, match, buflim))
        goto success;
}

//CodeSeg 1:
	      if (dfaexec (&dfa, beg, (char *) end, 0, NULL, &backref) == NULL)
		continue;
	    }
	  else
	    {
	      /* No good fixed strings; start with DFA. */
	      char const *next_beg = dfaexec (&dfa, beg, (char *) buflim,
					      0, NULL, &backref);
	      if (next_beg == NULL)
		break;
	      /* Narrow down to the line we've found. */
	      beg = next_beg;
	      if ((end = memchr(beg, eol, buflim - beg)) != NULL)
	        end++;
              else
                end = buflim;
	      while (beg > buf && beg[-1] != eol)
		--beg;
	    }
	  /* Successful, no backreferences encountered! */
	  if (!backref)
	    goto success;
	}
      else
	{
	  /* We are looking for the leftmost (then longest) exact match.
	     We will go through the outer loop only once.  */
	  beg = start_ptr;
	  end = buflim;
	}

      /* If we've made it to this point, this means DFA has seen
	 a probable match, and we need to run it through Regex. */
      best_match = end;
      best_len = 0;
      for (i = 0; i < pcount; i++)
	{
	  patterns[i].regexbuf.not_eol = 0;
	  if (0 <= (start = re_search (&(patterns[i].regexbuf),
				       buf, end - buf - 1,
				       beg - buf, end - beg - 1,
				       &(patterns[i].regs))))
	    {
	      len = patterns[i].regs.end[0] - start;
	      match = buf + start;
	      if (match > best_match)
		continue;
	      if (start_ptr && !match_words)
		goto assess_pattern_match;
	      if ((!match_lines && !match_words)
		  || (match_lines && len == end - beg - 1))
		{
		  match = beg;
		  len = end - beg;
		  goto assess_pattern_match;
		}
	      /* If -w, check if the match aligns with word boundaries.
		 We do this iteratively because:
		 (a) the line may contain more than one occurence of the
		 pattern, and
		 (b) Several alternatives in the pattern might be valid at a
		 given point, and we may need to consider a shorter one to
		 find a word boundary.  */
	      if (match_words)
		while (match <= best_match)
		  {
		    if ((match == buf || !WCHAR ((unsigned char) match[-1]))
			&& (len == end - beg - 1
			    || !WCHAR ((unsigned char) match[len])))
		      goto assess_pattern_match;
		    if (len > 0)
		      {
			/* Try a shorter length anchored at the same place. */
			--len;
			patterns[i].regexbuf.not_eol = 1;
			len = re_match (&(patterns[i].regexbuf),
					buf, match + len - beg, match - buf,
					&(patterns[i].regs));
		      }
		    if (len <= 0)
		      {
			/* Try looking further on. */
			if (match == end - 1)
			  break;
			match++;
			patterns[i].regexbuf.not_eol = 0;
			start = re_search (&(patterns[i].regexbuf),
					   buf, end - buf - 1,
					   match - buf, end - match - 1,
					   &(patterns[i].regs));
			if (start < 0)
			  break;
			len = patterns[i].regs.end[0] - start;
			match = buf + start;
		      }
		  } /* while (match <= best_match) */
	      continue;
	    assess_pattern_match:
	      if (!start_ptr)
		{
		  /* Good enough for a non-exact match.
		     No need to look at further patterns, if any.  */
		  beg = match;
		  goto success_in_len;
		}
	      if (match < best_match || (match == best_match && len > best_len))
		{
		  /* Best exact match:  leftmost, then longest.  */
		  best_match = match;
		  best_len = len;
		}
	    } /* if re_search >= 0 */
	} /* for Regex patterns.  */
	if (best_match < end)
	  {
	    /* We have found an exact match.  We were just
	       waiting for the best one (leftmost then longest).  */
	    beg = best_match;
	    len = best_len;
	    goto success_in_len;
	  }
    } /* for (beg = end ..) */

 failure:
  ret_val = -1;
  goto out;

 success:
  len = end - beg;
 success_in_len:
  *match_size = len;
  ret_val = beg - buf;
 out:
  return ret_val;
}

Testing negative cases!
Testing 0 (with abstract condition) ENVIS_NEG
Iteration 0
Running test command:
/home/ubuntu/spr-fast/tools/grep-test.py /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-8a025cf8-8f08d8e2/tempworkdir-l/src /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-8a025cf8-8f08d8e2/tempworkdir-l/tests /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-8a025cf8-8f08d8e2/tempworkdir-l 0  > __res
Opening:/tmp/neg.tmp!
NegativeBRANCH RECORD/tmp/neg.tmp!
Not caught by the negative case, give up!
APPENDING TO ISNEG:/tmp/neg.tmp!
Running test command:
/home/ubuntu/spr-fast/tools/grep-test.py /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-8a025cf8-8f08d8e2/tempworkdir-l/src /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-8a025cf8-8f08d8e2/tempworkdir-l/tests /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-8a025cf8-8f08d8e2/tempworkdir-l 0  > __res
CondTester, Testing instance id 53:
//src_file:src/dfasearch.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); void* memset(void*, int, unsigned long); 
/* dfasearch.c - searching subroutines using dfa and regex for grep.
   Copyright 1992, 1998, 2000, 2007, 2009-2010 Free Software Foundation, Inc.

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 3, or (at your option)
   any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program; if not, write to the Free Software
   Foundation, Inc., 51 Franklin Street - Fifth Floor, Boston, MA
   02110-1301, USA.  */

/* Written August 1992 by Mike Haertel. */

#include <config.h>
#include "search.h"
#include "dfa.h"

/* For -w, we also consider _ to be word constituent.  */
#define WCHAR(C) (ISALNUM(C) || (C) == '_')

/* KWset compiled pattern.  For Ecompile and Gcompile, we compile
   a list of strings, at least one of which is known to occur in
   any string matching the regexp. */
static kwset_t kwset;

/* DFA compiled regexp. */
static struct dfa dfa;

/* The Regex compiled patterns.  */
static struct patterns
{
  /* Regex compiled regexp. */
  struct re_pattern_buffer regexbuf;
  struct re_registers regs; /* This is here on account of a BRAIN-DEAD
			       Q@#%!# library interface in regex.c.  */
} patterns0;

struct patterns *patterns;
size_t pcount;

void
dfaerror (char const *mesg)
{
  error (EXIT_TROUBLE, 0, "%s", mesg);

  /* notreached */
  /* Tell static analyzers that this function does not return.  */
  abort ();
}

/* Number of compiled fixed strings known to exactly match the regexp.
   If kwsexec returns < kwset_exact_matches, then we don't need to
   call the regexp matcher at all. */
static int kwset_exact_matches;

static char const *
kwsincr_case (const char *must)
{
  const char *buf;
  size_t n;

  n = strlen (must);
#ifdef MBS_SUPPORT
  if (match_icase && MB_CUR_MAX > 1)
    buf = mbtolower (must, &n);
  else
#endif
    buf = must;
  return kwsincr (kwset, buf, n);
}

/* If the DFA turns out to have some set of fixed strings one of
   which must occur in the match, then we build a kwset matcher
   to find those strings, and thus quickly filter out impossible
   matches. */
static void
kwsmusts (void)
{
  struct dfamust const *dm;
  char const *err;

  if (dfa.musts)
    {
      kwsinit (&kwset);
      /* First, we compile in the substrings known to be exact
	 matches.  The kwset matcher will return the index
	 of the matching string that it chooses. */
      for (dm = dfa.musts; dm; dm = dm->next)
	{
	  if (!dm->exact)
	    continue;
	  ++kwset_exact_matches;
	  if ((err = kwsincr_case (dm->must)) != NULL)
	    error (EXIT_TROUBLE, 0, "%s", err);
	}
      /* Now, we compile the substrings that will require
	 the use of the regexp matcher.  */
      for (dm = dfa.musts; dm; dm = dm->next)
	{
	  if (dm->exact)
	    continue;
	  if ((err = kwsincr_case (dm->must)) != NULL)
	    error (EXIT_TROUBLE, 0, "%s", err);
	}
      if ((err = kwsprep (kwset)) != NULL)
	error (EXIT_TROUBLE, 0, "%s", err);
    }
}

void
GEAcompile (char const *pattern, size_t size, reg_syntax_t syntax_bits)
{
  const char *err;
  const char *p, *sep;
  size_t total = size;
  char *motif;

  if (match_icase)
    syntax_bits |= RE_ICASE;
  re_set_syntax (syntax_bits);
  dfasyntax (syntax_bits, match_icase, eolbyte);

  /* For GNU regex compiler we have to pass the patterns separately to detect
     errors like "[\nallo\n]\n".  The patterns here are "[", "allo" and "]"
     GNU regex should have raise a syntax error.  The same for backref, where
     the backref should have been local to each pattern.  */
  p = pattern;
  do
    {
      size_t len;
      sep = memchr (p, '\n', total);
      if (sep)
	{
	  len = sep - p;
	  sep++;
	  total -= (len + 1);
	}
      else
	{
	  len = total;
	  total = 0;
	}

      patterns = realloc (patterns, (pcount + 1) * sizeof (*patterns));
      if (patterns == NULL)
	error (EXIT_TROUBLE, errno, _("memory exhausted"));
      patterns[pcount] = patterns0;

      if ((err = re_compile_pattern (p, len,
				    &(patterns[pcount].regexbuf))) != NULL)
	error (EXIT_TROUBLE, 0, "%s", err);
      pcount++;

      p = sep;
    } while (sep && total != 0);

  /* In the match_words and match_lines cases, we use a different pattern
     for the DFA matcher that will quickly throw out cases that won't work.
     Then if DFA succeeds we do some hairy stuff using the regex matcher
     to decide whether the match should really count. */
  if (match_words || match_lines)
    {
      static char const line_beg_no_bk[] = "^(";
      static char const line_end_no_bk[] = ")$";
      static char const word_beg_no_bk[] = "(^|[^[:alnum:]_])(";
      static char const word_end_no_bk[] = ")([^[:alnum:]_]|$)";
      static char const line_beg_bk[] = "^\\(";
      static char const line_end_bk[] = "\\)$";
      static char const word_beg_bk[] = "\\(^\\|[^[:alnum:]_]\\)\\(";
      static char const word_end_bk[] = "\\)\\([^[:alnum:]_]\\|$\\)";
      int bk = !(syntax_bits & RE_NO_BK_PARENS);
      char *n = xmalloc (sizeof word_beg_bk - 1 + size + sizeof word_end_bk);

      strcpy (n, match_lines ? (bk ? line_beg_bk : line_beg_no_bk)
			     : (bk ? word_beg_bk : word_beg_no_bk));
      total = strlen(n);
      memcpy (n + total, pattern, size);
      total += size;
      strcpy (n + total, match_lines ? (bk ? line_end_bk : line_end_no_bk)
				     : (bk ? word_end_bk : word_end_no_bk));
      total += strlen (n + total);
      pattern = motif = n;
      size = total;
    }
  else
    motif = NULL;

  dfacomp (pattern, size, &dfa, 1);
  kwsmusts ();

  free(motif);
}

size_t
EGexecute (char const *buf, size_t size, size_t *match_size,
	   char const *start_ptr)
{
  char const *buflim, *beg, *end, *match, *best_match, *mb_start;
  char eol = eolbyte;
  int backref, start, len, best_len;
  struct kwsmatch kwsm;
  size_t i, ret_val;
#ifdef MBS_SUPPORT
  if (MB_CUR_MAX > 1)
    {
      if (match_icase)
        {
          /* mbtolower adds a NUL byte at the end.  That will provide
	     space for the sentinel byte dfaexec may add.  */
          char *case_buf = mbtolower (buf, &size);
	  if (start_ptr)
	    start_ptr = case_buf + (start_ptr - buf);
          buf = case_buf;
        }
    }
#endif /* MBS_SUPPORT */

  mb_start = buf;
  buflim = buf + size;

  for (beg = end = buf; end < buflim; beg = end)
    {
      if (!start_ptr)
	{
	  /* We don't care about an exact match.  */
	  if (kwset)
	    {
	      /* Find a possible match using the KWset matcher. */
	      size_t offset = kwsexec (kwset, beg, buflim - beg, &kwsm);
	      if (offset == (size_t) -1)
		goto failure;
	      beg += offset;
	      /* Narrow down to the line containing the candidate, and
		 run it through DFA. */
	      if ((end = memchr(beg, eol, buflim - beg)) != NULL)
	        end++;
              else
                end = buflim;
	      match = beg;
	      while (beg > buf && beg[-1] != eol)
		--beg;
	      
//Patch 0:
if ((kwsm.index < kwset_exact_matches) || (__is_neg(27, &(kwset_exact_matches), sizeof (kwset_exact_matches), &(kwsm.index), sizeof (kwsm.index), &(beg), sizeof (beg), &(buf), sizeof (buf), &(eol), sizeof (eol), &(match), sizeof (match), &(mb_start), sizeof (mb_start), &(buflim), sizeof (buflim), &(end), sizeof (end), &(backref), sizeof (backref), &(offset), sizeof (offset), &(kwset), sizeof (kwset), &(start_ptr), sizeof (start_ptr), &(size), sizeof (size), &(match_icase), sizeof (match_icase), &(best_match), sizeof (best_match), &(best_len), sizeof (best_len), &(eolbyte), sizeof (eolbyte), &(i), sizeof (i), &(pcount), sizeof (pcount), &(patterns), sizeof (patterns), &(start), sizeof (start), &(len), sizeof (len), &(match_words), sizeof (match_words), &(match_lines), sizeof (match_lines), &(ret_val), sizeof (ret_val), &(match_size), sizeof (match_size)))) {
    if (mb_start < beg)
        mb_start = beg;
    if ((__ctype_get_mb_cur_max()) == 1 || !is_mb_middle(&mb_start, match, buflim))
        goto success;
}

//CodeSeg 1:
	      if (dfaexec (&dfa, beg, (char *) end, 0, NULL, &backref) == NULL)
		continue;
	    }
	  else
	    {
	      /* No good fixed strings; start with DFA. */
	      char const *next_beg = dfaexec (&dfa, beg, (char *) buflim,
					      0, NULL, &backref);
	      if (next_beg == NULL)
		break;
	      /* Narrow down to the line we've found. */
	      beg = next_beg;
	      if ((end = memchr(beg, eol, buflim - beg)) != NULL)
	        end++;
              else
                end = buflim;
	      while (beg > buf && beg[-1] != eol)
		--beg;
	    }
	  /* Successful, no backreferences encountered! */
	  if (!backref)
	    goto success;
	}
      else
	{
	  /* We are looking for the leftmost (then longest) exact match.
	     We will go through the outer loop only once.  */
	  beg = start_ptr;
	  end = buflim;
	}

      /* If we've made it to this point, this means DFA has seen
	 a probable match, and we need to run it through Regex. */
      best_match = end;
      best_len = 0;
      for (i = 0; i < pcount; i++)
	{
	  patterns[i].regexbuf.not_eol = 0;
	  if (0 <= (start = re_search (&(patterns[i].regexbuf),
				       buf, end - buf - 1,
				       beg - buf, end - beg - 1,
				       &(patterns[i].regs))))
	    {
	      len = patterns[i].regs.end[0] - start;
	      match = buf + start;
	      if (match > best_match)
		continue;
	      if (start_ptr && !match_words)
		goto assess_pattern_match;
	      if ((!match_lines && !match_words)
		  || (match_lines && len == end - beg - 1))
		{
		  match = beg;
		  len = end - beg;
		  goto assess_pattern_match;
		}
	      /* If -w, check if the match aligns with word boundaries.
		 We do this iteratively because:
		 (a) the line may contain more than one occurence of the
		 pattern, and
		 (b) Several alternatives in the pattern might be valid at a
		 given point, and we may need to consider a shorter one to
		 find a word boundary.  */
	      if (match_words)
		while (match <= best_match)
		  {
		    if ((match == buf || !WCHAR ((unsigned char) match[-1]))
			&& (len == end - beg - 1
			    || !WCHAR ((unsigned char) match[len])))
		      goto assess_pattern_match;
		    if (len > 0)
		      {
			/* Try a shorter length anchored at the same place. */
			--len;
			patterns[i].regexbuf.not_eol = 1;
			len = re_match (&(patterns[i].regexbuf),
					buf, match + len - beg, match - buf,
					&(patterns[i].regs));
		      }
		    if (len <= 0)
		      {
			/* Try looking further on. */
			if (match == end - 1)
			  break;
			match++;
			patterns[i].regexbuf.not_eol = 0;
			start = re_search (&(patterns[i].regexbuf),
					   buf, end - buf - 1,
					   match - buf, end - match - 1,
					   &(patterns[i].regs));
			if (start < 0)
			  break;
			len = patterns[i].regs.end[0] - start;
			match = buf + start;
		      }
		  } /* while (match <= best_match) */
	      continue;
	    assess_pattern_match:
	      if (!start_ptr)
		{
		  /* Good enough for a non-exact match.
		     No need to look at further patterns, if any.  */
		  beg = match;
		  goto success_in_len;
		}
	      if (match < best_match || (match == best_match && len > best_len))
		{
		  /* Best exact match:  leftmost, then longest.  */
		  best_match = match;
		  best_len = len;
		}
	    } /* if re_search >= 0 */
	} /* for Regex patterns.  */
	if (best_match < end)
	  {
	    /* We have found an exact match.  We were just
	       waiting for the best one (leftmost then longest).  */
	    beg = best_match;
	    len = best_len;
	    goto success_in_len;
	  }
    } /* for (beg = end ..) */

 failure:
  ret_val = -1;
  goto out;

 success:
  len = end - beg;
 success_in_len:
  *match_size = len;
  ret_val = beg - buf;
 out:
  return ret_val;
}

Testing negative cases!
Testing 0 (with abstract condition) ENVIS_NEG
Iteration 0
Running test command:
/home/ubuntu/spr-fast/tools/grep-test.py /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-8a025cf8-8f08d8e2/tempworkdir-l/src /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-8a025cf8-8f08d8e2/tempworkdir-l/tests /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-8a025cf8-8f08d8e2/tempworkdir-l 0  > __res
Opening:/tmp/neg.tmp!
NegativeBRANCH RECORD/tmp/neg.tmp!
APPENDING TO ISNEG:/tmp/neg.tmp!
Branch 0: 0
Iteration 1
Running test command:
/home/ubuntu/spr-fast/tools/grep-test.py /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-8a025cf8-8f08d8e2/tempworkdir-l/src /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-8a025cf8-8f08d8e2/tempworkdir-l/tests /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-8a025cf8-8f08d8e2/tempworkdir-l 0  > __res
Opening:/tmp/neg.tmp!
NegativeBRANCH RECORD/tmp/neg.tmp!
APPENDING TO ISNEG:/tmp/neg.tmp!
Branch 0: 1
Passed in iteration!
Passed Negative Cases wiht CondTestder!
Testing positive cases!
Running test command:
/home/ubuntu/spr-fast/tools/grep-test.py /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-8a025cf8-8f08d8e2/tempworkdir-l/src /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-8a025cf8-8f08d8e2/tempworkdir-l/tests /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-8a025cf8-8f08d8e2/tempworkdir-l 11  > __res
Running test command:
/home/ubuntu/spr-fast/tools/grep-test.py /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-8a025cf8-8f08d8e2/tempworkdir-l/src /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-8a025cf8-8f08d8e2/tempworkdir-l/tests /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-8a025cf8-8f08d8e2/tempworkdir-l 14  > __res
Running test command:
/home/ubuntu/spr-fast/tools/grep-test.py /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-8a025cf8-8f08d8e2/tempworkdir-l/src /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-8a025cf8-8f08d8e2/tempworkdir-l/tests /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-8a025cf8-8f08d8e2/tempworkdir-l 17  > __res
Running test command:
/home/ubuntu/spr-fast/tools/grep-test.py /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-8a025cf8-8f08d8e2/tempworkdir-l/src /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-8a025cf8-8f08d8e2/tempworkdir-l/tests /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-8a025cf8-8f08d8e2/tempworkdir-l 22  > __res
Passed Positive Cases
Collect values for post processing!
WRITING TO ISNEG:/tmp/neg.tmp!
Running test command:
/home/ubuntu/spr-fast/tools/grep-test.py /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-8a025cf8-8f08d8e2/tempworkdir-l/src /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-8a025cf8-8f08d8e2/tempworkdir-l/tests /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-8a025cf8-8f08d8e2/tempworkdir-l 0  > __res
Running test command:
/home/ubuntu/spr-fast/tools/grep-test.py /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-8a025cf8-8f08d8e2/tempworkdir-l/src /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-8a025cf8-8f08d8e2/tempworkdir-l/tests /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-8a025cf8-8f08d8e2/tempworkdir-l 11  > __res
Running test command:
/home/ubuntu/spr-fast/tools/grep-test.py /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-8a025cf8-8f08d8e2/tempworkdir-l/src /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-8a025cf8-8f08d8e2/tempworkdir-l/tests /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-8a025cf8-8f08d8e2/tempworkdir-l 14  > __res
Running test command:
/home/ubuntu/spr-fast/tools/grep-test.py /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-8a025cf8-8f08d8e2/tempworkdir-l/src /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-8a025cf8-8f08d8e2/tempworkdir-l/tests /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-8a025cf8-8f08d8e2/tempworkdir-l 17  > __res
Running test command:
/home/ubuntu/spr-fast/tools/grep-test.py /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-8a025cf8-8f08d8e2/tempworkdir-l/src /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-8a025cf8-8f08d8e2/tempworkdir-l/tests /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-8a025cf8-8f08d8e2/tempworkdir-l 22  > __res
Passed!
CondTester, Postprocessing instance id 53:
//src_file:src/dfasearch.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); void* memset(void*, int, unsigned long); 
/* dfasearch.c - searching subroutines using dfa and regex for grep.
   Copyright 1992, 1998, 2000, 2007, 2009-2010 Free Software Foundation, Inc.

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 3, or (at your option)
   any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program; if not, write to the Free Software
   Foundation, Inc., 51 Franklin Street - Fifth Floor, Boston, MA
   02110-1301, USA.  */

/* Written August 1992 by Mike Haertel. */

#include <config.h>
#include "search.h"
#include "dfa.h"

/* For -w, we also consider _ to be word constituent.  */
#define WCHAR(C) (ISALNUM(C) || (C) == '_')

/* KWset compiled pattern.  For Ecompile and Gcompile, we compile
   a list of strings, at least one of which is known to occur in
   any string matching the regexp. */
static kwset_t kwset;

/* DFA compiled regexp. */
static struct dfa dfa;

/* The Regex compiled patterns.  */
static struct patterns
{
  /* Regex compiled regexp. */
  struct re_pattern_buffer regexbuf;
  struct re_registers regs; /* This is here on account of a BRAIN-DEAD
			       Q@#%!# library interface in regex.c.  */
} patterns0;

struct patterns *patterns;
size_t pcount;

void
dfaerror (char const *mesg)
{
  error (EXIT_TROUBLE, 0, "%s", mesg);

  /* notreached */
  /* Tell static analyzers that this function does not return.  */
  abort ();
}

/* Number of compiled fixed strings known to exactly match the regexp.
   If kwsexec returns < kwset_exact_matches, then we don't need to
   call the regexp matcher at all. */
static int kwset_exact_matches;

static char const *
kwsincr_case (const char *must)
{
  const char *buf;
  size_t n;

  n = strlen (must);
#ifdef MBS_SUPPORT
  if (match_icase && MB_CUR_MAX > 1)
    buf = mbtolower (must, &n);
  else
#endif
    buf = must;
  return kwsincr (kwset, buf, n);
}

/* If the DFA turns out to have some set of fixed strings one of
   which must occur in the match, then we build a kwset matcher
   to find those strings, and thus quickly filter out impossible
   matches. */
static void
kwsmusts (void)
{
  struct dfamust const *dm;
  char const *err;

  if (dfa.musts)
    {
      kwsinit (&kwset);
      /* First, we compile in the substrings known to be exact
	 matches.  The kwset matcher will return the index
	 of the matching string that it chooses. */
      for (dm = dfa.musts; dm; dm = dm->next)
	{
	  if (!dm->exact)
	    continue;
	  ++kwset_exact_matches;
	  if ((err = kwsincr_case (dm->must)) != NULL)
	    error (EXIT_TROUBLE, 0, "%s", err);
	}
      /* Now, we compile the substrings that will require
	 the use of the regexp matcher.  */
      for (dm = dfa.musts; dm; dm = dm->next)
	{
	  if (dm->exact)
	    continue;
	  if ((err = kwsincr_case (dm->must)) != NULL)
	    error (EXIT_TROUBLE, 0, "%s", err);
	}
      if ((err = kwsprep (kwset)) != NULL)
	error (EXIT_TROUBLE, 0, "%s", err);
    }
}

void
GEAcompile (char const *pattern, size_t size, reg_syntax_t syntax_bits)
{
  const char *err;
  const char *p, *sep;
  size_t total = size;
  char *motif;

  if (match_icase)
    syntax_bits |= RE_ICASE;
  re_set_syntax (syntax_bits);
  dfasyntax (syntax_bits, match_icase, eolbyte);

  /* For GNU regex compiler we have to pass the patterns separately to detect
     errors like "[\nallo\n]\n".  The patterns here are "[", "allo" and "]"
     GNU regex should have raise a syntax error.  The same for backref, where
     the backref should have been local to each pattern.  */
  p = pattern;
  do
    {
      size_t len;
      sep = memchr (p, '\n', total);
      if (sep)
	{
	  len = sep - p;
	  sep++;
	  total -= (len + 1);
	}
      else
	{
	  len = total;
	  total = 0;
	}

      patterns = realloc (patterns, (pcount + 1) * sizeof (*patterns));
      if (patterns == NULL)
	error (EXIT_TROUBLE, errno, _("memory exhausted"));
      patterns[pcount] = patterns0;

      if ((err = re_compile_pattern (p, len,
				    &(patterns[pcount].regexbuf))) != NULL)
	error (EXIT_TROUBLE, 0, "%s", err);
      pcount++;

      p = sep;
    } while (sep && total != 0);

  /* In the match_words and match_lines cases, we use a different pattern
     for the DFA matcher that will quickly throw out cases that won't work.
     Then if DFA succeeds we do some hairy stuff using the regex matcher
     to decide whether the match should really count. */
  if (match_words || match_lines)
    {
      static char const line_beg_no_bk[] = "^(";
      static char const line_end_no_bk[] = ")$";
      static char const word_beg_no_bk[] = "(^|[^[:alnum:]_])(";
      static char const word_end_no_bk[] = ")([^[:alnum:]_]|$)";
      static char const line_beg_bk[] = "^\\(";
      static char const line_end_bk[] = "\\)$";
      static char const word_beg_bk[] = "\\(^\\|[^[:alnum:]_]\\)\\(";
      static char const word_end_bk[] = "\\)\\([^[:alnum:]_]\\|$\\)";
      int bk = !(syntax_bits & RE_NO_BK_PARENS);
      char *n = xmalloc (sizeof word_beg_bk - 1 + size + sizeof word_end_bk);

      strcpy (n, match_lines ? (bk ? line_beg_bk : line_beg_no_bk)
			     : (bk ? word_beg_bk : word_beg_no_bk));
      total = strlen(n);
      memcpy (n + total, pattern, size);
      total += size;
      strcpy (n + total, match_lines ? (bk ? line_end_bk : line_end_no_bk)
				     : (bk ? word_end_bk : word_end_no_bk));
      total += strlen (n + total);
      pattern = motif = n;
      size = total;
    }
  else
    motif = NULL;

  dfacomp (pattern, size, &dfa, 1);
  kwsmusts ();

  free(motif);
}

size_t
EGexecute (char const *buf, size_t size, size_t *match_size,
	   char const *start_ptr)
{
  char const *buflim, *beg, *end, *match, *best_match, *mb_start;
  char eol = eolbyte;
  int backref, start, len, best_len;
  struct kwsmatch kwsm;
  size_t i, ret_val;
#ifdef MBS_SUPPORT
  if (MB_CUR_MAX > 1)
    {
      if (match_icase)
        {
          /* mbtolower adds a NUL byte at the end.  That will provide
	     space for the sentinel byte dfaexec may add.  */
          char *case_buf = mbtolower (buf, &size);
	  if (start_ptr)
	    start_ptr = case_buf + (start_ptr - buf);
          buf = case_buf;
        }
    }
#endif /* MBS_SUPPORT */

  mb_start = buf;
  buflim = buf + size;

  for (beg = end = buf; end < buflim; beg = end)
    {
      if (!start_ptr)
	{
	  /* We don't care about an exact match.  */
	  if (kwset)
	    {
	      /* Find a possible match using the KWset matcher. */
	      size_t offset = kwsexec (kwset, beg, buflim - beg, &kwsm);
	      if (offset == (size_t) -1)
		goto failure;
	      beg += offset;
	      /* Narrow down to the line containing the candidate, and
		 run it through DFA. */
	      if ((end = memchr(beg, eol, buflim - beg)) != NULL)
	        end++;
              else
                end = buflim;
	      match = beg;
	      while (beg > buf && beg[-1] != eol)
		--beg;
	      
//Patch 0:
if ((kwsm.index < kwset_exact_matches) || (__is_neg(27, &(kwset_exact_matches), sizeof (kwset_exact_matches), &(kwsm.index), sizeof (kwsm.index), &(beg), sizeof (beg), &(buf), sizeof (buf), &(eol), sizeof (eol), &(match), sizeof (match), &(mb_start), sizeof (mb_start), &(buflim), sizeof (buflim), &(end), sizeof (end), &(backref), sizeof (backref), &(offset), sizeof (offset), &(kwset), sizeof (kwset), &(start_ptr), sizeof (start_ptr), &(size), sizeof (size), &(match_icase), sizeof (match_icase), &(best_match), sizeof (best_match), &(best_len), sizeof (best_len), &(eolbyte), sizeof (eolbyte), &(i), sizeof (i), &(pcount), sizeof (pcount), &(patterns), sizeof (patterns), &(start), sizeof (start), &(len), sizeof (len), &(match_words), sizeof (match_words), &(match_lines), sizeof (match_lines), &(ret_val), sizeof (ret_val), &(match_size), sizeof (match_size)))) {
    if (mb_start < beg)
        mb_start = beg;
    if ((__ctype_get_mb_cur_max()) == 1 || !is_mb_middle(&mb_start, match, buflim))
        goto success;
}

//CodeSeg 1:
	      if (dfaexec (&dfa, beg, (char *) end, 0, NULL, &backref) == NULL)
		continue;
	    }
	  else
	    {
	      /* No good fixed strings; start with DFA. */
	      char const *next_beg = dfaexec (&dfa, beg, (char *) buflim,
					      0, NULL, &backref);
	      if (next_beg == NULL)
		break;
	      /* Narrow down to the line we've found. */
	      beg = next_beg;
	      if ((end = memchr(beg, eol, buflim - beg)) != NULL)
	        end++;
              else
                end = buflim;
	      while (beg > buf && beg[-1] != eol)
		--beg;
	    }
	  /* Successful, no backreferences encountered! */
	  if (!backref)
	    goto success;
	}
      else
	{
	  /* We are looking for the leftmost (then longest) exact match.
	     We will go through the outer loop only once.  */
	  beg = start_ptr;
	  end = buflim;
	}

      /* If we've made it to this point, this means DFA has seen
	 a probable match, and we need to run it through Regex. */
      best_match = end;
      best_len = 0;
      for (i = 0; i < pcount; i++)
	{
	  patterns[i].regexbuf.not_eol = 0;
	  if (0 <= (start = re_search (&(patterns[i].regexbuf),
				       buf, end - buf - 1,
				       beg - buf, end - beg - 1,
				       &(patterns[i].regs))))
	    {
	      len = patterns[i].regs.end[0] - start;
	      match = buf + start;
	      if (match > best_match)
		continue;
	      if (start_ptr && !match_words)
		goto assess_pattern_match;
	      if ((!match_lines && !match_words)
		  || (match_lines && len == end - beg - 1))
		{
		  match = beg;
		  len = end - beg;
		  goto assess_pattern_match;
		}
	      /* If -w, check if the match aligns with word boundaries.
		 We do this iteratively because:
		 (a) the line may contain more than one occurence of the
		 pattern, and
		 (b) Several alternatives in the pattern might be valid at a
		 given point, and we may need to consider a shorter one to
		 find a word boundary.  */
	      if (match_words)
		while (match <= best_match)
		  {
		    if ((match == buf || !WCHAR ((unsigned char) match[-1]))
			&& (len == end - beg - 1
			    || !WCHAR ((unsigned char) match[len])))
		      goto assess_pattern_match;
		    if (len > 0)
		      {
			/* Try a shorter length anchored at the same place. */
			--len;
			patterns[i].regexbuf.not_eol = 1;
			len = re_match (&(patterns[i].regexbuf),
					buf, match + len - beg, match - buf,
					&(patterns[i].regs));
		      }
		    if (len <= 0)
		      {
			/* Try looking further on. */
			if (match == end - 1)
			  break;
			match++;
			patterns[i].regexbuf.not_eol = 0;
			start = re_search (&(patterns[i].regexbuf),
					   buf, end - buf - 1,
					   match - buf, end - match - 1,
					   &(patterns[i].regs));
			if (start < 0)
			  break;
			len = patterns[i].regs.end[0] - start;
			match = buf + start;
		      }
		  } /* while (match <= best_match) */
	      continue;
	    assess_pattern_match:
	      if (!start_ptr)
		{
		  /* Good enough for a non-exact match.
		     No need to look at further patterns, if any.  */
		  beg = match;
		  goto success_in_len;
		}
	      if (match < best_match || (match == best_match && len > best_len))
		{
		  /* Best exact match:  leftmost, then longest.  */
		  best_match = match;
		  best_len = len;
		}
	    } /* if re_search >= 0 */
	} /* for Regex patterns.  */
	if (best_match < end)
	  {
	    /* We have found an exact match.  We were just
	       waiting for the best one (leftmost then longest).  */
	    beg = best_match;
	    len = best_len;
	    goto success_in_len;
	  }
    } /* for (beg = end ..) */

 failure:
  ret_val = -1;
  goto out;

 success:
  len = end - beg;
 success_in_len:
  *match_size = len;
  ret_val = beg - buf;
 out:
  return ret_val;
}

Trying a synthesis expr 1
Building:src at:
/home/ubuntu/spr-fast/tests/corebench/grep/grep-case-8a025cf8-8f08d8e2/tempworkdir-l/srcVerifing Negative cases!
Running test command:
/home/ubuntu/spr-fast/tools/grep-test.py /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-8a025cf8-8f08d8e2/tempworkdir-l/src /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-8a025cf8-8f08d8e2/tempworkdir-l/tests /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-8a025cf8-8f08d8e2/tempworkdir-l 0  > __res
Verifying positive cases
Running test command:
/home/ubuntu/spr-fast/tools/grep-test.py /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-8a025cf8-8f08d8e2/tempworkdir-l/src /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-8a025cf8-8f08d8e2/tempworkdir-l/tests /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-8a025cf8-8f08d8e2/tempworkdir-l 11  > __res
Failed positive case 11
Not passed!
Trying a synthesis expr offset == 0
Building:src at:
/home/ubuntu/spr-fast/tests/corebench/grep/grep-case-8a025cf8-8f08d8e2/tempworkdir-l/srcVerifing Negative cases!
Running test command:
/home/ubuntu/spr-fast/tools/grep-test.py /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-8a025cf8-8f08d8e2/tempworkdir-l/src /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-8a025cf8-8f08d8e2/tempworkdir-l/tests /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-8a025cf8-8f08d8e2/tempworkdir-l 0  > __res
Verifying positive cases
Running test command:
/home/ubuntu/spr-fast/tools/grep-test.py /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-8a025cf8-8f08d8e2/tempworkdir-l/src /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-8a025cf8-8f08d8e2/tempworkdir-l/tests /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-8a025cf8-8f08d8e2/tempworkdir-l 11  > __res
Running test command:
/home/ubuntu/spr-fast/tools/grep-test.py /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-8a025cf8-8f08d8e2/tempworkdir-l/src /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-8a025cf8-8f08d8e2/tempworkdir-l/tests /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-8a025cf8-8f08d8e2/tempworkdir-l 14  > __res
Running test command:
/home/ubuntu/spr-fast/tools/grep-test.py /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-8a025cf8-8f08d8e2/tempworkdir-l/src /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-8a025cf8-8f08d8e2/tempworkdir-l/tests /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-8a025cf8-8f08d8e2/tempworkdir-l 17  > __res
Running test command:
/home/ubuntu/spr-fast/tools/grep-test.py /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-8a025cf8-8f08d8e2/tempworkdir-l/src /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-8a025cf8-8f08d8e2/tempworkdir-l/tests /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-8a025cf8-8f08d8e2/tempworkdir-l 22  > __res
Passed Positive Cases
Passed!
Passed with updated best score 19999947.000000
a batched test job starts!
Building merged code:
src_file: src/dfasearch.c
full src: int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); void* memset(void*, int, unsigned long); 
/* dfasearch.c - searching subroutines using dfa and regex for grep.
   Copyright 1992, 1998, 2000, 2007, 2009-2010 Free Software Foundation, Inc.

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 3, or (at your option)
   any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program; if not, write to the Free Software
   Foundation, Inc., 51 Franklin Street - Fifth Floor, Boston, MA
   02110-1301, USA.  */

/* Written August 1992 by Mike Haertel. */

#include <config.h>
#include "search.h"
#include "dfa.h"

/* For -w, we also consider _ to be word constituent.  */
#define WCHAR(C) (ISALNUM(C) || (C) == '_')

/* KWset compiled pattern.  For Ecompile and Gcompile, we compile
   a list of strings, at least one of which is known to occur in
   any string matching the regexp. */
static kwset_t kwset;

/* DFA compiled regexp. */
static struct dfa dfa;

/* The Regex compiled patterns.  */
static struct patterns
{
  /* Regex compiled regexp. */
  struct re_pattern_buffer regexbuf;
  struct re_registers regs; /* This is here on account of a BRAIN-DEAD
			       Q@#%!# library interface in regex.c.  */
} patterns0;

struct patterns *patterns;
size_t pcount;

void
dfaerror (char const *mesg)
{
  error (EXIT_TROUBLE, 0, "%s", mesg);

  /* notreached */
  /* Tell static analyzers that this function does not return.  */
  abort ();
}

/* Number of compiled fixed strings known to exactly match the regexp.
   If kwsexec returns < kwset_exact_matches, then we don't need to
   call the regexp matcher at all. */
static int kwset_exact_matches;

static char const *
kwsincr_case (const char *must)
{
  const char *buf;
  size_t n;

  n = strlen (must);
#ifdef MBS_SUPPORT
  if (match_icase && MB_CUR_MAX > 1)
    buf = mbtolower (must, &n);
  else
#endif
    buf = must;
  return kwsincr (kwset, buf, n);
}

/* If the DFA turns out to have some set of fixed strings one of
   which must occur in the match, then we build a kwset matcher
   to find those strings, and thus quickly filter out impossible
   matches. */
static void
kwsmusts (void)
{
  struct dfamust const *dm;
  char const *err;

  if (dfa.musts)
    {
      kwsinit (&kwset);
      /* First, we compile in the substrings known to be exact
	 matches.  The kwset matcher will return the index
	 of the matching string that it chooses. */
      for (dm = dfa.musts; dm; dm = dm->next)
	{
	  if (!dm->exact)
	    continue;
	  ++kwset_exact_matches;
	  if ((err = kwsincr_case (dm->must)) != NULL)
	    error (EXIT_TROUBLE, 0, "%s", err);
	}
      /* Now, we compile the substrings that will require
	 the use of the regexp matcher.  */
      for (dm = dfa.musts; dm; dm = dm->next)
	{
	  if (dm->exact)
	    continue;
	  if ((err = kwsincr_case (dm->must)) != NULL)
	    error (EXIT_TROUBLE, 0, "%s", err);
	}
      if ((err = kwsprep (kwset)) != NULL)
	error (EXIT_TROUBLE, 0, "%s", err);
    }
}

void
GEAcompile (char const *pattern, size_t size, reg_syntax_t syntax_bits)
{
  const char *err;
  const char *p, *sep;
  size_t total = size;
  char *motif;

  if (match_icase)
    syntax_bits |= RE_ICASE;
  re_set_syntax (syntax_bits);
  dfasyntax (syntax_bits, match_icase, eolbyte);

  /* For GNU regex compiler we have to pass the patterns separately to detect
     errors like "[\nallo\n]\n".  The patterns here are "[", "allo" and "]"
     GNU regex should have raise a syntax error.  The same for backref, where
     the backref should have been local to each pattern.  */
  p = pattern;
  do
    {
      size_t len;
      sep = memchr (p, '\n', total);
      if (sep)
	{
	  len = sep - p;
	  sep++;
	  total -= (len + 1);
	}
      else
	{
	  len = total;
	  total = 0;
	}

      patterns = realloc (patterns, (pcount + 1) * sizeof (*patterns));
      if (patterns == NULL)
	error (EXIT_TROUBLE, errno, _("memory exhausted"));
      patterns[pcount] = patterns0;

      if ((err = re_compile_pattern (p, len,
				    &(patterns[pcount].regexbuf))) != NULL)
	error (EXIT_TROUBLE, 0, "%s", err);
      pcount++;

      p = sep;
    } while (sep && total != 0);

  /* In the match_words and match_lines cases, we use a different pattern
     for the DFA matcher that will quickly throw out cases that won't work.
     Then if DFA succeeds we do some hairy stuff using the regex matcher
     to decide whether the match should really count. */
  if (match_words || match_lines)
    {
      static char const line_beg_no_bk[] = "^(";
      static char const line_end_no_bk[] = ")$";
      static char const word_beg_no_bk[] = "(^|[^[:alnum:]_])(";
      static char const word_end_no_bk[] = ")([^[:alnum:]_]|$)";
      static char const line_beg_bk[] = "^\\(";
      static char const line_end_bk[] = "\\)$";
      static char const word_beg_bk[] = "\\(^\\|[^[:alnum:]_]\\)\\(";
      static char const word_end_bk[] = "\\)\\([^[:alnum:]_]\\|$\\)";
      int bk = !(syntax_bits & RE_NO_BK_PARENS);
      char *n = xmalloc (sizeof word_beg_bk - 1 + size + sizeof word_end_bk);

      strcpy (n, match_lines ? (bk ? line_beg_bk : line_beg_no_bk)
			     : (bk ? word_beg_bk : word_beg_no_bk));
      total = strlen(n);
      memcpy (n + total, pattern, size);
      total += size;
      strcpy (n + total, match_lines ? (bk ? line_end_bk : line_end_no_bk)
				     : (bk ? word_end_bk : word_end_no_bk));
      total += strlen (n + total);
      pattern = motif = n;
      size = total;
    }
  else
    motif = NULL;

  dfacomp (pattern, size, &dfa, 1);
  kwsmusts ();

  free(motif);
}

size_t
EGexecute (char const *buf, size_t size, size_t *match_size,
	   char const *start_ptr)
{
  char const *buflim, *beg, *end, *match, *best_match, *mb_start;
  char eol = eolbyte;
  int backref, start, len, best_len;
  struct kwsmatch kwsm;
  size_t i, ret_val;
#ifdef MBS_SUPPORT
  if (MB_CUR_MAX > 1)
    {
      if (match_icase)
        {
          /* mbtolower adds a NUL byte at the end.  That will provide
	     space for the sentinel byte dfaexec may add.  */
          char *case_buf = mbtolower (buf, &size);
	  if (start_ptr)
	    start_ptr = case_buf + (start_ptr - buf);
          buf = case_buf;
        }
    }
#endif /* MBS_SUPPORT */

  mb_start = buf;
  buflim = buf + size;

  for (beg = end = buf; end < buflim; beg = end)
    {
      if (!start_ptr)
	{
	  /* We don't care about an exact match.  */
	  if (kwset)
	    {
	      /* Find a possible match using the KWset matcher. */
	      size_t offset = kwsexec (kwset, beg, buflim - beg, &kwsm);
	      if (offset == (size_t) -1)
		goto failure;
	      beg += offset;
	      /* Narrow down to the line containing the candidate, and
		 run it through DFA. */
	      if ((end = memchr(beg, eol, buflim - beg)) != NULL)
	        end++;
              else
                end = buflim;
	      match = beg;
	      while (beg > buf && beg[-1] != eol)
		--beg;
	      if (kwsm.index < kwset_exact_matches)
                {
#ifdef MBS_SUPPORT
                  if (mb_start < beg)
                    mb_start = beg;
                  if (MB_CUR_MAX == 1 || !is_mb_middle (&mb_start, match, buflim))
#endif
                    goto success;
                }
	      //prophet generated patch
	      if (__get_mutant()==0) {
	      if ((dfaexec(&dfa, beg, (char *)end, 0, ((void *)0), &backref) == ((void *)0)) && !(__is_neg(54, &(beg), sizeof (beg), &(end), sizeof (end), &(backref), sizeof (backref), &(buflim), sizeof (buflim), &(match), sizeof (match), &(mb_start), sizeof (mb_start), &(kwset_exact_matches), sizeof (kwset_exact_matches), &(buf), sizeof (buf), &(eol), sizeof (eol), &(offset), sizeof (offset), &(kwset), sizeof (kwset), &(start_ptr), sizeof (start_ptr), &(size), sizeof (size), &(best_match), sizeof (best_match), &(best_len), sizeof (best_len), &(i), sizeof (i), &(pcount), sizeof (pcount), &(patterns), sizeof (patterns), &(start), sizeof (start), &(len), sizeof (len), &(match_icase), sizeof (match_icase), &(match_words), sizeof (match_words), &(match_lines), sizeof (match_lines), &(eolbyte), sizeof (eolbyte), &(ret_val), sizeof (ret_val), &(match_size), sizeof (match_size), &(dfa.charclasses), sizeof (dfa.charclasses), &(dfa.cindex), sizeof (dfa.cindex), &(dfa.calloc), sizeof (dfa.calloc), &(dfa.tokens), sizeof (dfa.tokens), &(dfa.tindex), sizeof (dfa.tindex), &(dfa.talloc), sizeof (dfa.talloc), &(dfa.depth), sizeof (dfa.depth), &(dfa.nleaves), sizeof (dfa.nleaves), &(dfa.nregexps), sizeof (dfa.nregexps), &(dfa.mb_cur_max), sizeof (dfa.mb_cur_max), &(dfa.nmultibyte_prop), sizeof (dfa.nmultibyte_prop), &(dfa.multibyte_prop), sizeof (dfa.multibyte_prop), &(dfa.mbcsets), sizeof (dfa.mbcsets), &(dfa.nmbcsets), sizeof (dfa.nmbcsets), &(dfa.mbcsets_alloc), sizeof (dfa.mbcsets_alloc), &(dfa.states), sizeof (dfa.states), &(dfa.sindex), sizeof (dfa.sindex), &(dfa.salloc), sizeof (dfa.salloc), &(dfa.follows), sizeof (dfa.follows), &(dfa.searchflag), sizeof (dfa.searchflag), &(dfa.tralloc), sizeof (dfa.tralloc), &(dfa.trcount), sizeof (dfa.trcount), &(dfa.trans), sizeof (dfa.trans), &(dfa.realtrans), sizeof (dfa.realtrans), &(dfa.fails), sizeof (dfa.fails), &(dfa.success), sizeof (dfa.success), &(dfa.newlines), sizeof (dfa.newlines), &(dfa.musts), sizeof (dfa.musts))))
	          continue;
	      }
	      else if (__get_mutant()==1) {
	      if ((dfaexec(&dfa, beg, (char *)end, 0, ((void *)0), &backref) == ((void *)0)) || (__is_neg(54, &(beg), sizeof (beg), &(end), sizeof (end), &(backref), sizeof (backref), &(buflim), sizeof (buflim), &(match), sizeof (match), &(mb_start), sizeof (mb_start), &(kwset_exact_matches), sizeof (kwset_exact_matches), &(buf), sizeof (buf), &(eol), sizeof (eol), &(offset), sizeof (offset), &(kwset), sizeof (kwset), &(start_ptr), sizeof (start_ptr), &(size), sizeof (size), &(best_match), sizeof (best_match), &(best_len), sizeof (best_len), &(i), sizeof (i), &(pcount), sizeof (pcount), &(patterns), sizeof (patterns), &(start), sizeof (start), &(len), sizeof (len), &(match_icase), sizeof (match_icase), &(match_words), sizeof (match_words), &(match_lines), sizeof (match_lines), &(eolbyte), sizeof (eolbyte), &(ret_val), sizeof (ret_val), &(match_size), sizeof (match_size), &(dfa.charclasses), sizeof (dfa.charclasses), &(dfa.cindex), sizeof (dfa.cindex), &(dfa.calloc), sizeof (dfa.calloc), &(dfa.tokens), sizeof (dfa.tokens), &(dfa.tindex), sizeof (dfa.tindex), &(dfa.talloc), sizeof (dfa.talloc), &(dfa.depth), sizeof (dfa.depth), &(dfa.nleaves), sizeof (dfa.nleaves), &(dfa.nregexps), sizeof (dfa.nregexps), &(dfa.mb_cur_max), sizeof (dfa.mb_cur_max), &(dfa.nmultibyte_prop), sizeof (dfa.nmultibyte_prop), &(dfa.multibyte_prop), sizeof (dfa.multibyte_prop), &(dfa.mbcsets), sizeof (dfa.mbcsets), &(dfa.nmbcsets), sizeof (dfa.nmbcsets), &(dfa.mbcsets_alloc), sizeof (dfa.mbcsets_alloc), &(dfa.states), sizeof (dfa.states), &(dfa.sindex), sizeof (dfa.sindex), &(dfa.salloc), sizeof (dfa.salloc), &(dfa.follows), sizeof (dfa.follows), &(dfa.searchflag), sizeof (dfa.searchflag), &(dfa.tralloc), sizeof (dfa.tralloc), &(dfa.trcount), sizeof (dfa.trcount), &(dfa.trans), sizeof (dfa.trans), &(dfa.realtrans), sizeof (dfa.realtrans), &(dfa.fails), sizeof (dfa.fails), &(dfa.success), sizeof (dfa.success), &(dfa.newlines), sizeof (dfa.newlines), &(dfa.musts), sizeof (dfa.musts))))
	          continue;
	      }
	    }
	  else
	    {
	      /* No good fixed strings; start with DFA. */
	      char const *next_beg = dfaexec (&dfa, beg, (char *) buflim,
					      0, NULL, &backref);
	      if (next_beg == NULL)
		break;
	      /* Narrow down to the line we've found. */
	      beg = next_beg;
	      if ((end = memchr(beg, eol, buflim - beg)) != NULL)
	        end++;
              else
                end = buflim;
	      while (beg > buf && beg[-1] != eol)
		--beg;
	    }
	  /* Successful, no backreferences encountered! */
	  if (!backref)
	    goto success;
	}
      else
	{
	  /* We are looking for the leftmost (then longest) exact match.
	     We will go through the outer loop only once.  */
	  beg = start_ptr;
	  end = buflim;
	}

      /* If we've made it to this point, this means DFA has seen
	 a probable match, and we need to run it through Regex. */
      best_match = end;
      best_len = 0;
      for (i = 0; i < pcount; i++)
	{
	  patterns[i].regexbuf.not_eol = 0;
	  if (0 <= (start = re_search (&(patterns[i].regexbuf),
				       buf, end - buf - 1,
				       beg - buf, end - beg - 1,
				       &(patterns[i].regs))))
	    {
	      len = patterns[i].regs.end[0] - start;
	      match = buf + start;
	      if (match > best_match)
		continue;
	      if (start_ptr && !match_words)
		goto assess_pattern_match;
	      if ((!match_lines && !match_words)
		  || (match_lines && len == end - beg - 1))
		{
		  match = beg;
		  len = end - beg;
		  goto assess_pattern_match;
		}
	      /* If -w, check if the match aligns with word boundaries.
		 We do this iteratively because:
		 (a) the line may contain more than one occurence of the
		 pattern, and
		 (b) Several alternatives in the pattern might be valid at a
		 given point, and we may need to consider a shorter one to
		 find a word boundary.  */
	      if (match_words)
		while (match <= best_match)
		  {
		    if ((match == buf || !WCHAR ((unsigned char) match[-1]))
			&& (len == end - beg - 1
			    || !WCHAR ((unsigned char) match[len])))
		      goto assess_pattern_match;
		    if (len > 0)
		      {
			/* Try a shorter length anchored at the same place. */
			--len;
			patterns[i].regexbuf.not_eol = 1;
			len = re_match (&(patterns[i].regexbuf),
					buf, match + len - beg, match - buf,
					&(patterns[i].regs));
		      }
		    if (len <= 0)
		      {
			/* Try looking further on. */
			if (match == end - 1)
			  break;
			match++;
			patterns[i].regexbuf.not_eol = 0;
			start = re_search (&(patterns[i].regexbuf),
					   buf, end - buf - 1,
					   match - buf, end - match - 1,
					   &(patterns[i].regs));
			if (start < 0)
			  break;
			len = patterns[i].regs.end[0] - start;
			match = buf + start;
		      }
		  } /* while (match <= best_match) */
	      continue;
	    assess_pattern_match:
	      if (!start_ptr)
		{
		  /* Good enough for a non-exact match.
		     No need to look at further patterns, if any.  */
		  beg = match;
		  goto success_in_len;
		}
	      if (match < best_match || (match == best_match && len > best_len))
		{
		  /* Best exact match:  leftmost, then longest.  */
		  best_match = match;
		  best_len = len;
		}
	    } /* if re_search >= 0 */
	} /* for Regex patterns.  */
	if (best_match < end)
	  {
	    /* We have found an exact match.  We were just
	       waiting for the best one (leftmost then longest).  */
	    beg = best_match;
	    len = best_len;
	    goto success_in_len;
	  }
    } /* for (beg = end ..) */

 failure:
  ret_val = -1;
  goto out;

 success:
  len = end - beg;
 success_in_len:
  *match_size = len;
  ret_val = beg - buf;
 out:
  return ret_val;
}

Building:src at:
/home/ubuntu/spr-fast/tests/corebench/grep/grep-case-8a025cf8-8f08d8e2/tempworkdir-l/srcMerged code building succ, going to invoke tester!
CondTester, Testing instance id 47:
//src_file:src/dfasearch.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); void* memset(void*, int, unsigned long); 
/* dfasearch.c - searching subroutines using dfa and regex for grep.
   Copyright 1992, 1998, 2000, 2007, 2009-2010 Free Software Foundation, Inc.

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 3, or (at your option)
   any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program; if not, write to the Free Software
   Foundation, Inc., 51 Franklin Street - Fifth Floor, Boston, MA
   02110-1301, USA.  */

/* Written August 1992 by Mike Haertel. */

#include <config.h>
#include "search.h"
#include "dfa.h"

/* For -w, we also consider _ to be word constituent.  */
#define WCHAR(C) (ISALNUM(C) || (C) == '_')

/* KWset compiled pattern.  For Ecompile and Gcompile, we compile
   a list of strings, at least one of which is known to occur in
   any string matching the regexp. */
static kwset_t kwset;

/* DFA compiled regexp. */
static struct dfa dfa;

/* The Regex compiled patterns.  */
static struct patterns
{
  /* Regex compiled regexp. */
  struct re_pattern_buffer regexbuf;
  struct re_registers regs; /* This is here on account of a BRAIN-DEAD
			       Q@#%!# library interface in regex.c.  */
} patterns0;

struct patterns *patterns;
size_t pcount;

void
dfaerror (char const *mesg)
{
  error (EXIT_TROUBLE, 0, "%s", mesg);

  /* notreached */
  /* Tell static analyzers that this function does not return.  */
  abort ();
}

/* Number of compiled fixed strings known to exactly match the regexp.
   If kwsexec returns < kwset_exact_matches, then we don't need to
   call the regexp matcher at all. */
static int kwset_exact_matches;

static char const *
kwsincr_case (const char *must)
{
  const char *buf;
  size_t n;

  n = strlen (must);
#ifdef MBS_SUPPORT
  if (match_icase && MB_CUR_MAX > 1)
    buf = mbtolower (must, &n);
  else
#endif
    buf = must;
  return kwsincr (kwset, buf, n);
}

/* If the DFA turns out to have some set of fixed strings one of
   which must occur in the match, then we build a kwset matcher
   to find those strings, and thus quickly filter out impossible
   matches. */
static void
kwsmusts (void)
{
  struct dfamust const *dm;
  char const *err;

  if (dfa.musts)
    {
      kwsinit (&kwset);
      /* First, we compile in the substrings known to be exact
	 matches.  The kwset matcher will return the index
	 of the matching string that it chooses. */
      for (dm = dfa.musts; dm; dm = dm->next)
	{
	  if (!dm->exact)
	    continue;
	  ++kwset_exact_matches;
	  if ((err = kwsincr_case (dm->must)) != NULL)
	    error (EXIT_TROUBLE, 0, "%s", err);
	}
      /* Now, we compile the substrings that will require
	 the use of the regexp matcher.  */
      for (dm = dfa.musts; dm; dm = dm->next)
	{
	  if (dm->exact)
	    continue;
	  if ((err = kwsincr_case (dm->must)) != NULL)
	    error (EXIT_TROUBLE, 0, "%s", err);
	}
      if ((err = kwsprep (kwset)) != NULL)
	error (EXIT_TROUBLE, 0, "%s", err);
    }
}

void
GEAcompile (char const *pattern, size_t size, reg_syntax_t syntax_bits)
{
  const char *err;
  const char *p, *sep;
  size_t total = size;
  char *motif;

  if (match_icase)
    syntax_bits |= RE_ICASE;
  re_set_syntax (syntax_bits);
  dfasyntax (syntax_bits, match_icase, eolbyte);

  /* For GNU regex compiler we have to pass the patterns separately to detect
     errors like "[\nallo\n]\n".  The patterns here are "[", "allo" and "]"
     GNU regex should have raise a syntax error.  The same for backref, where
     the backref should have been local to each pattern.  */
  p = pattern;
  do
    {
      size_t len;
      sep = memchr (p, '\n', total);
      if (sep)
	{
	  len = sep - p;
	  sep++;
	  total -= (len + 1);
	}
      else
	{
	  len = total;
	  total = 0;
	}

      patterns = realloc (patterns, (pcount + 1) * sizeof (*patterns));
      if (patterns == NULL)
	error (EXIT_TROUBLE, errno, _("memory exhausted"));
      patterns[pcount] = patterns0;

      if ((err = re_compile_pattern (p, len,
				    &(patterns[pcount].regexbuf))) != NULL)
	error (EXIT_TROUBLE, 0, "%s", err);
      pcount++;

      p = sep;
    } while (sep && total != 0);

  /* In the match_words and match_lines cases, we use a different pattern
     for the DFA matcher that will quickly throw out cases that won't work.
     Then if DFA succeeds we do some hairy stuff using the regex matcher
     to decide whether the match should really count. */
  if (match_words || match_lines)
    {
      static char const line_beg_no_bk[] = "^(";
      static char const line_end_no_bk[] = ")$";
      static char const word_beg_no_bk[] = "(^|[^[:alnum:]_])(";
      static char const word_end_no_bk[] = ")([^[:alnum:]_]|$)";
      static char const line_beg_bk[] = "^\\(";
      static char const line_end_bk[] = "\\)$";
      static char const word_beg_bk[] = "\\(^\\|[^[:alnum:]_]\\)\\(";
      static char const word_end_bk[] = "\\)\\([^[:alnum:]_]\\|$\\)";
      int bk = !(syntax_bits & RE_NO_BK_PARENS);
      char *n = xmalloc (sizeof word_beg_bk - 1 + size + sizeof word_end_bk);

      strcpy (n, match_lines ? (bk ? line_beg_bk : line_beg_no_bk)
			     : (bk ? word_beg_bk : word_beg_no_bk));
      total = strlen(n);
      memcpy (n + total, pattern, size);
      total += size;
      strcpy (n + total, match_lines ? (bk ? line_end_bk : line_end_no_bk)
				     : (bk ? word_end_bk : word_end_no_bk));
      total += strlen (n + total);
      pattern = motif = n;
      size = total;
    }
  else
    motif = NULL;

  dfacomp (pattern, size, &dfa, 1);
  kwsmusts ();

  free(motif);
}

size_t
EGexecute (char const *buf, size_t size, size_t *match_size,
	   char const *start_ptr)
{
  char const *buflim, *beg, *end, *match, *best_match, *mb_start;
  char eol = eolbyte;
  int backref, start, len, best_len;
  struct kwsmatch kwsm;
  size_t i, ret_val;
#ifdef MBS_SUPPORT
  if (MB_CUR_MAX > 1)
    {
      if (match_icase)
        {
          /* mbtolower adds a NUL byte at the end.  That will provide
	     space for the sentinel byte dfaexec may add.  */
          char *case_buf = mbtolower (buf, &size);
	  if (start_ptr)
	    start_ptr = case_buf + (start_ptr - buf);
          buf = case_buf;
        }
    }
#endif /* MBS_SUPPORT */

  mb_start = buf;
  buflim = buf + size;

  for (beg = end = buf; end < buflim; beg = end)
    {
      if (!start_ptr)
	{
	  /* We don't care about an exact match.  */
	  if (kwset)
	    {
	      /* Find a possible match using the KWset matcher. */
	      size_t offset = kwsexec (kwset, beg, buflim - beg, &kwsm);
	      if (offset == (size_t) -1)
		goto failure;
	      beg += offset;
	      /* Narrow down to the line containing the candidate, and
		 run it through DFA. */
	      if ((end = memchr(beg, eol, buflim - beg)) != NULL)
	        end++;
              else
                end = buflim;
	      match = beg;
	      while (beg > buf && beg[-1] != eol)
		--beg;
	      if (kwsm.index < kwset_exact_matches)
                {
#ifdef MBS_SUPPORT
                  if (mb_start < beg)
                    mb_start = beg;
                  if (MB_CUR_MAX == 1 || !is_mb_middle (&mb_start, match, buflim))
#endif
                    goto success;
                }
	      
//Patch 0:
if ((dfaexec(&dfa, beg, (char *)end, 0, ((void *)0), &backref) == ((void *)0)) && !(__is_neg(54, &(beg), sizeof (beg), &(end), sizeof (end), &(backref), sizeof (backref), &(buflim), sizeof (buflim), &(match), sizeof (match), &(mb_start), sizeof (mb_start), &(kwset_exact_matches), sizeof (kwset_exact_matches), &(buf), sizeof (buf), &(eol), sizeof (eol), &(offset), sizeof (offset), &(kwset), sizeof (kwset), &(start_ptr), sizeof (start_ptr), &(size), sizeof (size), &(best_match), sizeof (best_match), &(best_len), sizeof (best_len), &(i), sizeof (i), &(pcount), sizeof (pcount), &(patterns), sizeof (patterns), &(start), sizeof (start), &(len), sizeof (len), &(match_icase), sizeof (match_icase), &(match_words), sizeof (match_words), &(match_lines), sizeof (match_lines), &(eolbyte), sizeof (eolbyte), &(ret_val), sizeof (ret_val), &(match_size), sizeof (match_size), &(dfa.charclasses), sizeof (dfa.charclasses), &(dfa.cindex), sizeof (dfa.cindex), &(dfa.calloc), sizeof (dfa.calloc), &(dfa.tokens), sizeof (dfa.tokens), &(dfa.tindex), sizeof (dfa.tindex), &(dfa.talloc), sizeof (dfa.talloc), &(dfa.depth), sizeof (dfa.depth), &(dfa.nleaves), sizeof (dfa.nleaves), &(dfa.nregexps), sizeof (dfa.nregexps), &(dfa.mb_cur_max), sizeof (dfa.mb_cur_max), &(dfa.nmultibyte_prop), sizeof (dfa.nmultibyte_prop), &(dfa.multibyte_prop), sizeof (dfa.multibyte_prop), &(dfa.mbcsets), sizeof (dfa.mbcsets), &(dfa.nmbcsets), sizeof (dfa.nmbcsets), &(dfa.mbcsets_alloc), sizeof (dfa.mbcsets_alloc), &(dfa.states), sizeof (dfa.states), &(dfa.sindex), sizeof (dfa.sindex), &(dfa.salloc), sizeof (dfa.salloc), &(dfa.follows), sizeof (dfa.follows), &(dfa.searchflag), sizeof (dfa.searchflag), &(dfa.tralloc), sizeof (dfa.tralloc), &(dfa.trcount), sizeof (dfa.trcount), &(dfa.trans), sizeof (dfa.trans), &(dfa.realtrans), sizeof (dfa.realtrans), &(dfa.fails), sizeof (dfa.fails), &(dfa.success), sizeof (dfa.success), &(dfa.newlines), sizeof (dfa.newlines), &(dfa.musts), sizeof (dfa.musts))))
    continue;

//CodeSeg 1:
	    }
	  else
	    {
	      /* No good fixed strings; start with DFA. */
	      char const *next_beg = dfaexec (&dfa, beg, (char *) buflim,
					      0, NULL, &backref);
	      if (next_beg == NULL)
		break;
	      /* Narrow down to the line we've found. */
	      beg = next_beg;
	      if ((end = memchr(beg, eol, buflim - beg)) != NULL)
	        end++;
              else
                end = buflim;
	      while (beg > buf && beg[-1] != eol)
		--beg;
	    }
	  /* Successful, no backreferences encountered! */
	  if (!backref)
	    goto success;
	}
      else
	{
	  /* We are looking for the leftmost (then longest) exact match.
	     We will go through the outer loop only once.  */
	  beg = start_ptr;
	  end = buflim;
	}

      /* If we've made it to this point, this means DFA has seen
	 a probable match, and we need to run it through Regex. */
      best_match = end;
      best_len = 0;
      for (i = 0; i < pcount; i++)
	{
	  patterns[i].regexbuf.not_eol = 0;
	  if (0 <= (start = re_search (&(patterns[i].regexbuf),
				       buf, end - buf - 1,
				       beg - buf, end - beg - 1,
				       &(patterns[i].regs))))
	    {
	      len = patterns[i].regs.end[0] - start;
	      match = buf + start;
	      if (match > best_match)
		continue;
	      if (start_ptr && !match_words)
		goto assess_pattern_match;
	      if ((!match_lines && !match_words)
		  || (match_lines && len == end - beg - 1))
		{
		  match = beg;
		  len = end - beg;
		  goto assess_pattern_match;
		}
	      /* If -w, check if the match aligns with word boundaries.
		 We do this iteratively because:
		 (a) the line may contain more than one occurence of the
		 pattern, and
		 (b) Several alternatives in the pattern might be valid at a
		 given point, and we may need to consider a shorter one to
		 find a word boundary.  */
	      if (match_words)
		while (match <= best_match)
		  {
		    if ((match == buf || !WCHAR ((unsigned char) match[-1]))
			&& (len == end - beg - 1
			    || !WCHAR ((unsigned char) match[len])))
		      goto assess_pattern_match;
		    if (len > 0)
		      {
			/* Try a shorter length anchored at the same place. */
			--len;
			patterns[i].regexbuf.not_eol = 1;
			len = re_match (&(patterns[i].regexbuf),
					buf, match + len - beg, match - buf,
					&(patterns[i].regs));
		      }
		    if (len <= 0)
		      {
			/* Try looking further on. */
			if (match == end - 1)
			  break;
			match++;
			patterns[i].regexbuf.not_eol = 0;
			start = re_search (&(patterns[i].regexbuf),
					   buf, end - buf - 1,
					   match - buf, end - match - 1,
					   &(patterns[i].regs));
			if (start < 0)
			  break;
			len = patterns[i].regs.end[0] - start;
			match = buf + start;
		      }
		  } /* while (match <= best_match) */
	      continue;
	    assess_pattern_match:
	      if (!start_ptr)
		{
		  /* Good enough for a non-exact match.
		     No need to look at further patterns, if any.  */
		  beg = match;
		  goto success_in_len;
		}
	      if (match < best_match || (match == best_match && len > best_len))
		{
		  /* Best exact match:  leftmost, then longest.  */
		  best_match = match;
		  best_len = len;
		}
	    } /* if re_search >= 0 */
	} /* for Regex patterns.  */
	if (best_match < end)
	  {
	    /* We have found an exact match.  We were just
	       waiting for the best one (leftmost then longest).  */
	    beg = best_match;
	    len = best_len;
	    goto success_in_len;
	  }
    } /* for (beg = end ..) */

 failure:
  ret_val = -1;
  goto out;

 success:
  len = end - beg;
 success_in_len:
  *match_size = len;
  ret_val = beg - buf;
 out:
  return ret_val;
}

Testing negative cases!
Testing 0 (with abstract condition) ENVIS_NEG
Iteration 0
Running test command:
/home/ubuntu/spr-fast/tools/grep-test.py /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-8a025cf8-8f08d8e2/tempworkdir-l/src /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-8a025cf8-8f08d8e2/tempworkdir-l/tests /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-8a025cf8-8f08d8e2/tempworkdir-l 0  > __res
Opening:/tmp/neg.tmp!
NegativeBRANCH RECORD/tmp/neg.tmp!
Not caught by the negative case, give up!
APPENDING TO ISNEG:/tmp/neg.tmp!
Running test command:
/home/ubuntu/spr-fast/tools/grep-test.py /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-8a025cf8-8f08d8e2/tempworkdir-l/src /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-8a025cf8-8f08d8e2/tempworkdir-l/tests /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-8a025cf8-8f08d8e2/tempworkdir-l 0  > __res
CondTester, Testing instance id 48:
//src_file:src/dfasearch.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); void* memset(void*, int, unsigned long); 
/* dfasearch.c - searching subroutines using dfa and regex for grep.
   Copyright 1992, 1998, 2000, 2007, 2009-2010 Free Software Foundation, Inc.

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 3, or (at your option)
   any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program; if not, write to the Free Software
   Foundation, Inc., 51 Franklin Street - Fifth Floor, Boston, MA
   02110-1301, USA.  */

/* Written August 1992 by Mike Haertel. */

#include <config.h>
#include "search.h"
#include "dfa.h"

/* For -w, we also consider _ to be word constituent.  */
#define WCHAR(C) (ISALNUM(C) || (C) == '_')

/* KWset compiled pattern.  For Ecompile and Gcompile, we compile
   a list of strings, at least one of which is known to occur in
   any string matching the regexp. */
static kwset_t kwset;

/* DFA compiled regexp. */
static struct dfa dfa;

/* The Regex compiled patterns.  */
static struct patterns
{
  /* Regex compiled regexp. */
  struct re_pattern_buffer regexbuf;
  struct re_registers regs; /* This is here on account of a BRAIN-DEAD
			       Q@#%!# library interface in regex.c.  */
} patterns0;

struct patterns *patterns;
size_t pcount;

void
dfaerror (char const *mesg)
{
  error (EXIT_TROUBLE, 0, "%s", mesg);

  /* notreached */
  /* Tell static analyzers that this function does not return.  */
  abort ();
}

/* Number of compiled fixed strings known to exactly match the regexp.
   If kwsexec returns < kwset_exact_matches, then we don't need to
   call the regexp matcher at all. */
static int kwset_exact_matches;

static char const *
kwsincr_case (const char *must)
{
  const char *buf;
  size_t n;

  n = strlen (must);
#ifdef MBS_SUPPORT
  if (match_icase && MB_CUR_MAX > 1)
    buf = mbtolower (must, &n);
  else
#endif
    buf = must;
  return kwsincr (kwset, buf, n);
}

/* If the DFA turns out to have some set of fixed strings one of
   which must occur in the match, then we build a kwset matcher
   to find those strings, and thus quickly filter out impossible
   matches. */
static void
kwsmusts (void)
{
  struct dfamust const *dm;
  char const *err;

  if (dfa.musts)
    {
      kwsinit (&kwset);
      /* First, we compile in the substrings known to be exact
	 matches.  The kwset matcher will return the index
	 of the matching string that it chooses. */
      for (dm = dfa.musts; dm; dm = dm->next)
	{
	  if (!dm->exact)
	    continue;
	  ++kwset_exact_matches;
	  if ((err = kwsincr_case (dm->must)) != NULL)
	    error (EXIT_TROUBLE, 0, "%s", err);
	}
      /* Now, we compile the substrings that will require
	 the use of the regexp matcher.  */
      for (dm = dfa.musts; dm; dm = dm->next)
	{
	  if (dm->exact)
	    continue;
	  if ((err = kwsincr_case (dm->must)) != NULL)
	    error (EXIT_TROUBLE, 0, "%s", err);
	}
      if ((err = kwsprep (kwset)) != NULL)
	error (EXIT_TROUBLE, 0, "%s", err);
    }
}

void
GEAcompile (char const *pattern, size_t size, reg_syntax_t syntax_bits)
{
  const char *err;
  const char *p, *sep;
  size_t total = size;
  char *motif;

  if (match_icase)
    syntax_bits |= RE_ICASE;
  re_set_syntax (syntax_bits);
  dfasyntax (syntax_bits, match_icase, eolbyte);

  /* For GNU regex compiler we have to pass the patterns separately to detect
     errors like "[\nallo\n]\n".  The patterns here are "[", "allo" and "]"
     GNU regex should have raise a syntax error.  The same for backref, where
     the backref should have been local to each pattern.  */
  p = pattern;
  do
    {
      size_t len;
      sep = memchr (p, '\n', total);
      if (sep)
	{
	  len = sep - p;
	  sep++;
	  total -= (len + 1);
	}
      else
	{
	  len = total;
	  total = 0;
	}

      patterns = realloc (patterns, (pcount + 1) * sizeof (*patterns));
      if (patterns == NULL)
	error (EXIT_TROUBLE, errno, _("memory exhausted"));
      patterns[pcount] = patterns0;

      if ((err = re_compile_pattern (p, len,
				    &(patterns[pcount].regexbuf))) != NULL)
	error (EXIT_TROUBLE, 0, "%s", err);
      pcount++;

      p = sep;
    } while (sep && total != 0);

  /* In the match_words and match_lines cases, we use a different pattern
     for the DFA matcher that will quickly throw out cases that won't work.
     Then if DFA succeeds we do some hairy stuff using the regex matcher
     to decide whether the match should really count. */
  if (match_words || match_lines)
    {
      static char const line_beg_no_bk[] = "^(";
      static char const line_end_no_bk[] = ")$";
      static char const word_beg_no_bk[] = "(^|[^[:alnum:]_])(";
      static char const word_end_no_bk[] = ")([^[:alnum:]_]|$)";
      static char const line_beg_bk[] = "^\\(";
      static char const line_end_bk[] = "\\)$";
      static char const word_beg_bk[] = "\\(^\\|[^[:alnum:]_]\\)\\(";
      static char const word_end_bk[] = "\\)\\([^[:alnum:]_]\\|$\\)";
      int bk = !(syntax_bits & RE_NO_BK_PARENS);
      char *n = xmalloc (sizeof word_beg_bk - 1 + size + sizeof word_end_bk);

      strcpy (n, match_lines ? (bk ? line_beg_bk : line_beg_no_bk)
			     : (bk ? word_beg_bk : word_beg_no_bk));
      total = strlen(n);
      memcpy (n + total, pattern, size);
      total += size;
      strcpy (n + total, match_lines ? (bk ? line_end_bk : line_end_no_bk)
				     : (bk ? word_end_bk : word_end_no_bk));
      total += strlen (n + total);
      pattern = motif = n;
      size = total;
    }
  else
    motif = NULL;

  dfacomp (pattern, size, &dfa, 1);
  kwsmusts ();

  free(motif);
}

size_t
EGexecute (char const *buf, size_t size, size_t *match_size,
	   char const *start_ptr)
{
  char const *buflim, *beg, *end, *match, *best_match, *mb_start;
  char eol = eolbyte;
  int backref, start, len, best_len;
  struct kwsmatch kwsm;
  size_t i, ret_val;
#ifdef MBS_SUPPORT
  if (MB_CUR_MAX > 1)
    {
      if (match_icase)
        {
          /* mbtolower adds a NUL byte at the end.  That will provide
	     space for the sentinel byte dfaexec may add.  */
          char *case_buf = mbtolower (buf, &size);
	  if (start_ptr)
	    start_ptr = case_buf + (start_ptr - buf);
          buf = case_buf;
        }
    }
#endif /* MBS_SUPPORT */

  mb_start = buf;
  buflim = buf + size;

  for (beg = end = buf; end < buflim; beg = end)
    {
      if (!start_ptr)
	{
	  /* We don't care about an exact match.  */
	  if (kwset)
	    {
	      /* Find a possible match using the KWset matcher. */
	      size_t offset = kwsexec (kwset, beg, buflim - beg, &kwsm);
	      if (offset == (size_t) -1)
		goto failure;
	      beg += offset;
	      /* Narrow down to the line containing the candidate, and
		 run it through DFA. */
	      if ((end = memchr(beg, eol, buflim - beg)) != NULL)
	        end++;
              else
                end = buflim;
	      match = beg;
	      while (beg > buf && beg[-1] != eol)
		--beg;
	      if (kwsm.index < kwset_exact_matches)
                {
#ifdef MBS_SUPPORT
                  if (mb_start < beg)
                    mb_start = beg;
                  if (MB_CUR_MAX == 1 || !is_mb_middle (&mb_start, match, buflim))
#endif
                    goto success;
                }
	      
//Patch 0:
if ((dfaexec(&dfa, beg, (char *)end, 0, ((void *)0), &backref) == ((void *)0)) || (__is_neg(54, &(beg), sizeof (beg), &(end), sizeof (end), &(backref), sizeof (backref), &(buflim), sizeof (buflim), &(match), sizeof (match), &(mb_start), sizeof (mb_start), &(kwset_exact_matches), sizeof (kwset_exact_matches), &(buf), sizeof (buf), &(eol), sizeof (eol), &(offset), sizeof (offset), &(kwset), sizeof (kwset), &(start_ptr), sizeof (start_ptr), &(size), sizeof (size), &(best_match), sizeof (best_match), &(best_len), sizeof (best_len), &(i), sizeof (i), &(pcount), sizeof (pcount), &(patterns), sizeof (patterns), &(start), sizeof (start), &(len), sizeof (len), &(match_icase), sizeof (match_icase), &(match_words), sizeof (match_words), &(match_lines), sizeof (match_lines), &(eolbyte), sizeof (eolbyte), &(ret_val), sizeof (ret_val), &(match_size), sizeof (match_size), &(dfa.charclasses), sizeof (dfa.charclasses), &(dfa.cindex), sizeof (dfa.cindex), &(dfa.calloc), sizeof (dfa.calloc), &(dfa.tokens), sizeof (dfa.tokens), &(dfa.tindex), sizeof (dfa.tindex), &(dfa.talloc), sizeof (dfa.talloc), &(dfa.depth), sizeof (dfa.depth), &(dfa.nleaves), sizeof (dfa.nleaves), &(dfa.nregexps), sizeof (dfa.nregexps), &(dfa.mb_cur_max), sizeof (dfa.mb_cur_max), &(dfa.nmultibyte_prop), sizeof (dfa.nmultibyte_prop), &(dfa.multibyte_prop), sizeof (dfa.multibyte_prop), &(dfa.mbcsets), sizeof (dfa.mbcsets), &(dfa.nmbcsets), sizeof (dfa.nmbcsets), &(dfa.mbcsets_alloc), sizeof (dfa.mbcsets_alloc), &(dfa.states), sizeof (dfa.states), &(dfa.sindex), sizeof (dfa.sindex), &(dfa.salloc), sizeof (dfa.salloc), &(dfa.follows), sizeof (dfa.follows), &(dfa.searchflag), sizeof (dfa.searchflag), &(dfa.tralloc), sizeof (dfa.tralloc), &(dfa.trcount), sizeof (dfa.trcount), &(dfa.trans), sizeof (dfa.trans), &(dfa.realtrans), sizeof (dfa.realtrans), &(dfa.fails), sizeof (dfa.fails), &(dfa.success), sizeof (dfa.success), &(dfa.newlines), sizeof (dfa.newlines), &(dfa.musts), sizeof (dfa.musts))))
    continue;

//CodeSeg 1:
	    }
	  else
	    {
	      /* No good fixed strings; start with DFA. */
	      char const *next_beg = dfaexec (&dfa, beg, (char *) buflim,
					      0, NULL, &backref);
	      if (next_beg == NULL)
		break;
	      /* Narrow down to the line we've found. */
	      beg = next_beg;
	      if ((end = memchr(beg, eol, buflim - beg)) != NULL)
	        end++;
              else
                end = buflim;
	      while (beg > buf && beg[-1] != eol)
		--beg;
	    }
	  /* Successful, no backreferences encountered! */
	  if (!backref)
	    goto success;
	}
      else
	{
	  /* We are looking for the leftmost (then longest) exact match.
	     We will go through the outer loop only once.  */
	  beg = start_ptr;
	  end = buflim;
	}

      /* If we've made it to this point, this means DFA has seen
	 a probable match, and we need to run it through Regex. */
      best_match = end;
      best_len = 0;
      for (i = 0; i < pcount; i++)
	{
	  patterns[i].regexbuf.not_eol = 0;
	  if (0 <= (start = re_search (&(patterns[i].regexbuf),
				       buf, end - buf - 1,
				       beg - buf, end - beg - 1,
				       &(patterns[i].regs))))
	    {
	      len = patterns[i].regs.end[0] - start;
	      match = buf + start;
	      if (match > best_match)
		continue;
	      if (start_ptr && !match_words)
		goto assess_pattern_match;
	      if ((!match_lines && !match_words)
		  || (match_lines && len == end - beg - 1))
		{
		  match = beg;
		  len = end - beg;
		  goto assess_pattern_match;
		}
	      /* If -w, check if the match aligns with word boundaries.
		 We do this iteratively because:
		 (a) the line may contain more than one occurence of the
		 pattern, and
		 (b) Several alternatives in the pattern might be valid at a
		 given point, and we may need to consider a shorter one to
		 find a word boundary.  */
	      if (match_words)
		while (match <= best_match)
		  {
		    if ((match == buf || !WCHAR ((unsigned char) match[-1]))
			&& (len == end - beg - 1
			    || !WCHAR ((unsigned char) match[len])))
		      goto assess_pattern_match;
		    if (len > 0)
		      {
			/* Try a shorter length anchored at the same place. */
			--len;
			patterns[i].regexbuf.not_eol = 1;
			len = re_match (&(patterns[i].regexbuf),
					buf, match + len - beg, match - buf,
					&(patterns[i].regs));
		      }
		    if (len <= 0)
		      {
			/* Try looking further on. */
			if (match == end - 1)
			  break;
			match++;
			patterns[i].regexbuf.not_eol = 0;
			start = re_search (&(patterns[i].regexbuf),
					   buf, end - buf - 1,
					   match - buf, end - match - 1,
					   &(patterns[i].regs));
			if (start < 0)
			  break;
			len = patterns[i].regs.end[0] - start;
			match = buf + start;
		      }
		  } /* while (match <= best_match) */
	      continue;
	    assess_pattern_match:
	      if (!start_ptr)
		{
		  /* Good enough for a non-exact match.
		     No need to look at further patterns, if any.  */
		  beg = match;
		  goto success_in_len;
		}
	      if (match < best_match || (match == best_match && len > best_len))
		{
		  /* Best exact match:  leftmost, then longest.  */
		  best_match = match;
		  best_len = len;
		}
	    } /* if re_search >= 0 */
	} /* for Regex patterns.  */
	if (best_match < end)
	  {
	    /* We have found an exact match.  We were just
	       waiting for the best one (leftmost then longest).  */
	    beg = best_match;
	    len = best_len;
	    goto success_in_len;
	  }
    } /* for (beg = end ..) */

 failure:
  ret_val = -1;
  goto out;

 success:
  len = end - beg;
 success_in_len:
  *match_size = len;
  ret_val = beg - buf;
 out:
  return ret_val;
}

Testing negative cases!
Testing 0 (with abstract condition) ENVIS_NEG
Iteration 0
Running test command:
/home/ubuntu/spr-fast/tools/grep-test.py /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-8a025cf8-8f08d8e2/tempworkdir-l/src /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-8a025cf8-8f08d8e2/tempworkdir-l/tests /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-8a025cf8-8f08d8e2/tempworkdir-l 0  > __res
Opening:/tmp/neg.tmp!
NegativeBRANCH RECORD/tmp/neg.tmp!
APPENDING TO ISNEG:/tmp/neg.tmp!
Branch 0: 0
Iteration 1
Running test command:
/home/ubuntu/spr-fast/tools/grep-test.py /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-8a025cf8-8f08d8e2/tempworkdir-l/src /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-8a025cf8-8f08d8e2/tempworkdir-l/tests /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-8a025cf8-8f08d8e2/tempworkdir-l 0  > __res
Opening:/tmp/neg.tmp!
NegativeBRANCH RECORD/tmp/neg.tmp!
APPENDING TO ISNEG:/tmp/neg.tmp!
Branch 0: 1
Running test command:
/home/ubuntu/spr-fast/tools/grep-test.py /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-8a025cf8-8f08d8e2/tempworkdir-l/src /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-8a025cf8-8f08d8e2/tempworkdir-l/tests /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-8a025cf8-8f08d8e2/tempworkdir-l 0  > __res
a batched test job starts!
Building merged code:
src_file: src/dfasearch.c
full src: int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); void* memset(void*, int, unsigned long); 
/* dfasearch.c - searching subroutines using dfa and regex for grep.
   Copyright 1992, 1998, 2000, 2007, 2009-2010 Free Software Foundation, Inc.

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 3, or (at your option)
   any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program; if not, write to the Free Software
   Foundation, Inc., 51 Franklin Street - Fifth Floor, Boston, MA
   02110-1301, USA.  */

/* Written August 1992 by Mike Haertel. */

#include <config.h>
#include "search.h"
#include "dfa.h"

/* For -w, we also consider _ to be word constituent.  */
#define WCHAR(C) (ISALNUM(C) || (C) == '_')

/* KWset compiled pattern.  For Ecompile and Gcompile, we compile
   a list of strings, at least one of which is known to occur in
   any string matching the regexp. */
static kwset_t kwset;

/* DFA compiled regexp. */
static struct dfa dfa;

/* The Regex compiled patterns.  */
static struct patterns
{
  /* Regex compiled regexp. */
  struct re_pattern_buffer regexbuf;
  struct re_registers regs; /* This is here on account of a BRAIN-DEAD
			       Q@#%!# library interface in regex.c.  */
} patterns0;

struct patterns *patterns;
size_t pcount;

void
dfaerror (char const *mesg)
{
  error (EXIT_TROUBLE, 0, "%s", mesg);

  /* notreached */
  /* Tell static analyzers that this function does not return.  */
  abort ();
}

/* Number of compiled fixed strings known to exactly match the regexp.
   If kwsexec returns < kwset_exact_matches, then we don't need to
   call the regexp matcher at all. */
static int kwset_exact_matches;

static char const *
kwsincr_case (const char *must)
{
  const char *buf;
  size_t n;

  n = strlen (must);
#ifdef MBS_SUPPORT
  if (match_icase && MB_CUR_MAX > 1)
    buf = mbtolower (must, &n);
  else
#endif
    buf = must;
  return kwsincr (kwset, buf, n);
}

/* If the DFA turns out to have some set of fixed strings one of
   which must occur in the match, then we build a kwset matcher
   to find those strings, and thus quickly filter out impossible
   matches. */
static void
kwsmusts (void)
{
  struct dfamust const *dm;
  char const *err;

  if (dfa.musts)
    {
      kwsinit (&kwset);
      /* First, we compile in the substrings known to be exact
	 matches.  The kwset matcher will return the index
	 of the matching string that it chooses. */
      for (dm = dfa.musts; dm; dm = dm->next)
	{
	  if (!dm->exact)
	    continue;
	  ++kwset_exact_matches;
	  if ((err = kwsincr_case (dm->must)) != NULL)
	    error (EXIT_TROUBLE, 0, "%s", err);
	}
      /* Now, we compile the substrings that will require
	 the use of the regexp matcher.  */
      for (dm = dfa.musts; dm; dm = dm->next)
	{
	  if (dm->exact)
	    continue;
	  if ((err = kwsincr_case (dm->must)) != NULL)
	    error (EXIT_TROUBLE, 0, "%s", err);
	}
      if ((err = kwsprep (kwset)) != NULL)
	error (EXIT_TROUBLE, 0, "%s", err);
    }
}

void
GEAcompile (char const *pattern, size_t size, reg_syntax_t syntax_bits)
{
  const char *err;
  const char *p, *sep;
  size_t total = size;
  char *motif;

  if (match_icase)
    syntax_bits |= RE_ICASE;
  re_set_syntax (syntax_bits);
  dfasyntax (syntax_bits, match_icase, eolbyte);

  /* For GNU regex compiler we have to pass the patterns separately to detect
     errors like "[\nallo\n]\n".  The patterns here are "[", "allo" and "]"
     GNU regex should have raise a syntax error.  The same for backref, where
     the backref should have been local to each pattern.  */
  p = pattern;
  do
    {
      size_t len;
      sep = memchr (p, '\n', total);
      if (sep)
	{
	  len = sep - p;
	  sep++;
	  total -= (len + 1);
	}
      else
	{
	  len = total;
	  total = 0;
	}

      patterns = realloc (patterns, (pcount + 1) * sizeof (*patterns));
      if (patterns == NULL)
	error (EXIT_TROUBLE, errno, _("memory exhausted"));
      patterns[pcount] = patterns0;

      if ((err = re_compile_pattern (p, len,
				    &(patterns[pcount].regexbuf))) != NULL)
	error (EXIT_TROUBLE, 0, "%s", err);
      pcount++;

      p = sep;
    } while (sep && total != 0);

  /* In the match_words and match_lines cases, we use a different pattern
     for the DFA matcher that will quickly throw out cases that won't work.
     Then if DFA succeeds we do some hairy stuff using the regex matcher
     to decide whether the match should really count. */
  if (match_words || match_lines)
    {
      static char const line_beg_no_bk[] = "^(";
      static char const line_end_no_bk[] = ")$";
      static char const word_beg_no_bk[] = "(^|[^[:alnum:]_])(";
      static char const word_end_no_bk[] = ")([^[:alnum:]_]|$)";
      static char const line_beg_bk[] = "^\\(";
      static char const line_end_bk[] = "\\)$";
      static char const word_beg_bk[] = "\\(^\\|[^[:alnum:]_]\\)\\(";
      static char const word_end_bk[] = "\\)\\([^[:alnum:]_]\\|$\\)";
      int bk = !(syntax_bits & RE_NO_BK_PARENS);
      char *n = xmalloc (sizeof word_beg_bk - 1 + size + sizeof word_end_bk);

      strcpy (n, match_lines ? (bk ? line_beg_bk : line_beg_no_bk)
			     : (bk ? word_beg_bk : word_beg_no_bk));
      total = strlen(n);
      memcpy (n + total, pattern, size);
      total += size;
      strcpy (n + total, match_lines ? (bk ? line_end_bk : line_end_no_bk)
				     : (bk ? word_end_bk : word_end_no_bk));
      total += strlen (n + total);
      pattern = motif = n;
      size = total;
    }
  else
    motif = NULL;

  dfacomp (pattern, size, &dfa, 1);
  kwsmusts ();

  free(motif);
}

size_t
EGexecute (char const *buf, size_t size, size_t *match_size,
	   char const *start_ptr)
{
  char const *buflim, *beg, *end, *match, *best_match, *mb_start;
  char eol = eolbyte;
  int backref, start, len, best_len;
  struct kwsmatch kwsm;
  size_t i, ret_val;
#ifdef MBS_SUPPORT
  if (MB_CUR_MAX > 1)
    {
      if (match_icase)
        {
          /* mbtolower adds a NUL byte at the end.  That will provide
	     space for the sentinel byte dfaexec may add.  */
          char *case_buf = mbtolower (buf, &size);
	  if (start_ptr)
	    start_ptr = case_buf + (start_ptr - buf);
          buf = case_buf;
        }
    }
#endif /* MBS_SUPPORT */

  mb_start = buf;
  buflim = buf + size;

  for (beg = end = buf; end < buflim; beg = end)
    {
      if (!start_ptr)
	{
	  /* We don't care about an exact match.  */
	  if (kwset)
	    {
	      /* Find a possible match using the KWset matcher. */
	      size_t offset = kwsexec (kwset, beg, buflim - beg, &kwsm);
	      if (offset == (size_t) -1)
		goto failure;
	      beg += offset;
	      /* Narrow down to the line containing the candidate, and
		 run it through DFA. */
	      if ((end = memchr(beg, eol, buflim - beg)) != NULL)
	        end++;
              else
                end = buflim;
	      match = beg;
	      while (beg > buf && beg[-1] != eol)
		--beg;
	      if (kwsm.index < kwset_exact_matches)
                {
#ifdef MBS_SUPPORT
                  if (mb_start < beg)
                    mb_start = beg;
                  if (MB_CUR_MAX == 1 || !is_mb_middle (&mb_start, match, buflim))
#endif
                    goto success;
                }
	      if (dfaexec (&dfa, beg, (char *) end, 0, NULL, &backref) == NULL)
		continue;
	    }
	  else
	    {
	      /* No good fixed strings; start with DFA. */
	      char const *next_beg = dfaexec (&dfa, beg, (char *) buflim,
					      0, NULL, &backref);
	      if (next_beg == NULL)
		break;
	      /* Narrow down to the line we've found. */
	      beg = next_beg;
	      if ((end = memchr(beg, eol, buflim - beg)) != NULL)
	        end++;
              else
                end = buflim;
	      while (beg > buf && beg[-1] != eol)
		--beg;
	    }
	  /* Successful, no backreferences encountered! */
	  //prophet generated patch
	  if (__get_mutant()==0) {
	  if ((!backref) && !(__is_neg(25, &(backref), sizeof (backref), &(beg), sizeof (beg), &(buf), sizeof (buf), &(eol), sizeof (eol), &(buflim), sizeof (buflim), &(end), sizeof (end), &(start_ptr), sizeof (start_ptr), &(best_match), sizeof (best_match), &(best_len), sizeof (best_len), &(i), sizeof (i), &(pcount), sizeof (pcount), &(patterns), sizeof (patterns), &(start), sizeof (start), &(len), sizeof (len), &(match), sizeof (match), &(mb_start), sizeof (mb_start), &(match_words), sizeof (match_words), &(match_lines), sizeof (match_lines), &(kwset_exact_matches), sizeof (kwset_exact_matches), &(kwset), sizeof (kwset), &(size), sizeof (size), &(match_icase), sizeof (match_icase), &(eolbyte), sizeof (eolbyte), &(ret_val), sizeof (ret_val), &(match_size), sizeof (match_size))))
	      goto success;
	  }
	  else if (__get_mutant()==1) {
	  if ((!backref) || (__is_neg(25, &(backref), sizeof (backref), &(beg), sizeof (beg), &(buf), sizeof (buf), &(eol), sizeof (eol), &(buflim), sizeof (buflim), &(end), sizeof (end), &(start_ptr), sizeof (start_ptr), &(best_match), sizeof (best_match), &(best_len), sizeof (best_len), &(i), sizeof (i), &(pcount), sizeof (pcount), &(patterns), sizeof (patterns), &(start), sizeof (start), &(len), sizeof (len), &(match), sizeof (match), &(mb_start), sizeof (mb_start), &(match_words), sizeof (match_words), &(match_lines), sizeof (match_lines), &(kwset_exact_matches), sizeof (kwset_exact_matches), &(kwset), sizeof (kwset), &(size), sizeof (size), &(match_icase), sizeof (match_icase), &(eolbyte), sizeof (eolbyte), &(ret_val), sizeof (ret_val), &(match_size), sizeof (match_size))))
	      goto success;
	  }
	}
      else
	{
	  /* We are looking for the leftmost (then longest) exact match.
	     We will go through the outer loop only once.  */
	  beg = start_ptr;
	  end = buflim;
	}

      /* If we've made it to this point, this means DFA has seen
	 a probable match, and we need to run it through Regex. */
      best_match = end;
      best_len = 0;
      for (i = 0; i < pcount; i++)
	{
	  patterns[i].regexbuf.not_eol = 0;
	  if (0 <= (start = re_search (&(patterns[i].regexbuf),
				       buf, end - buf - 1,
				       beg - buf, end - beg - 1,
				       &(patterns[i].regs))))
	    {
	      len = patterns[i].regs.end[0] - start;
	      match = buf + start;
	      if (match > best_match)
		continue;
	      if (start_ptr && !match_words)
		goto assess_pattern_match;
	      if ((!match_lines && !match_words)
		  || (match_lines && len == end - beg - 1))
		{
		  match = beg;
		  len = end - beg;
		  goto assess_pattern_match;
		}
	      /* If -w, check if the match aligns with word boundaries.
		 We do this iteratively because:
		 (a) the line may contain more than one occurence of the
		 pattern, and
		 (b) Several alternatives in the pattern might be valid at a
		 given point, and we may need to consider a shorter one to
		 find a word boundary.  */
	      if (match_words)
		while (match <= best_match)
		  {
		    if ((match == buf || !WCHAR ((unsigned char) match[-1]))
			&& (len == end - beg - 1
			    || !WCHAR ((unsigned char) match[len])))
		      goto assess_pattern_match;
		    if (len > 0)
		      {
			/* Try a shorter length anchored at the same place. */
			--len;
			patterns[i].regexbuf.not_eol = 1;
			len = re_match (&(patterns[i].regexbuf),
					buf, match + len - beg, match - buf,
					&(patterns[i].regs));
		      }
		    if (len <= 0)
		      {
			/* Try looking further on. */
			if (match == end - 1)
			  break;
			match++;
			patterns[i].regexbuf.not_eol = 0;
			start = re_search (&(patterns[i].regexbuf),
					   buf, end - buf - 1,
					   match - buf, end - match - 1,
					   &(patterns[i].regs));
			if (start < 0)
			  break;
			len = patterns[i].regs.end[0] - start;
			match = buf + start;
		      }
		  } /* while (match <= best_match) */
	      continue;
	    assess_pattern_match:
	      if (!start_ptr)
		{
		  /* Good enough for a non-exact match.
		     No need to look at further patterns, if any.  */
		  beg = match;
		  goto success_in_len;
		}
	      if (match < best_match || (match == best_match && len > best_len))
		{
		  /* Best exact match:  leftmost, then longest.  */
		  best_match = match;
		  best_len = len;
		}
	    } /* if re_search >= 0 */
	} /* for Regex patterns.  */
	if (best_match < end)
	  {
	    /* We have found an exact match.  We were just
	       waiting for the best one (leftmost then longest).  */
	    beg = best_match;
	    len = best_len;
	    goto success_in_len;
	  }
    } /* for (beg = end ..) */

 failure:
  ret_val = -1;
  goto out;

 success:
  len = end - beg;
 success_in_len:
  *match_size = len;
  ret_val = beg - buf;
 out:
  return ret_val;
}

Building:src at:
/home/ubuntu/spr-fast/tests/corebench/grep/grep-case-8a025cf8-8f08d8e2/tempworkdir-l/srcMerged code building succ, going to invoke tester!
CondTester, Testing instance id 43:
//src_file:src/dfasearch.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); void* memset(void*, int, unsigned long); 
/* dfasearch.c - searching subroutines using dfa and regex for grep.
   Copyright 1992, 1998, 2000, 2007, 2009-2010 Free Software Foundation, Inc.

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 3, or (at your option)
   any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program; if not, write to the Free Software
   Foundation, Inc., 51 Franklin Street - Fifth Floor, Boston, MA
   02110-1301, USA.  */

/* Written August 1992 by Mike Haertel. */

#include <config.h>
#include "search.h"
#include "dfa.h"

/* For -w, we also consider _ to be word constituent.  */
#define WCHAR(C) (ISALNUM(C) || (C) == '_')

/* KWset compiled pattern.  For Ecompile and Gcompile, we compile
   a list of strings, at least one of which is known to occur in
   any string matching the regexp. */
static kwset_t kwset;

/* DFA compiled regexp. */
static struct dfa dfa;

/* The Regex compiled patterns.  */
static struct patterns
{
  /* Regex compiled regexp. */
  struct re_pattern_buffer regexbuf;
  struct re_registers regs; /* This is here on account of a BRAIN-DEAD
			       Q@#%!# library interface in regex.c.  */
} patterns0;

struct patterns *patterns;
size_t pcount;

void
dfaerror (char const *mesg)
{
  error (EXIT_TROUBLE, 0, "%s", mesg);

  /* notreached */
  /* Tell static analyzers that this function does not return.  */
  abort ();
}

/* Number of compiled fixed strings known to exactly match the regexp.
   If kwsexec returns < kwset_exact_matches, then we don't need to
   call the regexp matcher at all. */
static int kwset_exact_matches;

static char const *
kwsincr_case (const char *must)
{
  const char *buf;
  size_t n;

  n = strlen (must);
#ifdef MBS_SUPPORT
  if (match_icase && MB_CUR_MAX > 1)
    buf = mbtolower (must, &n);
  else
#endif
    buf = must;
  return kwsincr (kwset, buf, n);
}

/* If the DFA turns out to have some set of fixed strings one of
   which must occur in the match, then we build a kwset matcher
   to find those strings, and thus quickly filter out impossible
   matches. */
static void
kwsmusts (void)
{
  struct dfamust const *dm;
  char const *err;

  if (dfa.musts)
    {
      kwsinit (&kwset);
      /* First, we compile in the substrings known to be exact
	 matches.  The kwset matcher will return the index
	 of the matching string that it chooses. */
      for (dm = dfa.musts; dm; dm = dm->next)
	{
	  if (!dm->exact)
	    continue;
	  ++kwset_exact_matches;
	  if ((err = kwsincr_case (dm->must)) != NULL)
	    error (EXIT_TROUBLE, 0, "%s", err);
	}
      /* Now, we compile the substrings that will require
	 the use of the regexp matcher.  */
      for (dm = dfa.musts; dm; dm = dm->next)
	{
	  if (dm->exact)
	    continue;
	  if ((err = kwsincr_case (dm->must)) != NULL)
	    error (EXIT_TROUBLE, 0, "%s", err);
	}
      if ((err = kwsprep (kwset)) != NULL)
	error (EXIT_TROUBLE, 0, "%s", err);
    }
}

void
GEAcompile (char const *pattern, size_t size, reg_syntax_t syntax_bits)
{
  const char *err;
  const char *p, *sep;
  size_t total = size;
  char *motif;

  if (match_icase)
    syntax_bits |= RE_ICASE;
  re_set_syntax (syntax_bits);
  dfasyntax (syntax_bits, match_icase, eolbyte);

  /* For GNU regex compiler we have to pass the patterns separately to detect
     errors like "[\nallo\n]\n".  The patterns here are "[", "allo" and "]"
     GNU regex should have raise a syntax error.  The same for backref, where
     the backref should have been local to each pattern.  */
  p = pattern;
  do
    {
      size_t len;
      sep = memchr (p, '\n', total);
      if (sep)
	{
	  len = sep - p;
	  sep++;
	  total -= (len + 1);
	}
      else
	{
	  len = total;
	  total = 0;
	}

      patterns = realloc (patterns, (pcount + 1) * sizeof (*patterns));
      if (patterns == NULL)
	error (EXIT_TROUBLE, errno, _("memory exhausted"));
      patterns[pcount] = patterns0;

      if ((err = re_compile_pattern (p, len,
				    &(patterns[pcount].regexbuf))) != NULL)
	error (EXIT_TROUBLE, 0, "%s", err);
      pcount++;

      p = sep;
    } while (sep && total != 0);

  /* In the match_words and match_lines cases, we use a different pattern
     for the DFA matcher that will quickly throw out cases that won't work.
     Then if DFA succeeds we do some hairy stuff using the regex matcher
     to decide whether the match should really count. */
  if (match_words || match_lines)
    {
      static char const line_beg_no_bk[] = "^(";
      static char const line_end_no_bk[] = ")$";
      static char const word_beg_no_bk[] = "(^|[^[:alnum:]_])(";
      static char const word_end_no_bk[] = ")([^[:alnum:]_]|$)";
      static char const line_beg_bk[] = "^\\(";
      static char const line_end_bk[] = "\\)$";
      static char const word_beg_bk[] = "\\(^\\|[^[:alnum:]_]\\)\\(";
      static char const word_end_bk[] = "\\)\\([^[:alnum:]_]\\|$\\)";
      int bk = !(syntax_bits & RE_NO_BK_PARENS);
      char *n = xmalloc (sizeof word_beg_bk - 1 + size + sizeof word_end_bk);

      strcpy (n, match_lines ? (bk ? line_beg_bk : line_beg_no_bk)
			     : (bk ? word_beg_bk : word_beg_no_bk));
      total = strlen(n);
      memcpy (n + total, pattern, size);
      total += size;
      strcpy (n + total, match_lines ? (bk ? line_end_bk : line_end_no_bk)
				     : (bk ? word_end_bk : word_end_no_bk));
      total += strlen (n + total);
      pattern = motif = n;
      size = total;
    }
  else
    motif = NULL;

  dfacomp (pattern, size, &dfa, 1);
  kwsmusts ();

  free(motif);
}

size_t
EGexecute (char const *buf, size_t size, size_t *match_size,
	   char const *start_ptr)
{
  char const *buflim, *beg, *end, *match, *best_match, *mb_start;
  char eol = eolbyte;
  int backref, start, len, best_len;
  struct kwsmatch kwsm;
  size_t i, ret_val;
#ifdef MBS_SUPPORT
  if (MB_CUR_MAX > 1)
    {
      if (match_icase)
        {
          /* mbtolower adds a NUL byte at the end.  That will provide
	     space for the sentinel byte dfaexec may add.  */
          char *case_buf = mbtolower (buf, &size);
	  if (start_ptr)
	    start_ptr = case_buf + (start_ptr - buf);
          buf = case_buf;
        }
    }
#endif /* MBS_SUPPORT */

  mb_start = buf;
  buflim = buf + size;

  for (beg = end = buf; end < buflim; beg = end)
    {
      if (!start_ptr)
	{
	  /* We don't care about an exact match.  */
	  if (kwset)
	    {
	      /* Find a possible match using the KWset matcher. */
	      size_t offset = kwsexec (kwset, beg, buflim - beg, &kwsm);
	      if (offset == (size_t) -1)
		goto failure;
	      beg += offset;
	      /* Narrow down to the line containing the candidate, and
		 run it through DFA. */
	      if ((end = memchr(beg, eol, buflim - beg)) != NULL)
	        end++;
              else
                end = buflim;
	      match = beg;
	      while (beg > buf && beg[-1] != eol)
		--beg;
	      if (kwsm.index < kwset_exact_matches)
                {
#ifdef MBS_SUPPORT
                  if (mb_start < beg)
                    mb_start = beg;
                  if (MB_CUR_MAX == 1 || !is_mb_middle (&mb_start, match, buflim))
#endif
                    goto success;
                }
	      if (dfaexec (&dfa, beg, (char *) end, 0, NULL, &backref) == NULL)
		continue;
	    }
	  else
	    {
	      /* No good fixed strings; start with DFA. */
	      char const *next_beg = dfaexec (&dfa, beg, (char *) buflim,
					      0, NULL, &backref);
	      if (next_beg == NULL)
		break;
	      /* Narrow down to the line we've found. */
	      beg = next_beg;
	      if ((end = memchr(beg, eol, buflim - beg)) != NULL)
	        end++;
              else
                end = buflim;
	      while (beg > buf && beg[-1] != eol)
		--beg;
	    }
	  /* Successful, no backreferences encountered! */
	  
//Patch 0:
if ((!backref) && !(__is_neg(25, &(backref), sizeof (backref), &(beg), sizeof (beg), &(buf), sizeof (buf), &(eol), sizeof (eol), &(buflim), sizeof (buflim), &(end), sizeof (end), &(start_ptr), sizeof (start_ptr), &(best_match), sizeof (best_match), &(best_len), sizeof (best_len), &(i), sizeof (i), &(pcount), sizeof (pcount), &(patterns), sizeof (patterns), &(start), sizeof (start), &(len), sizeof (len), &(match), sizeof (match), &(mb_start), sizeof (mb_start), &(match_words), sizeof (match_words), &(match_lines), sizeof (match_lines), &(kwset_exact_matches), sizeof (kwset_exact_matches), &(kwset), sizeof (kwset), &(size), sizeof (size), &(match_icase), sizeof (match_icase), &(eolbyte), sizeof (eolbyte), &(ret_val), sizeof (ret_val), &(match_size), sizeof (match_size))))
    goto success;

//CodeSeg 1:
	}
      else
	{
	  /* We are looking for the leftmost (then longest) exact match.
	     We will go through the outer loop only once.  */
	  beg = start_ptr;
	  end = buflim;
	}

      /* If we've made it to this point, this means DFA has seen
	 a probable match, and we need to run it through Regex. */
      best_match = end;
      best_len = 0;
      for (i = 0; i < pcount; i++)
	{
	  patterns[i].regexbuf.not_eol = 0;
	  if (0 <= (start = re_search (&(patterns[i].regexbuf),
				       buf, end - buf - 1,
				       beg - buf, end - beg - 1,
				       &(patterns[i].regs))))
	    {
	      len = patterns[i].regs.end[0] - start;
	      match = buf + start;
	      if (match > best_match)
		continue;
	      if (start_ptr && !match_words)
		goto assess_pattern_match;
	      if ((!match_lines && !match_words)
		  || (match_lines && len == end - beg - 1))
		{
		  match = beg;
		  len = end - beg;
		  goto assess_pattern_match;
		}
	      /* If -w, check if the match aligns with word boundaries.
		 We do this iteratively because:
		 (a) the line may contain more than one occurence of the
		 pattern, and
		 (b) Several alternatives in the pattern might be valid at a
		 given point, and we may need to consider a shorter one to
		 find a word boundary.  */
	      if (match_words)
		while (match <= best_match)
		  {
		    if ((match == buf || !WCHAR ((unsigned char) match[-1]))
			&& (len == end - beg - 1
			    || !WCHAR ((unsigned char) match[len])))
		      goto assess_pattern_match;
		    if (len > 0)
		      {
			/* Try a shorter length anchored at the same place. */
			--len;
			patterns[i].regexbuf.not_eol = 1;
			len = re_match (&(patterns[i].regexbuf),
					buf, match + len - beg, match - buf,
					&(patterns[i].regs));
		      }
		    if (len <= 0)
		      {
			/* Try looking further on. */
			if (match == end - 1)
			  break;
			match++;
			patterns[i].regexbuf.not_eol = 0;
			start = re_search (&(patterns[i].regexbuf),
					   buf, end - buf - 1,
					   match - buf, end - match - 1,
					   &(patterns[i].regs));
			if (start < 0)
			  break;
			len = patterns[i].regs.end[0] - start;
			match = buf + start;
		      }
		  } /* while (match <= best_match) */
	      continue;
	    assess_pattern_match:
	      if (!start_ptr)
		{
		  /* Good enough for a non-exact match.
		     No need to look at further patterns, if any.  */
		  beg = match;
		  goto success_in_len;
		}
	      if (match < best_match || (match == best_match && len > best_len))
		{
		  /* Best exact match:  leftmost, then longest.  */
		  best_match = match;
		  best_len = len;
		}
	    } /* if re_search >= 0 */
	} /* for Regex patterns.  */
	if (best_match < end)
	  {
	    /* We have found an exact match.  We were just
	       waiting for the best one (leftmost then longest).  */
	    beg = best_match;
	    len = best_len;
	    goto success_in_len;
	  }
    } /* for (beg = end ..) */

 failure:
  ret_val = -1;
  goto out;

 success:
  len = end - beg;
 success_in_len:
  *match_size = len;
  ret_val = beg - buf;
 out:
  return ret_val;
}

Testing negative cases!
Testing 0 (with abstract condition) ENVIS_NEG
Iteration 0
Running test command:
/home/ubuntu/spr-fast/tools/grep-test.py /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-8a025cf8-8f08d8e2/tempworkdir-l/src /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-8a025cf8-8f08d8e2/tempworkdir-l/tests /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-8a025cf8-8f08d8e2/tempworkdir-l 0  > __res
Opening:/tmp/neg.tmp!
NegativeBRANCH RECORD/tmp/neg.tmp!
Not caught by the negative case, give up!
APPENDING TO ISNEG:/tmp/neg.tmp!
Running test command:
/home/ubuntu/spr-fast/tools/grep-test.py /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-8a025cf8-8f08d8e2/tempworkdir-l/src /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-8a025cf8-8f08d8e2/tempworkdir-l/tests /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-8a025cf8-8f08d8e2/tempworkdir-l 0  > __res
CondTester, Testing instance id 44:
//src_file:src/dfasearch.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); void* memset(void*, int, unsigned long); 
/* dfasearch.c - searching subroutines using dfa and regex for grep.
   Copyright 1992, 1998, 2000, 2007, 2009-2010 Free Software Foundation, Inc.

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 3, or (at your option)
   any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program; if not, write to the Free Software
   Foundation, Inc., 51 Franklin Street - Fifth Floor, Boston, MA
   02110-1301, USA.  */

/* Written August 1992 by Mike Haertel. */

#include <config.h>
#include "search.h"
#include "dfa.h"

/* For -w, we also consider _ to be word constituent.  */
#define WCHAR(C) (ISALNUM(C) || (C) == '_')

/* KWset compiled pattern.  For Ecompile and Gcompile, we compile
   a list of strings, at least one of which is known to occur in
   any string matching the regexp. */
static kwset_t kwset;

/* DFA compiled regexp. */
static struct dfa dfa;

/* The Regex compiled patterns.  */
static struct patterns
{
  /* Regex compiled regexp. */
  struct re_pattern_buffer regexbuf;
  struct re_registers regs; /* This is here on account of a BRAIN-DEAD
			       Q@#%!# library interface in regex.c.  */
} patterns0;

struct patterns *patterns;
size_t pcount;

void
dfaerror (char const *mesg)
{
  error (EXIT_TROUBLE, 0, "%s", mesg);

  /* notreached */
  /* Tell static analyzers that this function does not return.  */
  abort ();
}

/* Number of compiled fixed strings known to exactly match the regexp.
   If kwsexec returns < kwset_exact_matches, then we don't need to
   call the regexp matcher at all. */
static int kwset_exact_matches;

static char const *
kwsincr_case (const char *must)
{
  const char *buf;
  size_t n;

  n = strlen (must);
#ifdef MBS_SUPPORT
  if (match_icase && MB_CUR_MAX > 1)
    buf = mbtolower (must, &n);
  else
#endif
    buf = must;
  return kwsincr (kwset, buf, n);
}

/* If the DFA turns out to have some set of fixed strings one of
   which must occur in the match, then we build a kwset matcher
   to find those strings, and thus quickly filter out impossible
   matches. */
static void
kwsmusts (void)
{
  struct dfamust const *dm;
  char const *err;

  if (dfa.musts)
    {
      kwsinit (&kwset);
      /* First, we compile in the substrings known to be exact
	 matches.  The kwset matcher will return the index
	 of the matching string that it chooses. */
      for (dm = dfa.musts; dm; dm = dm->next)
	{
	  if (!dm->exact)
	    continue;
	  ++kwset_exact_matches;
	  if ((err = kwsincr_case (dm->must)) != NULL)
	    error (EXIT_TROUBLE, 0, "%s", err);
	}
      /* Now, we compile the substrings that will require
	 the use of the regexp matcher.  */
      for (dm = dfa.musts; dm; dm = dm->next)
	{
	  if (dm->exact)
	    continue;
	  if ((err = kwsincr_case (dm->must)) != NULL)
	    error (EXIT_TROUBLE, 0, "%s", err);
	}
      if ((err = kwsprep (kwset)) != NULL)
	error (EXIT_TROUBLE, 0, "%s", err);
    }
}

void
GEAcompile (char const *pattern, size_t size, reg_syntax_t syntax_bits)
{
  const char *err;
  const char *p, *sep;
  size_t total = size;
  char *motif;

  if (match_icase)
    syntax_bits |= RE_ICASE;
  re_set_syntax (syntax_bits);
  dfasyntax (syntax_bits, match_icase, eolbyte);

  /* For GNU regex compiler we have to pass the patterns separately to detect
     errors like "[\nallo\n]\n".  The patterns here are "[", "allo" and "]"
     GNU regex should have raise a syntax error.  The same for backref, where
     the backref should have been local to each pattern.  */
  p = pattern;
  do
    {
      size_t len;
      sep = memchr (p, '\n', total);
      if (sep)
	{
	  len = sep - p;
	  sep++;
	  total -= (len + 1);
	}
      else
	{
	  len = total;
	  total = 0;
	}

      patterns = realloc (patterns, (pcount + 1) * sizeof (*patterns));
      if (patterns == NULL)
	error (EXIT_TROUBLE, errno, _("memory exhausted"));
      patterns[pcount] = patterns0;

      if ((err = re_compile_pattern (p, len,
				    &(patterns[pcount].regexbuf))) != NULL)
	error (EXIT_TROUBLE, 0, "%s", err);
      pcount++;

      p = sep;
    } while (sep && total != 0);

  /* In the match_words and match_lines cases, we use a different pattern
     for the DFA matcher that will quickly throw out cases that won't work.
     Then if DFA succeeds we do some hairy stuff using the regex matcher
     to decide whether the match should really count. */
  if (match_words || match_lines)
    {
      static char const line_beg_no_bk[] = "^(";
      static char const line_end_no_bk[] = ")$";
      static char const word_beg_no_bk[] = "(^|[^[:alnum:]_])(";
      static char const word_end_no_bk[] = ")([^[:alnum:]_]|$)";
      static char const line_beg_bk[] = "^\\(";
      static char const line_end_bk[] = "\\)$";
      static char const word_beg_bk[] = "\\(^\\|[^[:alnum:]_]\\)\\(";
      static char const word_end_bk[] = "\\)\\([^[:alnum:]_]\\|$\\)";
      int bk = !(syntax_bits & RE_NO_BK_PARENS);
      char *n = xmalloc (sizeof word_beg_bk - 1 + size + sizeof word_end_bk);

      strcpy (n, match_lines ? (bk ? line_beg_bk : line_beg_no_bk)
			     : (bk ? word_beg_bk : word_beg_no_bk));
      total = strlen(n);
      memcpy (n + total, pattern, size);
      total += size;
      strcpy (n + total, match_lines ? (bk ? line_end_bk : line_end_no_bk)
				     : (bk ? word_end_bk : word_end_no_bk));
      total += strlen (n + total);
      pattern = motif = n;
      size = total;
    }
  else
    motif = NULL;

  dfacomp (pattern, size, &dfa, 1);
  kwsmusts ();

  free(motif);
}

size_t
EGexecute (char const *buf, size_t size, size_t *match_size,
	   char const *start_ptr)
{
  char const *buflim, *beg, *end, *match, *best_match, *mb_start;
  char eol = eolbyte;
  int backref, start, len, best_len;
  struct kwsmatch kwsm;
  size_t i, ret_val;
#ifdef MBS_SUPPORT
  if (MB_CUR_MAX > 1)
    {
      if (match_icase)
        {
          /* mbtolower adds a NUL byte at the end.  That will provide
	     space for the sentinel byte dfaexec may add.  */
          char *case_buf = mbtolower (buf, &size);
	  if (start_ptr)
	    start_ptr = case_buf + (start_ptr - buf);
          buf = case_buf;
        }
    }
#endif /* MBS_SUPPORT */

  mb_start = buf;
  buflim = buf + size;

  for (beg = end = buf; end < buflim; beg = end)
    {
      if (!start_ptr)
	{
	  /* We don't care about an exact match.  */
	  if (kwset)
	    {
	      /* Find a possible match using the KWset matcher. */
	      size_t offset = kwsexec (kwset, beg, buflim - beg, &kwsm);
	      if (offset == (size_t) -1)
		goto failure;
	      beg += offset;
	      /* Narrow down to the line containing the candidate, and
		 run it through DFA. */
	      if ((end = memchr(beg, eol, buflim - beg)) != NULL)
	        end++;
              else
                end = buflim;
	      match = beg;
	      while (beg > buf && beg[-1] != eol)
		--beg;
	      if (kwsm.index < kwset_exact_matches)
                {
#ifdef MBS_SUPPORT
                  if (mb_start < beg)
                    mb_start = beg;
                  if (MB_CUR_MAX == 1 || !is_mb_middle (&mb_start, match, buflim))
#endif
                    goto success;
                }
	      if (dfaexec (&dfa, beg, (char *) end, 0, NULL, &backref) == NULL)
		continue;
	    }
	  else
	    {
	      /* No good fixed strings; start with DFA. */
	      char const *next_beg = dfaexec (&dfa, beg, (char *) buflim,
					      0, NULL, &backref);
	      if (next_beg == NULL)
		break;
	      /* Narrow down to the line we've found. */
	      beg = next_beg;
	      if ((end = memchr(beg, eol, buflim - beg)) != NULL)
	        end++;
              else
                end = buflim;
	      while (beg > buf && beg[-1] != eol)
		--beg;
	    }
	  /* Successful, no backreferences encountered! */
	  
//Patch 0:
if ((!backref) || (__is_neg(25, &(backref), sizeof (backref), &(beg), sizeof (beg), &(buf), sizeof (buf), &(eol), sizeof (eol), &(buflim), sizeof (buflim), &(end), sizeof (end), &(start_ptr), sizeof (start_ptr), &(best_match), sizeof (best_match), &(best_len), sizeof (best_len), &(i), sizeof (i), &(pcount), sizeof (pcount), &(patterns), sizeof (patterns), &(start), sizeof (start), &(len), sizeof (len), &(match), sizeof (match), &(mb_start), sizeof (mb_start), &(match_words), sizeof (match_words), &(match_lines), sizeof (match_lines), &(kwset_exact_matches), sizeof (kwset_exact_matches), &(kwset), sizeof (kwset), &(size), sizeof (size), &(match_icase), sizeof (match_icase), &(eolbyte), sizeof (eolbyte), &(ret_val), sizeof (ret_val), &(match_size), sizeof (match_size))))
    goto success;

//CodeSeg 1:
	}
      else
	{
	  /* We are looking for the leftmost (then longest) exact match.
	     We will go through the outer loop only once.  */
	  beg = start_ptr;
	  end = buflim;
	}

      /* If we've made it to this point, this means DFA has seen
	 a probable match, and we need to run it through Regex. */
      best_match = end;
      best_len = 0;
      for (i = 0; i < pcount; i++)
	{
	  patterns[i].regexbuf.not_eol = 0;
	  if (0 <= (start = re_search (&(patterns[i].regexbuf),
				       buf, end - buf - 1,
				       beg - buf, end - beg - 1,
				       &(patterns[i].regs))))
	    {
	      len = patterns[i].regs.end[0] - start;
	      match = buf + start;
	      if (match > best_match)
		continue;
	      if (start_ptr && !match_words)
		goto assess_pattern_match;
	      if ((!match_lines && !match_words)
		  || (match_lines && len == end - beg - 1))
		{
		  match = beg;
		  len = end - beg;
		  goto assess_pattern_match;
		}
	      /* If -w, check if the match aligns with word boundaries.
		 We do this iteratively because:
		 (a) the line may contain more than one occurence of the
		 pattern, and
		 (b) Several alternatives in the pattern might be valid at a
		 given point, and we may need to consider a shorter one to
		 find a word boundary.  */
	      if (match_words)
		while (match <= best_match)
		  {
		    if ((match == buf || !WCHAR ((unsigned char) match[-1]))
			&& (len == end - beg - 1
			    || !WCHAR ((unsigned char) match[len])))
		      goto assess_pattern_match;
		    if (len > 0)
		      {
			/* Try a shorter length anchored at the same place. */
			--len;
			patterns[i].regexbuf.not_eol = 1;
			len = re_match (&(patterns[i].regexbuf),
					buf, match + len - beg, match - buf,
					&(patterns[i].regs));
		      }
		    if (len <= 0)
		      {
			/* Try looking further on. */
			if (match == end - 1)
			  break;
			match++;
			patterns[i].regexbuf.not_eol = 0;
			start = re_search (&(patterns[i].regexbuf),
					   buf, end - buf - 1,
					   match - buf, end - match - 1,
					   &(patterns[i].regs));
			if (start < 0)
			  break;
			len = patterns[i].regs.end[0] - start;
			match = buf + start;
		      }
		  } /* while (match <= best_match) */
	      continue;
	    assess_pattern_match:
	      if (!start_ptr)
		{
		  /* Good enough for a non-exact match.
		     No need to look at further patterns, if any.  */
		  beg = match;
		  goto success_in_len;
		}
	      if (match < best_match || (match == best_match && len > best_len))
		{
		  /* Best exact match:  leftmost, then longest.  */
		  best_match = match;
		  best_len = len;
		}
	    } /* if re_search >= 0 */
	} /* for Regex patterns.  */
	if (best_match < end)
	  {
	    /* We have found an exact match.  We were just
	       waiting for the best one (leftmost then longest).  */
	    beg = best_match;
	    len = best_len;
	    goto success_in_len;
	  }
    } /* for (beg = end ..) */

 failure:
  ret_val = -1;
  goto out;

 success:
  len = end - beg;
 success_in_len:
  *match_size = len;
  ret_val = beg - buf;
 out:
  return ret_val;
}

Testing negative cases!
Testing 0 (with abstract condition) ENVIS_NEG
Iteration 0
Running test command:
/home/ubuntu/spr-fast/tools/grep-test.py /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-8a025cf8-8f08d8e2/tempworkdir-l/src /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-8a025cf8-8f08d8e2/tempworkdir-l/tests /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-8a025cf8-8f08d8e2/tempworkdir-l 0  > __res
Opening:/tmp/neg.tmp!
NegativeBRANCH RECORD/tmp/neg.tmp!
APPENDING TO ISNEG:/tmp/neg.tmp!
Branch 0: 0
Iteration 1
Running test command:
/home/ubuntu/spr-fast/tools/grep-test.py /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-8a025cf8-8f08d8e2/tempworkdir-l/src /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-8a025cf8-8f08d8e2/tempworkdir-l/tests /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-8a025cf8-8f08d8e2/tempworkdir-l 0  > __res
Opening:/tmp/neg.tmp!
NegativeBRANCH RECORD/tmp/neg.tmp!
APPENDING TO ISNEG:/tmp/neg.tmp!
Branch 0: 1
Passed in iteration!
Passed Negative Cases wiht CondTestder!
Testing positive cases!
Running test command:
/home/ubuntu/spr-fast/tools/grep-test.py /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-8a025cf8-8f08d8e2/tempworkdir-l/src /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-8a025cf8-8f08d8e2/tempworkdir-l/tests /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-8a025cf8-8f08d8e2/tempworkdir-l 11  > __res
Running test command:
/home/ubuntu/spr-fast/tools/grep-test.py /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-8a025cf8-8f08d8e2/tempworkdir-l/src /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-8a025cf8-8f08d8e2/tempworkdir-l/tests /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-8a025cf8-8f08d8e2/tempworkdir-l 14  > __res
Running test command:
/home/ubuntu/spr-fast/tools/grep-test.py /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-8a025cf8-8f08d8e2/tempworkdir-l/src /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-8a025cf8-8f08d8e2/tempworkdir-l/tests /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-8a025cf8-8f08d8e2/tempworkdir-l 17  > __res
Running test command:
/home/ubuntu/spr-fast/tools/grep-test.py /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-8a025cf8-8f08d8e2/tempworkdir-l/src /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-8a025cf8-8f08d8e2/tempworkdir-l/tests /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-8a025cf8-8f08d8e2/tempworkdir-l 22  > __res
Passed Positive Cases
Collect values for post processing!
WRITING TO ISNEG:/tmp/neg.tmp!
Running test command:
/home/ubuntu/spr-fast/tools/grep-test.py /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-8a025cf8-8f08d8e2/tempworkdir-l/src /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-8a025cf8-8f08d8e2/tempworkdir-l/tests /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-8a025cf8-8f08d8e2/tempworkdir-l 0  > __res
Running test command:
/home/ubuntu/spr-fast/tools/grep-test.py /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-8a025cf8-8f08d8e2/tempworkdir-l/src /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-8a025cf8-8f08d8e2/tempworkdir-l/tests /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-8a025cf8-8f08d8e2/tempworkdir-l 11  > __res
Running test command:
/home/ubuntu/spr-fast/tools/grep-test.py /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-8a025cf8-8f08d8e2/tempworkdir-l/src /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-8a025cf8-8f08d8e2/tempworkdir-l/tests /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-8a025cf8-8f08d8e2/tempworkdir-l 14  > __res
Running test command:
/home/ubuntu/spr-fast/tools/grep-test.py /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-8a025cf8-8f08d8e2/tempworkdir-l/src /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-8a025cf8-8f08d8e2/tempworkdir-l/tests /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-8a025cf8-8f08d8e2/tempworkdir-l 17  > __res
Running test command:
/home/ubuntu/spr-fast/tools/grep-test.py /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-8a025cf8-8f08d8e2/tempworkdir-l/src /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-8a025cf8-8f08d8e2/tempworkdir-l/tests /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-8a025cf8-8f08d8e2/tempworkdir-l 22  > __res
Passed!
CondTester, Postprocessing instance id 44:
//src_file:src/dfasearch.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); void* memset(void*, int, unsigned long); 
/* dfasearch.c - searching subroutines using dfa and regex for grep.
   Copyright 1992, 1998, 2000, 2007, 2009-2010 Free Software Foundation, Inc.

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 3, or (at your option)
   any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program; if not, write to the Free Software
   Foundation, Inc., 51 Franklin Street - Fifth Floor, Boston, MA
   02110-1301, USA.  */

/* Written August 1992 by Mike Haertel. */

#include <config.h>
#include "search.h"
#include "dfa.h"

/* For -w, we also consider _ to be word constituent.  */
#define WCHAR(C) (ISALNUM(C) || (C) == '_')

/* KWset compiled pattern.  For Ecompile and Gcompile, we compile
   a list of strings, at least one of which is known to occur in
   any string matching the regexp. */
static kwset_t kwset;

/* DFA compiled regexp. */
static struct dfa dfa;

/* The Regex compiled patterns.  */
static struct patterns
{
  /* Regex compiled regexp. */
  struct re_pattern_buffer regexbuf;
  struct re_registers regs; /* This is here on account of a BRAIN-DEAD
			       Q@#%!# library interface in regex.c.  */
} patterns0;

struct patterns *patterns;
size_t pcount;

void
dfaerror (char const *mesg)
{
  error (EXIT_TROUBLE, 0, "%s", mesg);

  /* notreached */
  /* Tell static analyzers that this function does not return.  */
  abort ();
}

/* Number of compiled fixed strings known to exactly match the regexp.
   If kwsexec returns < kwset_exact_matches, then we don't need to
   call the regexp matcher at all. */
static int kwset_exact_matches;

static char const *
kwsincr_case (const char *must)
{
  const char *buf;
  size_t n;

  n = strlen (must);
#ifdef MBS_SUPPORT
  if (match_icase && MB_CUR_MAX > 1)
    buf = mbtolower (must, &n);
  else
#endif
    buf = must;
  return kwsincr (kwset, buf, n);
}

/* If the DFA turns out to have some set of fixed strings one of
   which must occur in the match, then we build a kwset matcher
   to find those strings, and thus quickly filter out impossible
   matches. */
static void
kwsmusts (void)
{
  struct dfamust const *dm;
  char const *err;

  if (dfa.musts)
    {
      kwsinit (&kwset);
      /* First, we compile in the substrings known to be exact
	 matches.  The kwset matcher will return the index
	 of the matching string that it chooses. */
      for (dm = dfa.musts; dm; dm = dm->next)
	{
	  if (!dm->exact)
	    continue;
	  ++kwset_exact_matches;
	  if ((err = kwsincr_case (dm->must)) != NULL)
	    error (EXIT_TROUBLE, 0, "%s", err);
	}
      /* Now, we compile the substrings that will require
	 the use of the regexp matcher.  */
      for (dm = dfa.musts; dm; dm = dm->next)
	{
	  if (dm->exact)
	    continue;
	  if ((err = kwsincr_case (dm->must)) != NULL)
	    error (EXIT_TROUBLE, 0, "%s", err);
	}
      if ((err = kwsprep (kwset)) != NULL)
	error (EXIT_TROUBLE, 0, "%s", err);
    }
}

void
GEAcompile (char const *pattern, size_t size, reg_syntax_t syntax_bits)
{
  const char *err;
  const char *p, *sep;
  size_t total = size;
  char *motif;

  if (match_icase)
    syntax_bits |= RE_ICASE;
  re_set_syntax (syntax_bits);
  dfasyntax (syntax_bits, match_icase, eolbyte);

  /* For GNU regex compiler we have to pass the patterns separately to detect
     errors like "[\nallo\n]\n".  The patterns here are "[", "allo" and "]"
     GNU regex should have raise a syntax error.  The same for backref, where
     the backref should have been local to each pattern.  */
  p = pattern;
  do
    {
      size_t len;
      sep = memchr (p, '\n', total);
      if (sep)
	{
	  len = sep - p;
	  sep++;
	  total -= (len + 1);
	}
      else
	{
	  len = total;
	  total = 0;
	}

      patterns = realloc (patterns, (pcount + 1) * sizeof (*patterns));
      if (patterns == NULL)
	error (EXIT_TROUBLE, errno, _("memory exhausted"));
      patterns[pcount] = patterns0;

      if ((err = re_compile_pattern (p, len,
				    &(patterns[pcount].regexbuf))) != NULL)
	error (EXIT_TROUBLE, 0, "%s", err);
      pcount++;

      p = sep;
    } while (sep && total != 0);

  /* In the match_words and match_lines cases, we use a different pattern
     for the DFA matcher that will quickly throw out cases that won't work.
     Then if DFA succeeds we do some hairy stuff using the regex matcher
     to decide whether the match should really count. */
  if (match_words || match_lines)
    {
      static char const line_beg_no_bk[] = "^(";
      static char const line_end_no_bk[] = ")$";
      static char const word_beg_no_bk[] = "(^|[^[:alnum:]_])(";
      static char const word_end_no_bk[] = ")([^[:alnum:]_]|$)";
      static char const line_beg_bk[] = "^\\(";
      static char const line_end_bk[] = "\\)$";
      static char const word_beg_bk[] = "\\(^\\|[^[:alnum:]_]\\)\\(";
      static char const word_end_bk[] = "\\)\\([^[:alnum:]_]\\|$\\)";
      int bk = !(syntax_bits & RE_NO_BK_PARENS);
      char *n = xmalloc (sizeof word_beg_bk - 1 + size + sizeof word_end_bk);

      strcpy (n, match_lines ? (bk ? line_beg_bk : line_beg_no_bk)
			     : (bk ? word_beg_bk : word_beg_no_bk));
      total = strlen(n);
      memcpy (n + total, pattern, size);
      total += size;
      strcpy (n + total, match_lines ? (bk ? line_end_bk : line_end_no_bk)
				     : (bk ? word_end_bk : word_end_no_bk));
      total += strlen (n + total);
      pattern = motif = n;
      size = total;
    }
  else
    motif = NULL;

  dfacomp (pattern, size, &dfa, 1);
  kwsmusts ();

  free(motif);
}

size_t
EGexecute (char const *buf, size_t size, size_t *match_size,
	   char const *start_ptr)
{
  char const *buflim, *beg, *end, *match, *best_match, *mb_start;
  char eol = eolbyte;
  int backref, start, len, best_len;
  struct kwsmatch kwsm;
  size_t i, ret_val;
#ifdef MBS_SUPPORT
  if (MB_CUR_MAX > 1)
    {
      if (match_icase)
        {
          /* mbtolower adds a NUL byte at the end.  That will provide
	     space for the sentinel byte dfaexec may add.  */
          char *case_buf = mbtolower (buf, &size);
	  if (start_ptr)
	    start_ptr = case_buf + (start_ptr - buf);
          buf = case_buf;
        }
    }
#endif /* MBS_SUPPORT */

  mb_start = buf;
  buflim = buf + size;

  for (beg = end = buf; end < buflim; beg = end)
    {
      if (!start_ptr)
	{
	  /* We don't care about an exact match.  */
	  if (kwset)
	    {
	      /* Find a possible match using the KWset matcher. */
	      size_t offset = kwsexec (kwset, beg, buflim - beg, &kwsm);
	      if (offset == (size_t) -1)
		goto failure;
	      beg += offset;
	      /* Narrow down to the line containing the candidate, and
		 run it through DFA. */
	      if ((end = memchr(beg, eol, buflim - beg)) != NULL)
	        end++;
              else
                end = buflim;
	      match = beg;
	      while (beg > buf && beg[-1] != eol)
		--beg;
	      if (kwsm.index < kwset_exact_matches)
                {
#ifdef MBS_SUPPORT
                  if (mb_start < beg)
                    mb_start = beg;
                  if (MB_CUR_MAX == 1 || !is_mb_middle (&mb_start, match, buflim))
#endif
                    goto success;
                }
	      if (dfaexec (&dfa, beg, (char *) end, 0, NULL, &backref) == NULL)
		continue;
	    }
	  else
	    {
	      /* No good fixed strings; start with DFA. */
	      char const *next_beg = dfaexec (&dfa, beg, (char *) buflim,
					      0, NULL, &backref);
	      if (next_beg == NULL)
		break;
	      /* Narrow down to the line we've found. */
	      beg = next_beg;
	      if ((end = memchr(beg, eol, buflim - beg)) != NULL)
	        end++;
              else
                end = buflim;
	      while (beg > buf && beg[-1] != eol)
		--beg;
	    }
	  /* Successful, no backreferences encountered! */
	  
//Patch 0:
if ((!backref) || (__is_neg(25, &(backref), sizeof (backref), &(beg), sizeof (beg), &(buf), sizeof (buf), &(eol), sizeof (eol), &(buflim), sizeof (buflim), &(end), sizeof (end), &(start_ptr), sizeof (start_ptr), &(best_match), sizeof (best_match), &(best_len), sizeof (best_len), &(i), sizeof (i), &(pcount), sizeof (pcount), &(patterns), sizeof (patterns), &(start), sizeof (start), &(len), sizeof (len), &(match), sizeof (match), &(mb_start), sizeof (mb_start), &(match_words), sizeof (match_words), &(match_lines), sizeof (match_lines), &(kwset_exact_matches), sizeof (kwset_exact_matches), &(kwset), sizeof (kwset), &(size), sizeof (size), &(match_icase), sizeof (match_icase), &(eolbyte), sizeof (eolbyte), &(ret_val), sizeof (ret_val), &(match_size), sizeof (match_size))))
    goto success;

//CodeSeg 1:
	}
      else
	{
	  /* We are looking for the leftmost (then longest) exact match.
	     We will go through the outer loop only once.  */
	  beg = start_ptr;
	  end = buflim;
	}

      /* If we've made it to this point, this means DFA has seen
	 a probable match, and we need to run it through Regex. */
      best_match = end;
      best_len = 0;
      for (i = 0; i < pcount; i++)
	{
	  patterns[i].regexbuf.not_eol = 0;
	  if (0 <= (start = re_search (&(patterns[i].regexbuf),
				       buf, end - buf - 1,
				       beg - buf, end - beg - 1,
				       &(patterns[i].regs))))
	    {
	      len = patterns[i].regs.end[0] - start;
	      match = buf + start;
	      if (match > best_match)
		continue;
	      if (start_ptr && !match_words)
		goto assess_pattern_match;
	      if ((!match_lines && !match_words)
		  || (match_lines && len == end - beg - 1))
		{
		  match = beg;
		  len = end - beg;
		  goto assess_pattern_match;
		}
	      /* If -w, check if the match aligns with word boundaries.
		 We do this iteratively because:
		 (a) the line may contain more than one occurence of the
		 pattern, and
		 (b) Several alternatives in the pattern might be valid at a
		 given point, and we may need to consider a shorter one to
		 find a word boundary.  */
	      if (match_words)
		while (match <= best_match)
		  {
		    if ((match == buf || !WCHAR ((unsigned char) match[-1]))
			&& (len == end - beg - 1
			    || !WCHAR ((unsigned char) match[len])))
		      goto assess_pattern_match;
		    if (len > 0)
		      {
			/* Try a shorter length anchored at the same place. */
			--len;
			patterns[i].regexbuf.not_eol = 1;
			len = re_match (&(patterns[i].regexbuf),
					buf, match + len - beg, match - buf,
					&(patterns[i].regs));
		      }
		    if (len <= 0)
		      {
			/* Try looking further on. */
			if (match == end - 1)
			  break;
			match++;
			patterns[i].regexbuf.not_eol = 0;
			start = re_search (&(patterns[i].regexbuf),
					   buf, end - buf - 1,
					   match - buf, end - match - 1,
					   &(patterns[i].regs));
			if (start < 0)
			  break;
			len = patterns[i].regs.end[0] - start;
			match = buf + start;
		      }
		  } /* while (match <= best_match) */
	      continue;
	    assess_pattern_match:
	      if (!start_ptr)
		{
		  /* Good enough for a non-exact match.
		     No need to look at further patterns, if any.  */
		  beg = match;
		  goto success_in_len;
		}
	      if (match < best_match || (match == best_match && len > best_len))
		{
		  /* Best exact match:  leftmost, then longest.  */
		  best_match = match;
		  best_len = len;
		}
	    } /* if re_search >= 0 */
	} /* for Regex patterns.  */
	if (best_match < end)
	  {
	    /* We have found an exact match.  We were just
	       waiting for the best one (leftmost then longest).  */
	    beg = best_match;
	    len = best_len;
	    goto success_in_len;
	  }
    } /* for (beg = end ..) */

 failure:
  ret_val = -1;
  goto out;

 success:
  len = end - beg;
 success_in_len:
  *match_size = len;
  ret_val = beg - buf;
 out:
  return ret_val;
}

Trying a synthesis expr 1
Building:src at:
/home/ubuntu/spr-fast/tests/corebench/grep/grep-case-8a025cf8-8f08d8e2/tempworkdir-l/srcVerifing Negative cases!
Running test command:
/home/ubuntu/spr-fast/tools/grep-test.py /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-8a025cf8-8f08d8e2/tempworkdir-l/src /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-8a025cf8-8f08d8e2/tempworkdir-l/tests /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-8a025cf8-8f08d8e2/tempworkdir-l 0  > __res
Verifying positive cases
Running test command:
/home/ubuntu/spr-fast/tools/grep-test.py /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-8a025cf8-8f08d8e2/tempworkdir-l/src /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-8a025cf8-8f08d8e2/tempworkdir-l/tests /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-8a025cf8-8f08d8e2/tempworkdir-l 11  > __res
Running test command:
/home/ubuntu/spr-fast/tools/grep-test.py /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-8a025cf8-8f08d8e2/tempworkdir-l/src /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-8a025cf8-8f08d8e2/tempworkdir-l/tests /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-8a025cf8-8f08d8e2/tempworkdir-l 14  > __res
Running test command:
/home/ubuntu/spr-fast/tools/grep-test.py /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-8a025cf8-8f08d8e2/tempworkdir-l/src /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-8a025cf8-8f08d8e2/tempworkdir-l/tests /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-8a025cf8-8f08d8e2/tempworkdir-l 17  > __res
Running test command:
/home/ubuntu/spr-fast/tools/grep-test.py /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-8a025cf8-8f08d8e2/tempworkdir-l/src /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-8a025cf8-8f08d8e2/tempworkdir-l/tests /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-8a025cf8-8f08d8e2/tempworkdir-l 22  > __res
Passed Positive Cases
Passed!
Passed with updated best score 19999956.000000
a batched test job starts!
Building merged code:
src_file: src/dfasearch.c
full src: int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); void* memset(void*, int, unsigned long); 
/* dfasearch.c - searching subroutines using dfa and regex for grep.
   Copyright 1992, 1998, 2000, 2007, 2009-2010 Free Software Foundation, Inc.

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 3, or (at your option)
   any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program; if not, write to the Free Software
   Foundation, Inc., 51 Franklin Street - Fifth Floor, Boston, MA
   02110-1301, USA.  */

/* Written August 1992 by Mike Haertel. */

#include <config.h>
#include "search.h"
#include "dfa.h"

/* For -w, we also consider _ to be word constituent.  */
#define WCHAR(C) (ISALNUM(C) || (C) == '_')

/* KWset compiled pattern.  For Ecompile and Gcompile, we compile
   a list of strings, at least one of which is known to occur in
   any string matching the regexp. */
static kwset_t kwset;

/* DFA compiled regexp. */
static struct dfa dfa;

/* The Regex compiled patterns.  */
static struct patterns
{
  /* Regex compiled regexp. */
  struct re_pattern_buffer regexbuf;
  struct re_registers regs; /* This is here on account of a BRAIN-DEAD
			       Q@#%!# library interface in regex.c.  */
} patterns0;

struct patterns *patterns;
size_t pcount;

void
dfaerror (char const *mesg)
{
  error (EXIT_TROUBLE, 0, "%s", mesg);

  /* notreached */
  /* Tell static analyzers that this function does not return.  */
  abort ();
}

/* Number of compiled fixed strings known to exactly match the regexp.
   If kwsexec returns < kwset_exact_matches, then we don't need to
   call the regexp matcher at all. */
static int kwset_exact_matches;

static char const *
kwsincr_case (const char *must)
{
  const char *buf;
  size_t n;

  n = strlen (must);
#ifdef MBS_SUPPORT
  if (match_icase && MB_CUR_MAX > 1)
    buf = mbtolower (must, &n);
  else
#endif
    buf = must;
  return kwsincr (kwset, buf, n);
}

/* If the DFA turns out to have some set of fixed strings one of
   which must occur in the match, then we build a kwset matcher
   to find those strings, and thus quickly filter out impossible
   matches. */
static void
kwsmusts (void)
{
  struct dfamust const *dm;
  char const *err;

  if (dfa.musts)
    {
      kwsinit (&kwset);
      /* First, we compile in the substrings known to be exact
	 matches.  The kwset matcher will return the index
	 of the matching string that it chooses. */
      for (dm = dfa.musts; dm; dm = dm->next)
	{
	  if (!dm->exact)
	    continue;
	  ++kwset_exact_matches;
	  if ((err = kwsincr_case (dm->must)) != NULL)
	    error (EXIT_TROUBLE, 0, "%s", err);
	}
      /* Now, we compile the substrings that will require
	 the use of the regexp matcher.  */
      for (dm = dfa.musts; dm; dm = dm->next)
	{
	  if (dm->exact)
	    continue;
	  if ((err = kwsincr_case (dm->must)) != NULL)
	    error (EXIT_TROUBLE, 0, "%s", err);
	}
      if ((err = kwsprep (kwset)) != NULL)
	error (EXIT_TROUBLE, 0, "%s", err);
    }
}

void
GEAcompile (char const *pattern, size_t size, reg_syntax_t syntax_bits)
{
  const char *err;
  const char *p, *sep;
  size_t total = size;
  char *motif;

  if (match_icase)
    syntax_bits |= RE_ICASE;
  re_set_syntax (syntax_bits);
  dfasyntax (syntax_bits, match_icase, eolbyte);

  /* For GNU regex compiler we have to pass the patterns separately to detect
     errors like "[\nallo\n]\n".  The patterns here are "[", "allo" and "]"
     GNU regex should have raise a syntax error.  The same for backref, where
     the backref should have been local to each pattern.  */
  p = pattern;
  do
    {
      size_t len;
      sep = memchr (p, '\n', total);
      if (sep)
	{
	  len = sep - p;
	  sep++;
	  total -= (len + 1);
	}
      else
	{
	  len = total;
	  total = 0;
	}

      patterns = realloc (patterns, (pcount + 1) * sizeof (*patterns));
      if (patterns == NULL)
	error (EXIT_TROUBLE, errno, _("memory exhausted"));
      patterns[pcount] = patterns0;

      if ((err = re_compile_pattern (p, len,
				    &(patterns[pcount].regexbuf))) != NULL)
	error (EXIT_TROUBLE, 0, "%s", err);
      pcount++;

      p = sep;
    } while (sep && total != 0);

  /* In the match_words and match_lines cases, we use a different pattern
     for the DFA matcher that will quickly throw out cases that won't work.
     Then if DFA succeeds we do some hairy stuff using the regex matcher
     to decide whether the match should really count. */
  if (match_words || match_lines)
    {
      static char const line_beg_no_bk[] = "^(";
      static char const line_end_no_bk[] = ")$";
      static char const word_beg_no_bk[] = "(^|[^[:alnum:]_])(";
      static char const word_end_no_bk[] = ")([^[:alnum:]_]|$)";
      static char const line_beg_bk[] = "^\\(";
      static char const line_end_bk[] = "\\)$";
      static char const word_beg_bk[] = "\\(^\\|[^[:alnum:]_]\\)\\(";
      static char const word_end_bk[] = "\\)\\([^[:alnum:]_]\\|$\\)";
      int bk = !(syntax_bits & RE_NO_BK_PARENS);
      char *n = xmalloc (sizeof word_beg_bk - 1 + size + sizeof word_end_bk);

      strcpy (n, match_lines ? (bk ? line_beg_bk : line_beg_no_bk)
			     : (bk ? word_beg_bk : word_beg_no_bk));
      total = strlen(n);
      memcpy (n + total, pattern, size);
      total += size;
      strcpy (n + total, match_lines ? (bk ? line_end_bk : line_end_no_bk)
				     : (bk ? word_end_bk : word_end_no_bk));
      total += strlen (n + total);
      pattern = motif = n;
      size = total;
    }
  else
    motif = NULL;

  dfacomp (pattern, size, &dfa, 1);
  kwsmusts ();

  free(motif);
}

size_t
EGexecute (char const *buf, size_t size, size_t *match_size,
	   char const *start_ptr)
{
  char const *buflim, *beg, *end, *match, *best_match, *mb_start;
  char eol = eolbyte;
  int backref, start, len, best_len;
  struct kwsmatch kwsm;
  size_t i, ret_val;
#ifdef MBS_SUPPORT
  if (MB_CUR_MAX > 1)
    {
      if (match_icase)
        {
          /* mbtolower adds a NUL byte at the end.  That will provide
	     space for the sentinel byte dfaexec may add.  */
          char *case_buf = mbtolower (buf, &size);
	  if (start_ptr)
	    start_ptr = case_buf + (start_ptr - buf);
          buf = case_buf;
        }
    }
#endif /* MBS_SUPPORT */

  mb_start = buf;
  buflim = buf + size;

  for (beg = end = buf; end < buflim; beg = end)
    {
      if (!start_ptr)
	{
	  /* We don't care about an exact match.  */
	  if (kwset)
	    {
	      /* Find a possible match using the KWset matcher. */
	      size_t offset = kwsexec (kwset, beg, buflim - beg, &kwsm);
	      if (offset == (size_t) -1)
		goto failure;
	      beg += offset;
	      /* Narrow down to the line containing the candidate, and
		 run it through DFA. */
	      if ((end = memchr(beg, eol, buflim - beg)) != NULL)
	        end++;
              else
                end = buflim;
	      match = beg;
	      while (beg > buf && beg[-1] != eol)
		--beg;
	      if (kwsm.index < kwset_exact_matches)
                {
#ifdef MBS_SUPPORT
                  if (mb_start < beg)
                    mb_start = beg;
                  if (MB_CUR_MAX == 1 || !is_mb_middle (&mb_start, match, buflim))
#endif
                    goto success;
                }
	      if (dfaexec (&dfa, beg, (char *) end, 0, NULL, &backref) == NULL)
		continue;
	    }
	  else
	    {
	      /* No good fixed strings; start with DFA. */
	      char const *next_beg = dfaexec (&dfa, beg, (char *) buflim,
					      0, NULL, &backref);
	      if (next_beg == NULL)
		break;
	      /* Narrow down to the line we've found. */
	      beg = next_beg;
	      if ((end = memchr(beg, eol, buflim - beg)) != NULL)
	        end++;
              else
                end = buflim;
	      while (beg > buf && beg[-1] != eol)
		--beg;
	    }
	  /* Successful, no backreferences encountered! */
	  if (!backref)
	    goto success;
	}
      else
	{
	  /* We are looking for the leftmost (then longest) exact match.
	     We will go through the outer loop only once.  */
	  beg = start_ptr;
	  end = buflim;
	}

      /* If we've made it to this point, this means DFA has seen
	 a probable match, and we need to run it through Regex. */
      best_match = end;
      best_len = 0;
      for (i = 0; i < pcount; i++)
	{
	  //prophet generated patch
	  if (__get_mutant()==0) {
	  if ((__is_neg(39, &(i), sizeof (i), &(patterns), sizeof (patterns), &(patterns[i].regexbuf.not_eol), sizeof (patterns[i].regexbuf.not_eol), &(start), sizeof (start), &(buf), sizeof (buf), &(end), sizeof (end), &(pcount), sizeof (pcount), &(beg), sizeof (beg), &(best_len), sizeof (best_len), &(best_match), sizeof (best_match), &(len), sizeof (len), &(match), sizeof (match), &(buflim), sizeof (buflim), &(start_ptr), sizeof (start_ptr), &(match_words), sizeof (match_words), &(match_lines), sizeof (match_lines), &(backref), sizeof (backref), &(eol), sizeof (eol), &(mb_start), sizeof (mb_start), &(kwset_exact_matches), sizeof (kwset_exact_matches), &(kwset), sizeof (kwset), &(size), sizeof (size), &(match_icase), sizeof (match_icase), &(ret_val), sizeof (ret_val), &(eolbyte), sizeof (eolbyte), &(match_size), sizeof (match_size), &(patterns[i].regexbuf.buffer), sizeof (patterns[i].regexbuf.buffer), &(patterns[i].regexbuf.allocated), sizeof (patterns[i].regexbuf.allocated), &(patterns[i].regexbuf.used), sizeof (patterns[i].regexbuf.used), &(patterns[i].regexbuf.syntax), sizeof (patterns[i].regexbuf.syntax), &(patterns[i].regexbuf.fastmap), sizeof (patterns[i].regexbuf.fastmap), &(patterns[i].regexbuf.translate), sizeof (patterns[i].regexbuf.translate), &(patterns[i].regexbuf.re_nsub), sizeof (patterns[i].regexbuf.re_nsub), &(patterns[i].regexbuf.can_be_null), sizeof (patterns[i].regexbuf.can_be_null), &(patterns[i].regexbuf.regs_allocated), sizeof (patterns[i].regexbuf.regs_allocated), &(patterns[i].regexbuf.fastmap_accurate), sizeof (patterns[i].regexbuf.fastmap_accurate), &(patterns[i].regexbuf.no_sub), sizeof (patterns[i].regexbuf.no_sub), &(patterns[i].regexbuf.not_bol), sizeof (patterns[i].regexbuf.not_bol), &(patterns[i].regexbuf.newline_anchor), sizeof (patterns[i].regexbuf.newline_anchor))))
	      goto assess_pattern_match;
	  patterns[i].regexbuf.not_eol = 0;
	  }
	  else if (__get_mutant()==1) {
	  if ((__is_neg(39, &(i), sizeof (i), &(patterns), sizeof (patterns), &(patterns[i].regexbuf.not_eol), sizeof (patterns[i].regexbuf.not_eol), &(start), sizeof (start), &(buf), sizeof (buf), &(end), sizeof (end), &(pcount), sizeof (pcount), &(beg), sizeof (beg), &(best_len), sizeof (best_len), &(best_match), sizeof (best_match), &(len), sizeof (len), &(match), sizeof (match), &(buflim), sizeof (buflim), &(start_ptr), sizeof (start_ptr), &(match_words), sizeof (match_words), &(match_lines), sizeof (match_lines), &(backref), sizeof (backref), &(eol), sizeof (eol), &(mb_start), sizeof (mb_start), &(kwset_exact_matches), sizeof (kwset_exact_matches), &(kwset), sizeof (kwset), &(size), sizeof (size), &(match_icase), sizeof (match_icase), &(ret_val), sizeof (ret_val), &(eolbyte), sizeof (eolbyte), &(match_size), sizeof (match_size), &(patterns[i].regexbuf.buffer), sizeof (patterns[i].regexbuf.buffer), &(patterns[i].regexbuf.allocated), sizeof (patterns[i].regexbuf.allocated), &(patterns[i].regexbuf.used), sizeof (patterns[i].regexbuf.used), &(patterns[i].regexbuf.syntax), sizeof (patterns[i].regexbuf.syntax), &(patterns[i].regexbuf.fastmap), sizeof (patterns[i].regexbuf.fastmap), &(patterns[i].regexbuf.translate), sizeof (patterns[i].regexbuf.translate), &(patterns[i].regexbuf.re_nsub), sizeof (patterns[i].regexbuf.re_nsub), &(patterns[i].regexbuf.can_be_null), sizeof (patterns[i].regexbuf.can_be_null), &(patterns[i].regexbuf.regs_allocated), sizeof (patterns[i].regexbuf.regs_allocated), &(patterns[i].regexbuf.fastmap_accurate), sizeof (patterns[i].regexbuf.fastmap_accurate), &(patterns[i].regexbuf.no_sub), sizeof (patterns[i].regexbuf.no_sub), &(patterns[i].regexbuf.not_bol), sizeof (patterns[i].regexbuf.not_bol), &(patterns[i].regexbuf.newline_anchor), sizeof (patterns[i].regexbuf.newline_anchor))))
	      goto failure;
	  patterns[i].regexbuf.not_eol = 0;
	  }
	  else if (__get_mutant()==2) {
	  if ((__is_neg(39, &(i), sizeof (i), &(patterns), sizeof (patterns), &(patterns[i].regexbuf.not_eol), sizeof (patterns[i].regexbuf.not_eol), &(start), sizeof (start), &(buf), sizeof (buf), &(end), sizeof (end), &(pcount), sizeof (pcount), &(beg), sizeof (beg), &(best_len), sizeof (best_len), &(best_match), sizeof (best_match), &(len), sizeof (len), &(match), sizeof (match), &(buflim), sizeof (buflim), &(start_ptr), sizeof (start_ptr), &(match_words), sizeof (match_words), &(match_lines), sizeof (match_lines), &(backref), sizeof (backref), &(eol), sizeof (eol), &(mb_start), sizeof (mb_start), &(kwset_exact_matches), sizeof (kwset_exact_matches), &(kwset), sizeof (kwset), &(size), sizeof (size), &(match_icase), sizeof (match_icase), &(ret_val), sizeof (ret_val), &(eolbyte), sizeof (eolbyte), &(match_size), sizeof (match_size), &(patterns[i].regexbuf.buffer), sizeof (patterns[i].regexbuf.buffer), &(patterns[i].regexbuf.allocated), sizeof (patterns[i].regexbuf.allocated), &(patterns[i].regexbuf.used), sizeof (patterns[i].regexbuf.used), &(patterns[i].regexbuf.syntax), sizeof (patterns[i].regexbuf.syntax), &(patterns[i].regexbuf.fastmap), sizeof (patterns[i].regexbuf.fastmap), &(patterns[i].regexbuf.translate), sizeof (patterns[i].regexbuf.translate), &(patterns[i].regexbuf.re_nsub), sizeof (patterns[i].regexbuf.re_nsub), &(patterns[i].regexbuf.can_be_null), sizeof (patterns[i].regexbuf.can_be_null), &(patterns[i].regexbuf.regs_allocated), sizeof (patterns[i].regexbuf.regs_allocated), &(patterns[i].regexbuf.fastmap_accurate), sizeof (patterns[i].regexbuf.fastmap_accurate), &(patterns[i].regexbuf.no_sub), sizeof (patterns[i].regexbuf.no_sub), &(patterns[i].regexbuf.not_bol), sizeof (patterns[i].regexbuf.not_bol), &(patterns[i].regexbuf.newline_anchor), sizeof (patterns[i].regexbuf.newline_anchor))))
	      goto success;
	  patterns[i].regexbuf.not_eol = 0;
	  }
	  else if (__get_mutant()==3) {
	  if ((__is_neg(39, &(i), sizeof (i), &(patterns), sizeof (patterns), &(patterns[i].regexbuf.not_eol), sizeof (patterns[i].regexbuf.not_eol), &(start), sizeof (start), &(buf), sizeof (buf), &(end), sizeof (end), &(pcount), sizeof (pcount), &(beg), sizeof (beg), &(best_len), sizeof (best_len), &(best_match), sizeof (best_match), &(len), sizeof (len), &(match), sizeof (match), &(buflim), sizeof (buflim), &(start_ptr), sizeof (start_ptr), &(match_words), sizeof (match_words), &(match_lines), sizeof (match_lines), &(backref), sizeof (backref), &(eol), sizeof (eol), &(mb_start), sizeof (mb_start), &(kwset_exact_matches), sizeof (kwset_exact_matches), &(kwset), sizeof (kwset), &(size), sizeof (size), &(match_icase), sizeof (match_icase), &(ret_val), sizeof (ret_val), &(eolbyte), sizeof (eolbyte), &(match_size), sizeof (match_size), &(patterns[i].regexbuf.buffer), sizeof (patterns[i].regexbuf.buffer), &(patterns[i].regexbuf.allocated), sizeof (patterns[i].regexbuf.allocated), &(patterns[i].regexbuf.used), sizeof (patterns[i].regexbuf.used), &(patterns[i].regexbuf.syntax), sizeof (patterns[i].regexbuf.syntax), &(patterns[i].regexbuf.fastmap), sizeof (patterns[i].regexbuf.fastmap), &(patterns[i].regexbuf.translate), sizeof (patterns[i].regexbuf.translate), &(patterns[i].regexbuf.re_nsub), sizeof (patterns[i].regexbuf.re_nsub), &(patterns[i].regexbuf.can_be_null), sizeof (patterns[i].regexbuf.can_be_null), &(patterns[i].regexbuf.regs_allocated), sizeof (patterns[i].regexbuf.regs_allocated), &(patterns[i].regexbuf.fastmap_accurate), sizeof (patterns[i].regexbuf.fastmap_accurate), &(patterns[i].regexbuf.no_sub), sizeof (patterns[i].regexbuf.no_sub), &(patterns[i].regexbuf.not_bol), sizeof (patterns[i].regexbuf.not_bol), &(patterns[i].regexbuf.newline_anchor), sizeof (patterns[i].regexbuf.newline_anchor))))
	      goto success_in_len;
	  patterns[i].regexbuf.not_eol = 0;
	  }
	  else if (__get_mutant()==4) {
	  if ((__is_neg(39, &(i), sizeof (i), &(patterns), sizeof (patterns), &(patterns[i].regexbuf.not_eol), sizeof (patterns[i].regexbuf.not_eol), &(start), sizeof (start), &(buf), sizeof (buf), &(end), sizeof (end), &(pcount), sizeof (pcount), &(beg), sizeof (beg), &(best_len), sizeof (best_len), &(best_match), sizeof (best_match), &(len), sizeof (len), &(match), sizeof (match), &(buflim), sizeof (buflim), &(start_ptr), sizeof (start_ptr), &(match_words), sizeof (match_words), &(match_lines), sizeof (match_lines), &(backref), sizeof (backref), &(eol), sizeof (eol), &(mb_start), sizeof (mb_start), &(kwset_exact_matches), sizeof (kwset_exact_matches), &(kwset), sizeof (kwset), &(size), sizeof (size), &(match_icase), sizeof (match_icase), &(ret_val), sizeof (ret_val), &(eolbyte), sizeof (eolbyte), &(match_size), sizeof (match_size), &(patterns[i].regexbuf.buffer), sizeof (patterns[i].regexbuf.buffer), &(patterns[i].regexbuf.allocated), sizeof (patterns[i].regexbuf.allocated), &(patterns[i].regexbuf.used), sizeof (patterns[i].regexbuf.used), &(patterns[i].regexbuf.syntax), sizeof (patterns[i].regexbuf.syntax), &(patterns[i].regexbuf.fastmap), sizeof (patterns[i].regexbuf.fastmap), &(patterns[i].regexbuf.translate), sizeof (patterns[i].regexbuf.translate), &(patterns[i].regexbuf.re_nsub), sizeof (patterns[i].regexbuf.re_nsub), &(patterns[i].regexbuf.can_be_null), sizeof (patterns[i].regexbuf.can_be_null), &(patterns[i].regexbuf.regs_allocated), sizeof (patterns[i].regexbuf.regs_allocated), &(patterns[i].regexbuf.fastmap_accurate), sizeof (patterns[i].regexbuf.fastmap_accurate), &(patterns[i].regexbuf.no_sub), sizeof (patterns[i].regexbuf.no_sub), &(patterns[i].regexbuf.not_bol), sizeof (patterns[i].regexbuf.not_bol), &(patterns[i].regexbuf.newline_anchor), sizeof (patterns[i].regexbuf.newline_anchor))))
	      goto out;
	  patterns[i].regexbuf.not_eol = 0;
	  }
	  else if (__get_mutant()==5) {
	  if ((__is_neg(39, &(i), sizeof (i), &(patterns), sizeof (patterns), &(patterns[i].regexbuf.not_eol), sizeof (patterns[i].regexbuf.not_eol), &(start), sizeof (start), &(buf), sizeof (buf), &(end), sizeof (end), &(pcount), sizeof (pcount), &(beg), sizeof (beg), &(best_len), sizeof (best_len), &(best_match), sizeof (best_match), &(len), sizeof (len), &(match), sizeof (match), &(buflim), sizeof (buflim), &(start_ptr), sizeof (start_ptr), &(match_words), sizeof (match_words), &(match_lines), sizeof (match_lines), &(backref), sizeof (backref), &(eol), sizeof (eol), &(mb_start), sizeof (mb_start), &(kwset_exact_matches), sizeof (kwset_exact_matches), &(kwset), sizeof (kwset), &(size), sizeof (size), &(match_icase), sizeof (match_icase), &(ret_val), sizeof (ret_val), &(eolbyte), sizeof (eolbyte), &(match_size), sizeof (match_size), &(patterns[i].regexbuf.buffer), sizeof (patterns[i].regexbuf.buffer), &(patterns[i].regexbuf.allocated), sizeof (patterns[i].regexbuf.allocated), &(patterns[i].regexbuf.used), sizeof (patterns[i].regexbuf.used), &(patterns[i].regexbuf.syntax), sizeof (patterns[i].regexbuf.syntax), &(patterns[i].regexbuf.fastmap), sizeof (patterns[i].regexbuf.fastmap), &(patterns[i].regexbuf.translate), sizeof (patterns[i].regexbuf.translate), &(patterns[i].regexbuf.re_nsub), sizeof (patterns[i].regexbuf.re_nsub), &(patterns[i].regexbuf.can_be_null), sizeof (patterns[i].regexbuf.can_be_null), &(patterns[i].regexbuf.regs_allocated), sizeof (patterns[i].regexbuf.regs_allocated), &(patterns[i].regexbuf.fastmap_accurate), sizeof (patterns[i].regexbuf.fastmap_accurate), &(patterns[i].regexbuf.no_sub), sizeof (patterns[i].regexbuf.no_sub), &(patterns[i].regexbuf.not_bol), sizeof (patterns[i].regexbuf.not_bol), &(patterns[i].regexbuf.newline_anchor), sizeof (patterns[i].regexbuf.newline_anchor))))
	      return -1;
	  patterns[i].regexbuf.not_eol = 0;
	  }
	  else if (__get_mutant()==6) {
	  if ((__is_neg(39, &(i), sizeof (i), &(patterns), sizeof (patterns), &(patterns[i].regexbuf.not_eol), sizeof (patterns[i].regexbuf.not_eol), &(start), sizeof (start), &(buf), sizeof (buf), &(end), sizeof (end), &(pcount), sizeof (pcount), &(beg), sizeof (beg), &(best_len), sizeof (best_len), &(best_match), sizeof (best_match), &(len), sizeof (len), &(match), sizeof (match), &(buflim), sizeof (buflim), &(start_ptr), sizeof (start_ptr), &(match_words), sizeof (match_words), &(match_lines), sizeof (match_lines), &(backref), sizeof (backref), &(eol), sizeof (eol), &(mb_start), sizeof (mb_start), &(kwset_exact_matches), sizeof (kwset_exact_matches), &(kwset), sizeof (kwset), &(size), sizeof (size), &(match_icase), sizeof (match_icase), &(ret_val), sizeof (ret_val), &(eolbyte), sizeof (eolbyte), &(match_size), sizeof (match_size), &(patterns[i].regexbuf.buffer), sizeof (patterns[i].regexbuf.buffer), &(patterns[i].regexbuf.allocated), sizeof (patterns[i].regexbuf.allocated), &(patterns[i].regexbuf.used), sizeof (patterns[i].regexbuf.used), &(patterns[i].regexbuf.syntax), sizeof (patterns[i].regexbuf.syntax), &(patterns[i].regexbuf.fastmap), sizeof (patterns[i].regexbuf.fastmap), &(patterns[i].regexbuf.translate), sizeof (patterns[i].regexbuf.translate), &(patterns[i].regexbuf.re_nsub), sizeof (patterns[i].regexbuf.re_nsub), &(patterns[i].regexbuf.can_be_null), sizeof (patterns[i].regexbuf.can_be_null), &(patterns[i].regexbuf.regs_allocated), sizeof (patterns[i].regexbuf.regs_allocated), &(patterns[i].regexbuf.fastmap_accurate), sizeof (patterns[i].regexbuf.fastmap_accurate), &(patterns[i].regexbuf.no_sub), sizeof (patterns[i].regexbuf.no_sub), &(patterns[i].regexbuf.not_bol), sizeof (patterns[i].regexbuf.not_bol), &(patterns[i].regexbuf.newline_anchor), sizeof (patterns[i].regexbuf.newline_anchor))))
	      return 0;
	  patterns[i].regexbuf.not_eol = 0;
	  }
	  else if (__get_mutant()==7) {
	  if ((__is_neg(39, &(i), sizeof (i), &(patterns), sizeof (patterns), &(patterns[i].regexbuf.not_eol), sizeof (patterns[i].regexbuf.not_eol), &(start), sizeof (start), &(buf), sizeof (buf), &(end), sizeof (end), &(pcount), sizeof (pcount), &(beg), sizeof (beg), &(best_len), sizeof (best_len), &(best_match), sizeof (best_match), &(len), sizeof (len), &(match), sizeof (match), &(buflim), sizeof (buflim), &(start_ptr), sizeof (start_ptr), &(match_words), sizeof (match_words), &(match_lines), sizeof (match_lines), &(backref), sizeof (backref), &(eol), sizeof (eol), &(mb_start), sizeof (mb_start), &(kwset_exact_matches), sizeof (kwset_exact_matches), &(kwset), sizeof (kwset), &(size), sizeof (size), &(match_icase), sizeof (match_icase), &(ret_val), sizeof (ret_val), &(eolbyte), sizeof (eolbyte), &(match_size), sizeof (match_size), &(patterns[i].regexbuf.buffer), sizeof (patterns[i].regexbuf.buffer), &(patterns[i].regexbuf.allocated), sizeof (patterns[i].regexbuf.allocated), &(patterns[i].regexbuf.used), sizeof (patterns[i].regexbuf.used), &(patterns[i].regexbuf.syntax), sizeof (patterns[i].regexbuf.syntax), &(patterns[i].regexbuf.fastmap), sizeof (patterns[i].regexbuf.fastmap), &(patterns[i].regexbuf.translate), sizeof (patterns[i].regexbuf.translate), &(patterns[i].regexbuf.re_nsub), sizeof (patterns[i].regexbuf.re_nsub), &(patterns[i].regexbuf.can_be_null), sizeof (patterns[i].regexbuf.can_be_null), &(patterns[i].regexbuf.regs_allocated), sizeof (patterns[i].regexbuf.regs_allocated), &(patterns[i].regexbuf.fastmap_accurate), sizeof (patterns[i].regexbuf.fastmap_accurate), &(patterns[i].regexbuf.no_sub), sizeof (patterns[i].regexbuf.no_sub), &(patterns[i].regexbuf.not_bol), sizeof (patterns[i].regexbuf.not_bol), &(patterns[i].regexbuf.newline_anchor), sizeof (patterns[i].regexbuf.newline_anchor))))
	      return 1;
	  patterns[i].regexbuf.not_eol = 0;
	  }
	  else if (__get_mutant()==8) {
	  if ((__is_neg(39, &(i), sizeof (i), &(patterns), sizeof (patterns), &(patterns[i].regexbuf.not_eol), sizeof (patterns[i].regexbuf.not_eol), &(start), sizeof (start), &(buf), sizeof (buf), &(end), sizeof (end), &(pcount), sizeof (pcount), &(beg), sizeof (beg), &(best_len), sizeof (best_len), &(best_match), sizeof (best_match), &(len), sizeof (len), &(match), sizeof (match), &(buflim), sizeof (buflim), &(start_ptr), sizeof (start_ptr), &(match_words), sizeof (match_words), &(match_lines), sizeof (match_lines), &(backref), sizeof (backref), &(eol), sizeof (eol), &(mb_start), sizeof (mb_start), &(kwset_exact_matches), sizeof (kwset_exact_matches), &(kwset), sizeof (kwset), &(size), sizeof (size), &(match_icase), sizeof (match_icase), &(ret_val), sizeof (ret_val), &(eolbyte), sizeof (eolbyte), &(match_size), sizeof (match_size), &(patterns[i].regexbuf.buffer), sizeof (patterns[i].regexbuf.buffer), &(patterns[i].regexbuf.allocated), sizeof (patterns[i].regexbuf.allocated), &(patterns[i].regexbuf.used), sizeof (patterns[i].regexbuf.used), &(patterns[i].regexbuf.syntax), sizeof (patterns[i].regexbuf.syntax), &(patterns[i].regexbuf.fastmap), sizeof (patterns[i].regexbuf.fastmap), &(patterns[i].regexbuf.translate), sizeof (patterns[i].regexbuf.translate), &(patterns[i].regexbuf.re_nsub), sizeof (patterns[i].regexbuf.re_nsub), &(patterns[i].regexbuf.can_be_null), sizeof (patterns[i].regexbuf.can_be_null), &(patterns[i].regexbuf.regs_allocated), sizeof (patterns[i].regexbuf.regs_allocated), &(patterns[i].regexbuf.fastmap_accurate), sizeof (patterns[i].regexbuf.fastmap_accurate), &(patterns[i].regexbuf.no_sub), sizeof (patterns[i].regexbuf.no_sub), &(patterns[i].regexbuf.not_bol), sizeof (patterns[i].regexbuf.not_bol), &(patterns[i].regexbuf.newline_anchor), sizeof (patterns[i].regexbuf.newline_anchor))))
	      break;
	  patterns[i].regexbuf.not_eol = 0;
	  }
	  if (0 <= (start = re_search (&(patterns[i].regexbuf),
				       buf, end - buf - 1,
				       beg - buf, end - beg - 1,
				       &(patterns[i].regs))))
	    {
	      len = patterns[i].regs.end[0] - start;
	      match = buf + start;
	      if (match > best_match)
		continue;
	      if (start_ptr && !match_words)
		goto assess_pattern_match;
	      if ((!match_lines && !match_words)
		  || (match_lines && len == end - beg - 1))
		{
		  match = beg;
		  len = end - beg;
		  goto assess_pattern_match;
		}
	      /* If -w, check if the match aligns with word boundaries.
		 We do this iteratively because:
		 (a) the line may contain more than one occurence of the
		 pattern, and
		 (b) Several alternatives in the pattern might be valid at a
		 given point, and we may need to consider a shorter one to
		 find a word boundary.  */
	      if (match_words)
		while (match <= best_match)
		  {
		    if ((match == buf || !WCHAR ((unsigned char) match[-1]))
			&& (len == end - beg - 1
			    || !WCHAR ((unsigned char) match[len])))
		      goto assess_pattern_match;
		    if (len > 0)
		      {
			/* Try a shorter length anchored at the same place. */
			--len;
			patterns[i].regexbuf.not_eol = 1;
			len = re_match (&(patterns[i].regexbuf),
					buf, match + len - beg, match - buf,
					&(patterns[i].regs));
		      }
		    if (len <= 0)
		      {
			/* Try looking further on. */
			if (match == end - 1)
			  break;
			match++;
			patterns[i].regexbuf.not_eol = 0;
			start = re_search (&(patterns[i].regexbuf),
					   buf, end - buf - 1,
					   match - buf, end - match - 1,
					   &(patterns[i].regs));
			if (start < 0)
			  break;
			len = patterns[i].regs.end[0] - start;
			match = buf + start;
		      }
		  } /* while (match <= best_match) */
	      continue;
	    assess_pattern_match:
	      if (!start_ptr)
		{
		  /* Good enough for a non-exact match.
		     No need to look at further patterns, if any.  */
		  beg = match;
		  goto success_in_len;
		}
	      if (match < best_match || (match == best_match && len > best_len))
		{
		  /* Best exact match:  leftmost, then longest.  */
		  best_match = match;
		  best_len = len;
		}
	    } /* if re_search >= 0 */
	} /* for Regex patterns.  */
	if (best_match < end)
	  {
	    /* We have found an exact match.  We were just
	       waiting for the best one (leftmost then longest).  */
	    beg = best_match;
	    len = best_len;
	    goto success_in_len;
	  }
    } /* for (beg = end ..) */

 failure:
  ret_val = -1;
  goto out;

 success:
  len = end - beg;
 success_in_len:
  *match_size = len;
  ret_val = beg - buf;
 out:
  return ret_val;
}

Building:src at:
/home/ubuntu/spr-fast/tests/corebench/grep/grep-case-8a025cf8-8f08d8e2/tempworkdir-l/srcMerged code building failed! Going to build saperately!
Building:src at:
/home/ubuntu/spr-fast/tests/corebench/grep/grep-case-8a025cf8-8f08d8e2/tempworkdir-l/srcSingle building for Tester 0x42e68c0 id 78 failed as well!
Building:src at:
/home/ubuntu/spr-fast/tests/corebench/grep/grep-case-8a025cf8-8f08d8e2/tempworkdir-l/srcSingle building for Tester 0x42e68c0 id 79 failed as well!
Building:src at:
/home/ubuntu/spr-fast/tests/corebench/grep/grep-case-8a025cf8-8f08d8e2/tempworkdir-l/srcSingle building for Tester 0x42e68c0 id 80 failed as well!
Building:src at:
/home/ubuntu/spr-fast/tests/corebench/grep/grep-case-8a025cf8-8f08d8e2/tempworkdir-l/srcSingle building for Tester 0x42e68c0 id 81 failed as well!
Building:src at:
/home/ubuntu/spr-fast/tests/corebench/grep/grep-case-8a025cf8-8f08d8e2/tempworkdir-l/srcSingle building for Tester 0x42e68c0 id 82 failed as well!
Building:src at:
/home/ubuntu/spr-fast/tests/corebench/grep/grep-case-8a025cf8-8f08d8e2/tempworkdir-l/srcSingle building for Tester 0x42e68c0 id 83 failed as well!
Building:src at:
/home/ubuntu/spr-fast/tests/corebench/grep/grep-case-8a025cf8-8f08d8e2/tempworkdir-l/srcSingle building for Tester 0x42e68c0 id 84 failed as well!
Building:src at:
/home/ubuntu/spr-fast/tests/corebench/grep/grep-case-8a025cf8-8f08d8e2/tempworkdir-l/srcSingle building for Tester 0x42e68c0 id 85 failed as well!
Building:src at:
/home/ubuntu/spr-fast/tests/corebench/grep/grep-case-8a025cf8-8f08d8e2/tempworkdir-l/srcSingle building for Tester 0x42e68c0 id 86 failed as well!
a batched test job starts!
Building merged code:
src_file: src/dfasearch.c
full src: int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); void* memset(void*, int, unsigned long); 
/* dfasearch.c - searching subroutines using dfa and regex for grep.
   Copyright 1992, 1998, 2000, 2007, 2009-2010 Free Software Foundation, Inc.

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 3, or (at your option)
   any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program; if not, write to the Free Software
   Foundation, Inc., 51 Franklin Street - Fifth Floor, Boston, MA
   02110-1301, USA.  */

/* Written August 1992 by Mike Haertel. */

#include <config.h>
#include "search.h"
#include "dfa.h"

/* For -w, we also consider _ to be word constituent.  */
#define WCHAR(C) (ISALNUM(C) || (C) == '_')

/* KWset compiled pattern.  For Ecompile and Gcompile, we compile
   a list of strings, at least one of which is known to occur in
   any string matching the regexp. */
static kwset_t kwset;

/* DFA compiled regexp. */
static struct dfa dfa;

/* The Regex compiled patterns.  */
static struct patterns
{
  /* Regex compiled regexp. */
  struct re_pattern_buffer regexbuf;
  struct re_registers regs; /* This is here on account of a BRAIN-DEAD
			       Q@#%!# library interface in regex.c.  */
} patterns0;

struct patterns *patterns;
size_t pcount;

void
dfaerror (char const *mesg)
{
  error (EXIT_TROUBLE, 0, "%s", mesg);

  /* notreached */
  /* Tell static analyzers that this function does not return.  */
  abort ();
}

/* Number of compiled fixed strings known to exactly match the regexp.
   If kwsexec returns < kwset_exact_matches, then we don't need to
   call the regexp matcher at all. */
static int kwset_exact_matches;

static char const *
kwsincr_case (const char *must)
{
  const char *buf;
  size_t n;

  n = strlen (must);
#ifdef MBS_SUPPORT
  if (match_icase && MB_CUR_MAX > 1)
    buf = mbtolower (must, &n);
  else
#endif
    buf = must;
  return kwsincr (kwset, buf, n);
}

/* If the DFA turns out to have some set of fixed strings one of
   which must occur in the match, then we build a kwset matcher
   to find those strings, and thus quickly filter out impossible
   matches. */
static void
kwsmusts (void)
{
  struct dfamust const *dm;
  char const *err;

  if (dfa.musts)
    {
      kwsinit (&kwset);
      /* First, we compile in the substrings known to be exact
	 matches.  The kwset matcher will return the index
	 of the matching string that it chooses. */
      for (dm = dfa.musts; dm; dm = dm->next)
	{
	  if (!dm->exact)
	    continue;
	  ++kwset_exact_matches;
	  if ((err = kwsincr_case (dm->must)) != NULL)
	    error (EXIT_TROUBLE, 0, "%s", err);
	}
      /* Now, we compile the substrings that will require
	 the use of the regexp matcher.  */
      for (dm = dfa.musts; dm; dm = dm->next)
	{
	  if (dm->exact)
	    continue;
	  if ((err = kwsincr_case (dm->must)) != NULL)
	    error (EXIT_TROUBLE, 0, "%s", err);
	}
      if ((err = kwsprep (kwset)) != NULL)
	error (EXIT_TROUBLE, 0, "%s", err);
    }
}

void
GEAcompile (char const *pattern, size_t size, reg_syntax_t syntax_bits)
{
  const char *err;
  const char *p, *sep;
  size_t total = size;
  char *motif;

  if (match_icase)
    syntax_bits |= RE_ICASE;
  re_set_syntax (syntax_bits);
  dfasyntax (syntax_bits, match_icase, eolbyte);

  /* For GNU regex compiler we have to pass the patterns separately to detect
     errors like "[\nallo\n]\n".  The patterns here are "[", "allo" and "]"
     GNU regex should have raise a syntax error.  The same for backref, where
     the backref should have been local to each pattern.  */
  p = pattern;
  do
    {
      size_t len;
      sep = memchr (p, '\n', total);
      if (sep)
	{
	  len = sep - p;
	  sep++;
	  total -= (len + 1);
	}
      else
	{
	  len = total;
	  total = 0;
	}

      patterns = realloc (patterns, (pcount + 1) * sizeof (*patterns));
      if (patterns == NULL)
	error (EXIT_TROUBLE, errno, _("memory exhausted"));
      patterns[pcount] = patterns0;

      if ((err = re_compile_pattern (p, len,
				    &(patterns[pcount].regexbuf))) != NULL)
	error (EXIT_TROUBLE, 0, "%s", err);
      pcount++;

      p = sep;
    } while (sep && total != 0);

  /* In the match_words and match_lines cases, we use a different pattern
     for the DFA matcher that will quickly throw out cases that won't work.
     Then if DFA succeeds we do some hairy stuff using the regex matcher
     to decide whether the match should really count. */
  if (match_words || match_lines)
    {
      static char const line_beg_no_bk[] = "^(";
      static char const line_end_no_bk[] = ")$";
      static char const word_beg_no_bk[] = "(^|[^[:alnum:]_])(";
      static char const word_end_no_bk[] = ")([^[:alnum:]_]|$)";
      static char const line_beg_bk[] = "^\\(";
      static char const line_end_bk[] = "\\)$";
      static char const word_beg_bk[] = "\\(^\\|[^[:alnum:]_]\\)\\(";
      static char const word_end_bk[] = "\\)\\([^[:alnum:]_]\\|$\\)";
      int bk = !(syntax_bits & RE_NO_BK_PARENS);
      char *n = xmalloc (sizeof word_beg_bk - 1 + size + sizeof word_end_bk);

      strcpy (n, match_lines ? (bk ? line_beg_bk : line_beg_no_bk)
			     : (bk ? word_beg_bk : word_beg_no_bk));
      total = strlen(n);
      memcpy (n + total, pattern, size);
      total += size;
      strcpy (n + total, match_lines ? (bk ? line_end_bk : line_end_no_bk)
				     : (bk ? word_end_bk : word_end_no_bk));
      total += strlen (n + total);
      pattern = motif = n;
      size = total;
    }
  else
    motif = NULL;

  dfacomp (pattern, size, &dfa, 1);
  kwsmusts ();

  free(motif);
}

size_t
EGexecute (char const *buf, size_t size, size_t *match_size,
	   char const *start_ptr)
{
  char const *buflim, *beg, *end, *match, *best_match, *mb_start;
  char eol = eolbyte;
  int backref, start, len, best_len;
  struct kwsmatch kwsm;
  size_t i, ret_val;
#ifdef MBS_SUPPORT
  if (MB_CUR_MAX > 1)
    {
      if (match_icase)
        {
          /* mbtolower adds a NUL byte at the end.  That will provide
	     space for the sentinel byte dfaexec may add.  */
          char *case_buf = mbtolower (buf, &size);
	  if (start_ptr)
	    start_ptr = case_buf + (start_ptr - buf);
          buf = case_buf;
        }
    }
#endif /* MBS_SUPPORT */

  mb_start = buf;
  buflim = buf + size;

  for (beg = end = buf; end < buflim; beg = end)
    {
      if (!start_ptr)
	{
	  /* We don't care about an exact match.  */
	  if (kwset)
	    {
	      /* Find a possible match using the KWset matcher. */
	      size_t offset = kwsexec (kwset, beg, buflim - beg, &kwsm);
	      if (offset == (size_t) -1)
		goto failure;
	      beg += offset;
	      /* Narrow down to the line containing the candidate, and
		 run it through DFA. */
	      if ((end = memchr(beg, eol, buflim - beg)) != NULL)
	        end++;
              else
                end = buflim;
	      match = beg;
	      while (beg > buf && beg[-1] != eol)
		--beg;
	      if (kwsm.index < kwset_exact_matches)
                {
#ifdef MBS_SUPPORT
                  if (mb_start < beg)
                    mb_start = beg;
                  if (MB_CUR_MAX == 1 || !is_mb_middle (&mb_start, match, buflim))
#endif
                    goto success;
                }
	      if (dfaexec (&dfa, beg, (char *) end, 0, NULL, &backref) == NULL)
		continue;
	    }
	  else
	    {
	      /* No good fixed strings; start with DFA. */
	      char const *next_beg = dfaexec (&dfa, beg, (char *) buflim,
					      0, NULL, &backref);
	      if (next_beg == NULL)
		break;
	      /* Narrow down to the line we've found. */
	      beg = next_beg;
	      if ((end = memchr(beg, eol, buflim - beg)) != NULL)
	        end++;
              else
                end = buflim;
	      while (beg > buf && beg[-1] != eol)
		--beg;
	    }
	  /* Successful, no backreferences encountered! */
	  if (!backref)
	    goto success;
	}
      else
	{
	  /* We are looking for the leftmost (then longest) exact match.
	     We will go through the outer loop only once.  */
	  beg = start_ptr;
	  end = buflim;
	}

      /* If we've made it to this point, this means DFA has seen
	 a probable match, and we need to run it through Regex. */
      best_match = end;
      best_len = 0;
      for (i = 0; i < pcount; i++)
	{
	  patterns[i].regexbuf.not_eol = 0;
	  //prophet generated patch
	  if (__get_mutant()==0) {
	  if ((0 <= (start = rpl_re_search(&(patterns[i].regexbuf), buf, end - buf - 1, beg - buf, end - beg - 1, &(patterns[i].regs)))) && !(__is_neg(28, &(i), sizeof (i), &(patterns), sizeof (patterns), &(buf), sizeof (buf), &(beg), sizeof (beg), &(end), sizeof (end), &(start), sizeof (start), &(len), sizeof (len), &(patterns[i].regs.end), sizeof (patterns[i].regs.end), &(match), sizeof (match), &(best_match), sizeof (best_match), &(start_ptr), sizeof (start_ptr), &(match_words), sizeof (match_words), &(pcount), sizeof (pcount), &(best_len), sizeof (best_len), &(match_lines), sizeof (match_lines), &(buflim), sizeof (buflim), &(backref), sizeof (backref), &(eol), sizeof (eol), &(mb_start), sizeof (mb_start), &(kwset_exact_matches), sizeof (kwset_exact_matches), &(kwset), sizeof (kwset), &(size), sizeof (size), &(ret_val), sizeof (ret_val), &(match_icase), sizeof (match_icase), &(match_size), sizeof (match_size), &(eolbyte), sizeof (eolbyte), &(patterns[i].regs.num_regs), sizeof (patterns[i].regs.num_regs), &(patterns[i].regs.start), sizeof (patterns[i].regs.start)))) {
	      len = patterns[i].regs.end[0] - start;
	      match = buf + start;
	      if (match > best_match)
	          continue;
	      if (start_ptr && !match_words)
	          goto assess_pattern_match;
	      if ((!match_lines && !match_words) || (match_lines && len == end - beg - 1)) {
	          match = beg;
	          len = end - beg;
	          goto assess_pattern_match;
	      }
	      if (match_words)
	          while (match <= best_match)
	              {
	                  if ((match == buf || !((1 && ((*__ctype_b_loc())[(int)(((unsigned char)match[-1]))] & (unsigned short)_ISalnum)) || ((unsigned char)match[-1]) == '_')) && (len == end - beg - 1 || !((1 && ((*__ctype_b_loc())[(int)(((unsigned char)match[len]))] & (unsigned short)_ISalnum)) || ((unsigned char)match[len]) == '_')))
	                      goto assess_pattern_match;
	                  if (len > 0) {
	                      --len;
	                      patterns[i].regexbuf.not_eol = 1;
	                      len = rpl_re_match(&(patterns[i].regexbuf), buf, match + len - beg, match - buf, &(patterns[i].regs));
	                  }
	                  if (len <= 0) {
	                      if (match == end - 1)
	                          break;
	                      match++;
	                      patterns[i].regexbuf.not_eol = 0;
	                      start = rpl_re_search(&(patterns[i].regexbuf), buf, end - buf - 1, match - buf, end - match - 1, &(patterns[i].regs));
	                      if (start < 0)
	                          break;
	                      len = patterns[i].regs.end[0] - start;
	                      match = buf + start;
	                  }
	              }
	      continue;
	    assess_pattern_match:
	      if (!start_ptr) {
	          beg = match;
	          goto success_in_len;
	      }
	      if (match < best_match || (match == best_match && len > best_len)) {
	          best_match = match;
	          best_len = len;
	      }
	  }
	  }
	  else if (__get_mutant()==1) {
	  if ((0 <= (start = rpl_re_search(&(patterns[i].regexbuf), buf, end - buf - 1, beg - buf, end - beg - 1, &(patterns[i].regs)))) || (__is_neg(28, &(i), sizeof (i), &(patterns), sizeof (patterns), &(buf), sizeof (buf), &(beg), sizeof (beg), &(end), sizeof (end), &(start), sizeof (start), &(len), sizeof (len), &(patterns[i].regs.end), sizeof (patterns[i].regs.end), &(match), sizeof (match), &(best_match), sizeof (best_match), &(start_ptr), sizeof (start_ptr), &(match_words), sizeof (match_words), &(pcount), sizeof (pcount), &(best_len), sizeof (best_len), &(match_lines), sizeof (match_lines), &(buflim), sizeof (buflim), &(backref), sizeof (backref), &(eol), sizeof (eol), &(mb_start), sizeof (mb_start), &(kwset_exact_matches), sizeof (kwset_exact_matches), &(kwset), sizeof (kwset), &(size), sizeof (size), &(ret_val), sizeof (ret_val), &(match_icase), sizeof (match_icase), &(match_size), sizeof (match_size), &(eolbyte), sizeof (eolbyte), &(patterns[i].regs.num_regs), sizeof (patterns[i].regs.num_regs), &(patterns[i].regs.start), sizeof (patterns[i].regs.start)))) {
	      len = patterns[i].regs.end[0] - start;
	      match = buf + start;
	      if (match > best_match)
	          continue;
	      if (start_ptr && !match_words)
	          goto assess_pattern_match;
	      if ((!match_lines && !match_words) || (match_lines && len == end - beg - 1)) {
	          match = beg;
	          len = end - beg;
	          goto assess_pattern_match;
	      }
	      if (match_words)
	          while (match <= best_match)
	              {
	                  if ((match == buf || !((1 && ((*__ctype_b_loc())[(int)(((unsigned char)match[-1]))] & (unsigned short)_ISalnum)) || ((unsigned char)match[-1]) == '_')) && (len == end - beg - 1 || !((1 && ((*__ctype_b_loc())[(int)(((unsigned char)match[len]))] & (unsigned short)_ISalnum)) || ((unsigned char)match[len]) == '_')))
	                      goto assess_pattern_match;
	                  if (len > 0) {
	                      --len;
	                      patterns[i].regexbuf.not_eol = 1;
	                      len = rpl_re_match(&(patterns[i].regexbuf), buf, match + len - beg, match - buf, &(patterns[i].regs));
	                  }
	                  if (len <= 0) {
	                      if (match == end - 1)
	                          break;
	                      match++;
	                      patterns[i].regexbuf.not_eol = 0;
	                      start = rpl_re_search(&(patterns[i].regexbuf), buf, end - buf - 1, match - buf, end - match - 1, &(patterns[i].regs));
	                      if (start < 0)
	                          break;
	                      len = patterns[i].regs.end[0] - start;
	                      match = buf + start;
	                  }
	              }
	      continue;
	    assess_pattern_match:
	      if (!start_ptr) {
	          beg = match;
	          goto success_in_len;
	      }
	      if (match < best_match || (match == best_match && len > best_len)) {
	          best_match = match;
	          best_len = len;
	      }
	  }
	  }
	} /* for Regex patterns.  */
	if (best_match < end)
	  {
	    /* We have found an exact match.  We were just
	       waiting for the best one (leftmost then longest).  */
	    beg = best_match;
	    len = best_len;
	    goto success_in_len;
	  }
    } /* for (beg = end ..) */

 failure:
  ret_val = -1;
  goto out;

 success:
  len = end - beg;
 success_in_len:
  *match_size = len;
  ret_val = beg - buf;
 out:
  return ret_val;
}

Building:src at:
/home/ubuntu/spr-fast/tests/corebench/grep/grep-case-8a025cf8-8f08d8e2/tempworkdir-l/srcMerged code building failed! Going to build saperately!
Building:src at:
/home/ubuntu/spr-fast/tests/corebench/grep/grep-case-8a025cf8-8f08d8e2/tempworkdir-l/srcCondTester, Testing instance id 9:
//src_file:src/dfasearch.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); void* memset(void*, int, unsigned long); 
/* dfasearch.c - searching subroutines using dfa and regex for grep.
   Copyright 1992, 1998, 2000, 2007, 2009-2010 Free Software Foundation, Inc.

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 3, or (at your option)
   any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program; if not, write to the Free Software
   Foundation, Inc., 51 Franklin Street - Fifth Floor, Boston, MA
   02110-1301, USA.  */

/* Written August 1992 by Mike Haertel. */

#include <config.h>
#include "search.h"
#include "dfa.h"

/* For -w, we also consider _ to be word constituent.  */
#define WCHAR(C) (ISALNUM(C) || (C) == '_')

/* KWset compiled pattern.  For Ecompile and Gcompile, we compile
   a list of strings, at least one of which is known to occur in
   any string matching the regexp. */
static kwset_t kwset;

/* DFA compiled regexp. */
static struct dfa dfa;

/* The Regex compiled patterns.  */
static struct patterns
{
  /* Regex compiled regexp. */
  struct re_pattern_buffer regexbuf;
  struct re_registers regs; /* This is here on account of a BRAIN-DEAD
			       Q@#%!# library interface in regex.c.  */
} patterns0;

struct patterns *patterns;
size_t pcount;

void
dfaerror (char const *mesg)
{
  error (EXIT_TROUBLE, 0, "%s", mesg);

  /* notreached */
  /* Tell static analyzers that this function does not return.  */
  abort ();
}

/* Number of compiled fixed strings known to exactly match the regexp.
   If kwsexec returns < kwset_exact_matches, then we don't need to
   call the regexp matcher at all. */
static int kwset_exact_matches;

static char const *
kwsincr_case (const char *must)
{
  const char *buf;
  size_t n;

  n = strlen (must);
#ifdef MBS_SUPPORT
  if (match_icase && MB_CUR_MAX > 1)
    buf = mbtolower (must, &n);
  else
#endif
    buf = must;
  return kwsincr (kwset, buf, n);
}

/* If the DFA turns out to have some set of fixed strings one of
   which must occur in the match, then we build a kwset matcher
   to find those strings, and thus quickly filter out impossible
   matches. */
static void
kwsmusts (void)
{
  struct dfamust const *dm;
  char const *err;

  if (dfa.musts)
    {
      kwsinit (&kwset);
      /* First, we compile in the substrings known to be exact
	 matches.  The kwset matcher will return the index
	 of the matching string that it chooses. */
      for (dm = dfa.musts; dm; dm = dm->next)
	{
	  if (!dm->exact)
	    continue;
	  ++kwset_exact_matches;
	  if ((err = kwsincr_case (dm->must)) != NULL)
	    error (EXIT_TROUBLE, 0, "%s", err);
	}
      /* Now, we compile the substrings that will require
	 the use of the regexp matcher.  */
      for (dm = dfa.musts; dm; dm = dm->next)
	{
	  if (dm->exact)
	    continue;
	  if ((err = kwsincr_case (dm->must)) != NULL)
	    error (EXIT_TROUBLE, 0, "%s", err);
	}
      if ((err = kwsprep (kwset)) != NULL)
	error (EXIT_TROUBLE, 0, "%s", err);
    }
}

void
GEAcompile (char const *pattern, size_t size, reg_syntax_t syntax_bits)
{
  const char *err;
  const char *p, *sep;
  size_t total = size;
  char *motif;

  if (match_icase)
    syntax_bits |= RE_ICASE;
  re_set_syntax (syntax_bits);
  dfasyntax (syntax_bits, match_icase, eolbyte);

  /* For GNU regex compiler we have to pass the patterns separately to detect
     errors like "[\nallo\n]\n".  The patterns here are "[", "allo" and "]"
     GNU regex should have raise a syntax error.  The same for backref, where
     the backref should have been local to each pattern.  */
  p = pattern;
  do
    {
      size_t len;
      sep = memchr (p, '\n', total);
      if (sep)
	{
	  len = sep - p;
	  sep++;
	  total -= (len + 1);
	}
      else
	{
	  len = total;
	  total = 0;
	}

      patterns = realloc (patterns, (pcount + 1) * sizeof (*patterns));
      if (patterns == NULL)
	error (EXIT_TROUBLE, errno, _("memory exhausted"));
      patterns[pcount] = patterns0;

      if ((err = re_compile_pattern (p, len,
				    &(patterns[pcount].regexbuf))) != NULL)
	error (EXIT_TROUBLE, 0, "%s", err);
      pcount++;

      p = sep;
    } while (sep && total != 0);

  /* In the match_words and match_lines cases, we use a different pattern
     for the DFA matcher that will quickly throw out cases that won't work.
     Then if DFA succeeds we do some hairy stuff using the regex matcher
     to decide whether the match should really count. */
  if (match_words || match_lines)
    {
      static char const line_beg_no_bk[] = "^(";
      static char const line_end_no_bk[] = ")$";
      static char const word_beg_no_bk[] = "(^|[^[:alnum:]_])(";
      static char const word_end_no_bk[] = ")([^[:alnum:]_]|$)";
      static char const line_beg_bk[] = "^\\(";
      static char const line_end_bk[] = "\\)$";
      static char const word_beg_bk[] = "\\(^\\|[^[:alnum:]_]\\)\\(";
      static char const word_end_bk[] = "\\)\\([^[:alnum:]_]\\|$\\)";
      int bk = !(syntax_bits & RE_NO_BK_PARENS);
      char *n = xmalloc (sizeof word_beg_bk - 1 + size + sizeof word_end_bk);

      strcpy (n, match_lines ? (bk ? line_beg_bk : line_beg_no_bk)
			     : (bk ? word_beg_bk : word_beg_no_bk));
      total = strlen(n);
      memcpy (n + total, pattern, size);
      total += size;
      strcpy (n + total, match_lines ? (bk ? line_end_bk : line_end_no_bk)
				     : (bk ? word_end_bk : word_end_no_bk));
      total += strlen (n + total);
      pattern = motif = n;
      size = total;
    }
  else
    motif = NULL;

  dfacomp (pattern, size, &dfa, 1);
  kwsmusts ();

  free(motif);
}

size_t
EGexecute (char const *buf, size_t size, size_t *match_size,
	   char const *start_ptr)
{
  char const *buflim, *beg, *end, *match, *best_match, *mb_start;
  char eol = eolbyte;
  int backref, start, len, best_len;
  struct kwsmatch kwsm;
  size_t i, ret_val;
#ifdef MBS_SUPPORT
  if (MB_CUR_MAX > 1)
    {
      if (match_icase)
        {
          /* mbtolower adds a NUL byte at the end.  That will provide
	     space for the sentinel byte dfaexec may add.  */
          char *case_buf = mbtolower (buf, &size);
	  if (start_ptr)
	    start_ptr = case_buf + (start_ptr - buf);
          buf = case_buf;
        }
    }
#endif /* MBS_SUPPORT */

  mb_start = buf;
  buflim = buf + size;

  for (beg = end = buf; end < buflim; beg = end)
    {
      if (!start_ptr)
	{
	  /* We don't care about an exact match.  */
	  if (kwset)
	    {
	      /* Find a possible match using the KWset matcher. */
	      size_t offset = kwsexec (kwset, beg, buflim - beg, &kwsm);
	      if (offset == (size_t) -1)
		goto failure;
	      beg += offset;
	      /* Narrow down to the line containing the candidate, and
		 run it through DFA. */
	      if ((end = memchr(beg, eol, buflim - beg)) != NULL)
	        end++;
              else
                end = buflim;
	      match = beg;
	      while (beg > buf && beg[-1] != eol)
		--beg;
	      if (kwsm.index < kwset_exact_matches)
                {
#ifdef MBS_SUPPORT
                  if (mb_start < beg)
                    mb_start = beg;
                  if (MB_CUR_MAX == 1 || !is_mb_middle (&mb_start, match, buflim))
#endif
                    goto success;
                }
	      if (dfaexec (&dfa, beg, (char *) end, 0, NULL, &backref) == NULL)
		continue;
	    }
	  else
	    {
	      /* No good fixed strings; start with DFA. */
	      char const *next_beg = dfaexec (&dfa, beg, (char *) buflim,
					      0, NULL, &backref);
	      if (next_beg == NULL)
		break;
	      /* Narrow down to the line we've found. */
	      beg = next_beg;
	      if ((end = memchr(beg, eol, buflim - beg)) != NULL)
	        end++;
              else
                end = buflim;
	      while (beg > buf && beg[-1] != eol)
		--beg;
	    }
	  /* Successful, no backreferences encountered! */
	  if (!backref)
	    goto success;
	}
      else
	{
	  /* We are looking for the leftmost (then longest) exact match.
	     We will go through the outer loop only once.  */
	  beg = start_ptr;
	  end = buflim;
	}

      /* If we've made it to this point, this means DFA has seen
	 a probable match, and we need to run it through Regex. */
      best_match = end;
      best_len = 0;
      for (i = 0; i < pcount; i++)
	{
	  patterns[i].regexbuf.not_eol = 0;
	  
//Patch 0:
if ((0 <= (start = rpl_re_search(&(patterns[i].regexbuf), buf, end - buf - 1, beg - buf, end - beg - 1, &(patterns[i].regs)))) && !(__is_neg(28, &(i), sizeof (i), &(patterns), sizeof (patterns), &(buf), sizeof (buf), &(beg), sizeof (beg), &(end), sizeof (end), &(start), sizeof (start), &(len), sizeof (len), &(patterns[i].regs.end), sizeof (patterns[i].regs.end), &(match), sizeof (match), &(best_match), sizeof (best_match), &(start_ptr), sizeof (start_ptr), &(match_words), sizeof (match_words), &(pcount), sizeof (pcount), &(best_len), sizeof (best_len), &(match_lines), sizeof (match_lines), &(buflim), sizeof (buflim), &(backref), sizeof (backref), &(eol), sizeof (eol), &(mb_start), sizeof (mb_start), &(kwset_exact_matches), sizeof (kwset_exact_matches), &(kwset), sizeof (kwset), &(size), sizeof (size), &(ret_val), sizeof (ret_val), &(match_icase), sizeof (match_icase), &(match_size), sizeof (match_size), &(eolbyte), sizeof (eolbyte), &(patterns[i].regs.num_regs), sizeof (patterns[i].regs.num_regs), &(patterns[i].regs.start), sizeof (patterns[i].regs.start)))) {
    len = patterns[i].regs.end[0] - start;
    match = buf + start;
    if (match > best_match)
        continue;
    if (start_ptr && !match_words)
        goto assess_pattern_match;
    if ((!match_lines && !match_words) || (match_lines && len == end - beg - 1)) {
        match = beg;
        len = end - beg;
        goto assess_pattern_match;
    }
    if (match_words)
        while (match <= best_match)
            {
                if ((match == buf || !((1 && ((*__ctype_b_loc())[(int)(((unsigned char)match[-1]))] & (unsigned short)_ISalnum)) || ((unsigned char)match[-1]) == '_')) && (len == end - beg - 1 || !((1 && ((*__ctype_b_loc())[(int)(((unsigned char)match[len]))] & (unsigned short)_ISalnum)) || ((unsigned char)match[len]) == '_')))
                    goto assess_pattern_match;
                if (len > 0) {
                    --len;
                    patterns[i].regexbuf.not_eol = 1;
                    len = rpl_re_match(&(patterns[i].regexbuf), buf, match + len - beg, match - buf, &(patterns[i].regs));
                }
                if (len <= 0) {
                    if (match == end - 1)
                        break;
                    match++;
                    patterns[i].regexbuf.not_eol = 0;
                    start = rpl_re_search(&(patterns[i].regexbuf), buf, end - buf - 1, match - buf, end - match - 1, &(patterns[i].regs));
                    if (start < 0)
                        break;
                    len = patterns[i].regs.end[0] - start;
                    match = buf + start;
                }
            }
    continue;
  assess_pattern_match:
    if (!start_ptr) {
        beg = match;
        goto success_in_len;
    }
    if (match < best_match || (match == best_match && len > best_len)) {
        best_match = match;
        best_len = len;
    }
}

//CodeSeg 1:
	} /* for Regex patterns.  */
	if (best_match < end)
	  {
	    /* We have found an exact match.  We were just
	       waiting for the best one (leftmost then longest).  */
	    beg = best_match;
	    len = best_len;
	    goto success_in_len;
	  }
    } /* for (beg = end ..) */

 failure:
  ret_val = -1;
  goto out;

 success:
  len = end - beg;
 success_in_len:
  *match_size = len;
  ret_val = beg - buf;
 out:
  return ret_val;
}

Testing negative cases!
Testing 0 (with abstract condition) ENVIS_NEG
Iteration 0
Running test command:
/home/ubuntu/spr-fast/tools/grep-test.py /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-8a025cf8-8f08d8e2/tempworkdir-l/src /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-8a025cf8-8f08d8e2/tempworkdir-l/tests /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-8a025cf8-8f08d8e2/tempworkdir-l 0  > __res
Opening:/tmp/neg.tmp!
NegativeBRANCH RECORD/tmp/neg.tmp!
APPENDING TO ISNEG:/tmp/neg.tmp!
Branch 0: 0
Iteration 1
Running test command:
/home/ubuntu/spr-fast/tools/grep-test.py /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-8a025cf8-8f08d8e2/tempworkdir-l/src /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-8a025cf8-8f08d8e2/tempworkdir-l/tests /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-8a025cf8-8f08d8e2/tempworkdir-l 0  > __res
Opening:/tmp/neg.tmp!
NegativeBRANCH RECORD/tmp/neg.tmp!
APPENDING TO ISNEG:/tmp/neg.tmp!
Branch 0: 1
Running test command:
/home/ubuntu/spr-fast/tools/grep-test.py /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-8a025cf8-8f08d8e2/tempworkdir-l/src /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-8a025cf8-8f08d8e2/tempworkdir-l/tests /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-8a025cf8-8f08d8e2/tempworkdir-l 0  > __res
Building:src at:
/home/ubuntu/spr-fast/tests/corebench/grep/grep-case-8a025cf8-8f08d8e2/tempworkdir-l/srcCondTester, Testing instance id 10:
//src_file:src/dfasearch.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); void* memset(void*, int, unsigned long); 
/* dfasearch.c - searching subroutines using dfa and regex for grep.
   Copyright 1992, 1998, 2000, 2007, 2009-2010 Free Software Foundation, Inc.

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 3, or (at your option)
   any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program; if not, write to the Free Software
   Foundation, Inc., 51 Franklin Street - Fifth Floor, Boston, MA
   02110-1301, USA.  */

/* Written August 1992 by Mike Haertel. */

#include <config.h>
#include "search.h"
#include "dfa.h"

/* For -w, we also consider _ to be word constituent.  */
#define WCHAR(C) (ISALNUM(C) || (C) == '_')

/* KWset compiled pattern.  For Ecompile and Gcompile, we compile
   a list of strings, at least one of which is known to occur in
   any string matching the regexp. */
static kwset_t kwset;

/* DFA compiled regexp. */
static struct dfa dfa;

/* The Regex compiled patterns.  */
static struct patterns
{
  /* Regex compiled regexp. */
  struct re_pattern_buffer regexbuf;
  struct re_registers regs; /* This is here on account of a BRAIN-DEAD
			       Q@#%!# library interface in regex.c.  */
} patterns0;

struct patterns *patterns;
size_t pcount;

void
dfaerror (char const *mesg)
{
  error (EXIT_TROUBLE, 0, "%s", mesg);

  /* notreached */
  /* Tell static analyzers that this function does not return.  */
  abort ();
}

/* Number of compiled fixed strings known to exactly match the regexp.
   If kwsexec returns < kwset_exact_matches, then we don't need to
   call the regexp matcher at all. */
static int kwset_exact_matches;

static char const *
kwsincr_case (const char *must)
{
  const char *buf;
  size_t n;

  n = strlen (must);
#ifdef MBS_SUPPORT
  if (match_icase && MB_CUR_MAX > 1)
    buf = mbtolower (must, &n);
  else
#endif
    buf = must;
  return kwsincr (kwset, buf, n);
}

/* If the DFA turns out to have some set of fixed strings one of
   which must occur in the match, then we build a kwset matcher
   to find those strings, and thus quickly filter out impossible
   matches. */
static void
kwsmusts (void)
{
  struct dfamust const *dm;
  char const *err;

  if (dfa.musts)
    {
      kwsinit (&kwset);
      /* First, we compile in the substrings known to be exact
	 matches.  The kwset matcher will return the index
	 of the matching string that it chooses. */
      for (dm = dfa.musts; dm; dm = dm->next)
	{
	  if (!dm->exact)
	    continue;
	  ++kwset_exact_matches;
	  if ((err = kwsincr_case (dm->must)) != NULL)
	    error (EXIT_TROUBLE, 0, "%s", err);
	}
      /* Now, we compile the substrings that will require
	 the use of the regexp matcher.  */
      for (dm = dfa.musts; dm; dm = dm->next)
	{
	  if (dm->exact)
	    continue;
	  if ((err = kwsincr_case (dm->must)) != NULL)
	    error (EXIT_TROUBLE, 0, "%s", err);
	}
      if ((err = kwsprep (kwset)) != NULL)
	error (EXIT_TROUBLE, 0, "%s", err);
    }
}

void
GEAcompile (char const *pattern, size_t size, reg_syntax_t syntax_bits)
{
  const char *err;
  const char *p, *sep;
  size_t total = size;
  char *motif;

  if (match_icase)
    syntax_bits |= RE_ICASE;
  re_set_syntax (syntax_bits);
  dfasyntax (syntax_bits, match_icase, eolbyte);

  /* For GNU regex compiler we have to pass the patterns separately to detect
     errors like "[\nallo\n]\n".  The patterns here are "[", "allo" and "]"
     GNU regex should have raise a syntax error.  The same for backref, where
     the backref should have been local to each pattern.  */
  p = pattern;
  do
    {
      size_t len;
      sep = memchr (p, '\n', total);
      if (sep)
	{
	  len = sep - p;
	  sep++;
	  total -= (len + 1);
	}
      else
	{
	  len = total;
	  total = 0;
	}

      patterns = realloc (patterns, (pcount + 1) * sizeof (*patterns));
      if (patterns == NULL)
	error (EXIT_TROUBLE, errno, _("memory exhausted"));
      patterns[pcount] = patterns0;

      if ((err = re_compile_pattern (p, len,
				    &(patterns[pcount].regexbuf))) != NULL)
	error (EXIT_TROUBLE, 0, "%s", err);
      pcount++;

      p = sep;
    } while (sep && total != 0);

  /* In the match_words and match_lines cases, we use a different pattern
     for the DFA matcher that will quickly throw out cases that won't work.
     Then if DFA succeeds we do some hairy stuff using the regex matcher
     to decide whether the match should really count. */
  if (match_words || match_lines)
    {
      static char const line_beg_no_bk[] = "^(";
      static char const line_end_no_bk[] = ")$";
      static char const word_beg_no_bk[] = "(^|[^[:alnum:]_])(";
      static char const word_end_no_bk[] = ")([^[:alnum:]_]|$)";
      static char const line_beg_bk[] = "^\\(";
      static char const line_end_bk[] = "\\)$";
      static char const word_beg_bk[] = "\\(^\\|[^[:alnum:]_]\\)\\(";
      static char const word_end_bk[] = "\\)\\([^[:alnum:]_]\\|$\\)";
      int bk = !(syntax_bits & RE_NO_BK_PARENS);
      char *n = xmalloc (sizeof word_beg_bk - 1 + size + sizeof word_end_bk);

      strcpy (n, match_lines ? (bk ? line_beg_bk : line_beg_no_bk)
			     : (bk ? word_beg_bk : word_beg_no_bk));
      total = strlen(n);
      memcpy (n + total, pattern, size);
      total += size;
      strcpy (n + total, match_lines ? (bk ? line_end_bk : line_end_no_bk)
				     : (bk ? word_end_bk : word_end_no_bk));
      total += strlen (n + total);
      pattern = motif = n;
      size = total;
    }
  else
    motif = NULL;

  dfacomp (pattern, size, &dfa, 1);
  kwsmusts ();

  free(motif);
}

size_t
EGexecute (char const *buf, size_t size, size_t *match_size,
	   char const *start_ptr)
{
  char const *buflim, *beg, *end, *match, *best_match, *mb_start;
  char eol = eolbyte;
  int backref, start, len, best_len;
  struct kwsmatch kwsm;
  size_t i, ret_val;
#ifdef MBS_SUPPORT
  if (MB_CUR_MAX > 1)
    {
      if (match_icase)
        {
          /* mbtolower adds a NUL byte at the end.  That will provide
	     space for the sentinel byte dfaexec may add.  */
          char *case_buf = mbtolower (buf, &size);
	  if (start_ptr)
	    start_ptr = case_buf + (start_ptr - buf);
          buf = case_buf;
        }
    }
#endif /* MBS_SUPPORT */

  mb_start = buf;
  buflim = buf + size;

  for (beg = end = buf; end < buflim; beg = end)
    {
      if (!start_ptr)
	{
	  /* We don't care about an exact match.  */
	  if (kwset)
	    {
	      /* Find a possible match using the KWset matcher. */
	      size_t offset = kwsexec (kwset, beg, buflim - beg, &kwsm);
	      if (offset == (size_t) -1)
		goto failure;
	      beg += offset;
	      /* Narrow down to the line containing the candidate, and
		 run it through DFA. */
	      if ((end = memchr(beg, eol, buflim - beg)) != NULL)
	        end++;
              else
                end = buflim;
	      match = beg;
	      while (beg > buf && beg[-1] != eol)
		--beg;
	      if (kwsm.index < kwset_exact_matches)
                {
#ifdef MBS_SUPPORT
                  if (mb_start < beg)
                    mb_start = beg;
                  if (MB_CUR_MAX == 1 || !is_mb_middle (&mb_start, match, buflim))
#endif
                    goto success;
                }
	      if (dfaexec (&dfa, beg, (char *) end, 0, NULL, &backref) == NULL)
		continue;
	    }
	  else
	    {
	      /* No good fixed strings; start with DFA. */
	      char const *next_beg = dfaexec (&dfa, beg, (char *) buflim,
					      0, NULL, &backref);
	      if (next_beg == NULL)
		break;
	      /* Narrow down to the line we've found. */
	      beg = next_beg;
	      if ((end = memchr(beg, eol, buflim - beg)) != NULL)
	        end++;
              else
                end = buflim;
	      while (beg > buf && beg[-1] != eol)
		--beg;
	    }
	  /* Successful, no backreferences encountered! */
	  if (!backref)
	    goto success;
	}
      else
	{
	  /* We are looking for the leftmost (then longest) exact match.
	     We will go through the outer loop only once.  */
	  beg = start_ptr;
	  end = buflim;
	}

      /* If we've made it to this point, this means DFA has seen
	 a probable match, and we need to run it through Regex. */
      best_match = end;
      best_len = 0;
      for (i = 0; i < pcount; i++)
	{
	  patterns[i].regexbuf.not_eol = 0;
	  
//Patch 0:
if ((0 <= (start = rpl_re_search(&(patterns[i].regexbuf), buf, end - buf - 1, beg - buf, end - beg - 1, &(patterns[i].regs)))) || (__is_neg(28, &(i), sizeof (i), &(patterns), sizeof (patterns), &(buf), sizeof (buf), &(beg), sizeof (beg), &(end), sizeof (end), &(start), sizeof (start), &(len), sizeof (len), &(patterns[i].regs.end), sizeof (patterns[i].regs.end), &(match), sizeof (match), &(best_match), sizeof (best_match), &(start_ptr), sizeof (start_ptr), &(match_words), sizeof (match_words), &(pcount), sizeof (pcount), &(best_len), sizeof (best_len), &(match_lines), sizeof (match_lines), &(buflim), sizeof (buflim), &(backref), sizeof (backref), &(eol), sizeof (eol), &(mb_start), sizeof (mb_start), &(kwset_exact_matches), sizeof (kwset_exact_matches), &(kwset), sizeof (kwset), &(size), sizeof (size), &(ret_val), sizeof (ret_val), &(match_icase), sizeof (match_icase), &(match_size), sizeof (match_size), &(eolbyte), sizeof (eolbyte), &(patterns[i].regs.num_regs), sizeof (patterns[i].regs.num_regs), &(patterns[i].regs.start), sizeof (patterns[i].regs.start)))) {
    len = patterns[i].regs.end[0] - start;
    match = buf + start;
    if (match > best_match)
        continue;
    if (start_ptr && !match_words)
        goto assess_pattern_match;
    if ((!match_lines && !match_words) || (match_lines && len == end - beg - 1)) {
        match = beg;
        len = end - beg;
        goto assess_pattern_match;
    }
    if (match_words)
        while (match <= best_match)
            {
                if ((match == buf || !((1 && ((*__ctype_b_loc())[(int)(((unsigned char)match[-1]))] & (unsigned short)_ISalnum)) || ((unsigned char)match[-1]) == '_')) && (len == end - beg - 1 || !((1 && ((*__ctype_b_loc())[(int)(((unsigned char)match[len]))] & (unsigned short)_ISalnum)) || ((unsigned char)match[len]) == '_')))
                    goto assess_pattern_match;
                if (len > 0) {
                    --len;
                    patterns[i].regexbuf.not_eol = 1;
                    len = rpl_re_match(&(patterns[i].regexbuf), buf, match + len - beg, match - buf, &(patterns[i].regs));
                }
                if (len <= 0) {
                    if (match == end - 1)
                        break;
                    match++;
                    patterns[i].regexbuf.not_eol = 0;
                    start = rpl_re_search(&(patterns[i].regexbuf), buf, end - buf - 1, match - buf, end - match - 1, &(patterns[i].regs));
                    if (start < 0)
                        break;
                    len = patterns[i].regs.end[0] - start;
                    match = buf + start;
                }
            }
    continue;
  assess_pattern_match:
    if (!start_ptr) {
        beg = match;
        goto success_in_len;
    }
    if (match < best_match || (match == best_match && len > best_len)) {
        best_match = match;
        best_len = len;
    }
}

//CodeSeg 1:
	} /* for Regex patterns.  */
	if (best_match < end)
	  {
	    /* We have found an exact match.  We were just
	       waiting for the best one (leftmost then longest).  */
	    beg = best_match;
	    len = best_len;
	    goto success_in_len;
	  }
    } /* for (beg = end ..) */

 failure:
  ret_val = -1;
  goto out;

 success:
  len = end - beg;
 success_in_len:
  *match_size = len;
  ret_val = beg - buf;
 out:
  return ret_val;
}

Testing negative cases!
Testing 0 (with abstract condition) ENVIS_NEG
Iteration 0
Running test command:
/home/ubuntu/spr-fast/tools/grep-test.py /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-8a025cf8-8f08d8e2/tempworkdir-l/src /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-8a025cf8-8f08d8e2/tempworkdir-l/tests /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-8a025cf8-8f08d8e2/tempworkdir-l 0  > __res
Opening:/tmp/neg.tmp!
NegativeBRANCH RECORD/tmp/neg.tmp!
Not caught by the negative case, give up!
APPENDING TO ISNEG:/tmp/neg.tmp!
Running test command:
/home/ubuntu/spr-fast/tools/grep-test.py /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-8a025cf8-8f08d8e2/tempworkdir-l/src /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-8a025cf8-8f08d8e2/tempworkdir-l/tests /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-8a025cf8-8f08d8e2/tempworkdir-l 0  > __res
a batched test job starts!
Building merged code:
src_file: src/dfasearch.c
full src: int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); void* memset(void*, int, unsigned long); 
/* dfasearch.c - searching subroutines using dfa and regex for grep.
   Copyright 1992, 1998, 2000, 2007, 2009-2010 Free Software Foundation, Inc.

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 3, or (at your option)
   any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program; if not, write to the Free Software
   Foundation, Inc., 51 Franklin Street - Fifth Floor, Boston, MA
   02110-1301, USA.  */

/* Written August 1992 by Mike Haertel. */

#include <config.h>
#include "search.h"
#include "dfa.h"

/* For -w, we also consider _ to be word constituent.  */
#define WCHAR(C) (ISALNUM(C) || (C) == '_')

/* KWset compiled pattern.  For Ecompile and Gcompile, we compile
   a list of strings, at least one of which is known to occur in
   any string matching the regexp. */
static kwset_t kwset;

/* DFA compiled regexp. */
static struct dfa dfa;

/* The Regex compiled patterns.  */
static struct patterns
{
  /* Regex compiled regexp. */
  struct re_pattern_buffer regexbuf;
  struct re_registers regs; /* This is here on account of a BRAIN-DEAD
			       Q@#%!# library interface in regex.c.  */
} patterns0;

struct patterns *patterns;
size_t pcount;

void
dfaerror (char const *mesg)
{
  error (EXIT_TROUBLE, 0, "%s", mesg);

  /* notreached */
  /* Tell static analyzers that this function does not return.  */
  abort ();
}

/* Number of compiled fixed strings known to exactly match the regexp.
   If kwsexec returns < kwset_exact_matches, then we don't need to
   call the regexp matcher at all. */
static int kwset_exact_matches;

static char const *
kwsincr_case (const char *must)
{
  const char *buf;
  size_t n;

  n = strlen (must);
#ifdef MBS_SUPPORT
  if (match_icase && MB_CUR_MAX > 1)
    buf = mbtolower (must, &n);
  else
#endif
    buf = must;
  return kwsincr (kwset, buf, n);
}

/* If the DFA turns out to have some set of fixed strings one of
   which must occur in the match, then we build a kwset matcher
   to find those strings, and thus quickly filter out impossible
   matches. */
static void
kwsmusts (void)
{
  struct dfamust const *dm;
  char const *err;

  if (dfa.musts)
    {
      kwsinit (&kwset);
      /* First, we compile in the substrings known to be exact
	 matches.  The kwset matcher will return the index
	 of the matching string that it chooses. */
      for (dm = dfa.musts; dm; dm = dm->next)
	{
	  if (!dm->exact)
	    continue;
	  ++kwset_exact_matches;
	  if ((err = kwsincr_case (dm->must)) != NULL)
	    error (EXIT_TROUBLE, 0, "%s", err);
	}
      /* Now, we compile the substrings that will require
	 the use of the regexp matcher.  */
      for (dm = dfa.musts; dm; dm = dm->next)
	{
	  if (dm->exact)
	    continue;
	  if ((err = kwsincr_case (dm->must)) != NULL)
	    error (EXIT_TROUBLE, 0, "%s", err);
	}
      if ((err = kwsprep (kwset)) != NULL)
	error (EXIT_TROUBLE, 0, "%s", err);
    }
}

void
GEAcompile (char const *pattern, size_t size, reg_syntax_t syntax_bits)
{
  const char *err;
  const char *p, *sep;
  size_t total = size;
  char *motif;

  if (match_icase)
    syntax_bits |= RE_ICASE;
  re_set_syntax (syntax_bits);
  dfasyntax (syntax_bits, match_icase, eolbyte);

  /* For GNU regex compiler we have to pass the patterns separately to detect
     errors like "[\nallo\n]\n".  The patterns here are "[", "allo" and "]"
     GNU regex should have raise a syntax error.  The same for backref, where
     the backref should have been local to each pattern.  */
  p = pattern;
  do
    {
      size_t len;
      sep = memchr (p, '\n', total);
      if (sep)
	{
	  len = sep - p;
	  sep++;
	  total -= (len + 1);
	}
      else
	{
	  len = total;
	  total = 0;
	}

      patterns = realloc (patterns, (pcount + 1) * sizeof (*patterns));
      if (patterns == NULL)
	error (EXIT_TROUBLE, errno, _("memory exhausted"));
      patterns[pcount] = patterns0;

      if ((err = re_compile_pattern (p, len,
				    &(patterns[pcount].regexbuf))) != NULL)
	error (EXIT_TROUBLE, 0, "%s", err);
      pcount++;

      p = sep;
    } while (sep && total != 0);

  /* In the match_words and match_lines cases, we use a different pattern
     for the DFA matcher that will quickly throw out cases that won't work.
     Then if DFA succeeds we do some hairy stuff using the regex matcher
     to decide whether the match should really count. */
  if (match_words || match_lines)
    {
      static char const line_beg_no_bk[] = "^(";
      static char const line_end_no_bk[] = ")$";
      static char const word_beg_no_bk[] = "(^|[^[:alnum:]_])(";
      static char const word_end_no_bk[] = ")([^[:alnum:]_]|$)";
      static char const line_beg_bk[] = "^\\(";
      static char const line_end_bk[] = "\\)$";
      static char const word_beg_bk[] = "\\(^\\|[^[:alnum:]_]\\)\\(";
      static char const word_end_bk[] = "\\)\\([^[:alnum:]_]\\|$\\)";
      int bk = !(syntax_bits & RE_NO_BK_PARENS);
      char *n = xmalloc (sizeof word_beg_bk - 1 + size + sizeof word_end_bk);

      strcpy (n, match_lines ? (bk ? line_beg_bk : line_beg_no_bk)
			     : (bk ? word_beg_bk : word_beg_no_bk));
      total = strlen(n);
      memcpy (n + total, pattern, size);
      total += size;
      strcpy (n + total, match_lines ? (bk ? line_end_bk : line_end_no_bk)
				     : (bk ? word_end_bk : word_end_no_bk));
      total += strlen (n + total);
      pattern = motif = n;
      size = total;
    }
  else
    motif = NULL;

  dfacomp (pattern, size, &dfa, 1);
  kwsmusts ();

  free(motif);
}

size_t
EGexecute (char const *buf, size_t size, size_t *match_size,
	   char const *start_ptr)
{
  char const *buflim, *beg, *end, *match, *best_match, *mb_start;
  char eol = eolbyte;
  int backref, start, len, best_len;
  struct kwsmatch kwsm;
  size_t i, ret_val;
#ifdef MBS_SUPPORT
  if (MB_CUR_MAX > 1)
    {
      if (match_icase)
        {
          /* mbtolower adds a NUL byte at the end.  That will provide
	     space for the sentinel byte dfaexec may add.  */
          char *case_buf = mbtolower (buf, &size);
	  if (start_ptr)
	    start_ptr = case_buf + (start_ptr - buf);
          buf = case_buf;
        }
    }
#endif /* MBS_SUPPORT */

  mb_start = buf;
  buflim = buf + size;

  for (beg = end = buf; end < buflim; beg = end)
    {
      if (!start_ptr)
	{
	  /* We don't care about an exact match.  */
	  if (kwset)
	    {
	      /* Find a possible match using the KWset matcher. */
	      size_t offset = kwsexec (kwset, beg, buflim - beg, &kwsm);
	      if (offset == (size_t) -1)
		goto failure;
	      beg += offset;
	      /* Narrow down to the line containing the candidate, and
		 run it through DFA. */
	      if ((end = memchr(beg, eol, buflim - beg)) != NULL)
	        end++;
              else
                end = buflim;
	      match = beg;
	      while (beg > buf && beg[-1] != eol)
		--beg;
	      if (kwsm.index < kwset_exact_matches)
                {
#ifdef MBS_SUPPORT
                  if (mb_start < beg)
                    mb_start = beg;
                  if (MB_CUR_MAX == 1 || !is_mb_middle (&mb_start, match, buflim))
#endif
                    goto success;
                }
	      if (dfaexec (&dfa, beg, (char *) end, 0, NULL, &backref) == NULL)
		continue;
	    }
	  else
	    {
	      /* No good fixed strings; start with DFA. */
	      char const *next_beg = dfaexec (&dfa, beg, (char *) buflim,
					      0, NULL, &backref);
	      if (next_beg == NULL)
		break;
	      /* Narrow down to the line we've found. */
	      beg = next_beg;
	      if ((end = memchr(beg, eol, buflim - beg)) != NULL)
	        end++;
              else
                end = buflim;
	      while (beg > buf && beg[-1] != eol)
		--beg;
	    }
	  /* Successful, no backreferences encountered! */
	  if (!backref)
	    goto success;
	}
      else
	{
	  /* We are looking for the leftmost (then longest) exact match.
	     We will go through the outer loop only once.  */
	  beg = start_ptr;
	  end = buflim;
	}

      /* If we've made it to this point, this means DFA has seen
	 a probable match, and we need to run it through Regex. */
      best_match = end;
      best_len = 0;
      for (i = 0; i < pcount; i++)
	{
	  patterns[i].regexbuf.not_eol = 0;
	  if (0 <= (start = re_search (&(patterns[i].regexbuf),
				       buf, end - buf - 1,
				       beg - buf, end - beg - 1,
				       &(patterns[i].regs))))
	    {
	      //prophet generated patch
	      if (__get_mutant()==0) {
	      if ((__is_neg(28, &(start), sizeof (start), &(len), sizeof (len), &(i), sizeof (i), &(patterns), sizeof (patterns), &(patterns[i].regs.end), sizeof (patterns[i].regs.end), &(buf), sizeof (buf), &(match), sizeof (match), &(best_match), sizeof (best_match), &(beg), sizeof (beg), &(end), sizeof (end), &(start_ptr), sizeof (start_ptr), &(match_words), sizeof (match_words), &(match_lines), sizeof (match_lines), &(pcount), sizeof (pcount), &(best_len), sizeof (best_len), &(buflim), sizeof (buflim), &(backref), sizeof (backref), &(eol), sizeof (eol), &(mb_start), sizeof (mb_start), &(kwset_exact_matches), sizeof (kwset_exact_matches), &(kwset), sizeof (kwset), &(size), sizeof (size), &(ret_val), sizeof (ret_val), &(match_size), sizeof (match_size), &(match_icase), sizeof (match_icase), &(eolbyte), sizeof (eolbyte), &(patterns[i].regs.num_regs), sizeof (patterns[i].regs.num_regs), &(patterns[i].regs.start), sizeof (patterns[i].regs.start))))
	          goto assess_pattern_match;
	      len = patterns[i].regs.end[0] - start;
	      }
	      else if (__get_mutant()==1) {
	      if ((__is_neg(28, &(start), sizeof (start), &(len), sizeof (len), &(i), sizeof (i), &(patterns), sizeof (patterns), &(patterns[i].regs.end), sizeof (patterns[i].regs.end), &(buf), sizeof (buf), &(match), sizeof (match), &(best_match), sizeof (best_match), &(beg), sizeof (beg), &(end), sizeof (end), &(start_ptr), sizeof (start_ptr), &(match_words), sizeof (match_words), &(match_lines), sizeof (match_lines), &(pcount), sizeof (pcount), &(best_len), sizeof (best_len), &(buflim), sizeof (buflim), &(backref), sizeof (backref), &(eol), sizeof (eol), &(mb_start), sizeof (mb_start), &(kwset_exact_matches), sizeof (kwset_exact_matches), &(kwset), sizeof (kwset), &(size), sizeof (size), &(ret_val), sizeof (ret_val), &(match_size), sizeof (match_size), &(match_icase), sizeof (match_icase), &(eolbyte), sizeof (eolbyte), &(patterns[i].regs.num_regs), sizeof (patterns[i].regs.num_regs), &(patterns[i].regs.start), sizeof (patterns[i].regs.start))))
	          goto failure;
	      len = patterns[i].regs.end[0] - start;
	      }
	      else if (__get_mutant()==2) {
	      if ((__is_neg(28, &(start), sizeof (start), &(len), sizeof (len), &(i), sizeof (i), &(patterns), sizeof (patterns), &(patterns[i].regs.end), sizeof (patterns[i].regs.end), &(buf), sizeof (buf), &(match), sizeof (match), &(best_match), sizeof (best_match), &(beg), sizeof (beg), &(end), sizeof (end), &(start_ptr), sizeof (start_ptr), &(match_words), sizeof (match_words), &(match_lines), sizeof (match_lines), &(pcount), sizeof (pcount), &(best_len), sizeof (best_len), &(buflim), sizeof (buflim), &(backref), sizeof (backref), &(eol), sizeof (eol), &(mb_start), sizeof (mb_start), &(kwset_exact_matches), sizeof (kwset_exact_matches), &(kwset), sizeof (kwset), &(size), sizeof (size), &(ret_val), sizeof (ret_val), &(match_size), sizeof (match_size), &(match_icase), sizeof (match_icase), &(eolbyte), sizeof (eolbyte), &(patterns[i].regs.num_regs), sizeof (patterns[i].regs.num_regs), &(patterns[i].regs.start), sizeof (patterns[i].regs.start))))
	          goto success;
	      len = patterns[i].regs.end[0] - start;
	      }
	      else if (__get_mutant()==3) {
	      if ((__is_neg(28, &(start), sizeof (start), &(len), sizeof (len), &(i), sizeof (i), &(patterns), sizeof (patterns), &(patterns[i].regs.end), sizeof (patterns[i].regs.end), &(buf), sizeof (buf), &(match), sizeof (match), &(best_match), sizeof (best_match), &(beg), sizeof (beg), &(end), sizeof (end), &(start_ptr), sizeof (start_ptr), &(match_words), sizeof (match_words), &(match_lines), sizeof (match_lines), &(pcount), sizeof (pcount), &(best_len), sizeof (best_len), &(buflim), sizeof (buflim), &(backref), sizeof (backref), &(eol), sizeof (eol), &(mb_start), sizeof (mb_start), &(kwset_exact_matches), sizeof (kwset_exact_matches), &(kwset), sizeof (kwset), &(size), sizeof (size), &(ret_val), sizeof (ret_val), &(match_size), sizeof (match_size), &(match_icase), sizeof (match_icase), &(eolbyte), sizeof (eolbyte), &(patterns[i].regs.num_regs), sizeof (patterns[i].regs.num_regs), &(patterns[i].regs.start), sizeof (patterns[i].regs.start))))
	          goto success_in_len;
	      len = patterns[i].regs.end[0] - start;
	      }
	      else if (__get_mutant()==4) {
	      if ((__is_neg(28, &(start), sizeof (start), &(len), sizeof (len), &(i), sizeof (i), &(patterns), sizeof (patterns), &(patterns[i].regs.end), sizeof (patterns[i].regs.end), &(buf), sizeof (buf), &(match), sizeof (match), &(best_match), sizeof (best_match), &(beg), sizeof (beg), &(end), sizeof (end), &(start_ptr), sizeof (start_ptr), &(match_words), sizeof (match_words), &(match_lines), sizeof (match_lines), &(pcount), sizeof (pcount), &(best_len), sizeof (best_len), &(buflim), sizeof (buflim), &(backref), sizeof (backref), &(eol), sizeof (eol), &(mb_start), sizeof (mb_start), &(kwset_exact_matches), sizeof (kwset_exact_matches), &(kwset), sizeof (kwset), &(size), sizeof (size), &(ret_val), sizeof (ret_val), &(match_size), sizeof (match_size), &(match_icase), sizeof (match_icase), &(eolbyte), sizeof (eolbyte), &(patterns[i].regs.num_regs), sizeof (patterns[i].regs.num_regs), &(patterns[i].regs.start), sizeof (patterns[i].regs.start))))
	          goto out;
	      len = patterns[i].regs.end[0] - start;
	      }
	      else if (__get_mutant()==5) {
	      if ((__is_neg(28, &(start), sizeof (start), &(len), sizeof (len), &(i), sizeof (i), &(patterns), sizeof (patterns), &(patterns[i].regs.end), sizeof (patterns[i].regs.end), &(buf), sizeof (buf), &(match), sizeof (match), &(best_match), sizeof (best_match), &(beg), sizeof (beg), &(end), sizeof (end), &(start_ptr), sizeof (start_ptr), &(match_words), sizeof (match_words), &(match_lines), sizeof (match_lines), &(pcount), sizeof (pcount), &(best_len), sizeof (best_len), &(buflim), sizeof (buflim), &(backref), sizeof (backref), &(eol), sizeof (eol), &(mb_start), sizeof (mb_start), &(kwset_exact_matches), sizeof (kwset_exact_matches), &(kwset), sizeof (kwset), &(size), sizeof (size), &(ret_val), sizeof (ret_val), &(match_size), sizeof (match_size), &(match_icase), sizeof (match_icase), &(eolbyte), sizeof (eolbyte), &(patterns[i].regs.num_regs), sizeof (patterns[i].regs.num_regs), &(patterns[i].regs.start), sizeof (patterns[i].regs.start))))
	          return -1;
	      len = patterns[i].regs.end[0] - start;
	      }
	      else if (__get_mutant()==6) {
	      if ((__is_neg(28, &(start), sizeof (start), &(len), sizeof (len), &(i), sizeof (i), &(patterns), sizeof (patterns), &(patterns[i].regs.end), sizeof (patterns[i].regs.end), &(buf), sizeof (buf), &(match), sizeof (match), &(best_match), sizeof (best_match), &(beg), sizeof (beg), &(end), sizeof (end), &(start_ptr), sizeof (start_ptr), &(match_words), sizeof (match_words), &(match_lines), sizeof (match_lines), &(pcount), sizeof (pcount), &(best_len), sizeof (best_len), &(buflim), sizeof (buflim), &(backref), sizeof (backref), &(eol), sizeof (eol), &(mb_start), sizeof (mb_start), &(kwset_exact_matches), sizeof (kwset_exact_matches), &(kwset), sizeof (kwset), &(size), sizeof (size), &(ret_val), sizeof (ret_val), &(match_size), sizeof (match_size), &(match_icase), sizeof (match_icase), &(eolbyte), sizeof (eolbyte), &(patterns[i].regs.num_regs), sizeof (patterns[i].regs.num_regs), &(patterns[i].regs.start), sizeof (patterns[i].regs.start))))
	          return 0;
	      len = patterns[i].regs.end[0] - start;
	      }
	      else if (__get_mutant()==7) {
	      if ((__is_neg(28, &(start), sizeof (start), &(len), sizeof (len), &(i), sizeof (i), &(patterns), sizeof (patterns), &(patterns[i].regs.end), sizeof (patterns[i].regs.end), &(buf), sizeof (buf), &(match), sizeof (match), &(best_match), sizeof (best_match), &(beg), sizeof (beg), &(end), sizeof (end), &(start_ptr), sizeof (start_ptr), &(match_words), sizeof (match_words), &(match_lines), sizeof (match_lines), &(pcount), sizeof (pcount), &(best_len), sizeof (best_len), &(buflim), sizeof (buflim), &(backref), sizeof (backref), &(eol), sizeof (eol), &(mb_start), sizeof (mb_start), &(kwset_exact_matches), sizeof (kwset_exact_matches), &(kwset), sizeof (kwset), &(size), sizeof (size), &(ret_val), sizeof (ret_val), &(match_size), sizeof (match_size), &(match_icase), sizeof (match_icase), &(eolbyte), sizeof (eolbyte), &(patterns[i].regs.num_regs), sizeof (patterns[i].regs.num_regs), &(patterns[i].regs.start), sizeof (patterns[i].regs.start))))
	          return 1;
	      len = patterns[i].regs.end[0] - start;
	      }
	      else if (__get_mutant()==8) {
	      if ((__is_neg(28, &(start), sizeof (start), &(len), sizeof (len), &(i), sizeof (i), &(patterns), sizeof (patterns), &(patterns[i].regs.end), sizeof (patterns[i].regs.end), &(buf), sizeof (buf), &(match), sizeof (match), &(best_match), sizeof (best_match), &(beg), sizeof (beg), &(end), sizeof (end), &(start_ptr), sizeof (start_ptr), &(match_words), sizeof (match_words), &(match_lines), sizeof (match_lines), &(pcount), sizeof (pcount), &(best_len), sizeof (best_len), &(buflim), sizeof (buflim), &(backref), sizeof (backref), &(eol), sizeof (eol), &(mb_start), sizeof (mb_start), &(kwset_exact_matches), sizeof (kwset_exact_matches), &(kwset), sizeof (kwset), &(size), sizeof (size), &(ret_val), sizeof (ret_val), &(match_size), sizeof (match_size), &(match_icase), sizeof (match_icase), &(eolbyte), sizeof (eolbyte), &(patterns[i].regs.num_regs), sizeof (patterns[i].regs.num_regs), &(patterns[i].regs.start), sizeof (patterns[i].regs.start))))
	          break;
	      len = patterns[i].regs.end[0] - start;
	      }
	      match = buf + start;
	      if (match > best_match)
		continue;
	      if (start_ptr && !match_words)
		goto assess_pattern_match;
	      if ((!match_lines && !match_words)
		  || (match_lines && len == end - beg - 1))
		{
		  match = beg;
		  len = end - beg;
		  goto assess_pattern_match;
		}
	      /* If -w, check if the match aligns with word boundaries.
		 We do this iteratively because:
		 (a) the line may contain more than one occurence of the
		 pattern, and
		 (b) Several alternatives in the pattern might be valid at a
		 given point, and we may need to consider a shorter one to
		 find a word boundary.  */
	      if (match_words)
		while (match <= best_match)
		  {
		    if ((match == buf || !WCHAR ((unsigned char) match[-1]))
			&& (len == end - beg - 1
			    || !WCHAR ((unsigned char) match[len])))
		      goto assess_pattern_match;
		    if (len > 0)
		      {
			/* Try a shorter length anchored at the same place. */
			--len;
			patterns[i].regexbuf.not_eol = 1;
			len = re_match (&(patterns[i].regexbuf),
					buf, match + len - beg, match - buf,
					&(patterns[i].regs));
		      }
		    if (len <= 0)
		      {
			/* Try looking further on. */
			if (match == end - 1)
			  break;
			match++;
			patterns[i].regexbuf.not_eol = 0;
			start = re_search (&(patterns[i].regexbuf),
					   buf, end - buf - 1,
					   match - buf, end - match - 1,
					   &(patterns[i].regs));
			if (start < 0)
			  break;
			len = patterns[i].regs.end[0] - start;
			match = buf + start;
		      }
		  } /* while (match <= best_match) */
	      continue;
	    assess_pattern_match:
	      if (!start_ptr)
		{
		  /* Good enough for a non-exact match.
		     No need to look at further patterns, if any.  */
		  beg = match;
		  goto success_in_len;
		}
	      if (match < best_match || (match == best_match && len > best_len))
		{
		  /* Best exact match:  leftmost, then longest.  */
		  best_match = match;
		  best_len = len;
		}
	    } /* if re_search >= 0 */
	} /* for Regex patterns.  */
	if (best_match < end)
	  {
	    /* We have found an exact match.  We were just
	       waiting for the best one (leftmost then longest).  */
	    beg = best_match;
	    len = best_len;
	    goto success_in_len;
	  }
    } /* for (beg = end ..) */

 failure:
  ret_val = -1;
  goto out;

 success:
  len = end - beg;
 success_in_len:
  *match_size = len;
  ret_val = beg - buf;
 out:
  return ret_val;
}

Building:src at:
/home/ubuntu/spr-fast/tests/corebench/grep/grep-case-8a025cf8-8f08d8e2/tempworkdir-l/srcMerged code building succ, going to invoke tester!
CondTester, Testing instance id 62:
//src_file:src/dfasearch.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); void* memset(void*, int, unsigned long); 
/* dfasearch.c - searching subroutines using dfa and regex for grep.
   Copyright 1992, 1998, 2000, 2007, 2009-2010 Free Software Foundation, Inc.

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 3, or (at your option)
   any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program; if not, write to the Free Software
   Foundation, Inc., 51 Franklin Street - Fifth Floor, Boston, MA
   02110-1301, USA.  */

/* Written August 1992 by Mike Haertel. */

#include <config.h>
#include "search.h"
#include "dfa.h"

/* For -w, we also consider _ to be word constituent.  */
#define WCHAR(C) (ISALNUM(C) || (C) == '_')

/* KWset compiled pattern.  For Ecompile and Gcompile, we compile
   a list of strings, at least one of which is known to occur in
   any string matching the regexp. */
static kwset_t kwset;

/* DFA compiled regexp. */
static struct dfa dfa;

/* The Regex compiled patterns.  */
static struct patterns
{
  /* Regex compiled regexp. */
  struct re_pattern_buffer regexbuf;
  struct re_registers regs; /* This is here on account of a BRAIN-DEAD
			       Q@#%!# library interface in regex.c.  */
} patterns0;

struct patterns *patterns;
size_t pcount;

void
dfaerror (char const *mesg)
{
  error (EXIT_TROUBLE, 0, "%s", mesg);

  /* notreached */
  /* Tell static analyzers that this function does not return.  */
  abort ();
}

/* Number of compiled fixed strings known to exactly match the regexp.
   If kwsexec returns < kwset_exact_matches, then we don't need to
   call the regexp matcher at all. */
static int kwset_exact_matches;

static char const *
kwsincr_case (const char *must)
{
  const char *buf;
  size_t n;

  n = strlen (must);
#ifdef MBS_SUPPORT
  if (match_icase && MB_CUR_MAX > 1)
    buf = mbtolower (must, &n);
  else
#endif
    buf = must;
  return kwsincr (kwset, buf, n);
}

/* If the DFA turns out to have some set of fixed strings one of
   which must occur in the match, then we build a kwset matcher
   to find those strings, and thus quickly filter out impossible
   matches. */
static void
kwsmusts (void)
{
  struct dfamust const *dm;
  char const *err;

  if (dfa.musts)
    {
      kwsinit (&kwset);
      /* First, we compile in the substrings known to be exact
	 matches.  The kwset matcher will return the index
	 of the matching string that it chooses. */
      for (dm = dfa.musts; dm; dm = dm->next)
	{
	  if (!dm->exact)
	    continue;
	  ++kwset_exact_matches;
	  if ((err = kwsincr_case (dm->must)) != NULL)
	    error (EXIT_TROUBLE, 0, "%s", err);
	}
      /* Now, we compile the substrings that will require
	 the use of the regexp matcher.  */
      for (dm = dfa.musts; dm; dm = dm->next)
	{
	  if (dm->exact)
	    continue;
	  if ((err = kwsincr_case (dm->must)) != NULL)
	    error (EXIT_TROUBLE, 0, "%s", err);
	}
      if ((err = kwsprep (kwset)) != NULL)
	error (EXIT_TROUBLE, 0, "%s", err);
    }
}

void
GEAcompile (char const *pattern, size_t size, reg_syntax_t syntax_bits)
{
  const char *err;
  const char *p, *sep;
  size_t total = size;
  char *motif;

  if (match_icase)
    syntax_bits |= RE_ICASE;
  re_set_syntax (syntax_bits);
  dfasyntax (syntax_bits, match_icase, eolbyte);

  /* For GNU regex compiler we have to pass the patterns separately to detect
     errors like "[\nallo\n]\n".  The patterns here are "[", "allo" and "]"
     GNU regex should have raise a syntax error.  The same for backref, where
     the backref should have been local to each pattern.  */
  p = pattern;
  do
    {
      size_t len;
      sep = memchr (p, '\n', total);
      if (sep)
	{
	  len = sep - p;
	  sep++;
	  total -= (len + 1);
	}
      else
	{
	  len = total;
	  total = 0;
	}

      patterns = realloc (patterns, (pcount + 1) * sizeof (*patterns));
      if (patterns == NULL)
	error (EXIT_TROUBLE, errno, _("memory exhausted"));
      patterns[pcount] = patterns0;

      if ((err = re_compile_pattern (p, len,
				    &(patterns[pcount].regexbuf))) != NULL)
	error (EXIT_TROUBLE, 0, "%s", err);
      pcount++;

      p = sep;
    } while (sep && total != 0);

  /* In the match_words and match_lines cases, we use a different pattern
     for the DFA matcher that will quickly throw out cases that won't work.
     Then if DFA succeeds we do some hairy stuff using the regex matcher
     to decide whether the match should really count. */
  if (match_words || match_lines)
    {
      static char const line_beg_no_bk[] = "^(";
      static char const line_end_no_bk[] = ")$";
      static char const word_beg_no_bk[] = "(^|[^[:alnum:]_])(";
      static char const word_end_no_bk[] = ")([^[:alnum:]_]|$)";
      static char const line_beg_bk[] = "^\\(";
      static char const line_end_bk[] = "\\)$";
      static char const word_beg_bk[] = "\\(^\\|[^[:alnum:]_]\\)\\(";
      static char const word_end_bk[] = "\\)\\([^[:alnum:]_]\\|$\\)";
      int bk = !(syntax_bits & RE_NO_BK_PARENS);
      char *n = xmalloc (sizeof word_beg_bk - 1 + size + sizeof word_end_bk);

      strcpy (n, match_lines ? (bk ? line_beg_bk : line_beg_no_bk)
			     : (bk ? word_beg_bk : word_beg_no_bk));
      total = strlen(n);
      memcpy (n + total, pattern, size);
      total += size;
      strcpy (n + total, match_lines ? (bk ? line_end_bk : line_end_no_bk)
				     : (bk ? word_end_bk : word_end_no_bk));
      total += strlen (n + total);
      pattern = motif = n;
      size = total;
    }
  else
    motif = NULL;

  dfacomp (pattern, size, &dfa, 1);
  kwsmusts ();

  free(motif);
}

size_t
EGexecute (char const *buf, size_t size, size_t *match_size,
	   char const *start_ptr)
{
  char const *buflim, *beg, *end, *match, *best_match, *mb_start;
  char eol = eolbyte;
  int backref, start, len, best_len;
  struct kwsmatch kwsm;
  size_t i, ret_val;
#ifdef MBS_SUPPORT
  if (MB_CUR_MAX > 1)
    {
      if (match_icase)
        {
          /* mbtolower adds a NUL byte at the end.  That will provide
	     space for the sentinel byte dfaexec may add.  */
          char *case_buf = mbtolower (buf, &size);
	  if (start_ptr)
	    start_ptr = case_buf + (start_ptr - buf);
          buf = case_buf;
        }
    }
#endif /* MBS_SUPPORT */

  mb_start = buf;
  buflim = buf + size;

  for (beg = end = buf; end < buflim; beg = end)
    {
      if (!start_ptr)
	{
	  /* We don't care about an exact match.  */
	  if (kwset)
	    {
	      /* Find a possible match using the KWset matcher. */
	      size_t offset = kwsexec (kwset, beg, buflim - beg, &kwsm);
	      if (offset == (size_t) -1)
		goto failure;
	      beg += offset;
	      /* Narrow down to the line containing the candidate, and
		 run it through DFA. */
	      if ((end = memchr(beg, eol, buflim - beg)) != NULL)
	        end++;
              else
                end = buflim;
	      match = beg;
	      while (beg > buf && beg[-1] != eol)
		--beg;
	      if (kwsm.index < kwset_exact_matches)
                {
#ifdef MBS_SUPPORT
                  if (mb_start < beg)
                    mb_start = beg;
                  if (MB_CUR_MAX == 1 || !is_mb_middle (&mb_start, match, buflim))
#endif
                    goto success;
                }
	      if (dfaexec (&dfa, beg, (char *) end, 0, NULL, &backref) == NULL)
		continue;
	    }
	  else
	    {
	      /* No good fixed strings; start with DFA. */
	      char const *next_beg = dfaexec (&dfa, beg, (char *) buflim,
					      0, NULL, &backref);
	      if (next_beg == NULL)
		break;
	      /* Narrow down to the line we've found. */
	      beg = next_beg;
	      if ((end = memchr(beg, eol, buflim - beg)) != NULL)
	        end++;
              else
                end = buflim;
	      while (beg > buf && beg[-1] != eol)
		--beg;
	    }
	  /* Successful, no backreferences encountered! */
	  if (!backref)
	    goto success;
	}
      else
	{
	  /* We are looking for the leftmost (then longest) exact match.
	     We will go through the outer loop only once.  */
	  beg = start_ptr;
	  end = buflim;
	}

      /* If we've made it to this point, this means DFA has seen
	 a probable match, and we need to run it through Regex. */
      best_match = end;
      best_len = 0;
      for (i = 0; i < pcount; i++)
	{
	  patterns[i].regexbuf.not_eol = 0;
	  if (0 <= (start = re_search (&(patterns[i].regexbuf),
				       buf, end - buf - 1,
				       beg - buf, end - beg - 1,
				       &(patterns[i].regs))))
	    {
	      
//Patch 0:
if ((__is_neg(28, &(start), sizeof (start), &(len), sizeof (len), &(i), sizeof (i), &(patterns), sizeof (patterns), &(patterns[i].regs.end), sizeof (patterns[i].regs.end), &(buf), sizeof (buf), &(match), sizeof (match), &(best_match), sizeof (best_match), &(beg), sizeof (beg), &(end), sizeof (end), &(start_ptr), sizeof (start_ptr), &(match_words), sizeof (match_words), &(match_lines), sizeof (match_lines), &(pcount), sizeof (pcount), &(best_len), sizeof (best_len), &(buflim), sizeof (buflim), &(backref), sizeof (backref), &(eol), sizeof (eol), &(mb_start), sizeof (mb_start), &(kwset_exact_matches), sizeof (kwset_exact_matches), &(kwset), sizeof (kwset), &(size), sizeof (size), &(ret_val), sizeof (ret_val), &(match_size), sizeof (match_size), &(match_icase), sizeof (match_icase), &(eolbyte), sizeof (eolbyte), &(patterns[i].regs.num_regs), sizeof (patterns[i].regs.num_regs), &(patterns[i].regs.start), sizeof (patterns[i].regs.start))))
    goto assess_pattern_match;
len = patterns[i].regs.end[0] - start;

//CodeSeg 1:
	      match = buf + start;
	      if (match > best_match)
		continue;
	      if (start_ptr && !match_words)
		goto assess_pattern_match;
	      if ((!match_lines && !match_words)
		  || (match_lines && len == end - beg - 1))
		{
		  match = beg;
		  len = end - beg;
		  goto assess_pattern_match;
		}
	      /* If -w, check if the match aligns with word boundaries.
		 We do this iteratively because:
		 (a) the line may contain more than one occurence of the
		 pattern, and
		 (b) Several alternatives in the pattern might be valid at a
		 given point, and we may need to consider a shorter one to
		 find a word boundary.  */
	      if (match_words)
		while (match <= best_match)
		  {
		    if ((match == buf || !WCHAR ((unsigned char) match[-1]))
			&& (len == end - beg - 1
			    || !WCHAR ((unsigned char) match[len])))
		      goto assess_pattern_match;
		    if (len > 0)
		      {
			/* Try a shorter length anchored at the same place. */
			--len;
			patterns[i].regexbuf.not_eol = 1;
			len = re_match (&(patterns[i].regexbuf),
					buf, match + len - beg, match - buf,
					&(patterns[i].regs));
		      }
		    if (len <= 0)
		      {
			/* Try looking further on. */
			if (match == end - 1)
			  break;
			match++;
			patterns[i].regexbuf.not_eol = 0;
			start = re_search (&(patterns[i].regexbuf),
					   buf, end - buf - 1,
					   match - buf, end - match - 1,
					   &(patterns[i].regs));
			if (start < 0)
			  break;
			len = patterns[i].regs.end[0] - start;
			match = buf + start;
		      }
		  } /* while (match <= best_match) */
	      continue;
	    assess_pattern_match:
	      if (!start_ptr)
		{
		  /* Good enough for a non-exact match.
		     No need to look at further patterns, if any.  */
		  beg = match;
		  goto success_in_len;
		}
	      if (match < best_match || (match == best_match && len > best_len))
		{
		  /* Best exact match:  leftmost, then longest.  */
		  best_match = match;
		  best_len = len;
		}
	    } /* if re_search >= 0 */
	} /* for Regex patterns.  */
	if (best_match < end)
	  {
	    /* We have found an exact match.  We were just
	       waiting for the best one (leftmost then longest).  */
	    beg = best_match;
	    len = best_len;
	    goto success_in_len;
	  }
    } /* for (beg = end ..) */

 failure:
  ret_val = -1;
  goto out;

 success:
  len = end - beg;
 success_in_len:
  *match_size = len;
  ret_val = beg - buf;
 out:
  return ret_val;
}

Testing negative cases!
Testing 0 (with abstract condition) ENVIS_NEG
Iteration 0
Running test command:
/home/ubuntu/spr-fast/tools/grep-test.py /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-8a025cf8-8f08d8e2/tempworkdir-l/src /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-8a025cf8-8f08d8e2/tempworkdir-l/tests /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-8a025cf8-8f08d8e2/tempworkdir-l 0  > __res
Opening:/tmp/neg.tmp!
NegativeBRANCH RECORD/tmp/neg.tmp!
APPENDING TO ISNEG:/tmp/neg.tmp!
Branch 0: 0
Iteration 1
Running test command:
/home/ubuntu/spr-fast/tools/grep-test.py /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-8a025cf8-8f08d8e2/tempworkdir-l/src /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-8a025cf8-8f08d8e2/tempworkdir-l/tests /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-8a025cf8-8f08d8e2/tempworkdir-l 0  > __res
Opening:/tmp/neg.tmp!
NegativeBRANCH RECORD/tmp/neg.tmp!
APPENDING TO ISNEG:/tmp/neg.tmp!
Branch 0: 1
Running test command:
/home/ubuntu/spr-fast/tools/grep-test.py /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-8a025cf8-8f08d8e2/tempworkdir-l/src /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-8a025cf8-8f08d8e2/tempworkdir-l/tests /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-8a025cf8-8f08d8e2/tempworkdir-l 0  > __res
CondTester, Testing instance id 63:
//src_file:src/dfasearch.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); void* memset(void*, int, unsigned long); 
/* dfasearch.c - searching subroutines using dfa and regex for grep.
   Copyright 1992, 1998, 2000, 2007, 2009-2010 Free Software Foundation, Inc.

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 3, or (at your option)
   any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program; if not, write to the Free Software
   Foundation, Inc., 51 Franklin Street - Fifth Floor, Boston, MA
   02110-1301, USA.  */

/* Written August 1992 by Mike Haertel. */

#include <config.h>
#include "search.h"
#include "dfa.h"

/* For -w, we also consider _ to be word constituent.  */
#define WCHAR(C) (ISALNUM(C) || (C) == '_')

/* KWset compiled pattern.  For Ecompile and Gcompile, we compile
   a list of strings, at least one of which is known to occur in
   any string matching the regexp. */
static kwset_t kwset;

/* DFA compiled regexp. */
static struct dfa dfa;

/* The Regex compiled patterns.  */
static struct patterns
{
  /* Regex compiled regexp. */
  struct re_pattern_buffer regexbuf;
  struct re_registers regs; /* This is here on account of a BRAIN-DEAD
			       Q@#%!# library interface in regex.c.  */
} patterns0;

struct patterns *patterns;
size_t pcount;

void
dfaerror (char const *mesg)
{
  error (EXIT_TROUBLE, 0, "%s", mesg);

  /* notreached */
  /* Tell static analyzers that this function does not return.  */
  abort ();
}

/* Number of compiled fixed strings known to exactly match the regexp.
   If kwsexec returns < kwset_exact_matches, then we don't need to
   call the regexp matcher at all. */
static int kwset_exact_matches;

static char const *
kwsincr_case (const char *must)
{
  const char *buf;
  size_t n;

  n = strlen (must);
#ifdef MBS_SUPPORT
  if (match_icase && MB_CUR_MAX > 1)
    buf = mbtolower (must, &n);
  else
#endif
    buf = must;
  return kwsincr (kwset, buf, n);
}

/* If the DFA turns out to have some set of fixed strings one of
   which must occur in the match, then we build a kwset matcher
   to find those strings, and thus quickly filter out impossible
   matches. */
static void
kwsmusts (void)
{
  struct dfamust const *dm;
  char const *err;

  if (dfa.musts)
    {
      kwsinit (&kwset);
      /* First, we compile in the substrings known to be exact
	 matches.  The kwset matcher will return the index
	 of the matching string that it chooses. */
      for (dm = dfa.musts; dm; dm = dm->next)
	{
	  if (!dm->exact)
	    continue;
	  ++kwset_exact_matches;
	  if ((err = kwsincr_case (dm->must)) != NULL)
	    error (EXIT_TROUBLE, 0, "%s", err);
	}
      /* Now, we compile the substrings that will require
	 the use of the regexp matcher.  */
      for (dm = dfa.musts; dm; dm = dm->next)
	{
	  if (dm->exact)
	    continue;
	  if ((err = kwsincr_case (dm->must)) != NULL)
	    error (EXIT_TROUBLE, 0, "%s", err);
	}
      if ((err = kwsprep (kwset)) != NULL)
	error (EXIT_TROUBLE, 0, "%s", err);
    }
}

void
GEAcompile (char const *pattern, size_t size, reg_syntax_t syntax_bits)
{
  const char *err;
  const char *p, *sep;
  size_t total = size;
  char *motif;

  if (match_icase)
    syntax_bits |= RE_ICASE;
  re_set_syntax (syntax_bits);
  dfasyntax (syntax_bits, match_icase, eolbyte);

  /* For GNU regex compiler we have to pass the patterns separately to detect
     errors like "[\nallo\n]\n".  The patterns here are "[", "allo" and "]"
     GNU regex should have raise a syntax error.  The same for backref, where
     the backref should have been local to each pattern.  */
  p = pattern;
  do
    {
      size_t len;
      sep = memchr (p, '\n', total);
      if (sep)
	{
	  len = sep - p;
	  sep++;
	  total -= (len + 1);
	}
      else
	{
	  len = total;
	  total = 0;
	}

      patterns = realloc (patterns, (pcount + 1) * sizeof (*patterns));
      if (patterns == NULL)
	error (EXIT_TROUBLE, errno, _("memory exhausted"));
      patterns[pcount] = patterns0;

      if ((err = re_compile_pattern (p, len,
				    &(patterns[pcount].regexbuf))) != NULL)
	error (EXIT_TROUBLE, 0, "%s", err);
      pcount++;

      p = sep;
    } while (sep && total != 0);

  /* In the match_words and match_lines cases, we use a different pattern
     for the DFA matcher that will quickly throw out cases that won't work.
     Then if DFA succeeds we do some hairy stuff using the regex matcher
     to decide whether the match should really count. */
  if (match_words || match_lines)
    {
      static char const line_beg_no_bk[] = "^(";
      static char const line_end_no_bk[] = ")$";
      static char const word_beg_no_bk[] = "(^|[^[:alnum:]_])(";
      static char const word_end_no_bk[] = ")([^[:alnum:]_]|$)";
      static char const line_beg_bk[] = "^\\(";
      static char const line_end_bk[] = "\\)$";
      static char const word_beg_bk[] = "\\(^\\|[^[:alnum:]_]\\)\\(";
      static char const word_end_bk[] = "\\)\\([^[:alnum:]_]\\|$\\)";
      int bk = !(syntax_bits & RE_NO_BK_PARENS);
      char *n = xmalloc (sizeof word_beg_bk - 1 + size + sizeof word_end_bk);

      strcpy (n, match_lines ? (bk ? line_beg_bk : line_beg_no_bk)
			     : (bk ? word_beg_bk : word_beg_no_bk));
      total = strlen(n);
      memcpy (n + total, pattern, size);
      total += size;
      strcpy (n + total, match_lines ? (bk ? line_end_bk : line_end_no_bk)
				     : (bk ? word_end_bk : word_end_no_bk));
      total += strlen (n + total);
      pattern = motif = n;
      size = total;
    }
  else
    motif = NULL;

  dfacomp (pattern, size, &dfa, 1);
  kwsmusts ();

  free(motif);
}

size_t
EGexecute (char const *buf, size_t size, size_t *match_size,
	   char const *start_ptr)
{
  char const *buflim, *beg, *end, *match, *best_match, *mb_start;
  char eol = eolbyte;
  int backref, start, len, best_len;
  struct kwsmatch kwsm;
  size_t i, ret_val;
#ifdef MBS_SUPPORT
  if (MB_CUR_MAX > 1)
    {
      if (match_icase)
        {
          /* mbtolower adds a NUL byte at the end.  That will provide
	     space for the sentinel byte dfaexec may add.  */
          char *case_buf = mbtolower (buf, &size);
	  if (start_ptr)
	    start_ptr = case_buf + (start_ptr - buf);
          buf = case_buf;
        }
    }
#endif /* MBS_SUPPORT */

  mb_start = buf;
  buflim = buf + size;

  for (beg = end = buf; end < buflim; beg = end)
    {
      if (!start_ptr)
	{
	  /* We don't care about an exact match.  */
	  if (kwset)
	    {
	      /* Find a possible match using the KWset matcher. */
	      size_t offset = kwsexec (kwset, beg, buflim - beg, &kwsm);
	      if (offset == (size_t) -1)
		goto failure;
	      beg += offset;
	      /* Narrow down to the line containing the candidate, and
		 run it through DFA. */
	      if ((end = memchr(beg, eol, buflim - beg)) != NULL)
	        end++;
              else
                end = buflim;
	      match = beg;
	      while (beg > buf && beg[-1] != eol)
		--beg;
	      if (kwsm.index < kwset_exact_matches)
                {
#ifdef MBS_SUPPORT
                  if (mb_start < beg)
                    mb_start = beg;
                  if (MB_CUR_MAX == 1 || !is_mb_middle (&mb_start, match, buflim))
#endif
                    goto success;
                }
	      if (dfaexec (&dfa, beg, (char *) end, 0, NULL, &backref) == NULL)
		continue;
	    }
	  else
	    {
	      /* No good fixed strings; start with DFA. */
	      char const *next_beg = dfaexec (&dfa, beg, (char *) buflim,
					      0, NULL, &backref);
	      if (next_beg == NULL)
		break;
	      /* Narrow down to the line we've found. */
	      beg = next_beg;
	      if ((end = memchr(beg, eol, buflim - beg)) != NULL)
	        end++;
              else
                end = buflim;
	      while (beg > buf && beg[-1] != eol)
		--beg;
	    }
	  /* Successful, no backreferences encountered! */
	  if (!backref)
	    goto success;
	}
      else
	{
	  /* We are looking for the leftmost (then longest) exact match.
	     We will go through the outer loop only once.  */
	  beg = start_ptr;
	  end = buflim;
	}

      /* If we've made it to this point, this means DFA has seen
	 a probable match, and we need to run it through Regex. */
      best_match = end;
      best_len = 0;
      for (i = 0; i < pcount; i++)
	{
	  patterns[i].regexbuf.not_eol = 0;
	  if (0 <= (start = re_search (&(patterns[i].regexbuf),
				       buf, end - buf - 1,
				       beg - buf, end - beg - 1,
				       &(patterns[i].regs))))
	    {
	      
//Patch 0:
if ((__is_neg(28, &(start), sizeof (start), &(len), sizeof (len), &(i), sizeof (i), &(patterns), sizeof (patterns), &(patterns[i].regs.end), sizeof (patterns[i].regs.end), &(buf), sizeof (buf), &(match), sizeof (match), &(best_match), sizeof (best_match), &(beg), sizeof (beg), &(end), sizeof (end), &(start_ptr), sizeof (start_ptr), &(match_words), sizeof (match_words), &(match_lines), sizeof (match_lines), &(pcount), sizeof (pcount), &(best_len), sizeof (best_len), &(buflim), sizeof (buflim), &(backref), sizeof (backref), &(eol), sizeof (eol), &(mb_start), sizeof (mb_start), &(kwset_exact_matches), sizeof (kwset_exact_matches), &(kwset), sizeof (kwset), &(size), sizeof (size), &(ret_val), sizeof (ret_val), &(match_size), sizeof (match_size), &(match_icase), sizeof (match_icase), &(eolbyte), sizeof (eolbyte), &(patterns[i].regs.num_regs), sizeof (patterns[i].regs.num_regs), &(patterns[i].regs.start), sizeof (patterns[i].regs.start))))
    goto failure;
len = patterns[i].regs.end[0] - start;

//CodeSeg 1:
	      match = buf + start;
	      if (match > best_match)
		continue;
	      if (start_ptr && !match_words)
		goto assess_pattern_match;
	      if ((!match_lines && !match_words)
		  || (match_lines && len == end - beg - 1))
		{
		  match = beg;
		  len = end - beg;
		  goto assess_pattern_match;
		}
	      /* If -w, check if the match aligns with word boundaries.
		 We do this iteratively because:
		 (a) the line may contain more than one occurence of the
		 pattern, and
		 (b) Several alternatives in the pattern might be valid at a
		 given point, and we may need to consider a shorter one to
		 find a word boundary.  */
	      if (match_words)
		while (match <= best_match)
		  {
		    if ((match == buf || !WCHAR ((unsigned char) match[-1]))
			&& (len == end - beg - 1
			    || !WCHAR ((unsigned char) match[len])))
		      goto assess_pattern_match;
		    if (len > 0)
		      {
			/* Try a shorter length anchored at the same place. */
			--len;
			patterns[i].regexbuf.not_eol = 1;
			len = re_match (&(patterns[i].regexbuf),
					buf, match + len - beg, match - buf,
					&(patterns[i].regs));
		      }
		    if (len <= 0)
		      {
			/* Try looking further on. */
			if (match == end - 1)
			  break;
			match++;
			patterns[i].regexbuf.not_eol = 0;
			start = re_search (&(patterns[i].regexbuf),
					   buf, end - buf - 1,
					   match - buf, end - match - 1,
					   &(patterns[i].regs));
			if (start < 0)
			  break;
			len = patterns[i].regs.end[0] - start;
			match = buf + start;
		      }
		  } /* while (match <= best_match) */
	      continue;
	    assess_pattern_match:
	      if (!start_ptr)
		{
		  /* Good enough for a non-exact match.
		     No need to look at further patterns, if any.  */
		  beg = match;
		  goto success_in_len;
		}
	      if (match < best_match || (match == best_match && len > best_len))
		{
		  /* Best exact match:  leftmost, then longest.  */
		  best_match = match;
		  best_len = len;
		}
	    } /* if re_search >= 0 */
	} /* for Regex patterns.  */
	if (best_match < end)
	  {
	    /* We have found an exact match.  We were just
	       waiting for the best one (leftmost then longest).  */
	    beg = best_match;
	    len = best_len;
	    goto success_in_len;
	  }
    } /* for (beg = end ..) */

 failure:
  ret_val = -1;
  goto out;

 success:
  len = end - beg;
 success_in_len:
  *match_size = len;
  ret_val = beg - buf;
 out:
  return ret_val;
}

Testing negative cases!
Testing 0 (with abstract condition) ENVIS_NEG
Iteration 0
Running test command:
/home/ubuntu/spr-fast/tools/grep-test.py /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-8a025cf8-8f08d8e2/tempworkdir-l/src /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-8a025cf8-8f08d8e2/tempworkdir-l/tests /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-8a025cf8-8f08d8e2/tempworkdir-l 0  > __res
Opening:/tmp/neg.tmp!
NegativeBRANCH RECORD/tmp/neg.tmp!
APPENDING TO ISNEG:/tmp/neg.tmp!
Branch 0: 0
Iteration 1
Running test command:
/home/ubuntu/spr-fast/tools/grep-test.py /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-8a025cf8-8f08d8e2/tempworkdir-l/src /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-8a025cf8-8f08d8e2/tempworkdir-l/tests /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-8a025cf8-8f08d8e2/tempworkdir-l 0  > __res
Opening:/tmp/neg.tmp!
NegativeBRANCH RECORD/tmp/neg.tmp!
APPENDING TO ISNEG:/tmp/neg.tmp!
Branch 0: 1
Running test command:
/home/ubuntu/spr-fast/tools/grep-test.py /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-8a025cf8-8f08d8e2/tempworkdir-l/src /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-8a025cf8-8f08d8e2/tempworkdir-l/tests /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-8a025cf8-8f08d8e2/tempworkdir-l 0  > __res
CondTester, Testing instance id 64:
//src_file:src/dfasearch.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); void* memset(void*, int, unsigned long); 
/* dfasearch.c - searching subroutines using dfa and regex for grep.
   Copyright 1992, 1998, 2000, 2007, 2009-2010 Free Software Foundation, Inc.

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 3, or (at your option)
   any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program; if not, write to the Free Software
   Foundation, Inc., 51 Franklin Street - Fifth Floor, Boston, MA
   02110-1301, USA.  */

/* Written August 1992 by Mike Haertel. */

#include <config.h>
#include "search.h"
#include "dfa.h"

/* For -w, we also consider _ to be word constituent.  */
#define WCHAR(C) (ISALNUM(C) || (C) == '_')

/* KWset compiled pattern.  For Ecompile and Gcompile, we compile
   a list of strings, at least one of which is known to occur in
   any string matching the regexp. */
static kwset_t kwset;

/* DFA compiled regexp. */
static struct dfa dfa;

/* The Regex compiled patterns.  */
static struct patterns
{
  /* Regex compiled regexp. */
  struct re_pattern_buffer regexbuf;
  struct re_registers regs; /* This is here on account of a BRAIN-DEAD
			       Q@#%!# library interface in regex.c.  */
} patterns0;

struct patterns *patterns;
size_t pcount;

void
dfaerror (char const *mesg)
{
  error (EXIT_TROUBLE, 0, "%s", mesg);

  /* notreached */
  /* Tell static analyzers that this function does not return.  */
  abort ();
}

/* Number of compiled fixed strings known to exactly match the regexp.
   If kwsexec returns < kwset_exact_matches, then we don't need to
   call the regexp matcher at all. */
static int kwset_exact_matches;

static char const *
kwsincr_case (const char *must)
{
  const char *buf;
  size_t n;

  n = strlen (must);
#ifdef MBS_SUPPORT
  if (match_icase && MB_CUR_MAX > 1)
    buf = mbtolower (must, &n);
  else
#endif
    buf = must;
  return kwsincr (kwset, buf, n);
}

/* If the DFA turns out to have some set of fixed strings one of
   which must occur in the match, then we build a kwset matcher
   to find those strings, and thus quickly filter out impossible
   matches. */
static void
kwsmusts (void)
{
  struct dfamust const *dm;
  char const *err;

  if (dfa.musts)
    {
      kwsinit (&kwset);
      /* First, we compile in the substrings known to be exact
	 matches.  The kwset matcher will return the index
	 of the matching string that it chooses. */
      for (dm = dfa.musts; dm; dm = dm->next)
	{
	  if (!dm->exact)
	    continue;
	  ++kwset_exact_matches;
	  if ((err = kwsincr_case (dm->must)) != NULL)
	    error (EXIT_TROUBLE, 0, "%s", err);
	}
      /* Now, we compile the substrings that will require
	 the use of the regexp matcher.  */
      for (dm = dfa.musts; dm; dm = dm->next)
	{
	  if (dm->exact)
	    continue;
	  if ((err = kwsincr_case (dm->must)) != NULL)
	    error (EXIT_TROUBLE, 0, "%s", err);
	}
      if ((err = kwsprep (kwset)) != NULL)
	error (EXIT_TROUBLE, 0, "%s", err);
    }
}

void
GEAcompile (char const *pattern, size_t size, reg_syntax_t syntax_bits)
{
  const char *err;
  const char *p, *sep;
  size_t total = size;
  char *motif;

  if (match_icase)
    syntax_bits |= RE_ICASE;
  re_set_syntax (syntax_bits);
  dfasyntax (syntax_bits, match_icase, eolbyte);

  /* For GNU regex compiler we have to pass the patterns separately to detect
     errors like "[\nallo\n]\n".  The patterns here are "[", "allo" and "]"
     GNU regex should have raise a syntax error.  The same for backref, where
     the backref should have been local to each pattern.  */
  p = pattern;
  do
    {
      size_t len;
      sep = memchr (p, '\n', total);
      if (sep)
	{
	  len = sep - p;
	  sep++;
	  total -= (len + 1);
	}
      else
	{
	  len = total;
	  total = 0;
	}

      patterns = realloc (patterns, (pcount + 1) * sizeof (*patterns));
      if (patterns == NULL)
	error (EXIT_TROUBLE, errno, _("memory exhausted"));
      patterns[pcount] = patterns0;

      if ((err = re_compile_pattern (p, len,
				    &(patterns[pcount].regexbuf))) != NULL)
	error (EXIT_TROUBLE, 0, "%s", err);
      pcount++;

      p = sep;
    } while (sep && total != 0);

  /* In the match_words and match_lines cases, we use a different pattern
     for the DFA matcher that will quickly throw out cases that won't work.
     Then if DFA succeeds we do some hairy stuff using the regex matcher
     to decide whether the match should really count. */
  if (match_words || match_lines)
    {
      static char const line_beg_no_bk[] = "^(";
      static char const line_end_no_bk[] = ")$";
      static char const word_beg_no_bk[] = "(^|[^[:alnum:]_])(";
      static char const word_end_no_bk[] = ")([^[:alnum:]_]|$)";
      static char const line_beg_bk[] = "^\\(";
      static char const line_end_bk[] = "\\)$";
      static char const word_beg_bk[] = "\\(^\\|[^[:alnum:]_]\\)\\(";
      static char const word_end_bk[] = "\\)\\([^[:alnum:]_]\\|$\\)";
      int bk = !(syntax_bits & RE_NO_BK_PARENS);
      char *n = xmalloc (sizeof word_beg_bk - 1 + size + sizeof word_end_bk);

      strcpy (n, match_lines ? (bk ? line_beg_bk : line_beg_no_bk)
			     : (bk ? word_beg_bk : word_beg_no_bk));
      total = strlen(n);
      memcpy (n + total, pattern, size);
      total += size;
      strcpy (n + total, match_lines ? (bk ? line_end_bk : line_end_no_bk)
				     : (bk ? word_end_bk : word_end_no_bk));
      total += strlen (n + total);
      pattern = motif = n;
      size = total;
    }
  else
    motif = NULL;

  dfacomp (pattern, size, &dfa, 1);
  kwsmusts ();

  free(motif);
}

size_t
EGexecute (char const *buf, size_t size, size_t *match_size,
	   char const *start_ptr)
{
  char const *buflim, *beg, *end, *match, *best_match, *mb_start;
  char eol = eolbyte;
  int backref, start, len, best_len;
  struct kwsmatch kwsm;
  size_t i, ret_val;
#ifdef MBS_SUPPORT
  if (MB_CUR_MAX > 1)
    {
      if (match_icase)
        {
          /* mbtolower adds a NUL byte at the end.  That will provide
	     space for the sentinel byte dfaexec may add.  */
          char *case_buf = mbtolower (buf, &size);
	  if (start_ptr)
	    start_ptr = case_buf + (start_ptr - buf);
          buf = case_buf;
        }
    }
#endif /* MBS_SUPPORT */

  mb_start = buf;
  buflim = buf + size;

  for (beg = end = buf; end < buflim; beg = end)
    {
      if (!start_ptr)
	{
	  /* We don't care about an exact match.  */
	  if (kwset)
	    {
	      /* Find a possible match using the KWset matcher. */
	      size_t offset = kwsexec (kwset, beg, buflim - beg, &kwsm);
	      if (offset == (size_t) -1)
		goto failure;
	      beg += offset;
	      /* Narrow down to the line containing the candidate, and
		 run it through DFA. */
	      if ((end = memchr(beg, eol, buflim - beg)) != NULL)
	        end++;
              else
                end = buflim;
	      match = beg;
	      while (beg > buf && beg[-1] != eol)
		--beg;
	      if (kwsm.index < kwset_exact_matches)
                {
#ifdef MBS_SUPPORT
                  if (mb_start < beg)
                    mb_start = beg;
                  if (MB_CUR_MAX == 1 || !is_mb_middle (&mb_start, match, buflim))
#endif
                    goto success;
                }
	      if (dfaexec (&dfa, beg, (char *) end, 0, NULL, &backref) == NULL)
		continue;
	    }
	  else
	    {
	      /* No good fixed strings; start with DFA. */
	      char const *next_beg = dfaexec (&dfa, beg, (char *) buflim,
					      0, NULL, &backref);
	      if (next_beg == NULL)
		break;
	      /* Narrow down to the line we've found. */
	      beg = next_beg;
	      if ((end = memchr(beg, eol, buflim - beg)) != NULL)
	        end++;
              else
                end = buflim;
	      while (beg > buf && beg[-1] != eol)
		--beg;
	    }
	  /* Successful, no backreferences encountered! */
	  if (!backref)
	    goto success;
	}
      else
	{
	  /* We are looking for the leftmost (then longest) exact match.
	     We will go through the outer loop only once.  */
	  beg = start_ptr;
	  end = buflim;
	}

      /* If we've made it to this point, this means DFA has seen
	 a probable match, and we need to run it through Regex. */
      best_match = end;
      best_len = 0;
      for (i = 0; i < pcount; i++)
	{
	  patterns[i].regexbuf.not_eol = 0;
	  if (0 <= (start = re_search (&(patterns[i].regexbuf),
				       buf, end - buf - 1,
				       beg - buf, end - beg - 1,
				       &(patterns[i].regs))))
	    {
	      
//Patch 0:
if ((__is_neg(28, &(start), sizeof (start), &(len), sizeof (len), &(i), sizeof (i), &(patterns), sizeof (patterns), &(patterns[i].regs.end), sizeof (patterns[i].regs.end), &(buf), sizeof (buf), &(match), sizeof (match), &(best_match), sizeof (best_match), &(beg), sizeof (beg), &(end), sizeof (end), &(start_ptr), sizeof (start_ptr), &(match_words), sizeof (match_words), &(match_lines), sizeof (match_lines), &(pcount), sizeof (pcount), &(best_len), sizeof (best_len), &(buflim), sizeof (buflim), &(backref), sizeof (backref), &(eol), sizeof (eol), &(mb_start), sizeof (mb_start), &(kwset_exact_matches), sizeof (kwset_exact_matches), &(kwset), sizeof (kwset), &(size), sizeof (size), &(ret_val), sizeof (ret_val), &(match_size), sizeof (match_size), &(match_icase), sizeof (match_icase), &(eolbyte), sizeof (eolbyte), &(patterns[i].regs.num_regs), sizeof (patterns[i].regs.num_regs), &(patterns[i].regs.start), sizeof (patterns[i].regs.start))))
    goto success;
len = patterns[i].regs.end[0] - start;

//CodeSeg 1:
	      match = buf + start;
	      if (match > best_match)
		continue;
	      if (start_ptr && !match_words)
		goto assess_pattern_match;
	      if ((!match_lines && !match_words)
		  || (match_lines && len == end - beg - 1))
		{
		  match = beg;
		  len = end - beg;
		  goto assess_pattern_match;
		}
	      /* If -w, check if the match aligns with word boundaries.
		 We do this iteratively because:
		 (a) the line may contain more than one occurence of the
		 pattern, and
		 (b) Several alternatives in the pattern might be valid at a
		 given point, and we may need to consider a shorter one to
		 find a word boundary.  */
	      if (match_words)
		while (match <= best_match)
		  {
		    if ((match == buf || !WCHAR ((unsigned char) match[-1]))
			&& (len == end - beg - 1
			    || !WCHAR ((unsigned char) match[len])))
		      goto assess_pattern_match;
		    if (len > 0)
		      {
			/* Try a shorter length anchored at the same place. */
			--len;
			patterns[i].regexbuf.not_eol = 1;
			len = re_match (&(patterns[i].regexbuf),
					buf, match + len - beg, match - buf,
					&(patterns[i].regs));
		      }
		    if (len <= 0)
		      {
			/* Try looking further on. */
			if (match == end - 1)
			  break;
			match++;
			patterns[i].regexbuf.not_eol = 0;
			start = re_search (&(patterns[i].regexbuf),
					   buf, end - buf - 1,
					   match - buf, end - match - 1,
					   &(patterns[i].regs));
			if (start < 0)
			  break;
			len = patterns[i].regs.end[0] - start;
			match = buf + start;
		      }
		  } /* while (match <= best_match) */
	      continue;
	    assess_pattern_match:
	      if (!start_ptr)
		{
		  /* Good enough for a non-exact match.
		     No need to look at further patterns, if any.  */
		  beg = match;
		  goto success_in_len;
		}
	      if (match < best_match || (match == best_match && len > best_len))
		{
		  /* Best exact match:  leftmost, then longest.  */
		  best_match = match;
		  best_len = len;
		}
	    } /* if re_search >= 0 */
	} /* for Regex patterns.  */
	if (best_match < end)
	  {
	    /* We have found an exact match.  We were just
	       waiting for the best one (leftmost then longest).  */
	    beg = best_match;
	    len = best_len;
	    goto success_in_len;
	  }
    } /* for (beg = end ..) */

 failure:
  ret_val = -1;
  goto out;

 success:
  len = end - beg;
 success_in_len:
  *match_size = len;
  ret_val = beg - buf;
 out:
  return ret_val;
}

Testing negative cases!
Testing 0 (with abstract condition) ENVIS_NEG
Iteration 0
Running test command:
/home/ubuntu/spr-fast/tools/grep-test.py /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-8a025cf8-8f08d8e2/tempworkdir-l/src /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-8a025cf8-8f08d8e2/tempworkdir-l/tests /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-8a025cf8-8f08d8e2/tempworkdir-l 0  > __res
Opening:/tmp/neg.tmp!
NegativeBRANCH RECORD/tmp/neg.tmp!
APPENDING TO ISNEG:/tmp/neg.tmp!
Branch 0: 0
Iteration 1
Running test command:
/home/ubuntu/spr-fast/tools/grep-test.py /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-8a025cf8-8f08d8e2/tempworkdir-l/src /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-8a025cf8-8f08d8e2/tempworkdir-l/tests /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-8a025cf8-8f08d8e2/tempworkdir-l 0  > __res
Opening:/tmp/neg.tmp!
NegativeBRANCH RECORD/tmp/neg.tmp!
APPENDING TO ISNEG:/tmp/neg.tmp!
Branch 0: 1
Passed in iteration!
Passed Negative Cases wiht CondTestder!
Testing positive cases!
Running test command:
/home/ubuntu/spr-fast/tools/grep-test.py /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-8a025cf8-8f08d8e2/tempworkdir-l/src /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-8a025cf8-8f08d8e2/tempworkdir-l/tests /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-8a025cf8-8f08d8e2/tempworkdir-l 11  > __res
Running test command:
/home/ubuntu/spr-fast/tools/grep-test.py /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-8a025cf8-8f08d8e2/tempworkdir-l/src /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-8a025cf8-8f08d8e2/tempworkdir-l/tests /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-8a025cf8-8f08d8e2/tempworkdir-l 14  > __res
Running test command:
/home/ubuntu/spr-fast/tools/grep-test.py /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-8a025cf8-8f08d8e2/tempworkdir-l/src /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-8a025cf8-8f08d8e2/tempworkdir-l/tests /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-8a025cf8-8f08d8e2/tempworkdir-l 17  > __res
Running test command:
/home/ubuntu/spr-fast/tools/grep-test.py /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-8a025cf8-8f08d8e2/tempworkdir-l/src /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-8a025cf8-8f08d8e2/tempworkdir-l/tests /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-8a025cf8-8f08d8e2/tempworkdir-l 22  > __res
Passed Positive Cases
Collect values for post processing!
WRITING TO ISNEG:/tmp/neg.tmp!
Running test command:
/home/ubuntu/spr-fast/tools/grep-test.py /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-8a025cf8-8f08d8e2/tempworkdir-l/src /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-8a025cf8-8f08d8e2/tempworkdir-l/tests /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-8a025cf8-8f08d8e2/tempworkdir-l 0  > __res
Running test command:
/home/ubuntu/spr-fast/tools/grep-test.py /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-8a025cf8-8f08d8e2/tempworkdir-l/src /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-8a025cf8-8f08d8e2/tempworkdir-l/tests /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-8a025cf8-8f08d8e2/tempworkdir-l 11  > __res
Running test command:
/home/ubuntu/spr-fast/tools/grep-test.py /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-8a025cf8-8f08d8e2/tempworkdir-l/src /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-8a025cf8-8f08d8e2/tempworkdir-l/tests /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-8a025cf8-8f08d8e2/tempworkdir-l 14  > __res
Running test command:
/home/ubuntu/spr-fast/tools/grep-test.py /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-8a025cf8-8f08d8e2/tempworkdir-l/src /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-8a025cf8-8f08d8e2/tempworkdir-l/tests /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-8a025cf8-8f08d8e2/tempworkdir-l 17  > __res
Running test command:
/home/ubuntu/spr-fast/tools/grep-test.py /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-8a025cf8-8f08d8e2/tempworkdir-l/src /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-8a025cf8-8f08d8e2/tempworkdir-l/tests /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-8a025cf8-8f08d8e2/tempworkdir-l 22  > __res
Passed!
CondTester, Testing instance id 65:
//src_file:src/dfasearch.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); void* memset(void*, int, unsigned long); 
/* dfasearch.c - searching subroutines using dfa and regex for grep.
   Copyright 1992, 1998, 2000, 2007, 2009-2010 Free Software Foundation, Inc.

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 3, or (at your option)
   any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program; if not, write to the Free Software
   Foundation, Inc., 51 Franklin Street - Fifth Floor, Boston, MA
   02110-1301, USA.  */

/* Written August 1992 by Mike Haertel. */

#include <config.h>
#include "search.h"
#include "dfa.h"

/* For -w, we also consider _ to be word constituent.  */
#define WCHAR(C) (ISALNUM(C) || (C) == '_')

/* KWset compiled pattern.  For Ecompile and Gcompile, we compile
   a list of strings, at least one of which is known to occur in
   any string matching the regexp. */
static kwset_t kwset;

/* DFA compiled regexp. */
static struct dfa dfa;

/* The Regex compiled patterns.  */
static struct patterns
{
  /* Regex compiled regexp. */
  struct re_pattern_buffer regexbuf;
  struct re_registers regs; /* This is here on account of a BRAIN-DEAD
			       Q@#%!# library interface in regex.c.  */
} patterns0;

struct patterns *patterns;
size_t pcount;

void
dfaerror (char const *mesg)
{
  error (EXIT_TROUBLE, 0, "%s", mesg);

  /* notreached */
  /* Tell static analyzers that this function does not return.  */
  abort ();
}

/* Number of compiled fixed strings known to exactly match the regexp.
   If kwsexec returns < kwset_exact_matches, then we don't need to
   call the regexp matcher at all. */
static int kwset_exact_matches;

static char const *
kwsincr_case (const char *must)
{
  const char *buf;
  size_t n;

  n = strlen (must);
#ifdef MBS_SUPPORT
  if (match_icase && MB_CUR_MAX > 1)
    buf = mbtolower (must, &n);
  else
#endif
    buf = must;
  return kwsincr (kwset, buf, n);
}

/* If the DFA turns out to have some set of fixed strings one of
   which must occur in the match, then we build a kwset matcher
   to find those strings, and thus quickly filter out impossible
   matches. */
static void
kwsmusts (void)
{
  struct dfamust const *dm;
  char const *err;

  if (dfa.musts)
    {
      kwsinit (&kwset);
      /* First, we compile in the substrings known to be exact
	 matches.  The kwset matcher will return the index
	 of the matching string that it chooses. */
      for (dm = dfa.musts; dm; dm = dm->next)
	{
	  if (!dm->exact)
	    continue;
	  ++kwset_exact_matches;
	  if ((err = kwsincr_case (dm->must)) != NULL)
	    error (EXIT_TROUBLE, 0, "%s", err);
	}
      /* Now, we compile the substrings that will require
	 the use of the regexp matcher.  */
      for (dm = dfa.musts; dm; dm = dm->next)
	{
	  if (dm->exact)
	    continue;
	  if ((err = kwsincr_case (dm->must)) != NULL)
	    error (EXIT_TROUBLE, 0, "%s", err);
	}
      if ((err = kwsprep (kwset)) != NULL)
	error (EXIT_TROUBLE, 0, "%s", err);
    }
}

void
GEAcompile (char const *pattern, size_t size, reg_syntax_t syntax_bits)
{
  const char *err;
  const char *p, *sep;
  size_t total = size;
  char *motif;

  if (match_icase)
    syntax_bits |= RE_ICASE;
  re_set_syntax (syntax_bits);
  dfasyntax (syntax_bits, match_icase, eolbyte);

  /* For GNU regex compiler we have to pass the patterns separately to detect
     errors like "[\nallo\n]\n".  The patterns here are "[", "allo" and "]"
     GNU regex should have raise a syntax error.  The same for backref, where
     the backref should have been local to each pattern.  */
  p = pattern;
  do
    {
      size_t len;
      sep = memchr (p, '\n', total);
      if (sep)
	{
	  len = sep - p;
	  sep++;
	  total -= (len + 1);
	}
      else
	{
	  len = total;
	  total = 0;
	}

      patterns = realloc (patterns, (pcount + 1) * sizeof (*patterns));
      if (patterns == NULL)
	error (EXIT_TROUBLE, errno, _("memory exhausted"));
      patterns[pcount] = patterns0;

      if ((err = re_compile_pattern (p, len,
				    &(patterns[pcount].regexbuf))) != NULL)
	error (EXIT_TROUBLE, 0, "%s", err);
      pcount++;

      p = sep;
    } while (sep && total != 0);

  /* In the match_words and match_lines cases, we use a different pattern
     for the DFA matcher that will quickly throw out cases that won't work.
     Then if DFA succeeds we do some hairy stuff using the regex matcher
     to decide whether the match should really count. */
  if (match_words || match_lines)
    {
      static char const line_beg_no_bk[] = "^(";
      static char const line_end_no_bk[] = ")$";
      static char const word_beg_no_bk[] = "(^|[^[:alnum:]_])(";
      static char const word_end_no_bk[] = ")([^[:alnum:]_]|$)";
      static char const line_beg_bk[] = "^\\(";
      static char const line_end_bk[] = "\\)$";
      static char const word_beg_bk[] = "\\(^\\|[^[:alnum:]_]\\)\\(";
      static char const word_end_bk[] = "\\)\\([^[:alnum:]_]\\|$\\)";
      int bk = !(syntax_bits & RE_NO_BK_PARENS);
      char *n = xmalloc (sizeof word_beg_bk - 1 + size + sizeof word_end_bk);

      strcpy (n, match_lines ? (bk ? line_beg_bk : line_beg_no_bk)
			     : (bk ? word_beg_bk : word_beg_no_bk));
      total = strlen(n);
      memcpy (n + total, pattern, size);
      total += size;
      strcpy (n + total, match_lines ? (bk ? line_end_bk : line_end_no_bk)
				     : (bk ? word_end_bk : word_end_no_bk));
      total += strlen (n + total);
      pattern = motif = n;
      size = total;
    }
  else
    motif = NULL;

  dfacomp (pattern, size, &dfa, 1);
  kwsmusts ();

  free(motif);
}

size_t
EGexecute (char const *buf, size_t size, size_t *match_size,
	   char const *start_ptr)
{
  char const *buflim, *beg, *end, *match, *best_match, *mb_start;
  char eol = eolbyte;
  int backref, start, len, best_len;
  struct kwsmatch kwsm;
  size_t i, ret_val;
#ifdef MBS_SUPPORT
  if (MB_CUR_MAX > 1)
    {
      if (match_icase)
        {
          /* mbtolower adds a NUL byte at the end.  That will provide
	     space for the sentinel byte dfaexec may add.  */
          char *case_buf = mbtolower (buf, &size);
	  if (start_ptr)
	    start_ptr = case_buf + (start_ptr - buf);
          buf = case_buf;
        }
    }
#endif /* MBS_SUPPORT */

  mb_start = buf;
  buflim = buf + size;

  for (beg = end = buf; end < buflim; beg = end)
    {
      if (!start_ptr)
	{
	  /* We don't care about an exact match.  */
	  if (kwset)
	    {
	      /* Find a possible match using the KWset matcher. */
	      size_t offset = kwsexec (kwset, beg, buflim - beg, &kwsm);
	      if (offset == (size_t) -1)
		goto failure;
	      beg += offset;
	      /* Narrow down to the line containing the candidate, and
		 run it through DFA. */
	      if ((end = memchr(beg, eol, buflim - beg)) != NULL)
	        end++;
              else
                end = buflim;
	      match = beg;
	      while (beg > buf && beg[-1] != eol)
		--beg;
	      if (kwsm.index < kwset_exact_matches)
                {
#ifdef MBS_SUPPORT
                  if (mb_start < beg)
                    mb_start = beg;
                  if (MB_CUR_MAX == 1 || !is_mb_middle (&mb_start, match, buflim))
#endif
                    goto success;
                }
	      if (dfaexec (&dfa, beg, (char *) end, 0, NULL, &backref) == NULL)
		continue;
	    }
	  else
	    {
	      /* No good fixed strings; start with DFA. */
	      char const *next_beg = dfaexec (&dfa, beg, (char *) buflim,
					      0, NULL, &backref);
	      if (next_beg == NULL)
		break;
	      /* Narrow down to the line we've found. */
	      beg = next_beg;
	      if ((end = memchr(beg, eol, buflim - beg)) != NULL)
	        end++;
              else
                end = buflim;
	      while (beg > buf && beg[-1] != eol)
		--beg;
	    }
	  /* Successful, no backreferences encountered! */
	  if (!backref)
	    goto success;
	}
      else
	{
	  /* We are looking for the leftmost (then longest) exact match.
	     We will go through the outer loop only once.  */
	  beg = start_ptr;
	  end = buflim;
	}

      /* If we've made it to this point, this means DFA has seen
	 a probable match, and we need to run it through Regex. */
      best_match = end;
      best_len = 0;
      for (i = 0; i < pcount; i++)
	{
	  patterns[i].regexbuf.not_eol = 0;
	  if (0 <= (start = re_search (&(patterns[i].regexbuf),
				       buf, end - buf - 1,
				       beg - buf, end - beg - 1,
				       &(patterns[i].regs))))
	    {
	      
//Patch 0:
if ((__is_neg(28, &(start), sizeof (start), &(len), sizeof (len), &(i), sizeof (i), &(patterns), sizeof (patterns), &(patterns[i].regs.end), sizeof (patterns[i].regs.end), &(buf), sizeof (buf), &(match), sizeof (match), &(best_match), sizeof (best_match), &(beg), sizeof (beg), &(end), sizeof (end), &(start_ptr), sizeof (start_ptr), &(match_words), sizeof (match_words), &(match_lines), sizeof (match_lines), &(pcount), sizeof (pcount), &(best_len), sizeof (best_len), &(buflim), sizeof (buflim), &(backref), sizeof (backref), &(eol), sizeof (eol), &(mb_start), sizeof (mb_start), &(kwset_exact_matches), sizeof (kwset_exact_matches), &(kwset), sizeof (kwset), &(size), sizeof (size), &(ret_val), sizeof (ret_val), &(match_size), sizeof (match_size), &(match_icase), sizeof (match_icase), &(eolbyte), sizeof (eolbyte), &(patterns[i].regs.num_regs), sizeof (patterns[i].regs.num_regs), &(patterns[i].regs.start), sizeof (patterns[i].regs.start))))
    goto success_in_len;
len = patterns[i].regs.end[0] - start;

//CodeSeg 1:
	      match = buf + start;
	      if (match > best_match)
		continue;
	      if (start_ptr && !match_words)
		goto assess_pattern_match;
	      if ((!match_lines && !match_words)
		  || (match_lines && len == end - beg - 1))
		{
		  match = beg;
		  len = end - beg;
		  goto assess_pattern_match;
		}
	      /* If -w, check if the match aligns with word boundaries.
		 We do this iteratively because:
		 (a) the line may contain more than one occurence of the
		 pattern, and
		 (b) Several alternatives in the pattern might be valid at a
		 given point, and we may need to consider a shorter one to
		 find a word boundary.  */
	      if (match_words)
		while (match <= best_match)
		  {
		    if ((match == buf || !WCHAR ((unsigned char) match[-1]))
			&& (len == end - beg - 1
			    || !WCHAR ((unsigned char) match[len])))
		      goto assess_pattern_match;
		    if (len > 0)
		      {
			/* Try a shorter length anchored at the same place. */
			--len;
			patterns[i].regexbuf.not_eol = 1;
			len = re_match (&(patterns[i].regexbuf),
					buf, match + len - beg, match - buf,
					&(patterns[i].regs));
		      }
		    if (len <= 0)
		      {
			/* Try looking further on. */
			if (match == end - 1)
			  break;
			match++;
			patterns[i].regexbuf.not_eol = 0;
			start = re_search (&(patterns[i].regexbuf),
					   buf, end - buf - 1,
					   match - buf, end - match - 1,
					   &(patterns[i].regs));
			if (start < 0)
			  break;
			len = patterns[i].regs.end[0] - start;
			match = buf + start;
		      }
		  } /* while (match <= best_match) */
	      continue;
	    assess_pattern_match:
	      if (!start_ptr)
		{
		  /* Good enough for a non-exact match.
		     No need to look at further patterns, if any.  */
		  beg = match;
		  goto success_in_len;
		}
	      if (match < best_match || (match == best_match && len > best_len))
		{
		  /* Best exact match:  leftmost, then longest.  */
		  best_match = match;
		  best_len = len;
		}
	    } /* if re_search >= 0 */
	} /* for Regex patterns.  */
	if (best_match < end)
	  {
	    /* We have found an exact match.  We were just
	       waiting for the best one (leftmost then longest).  */
	    beg = best_match;
	    len = best_len;
	    goto success_in_len;
	  }
    } /* for (beg = end ..) */

 failure:
  ret_val = -1;
  goto out;

 success:
  len = end - beg;
 success_in_len:
  *match_size = len;
  ret_val = beg - buf;
 out:
  return ret_val;
}

Testing negative cases!
Testing 0 (with abstract condition) ENVIS_NEG
Iteration 0
Running test command:
/home/ubuntu/spr-fast/tools/grep-test.py /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-8a025cf8-8f08d8e2/tempworkdir-l/src /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-8a025cf8-8f08d8e2/tempworkdir-l/tests /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-8a025cf8-8f08d8e2/tempworkdir-l 0  > __res
Opening:/tmp/neg.tmp!
NegativeBRANCH RECORD/tmp/neg.tmp!
APPENDING TO ISNEG:/tmp/neg.tmp!
Branch 0: 0
Iteration 1
Running test command:
/home/ubuntu/spr-fast/tools/grep-test.py /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-8a025cf8-8f08d8e2/tempworkdir-l/src /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-8a025cf8-8f08d8e2/tempworkdir-l/tests /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-8a025cf8-8f08d8e2/tempworkdir-l 0  > __res
Opening:/tmp/neg.tmp!
NegativeBRANCH RECORD/tmp/neg.tmp!
APPENDING TO ISNEG:/tmp/neg.tmp!
Branch 0: 1
Running test command:
/home/ubuntu/spr-fast/tools/grep-test.py /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-8a025cf8-8f08d8e2/tempworkdir-l/src /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-8a025cf8-8f08d8e2/tempworkdir-l/tests /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-8a025cf8-8f08d8e2/tempworkdir-l 0  > __res
CondTester, Testing instance id 66:
//src_file:src/dfasearch.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); void* memset(void*, int, unsigned long); 
/* dfasearch.c - searching subroutines using dfa and regex for grep.
   Copyright 1992, 1998, 2000, 2007, 2009-2010 Free Software Foundation, Inc.

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 3, or (at your option)
   any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program; if not, write to the Free Software
   Foundation, Inc., 51 Franklin Street - Fifth Floor, Boston, MA
   02110-1301, USA.  */

/* Written August 1992 by Mike Haertel. */

#include <config.h>
#include "search.h"
#include "dfa.h"

/* For -w, we also consider _ to be word constituent.  */
#define WCHAR(C) (ISALNUM(C) || (C) == '_')

/* KWset compiled pattern.  For Ecompile and Gcompile, we compile
   a list of strings, at least one of which is known to occur in
   any string matching the regexp. */
static kwset_t kwset;

/* DFA compiled regexp. */
static struct dfa dfa;

/* The Regex compiled patterns.  */
static struct patterns
{
  /* Regex compiled regexp. */
  struct re_pattern_buffer regexbuf;
  struct re_registers regs; /* This is here on account of a BRAIN-DEAD
			       Q@#%!# library interface in regex.c.  */
} patterns0;

struct patterns *patterns;
size_t pcount;

void
dfaerror (char const *mesg)
{
  error (EXIT_TROUBLE, 0, "%s", mesg);

  /* notreached */
  /* Tell static analyzers that this function does not return.  */
  abort ();
}

/* Number of compiled fixed strings known to exactly match the regexp.
   If kwsexec returns < kwset_exact_matches, then we don't need to
   call the regexp matcher at all. */
static int kwset_exact_matches;

static char const *
kwsincr_case (const char *must)
{
  const char *buf;
  size_t n;

  n = strlen (must);
#ifdef MBS_SUPPORT
  if (match_icase && MB_CUR_MAX > 1)
    buf = mbtolower (must, &n);
  else
#endif
    buf = must;
  return kwsincr (kwset, buf, n);
}

/* If the DFA turns out to have some set of fixed strings one of
   which must occur in the match, then we build a kwset matcher
   to find those strings, and thus quickly filter out impossible
   matches. */
static void
kwsmusts (void)
{
  struct dfamust const *dm;
  char const *err;

  if (dfa.musts)
    {
      kwsinit (&kwset);
      /* First, we compile in the substrings known to be exact
	 matches.  The kwset matcher will return the index
	 of the matching string that it chooses. */
      for (dm = dfa.musts; dm; dm = dm->next)
	{
	  if (!dm->exact)
	    continue;
	  ++kwset_exact_matches;
	  if ((err = kwsincr_case (dm->must)) != NULL)
	    error (EXIT_TROUBLE, 0, "%s", err);
	}
      /* Now, we compile the substrings that will require
	 the use of the regexp matcher.  */
      for (dm = dfa.musts; dm; dm = dm->next)
	{
	  if (dm->exact)
	    continue;
	  if ((err = kwsincr_case (dm->must)) != NULL)
	    error (EXIT_TROUBLE, 0, "%s", err);
	}
      if ((err = kwsprep (kwset)) != NULL)
	error (EXIT_TROUBLE, 0, "%s", err);
    }
}

void
GEAcompile (char const *pattern, size_t size, reg_syntax_t syntax_bits)
{
  const char *err;
  const char *p, *sep;
  size_t total = size;
  char *motif;

  if (match_icase)
    syntax_bits |= RE_ICASE;
  re_set_syntax (syntax_bits);
  dfasyntax (syntax_bits, match_icase, eolbyte);

  /* For GNU regex compiler we have to pass the patterns separately to detect
     errors like "[\nallo\n]\n".  The patterns here are "[", "allo" and "]"
     GNU regex should have raise a syntax error.  The same for backref, where
     the backref should have been local to each pattern.  */
  p = pattern;
  do
    {
      size_t len;
      sep = memchr (p, '\n', total);
      if (sep)
	{
	  len = sep - p;
	  sep++;
	  total -= (len + 1);
	}
      else
	{
	  len = total;
	  total = 0;
	}

      patterns = realloc (patterns, (pcount + 1) * sizeof (*patterns));
      if (patterns == NULL)
	error (EXIT_TROUBLE, errno, _("memory exhausted"));
      patterns[pcount] = patterns0;

      if ((err = re_compile_pattern (p, len,
				    &(patterns[pcount].regexbuf))) != NULL)
	error (EXIT_TROUBLE, 0, "%s", err);
      pcount++;

      p = sep;
    } while (sep && total != 0);

  /* In the match_words and match_lines cases, we use a different pattern
     for the DFA matcher that will quickly throw out cases that won't work.
     Then if DFA succeeds we do some hairy stuff using the regex matcher
     to decide whether the match should really count. */
  if (match_words || match_lines)
    {
      static char const line_beg_no_bk[] = "^(";
      static char const line_end_no_bk[] = ")$";
      static char const word_beg_no_bk[] = "(^|[^[:alnum:]_])(";
      static char const word_end_no_bk[] = ")([^[:alnum:]_]|$)";
      static char const line_beg_bk[] = "^\\(";
      static char const line_end_bk[] = "\\)$";
      static char const word_beg_bk[] = "\\(^\\|[^[:alnum:]_]\\)\\(";
      static char const word_end_bk[] = "\\)\\([^[:alnum:]_]\\|$\\)";
      int bk = !(syntax_bits & RE_NO_BK_PARENS);
      char *n = xmalloc (sizeof word_beg_bk - 1 + size + sizeof word_end_bk);

      strcpy (n, match_lines ? (bk ? line_beg_bk : line_beg_no_bk)
			     : (bk ? word_beg_bk : word_beg_no_bk));
      total = strlen(n);
      memcpy (n + total, pattern, size);
      total += size;
      strcpy (n + total, match_lines ? (bk ? line_end_bk : line_end_no_bk)
				     : (bk ? word_end_bk : word_end_no_bk));
      total += strlen (n + total);
      pattern = motif = n;
      size = total;
    }
  else
    motif = NULL;

  dfacomp (pattern, size, &dfa, 1);
  kwsmusts ();

  free(motif);
}

size_t
EGexecute (char const *buf, size_t size, size_t *match_size,
	   char const *start_ptr)
{
  char const *buflim, *beg, *end, *match, *best_match, *mb_start;
  char eol = eolbyte;
  int backref, start, len, best_len;
  struct kwsmatch kwsm;
  size_t i, ret_val;
#ifdef MBS_SUPPORT
  if (MB_CUR_MAX > 1)
    {
      if (match_icase)
        {
          /* mbtolower adds a NUL byte at the end.  That will provide
	     space for the sentinel byte dfaexec may add.  */
          char *case_buf = mbtolower (buf, &size);
	  if (start_ptr)
	    start_ptr = case_buf + (start_ptr - buf);
          buf = case_buf;
        }
    }
#endif /* MBS_SUPPORT */

  mb_start = buf;
  buflim = buf + size;

  for (beg = end = buf; end < buflim; beg = end)
    {
      if (!start_ptr)
	{
	  /* We don't care about an exact match.  */
	  if (kwset)
	    {
	      /* Find a possible match using the KWset matcher. */
	      size_t offset = kwsexec (kwset, beg, buflim - beg, &kwsm);
	      if (offset == (size_t) -1)
		goto failure;
	      beg += offset;
	      /* Narrow down to the line containing the candidate, and
		 run it through DFA. */
	      if ((end = memchr(beg, eol, buflim - beg)) != NULL)
	        end++;
              else
                end = buflim;
	      match = beg;
	      while (beg > buf && beg[-1] != eol)
		--beg;
	      if (kwsm.index < kwset_exact_matches)
                {
#ifdef MBS_SUPPORT
                  if (mb_start < beg)
                    mb_start = beg;
                  if (MB_CUR_MAX == 1 || !is_mb_middle (&mb_start, match, buflim))
#endif
                    goto success;
                }
	      if (dfaexec (&dfa, beg, (char *) end, 0, NULL, &backref) == NULL)
		continue;
	    }
	  else
	    {
	      /* No good fixed strings; start with DFA. */
	      char const *next_beg = dfaexec (&dfa, beg, (char *) buflim,
					      0, NULL, &backref);
	      if (next_beg == NULL)
		break;
	      /* Narrow down to the line we've found. */
	      beg = next_beg;
	      if ((end = memchr(beg, eol, buflim - beg)) != NULL)
	        end++;
              else
                end = buflim;
	      while (beg > buf && beg[-1] != eol)
		--beg;
	    }
	  /* Successful, no backreferences encountered! */
	  if (!backref)
	    goto success;
	}
      else
	{
	  /* We are looking for the leftmost (then longest) exact match.
	     We will go through the outer loop only once.  */
	  beg = start_ptr;
	  end = buflim;
	}

      /* If we've made it to this point, this means DFA has seen
	 a probable match, and we need to run it through Regex. */
      best_match = end;
      best_len = 0;
      for (i = 0; i < pcount; i++)
	{
	  patterns[i].regexbuf.not_eol = 0;
	  if (0 <= (start = re_search (&(patterns[i].regexbuf),
				       buf, end - buf - 1,
				       beg - buf, end - beg - 1,
				       &(patterns[i].regs))))
	    {
	      
//Patch 0:
if ((__is_neg(28, &(start), sizeof (start), &(len), sizeof (len), &(i), sizeof (i), &(patterns), sizeof (patterns), &(patterns[i].regs.end), sizeof (patterns[i].regs.end), &(buf), sizeof (buf), &(match), sizeof (match), &(best_match), sizeof (best_match), &(beg), sizeof (beg), &(end), sizeof (end), &(start_ptr), sizeof (start_ptr), &(match_words), sizeof (match_words), &(match_lines), sizeof (match_lines), &(pcount), sizeof (pcount), &(best_len), sizeof (best_len), &(buflim), sizeof (buflim), &(backref), sizeof (backref), &(eol), sizeof (eol), &(mb_start), sizeof (mb_start), &(kwset_exact_matches), sizeof (kwset_exact_matches), &(kwset), sizeof (kwset), &(size), sizeof (size), &(ret_val), sizeof (ret_val), &(match_size), sizeof (match_size), &(match_icase), sizeof (match_icase), &(eolbyte), sizeof (eolbyte), &(patterns[i].regs.num_regs), sizeof (patterns[i].regs.num_regs), &(patterns[i].regs.start), sizeof (patterns[i].regs.start))))
    goto out;
len = patterns[i].regs.end[0] - start;

//CodeSeg 1:
	      match = buf + start;
	      if (match > best_match)
		continue;
	      if (start_ptr && !match_words)
		goto assess_pattern_match;
	      if ((!match_lines && !match_words)
		  || (match_lines && len == end - beg - 1))
		{
		  match = beg;
		  len = end - beg;
		  goto assess_pattern_match;
		}
	      /* If -w, check if the match aligns with word boundaries.
		 We do this iteratively because:
		 (a) the line may contain more than one occurence of the
		 pattern, and
		 (b) Several alternatives in the pattern might be valid at a
		 given point, and we may need to consider a shorter one to
		 find a word boundary.  */
	      if (match_words)
		while (match <= best_match)
		  {
		    if ((match == buf || !WCHAR ((unsigned char) match[-1]))
			&& (len == end - beg - 1
			    || !WCHAR ((unsigned char) match[len])))
		      goto assess_pattern_match;
		    if (len > 0)
		      {
			/* Try a shorter length anchored at the same place. */
			--len;
			patterns[i].regexbuf.not_eol = 1;
			len = re_match (&(patterns[i].regexbuf),
					buf, match + len - beg, match - buf,
					&(patterns[i].regs));
		      }
		    if (len <= 0)
		      {
			/* Try looking further on. */
			if (match == end - 1)
			  break;
			match++;
			patterns[i].regexbuf.not_eol = 0;
			start = re_search (&(patterns[i].regexbuf),
					   buf, end - buf - 1,
					   match - buf, end - match - 1,
					   &(patterns[i].regs));
			if (start < 0)
			  break;
			len = patterns[i].regs.end[0] - start;
			match = buf + start;
		      }
		  } /* while (match <= best_match) */
	      continue;
	    assess_pattern_match:
	      if (!start_ptr)
		{
		  /* Good enough for a non-exact match.
		     No need to look at further patterns, if any.  */
		  beg = match;
		  goto success_in_len;
		}
	      if (match < best_match || (match == best_match && len > best_len))
		{
		  /* Best exact match:  leftmost, then longest.  */
		  best_match = match;
		  best_len = len;
		}
	    } /* if re_search >= 0 */
	} /* for Regex patterns.  */
	if (best_match < end)
	  {
	    /* We have found an exact match.  We were just
	       waiting for the best one (leftmost then longest).  */
	    beg = best_match;
	    len = best_len;
	    goto success_in_len;
	  }
    } /* for (beg = end ..) */

 failure:
  ret_val = -1;
  goto out;

 success:
  len = end - beg;
 success_in_len:
  *match_size = len;
  ret_val = beg - buf;
 out:
  return ret_val;
}

Testing negative cases!
Testing 0 (with abstract condition) ENVIS_NEG
Iteration 0
Running test command:
/home/ubuntu/spr-fast/tools/grep-test.py /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-8a025cf8-8f08d8e2/tempworkdir-l/src /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-8a025cf8-8f08d8e2/tempworkdir-l/tests /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-8a025cf8-8f08d8e2/tempworkdir-l 0  > __res
Opening:/tmp/neg.tmp!
NegativeBRANCH RECORD/tmp/neg.tmp!
APPENDING TO ISNEG:/tmp/neg.tmp!
Branch 0: 0
Iteration 1
Running test command:
/home/ubuntu/spr-fast/tools/grep-test.py /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-8a025cf8-8f08d8e2/tempworkdir-l/src /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-8a025cf8-8f08d8e2/tempworkdir-l/tests /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-8a025cf8-8f08d8e2/tempworkdir-l 0  > __res
Opening:/tmp/neg.tmp!
NegativeBRANCH RECORD/tmp/neg.tmp!
APPENDING TO ISNEG:/tmp/neg.tmp!
Branch 0: 1
Running test command:
/home/ubuntu/spr-fast/tools/grep-test.py /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-8a025cf8-8f08d8e2/tempworkdir-l/src /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-8a025cf8-8f08d8e2/tempworkdir-l/tests /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-8a025cf8-8f08d8e2/tempworkdir-l 0  > __res
CondTester, Testing instance id 71:
//src_file:src/dfasearch.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); void* memset(void*, int, unsigned long); 
/* dfasearch.c - searching subroutines using dfa and regex for grep.
   Copyright 1992, 1998, 2000, 2007, 2009-2010 Free Software Foundation, Inc.

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 3, or (at your option)
   any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program; if not, write to the Free Software
   Foundation, Inc., 51 Franklin Street - Fifth Floor, Boston, MA
   02110-1301, USA.  */

/* Written August 1992 by Mike Haertel. */

#include <config.h>
#include "search.h"
#include "dfa.h"

/* For -w, we also consider _ to be word constituent.  */
#define WCHAR(C) (ISALNUM(C) || (C) == '_')

/* KWset compiled pattern.  For Ecompile and Gcompile, we compile
   a list of strings, at least one of which is known to occur in
   any string matching the regexp. */
static kwset_t kwset;

/* DFA compiled regexp. */
static struct dfa dfa;

/* The Regex compiled patterns.  */
static struct patterns
{
  /* Regex compiled regexp. */
  struct re_pattern_buffer regexbuf;
  struct re_registers regs; /* This is here on account of a BRAIN-DEAD
			       Q@#%!# library interface in regex.c.  */
} patterns0;

struct patterns *patterns;
size_t pcount;

void
dfaerror (char const *mesg)
{
  error (EXIT_TROUBLE, 0, "%s", mesg);

  /* notreached */
  /* Tell static analyzers that this function does not return.  */
  abort ();
}

/* Number of compiled fixed strings known to exactly match the regexp.
   If kwsexec returns < kwset_exact_matches, then we don't need to
   call the regexp matcher at all. */
static int kwset_exact_matches;

static char const *
kwsincr_case (const char *must)
{
  const char *buf;
  size_t n;

  n = strlen (must);
#ifdef MBS_SUPPORT
  if (match_icase && MB_CUR_MAX > 1)
    buf = mbtolower (must, &n);
  else
#endif
    buf = must;
  return kwsincr (kwset, buf, n);
}

/* If the DFA turns out to have some set of fixed strings one of
   which must occur in the match, then we build a kwset matcher
   to find those strings, and thus quickly filter out impossible
   matches. */
static void
kwsmusts (void)
{
  struct dfamust const *dm;
  char const *err;

  if (dfa.musts)
    {
      kwsinit (&kwset);
      /* First, we compile in the substrings known to be exact
	 matches.  The kwset matcher will return the index
	 of the matching string that it chooses. */
      for (dm = dfa.musts; dm; dm = dm->next)
	{
	  if (!dm->exact)
	    continue;
	  ++kwset_exact_matches;
	  if ((err = kwsincr_case (dm->must)) != NULL)
	    error (EXIT_TROUBLE, 0, "%s", err);
	}
      /* Now, we compile the substrings that will require
	 the use of the regexp matcher.  */
      for (dm = dfa.musts; dm; dm = dm->next)
	{
	  if (dm->exact)
	    continue;
	  if ((err = kwsincr_case (dm->must)) != NULL)
	    error (EXIT_TROUBLE, 0, "%s", err);
	}
      if ((err = kwsprep (kwset)) != NULL)
	error (EXIT_TROUBLE, 0, "%s", err);
    }
}

void
GEAcompile (char const *pattern, size_t size, reg_syntax_t syntax_bits)
{
  const char *err;
  const char *p, *sep;
  size_t total = size;
  char *motif;

  if (match_icase)
    syntax_bits |= RE_ICASE;
  re_set_syntax (syntax_bits);
  dfasyntax (syntax_bits, match_icase, eolbyte);

  /* For GNU regex compiler we have to pass the patterns separately to detect
     errors like "[\nallo\n]\n".  The patterns here are "[", "allo" and "]"
     GNU regex should have raise a syntax error.  The same for backref, where
     the backref should have been local to each pattern.  */
  p = pattern;
  do
    {
      size_t len;
      sep = memchr (p, '\n', total);
      if (sep)
	{
	  len = sep - p;
	  sep++;
	  total -= (len + 1);
	}
      else
	{
	  len = total;
	  total = 0;
	}

      patterns = realloc (patterns, (pcount + 1) * sizeof (*patterns));
      if (patterns == NULL)
	error (EXIT_TROUBLE, errno, _("memory exhausted"));
      patterns[pcount] = patterns0;

      if ((err = re_compile_pattern (p, len,
				    &(patterns[pcount].regexbuf))) != NULL)
	error (EXIT_TROUBLE, 0, "%s", err);
      pcount++;

      p = sep;
    } while (sep && total != 0);

  /* In the match_words and match_lines cases, we use a different pattern
     for the DFA matcher that will quickly throw out cases that won't work.
     Then if DFA succeeds we do some hairy stuff using the regex matcher
     to decide whether the match should really count. */
  if (match_words || match_lines)
    {
      static char const line_beg_no_bk[] = "^(";
      static char const line_end_no_bk[] = ")$";
      static char const word_beg_no_bk[] = "(^|[^[:alnum:]_])(";
      static char const word_end_no_bk[] = ")([^[:alnum:]_]|$)";
      static char const line_beg_bk[] = "^\\(";
      static char const line_end_bk[] = "\\)$";
      static char const word_beg_bk[] = "\\(^\\|[^[:alnum:]_]\\)\\(";
      static char const word_end_bk[] = "\\)\\([^[:alnum:]_]\\|$\\)";
      int bk = !(syntax_bits & RE_NO_BK_PARENS);
      char *n = xmalloc (sizeof word_beg_bk - 1 + size + sizeof word_end_bk);

      strcpy (n, match_lines ? (bk ? line_beg_bk : line_beg_no_bk)
			     : (bk ? word_beg_bk : word_beg_no_bk));
      total = strlen(n);
      memcpy (n + total, pattern, size);
      total += size;
      strcpy (n + total, match_lines ? (bk ? line_end_bk : line_end_no_bk)
				     : (bk ? word_end_bk : word_end_no_bk));
      total += strlen (n + total);
      pattern = motif = n;
      size = total;
    }
  else
    motif = NULL;

  dfacomp (pattern, size, &dfa, 1);
  kwsmusts ();

  free(motif);
}

size_t
EGexecute (char const *buf, size_t size, size_t *match_size,
	   char const *start_ptr)
{
  char const *buflim, *beg, *end, *match, *best_match, *mb_start;
  char eol = eolbyte;
  int backref, start, len, best_len;
  struct kwsmatch kwsm;
  size_t i, ret_val;
#ifdef MBS_SUPPORT
  if (MB_CUR_MAX > 1)
    {
      if (match_icase)
        {
          /* mbtolower adds a NUL byte at the end.  That will provide
	     space for the sentinel byte dfaexec may add.  */
          char *case_buf = mbtolower (buf, &size);
	  if (start_ptr)
	    start_ptr = case_buf + (start_ptr - buf);
          buf = case_buf;
        }
    }
#endif /* MBS_SUPPORT */

  mb_start = buf;
  buflim = buf + size;

  for (beg = end = buf; end < buflim; beg = end)
    {
      if (!start_ptr)
	{
	  /* We don't care about an exact match.  */
	  if (kwset)
	    {
	      /* Find a possible match using the KWset matcher. */
	      size_t offset = kwsexec (kwset, beg, buflim - beg, &kwsm);
	      if (offset == (size_t) -1)
		goto failure;
	      beg += offset;
	      /* Narrow down to the line containing the candidate, and
		 run it through DFA. */
	      if ((end = memchr(beg, eol, buflim - beg)) != NULL)
	        end++;
              else
                end = buflim;
	      match = beg;
	      while (beg > buf && beg[-1] != eol)
		--beg;
	      if (kwsm.index < kwset_exact_matches)
                {
#ifdef MBS_SUPPORT
                  if (mb_start < beg)
                    mb_start = beg;
                  if (MB_CUR_MAX == 1 || !is_mb_middle (&mb_start, match, buflim))
#endif
                    goto success;
                }
	      if (dfaexec (&dfa, beg, (char *) end, 0, NULL, &backref) == NULL)
		continue;
	    }
	  else
	    {
	      /* No good fixed strings; start with DFA. */
	      char const *next_beg = dfaexec (&dfa, beg, (char *) buflim,
					      0, NULL, &backref);
	      if (next_beg == NULL)
		break;
	      /* Narrow down to the line we've found. */
	      beg = next_beg;
	      if ((end = memchr(beg, eol, buflim - beg)) != NULL)
	        end++;
              else
                end = buflim;
	      while (beg > buf && beg[-1] != eol)
		--beg;
	    }
	  /* Successful, no backreferences encountered! */
	  if (!backref)
	    goto success;
	}
      else
	{
	  /* We are looking for the leftmost (then longest) exact match.
	     We will go through the outer loop only once.  */
	  beg = start_ptr;
	  end = buflim;
	}

      /* If we've made it to this point, this means DFA has seen
	 a probable match, and we need to run it through Regex. */
      best_match = end;
      best_len = 0;
      for (i = 0; i < pcount; i++)
	{
	  patterns[i].regexbuf.not_eol = 0;
	  if (0 <= (start = re_search (&(patterns[i].regexbuf),
				       buf, end - buf - 1,
				       beg - buf, end - beg - 1,
				       &(patterns[i].regs))))
	    {
	      
//Patch 0:
if ((__is_neg(28, &(start), sizeof (start), &(len), sizeof (len), &(i), sizeof (i), &(patterns), sizeof (patterns), &(patterns[i].regs.end), sizeof (patterns[i].regs.end), &(buf), sizeof (buf), &(match), sizeof (match), &(best_match), sizeof (best_match), &(beg), sizeof (beg), &(end), sizeof (end), &(start_ptr), sizeof (start_ptr), &(match_words), sizeof (match_words), &(match_lines), sizeof (match_lines), &(pcount), sizeof (pcount), &(best_len), sizeof (best_len), &(buflim), sizeof (buflim), &(backref), sizeof (backref), &(eol), sizeof (eol), &(mb_start), sizeof (mb_start), &(kwset_exact_matches), sizeof (kwset_exact_matches), &(kwset), sizeof (kwset), &(size), sizeof (size), &(ret_val), sizeof (ret_val), &(match_size), sizeof (match_size), &(match_icase), sizeof (match_icase), &(eolbyte), sizeof (eolbyte), &(patterns[i].regs.num_regs), sizeof (patterns[i].regs.num_regs), &(patterns[i].regs.start), sizeof (patterns[i].regs.start))))
    return -1;
len = patterns[i].regs.end[0] - start;

//CodeSeg 1:
	      match = buf + start;
	      if (match > best_match)
		continue;
	      if (start_ptr && !match_words)
		goto assess_pattern_match;
	      if ((!match_lines && !match_words)
		  || (match_lines && len == end - beg - 1))
		{
		  match = beg;
		  len = end - beg;
		  goto assess_pattern_match;
		}
	      /* If -w, check if the match aligns with word boundaries.
		 We do this iteratively because:
		 (a) the line may contain more than one occurence of the
		 pattern, and
		 (b) Several alternatives in the pattern might be valid at a
		 given point, and we may need to consider a shorter one to
		 find a word boundary.  */
	      if (match_words)
		while (match <= best_match)
		  {
		    if ((match == buf || !WCHAR ((unsigned char) match[-1]))
			&& (len == end - beg - 1
			    || !WCHAR ((unsigned char) match[len])))
		      goto assess_pattern_match;
		    if (len > 0)
		      {
			/* Try a shorter length anchored at the same place. */
			--len;
			patterns[i].regexbuf.not_eol = 1;
			len = re_match (&(patterns[i].regexbuf),
					buf, match + len - beg, match - buf,
					&(patterns[i].regs));
		      }
		    if (len <= 0)
		      {
			/* Try looking further on. */
			if (match == end - 1)
			  break;
			match++;
			patterns[i].regexbuf.not_eol = 0;
			start = re_search (&(patterns[i].regexbuf),
					   buf, end - buf - 1,
					   match - buf, end - match - 1,
					   &(patterns[i].regs));
			if (start < 0)
			  break;
			len = patterns[i].regs.end[0] - start;
			match = buf + start;
		      }
		  } /* while (match <= best_match) */
	      continue;
	    assess_pattern_match:
	      if (!start_ptr)
		{
		  /* Good enough for a non-exact match.
		     No need to look at further patterns, if any.  */
		  beg = match;
		  goto success_in_len;
		}
	      if (match < best_match || (match == best_match && len > best_len))
		{
		  /* Best exact match:  leftmost, then longest.  */
		  best_match = match;
		  best_len = len;
		}
	    } /* if re_search >= 0 */
	} /* for Regex patterns.  */
	if (best_match < end)
	  {
	    /* We have found an exact match.  We were just
	       waiting for the best one (leftmost then longest).  */
	    beg = best_match;
	    len = best_len;
	    goto success_in_len;
	  }
    } /* for (beg = end ..) */

 failure:
  ret_val = -1;
  goto out;

 success:
  len = end - beg;
 success_in_len:
  *match_size = len;
  ret_val = beg - buf;
 out:
  return ret_val;
}

Testing negative cases!
Testing 0 (with abstract condition) ENVIS_NEG
Iteration 0
Running test command:
/home/ubuntu/spr-fast/tools/grep-test.py /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-8a025cf8-8f08d8e2/tempworkdir-l/src /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-8a025cf8-8f08d8e2/tempworkdir-l/tests /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-8a025cf8-8f08d8e2/tempworkdir-l 0  > __res
Opening:/tmp/neg.tmp!
NegativeBRANCH RECORD/tmp/neg.tmp!
APPENDING TO ISNEG:/tmp/neg.tmp!
Branch 0: 0
Iteration 1
Running test command:
/home/ubuntu/spr-fast/tools/grep-test.py /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-8a025cf8-8f08d8e2/tempworkdir-l/src /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-8a025cf8-8f08d8e2/tempworkdir-l/tests /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-8a025cf8-8f08d8e2/tempworkdir-l 0  > __res
Opening:/tmp/neg.tmp!
NegativeBRANCH RECORD/tmp/neg.tmp!
APPENDING TO ISNEG:/tmp/neg.tmp!
Branch 0: 1
Running test command:
/home/ubuntu/spr-fast/tools/grep-test.py /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-8a025cf8-8f08d8e2/tempworkdir-l/src /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-8a025cf8-8f08d8e2/tempworkdir-l/tests /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-8a025cf8-8f08d8e2/tempworkdir-l 0  > __res
CondTester, Testing instance id 72:
//src_file:src/dfasearch.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); void* memset(void*, int, unsigned long); 
/* dfasearch.c - searching subroutines using dfa and regex for grep.
   Copyright 1992, 1998, 2000, 2007, 2009-2010 Free Software Foundation, Inc.

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 3, or (at your option)
   any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program; if not, write to the Free Software
   Foundation, Inc., 51 Franklin Street - Fifth Floor, Boston, MA
   02110-1301, USA.  */

/* Written August 1992 by Mike Haertel. */

#include <config.h>
#include "search.h"
#include "dfa.h"

/* For -w, we also consider _ to be word constituent.  */
#define WCHAR(C) (ISALNUM(C) || (C) == '_')

/* KWset compiled pattern.  For Ecompile and Gcompile, we compile
   a list of strings, at least one of which is known to occur in
   any string matching the regexp. */
static kwset_t kwset;

/* DFA compiled regexp. */
static struct dfa dfa;

/* The Regex compiled patterns.  */
static struct patterns
{
  /* Regex compiled regexp. */
  struct re_pattern_buffer regexbuf;
  struct re_registers regs; /* This is here on account of a BRAIN-DEAD
			       Q@#%!# library interface in regex.c.  */
} patterns0;

struct patterns *patterns;
size_t pcount;

void
dfaerror (char const *mesg)
{
  error (EXIT_TROUBLE, 0, "%s", mesg);

  /* notreached */
  /* Tell static analyzers that this function does not return.  */
  abort ();
}

/* Number of compiled fixed strings known to exactly match the regexp.
   If kwsexec returns < kwset_exact_matches, then we don't need to
   call the regexp matcher at all. */
static int kwset_exact_matches;

static char const *
kwsincr_case (const char *must)
{
  const char *buf;
  size_t n;

  n = strlen (must);
#ifdef MBS_SUPPORT
  if (match_icase && MB_CUR_MAX > 1)
    buf = mbtolower (must, &n);
  else
#endif
    buf = must;
  return kwsincr (kwset, buf, n);
}

/* If the DFA turns out to have some set of fixed strings one of
   which must occur in the match, then we build a kwset matcher
   to find those strings, and thus quickly filter out impossible
   matches. */
static void
kwsmusts (void)
{
  struct dfamust const *dm;
  char const *err;

  if (dfa.musts)
    {
      kwsinit (&kwset);
      /* First, we compile in the substrings known to be exact
	 matches.  The kwset matcher will return the index
	 of the matching string that it chooses. */
      for (dm = dfa.musts; dm; dm = dm->next)
	{
	  if (!dm->exact)
	    continue;
	  ++kwset_exact_matches;
	  if ((err = kwsincr_case (dm->must)) != NULL)
	    error (EXIT_TROUBLE, 0, "%s", err);
	}
      /* Now, we compile the substrings that will require
	 the use of the regexp matcher.  */
      for (dm = dfa.musts; dm; dm = dm->next)
	{
	  if (dm->exact)
	    continue;
	  if ((err = kwsincr_case (dm->must)) != NULL)
	    error (EXIT_TROUBLE, 0, "%s", err);
	}
      if ((err = kwsprep (kwset)) != NULL)
	error (EXIT_TROUBLE, 0, "%s", err);
    }
}

void
GEAcompile (char const *pattern, size_t size, reg_syntax_t syntax_bits)
{
  const char *err;
  const char *p, *sep;
  size_t total = size;
  char *motif;

  if (match_icase)
    syntax_bits |= RE_ICASE;
  re_set_syntax (syntax_bits);
  dfasyntax (syntax_bits, match_icase, eolbyte);

  /* For GNU regex compiler we have to pass the patterns separately to detect
     errors like "[\nallo\n]\n".  The patterns here are "[", "allo" and "]"
     GNU regex should have raise a syntax error.  The same for backref, where
     the backref should have been local to each pattern.  */
  p = pattern;
  do
    {
      size_t len;
      sep = memchr (p, '\n', total);
      if (sep)
	{
	  len = sep - p;
	  sep++;
	  total -= (len + 1);
	}
      else
	{
	  len = total;
	  total = 0;
	}

      patterns = realloc (patterns, (pcount + 1) * sizeof (*patterns));
      if (patterns == NULL)
	error (EXIT_TROUBLE, errno, _("memory exhausted"));
      patterns[pcount] = patterns0;

      if ((err = re_compile_pattern (p, len,
				    &(patterns[pcount].regexbuf))) != NULL)
	error (EXIT_TROUBLE, 0, "%s", err);
      pcount++;

      p = sep;
    } while (sep && total != 0);

  /* In the match_words and match_lines cases, we use a different pattern
     for the DFA matcher that will quickly throw out cases that won't work.
     Then if DFA succeeds we do some hairy stuff using the regex matcher
     to decide whether the match should really count. */
  if (match_words || match_lines)
    {
      static char const line_beg_no_bk[] = "^(";
      static char const line_end_no_bk[] = ")$";
      static char const word_beg_no_bk[] = "(^|[^[:alnum:]_])(";
      static char const word_end_no_bk[] = ")([^[:alnum:]_]|$)";
      static char const line_beg_bk[] = "^\\(";
      static char const line_end_bk[] = "\\)$";
      static char const word_beg_bk[] = "\\(^\\|[^[:alnum:]_]\\)\\(";
      static char const word_end_bk[] = "\\)\\([^[:alnum:]_]\\|$\\)";
      int bk = !(syntax_bits & RE_NO_BK_PARENS);
      char *n = xmalloc (sizeof word_beg_bk - 1 + size + sizeof word_end_bk);

      strcpy (n, match_lines ? (bk ? line_beg_bk : line_beg_no_bk)
			     : (bk ? word_beg_bk : word_beg_no_bk));
      total = strlen(n);
      memcpy (n + total, pattern, size);
      total += size;
      strcpy (n + total, match_lines ? (bk ? line_end_bk : line_end_no_bk)
				     : (bk ? word_end_bk : word_end_no_bk));
      total += strlen (n + total);
      pattern = motif = n;
      size = total;
    }
  else
    motif = NULL;

  dfacomp (pattern, size, &dfa, 1);
  kwsmusts ();

  free(motif);
}

size_t
EGexecute (char const *buf, size_t size, size_t *match_size,
	   char const *start_ptr)
{
  char const *buflim, *beg, *end, *match, *best_match, *mb_start;
  char eol = eolbyte;
  int backref, start, len, best_len;
  struct kwsmatch kwsm;
  size_t i, ret_val;
#ifdef MBS_SUPPORT
  if (MB_CUR_MAX > 1)
    {
      if (match_icase)
        {
          /* mbtolower adds a NUL byte at the end.  That will provide
	     space for the sentinel byte dfaexec may add.  */
          char *case_buf = mbtolower (buf, &size);
	  if (start_ptr)
	    start_ptr = case_buf + (start_ptr - buf);
          buf = case_buf;
        }
    }
#endif /* MBS_SUPPORT */

  mb_start = buf;
  buflim = buf + size;

  for (beg = end = buf; end < buflim; beg = end)
    {
      if (!start_ptr)
	{
	  /* We don't care about an exact match.  */
	  if (kwset)
	    {
	      /* Find a possible match using the KWset matcher. */
	      size_t offset = kwsexec (kwset, beg, buflim - beg, &kwsm);
	      if (offset == (size_t) -1)
		goto failure;
	      beg += offset;
	      /* Narrow down to the line containing the candidate, and
		 run it through DFA. */
	      if ((end = memchr(beg, eol, buflim - beg)) != NULL)
	        end++;
              else
                end = buflim;
	      match = beg;
	      while (beg > buf && beg[-1] != eol)
		--beg;
	      if (kwsm.index < kwset_exact_matches)
                {
#ifdef MBS_SUPPORT
                  if (mb_start < beg)
                    mb_start = beg;
                  if (MB_CUR_MAX == 1 || !is_mb_middle (&mb_start, match, buflim))
#endif
                    goto success;
                }
	      if (dfaexec (&dfa, beg, (char *) end, 0, NULL, &backref) == NULL)
		continue;
	    }
	  else
	    {
	      /* No good fixed strings; start with DFA. */
	      char const *next_beg = dfaexec (&dfa, beg, (char *) buflim,
					      0, NULL, &backref);
	      if (next_beg == NULL)
		break;
	      /* Narrow down to the line we've found. */
	      beg = next_beg;
	      if ((end = memchr(beg, eol, buflim - beg)) != NULL)
	        end++;
              else
                end = buflim;
	      while (beg > buf && beg[-1] != eol)
		--beg;
	    }
	  /* Successful, no backreferences encountered! */
	  if (!backref)
	    goto success;
	}
      else
	{
	  /* We are looking for the leftmost (then longest) exact match.
	     We will go through the outer loop only once.  */
	  beg = start_ptr;
	  end = buflim;
	}

      /* If we've made it to this point, this means DFA has seen
	 a probable match, and we need to run it through Regex. */
      best_match = end;
      best_len = 0;
      for (i = 0; i < pcount; i++)
	{
	  patterns[i].regexbuf.not_eol = 0;
	  if (0 <= (start = re_search (&(patterns[i].regexbuf),
				       buf, end - buf - 1,
				       beg - buf, end - beg - 1,
				       &(patterns[i].regs))))
	    {
	      
//Patch 0:
if ((__is_neg(28, &(start), sizeof (start), &(len), sizeof (len), &(i), sizeof (i), &(patterns), sizeof (patterns), &(patterns[i].regs.end), sizeof (patterns[i].regs.end), &(buf), sizeof (buf), &(match), sizeof (match), &(best_match), sizeof (best_match), &(beg), sizeof (beg), &(end), sizeof (end), &(start_ptr), sizeof (start_ptr), &(match_words), sizeof (match_words), &(match_lines), sizeof (match_lines), &(pcount), sizeof (pcount), &(best_len), sizeof (best_len), &(buflim), sizeof (buflim), &(backref), sizeof (backref), &(eol), sizeof (eol), &(mb_start), sizeof (mb_start), &(kwset_exact_matches), sizeof (kwset_exact_matches), &(kwset), sizeof (kwset), &(size), sizeof (size), &(ret_val), sizeof (ret_val), &(match_size), sizeof (match_size), &(match_icase), sizeof (match_icase), &(eolbyte), sizeof (eolbyte), &(patterns[i].regs.num_regs), sizeof (patterns[i].regs.num_regs), &(patterns[i].regs.start), sizeof (patterns[i].regs.start))))
    return 0;
len = patterns[i].regs.end[0] - start;

//CodeSeg 1:
	      match = buf + start;
	      if (match > best_match)
		continue;
	      if (start_ptr && !match_words)
		goto assess_pattern_match;
	      if ((!match_lines && !match_words)
		  || (match_lines && len == end - beg - 1))
		{
		  match = beg;
		  len = end - beg;
		  goto assess_pattern_match;
		}
	      /* If -w, check if the match aligns with word boundaries.
		 We do this iteratively because:
		 (a) the line may contain more than one occurence of the
		 pattern, and
		 (b) Several alternatives in the pattern might be valid at a
		 given point, and we may need to consider a shorter one to
		 find a word boundary.  */
	      if (match_words)
		while (match <= best_match)
		  {
		    if ((match == buf || !WCHAR ((unsigned char) match[-1]))
			&& (len == end - beg - 1
			    || !WCHAR ((unsigned char) match[len])))
		      goto assess_pattern_match;
		    if (len > 0)
		      {
			/* Try a shorter length anchored at the same place. */
			--len;
			patterns[i].regexbuf.not_eol = 1;
			len = re_match (&(patterns[i].regexbuf),
					buf, match + len - beg, match - buf,
					&(patterns[i].regs));
		      }
		    if (len <= 0)
		      {
			/* Try looking further on. */
			if (match == end - 1)
			  break;
			match++;
			patterns[i].regexbuf.not_eol = 0;
			start = re_search (&(patterns[i].regexbuf),
					   buf, end - buf - 1,
					   match - buf, end - match - 1,
					   &(patterns[i].regs));
			if (start < 0)
			  break;
			len = patterns[i].regs.end[0] - start;
			match = buf + start;
		      }
		  } /* while (match <= best_match) */
	      continue;
	    assess_pattern_match:
	      if (!start_ptr)
		{
		  /* Good enough for a non-exact match.
		     No need to look at further patterns, if any.  */
		  beg = match;
		  goto success_in_len;
		}
	      if (match < best_match || (match == best_match && len > best_len))
		{
		  /* Best exact match:  leftmost, then longest.  */
		  best_match = match;
		  best_len = len;
		}
	    } /* if re_search >= 0 */
	} /* for Regex patterns.  */
	if (best_match < end)
	  {
	    /* We have found an exact match.  We were just
	       waiting for the best one (leftmost then longest).  */
	    beg = best_match;
	    len = best_len;
	    goto success_in_len;
	  }
    } /* for (beg = end ..) */

 failure:
  ret_val = -1;
  goto out;

 success:
  len = end - beg;
 success_in_len:
  *match_size = len;
  ret_val = beg - buf;
 out:
  return ret_val;
}

Testing negative cases!
Testing 0 (with abstract condition) ENVIS_NEG
Iteration 0
Running test command:
/home/ubuntu/spr-fast/tools/grep-test.py /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-8a025cf8-8f08d8e2/tempworkdir-l/src /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-8a025cf8-8f08d8e2/tempworkdir-l/tests /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-8a025cf8-8f08d8e2/tempworkdir-l 0  > __res
Opening:/tmp/neg.tmp!
NegativeBRANCH RECORD/tmp/neg.tmp!
APPENDING TO ISNEG:/tmp/neg.tmp!
Branch 0: 0
Iteration 1
Running test command:
/home/ubuntu/spr-fast/tools/grep-test.py /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-8a025cf8-8f08d8e2/tempworkdir-l/src /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-8a025cf8-8f08d8e2/tempworkdir-l/tests /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-8a025cf8-8f08d8e2/tempworkdir-l 0  > __res
Opening:/tmp/neg.tmp!
NegativeBRANCH RECORD/tmp/neg.tmp!
APPENDING TO ISNEG:/tmp/neg.tmp!
Branch 0: 1
Running test command:
/home/ubuntu/spr-fast/tools/grep-test.py /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-8a025cf8-8f08d8e2/tempworkdir-l/src /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-8a025cf8-8f08d8e2/tempworkdir-l/tests /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-8a025cf8-8f08d8e2/tempworkdir-l 0  > __res
CondTester, Testing instance id 73:
//src_file:src/dfasearch.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); void* memset(void*, int, unsigned long); 
/* dfasearch.c - searching subroutines using dfa and regex for grep.
   Copyright 1992, 1998, 2000, 2007, 2009-2010 Free Software Foundation, Inc.

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 3, or (at your option)
   any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program; if not, write to the Free Software
   Foundation, Inc., 51 Franklin Street - Fifth Floor, Boston, MA
   02110-1301, USA.  */

/* Written August 1992 by Mike Haertel. */

#include <config.h>
#include "search.h"
#include "dfa.h"

/* For -w, we also consider _ to be word constituent.  */
#define WCHAR(C) (ISALNUM(C) || (C) == '_')

/* KWset compiled pattern.  For Ecompile and Gcompile, we compile
   a list of strings, at least one of which is known to occur in
   any string matching the regexp. */
static kwset_t kwset;

/* DFA compiled regexp. */
static struct dfa dfa;

/* The Regex compiled patterns.  */
static struct patterns
{
  /* Regex compiled regexp. */
  struct re_pattern_buffer regexbuf;
  struct re_registers regs; /* This is here on account of a BRAIN-DEAD
			       Q@#%!# library interface in regex.c.  */
} patterns0;

struct patterns *patterns;
size_t pcount;

void
dfaerror (char const *mesg)
{
  error (EXIT_TROUBLE, 0, "%s", mesg);

  /* notreached */
  /* Tell static analyzers that this function does not return.  */
  abort ();
}

/* Number of compiled fixed strings known to exactly match the regexp.
   If kwsexec returns < kwset_exact_matches, then we don't need to
   call the regexp matcher at all. */
static int kwset_exact_matches;

static char const *
kwsincr_case (const char *must)
{
  const char *buf;
  size_t n;

  n = strlen (must);
#ifdef MBS_SUPPORT
  if (match_icase && MB_CUR_MAX > 1)
    buf = mbtolower (must, &n);
  else
#endif
    buf = must;
  return kwsincr (kwset, buf, n);
}

/* If the DFA turns out to have some set of fixed strings one of
   which must occur in the match, then we build a kwset matcher
   to find those strings, and thus quickly filter out impossible
   matches. */
static void
kwsmusts (void)
{
  struct dfamust const *dm;
  char const *err;

  if (dfa.musts)
    {
      kwsinit (&kwset);
      /* First, we compile in the substrings known to be exact
	 matches.  The kwset matcher will return the index
	 of the matching string that it chooses. */
      for (dm = dfa.musts; dm; dm = dm->next)
	{
	  if (!dm->exact)
	    continue;
	  ++kwset_exact_matches;
	  if ((err = kwsincr_case (dm->must)) != NULL)
	    error (EXIT_TROUBLE, 0, "%s", err);
	}
      /* Now, we compile the substrings that will require
	 the use of the regexp matcher.  */
      for (dm = dfa.musts; dm; dm = dm->next)
	{
	  if (dm->exact)
	    continue;
	  if ((err = kwsincr_case (dm->must)) != NULL)
	    error (EXIT_TROUBLE, 0, "%s", err);
	}
      if ((err = kwsprep (kwset)) != NULL)
	error (EXIT_TROUBLE, 0, "%s", err);
    }
}

void
GEAcompile (char const *pattern, size_t size, reg_syntax_t syntax_bits)
{
  const char *err;
  const char *p, *sep;
  size_t total = size;
  char *motif;

  if (match_icase)
    syntax_bits |= RE_ICASE;
  re_set_syntax (syntax_bits);
  dfasyntax (syntax_bits, match_icase, eolbyte);

  /* For GNU regex compiler we have to pass the patterns separately to detect
     errors like "[\nallo\n]\n".  The patterns here are "[", "allo" and "]"
     GNU regex should have raise a syntax error.  The same for backref, where
     the backref should have been local to each pattern.  */
  p = pattern;
  do
    {
      size_t len;
      sep = memchr (p, '\n', total);
      if (sep)
	{
	  len = sep - p;
	  sep++;
	  total -= (len + 1);
	}
      else
	{
	  len = total;
	  total = 0;
	}

      patterns = realloc (patterns, (pcount + 1) * sizeof (*patterns));
      if (patterns == NULL)
	error (EXIT_TROUBLE, errno, _("memory exhausted"));
      patterns[pcount] = patterns0;

      if ((err = re_compile_pattern (p, len,
				    &(patterns[pcount].regexbuf))) != NULL)
	error (EXIT_TROUBLE, 0, "%s", err);
      pcount++;

      p = sep;
    } while (sep && total != 0);

  /* In the match_words and match_lines cases, we use a different pattern
     for the DFA matcher that will quickly throw out cases that won't work.
     Then if DFA succeeds we do some hairy stuff using the regex matcher
     to decide whether the match should really count. */
  if (match_words || match_lines)
    {
      static char const line_beg_no_bk[] = "^(";
      static char const line_end_no_bk[] = ")$";
      static char const word_beg_no_bk[] = "(^|[^[:alnum:]_])(";
      static char const word_end_no_bk[] = ")([^[:alnum:]_]|$)";
      static char const line_beg_bk[] = "^\\(";
      static char const line_end_bk[] = "\\)$";
      static char const word_beg_bk[] = "\\(^\\|[^[:alnum:]_]\\)\\(";
      static char const word_end_bk[] = "\\)\\([^[:alnum:]_]\\|$\\)";
      int bk = !(syntax_bits & RE_NO_BK_PARENS);
      char *n = xmalloc (sizeof word_beg_bk - 1 + size + sizeof word_end_bk);

      strcpy (n, match_lines ? (bk ? line_beg_bk : line_beg_no_bk)
			     : (bk ? word_beg_bk : word_beg_no_bk));
      total = strlen(n);
      memcpy (n + total, pattern, size);
      total += size;
      strcpy (n + total, match_lines ? (bk ? line_end_bk : line_end_no_bk)
				     : (bk ? word_end_bk : word_end_no_bk));
      total += strlen (n + total);
      pattern = motif = n;
      size = total;
    }
  else
    motif = NULL;

  dfacomp (pattern, size, &dfa, 1);
  kwsmusts ();

  free(motif);
}

size_t
EGexecute (char const *buf, size_t size, size_t *match_size,
	   char const *start_ptr)
{
  char const *buflim, *beg, *end, *match, *best_match, *mb_start;
  char eol = eolbyte;
  int backref, start, len, best_len;
  struct kwsmatch kwsm;
  size_t i, ret_val;
#ifdef MBS_SUPPORT
  if (MB_CUR_MAX > 1)
    {
      if (match_icase)
        {
          /* mbtolower adds a NUL byte at the end.  That will provide
	     space for the sentinel byte dfaexec may add.  */
          char *case_buf = mbtolower (buf, &size);
	  if (start_ptr)
	    start_ptr = case_buf + (start_ptr - buf);
          buf = case_buf;
        }
    }
#endif /* MBS_SUPPORT */

  mb_start = buf;
  buflim = buf + size;

  for (beg = end = buf; end < buflim; beg = end)
    {
      if (!start_ptr)
	{
	  /* We don't care about an exact match.  */
	  if (kwset)
	    {
	      /* Find a possible match using the KWset matcher. */
	      size_t offset = kwsexec (kwset, beg, buflim - beg, &kwsm);
	      if (offset == (size_t) -1)
		goto failure;
	      beg += offset;
	      /* Narrow down to the line containing the candidate, and
		 run it through DFA. */
	      if ((end = memchr(beg, eol, buflim - beg)) != NULL)
	        end++;
              else
                end = buflim;
	      match = beg;
	      while (beg > buf && beg[-1] != eol)
		--beg;
	      if (kwsm.index < kwset_exact_matches)
                {
#ifdef MBS_SUPPORT
                  if (mb_start < beg)
                    mb_start = beg;
                  if (MB_CUR_MAX == 1 || !is_mb_middle (&mb_start, match, buflim))
#endif
                    goto success;
                }
	      if (dfaexec (&dfa, beg, (char *) end, 0, NULL, &backref) == NULL)
		continue;
	    }
	  else
	    {
	      /* No good fixed strings; start with DFA. */
	      char const *next_beg = dfaexec (&dfa, beg, (char *) buflim,
					      0, NULL, &backref);
	      if (next_beg == NULL)
		break;
	      /* Narrow down to the line we've found. */
	      beg = next_beg;
	      if ((end = memchr(beg, eol, buflim - beg)) != NULL)
	        end++;
              else
                end = buflim;
	      while (beg > buf && beg[-1] != eol)
		--beg;
	    }
	  /* Successful, no backreferences encountered! */
	  if (!backref)
	    goto success;
	}
      else
	{
	  /* We are looking for the leftmost (then longest) exact match.
	     We will go through the outer loop only once.  */
	  beg = start_ptr;
	  end = buflim;
	}

      /* If we've made it to this point, this means DFA has seen
	 a probable match, and we need to run it through Regex. */
      best_match = end;
      best_len = 0;
      for (i = 0; i < pcount; i++)
	{
	  patterns[i].regexbuf.not_eol = 0;
	  if (0 <= (start = re_search (&(patterns[i].regexbuf),
				       buf, end - buf - 1,
				       beg - buf, end - beg - 1,
				       &(patterns[i].regs))))
	    {
	      
//Patch 0:
if ((__is_neg(28, &(start), sizeof (start), &(len), sizeof (len), &(i), sizeof (i), &(patterns), sizeof (patterns), &(patterns[i].regs.end), sizeof (patterns[i].regs.end), &(buf), sizeof (buf), &(match), sizeof (match), &(best_match), sizeof (best_match), &(beg), sizeof (beg), &(end), sizeof (end), &(start_ptr), sizeof (start_ptr), &(match_words), sizeof (match_words), &(match_lines), sizeof (match_lines), &(pcount), sizeof (pcount), &(best_len), sizeof (best_len), &(buflim), sizeof (buflim), &(backref), sizeof (backref), &(eol), sizeof (eol), &(mb_start), sizeof (mb_start), &(kwset_exact_matches), sizeof (kwset_exact_matches), &(kwset), sizeof (kwset), &(size), sizeof (size), &(ret_val), sizeof (ret_val), &(match_size), sizeof (match_size), &(match_icase), sizeof (match_icase), &(eolbyte), sizeof (eolbyte), &(patterns[i].regs.num_regs), sizeof (patterns[i].regs.num_regs), &(patterns[i].regs.start), sizeof (patterns[i].regs.start))))
    return 1;
len = patterns[i].regs.end[0] - start;

//CodeSeg 1:
	      match = buf + start;
	      if (match > best_match)
		continue;
	      if (start_ptr && !match_words)
		goto assess_pattern_match;
	      if ((!match_lines && !match_words)
		  || (match_lines && len == end - beg - 1))
		{
		  match = beg;
		  len = end - beg;
		  goto assess_pattern_match;
		}
	      /* If -w, check if the match aligns with word boundaries.
		 We do this iteratively because:
		 (a) the line may contain more than one occurence of the
		 pattern, and
		 (b) Several alternatives in the pattern might be valid at a
		 given point, and we may need to consider a shorter one to
		 find a word boundary.  */
	      if (match_words)
		while (match <= best_match)
		  {
		    if ((match == buf || !WCHAR ((unsigned char) match[-1]))
			&& (len == end - beg - 1
			    || !WCHAR ((unsigned char) match[len])))
		      goto assess_pattern_match;
		    if (len > 0)
		      {
			/* Try a shorter length anchored at the same place. */
			--len;
			patterns[i].regexbuf.not_eol = 1;
			len = re_match (&(patterns[i].regexbuf),
					buf, match + len - beg, match - buf,
					&(patterns[i].regs));
		      }
		    if (len <= 0)
		      {
			/* Try looking further on. */
			if (match == end - 1)
			  break;
			match++;
			patterns[i].regexbuf.not_eol = 0;
			start = re_search (&(patterns[i].regexbuf),
					   buf, end - buf - 1,
					   match - buf, end - match - 1,
					   &(patterns[i].regs));
			if (start < 0)
			  break;
			len = patterns[i].regs.end[0] - start;
			match = buf + start;
		      }
		  } /* while (match <= best_match) */
	      continue;
	    assess_pattern_match:
	      if (!start_ptr)
		{
		  /* Good enough for a non-exact match.
		     No need to look at further patterns, if any.  */
		  beg = match;
		  goto success_in_len;
		}
	      if (match < best_match || (match == best_match && len > best_len))
		{
		  /* Best exact match:  leftmost, then longest.  */
		  best_match = match;
		  best_len = len;
		}
	    } /* if re_search >= 0 */
	} /* for Regex patterns.  */
	if (best_match < end)
	  {
	    /* We have found an exact match.  We were just
	       waiting for the best one (leftmost then longest).  */
	    beg = best_match;
	    len = best_len;
	    goto success_in_len;
	  }
    } /* for (beg = end ..) */

 failure:
  ret_val = -1;
  goto out;

 success:
  len = end - beg;
 success_in_len:
  *match_size = len;
  ret_val = beg - buf;
 out:
  return ret_val;
}

Testing negative cases!
Testing 0 (with abstract condition) ENVIS_NEG
Iteration 0
Running test command:
/home/ubuntu/spr-fast/tools/grep-test.py /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-8a025cf8-8f08d8e2/tempworkdir-l/src /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-8a025cf8-8f08d8e2/tempworkdir-l/tests /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-8a025cf8-8f08d8e2/tempworkdir-l 0  > __res
Opening:/tmp/neg.tmp!
NegativeBRANCH RECORD/tmp/neg.tmp!
APPENDING TO ISNEG:/tmp/neg.tmp!
Branch 0: 0
Iteration 1
Running test command:
/home/ubuntu/spr-fast/tools/grep-test.py /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-8a025cf8-8f08d8e2/tempworkdir-l/src /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-8a025cf8-8f08d8e2/tempworkdir-l/tests /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-8a025cf8-8f08d8e2/tempworkdir-l 0  > __res
Opening:/tmp/neg.tmp!
NegativeBRANCH RECORD/tmp/neg.tmp!
APPENDING TO ISNEG:/tmp/neg.tmp!
Branch 0: 1
Running test command:
/home/ubuntu/spr-fast/tools/grep-test.py /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-8a025cf8-8f08d8e2/tempworkdir-l/src /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-8a025cf8-8f08d8e2/tempworkdir-l/tests /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-8a025cf8-8f08d8e2/tempworkdir-l 0  > __res
CondTester, Testing instance id 74:
//src_file:src/dfasearch.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); void* memset(void*, int, unsigned long); 
/* dfasearch.c - searching subroutines using dfa and regex for grep.
   Copyright 1992, 1998, 2000, 2007, 2009-2010 Free Software Foundation, Inc.

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 3, or (at your option)
   any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program; if not, write to the Free Software
   Foundation, Inc., 51 Franklin Street - Fifth Floor, Boston, MA
   02110-1301, USA.  */

/* Written August 1992 by Mike Haertel. */

#include <config.h>
#include "search.h"
#include "dfa.h"

/* For -w, we also consider _ to be word constituent.  */
#define WCHAR(C) (ISALNUM(C) || (C) == '_')

/* KWset compiled pattern.  For Ecompile and Gcompile, we compile
   a list of strings, at least one of which is known to occur in
   any string matching the regexp. */
static kwset_t kwset;

/* DFA compiled regexp. */
static struct dfa dfa;

/* The Regex compiled patterns.  */
static struct patterns
{
  /* Regex compiled regexp. */
  struct re_pattern_buffer regexbuf;
  struct re_registers regs; /* This is here on account of a BRAIN-DEAD
			       Q@#%!# library interface in regex.c.  */
} patterns0;

struct patterns *patterns;
size_t pcount;

void
dfaerror (char const *mesg)
{
  error (EXIT_TROUBLE, 0, "%s", mesg);

  /* notreached */
  /* Tell static analyzers that this function does not return.  */
  abort ();
}

/* Number of compiled fixed strings known to exactly match the regexp.
   If kwsexec returns < kwset_exact_matches, then we don't need to
   call the regexp matcher at all. */
static int kwset_exact_matches;

static char const *
kwsincr_case (const char *must)
{
  const char *buf;
  size_t n;

  n = strlen (must);
#ifdef MBS_SUPPORT
  if (match_icase && MB_CUR_MAX > 1)
    buf = mbtolower (must, &n);
  else
#endif
    buf = must;
  return kwsincr (kwset, buf, n);
}

/* If the DFA turns out to have some set of fixed strings one of
   which must occur in the match, then we build a kwset matcher
   to find those strings, and thus quickly filter out impossible
   matches. */
static void
kwsmusts (void)
{
  struct dfamust const *dm;
  char const *err;

  if (dfa.musts)
    {
      kwsinit (&kwset);
      /* First, we compile in the substrings known to be exact
	 matches.  The kwset matcher will return the index
	 of the matching string that it chooses. */
      for (dm = dfa.musts; dm; dm = dm->next)
	{
	  if (!dm->exact)
	    continue;
	  ++kwset_exact_matches;
	  if ((err = kwsincr_case (dm->must)) != NULL)
	    error (EXIT_TROUBLE, 0, "%s", err);
	}
      /* Now, we compile the substrings that will require
	 the use of the regexp matcher.  */
      for (dm = dfa.musts; dm; dm = dm->next)
	{
	  if (dm->exact)
	    continue;
	  if ((err = kwsincr_case (dm->must)) != NULL)
	    error (EXIT_TROUBLE, 0, "%s", err);
	}
      if ((err = kwsprep (kwset)) != NULL)
	error (EXIT_TROUBLE, 0, "%s", err);
    }
}

void
GEAcompile (char const *pattern, size_t size, reg_syntax_t syntax_bits)
{
  const char *err;
  const char *p, *sep;
  size_t total = size;
  char *motif;

  if (match_icase)
    syntax_bits |= RE_ICASE;
  re_set_syntax (syntax_bits);
  dfasyntax (syntax_bits, match_icase, eolbyte);

  /* For GNU regex compiler we have to pass the patterns separately to detect
     errors like "[\nallo\n]\n".  The patterns here are "[", "allo" and "]"
     GNU regex should have raise a syntax error.  The same for backref, where
     the backref should have been local to each pattern.  */
  p = pattern;
  do
    {
      size_t len;
      sep = memchr (p, '\n', total);
      if (sep)
	{
	  len = sep - p;
	  sep++;
	  total -= (len + 1);
	}
      else
	{
	  len = total;
	  total = 0;
	}

      patterns = realloc (patterns, (pcount + 1) * sizeof (*patterns));
      if (patterns == NULL)
	error (EXIT_TROUBLE, errno, _("memory exhausted"));
      patterns[pcount] = patterns0;

      if ((err = re_compile_pattern (p, len,
				    &(patterns[pcount].regexbuf))) != NULL)
	error (EXIT_TROUBLE, 0, "%s", err);
      pcount++;

      p = sep;
    } while (sep && total != 0);

  /* In the match_words and match_lines cases, we use a different pattern
     for the DFA matcher that will quickly throw out cases that won't work.
     Then if DFA succeeds we do some hairy stuff using the regex matcher
     to decide whether the match should really count. */
  if (match_words || match_lines)
    {
      static char const line_beg_no_bk[] = "^(";
      static char const line_end_no_bk[] = ")$";
      static char const word_beg_no_bk[] = "(^|[^[:alnum:]_])(";
      static char const word_end_no_bk[] = ")([^[:alnum:]_]|$)";
      static char const line_beg_bk[] = "^\\(";
      static char const line_end_bk[] = "\\)$";
      static char const word_beg_bk[] = "\\(^\\|[^[:alnum:]_]\\)\\(";
      static char const word_end_bk[] = "\\)\\([^[:alnum:]_]\\|$\\)";
      int bk = !(syntax_bits & RE_NO_BK_PARENS);
      char *n = xmalloc (sizeof word_beg_bk - 1 + size + sizeof word_end_bk);

      strcpy (n, match_lines ? (bk ? line_beg_bk : line_beg_no_bk)
			     : (bk ? word_beg_bk : word_beg_no_bk));
      total = strlen(n);
      memcpy (n + total, pattern, size);
      total += size;
      strcpy (n + total, match_lines ? (bk ? line_end_bk : line_end_no_bk)
				     : (bk ? word_end_bk : word_end_no_bk));
      total += strlen (n + total);
      pattern = motif = n;
      size = total;
    }
  else
    motif = NULL;

  dfacomp (pattern, size, &dfa, 1);
  kwsmusts ();

  free(motif);
}

size_t
EGexecute (char const *buf, size_t size, size_t *match_size,
	   char const *start_ptr)
{
  char const *buflim, *beg, *end, *match, *best_match, *mb_start;
  char eol = eolbyte;
  int backref, start, len, best_len;
  struct kwsmatch kwsm;
  size_t i, ret_val;
#ifdef MBS_SUPPORT
  if (MB_CUR_MAX > 1)
    {
      if (match_icase)
        {
          /* mbtolower adds a NUL byte at the end.  That will provide
	     space for the sentinel byte dfaexec may add.  */
          char *case_buf = mbtolower (buf, &size);
	  if (start_ptr)
	    start_ptr = case_buf + (start_ptr - buf);
          buf = case_buf;
        }
    }
#endif /* MBS_SUPPORT */

  mb_start = buf;
  buflim = buf + size;

  for (beg = end = buf; end < buflim; beg = end)
    {
      if (!start_ptr)
	{
	  /* We don't care about an exact match.  */
	  if (kwset)
	    {
	      /* Find a possible match using the KWset matcher. */
	      size_t offset = kwsexec (kwset, beg, buflim - beg, &kwsm);
	      if (offset == (size_t) -1)
		goto failure;
	      beg += offset;
	      /* Narrow down to the line containing the candidate, and
		 run it through DFA. */
	      if ((end = memchr(beg, eol, buflim - beg)) != NULL)
	        end++;
              else
                end = buflim;
	      match = beg;
	      while (beg > buf && beg[-1] != eol)
		--beg;
	      if (kwsm.index < kwset_exact_matches)
                {
#ifdef MBS_SUPPORT
                  if (mb_start < beg)
                    mb_start = beg;
                  if (MB_CUR_MAX == 1 || !is_mb_middle (&mb_start, match, buflim))
#endif
                    goto success;
                }
	      if (dfaexec (&dfa, beg, (char *) end, 0, NULL, &backref) == NULL)
		continue;
	    }
	  else
	    {
	      /* No good fixed strings; start with DFA. */
	      char const *next_beg = dfaexec (&dfa, beg, (char *) buflim,
					      0, NULL, &backref);
	      if (next_beg == NULL)
		break;
	      /* Narrow down to the line we've found. */
	      beg = next_beg;
	      if ((end = memchr(beg, eol, buflim - beg)) != NULL)
	        end++;
              else
                end = buflim;
	      while (beg > buf && beg[-1] != eol)
		--beg;
	    }
	  /* Successful, no backreferences encountered! */
	  if (!backref)
	    goto success;
	}
      else
	{
	  /* We are looking for the leftmost (then longest) exact match.
	     We will go through the outer loop only once.  */
	  beg = start_ptr;
	  end = buflim;
	}

      /* If we've made it to this point, this means DFA has seen
	 a probable match, and we need to run it through Regex. */
      best_match = end;
      best_len = 0;
      for (i = 0; i < pcount; i++)
	{
	  patterns[i].regexbuf.not_eol = 0;
	  if (0 <= (start = re_search (&(patterns[i].regexbuf),
				       buf, end - buf - 1,
				       beg - buf, end - beg - 1,
				       &(patterns[i].regs))))
	    {
	      
//Patch 0:
if ((__is_neg(28, &(start), sizeof (start), &(len), sizeof (len), &(i), sizeof (i), &(patterns), sizeof (patterns), &(patterns[i].regs.end), sizeof (patterns[i].regs.end), &(buf), sizeof (buf), &(match), sizeof (match), &(best_match), sizeof (best_match), &(beg), sizeof (beg), &(end), sizeof (end), &(start_ptr), sizeof (start_ptr), &(match_words), sizeof (match_words), &(match_lines), sizeof (match_lines), &(pcount), sizeof (pcount), &(best_len), sizeof (best_len), &(buflim), sizeof (buflim), &(backref), sizeof (backref), &(eol), sizeof (eol), &(mb_start), sizeof (mb_start), &(kwset_exact_matches), sizeof (kwset_exact_matches), &(kwset), sizeof (kwset), &(size), sizeof (size), &(ret_val), sizeof (ret_val), &(match_size), sizeof (match_size), &(match_icase), sizeof (match_icase), &(eolbyte), sizeof (eolbyte), &(patterns[i].regs.num_regs), sizeof (patterns[i].regs.num_regs), &(patterns[i].regs.start), sizeof (patterns[i].regs.start))))
    break;
len = patterns[i].regs.end[0] - start;

//CodeSeg 1:
	      match = buf + start;
	      if (match > best_match)
		continue;
	      if (start_ptr && !match_words)
		goto assess_pattern_match;
	      if ((!match_lines && !match_words)
		  || (match_lines && len == end - beg - 1))
		{
		  match = beg;
		  len = end - beg;
		  goto assess_pattern_match;
		}
	      /* If -w, check if the match aligns with word boundaries.
		 We do this iteratively because:
		 (a) the line may contain more than one occurence of the
		 pattern, and
		 (b) Several alternatives in the pattern might be valid at a
		 given point, and we may need to consider a shorter one to
		 find a word boundary.  */
	      if (match_words)
		while (match <= best_match)
		  {
		    if ((match == buf || !WCHAR ((unsigned char) match[-1]))
			&& (len == end - beg - 1
			    || !WCHAR ((unsigned char) match[len])))
		      goto assess_pattern_match;
		    if (len > 0)
		      {
			/* Try a shorter length anchored at the same place. */
			--len;
			patterns[i].regexbuf.not_eol = 1;
			len = re_match (&(patterns[i].regexbuf),
					buf, match + len - beg, match - buf,
					&(patterns[i].regs));
		      }
		    if (len <= 0)
		      {
			/* Try looking further on. */
			if (match == end - 1)
			  break;
			match++;
			patterns[i].regexbuf.not_eol = 0;
			start = re_search (&(patterns[i].regexbuf),
					   buf, end - buf - 1,
					   match - buf, end - match - 1,
					   &(patterns[i].regs));
			if (start < 0)
			  break;
			len = patterns[i].regs.end[0] - start;
			match = buf + start;
		      }
		  } /* while (match <= best_match) */
	      continue;
	    assess_pattern_match:
	      if (!start_ptr)
		{
		  /* Good enough for a non-exact match.
		     No need to look at further patterns, if any.  */
		  beg = match;
		  goto success_in_len;
		}
	      if (match < best_match || (match == best_match && len > best_len))
		{
		  /* Best exact match:  leftmost, then longest.  */
		  best_match = match;
		  best_len = len;
		}
	    } /* if re_search >= 0 */
	} /* for Regex patterns.  */
	if (best_match < end)
	  {
	    /* We have found an exact match.  We were just
	       waiting for the best one (leftmost then longest).  */
	    beg = best_match;
	    len = best_len;
	    goto success_in_len;
	  }
    } /* for (beg = end ..) */

 failure:
  ret_val = -1;
  goto out;

 success:
  len = end - beg;
 success_in_len:
  *match_size = len;
  ret_val = beg - buf;
 out:
  return ret_val;
}

Testing negative cases!
Testing 0 (with abstract condition) ENVIS_NEG
Iteration 0
Running test command:
/home/ubuntu/spr-fast/tools/grep-test.py /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-8a025cf8-8f08d8e2/tempworkdir-l/src /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-8a025cf8-8f08d8e2/tempworkdir-l/tests /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-8a025cf8-8f08d8e2/tempworkdir-l 0  > __res
Opening:/tmp/neg.tmp!
NegativeBRANCH RECORD/tmp/neg.tmp!
APPENDING TO ISNEG:/tmp/neg.tmp!
Branch 0: 0
Iteration 1
Running test command:
/home/ubuntu/spr-fast/tools/grep-test.py /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-8a025cf8-8f08d8e2/tempworkdir-l/src /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-8a025cf8-8f08d8e2/tempworkdir-l/tests /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-8a025cf8-8f08d8e2/tempworkdir-l 0  > __res
Opening:/tmp/neg.tmp!
NegativeBRANCH RECORD/tmp/neg.tmp!
APPENDING TO ISNEG:/tmp/neg.tmp!
Branch 0: 1
Running test command:
/home/ubuntu/spr-fast/tools/grep-test.py /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-8a025cf8-8f08d8e2/tempworkdir-l/src /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-8a025cf8-8f08d8e2/tempworkdir-l/tests /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-8a025cf8-8f08d8e2/tempworkdir-l 0  > __res
CondTester, Postprocessing instance id 64:
//src_file:src/dfasearch.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); void* memset(void*, int, unsigned long); 
/* dfasearch.c - searching subroutines using dfa and regex for grep.
   Copyright 1992, 1998, 2000, 2007, 2009-2010 Free Software Foundation, Inc.

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 3, or (at your option)
   any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program; if not, write to the Free Software
   Foundation, Inc., 51 Franklin Street - Fifth Floor, Boston, MA
   02110-1301, USA.  */

/* Written August 1992 by Mike Haertel. */

#include <config.h>
#include "search.h"
#include "dfa.h"

/* For -w, we also consider _ to be word constituent.  */
#define WCHAR(C) (ISALNUM(C) || (C) == '_')

/* KWset compiled pattern.  For Ecompile and Gcompile, we compile
   a list of strings, at least one of which is known to occur in
   any string matching the regexp. */
static kwset_t kwset;

/* DFA compiled regexp. */
static struct dfa dfa;

/* The Regex compiled patterns.  */
static struct patterns
{
  /* Regex compiled regexp. */
  struct re_pattern_buffer regexbuf;
  struct re_registers regs; /* This is here on account of a BRAIN-DEAD
			       Q@#%!# library interface in regex.c.  */
} patterns0;

struct patterns *patterns;
size_t pcount;

void
dfaerror (char const *mesg)
{
  error (EXIT_TROUBLE, 0, "%s", mesg);

  /* notreached */
  /* Tell static analyzers that this function does not return.  */
  abort ();
}

/* Number of compiled fixed strings known to exactly match the regexp.
   If kwsexec returns < kwset_exact_matches, then we don't need to
   call the regexp matcher at all. */
static int kwset_exact_matches;

static char const *
kwsincr_case (const char *must)
{
  const char *buf;
  size_t n;

  n = strlen (must);
#ifdef MBS_SUPPORT
  if (match_icase && MB_CUR_MAX > 1)
    buf = mbtolower (must, &n);
  else
#endif
    buf = must;
  return kwsincr (kwset, buf, n);
}

/* If the DFA turns out to have some set of fixed strings one of
   which must occur in the match, then we build a kwset matcher
   to find those strings, and thus quickly filter out impossible
   matches. */
static void
kwsmusts (void)
{
  struct dfamust const *dm;
  char const *err;

  if (dfa.musts)
    {
      kwsinit (&kwset);
      /* First, we compile in the substrings known to be exact
	 matches.  The kwset matcher will return the index
	 of the matching string that it chooses. */
      for (dm = dfa.musts; dm; dm = dm->next)
	{
	  if (!dm->exact)
	    continue;
	  ++kwset_exact_matches;
	  if ((err = kwsincr_case (dm->must)) != NULL)
	    error (EXIT_TROUBLE, 0, "%s", err);
	}
      /* Now, we compile the substrings that will require
	 the use of the regexp matcher.  */
      for (dm = dfa.musts; dm; dm = dm->next)
	{
	  if (dm->exact)
	    continue;
	  if ((err = kwsincr_case (dm->must)) != NULL)
	    error (EXIT_TROUBLE, 0, "%s", err);
	}
      if ((err = kwsprep (kwset)) != NULL)
	error (EXIT_TROUBLE, 0, "%s", err);
    }
}

void
GEAcompile (char const *pattern, size_t size, reg_syntax_t syntax_bits)
{
  const char *err;
  const char *p, *sep;
  size_t total = size;
  char *motif;

  if (match_icase)
    syntax_bits |= RE_ICASE;
  re_set_syntax (syntax_bits);
  dfasyntax (syntax_bits, match_icase, eolbyte);

  /* For GNU regex compiler we have to pass the patterns separately to detect
     errors like "[\nallo\n]\n".  The patterns here are "[", "allo" and "]"
     GNU regex should have raise a syntax error.  The same for backref, where
     the backref should have been local to each pattern.  */
  p = pattern;
  do
    {
      size_t len;
      sep = memchr (p, '\n', total);
      if (sep)
	{
	  len = sep - p;
	  sep++;
	  total -= (len + 1);
	}
      else
	{
	  len = total;
	  total = 0;
	}

      patterns = realloc (patterns, (pcount + 1) * sizeof (*patterns));
      if (patterns == NULL)
	error (EXIT_TROUBLE, errno, _("memory exhausted"));
      patterns[pcount] = patterns0;

      if ((err = re_compile_pattern (p, len,
				    &(patterns[pcount].regexbuf))) != NULL)
	error (EXIT_TROUBLE, 0, "%s", err);
      pcount++;

      p = sep;
    } while (sep && total != 0);

  /* In the match_words and match_lines cases, we use a different pattern
     for the DFA matcher that will quickly throw out cases that won't work.
     Then if DFA succeeds we do some hairy stuff using the regex matcher
     to decide whether the match should really count. */
  if (match_words || match_lines)
    {
      static char const line_beg_no_bk[] = "^(";
      static char const line_end_no_bk[] = ")$";
      static char const word_beg_no_bk[] = "(^|[^[:alnum:]_])(";
      static char const word_end_no_bk[] = ")([^[:alnum:]_]|$)";
      static char const line_beg_bk[] = "^\\(";
      static char const line_end_bk[] = "\\)$";
      static char const word_beg_bk[] = "\\(^\\|[^[:alnum:]_]\\)\\(";
      static char const word_end_bk[] = "\\)\\([^[:alnum:]_]\\|$\\)";
      int bk = !(syntax_bits & RE_NO_BK_PARENS);
      char *n = xmalloc (sizeof word_beg_bk - 1 + size + sizeof word_end_bk);

      strcpy (n, match_lines ? (bk ? line_beg_bk : line_beg_no_bk)
			     : (bk ? word_beg_bk : word_beg_no_bk));
      total = strlen(n);
      memcpy (n + total, pattern, size);
      total += size;
      strcpy (n + total, match_lines ? (bk ? line_end_bk : line_end_no_bk)
				     : (bk ? word_end_bk : word_end_no_bk));
      total += strlen (n + total);
      pattern = motif = n;
      size = total;
    }
  else
    motif = NULL;

  dfacomp (pattern, size, &dfa, 1);
  kwsmusts ();

  free(motif);
}

size_t
EGexecute (char const *buf, size_t size, size_t *match_size,
	   char const *start_ptr)
{
  char const *buflim, *beg, *end, *match, *best_match, *mb_start;
  char eol = eolbyte;
  int backref, start, len, best_len;
  struct kwsmatch kwsm;
  size_t i, ret_val;
#ifdef MBS_SUPPORT
  if (MB_CUR_MAX > 1)
    {
      if (match_icase)
        {
          /* mbtolower adds a NUL byte at the end.  That will provide
	     space for the sentinel byte dfaexec may add.  */
          char *case_buf = mbtolower (buf, &size);
	  if (start_ptr)
	    start_ptr = case_buf + (start_ptr - buf);
          buf = case_buf;
        }
    }
#endif /* MBS_SUPPORT */

  mb_start = buf;
  buflim = buf + size;

  for (beg = end = buf; end < buflim; beg = end)
    {
      if (!start_ptr)
	{
	  /* We don't care about an exact match.  */
	  if (kwset)
	    {
	      /* Find a possible match using the KWset matcher. */
	      size_t offset = kwsexec (kwset, beg, buflim - beg, &kwsm);
	      if (offset == (size_t) -1)
		goto failure;
	      beg += offset;
	      /* Narrow down to the line containing the candidate, and
		 run it through DFA. */
	      if ((end = memchr(beg, eol, buflim - beg)) != NULL)
	        end++;
              else
                end = buflim;
	      match = beg;
	      while (beg > buf && beg[-1] != eol)
		--beg;
	      if (kwsm.index < kwset_exact_matches)
                {
#ifdef MBS_SUPPORT
                  if (mb_start < beg)
                    mb_start = beg;
                  if (MB_CUR_MAX == 1 || !is_mb_middle (&mb_start, match, buflim))
#endif
                    goto success;
                }
	      if (dfaexec (&dfa, beg, (char *) end, 0, NULL, &backref) == NULL)
		continue;
	    }
	  else
	    {
	      /* No good fixed strings; start with DFA. */
	      char const *next_beg = dfaexec (&dfa, beg, (char *) buflim,
					      0, NULL, &backref);
	      if (next_beg == NULL)
		break;
	      /* Narrow down to the line we've found. */
	      beg = next_beg;
	      if ((end = memchr(beg, eol, buflim - beg)) != NULL)
	        end++;
              else
                end = buflim;
	      while (beg > buf && beg[-1] != eol)
		--beg;
	    }
	  /* Successful, no backreferences encountered! */
	  if (!backref)
	    goto success;
	}
      else
	{
	  /* We are looking for the leftmost (then longest) exact match.
	     We will go through the outer loop only once.  */
	  beg = start_ptr;
	  end = buflim;
	}

      /* If we've made it to this point, this means DFA has seen
	 a probable match, and we need to run it through Regex. */
      best_match = end;
      best_len = 0;
      for (i = 0; i < pcount; i++)
	{
	  patterns[i].regexbuf.not_eol = 0;
	  if (0 <= (start = re_search (&(patterns[i].regexbuf),
				       buf, end - buf - 1,
				       beg - buf, end - beg - 1,
				       &(patterns[i].regs))))
	    {
	      
//Patch 0:
if ((__is_neg(28, &(start), sizeof (start), &(len), sizeof (len), &(i), sizeof (i), &(patterns), sizeof (patterns), &(patterns[i].regs.end), sizeof (patterns[i].regs.end), &(buf), sizeof (buf), &(match), sizeof (match), &(best_match), sizeof (best_match), &(beg), sizeof (beg), &(end), sizeof (end), &(start_ptr), sizeof (start_ptr), &(match_words), sizeof (match_words), &(match_lines), sizeof (match_lines), &(pcount), sizeof (pcount), &(best_len), sizeof (best_len), &(buflim), sizeof (buflim), &(backref), sizeof (backref), &(eol), sizeof (eol), &(mb_start), sizeof (mb_start), &(kwset_exact_matches), sizeof (kwset_exact_matches), &(kwset), sizeof (kwset), &(size), sizeof (size), &(ret_val), sizeof (ret_val), &(match_size), sizeof (match_size), &(match_icase), sizeof (match_icase), &(eolbyte), sizeof (eolbyte), &(patterns[i].regs.num_regs), sizeof (patterns[i].regs.num_regs), &(patterns[i].regs.start), sizeof (patterns[i].regs.start))))
    goto success;
len = patterns[i].regs.end[0] - start;

//CodeSeg 1:
	      match = buf + start;
	      if (match > best_match)
		continue;
	      if (start_ptr && !match_words)
		goto assess_pattern_match;
	      if ((!match_lines && !match_words)
		  || (match_lines && len == end - beg - 1))
		{
		  match = beg;
		  len = end - beg;
		  goto assess_pattern_match;
		}
	      /* If -w, check if the match aligns with word boundaries.
		 We do this iteratively because:
		 (a) the line may contain more than one occurence of the
		 pattern, and
		 (b) Several alternatives in the pattern might be valid at a
		 given point, and we may need to consider a shorter one to
		 find a word boundary.  */
	      if (match_words)
		while (match <= best_match)
		  {
		    if ((match == buf || !WCHAR ((unsigned char) match[-1]))
			&& (len == end - beg - 1
			    || !WCHAR ((unsigned char) match[len])))
		      goto assess_pattern_match;
		    if (len > 0)
		      {
			/* Try a shorter length anchored at the same place. */
			--len;
			patterns[i].regexbuf.not_eol = 1;
			len = re_match (&(patterns[i].regexbuf),
					buf, match + len - beg, match - buf,
					&(patterns[i].regs));
		      }
		    if (len <= 0)
		      {
			/* Try looking further on. */
			if (match == end - 1)
			  break;
			match++;
			patterns[i].regexbuf.not_eol = 0;
			start = re_search (&(patterns[i].regexbuf),
					   buf, end - buf - 1,
					   match - buf, end - match - 1,
					   &(patterns[i].regs));
			if (start < 0)
			  break;
			len = patterns[i].regs.end[0] - start;
			match = buf + start;
		      }
		  } /* while (match <= best_match) */
	      continue;
	    assess_pattern_match:
	      if (!start_ptr)
		{
		  /* Good enough for a non-exact match.
		     No need to look at further patterns, if any.  */
		  beg = match;
		  goto success_in_len;
		}
	      if (match < best_match || (match == best_match && len > best_len))
		{
		  /* Best exact match:  leftmost, then longest.  */
		  best_match = match;
		  best_len = len;
		}
	    } /* if re_search >= 0 */
	} /* for Regex patterns.  */
	if (best_match < end)
	  {
	    /* We have found an exact match.  We were just
	       waiting for the best one (leftmost then longest).  */
	    beg = best_match;
	    len = best_len;
	    goto success_in_len;
	  }
    } /* for (beg = end ..) */

 failure:
  ret_val = -1;
  goto out;

 success:
  len = end - beg;
 success_in_len:
  *match_size = len;
  ret_val = beg - buf;
 out:
  return ret_val;
}

Postprocessing failed!
a batched test job starts!
Building merged code:
src_file: src/dfasearch.c
full src: int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); void* memset(void*, int, unsigned long); 
/* dfasearch.c - searching subroutines using dfa and regex for grep.
   Copyright 1992, 1998, 2000, 2007, 2009-2010 Free Software Foundation, Inc.

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 3, or (at your option)
   any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program; if not, write to the Free Software
   Foundation, Inc., 51 Franklin Street - Fifth Floor, Boston, MA
   02110-1301, USA.  */

/* Written August 1992 by Mike Haertel. */

#include <config.h>
#include "search.h"
#include "dfa.h"

/* For -w, we also consider _ to be word constituent.  */
#define WCHAR(C) (ISALNUM(C) || (C) == '_')

/* KWset compiled pattern.  For Ecompile and Gcompile, we compile
   a list of strings, at least one of which is known to occur in
   any string matching the regexp. */
static kwset_t kwset;

/* DFA compiled regexp. */
static struct dfa dfa;

/* The Regex compiled patterns.  */
static struct patterns
{
  /* Regex compiled regexp. */
  struct re_pattern_buffer regexbuf;
  struct re_registers regs; /* This is here on account of a BRAIN-DEAD
			       Q@#%!# library interface in regex.c.  */
} patterns0;

struct patterns *patterns;
size_t pcount;

void
dfaerror (char const *mesg)
{
  error (EXIT_TROUBLE, 0, "%s", mesg);

  /* notreached */
  /* Tell static analyzers that this function does not return.  */
  abort ();
}

/* Number of compiled fixed strings known to exactly match the regexp.
   If kwsexec returns < kwset_exact_matches, then we don't need to
   call the regexp matcher at all. */
static int kwset_exact_matches;

static char const *
kwsincr_case (const char *must)
{
  const char *buf;
  size_t n;

  n = strlen (must);
#ifdef MBS_SUPPORT
  if (match_icase && MB_CUR_MAX > 1)
    buf = mbtolower (must, &n);
  else
#endif
    buf = must;
  return kwsincr (kwset, buf, n);
}

/* If the DFA turns out to have some set of fixed strings one of
   which must occur in the match, then we build a kwset matcher
   to find those strings, and thus quickly filter out impossible
   matches. */
static void
kwsmusts (void)
{
  struct dfamust const *dm;
  char const *err;

  if (dfa.musts)
    {
      kwsinit (&kwset);
      /* First, we compile in the substrings known to be exact
	 matches.  The kwset matcher will return the index
	 of the matching string that it chooses. */
      for (dm = dfa.musts; dm; dm = dm->next)
	{
	  if (!dm->exact)
	    continue;
	  ++kwset_exact_matches;
	  if ((err = kwsincr_case (dm->must)) != NULL)
	    error (EXIT_TROUBLE, 0, "%s", err);
	}
      /* Now, we compile the substrings that will require
	 the use of the regexp matcher.  */
      for (dm = dfa.musts; dm; dm = dm->next)
	{
	  if (dm->exact)
	    continue;
	  if ((err = kwsincr_case (dm->must)) != NULL)
	    error (EXIT_TROUBLE, 0, "%s", err);
	}
      if ((err = kwsprep (kwset)) != NULL)
	error (EXIT_TROUBLE, 0, "%s", err);
    }
}

void
GEAcompile (char const *pattern, size_t size, reg_syntax_t syntax_bits)
{
  const char *err;
  const char *p, *sep;
  size_t total = size;
  char *motif;

  if (match_icase)
    syntax_bits |= RE_ICASE;
  re_set_syntax (syntax_bits);
  dfasyntax (syntax_bits, match_icase, eolbyte);

  /* For GNU regex compiler we have to pass the patterns separately to detect
     errors like "[\nallo\n]\n".  The patterns here are "[", "allo" and "]"
     GNU regex should have raise a syntax error.  The same for backref, where
     the backref should have been local to each pattern.  */
  p = pattern;
  do
    {
      size_t len;
      sep = memchr (p, '\n', total);
      if (sep)
	{
	  len = sep - p;
	  sep++;
	  total -= (len + 1);
	}
      else
	{
	  len = total;
	  total = 0;
	}

      patterns = realloc (patterns, (pcount + 1) * sizeof (*patterns));
      if (patterns == NULL)
	error (EXIT_TROUBLE, errno, _("memory exhausted"));
      patterns[pcount] = patterns0;

      if ((err = re_compile_pattern (p, len,
				    &(patterns[pcount].regexbuf))) != NULL)
	error (EXIT_TROUBLE, 0, "%s", err);
      pcount++;

      p = sep;
    } while (sep && total != 0);

  /* In the match_words and match_lines cases, we use a different pattern
     for the DFA matcher that will quickly throw out cases that won't work.
     Then if DFA succeeds we do some hairy stuff using the regex matcher
     to decide whether the match should really count. */
  if (match_words || match_lines)
    {
      static char const line_beg_no_bk[] = "^(";
      static char const line_end_no_bk[] = ")$";
      static char const word_beg_no_bk[] = "(^|[^[:alnum:]_])(";
      static char const word_end_no_bk[] = ")([^[:alnum:]_]|$)";
      static char const line_beg_bk[] = "^\\(";
      static char const line_end_bk[] = "\\)$";
      static char const word_beg_bk[] = "\\(^\\|[^[:alnum:]_]\\)\\(";
      static char const word_end_bk[] = "\\)\\([^[:alnum:]_]\\|$\\)";
      int bk = !(syntax_bits & RE_NO_BK_PARENS);
      char *n = xmalloc (sizeof word_beg_bk - 1 + size + sizeof word_end_bk);

      strcpy (n, match_lines ? (bk ? line_beg_bk : line_beg_no_bk)
			     : (bk ? word_beg_bk : word_beg_no_bk));
      total = strlen(n);
      memcpy (n + total, pattern, size);
      total += size;
      strcpy (n + total, match_lines ? (bk ? line_end_bk : line_end_no_bk)
				     : (bk ? word_end_bk : word_end_no_bk));
      total += strlen (n + total);
      pattern = motif = n;
      size = total;
    }
  else
    motif = NULL;

  dfacomp (pattern, size, &dfa, 1);
  kwsmusts ();

  free(motif);
}

size_t
EGexecute (char const *buf, size_t size, size_t *match_size,
	   char const *start_ptr)
{
  char const *buflim, *beg, *end, *match, *best_match, *mb_start;
  char eol = eolbyte;
  int backref, start, len, best_len;
  struct kwsmatch kwsm;
  size_t i, ret_val;
#ifdef MBS_SUPPORT
  if (MB_CUR_MAX > 1)
    {
      if (match_icase)
        {
          /* mbtolower adds a NUL byte at the end.  That will provide
	     space for the sentinel byte dfaexec may add.  */
          char *case_buf = mbtolower (buf, &size);
	  if (start_ptr)
	    start_ptr = case_buf + (start_ptr - buf);
          buf = case_buf;
        }
    }
#endif /* MBS_SUPPORT */

  mb_start = buf;
  buflim = buf + size;

  for (beg = end = buf; end < buflim; beg = end)
    {
      if (!start_ptr)
	{
	  /* We don't care about an exact match.  */
	  if (kwset)
	    {
	      /* Find a possible match using the KWset matcher. */
	      size_t offset = kwsexec (kwset, beg, buflim - beg, &kwsm);
	      if (offset == (size_t) -1)
		goto failure;
	      beg += offset;
	      /* Narrow down to the line containing the candidate, and
		 run it through DFA. */
	      if ((end = memchr(beg, eol, buflim - beg)) != NULL)
	        end++;
              else
                end = buflim;
	      match = beg;
	      while (beg > buf && beg[-1] != eol)
		--beg;
	      if (kwsm.index < kwset_exact_matches)
                {
#ifdef MBS_SUPPORT
                  if (mb_start < beg)
                    mb_start = beg;
                  if (MB_CUR_MAX == 1 || !is_mb_middle (&mb_start, match, buflim))
#endif
                    goto success;
                }
	      if (dfaexec (&dfa, beg, (char *) end, 0, NULL, &backref) == NULL)
		continue;
	    }
	  else
	    {
	      /* No good fixed strings; start with DFA. */
	      char const *next_beg = dfaexec (&dfa, beg, (char *) buflim,
					      0, NULL, &backref);
	      if (next_beg == NULL)
		break;
	      /* Narrow down to the line we've found. */
	      beg = next_beg;
	      if ((end = memchr(beg, eol, buflim - beg)) != NULL)
	        end++;
              else
                end = buflim;
	      while (beg > buf && beg[-1] != eol)
		--beg;
	    }
	  /* Successful, no backreferences encountered! */
	  if (!backref)
	    goto success;
	}
      else
	{
	  /* We are looking for the leftmost (then longest) exact match.
	     We will go through the outer loop only once.  */
	  beg = start_ptr;
	  end = buflim;
	}

      /* If we've made it to this point, this means DFA has seen
	 a probable match, and we need to run it through Regex. */
      best_match = end;
      best_len = 0;
      for (i = 0; i < pcount; i++)
	{
	  patterns[i].regexbuf.not_eol = 0;
	  if (0 <= (start = re_search (&(patterns[i].regexbuf),
				       buf, end - buf - 1,
				       beg - buf, end - beg - 1,
				       &(patterns[i].regs))))
	    {
	      len = patterns[i].regs.end[0] - start;
	      match = buf + start;
	      //prophet generated patch
	      if (__get_mutant()==0) {
	      if ((match > best_match) && !(__is_neg(25, &(match), sizeof (match), &(best_match), sizeof (best_match), &(buf), sizeof (buf), &(start), sizeof (start), &(start_ptr), sizeof (start_ptr), &(len), sizeof (len), &(i), sizeof (i), &(match_words), sizeof (match_words), &(patterns), sizeof (patterns), &(match_lines), sizeof (match_lines), &(beg), sizeof (beg), &(end), sizeof (end), &(pcount), sizeof (pcount), &(best_len), sizeof (best_len), &(buflim), sizeof (buflim), &(backref), sizeof (backref), &(eol), sizeof (eol), &(mb_start), sizeof (mb_start), &(kwset_exact_matches), sizeof (kwset_exact_matches), &(kwset), sizeof (kwset), &(size), sizeof (size), &(ret_val), sizeof (ret_val), &(match_size), sizeof (match_size), &(match_icase), sizeof (match_icase), &(eolbyte), sizeof (eolbyte))))
	          continue;
	      }
	      else if (__get_mutant()==1) {
	      if ((match > best_match) || (__is_neg(25, &(match), sizeof (match), &(best_match), sizeof (best_match), &(buf), sizeof (buf), &(start), sizeof (start), &(start_ptr), sizeof (start_ptr), &(len), sizeof (len), &(i), sizeof (i), &(match_words), sizeof (match_words), &(patterns), sizeof (patterns), &(match_lines), sizeof (match_lines), &(beg), sizeof (beg), &(end), sizeof (end), &(pcount), sizeof (pcount), &(best_len), sizeof (best_len), &(buflim), sizeof (buflim), &(backref), sizeof (backref), &(eol), sizeof (eol), &(mb_start), sizeof (mb_start), &(kwset_exact_matches), sizeof (kwset_exact_matches), &(kwset), sizeof (kwset), &(size), sizeof (size), &(ret_val), sizeof (ret_val), &(match_size), sizeof (match_size), &(match_icase), sizeof (match_icase), &(eolbyte), sizeof (eolbyte))))
	          continue;
	      }
	      if (start_ptr && !match_words)
		goto assess_pattern_match;
	      if ((!match_lines && !match_words)
		  || (match_lines && len == end - beg - 1))
		{
		  match = beg;
		  len = end - beg;
		  goto assess_pattern_match;
		}
	      /* If -w, check if the match aligns with word boundaries.
		 We do this iteratively because:
		 (a) the line may contain more than one occurence of the
		 pattern, and
		 (b) Several alternatives in the pattern might be valid at a
		 given point, and we may need to consider a shorter one to
		 find a word boundary.  */
	      if (match_words)
		while (match <= best_match)
		  {
		    if ((match == buf || !WCHAR ((unsigned char) match[-1]))
			&& (len == end - beg - 1
			    || !WCHAR ((unsigned char) match[len])))
		      goto assess_pattern_match;
		    if (len > 0)
		      {
			/* Try a shorter length anchored at the same place. */
			--len;
			patterns[i].regexbuf.not_eol = 1;
			len = re_match (&(patterns[i].regexbuf),
					buf, match + len - beg, match - buf,
					&(patterns[i].regs));
		      }
		    if (len <= 0)
		      {
			/* Try looking further on. */
			if (match == end - 1)
			  break;
			match++;
			patterns[i].regexbuf.not_eol = 0;
			start = re_search (&(patterns[i].regexbuf),
					   buf, end - buf - 1,
					   match - buf, end - match - 1,
					   &(patterns[i].regs));
			if (start < 0)
			  break;
			len = patterns[i].regs.end[0] - start;
			match = buf + start;
		      }
		  } /* while (match <= best_match) */
	      continue;
	    assess_pattern_match:
	      if (!start_ptr)
		{
		  /* Good enough for a non-exact match.
		     No need to look at further patterns, if any.  */
		  beg = match;
		  goto success_in_len;
		}
	      if (match < best_match || (match == best_match && len > best_len))
		{
		  /* Best exact match:  leftmost, then longest.  */
		  best_match = match;
		  best_len = len;
		}
	    } /* if re_search >= 0 */
	} /* for Regex patterns.  */
	if (best_match < end)
	  {
	    /* We have found an exact match.  We were just
	       waiting for the best one (leftmost then longest).  */
	    beg = best_match;
	    len = best_len;
	    goto success_in_len;
	  }
    } /* for (beg = end ..) */

 failure:
  ret_val = -1;
  goto out;

 success:
  len = end - beg;
 success_in_len:
  *match_size = len;
  ret_val = beg - buf;
 out:
  return ret_val;
}

Building:src at:
/home/ubuntu/spr-fast/tests/corebench/grep/grep-case-8a025cf8-8f08d8e2/tempworkdir-l/srcMerged code building succ, going to invoke tester!
CondTester, Testing instance id 26:
//src_file:src/dfasearch.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); void* memset(void*, int, unsigned long); 
/* dfasearch.c - searching subroutines using dfa and regex for grep.
   Copyright 1992, 1998, 2000, 2007, 2009-2010 Free Software Foundation, Inc.

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 3, or (at your option)
   any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program; if not, write to the Free Software
   Foundation, Inc., 51 Franklin Street - Fifth Floor, Boston, MA
   02110-1301, USA.  */

/* Written August 1992 by Mike Haertel. */

#include <config.h>
#include "search.h"
#include "dfa.h"

/* For -w, we also consider _ to be word constituent.  */
#define WCHAR(C) (ISALNUM(C) || (C) == '_')

/* KWset compiled pattern.  For Ecompile and Gcompile, we compile
   a list of strings, at least one of which is known to occur in
   any string matching the regexp. */
static kwset_t kwset;

/* DFA compiled regexp. */
static struct dfa dfa;

/* The Regex compiled patterns.  */
static struct patterns
{
  /* Regex compiled regexp. */
  struct re_pattern_buffer regexbuf;
  struct re_registers regs; /* This is here on account of a BRAIN-DEAD
			       Q@#%!# library interface in regex.c.  */
} patterns0;

struct patterns *patterns;
size_t pcount;

void
dfaerror (char const *mesg)
{
  error (EXIT_TROUBLE, 0, "%s", mesg);

  /* notreached */
  /* Tell static analyzers that this function does not return.  */
  abort ();
}

/* Number of compiled fixed strings known to exactly match the regexp.
   If kwsexec returns < kwset_exact_matches, then we don't need to
   call the regexp matcher at all. */
static int kwset_exact_matches;

static char const *
kwsincr_case (const char *must)
{
  const char *buf;
  size_t n;

  n = strlen (must);
#ifdef MBS_SUPPORT
  if (match_icase && MB_CUR_MAX > 1)
    buf = mbtolower (must, &n);
  else
#endif
    buf = must;
  return kwsincr (kwset, buf, n);
}

/* If the DFA turns out to have some set of fixed strings one of
   which must occur in the match, then we build a kwset matcher
   to find those strings, and thus quickly filter out impossible
   matches. */
static void
kwsmusts (void)
{
  struct dfamust const *dm;
  char const *err;

  if (dfa.musts)
    {
      kwsinit (&kwset);
      /* First, we compile in the substrings known to be exact
	 matches.  The kwset matcher will return the index
	 of the matching string that it chooses. */
      for (dm = dfa.musts; dm; dm = dm->next)
	{
	  if (!dm->exact)
	    continue;
	  ++kwset_exact_matches;
	  if ((err = kwsincr_case (dm->must)) != NULL)
	    error (EXIT_TROUBLE, 0, "%s", err);
	}
      /* Now, we compile the substrings that will require
	 the use of the regexp matcher.  */
      for (dm = dfa.musts; dm; dm = dm->next)
	{
	  if (dm->exact)
	    continue;
	  if ((err = kwsincr_case (dm->must)) != NULL)
	    error (EXIT_TROUBLE, 0, "%s", err);
	}
      if ((err = kwsprep (kwset)) != NULL)
	error (EXIT_TROUBLE, 0, "%s", err);
    }
}

void
GEAcompile (char const *pattern, size_t size, reg_syntax_t syntax_bits)
{
  const char *err;
  const char *p, *sep;
  size_t total = size;
  char *motif;

  if (match_icase)
    syntax_bits |= RE_ICASE;
  re_set_syntax (syntax_bits);
  dfasyntax (syntax_bits, match_icase, eolbyte);

  /* For GNU regex compiler we have to pass the patterns separately to detect
     errors like "[\nallo\n]\n".  The patterns here are "[", "allo" and "]"
     GNU regex should have raise a syntax error.  The same for backref, where
     the backref should have been local to each pattern.  */
  p = pattern;
  do
    {
      size_t len;
      sep = memchr (p, '\n', total);
      if (sep)
	{
	  len = sep - p;
	  sep++;
	  total -= (len + 1);
	}
      else
	{
	  len = total;
	  total = 0;
	}

      patterns = realloc (patterns, (pcount + 1) * sizeof (*patterns));
      if (patterns == NULL)
	error (EXIT_TROUBLE, errno, _("memory exhausted"));
      patterns[pcount] = patterns0;

      if ((err = re_compile_pattern (p, len,
				    &(patterns[pcount].regexbuf))) != NULL)
	error (EXIT_TROUBLE, 0, "%s", err);
      pcount++;

      p = sep;
    } while (sep && total != 0);

  /* In the match_words and match_lines cases, we use a different pattern
     for the DFA matcher that will quickly throw out cases that won't work.
     Then if DFA succeeds we do some hairy stuff using the regex matcher
     to decide whether the match should really count. */
  if (match_words || match_lines)
    {
      static char const line_beg_no_bk[] = "^(";
      static char const line_end_no_bk[] = ")$";
      static char const word_beg_no_bk[] = "(^|[^[:alnum:]_])(";
      static char const word_end_no_bk[] = ")([^[:alnum:]_]|$)";
      static char const line_beg_bk[] = "^\\(";
      static char const line_end_bk[] = "\\)$";
      static char const word_beg_bk[] = "\\(^\\|[^[:alnum:]_]\\)\\(";
      static char const word_end_bk[] = "\\)\\([^[:alnum:]_]\\|$\\)";
      int bk = !(syntax_bits & RE_NO_BK_PARENS);
      char *n = xmalloc (sizeof word_beg_bk - 1 + size + sizeof word_end_bk);

      strcpy (n, match_lines ? (bk ? line_beg_bk : line_beg_no_bk)
			     : (bk ? word_beg_bk : word_beg_no_bk));
      total = strlen(n);
      memcpy (n + total, pattern, size);
      total += size;
      strcpy (n + total, match_lines ? (bk ? line_end_bk : line_end_no_bk)
				     : (bk ? word_end_bk : word_end_no_bk));
      total += strlen (n + total);
      pattern = motif = n;
      size = total;
    }
  else
    motif = NULL;

  dfacomp (pattern, size, &dfa, 1);
  kwsmusts ();

  free(motif);
}

size_t
EGexecute (char const *buf, size_t size, size_t *match_size,
	   char const *start_ptr)
{
  char const *buflim, *beg, *end, *match, *best_match, *mb_start;
  char eol = eolbyte;
  int backref, start, len, best_len;
  struct kwsmatch kwsm;
  size_t i, ret_val;
#ifdef MBS_SUPPORT
  if (MB_CUR_MAX > 1)
    {
      if (match_icase)
        {
          /* mbtolower adds a NUL byte at the end.  That will provide
	     space for the sentinel byte dfaexec may add.  */
          char *case_buf = mbtolower (buf, &size);
	  if (start_ptr)
	    start_ptr = case_buf + (start_ptr - buf);
          buf = case_buf;
        }
    }
#endif /* MBS_SUPPORT */

  mb_start = buf;
  buflim = buf + size;

  for (beg = end = buf; end < buflim; beg = end)
    {
      if (!start_ptr)
	{
	  /* We don't care about an exact match.  */
	  if (kwset)
	    {
	      /* Find a possible match using the KWset matcher. */
	      size_t offset = kwsexec (kwset, beg, buflim - beg, &kwsm);
	      if (offset == (size_t) -1)
		goto failure;
	      beg += offset;
	      /* Narrow down to the line containing the candidate, and
		 run it through DFA. */
	      if ((end = memchr(beg, eol, buflim - beg)) != NULL)
	        end++;
              else
                end = buflim;
	      match = beg;
	      while (beg > buf && beg[-1] != eol)
		--beg;
	      if (kwsm.index < kwset_exact_matches)
                {
#ifdef MBS_SUPPORT
                  if (mb_start < beg)
                    mb_start = beg;
                  if (MB_CUR_MAX == 1 || !is_mb_middle (&mb_start, match, buflim))
#endif
                    goto success;
                }
	      if (dfaexec (&dfa, beg, (char *) end, 0, NULL, &backref) == NULL)
		continue;
	    }
	  else
	    {
	      /* No good fixed strings; start with DFA. */
	      char const *next_beg = dfaexec (&dfa, beg, (char *) buflim,
					      0, NULL, &backref);
	      if (next_beg == NULL)
		break;
	      /* Narrow down to the line we've found. */
	      beg = next_beg;
	      if ((end = memchr(beg, eol, buflim - beg)) != NULL)
	        end++;
              else
                end = buflim;
	      while (beg > buf && beg[-1] != eol)
		--beg;
	    }
	  /* Successful, no backreferences encountered! */
	  if (!backref)
	    goto success;
	}
      else
	{
	  /* We are looking for the leftmost (then longest) exact match.
	     We will go through the outer loop only once.  */
	  beg = start_ptr;
	  end = buflim;
	}

      /* If we've made it to this point, this means DFA has seen
	 a probable match, and we need to run it through Regex. */
      best_match = end;
      best_len = 0;
      for (i = 0; i < pcount; i++)
	{
	  patterns[i].regexbuf.not_eol = 0;
	  if (0 <= (start = re_search (&(patterns[i].regexbuf),
				       buf, end - buf - 1,
				       beg - buf, end - beg - 1,
				       &(patterns[i].regs))))
	    {
	      len = patterns[i].regs.end[0] - start;
	      match = buf + start;
	      
//Patch 0:
if ((match > best_match) && !(__is_neg(25, &(match), sizeof (match), &(best_match), sizeof (best_match), &(buf), sizeof (buf), &(start), sizeof (start), &(start_ptr), sizeof (start_ptr), &(len), sizeof (len), &(i), sizeof (i), &(match_words), sizeof (match_words), &(patterns), sizeof (patterns), &(match_lines), sizeof (match_lines), &(beg), sizeof (beg), &(end), sizeof (end), &(pcount), sizeof (pcount), &(best_len), sizeof (best_len), &(buflim), sizeof (buflim), &(backref), sizeof (backref), &(eol), sizeof (eol), &(mb_start), sizeof (mb_start), &(kwset_exact_matches), sizeof (kwset_exact_matches), &(kwset), sizeof (kwset), &(size), sizeof (size), &(ret_val), sizeof (ret_val), &(match_size), sizeof (match_size), &(match_icase), sizeof (match_icase), &(eolbyte), sizeof (eolbyte))))
    continue;

//CodeSeg 1:
	      if (start_ptr && !match_words)
		goto assess_pattern_match;
	      if ((!match_lines && !match_words)
		  || (match_lines && len == end - beg - 1))
		{
		  match = beg;
		  len = end - beg;
		  goto assess_pattern_match;
		}
	      /* If -w, check if the match aligns with word boundaries.
		 We do this iteratively because:
		 (a) the line may contain more than one occurence of the
		 pattern, and
		 (b) Several alternatives in the pattern might be valid at a
		 given point, and we may need to consider a shorter one to
		 find a word boundary.  */
	      if (match_words)
		while (match <= best_match)
		  {
		    if ((match == buf || !WCHAR ((unsigned char) match[-1]))
			&& (len == end - beg - 1
			    || !WCHAR ((unsigned char) match[len])))
		      goto assess_pattern_match;
		    if (len > 0)
		      {
			/* Try a shorter length anchored at the same place. */
			--len;
			patterns[i].regexbuf.not_eol = 1;
			len = re_match (&(patterns[i].regexbuf),
					buf, match + len - beg, match - buf,
					&(patterns[i].regs));
		      }
		    if (len <= 0)
		      {
			/* Try looking further on. */
			if (match == end - 1)
			  break;
			match++;
			patterns[i].regexbuf.not_eol = 0;
			start = re_search (&(patterns[i].regexbuf),
					   buf, end - buf - 1,
					   match - buf, end - match - 1,
					   &(patterns[i].regs));
			if (start < 0)
			  break;
			len = patterns[i].regs.end[0] - start;
			match = buf + start;
		      }
		  } /* while (match <= best_match) */
	      continue;
	    assess_pattern_match:
	      if (!start_ptr)
		{
		  /* Good enough for a non-exact match.
		     No need to look at further patterns, if any.  */
		  beg = match;
		  goto success_in_len;
		}
	      if (match < best_match || (match == best_match && len > best_len))
		{
		  /* Best exact match:  leftmost, then longest.  */
		  best_match = match;
		  best_len = len;
		}
	    } /* if re_search >= 0 */
	} /* for Regex patterns.  */
	if (best_match < end)
	  {
	    /* We have found an exact match.  We were just
	       waiting for the best one (leftmost then longest).  */
	    beg = best_match;
	    len = best_len;
	    goto success_in_len;
	  }
    } /* for (beg = end ..) */

 failure:
  ret_val = -1;
  goto out;

 success:
  len = end - beg;
 success_in_len:
  *match_size = len;
  ret_val = beg - buf;
 out:
  return ret_val;
}

Testing negative cases!
Testing 0 (with abstract condition) ENVIS_NEG
Iteration 0
Running test command:
/home/ubuntu/spr-fast/tools/grep-test.py /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-8a025cf8-8f08d8e2/tempworkdir-l/src /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-8a025cf8-8f08d8e2/tempworkdir-l/tests /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-8a025cf8-8f08d8e2/tempworkdir-l 0  > __res
Opening:/tmp/neg.tmp!
NegativeBRANCH RECORD/tmp/neg.tmp!
Not caught by the negative case, give up!
APPENDING TO ISNEG:/tmp/neg.tmp!
Running test command:
/home/ubuntu/spr-fast/tools/grep-test.py /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-8a025cf8-8f08d8e2/tempworkdir-l/src /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-8a025cf8-8f08d8e2/tempworkdir-l/tests /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-8a025cf8-8f08d8e2/tempworkdir-l 0  > __res
CondTester, Testing instance id 27:
//src_file:src/dfasearch.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); void* memset(void*, int, unsigned long); 
/* dfasearch.c - searching subroutines using dfa and regex for grep.
   Copyright 1992, 1998, 2000, 2007, 2009-2010 Free Software Foundation, Inc.

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 3, or (at your option)
   any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program; if not, write to the Free Software
   Foundation, Inc., 51 Franklin Street - Fifth Floor, Boston, MA
   02110-1301, USA.  */

/* Written August 1992 by Mike Haertel. */

#include <config.h>
#include "search.h"
#include "dfa.h"

/* For -w, we also consider _ to be word constituent.  */
#define WCHAR(C) (ISALNUM(C) || (C) == '_')

/* KWset compiled pattern.  For Ecompile and Gcompile, we compile
   a list of strings, at least one of which is known to occur in
   any string matching the regexp. */
static kwset_t kwset;

/* DFA compiled regexp. */
static struct dfa dfa;

/* The Regex compiled patterns.  */
static struct patterns
{
  /* Regex compiled regexp. */
  struct re_pattern_buffer regexbuf;
  struct re_registers regs; /* This is here on account of a BRAIN-DEAD
			       Q@#%!# library interface in regex.c.  */
} patterns0;

struct patterns *patterns;
size_t pcount;

void
dfaerror (char const *mesg)
{
  error (EXIT_TROUBLE, 0, "%s", mesg);

  /* notreached */
  /* Tell static analyzers that this function does not return.  */
  abort ();
}

/* Number of compiled fixed strings known to exactly match the regexp.
   If kwsexec returns < kwset_exact_matches, then we don't need to
   call the regexp matcher at all. */
static int kwset_exact_matches;

static char const *
kwsincr_case (const char *must)
{
  const char *buf;
  size_t n;

  n = strlen (must);
#ifdef MBS_SUPPORT
  if (match_icase && MB_CUR_MAX > 1)
    buf = mbtolower (must, &n);
  else
#endif
    buf = must;
  return kwsincr (kwset, buf, n);
}

/* If the DFA turns out to have some set of fixed strings one of
   which must occur in the match, then we build a kwset matcher
   to find those strings, and thus quickly filter out impossible
   matches. */
static void
kwsmusts (void)
{
  struct dfamust const *dm;
  char const *err;

  if (dfa.musts)
    {
      kwsinit (&kwset);
      /* First, we compile in the substrings known to be exact
	 matches.  The kwset matcher will return the index
	 of the matching string that it chooses. */
      for (dm = dfa.musts; dm; dm = dm->next)
	{
	  if (!dm->exact)
	    continue;
	  ++kwset_exact_matches;
	  if ((err = kwsincr_case (dm->must)) != NULL)
	    error (EXIT_TROUBLE, 0, "%s", err);
	}
      /* Now, we compile the substrings that will require
	 the use of the regexp matcher.  */
      for (dm = dfa.musts; dm; dm = dm->next)
	{
	  if (dm->exact)
	    continue;
	  if ((err = kwsincr_case (dm->must)) != NULL)
	    error (EXIT_TROUBLE, 0, "%s", err);
	}
      if ((err = kwsprep (kwset)) != NULL)
	error (EXIT_TROUBLE, 0, "%s", err);
    }
}

void
GEAcompile (char const *pattern, size_t size, reg_syntax_t syntax_bits)
{
  const char *err;
  const char *p, *sep;
  size_t total = size;
  char *motif;

  if (match_icase)
    syntax_bits |= RE_ICASE;
  re_set_syntax (syntax_bits);
  dfasyntax (syntax_bits, match_icase, eolbyte);

  /* For GNU regex compiler we have to pass the patterns separately to detect
     errors like "[\nallo\n]\n".  The patterns here are "[", "allo" and "]"
     GNU regex should have raise a syntax error.  The same for backref, where
     the backref should have been local to each pattern.  */
  p = pattern;
  do
    {
      size_t len;
      sep = memchr (p, '\n', total);
      if (sep)
	{
	  len = sep - p;
	  sep++;
	  total -= (len + 1);
	}
      else
	{
	  len = total;
	  total = 0;
	}

      patterns = realloc (patterns, (pcount + 1) * sizeof (*patterns));
      if (patterns == NULL)
	error (EXIT_TROUBLE, errno, _("memory exhausted"));
      patterns[pcount] = patterns0;

      if ((err = re_compile_pattern (p, len,
				    &(patterns[pcount].regexbuf))) != NULL)
	error (EXIT_TROUBLE, 0, "%s", err);
      pcount++;

      p = sep;
    } while (sep && total != 0);

  /* In the match_words and match_lines cases, we use a different pattern
     for the DFA matcher that will quickly throw out cases that won't work.
     Then if DFA succeeds we do some hairy stuff using the regex matcher
     to decide whether the match should really count. */
  if (match_words || match_lines)
    {
      static char const line_beg_no_bk[] = "^(";
      static char const line_end_no_bk[] = ")$";
      static char const word_beg_no_bk[] = "(^|[^[:alnum:]_])(";
      static char const word_end_no_bk[] = ")([^[:alnum:]_]|$)";
      static char const line_beg_bk[] = "^\\(";
      static char const line_end_bk[] = "\\)$";
      static char const word_beg_bk[] = "\\(^\\|[^[:alnum:]_]\\)\\(";
      static char const word_end_bk[] = "\\)\\([^[:alnum:]_]\\|$\\)";
      int bk = !(syntax_bits & RE_NO_BK_PARENS);
      char *n = xmalloc (sizeof word_beg_bk - 1 + size + sizeof word_end_bk);

      strcpy (n, match_lines ? (bk ? line_beg_bk : line_beg_no_bk)
			     : (bk ? word_beg_bk : word_beg_no_bk));
      total = strlen(n);
      memcpy (n + total, pattern, size);
      total += size;
      strcpy (n + total, match_lines ? (bk ? line_end_bk : line_end_no_bk)
				     : (bk ? word_end_bk : word_end_no_bk));
      total += strlen (n + total);
      pattern = motif = n;
      size = total;
    }
  else
    motif = NULL;

  dfacomp (pattern, size, &dfa, 1);
  kwsmusts ();

  free(motif);
}

size_t
EGexecute (char const *buf, size_t size, size_t *match_size,
	   char const *start_ptr)
{
  char const *buflim, *beg, *end, *match, *best_match, *mb_start;
  char eol = eolbyte;
  int backref, start, len, best_len;
  struct kwsmatch kwsm;
  size_t i, ret_val;
#ifdef MBS_SUPPORT
  if (MB_CUR_MAX > 1)
    {
      if (match_icase)
        {
          /* mbtolower adds a NUL byte at the end.  That will provide
	     space for the sentinel byte dfaexec may add.  */
          char *case_buf = mbtolower (buf, &size);
	  if (start_ptr)
	    start_ptr = case_buf + (start_ptr - buf);
          buf = case_buf;
        }
    }
#endif /* MBS_SUPPORT */

  mb_start = buf;
  buflim = buf + size;

  for (beg = end = buf; end < buflim; beg = end)
    {
      if (!start_ptr)
	{
	  /* We don't care about an exact match.  */
	  if (kwset)
	    {
	      /* Find a possible match using the KWset matcher. */
	      size_t offset = kwsexec (kwset, beg, buflim - beg, &kwsm);
	      if (offset == (size_t) -1)
		goto failure;
	      beg += offset;
	      /* Narrow down to the line containing the candidate, and
		 run it through DFA. */
	      if ((end = memchr(beg, eol, buflim - beg)) != NULL)
	        end++;
              else
                end = buflim;
	      match = beg;
	      while (beg > buf && beg[-1] != eol)
		--beg;
	      if (kwsm.index < kwset_exact_matches)
                {
#ifdef MBS_SUPPORT
                  if (mb_start < beg)
                    mb_start = beg;
                  if (MB_CUR_MAX == 1 || !is_mb_middle (&mb_start, match, buflim))
#endif
                    goto success;
                }
	      if (dfaexec (&dfa, beg, (char *) end, 0, NULL, &backref) == NULL)
		continue;
	    }
	  else
	    {
	      /* No good fixed strings; start with DFA. */
	      char const *next_beg = dfaexec (&dfa, beg, (char *) buflim,
					      0, NULL, &backref);
	      if (next_beg == NULL)
		break;
	      /* Narrow down to the line we've found. */
	      beg = next_beg;
	      if ((end = memchr(beg, eol, buflim - beg)) != NULL)
	        end++;
              else
                end = buflim;
	      while (beg > buf && beg[-1] != eol)
		--beg;
	    }
	  /* Successful, no backreferences encountered! */
	  if (!backref)
	    goto success;
	}
      else
	{
	  /* We are looking for the leftmost (then longest) exact match.
	     We will go through the outer loop only once.  */
	  beg = start_ptr;
	  end = buflim;
	}

      /* If we've made it to this point, this means DFA has seen
	 a probable match, and we need to run it through Regex. */
      best_match = end;
      best_len = 0;
      for (i = 0; i < pcount; i++)
	{
	  patterns[i].regexbuf.not_eol = 0;
	  if (0 <= (start = re_search (&(patterns[i].regexbuf),
				       buf, end - buf - 1,
				       beg - buf, end - beg - 1,
				       &(patterns[i].regs))))
	    {
	      len = patterns[i].regs.end[0] - start;
	      match = buf + start;
	      
//Patch 0:
if ((match > best_match) || (__is_neg(25, &(match), sizeof (match), &(best_match), sizeof (best_match), &(buf), sizeof (buf), &(start), sizeof (start), &(start_ptr), sizeof (start_ptr), &(len), sizeof (len), &(i), sizeof (i), &(match_words), sizeof (match_words), &(patterns), sizeof (patterns), &(match_lines), sizeof (match_lines), &(beg), sizeof (beg), &(end), sizeof (end), &(pcount), sizeof (pcount), &(best_len), sizeof (best_len), &(buflim), sizeof (buflim), &(backref), sizeof (backref), &(eol), sizeof (eol), &(mb_start), sizeof (mb_start), &(kwset_exact_matches), sizeof (kwset_exact_matches), &(kwset), sizeof (kwset), &(size), sizeof (size), &(ret_val), sizeof (ret_val), &(match_size), sizeof (match_size), &(match_icase), sizeof (match_icase), &(eolbyte), sizeof (eolbyte))))
    continue;

//CodeSeg 1:
	      if (start_ptr && !match_words)
		goto assess_pattern_match;
	      if ((!match_lines && !match_words)
		  || (match_lines && len == end - beg - 1))
		{
		  match = beg;
		  len = end - beg;
		  goto assess_pattern_match;
		}
	      /* If -w, check if the match aligns with word boundaries.
		 We do this iteratively because:
		 (a) the line may contain more than one occurence of the
		 pattern, and
		 (b) Several alternatives in the pattern might be valid at a
		 given point, and we may need to consider a shorter one to
		 find a word boundary.  */
	      if (match_words)
		while (match <= best_match)
		  {
		    if ((match == buf || !WCHAR ((unsigned char) match[-1]))
			&& (len == end - beg - 1
			    || !WCHAR ((unsigned char) match[len])))
		      goto assess_pattern_match;
		    if (len > 0)
		      {
			/* Try a shorter length anchored at the same place. */
			--len;
			patterns[i].regexbuf.not_eol = 1;
			len = re_match (&(patterns[i].regexbuf),
					buf, match + len - beg, match - buf,
					&(patterns[i].regs));
		      }
		    if (len <= 0)
		      {
			/* Try looking further on. */
			if (match == end - 1)
			  break;
			match++;
			patterns[i].regexbuf.not_eol = 0;
			start = re_search (&(patterns[i].regexbuf),
					   buf, end - buf - 1,
					   match - buf, end - match - 1,
					   &(patterns[i].regs));
			if (start < 0)
			  break;
			len = patterns[i].regs.end[0] - start;
			match = buf + start;
		      }
		  } /* while (match <= best_match) */
	      continue;
	    assess_pattern_match:
	      if (!start_ptr)
		{
		  /* Good enough for a non-exact match.
		     No need to look at further patterns, if any.  */
		  beg = match;
		  goto success_in_len;
		}
	      if (match < best_match || (match == best_match && len > best_len))
		{
		  /* Best exact match:  leftmost, then longest.  */
		  best_match = match;
		  best_len = len;
		}
	    } /* if re_search >= 0 */
	} /* for Regex patterns.  */
	if (best_match < end)
	  {
	    /* We have found an exact match.  We were just
	       waiting for the best one (leftmost then longest).  */
	    beg = best_match;
	    len = best_len;
	    goto success_in_len;
	  }
    } /* for (beg = end ..) */

 failure:
  ret_val = -1;
  goto out;

 success:
  len = end - beg;
 success_in_len:
  *match_size = len;
  ret_val = beg - buf;
 out:
  return ret_val;
}

Testing negative cases!
Testing 0 (with abstract condition) ENVIS_NEG
Iteration 0
Running test command:
/home/ubuntu/spr-fast/tools/grep-test.py /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-8a025cf8-8f08d8e2/tempworkdir-l/src /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-8a025cf8-8f08d8e2/tempworkdir-l/tests /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-8a025cf8-8f08d8e2/tempworkdir-l 0  > __res
Opening:/tmp/neg.tmp!
NegativeBRANCH RECORD/tmp/neg.tmp!
APPENDING TO ISNEG:/tmp/neg.tmp!
Branch 0: 0
Iteration 1
Running test command:
/home/ubuntu/spr-fast/tools/grep-test.py /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-8a025cf8-8f08d8e2/tempworkdir-l/src /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-8a025cf8-8f08d8e2/tempworkdir-l/tests /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-8a025cf8-8f08d8e2/tempworkdir-l 0  > __res
Opening:/tmp/neg.tmp!
NegativeBRANCH RECORD/tmp/neg.tmp!
APPENDING TO ISNEG:/tmp/neg.tmp!
Branch 0: 1
Running test command:
/home/ubuntu/spr-fast/tools/grep-test.py /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-8a025cf8-8f08d8e2/tempworkdir-l/src /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-8a025cf8-8f08d8e2/tempworkdir-l/tests /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-8a025cf8-8f08d8e2/tempworkdir-l 0  > __res
a batched test job starts!
Building merged code:
src_file: src/dfasearch.c
full src: int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); void* memset(void*, int, unsigned long); 
/* dfasearch.c - searching subroutines using dfa and regex for grep.
   Copyright 1992, 1998, 2000, 2007, 2009-2010 Free Software Foundation, Inc.

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 3, or (at your option)
   any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program; if not, write to the Free Software
   Foundation, Inc., 51 Franklin Street - Fifth Floor, Boston, MA
   02110-1301, USA.  */

/* Written August 1992 by Mike Haertel. */

#include <config.h>
#include "search.h"
#include "dfa.h"

/* For -w, we also consider _ to be word constituent.  */
#define WCHAR(C) (ISALNUM(C) || (C) == '_')

/* KWset compiled pattern.  For Ecompile and Gcompile, we compile
   a list of strings, at least one of which is known to occur in
   any string matching the regexp. */
static kwset_t kwset;

/* DFA compiled regexp. */
static struct dfa dfa;

/* The Regex compiled patterns.  */
static struct patterns
{
  /* Regex compiled regexp. */
  struct re_pattern_buffer regexbuf;
  struct re_registers regs; /* This is here on account of a BRAIN-DEAD
			       Q@#%!# library interface in regex.c.  */
} patterns0;

struct patterns *patterns;
size_t pcount;

void
dfaerror (char const *mesg)
{
  error (EXIT_TROUBLE, 0, "%s", mesg);

  /* notreached */
  /* Tell static analyzers that this function does not return.  */
  abort ();
}

/* Number of compiled fixed strings known to exactly match the regexp.
   If kwsexec returns < kwset_exact_matches, then we don't need to
   call the regexp matcher at all. */
static int kwset_exact_matches;

static char const *
kwsincr_case (const char *must)
{
  const char *buf;
  size_t n;

  n = strlen (must);
#ifdef MBS_SUPPORT
  if (match_icase && MB_CUR_MAX > 1)
    buf = mbtolower (must, &n);
  else
#endif
    buf = must;
  return kwsincr (kwset, buf, n);
}

/* If the DFA turns out to have some set of fixed strings one of
   which must occur in the match, then we build a kwset matcher
   to find those strings, and thus quickly filter out impossible
   matches. */
static void
kwsmusts (void)
{
  struct dfamust const *dm;
  char const *err;

  if (dfa.musts)
    {
      kwsinit (&kwset);
      /* First, we compile in the substrings known to be exact
	 matches.  The kwset matcher will return the index
	 of the matching string that it chooses. */
      for (dm = dfa.musts; dm; dm = dm->next)
	{
	  if (!dm->exact)
	    continue;
	  ++kwset_exact_matches;
	  if ((err = kwsincr_case (dm->must)) != NULL)
	    error (EXIT_TROUBLE, 0, "%s", err);
	}
      /* Now, we compile the substrings that will require
	 the use of the regexp matcher.  */
      for (dm = dfa.musts; dm; dm = dm->next)
	{
	  if (dm->exact)
	    continue;
	  if ((err = kwsincr_case (dm->must)) != NULL)
	    error (EXIT_TROUBLE, 0, "%s", err);
	}
      if ((err = kwsprep (kwset)) != NULL)
	error (EXIT_TROUBLE, 0, "%s", err);
    }
}

void
GEAcompile (char const *pattern, size_t size, reg_syntax_t syntax_bits)
{
  const char *err;
  const char *p, *sep;
  size_t total = size;
  char *motif;

  if (match_icase)
    syntax_bits |= RE_ICASE;
  re_set_syntax (syntax_bits);
  dfasyntax (syntax_bits, match_icase, eolbyte);

  /* For GNU regex compiler we have to pass the patterns separately to detect
     errors like "[\nallo\n]\n".  The patterns here are "[", "allo" and "]"
     GNU regex should have raise a syntax error.  The same for backref, where
     the backref should have been local to each pattern.  */
  p = pattern;
  do
    {
      size_t len;
      sep = memchr (p, '\n', total);
      if (sep)
	{
	  len = sep - p;
	  sep++;
	  total -= (len + 1);
	}
      else
	{
	  len = total;
	  total = 0;
	}

      patterns = realloc (patterns, (pcount + 1) * sizeof (*patterns));
      if (patterns == NULL)
	error (EXIT_TROUBLE, errno, _("memory exhausted"));
      patterns[pcount] = patterns0;

      if ((err = re_compile_pattern (p, len,
				    &(patterns[pcount].regexbuf))) != NULL)
	error (EXIT_TROUBLE, 0, "%s", err);
      pcount++;

      p = sep;
    } while (sep && total != 0);

  /* In the match_words and match_lines cases, we use a different pattern
     for the DFA matcher that will quickly throw out cases that won't work.
     Then if DFA succeeds we do some hairy stuff using the regex matcher
     to decide whether the match should really count. */
  if (match_words || match_lines)
    {
      static char const line_beg_no_bk[] = "^(";
      static char const line_end_no_bk[] = ")$";
      static char const word_beg_no_bk[] = "(^|[^[:alnum:]_])(";
      static char const word_end_no_bk[] = ")([^[:alnum:]_]|$)";
      static char const line_beg_bk[] = "^\\(";
      static char const line_end_bk[] = "\\)$";
      static char const word_beg_bk[] = "\\(^\\|[^[:alnum:]_]\\)\\(";
      static char const word_end_bk[] = "\\)\\([^[:alnum:]_]\\|$\\)";
      int bk = !(syntax_bits & RE_NO_BK_PARENS);
      char *n = xmalloc (sizeof word_beg_bk - 1 + size + sizeof word_end_bk);

      strcpy (n, match_lines ? (bk ? line_beg_bk : line_beg_no_bk)
			     : (bk ? word_beg_bk : word_beg_no_bk));
      total = strlen(n);
      memcpy (n + total, pattern, size);
      total += size;
      strcpy (n + total, match_lines ? (bk ? line_end_bk : line_end_no_bk)
				     : (bk ? word_end_bk : word_end_no_bk));
      total += strlen (n + total);
      pattern = motif = n;
      size = total;
    }
  else
    motif = NULL;

  dfacomp (pattern, size, &dfa, 1);
  kwsmusts ();

  free(motif);
}

size_t
EGexecute (char const *buf, size_t size, size_t *match_size,
	   char const *start_ptr)
{
  char const *buflim, *beg, *end, *match, *best_match, *mb_start;
  char eol = eolbyte;
  int backref, start, len, best_len;
  struct kwsmatch kwsm;
  size_t i, ret_val;
#ifdef MBS_SUPPORT
  if (MB_CUR_MAX > 1)
    {
      if (match_icase)
        {
          /* mbtolower adds a NUL byte at the end.  That will provide
	     space for the sentinel byte dfaexec may add.  */
          char *case_buf = mbtolower (buf, &size);
	  if (start_ptr)
	    start_ptr = case_buf + (start_ptr - buf);
          buf = case_buf;
        }
    }
#endif /* MBS_SUPPORT */

  mb_start = buf;
  buflim = buf + size;

  for (beg = end = buf; end < buflim; beg = end)
    {
      if (!start_ptr)
	{
	  /* We don't care about an exact match.  */
	  if (kwset)
	    {
	      /* Find a possible match using the KWset matcher. */
	      size_t offset = kwsexec (kwset, beg, buflim - beg, &kwsm);
	      if (offset == (size_t) -1)
		goto failure;
	      beg += offset;
	      /* Narrow down to the line containing the candidate, and
		 run it through DFA. */
	      if ((end = memchr(beg, eol, buflim - beg)) != NULL)
	        end++;
              else
                end = buflim;
	      match = beg;
	      while (beg > buf && beg[-1] != eol)
		--beg;
	      if (kwsm.index < kwset_exact_matches)
                {
#ifdef MBS_SUPPORT
                  if (mb_start < beg)
                    mb_start = beg;
                  if (MB_CUR_MAX == 1 || !is_mb_middle (&mb_start, match, buflim))
#endif
                    goto success;
                }
	      if (dfaexec (&dfa, beg, (char *) end, 0, NULL, &backref) == NULL)
		continue;
	    }
	  else
	    {
	      /* No good fixed strings; start with DFA. */
	      char const *next_beg = dfaexec (&dfa, beg, (char *) buflim,
					      0, NULL, &backref);
	      if (next_beg == NULL)
		break;
	      /* Narrow down to the line we've found. */
	      beg = next_beg;
	      if ((end = memchr(beg, eol, buflim - beg)) != NULL)
	        end++;
              else
                end = buflim;
	      while (beg > buf && beg[-1] != eol)
		--beg;
	    }
	  /* Successful, no backreferences encountered! */
	  if (!backref)
	    goto success;
	}
      else
	{
	  /* We are looking for the leftmost (then longest) exact match.
	     We will go through the outer loop only once.  */
	  beg = start_ptr;
	  end = buflim;
	}

      /* If we've made it to this point, this means DFA has seen
	 a probable match, and we need to run it through Regex. */
      best_match = end;
      best_len = 0;
      for (i = 0; i < pcount; i++)
	{
	  patterns[i].regexbuf.not_eol = 0;
	  if (0 <= (start = re_search (&(patterns[i].regexbuf),
				       buf, end - buf - 1,
				       beg - buf, end - beg - 1,
				       &(patterns[i].regs))))
	    {
	      len = patterns[i].regs.end[0] - start;
	      match = buf + start;
	      if (match > best_match)
		continue;
	      //prophet generated patch
	      if (__get_mutant()==0) {
	      if ((start_ptr && !match_words) && !(__is_neg(25, &(start_ptr), sizeof (start_ptr), &(match_words), sizeof (match_words), &(match), sizeof (match), &(best_match), sizeof (best_match), &(match_lines), sizeof (match_lines), &(buf), sizeof (buf), &(beg), sizeof (beg), &(end), sizeof (end), &(start), sizeof (start), &(len), sizeof (len), &(i), sizeof (i), &(patterns), sizeof (patterns), &(pcount), sizeof (pcount), &(best_len), sizeof (best_len), &(buflim), sizeof (buflim), &(backref), sizeof (backref), &(eol), sizeof (eol), &(mb_start), sizeof (mb_start), &(kwset_exact_matches), sizeof (kwset_exact_matches), &(kwset), sizeof (kwset), &(ret_val), sizeof (ret_val), &(size), sizeof (size), &(match_size), sizeof (match_size), &(match_icase), sizeof (match_icase), &(eolbyte), sizeof (eolbyte))))
	          goto assess_pattern_match;
	      }
	      else if (__get_mutant()==1) {
	      if ((start_ptr && !match_words) || (__is_neg(25, &(start_ptr), sizeof (start_ptr), &(match_words), sizeof (match_words), &(match), sizeof (match), &(best_match), sizeof (best_match), &(match_lines), sizeof (match_lines), &(buf), sizeof (buf), &(beg), sizeof (beg), &(end), sizeof (end), &(start), sizeof (start), &(len), sizeof (len), &(i), sizeof (i), &(patterns), sizeof (patterns), &(pcount), sizeof (pcount), &(best_len), sizeof (best_len), &(buflim), sizeof (buflim), &(backref), sizeof (backref), &(eol), sizeof (eol), &(mb_start), sizeof (mb_start), &(kwset_exact_matches), sizeof (kwset_exact_matches), &(kwset), sizeof (kwset), &(ret_val), sizeof (ret_val), &(size), sizeof (size), &(match_size), sizeof (match_size), &(match_icase), sizeof (match_icase), &(eolbyte), sizeof (eolbyte))))
	          goto assess_pattern_match;
	      }
	      else if (__get_mutant()==2) {
	      if (((start_ptr) || (__is_neg(25, &(start_ptr), sizeof (start_ptr), &(match_words), sizeof (match_words), &(match), sizeof (match), &(best_match), sizeof (best_match), &(match_lines), sizeof (match_lines), &(buf), sizeof (buf), &(beg), sizeof (beg), &(end), sizeof (end), &(start), sizeof (start), &(len), sizeof (len), &(i), sizeof (i), &(patterns), sizeof (patterns), &(pcount), sizeof (pcount), &(best_len), sizeof (best_len), &(buflim), sizeof (buflim), &(backref), sizeof (backref), &(eol), sizeof (eol), &(mb_start), sizeof (mb_start), &(kwset_exact_matches), sizeof (kwset_exact_matches), &(kwset), sizeof (kwset), &(ret_val), sizeof (ret_val), &(size), sizeof (size), &(match_size), sizeof (match_size), &(match_icase), sizeof (match_icase), &(eolbyte), sizeof (eolbyte)))) && !match_words)
	          goto assess_pattern_match;
	      }
	      if ((!match_lines && !match_words)
		  || (match_lines && len == end - beg - 1))
		{
		  match = beg;
		  len = end - beg;
		  goto assess_pattern_match;
		}
	      /* If -w, check if the match aligns with word boundaries.
		 We do this iteratively because:
		 (a) the line may contain more than one occurence of the
		 pattern, and
		 (b) Several alternatives in the pattern might be valid at a
		 given point, and we may need to consider a shorter one to
		 find a word boundary.  */
	      if (match_words)
		while (match <= best_match)
		  {
		    if ((match == buf || !WCHAR ((unsigned char) match[-1]))
			&& (len == end - beg - 1
			    || !WCHAR ((unsigned char) match[len])))
		      goto assess_pattern_match;
		    if (len > 0)
		      {
			/* Try a shorter length anchored at the same place. */
			--len;
			patterns[i].regexbuf.not_eol = 1;
			len = re_match (&(patterns[i].regexbuf),
					buf, match + len - beg, match - buf,
					&(patterns[i].regs));
		      }
		    if (len <= 0)
		      {
			/* Try looking further on. */
			if (match == end - 1)
			  break;
			match++;
			patterns[i].regexbuf.not_eol = 0;
			start = re_search (&(patterns[i].regexbuf),
					   buf, end - buf - 1,
					   match - buf, end - match - 1,
					   &(patterns[i].regs));
			if (start < 0)
			  break;
			len = patterns[i].regs.end[0] - start;
			match = buf + start;
		      }
		  } /* while (match <= best_match) */
	      continue;
	    assess_pattern_match:
	      if (!start_ptr)
		{
		  /* Good enough for a non-exact match.
		     No need to look at further patterns, if any.  */
		  beg = match;
		  goto success_in_len;
		}
	      if (match < best_match || (match == best_match && len > best_len))
		{
		  /* Best exact match:  leftmost, then longest.  */
		  best_match = match;
		  best_len = len;
		}
	    } /* if re_search >= 0 */
	} /* for Regex patterns.  */
	if (best_match < end)
	  {
	    /* We have found an exact match.  We were just
	       waiting for the best one (leftmost then longest).  */
	    beg = best_match;
	    len = best_len;
	    goto success_in_len;
	  }
    } /* for (beg = end ..) */

 failure:
  ret_val = -1;
  goto out;

 success:
  len = end - beg;
 success_in_len:
  *match_size = len;
  ret_val = beg - buf;
 out:
  return ret_val;
}

Building:src at:
/home/ubuntu/spr-fast/tests/corebench/grep/grep-case-8a025cf8-8f08d8e2/tempworkdir-l/srcMerged code building succ, going to invoke tester!
CondTester, Testing instance id 22:
//src_file:src/dfasearch.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); void* memset(void*, int, unsigned long); 
/* dfasearch.c - searching subroutines using dfa and regex for grep.
   Copyright 1992, 1998, 2000, 2007, 2009-2010 Free Software Foundation, Inc.

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 3, or (at your option)
   any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program; if not, write to the Free Software
   Foundation, Inc., 51 Franklin Street - Fifth Floor, Boston, MA
   02110-1301, USA.  */

/* Written August 1992 by Mike Haertel. */

#include <config.h>
#include "search.h"
#include "dfa.h"

/* For -w, we also consider _ to be word constituent.  */
#define WCHAR(C) (ISALNUM(C) || (C) == '_')

/* KWset compiled pattern.  For Ecompile and Gcompile, we compile
   a list of strings, at least one of which is known to occur in
   any string matching the regexp. */
static kwset_t kwset;

/* DFA compiled regexp. */
static struct dfa dfa;

/* The Regex compiled patterns.  */
static struct patterns
{
  /* Regex compiled regexp. */
  struct re_pattern_buffer regexbuf;
  struct re_registers regs; /* This is here on account of a BRAIN-DEAD
			       Q@#%!# library interface in regex.c.  */
} patterns0;

struct patterns *patterns;
size_t pcount;

void
dfaerror (char const *mesg)
{
  error (EXIT_TROUBLE, 0, "%s", mesg);

  /* notreached */
  /* Tell static analyzers that this function does not return.  */
  abort ();
}

/* Number of compiled fixed strings known to exactly match the regexp.
   If kwsexec returns < kwset_exact_matches, then we don't need to
   call the regexp matcher at all. */
static int kwset_exact_matches;

static char const *
kwsincr_case (const char *must)
{
  const char *buf;
  size_t n;

  n = strlen (must);
#ifdef MBS_SUPPORT
  if (match_icase && MB_CUR_MAX > 1)
    buf = mbtolower (must, &n);
  else
#endif
    buf = must;
  return kwsincr (kwset, buf, n);
}

/* If the DFA turns out to have some set of fixed strings one of
   which must occur in the match, then we build a kwset matcher
   to find those strings, and thus quickly filter out impossible
   matches. */
static void
kwsmusts (void)
{
  struct dfamust const *dm;
  char const *err;

  if (dfa.musts)
    {
      kwsinit (&kwset);
      /* First, we compile in the substrings known to be exact
	 matches.  The kwset matcher will return the index
	 of the matching string that it chooses. */
      for (dm = dfa.musts; dm; dm = dm->next)
	{
	  if (!dm->exact)
	    continue;
	  ++kwset_exact_matches;
	  if ((err = kwsincr_case (dm->must)) != NULL)
	    error (EXIT_TROUBLE, 0, "%s", err);
	}
      /* Now, we compile the substrings that will require
	 the use of the regexp matcher.  */
      for (dm = dfa.musts; dm; dm = dm->next)
	{
	  if (dm->exact)
	    continue;
	  if ((err = kwsincr_case (dm->must)) != NULL)
	    error (EXIT_TROUBLE, 0, "%s", err);
	}
      if ((err = kwsprep (kwset)) != NULL)
	error (EXIT_TROUBLE, 0, "%s", err);
    }
}

void
GEAcompile (char const *pattern, size_t size, reg_syntax_t syntax_bits)
{
  const char *err;
  const char *p, *sep;
  size_t total = size;
  char *motif;

  if (match_icase)
    syntax_bits |= RE_ICASE;
  re_set_syntax (syntax_bits);
  dfasyntax (syntax_bits, match_icase, eolbyte);

  /* For GNU regex compiler we have to pass the patterns separately to detect
     errors like "[\nallo\n]\n".  The patterns here are "[", "allo" and "]"
     GNU regex should have raise a syntax error.  The same for backref, where
     the backref should have been local to each pattern.  */
  p = pattern;
  do
    {
      size_t len;
      sep = memchr (p, '\n', total);
      if (sep)
	{
	  len = sep - p;
	  sep++;
	  total -= (len + 1);
	}
      else
	{
	  len = total;
	  total = 0;
	}

      patterns = realloc (patterns, (pcount + 1) * sizeof (*patterns));
      if (patterns == NULL)
	error (EXIT_TROUBLE, errno, _("memory exhausted"));
      patterns[pcount] = patterns0;

      if ((err = re_compile_pattern (p, len,
				    &(patterns[pcount].regexbuf))) != NULL)
	error (EXIT_TROUBLE, 0, "%s", err);
      pcount++;

      p = sep;
    } while (sep && total != 0);

  /* In the match_words and match_lines cases, we use a different pattern
     for the DFA matcher that will quickly throw out cases that won't work.
     Then if DFA succeeds we do some hairy stuff using the regex matcher
     to decide whether the match should really count. */
  if (match_words || match_lines)
    {
      static char const line_beg_no_bk[] = "^(";
      static char const line_end_no_bk[] = ")$";
      static char const word_beg_no_bk[] = "(^|[^[:alnum:]_])(";
      static char const word_end_no_bk[] = ")([^[:alnum:]_]|$)";
      static char const line_beg_bk[] = "^\\(";
      static char const line_end_bk[] = "\\)$";
      static char const word_beg_bk[] = "\\(^\\|[^[:alnum:]_]\\)\\(";
      static char const word_end_bk[] = "\\)\\([^[:alnum:]_]\\|$\\)";
      int bk = !(syntax_bits & RE_NO_BK_PARENS);
      char *n = xmalloc (sizeof word_beg_bk - 1 + size + sizeof word_end_bk);

      strcpy (n, match_lines ? (bk ? line_beg_bk : line_beg_no_bk)
			     : (bk ? word_beg_bk : word_beg_no_bk));
      total = strlen(n);
      memcpy (n + total, pattern, size);
      total += size;
      strcpy (n + total, match_lines ? (bk ? line_end_bk : line_end_no_bk)
				     : (bk ? word_end_bk : word_end_no_bk));
      total += strlen (n + total);
      pattern = motif = n;
      size = total;
    }
  else
    motif = NULL;

  dfacomp (pattern, size, &dfa, 1);
  kwsmusts ();

  free(motif);
}

size_t
EGexecute (char const *buf, size_t size, size_t *match_size,
	   char const *start_ptr)
{
  char const *buflim, *beg, *end, *match, *best_match, *mb_start;
  char eol = eolbyte;
  int backref, start, len, best_len;
  struct kwsmatch kwsm;
  size_t i, ret_val;
#ifdef MBS_SUPPORT
  if (MB_CUR_MAX > 1)
    {
      if (match_icase)
        {
          /* mbtolower adds a NUL byte at the end.  That will provide
	     space for the sentinel byte dfaexec may add.  */
          char *case_buf = mbtolower (buf, &size);
	  if (start_ptr)
	    start_ptr = case_buf + (start_ptr - buf);
          buf = case_buf;
        }
    }
#endif /* MBS_SUPPORT */

  mb_start = buf;
  buflim = buf + size;

  for (beg = end = buf; end < buflim; beg = end)
    {
      if (!start_ptr)
	{
	  /* We don't care about an exact match.  */
	  if (kwset)
	    {
	      /* Find a possible match using the KWset matcher. */
	      size_t offset = kwsexec (kwset, beg, buflim - beg, &kwsm);
	      if (offset == (size_t) -1)
		goto failure;
	      beg += offset;
	      /* Narrow down to the line containing the candidate, and
		 run it through DFA. */
	      if ((end = memchr(beg, eol, buflim - beg)) != NULL)
	        end++;
              else
                end = buflim;
	      match = beg;
	      while (beg > buf && beg[-1] != eol)
		--beg;
	      if (kwsm.index < kwset_exact_matches)
                {
#ifdef MBS_SUPPORT
                  if (mb_start < beg)
                    mb_start = beg;
                  if (MB_CUR_MAX == 1 || !is_mb_middle (&mb_start, match, buflim))
#endif
                    goto success;
                }
	      if (dfaexec (&dfa, beg, (char *) end, 0, NULL, &backref) == NULL)
		continue;
	    }
	  else
	    {
	      /* No good fixed strings; start with DFA. */
	      char const *next_beg = dfaexec (&dfa, beg, (char *) buflim,
					      0, NULL, &backref);
	      if (next_beg == NULL)
		break;
	      /* Narrow down to the line we've found. */
	      beg = next_beg;
	      if ((end = memchr(beg, eol, buflim - beg)) != NULL)
	        end++;
              else
                end = buflim;
	      while (beg > buf && beg[-1] != eol)
		--beg;
	    }
	  /* Successful, no backreferences encountered! */
	  if (!backref)
	    goto success;
	}
      else
	{
	  /* We are looking for the leftmost (then longest) exact match.
	     We will go through the outer loop only once.  */
	  beg = start_ptr;
	  end = buflim;
	}

      /* If we've made it to this point, this means DFA has seen
	 a probable match, and we need to run it through Regex. */
      best_match = end;
      best_len = 0;
      for (i = 0; i < pcount; i++)
	{
	  patterns[i].regexbuf.not_eol = 0;
	  if (0 <= (start = re_search (&(patterns[i].regexbuf),
				       buf, end - buf - 1,
				       beg - buf, end - beg - 1,
				       &(patterns[i].regs))))
	    {
	      len = patterns[i].regs.end[0] - start;
	      match = buf + start;
	      if (match > best_match)
		continue;
	      
//Patch 0:
if ((start_ptr && !match_words) && !(__is_neg(25, &(start_ptr), sizeof (start_ptr), &(match_words), sizeof (match_words), &(match), sizeof (match), &(best_match), sizeof (best_match), &(match_lines), sizeof (match_lines), &(buf), sizeof (buf), &(beg), sizeof (beg), &(end), sizeof (end), &(start), sizeof (start), &(len), sizeof (len), &(i), sizeof (i), &(patterns), sizeof (patterns), &(pcount), sizeof (pcount), &(best_len), sizeof (best_len), &(buflim), sizeof (buflim), &(backref), sizeof (backref), &(eol), sizeof (eol), &(mb_start), sizeof (mb_start), &(kwset_exact_matches), sizeof (kwset_exact_matches), &(kwset), sizeof (kwset), &(ret_val), sizeof (ret_val), &(size), sizeof (size), &(match_size), sizeof (match_size), &(match_icase), sizeof (match_icase), &(eolbyte), sizeof (eolbyte))))
    goto assess_pattern_match;

//CodeSeg 1:
	      if ((!match_lines && !match_words)
		  || (match_lines && len == end - beg - 1))
		{
		  match = beg;
		  len = end - beg;
		  goto assess_pattern_match;
		}
	      /* If -w, check if the match aligns with word boundaries.
		 We do this iteratively because:
		 (a) the line may contain more than one occurence of the
		 pattern, and
		 (b) Several alternatives in the pattern might be valid at a
		 given point, and we may need to consider a shorter one to
		 find a word boundary.  */
	      if (match_words)
		while (match <= best_match)
		  {
		    if ((match == buf || !WCHAR ((unsigned char) match[-1]))
			&& (len == end - beg - 1
			    || !WCHAR ((unsigned char) match[len])))
		      goto assess_pattern_match;
		    if (len > 0)
		      {
			/* Try a shorter length anchored at the same place. */
			--len;
			patterns[i].regexbuf.not_eol = 1;
			len = re_match (&(patterns[i].regexbuf),
					buf, match + len - beg, match - buf,
					&(patterns[i].regs));
		      }
		    if (len <= 0)
		      {
			/* Try looking further on. */
			if (match == end - 1)
			  break;
			match++;
			patterns[i].regexbuf.not_eol = 0;
			start = re_search (&(patterns[i].regexbuf),
					   buf, end - buf - 1,
					   match - buf, end - match - 1,
					   &(patterns[i].regs));
			if (start < 0)
			  break;
			len = patterns[i].regs.end[0] - start;
			match = buf + start;
		      }
		  } /* while (match <= best_match) */
	      continue;
	    assess_pattern_match:
	      if (!start_ptr)
		{
		  /* Good enough for a non-exact match.
		     No need to look at further patterns, if any.  */
		  beg = match;
		  goto success_in_len;
		}
	      if (match < best_match || (match == best_match && len > best_len))
		{
		  /* Best exact match:  leftmost, then longest.  */
		  best_match = match;
		  best_len = len;
		}
	    } /* if re_search >= 0 */
	} /* for Regex patterns.  */
	if (best_match < end)
	  {
	    /* We have found an exact match.  We were just
	       waiting for the best one (leftmost then longest).  */
	    beg = best_match;
	    len = best_len;
	    goto success_in_len;
	  }
    } /* for (beg = end ..) */

 failure:
  ret_val = -1;
  goto out;

 success:
  len = end - beg;
 success_in_len:
  *match_size = len;
  ret_val = beg - buf;
 out:
  return ret_val;
}

Testing negative cases!
Testing 0 (with abstract condition) ENVIS_NEG
Iteration 0
Running test command:
/home/ubuntu/spr-fast/tools/grep-test.py /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-8a025cf8-8f08d8e2/tempworkdir-l/src /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-8a025cf8-8f08d8e2/tempworkdir-l/tests /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-8a025cf8-8f08d8e2/tempworkdir-l 0  > __res
Opening:/tmp/neg.tmp!
NegativeBRANCH RECORD/tmp/neg.tmp!
Not caught by the negative case, give up!
APPENDING TO ISNEG:/tmp/neg.tmp!
Running test command:
/home/ubuntu/spr-fast/tools/grep-test.py /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-8a025cf8-8f08d8e2/tempworkdir-l/src /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-8a025cf8-8f08d8e2/tempworkdir-l/tests /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-8a025cf8-8f08d8e2/tempworkdir-l 0  > __res
CondTester, Testing instance id 23:
//src_file:src/dfasearch.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); void* memset(void*, int, unsigned long); 
/* dfasearch.c - searching subroutines using dfa and regex for grep.
   Copyright 1992, 1998, 2000, 2007, 2009-2010 Free Software Foundation, Inc.

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 3, or (at your option)
   any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program; if not, write to the Free Software
   Foundation, Inc., 51 Franklin Street - Fifth Floor, Boston, MA
   02110-1301, USA.  */

/* Written August 1992 by Mike Haertel. */

#include <config.h>
#include "search.h"
#include "dfa.h"

/* For -w, we also consider _ to be word constituent.  */
#define WCHAR(C) (ISALNUM(C) || (C) == '_')

/* KWset compiled pattern.  For Ecompile and Gcompile, we compile
   a list of strings, at least one of which is known to occur in
   any string matching the regexp. */
static kwset_t kwset;

/* DFA compiled regexp. */
static struct dfa dfa;

/* The Regex compiled patterns.  */
static struct patterns
{
  /* Regex compiled regexp. */
  struct re_pattern_buffer regexbuf;
  struct re_registers regs; /* This is here on account of a BRAIN-DEAD
			       Q@#%!# library interface in regex.c.  */
} patterns0;

struct patterns *patterns;
size_t pcount;

void
dfaerror (char const *mesg)
{
  error (EXIT_TROUBLE, 0, "%s", mesg);

  /* notreached */
  /* Tell static analyzers that this function does not return.  */
  abort ();
}

/* Number of compiled fixed strings known to exactly match the regexp.
   If kwsexec returns < kwset_exact_matches, then we don't need to
   call the regexp matcher at all. */
static int kwset_exact_matches;

static char const *
kwsincr_case (const char *must)
{
  const char *buf;
  size_t n;

  n = strlen (must);
#ifdef MBS_SUPPORT
  if (match_icase && MB_CUR_MAX > 1)
    buf = mbtolower (must, &n);
  else
#endif
    buf = must;
  return kwsincr (kwset, buf, n);
}

/* If the DFA turns out to have some set of fixed strings one of
   which must occur in the match, then we build a kwset matcher
   to find those strings, and thus quickly filter out impossible
   matches. */
static void
kwsmusts (void)
{
  struct dfamust const *dm;
  char const *err;

  if (dfa.musts)
    {
      kwsinit (&kwset);
      /* First, we compile in the substrings known to be exact
	 matches.  The kwset matcher will return the index
	 of the matching string that it chooses. */
      for (dm = dfa.musts; dm; dm = dm->next)
	{
	  if (!dm->exact)
	    continue;
	  ++kwset_exact_matches;
	  if ((err = kwsincr_case (dm->must)) != NULL)
	    error (EXIT_TROUBLE, 0, "%s", err);
	}
      /* Now, we compile the substrings that will require
	 the use of the regexp matcher.  */
      for (dm = dfa.musts; dm; dm = dm->next)
	{
	  if (dm->exact)
	    continue;
	  if ((err = kwsincr_case (dm->must)) != NULL)
	    error (EXIT_TROUBLE, 0, "%s", err);
	}
      if ((err = kwsprep (kwset)) != NULL)
	error (EXIT_TROUBLE, 0, "%s", err);
    }
}

void
GEAcompile (char const *pattern, size_t size, reg_syntax_t syntax_bits)
{
  const char *err;
  const char *p, *sep;
  size_t total = size;
  char *motif;

  if (match_icase)
    syntax_bits |= RE_ICASE;
  re_set_syntax (syntax_bits);
  dfasyntax (syntax_bits, match_icase, eolbyte);

  /* For GNU regex compiler we have to pass the patterns separately to detect
     errors like "[\nallo\n]\n".  The patterns here are "[", "allo" and "]"
     GNU regex should have raise a syntax error.  The same for backref, where
     the backref should have been local to each pattern.  */
  p = pattern;
  do
    {
      size_t len;
      sep = memchr (p, '\n', total);
      if (sep)
	{
	  len = sep - p;
	  sep++;
	  total -= (len + 1);
	}
      else
	{
	  len = total;
	  total = 0;
	}

      patterns = realloc (patterns, (pcount + 1) * sizeof (*patterns));
      if (patterns == NULL)
	error (EXIT_TROUBLE, errno, _("memory exhausted"));
      patterns[pcount] = patterns0;

      if ((err = re_compile_pattern (p, len,
				    &(patterns[pcount].regexbuf))) != NULL)
	error (EXIT_TROUBLE, 0, "%s", err);
      pcount++;

      p = sep;
    } while (sep && total != 0);

  /* In the match_words and match_lines cases, we use a different pattern
     for the DFA matcher that will quickly throw out cases that won't work.
     Then if DFA succeeds we do some hairy stuff using the regex matcher
     to decide whether the match should really count. */
  if (match_words || match_lines)
    {
      static char const line_beg_no_bk[] = "^(";
      static char const line_end_no_bk[] = ")$";
      static char const word_beg_no_bk[] = "(^|[^[:alnum:]_])(";
      static char const word_end_no_bk[] = ")([^[:alnum:]_]|$)";
      static char const line_beg_bk[] = "^\\(";
      static char const line_end_bk[] = "\\)$";
      static char const word_beg_bk[] = "\\(^\\|[^[:alnum:]_]\\)\\(";
      static char const word_end_bk[] = "\\)\\([^[:alnum:]_]\\|$\\)";
      int bk = !(syntax_bits & RE_NO_BK_PARENS);
      char *n = xmalloc (sizeof word_beg_bk - 1 + size + sizeof word_end_bk);

      strcpy (n, match_lines ? (bk ? line_beg_bk : line_beg_no_bk)
			     : (bk ? word_beg_bk : word_beg_no_bk));
      total = strlen(n);
      memcpy (n + total, pattern, size);
      total += size;
      strcpy (n + total, match_lines ? (bk ? line_end_bk : line_end_no_bk)
				     : (bk ? word_end_bk : word_end_no_bk));
      total += strlen (n + total);
      pattern = motif = n;
      size = total;
    }
  else
    motif = NULL;

  dfacomp (pattern, size, &dfa, 1);
  kwsmusts ();

  free(motif);
}

size_t
EGexecute (char const *buf, size_t size, size_t *match_size,
	   char const *start_ptr)
{
  char const *buflim, *beg, *end, *match, *best_match, *mb_start;
  char eol = eolbyte;
  int backref, start, len, best_len;
  struct kwsmatch kwsm;
  size_t i, ret_val;
#ifdef MBS_SUPPORT
  if (MB_CUR_MAX > 1)
    {
      if (match_icase)
        {
          /* mbtolower adds a NUL byte at the end.  That will provide
	     space for the sentinel byte dfaexec may add.  */
          char *case_buf = mbtolower (buf, &size);
	  if (start_ptr)
	    start_ptr = case_buf + (start_ptr - buf);
          buf = case_buf;
        }
    }
#endif /* MBS_SUPPORT */

  mb_start = buf;
  buflim = buf + size;

  for (beg = end = buf; end < buflim; beg = end)
    {
      if (!start_ptr)
	{
	  /* We don't care about an exact match.  */
	  if (kwset)
	    {
	      /* Find a possible match using the KWset matcher. */
	      size_t offset = kwsexec (kwset, beg, buflim - beg, &kwsm);
	      if (offset == (size_t) -1)
		goto failure;
	      beg += offset;
	      /* Narrow down to the line containing the candidate, and
		 run it through DFA. */
	      if ((end = memchr(beg, eol, buflim - beg)) != NULL)
	        end++;
              else
                end = buflim;
	      match = beg;
	      while (beg > buf && beg[-1] != eol)
		--beg;
	      if (kwsm.index < kwset_exact_matches)
                {
#ifdef MBS_SUPPORT
                  if (mb_start < beg)
                    mb_start = beg;
                  if (MB_CUR_MAX == 1 || !is_mb_middle (&mb_start, match, buflim))
#endif
                    goto success;
                }
	      if (dfaexec (&dfa, beg, (char *) end, 0, NULL, &backref) == NULL)
		continue;
	    }
	  else
	    {
	      /* No good fixed strings; start with DFA. */
	      char const *next_beg = dfaexec (&dfa, beg, (char *) buflim,
					      0, NULL, &backref);
	      if (next_beg == NULL)
		break;
	      /* Narrow down to the line we've found. */
	      beg = next_beg;
	      if ((end = memchr(beg, eol, buflim - beg)) != NULL)
	        end++;
              else
                end = buflim;
	      while (beg > buf && beg[-1] != eol)
		--beg;
	    }
	  /* Successful, no backreferences encountered! */
	  if (!backref)
	    goto success;
	}
      else
	{
	  /* We are looking for the leftmost (then longest) exact match.
	     We will go through the outer loop only once.  */
	  beg = start_ptr;
	  end = buflim;
	}

      /* If we've made it to this point, this means DFA has seen
	 a probable match, and we need to run it through Regex. */
      best_match = end;
      best_len = 0;
      for (i = 0; i < pcount; i++)
	{
	  patterns[i].regexbuf.not_eol = 0;
	  if (0 <= (start = re_search (&(patterns[i].regexbuf),
				       buf, end - buf - 1,
				       beg - buf, end - beg - 1,
				       &(patterns[i].regs))))
	    {
	      len = patterns[i].regs.end[0] - start;
	      match = buf + start;
	      if (match > best_match)
		continue;
	      
//Patch 0:
if ((start_ptr && !match_words) || (__is_neg(25, &(start_ptr), sizeof (start_ptr), &(match_words), sizeof (match_words), &(match), sizeof (match), &(best_match), sizeof (best_match), &(match_lines), sizeof (match_lines), &(buf), sizeof (buf), &(beg), sizeof (beg), &(end), sizeof (end), &(start), sizeof (start), &(len), sizeof (len), &(i), sizeof (i), &(patterns), sizeof (patterns), &(pcount), sizeof (pcount), &(best_len), sizeof (best_len), &(buflim), sizeof (buflim), &(backref), sizeof (backref), &(eol), sizeof (eol), &(mb_start), sizeof (mb_start), &(kwset_exact_matches), sizeof (kwset_exact_matches), &(kwset), sizeof (kwset), &(ret_val), sizeof (ret_val), &(size), sizeof (size), &(match_size), sizeof (match_size), &(match_icase), sizeof (match_icase), &(eolbyte), sizeof (eolbyte))))
    goto assess_pattern_match;

//CodeSeg 1:
	      if ((!match_lines && !match_words)
		  || (match_lines && len == end - beg - 1))
		{
		  match = beg;
		  len = end - beg;
		  goto assess_pattern_match;
		}
	      /* If -w, check if the match aligns with word boundaries.
		 We do this iteratively because:
		 (a) the line may contain more than one occurence of the
		 pattern, and
		 (b) Several alternatives in the pattern might be valid at a
		 given point, and we may need to consider a shorter one to
		 find a word boundary.  */
	      if (match_words)
		while (match <= best_match)
		  {
		    if ((match == buf || !WCHAR ((unsigned char) match[-1]))
			&& (len == end - beg - 1
			    || !WCHAR ((unsigned char) match[len])))
		      goto assess_pattern_match;
		    if (len > 0)
		      {
			/* Try a shorter length anchored at the same place. */
			--len;
			patterns[i].regexbuf.not_eol = 1;
			len = re_match (&(patterns[i].regexbuf),
					buf, match + len - beg, match - buf,
					&(patterns[i].regs));
		      }
		    if (len <= 0)
		      {
			/* Try looking further on. */
			if (match == end - 1)
			  break;
			match++;
			patterns[i].regexbuf.not_eol = 0;
			start = re_search (&(patterns[i].regexbuf),
					   buf, end - buf - 1,
					   match - buf, end - match - 1,
					   &(patterns[i].regs));
			if (start < 0)
			  break;
			len = patterns[i].regs.end[0] - start;
			match = buf + start;
		      }
		  } /* while (match <= best_match) */
	      continue;
	    assess_pattern_match:
	      if (!start_ptr)
		{
		  /* Good enough for a non-exact match.
		     No need to look at further patterns, if any.  */
		  beg = match;
		  goto success_in_len;
		}
	      if (match < best_match || (match == best_match && len > best_len))
		{
		  /* Best exact match:  leftmost, then longest.  */
		  best_match = match;
		  best_len = len;
		}
	    } /* if re_search >= 0 */
	} /* for Regex patterns.  */
	if (best_match < end)
	  {
	    /* We have found an exact match.  We were just
	       waiting for the best one (leftmost then longest).  */
	    beg = best_match;
	    len = best_len;
	    goto success_in_len;
	  }
    } /* for (beg = end ..) */

 failure:
  ret_val = -1;
  goto out;

 success:
  len = end - beg;
 success_in_len:
  *match_size = len;
  ret_val = beg - buf;
 out:
  return ret_val;
}

Testing negative cases!
Testing 0 (with abstract condition) ENVIS_NEG
Iteration 0
Running test command:
/home/ubuntu/spr-fast/tools/grep-test.py /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-8a025cf8-8f08d8e2/tempworkdir-l/src /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-8a025cf8-8f08d8e2/tempworkdir-l/tests /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-8a025cf8-8f08d8e2/tempworkdir-l 0  > __res
Opening:/tmp/neg.tmp!
NegativeBRANCH RECORD/tmp/neg.tmp!
APPENDING TO ISNEG:/tmp/neg.tmp!
Branch 0: 0
Iteration 1
Running test command:
/home/ubuntu/spr-fast/tools/grep-test.py /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-8a025cf8-8f08d8e2/tempworkdir-l/src /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-8a025cf8-8f08d8e2/tempworkdir-l/tests /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-8a025cf8-8f08d8e2/tempworkdir-l 0  > __res
Opening:/tmp/neg.tmp!
NegativeBRANCH RECORD/tmp/neg.tmp!
APPENDING TO ISNEG:/tmp/neg.tmp!
Branch 0: 1
Running test command:
/home/ubuntu/spr-fast/tools/grep-test.py /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-8a025cf8-8f08d8e2/tempworkdir-l/src /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-8a025cf8-8f08d8e2/tempworkdir-l/tests /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-8a025cf8-8f08d8e2/tempworkdir-l 0  > __res
CondTester, Testing instance id 24:
//src_file:src/dfasearch.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); void* memset(void*, int, unsigned long); 
/* dfasearch.c - searching subroutines using dfa and regex for grep.
   Copyright 1992, 1998, 2000, 2007, 2009-2010 Free Software Foundation, Inc.

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 3, or (at your option)
   any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program; if not, write to the Free Software
   Foundation, Inc., 51 Franklin Street - Fifth Floor, Boston, MA
   02110-1301, USA.  */

/* Written August 1992 by Mike Haertel. */

#include <config.h>
#include "search.h"
#include "dfa.h"

/* For -w, we also consider _ to be word constituent.  */
#define WCHAR(C) (ISALNUM(C) || (C) == '_')

/* KWset compiled pattern.  For Ecompile and Gcompile, we compile
   a list of strings, at least one of which is known to occur in
   any string matching the regexp. */
static kwset_t kwset;

/* DFA compiled regexp. */
static struct dfa dfa;

/* The Regex compiled patterns.  */
static struct patterns
{
  /* Regex compiled regexp. */
  struct re_pattern_buffer regexbuf;
  struct re_registers regs; /* This is here on account of a BRAIN-DEAD
			       Q@#%!# library interface in regex.c.  */
} patterns0;

struct patterns *patterns;
size_t pcount;

void
dfaerror (char const *mesg)
{
  error (EXIT_TROUBLE, 0, "%s", mesg);

  /* notreached */
  /* Tell static analyzers that this function does not return.  */
  abort ();
}

/* Number of compiled fixed strings known to exactly match the regexp.
   If kwsexec returns < kwset_exact_matches, then we don't need to
   call the regexp matcher at all. */
static int kwset_exact_matches;

static char const *
kwsincr_case (const char *must)
{
  const char *buf;
  size_t n;

  n = strlen (must);
#ifdef MBS_SUPPORT
  if (match_icase && MB_CUR_MAX > 1)
    buf = mbtolower (must, &n);
  else
#endif
    buf = must;
  return kwsincr (kwset, buf, n);
}

/* If the DFA turns out to have some set of fixed strings one of
   which must occur in the match, then we build a kwset matcher
   to find those strings, and thus quickly filter out impossible
   matches. */
static void
kwsmusts (void)
{
  struct dfamust const *dm;
  char const *err;

  if (dfa.musts)
    {
      kwsinit (&kwset);
      /* First, we compile in the substrings known to be exact
	 matches.  The kwset matcher will return the index
	 of the matching string that it chooses. */
      for (dm = dfa.musts; dm; dm = dm->next)
	{
	  if (!dm->exact)
	    continue;
	  ++kwset_exact_matches;
	  if ((err = kwsincr_case (dm->must)) != NULL)
	    error (EXIT_TROUBLE, 0, "%s", err);
	}
      /* Now, we compile the substrings that will require
	 the use of the regexp matcher.  */
      for (dm = dfa.musts; dm; dm = dm->next)
	{
	  if (dm->exact)
	    continue;
	  if ((err = kwsincr_case (dm->must)) != NULL)
	    error (EXIT_TROUBLE, 0, "%s", err);
	}
      if ((err = kwsprep (kwset)) != NULL)
	error (EXIT_TROUBLE, 0, "%s", err);
    }
}

void
GEAcompile (char const *pattern, size_t size, reg_syntax_t syntax_bits)
{
  const char *err;
  const char *p, *sep;
  size_t total = size;
  char *motif;

  if (match_icase)
    syntax_bits |= RE_ICASE;
  re_set_syntax (syntax_bits);
  dfasyntax (syntax_bits, match_icase, eolbyte);

  /* For GNU regex compiler we have to pass the patterns separately to detect
     errors like "[\nallo\n]\n".  The patterns here are "[", "allo" and "]"
     GNU regex should have raise a syntax error.  The same for backref, where
     the backref should have been local to each pattern.  */
  p = pattern;
  do
    {
      size_t len;
      sep = memchr (p, '\n', total);
      if (sep)
	{
	  len = sep - p;
	  sep++;
	  total -= (len + 1);
	}
      else
	{
	  len = total;
	  total = 0;
	}

      patterns = realloc (patterns, (pcount + 1) * sizeof (*patterns));
      if (patterns == NULL)
	error (EXIT_TROUBLE, errno, _("memory exhausted"));
      patterns[pcount] = patterns0;

      if ((err = re_compile_pattern (p, len,
				    &(patterns[pcount].regexbuf))) != NULL)
	error (EXIT_TROUBLE, 0, "%s", err);
      pcount++;

      p = sep;
    } while (sep && total != 0);

  /* In the match_words and match_lines cases, we use a different pattern
     for the DFA matcher that will quickly throw out cases that won't work.
     Then if DFA succeeds we do some hairy stuff using the regex matcher
     to decide whether the match should really count. */
  if (match_words || match_lines)
    {
      static char const line_beg_no_bk[] = "^(";
      static char const line_end_no_bk[] = ")$";
      static char const word_beg_no_bk[] = "(^|[^[:alnum:]_])(";
      static char const word_end_no_bk[] = ")([^[:alnum:]_]|$)";
      static char const line_beg_bk[] = "^\\(";
      static char const line_end_bk[] = "\\)$";
      static char const word_beg_bk[] = "\\(^\\|[^[:alnum:]_]\\)\\(";
      static char const word_end_bk[] = "\\)\\([^[:alnum:]_]\\|$\\)";
      int bk = !(syntax_bits & RE_NO_BK_PARENS);
      char *n = xmalloc (sizeof word_beg_bk - 1 + size + sizeof word_end_bk);

      strcpy (n, match_lines ? (bk ? line_beg_bk : line_beg_no_bk)
			     : (bk ? word_beg_bk : word_beg_no_bk));
      total = strlen(n);
      memcpy (n + total, pattern, size);
      total += size;
      strcpy (n + total, match_lines ? (bk ? line_end_bk : line_end_no_bk)
				     : (bk ? word_end_bk : word_end_no_bk));
      total += strlen (n + total);
      pattern = motif = n;
      size = total;
    }
  else
    motif = NULL;

  dfacomp (pattern, size, &dfa, 1);
  kwsmusts ();

  free(motif);
}

size_t
EGexecute (char const *buf, size_t size, size_t *match_size,
	   char const *start_ptr)
{
  char const *buflim, *beg, *end, *match, *best_match, *mb_start;
  char eol = eolbyte;
  int backref, start, len, best_len;
  struct kwsmatch kwsm;
  size_t i, ret_val;
#ifdef MBS_SUPPORT
  if (MB_CUR_MAX > 1)
    {
      if (match_icase)
        {
          /* mbtolower adds a NUL byte at the end.  That will provide
	     space for the sentinel byte dfaexec may add.  */
          char *case_buf = mbtolower (buf, &size);
	  if (start_ptr)
	    start_ptr = case_buf + (start_ptr - buf);
          buf = case_buf;
        }
    }
#endif /* MBS_SUPPORT */

  mb_start = buf;
  buflim = buf + size;

  for (beg = end = buf; end < buflim; beg = end)
    {
      if (!start_ptr)
	{
	  /* We don't care about an exact match.  */
	  if (kwset)
	    {
	      /* Find a possible match using the KWset matcher. */
	      size_t offset = kwsexec (kwset, beg, buflim - beg, &kwsm);
	      if (offset == (size_t) -1)
		goto failure;
	      beg += offset;
	      /* Narrow down to the line containing the candidate, and
		 run it through DFA. */
	      if ((end = memchr(beg, eol, buflim - beg)) != NULL)
	        end++;
              else
                end = buflim;
	      match = beg;
	      while (beg > buf && beg[-1] != eol)
		--beg;
	      if (kwsm.index < kwset_exact_matches)
                {
#ifdef MBS_SUPPORT
                  if (mb_start < beg)
                    mb_start = beg;
                  if (MB_CUR_MAX == 1 || !is_mb_middle (&mb_start, match, buflim))
#endif
                    goto success;
                }
	      if (dfaexec (&dfa, beg, (char *) end, 0, NULL, &backref) == NULL)
		continue;
	    }
	  else
	    {
	      /* No good fixed strings; start with DFA. */
	      char const *next_beg = dfaexec (&dfa, beg, (char *) buflim,
					      0, NULL, &backref);
	      if (next_beg == NULL)
		break;
	      /* Narrow down to the line we've found. */
	      beg = next_beg;
	      if ((end = memchr(beg, eol, buflim - beg)) != NULL)
	        end++;
              else
                end = buflim;
	      while (beg > buf && beg[-1] != eol)
		--beg;
	    }
	  /* Successful, no backreferences encountered! */
	  if (!backref)
	    goto success;
	}
      else
	{
	  /* We are looking for the leftmost (then longest) exact match.
	     We will go through the outer loop only once.  */
	  beg = start_ptr;
	  end = buflim;
	}

      /* If we've made it to this point, this means DFA has seen
	 a probable match, and we need to run it through Regex. */
      best_match = end;
      best_len = 0;
      for (i = 0; i < pcount; i++)
	{
	  patterns[i].regexbuf.not_eol = 0;
	  if (0 <= (start = re_search (&(patterns[i].regexbuf),
				       buf, end - buf - 1,
				       beg - buf, end - beg - 1,
				       &(patterns[i].regs))))
	    {
	      len = patterns[i].regs.end[0] - start;
	      match = buf + start;
	      if (match > best_match)
		continue;
	      
//Patch 0:
if (((start_ptr) || (__is_neg(25, &(start_ptr), sizeof (start_ptr), &(match_words), sizeof (match_words), &(match), sizeof (match), &(best_match), sizeof (best_match), &(match_lines), sizeof (match_lines), &(buf), sizeof (buf), &(beg), sizeof (beg), &(end), sizeof (end), &(start), sizeof (start), &(len), sizeof (len), &(i), sizeof (i), &(patterns), sizeof (patterns), &(pcount), sizeof (pcount), &(best_len), sizeof (best_len), &(buflim), sizeof (buflim), &(backref), sizeof (backref), &(eol), sizeof (eol), &(mb_start), sizeof (mb_start), &(kwset_exact_matches), sizeof (kwset_exact_matches), &(kwset), sizeof (kwset), &(ret_val), sizeof (ret_val), &(size), sizeof (size), &(match_size), sizeof (match_size), &(match_icase), sizeof (match_icase), &(eolbyte), sizeof (eolbyte)))) && !match_words)
    goto assess_pattern_match;

//CodeSeg 1:
	      if ((!match_lines && !match_words)
		  || (match_lines && len == end - beg - 1))
		{
		  match = beg;
		  len = end - beg;
		  goto assess_pattern_match;
		}
	      /* If -w, check if the match aligns with word boundaries.
		 We do this iteratively because:
		 (a) the line may contain more than one occurence of the
		 pattern, and
		 (b) Several alternatives in the pattern might be valid at a
		 given point, and we may need to consider a shorter one to
		 find a word boundary.  */
	      if (match_words)
		while (match <= best_match)
		  {
		    if ((match == buf || !WCHAR ((unsigned char) match[-1]))
			&& (len == end - beg - 1
			    || !WCHAR ((unsigned char) match[len])))
		      goto assess_pattern_match;
		    if (len > 0)
		      {
			/* Try a shorter length anchored at the same place. */
			--len;
			patterns[i].regexbuf.not_eol = 1;
			len = re_match (&(patterns[i].regexbuf),
					buf, match + len - beg, match - buf,
					&(patterns[i].regs));
		      }
		    if (len <= 0)
		      {
			/* Try looking further on. */
			if (match == end - 1)
			  break;
			match++;
			patterns[i].regexbuf.not_eol = 0;
			start = re_search (&(patterns[i].regexbuf),
					   buf, end - buf - 1,
					   match - buf, end - match - 1,
					   &(patterns[i].regs));
			if (start < 0)
			  break;
			len = patterns[i].regs.end[0] - start;
			match = buf + start;
		      }
		  } /* while (match <= best_match) */
	      continue;
	    assess_pattern_match:
	      if (!start_ptr)
		{
		  /* Good enough for a non-exact match.
		     No need to look at further patterns, if any.  */
		  beg = match;
		  goto success_in_len;
		}
	      if (match < best_match || (match == best_match && len > best_len))
		{
		  /* Best exact match:  leftmost, then longest.  */
		  best_match = match;
		  best_len = len;
		}
	    } /* if re_search >= 0 */
	} /* for Regex patterns.  */
	if (best_match < end)
	  {
	    /* We have found an exact match.  We were just
	       waiting for the best one (leftmost then longest).  */
	    beg = best_match;
	    len = best_len;
	    goto success_in_len;
	  }
    } /* for (beg = end ..) */

 failure:
  ret_val = -1;
  goto out;

 success:
  len = end - beg;
 success_in_len:
  *match_size = len;
  ret_val = beg - buf;
 out:
  return ret_val;
}

Testing negative cases!
Testing 0 (with abstract condition) ENVIS_NEG
Iteration 0
Running test command:
/home/ubuntu/spr-fast/tools/grep-test.py /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-8a025cf8-8f08d8e2/tempworkdir-l/src /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-8a025cf8-8f08d8e2/tempworkdir-l/tests /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-8a025cf8-8f08d8e2/tempworkdir-l 0  > __res
Opening:/tmp/neg.tmp!
NegativeBRANCH RECORD/tmp/neg.tmp!
APPENDING TO ISNEG:/tmp/neg.tmp!
Branch 0: 0
Iteration 1
Running test command:
/home/ubuntu/spr-fast/tools/grep-test.py /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-8a025cf8-8f08d8e2/tempworkdir-l/src /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-8a025cf8-8f08d8e2/tempworkdir-l/tests /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-8a025cf8-8f08d8e2/tempworkdir-l 0  > __res
Opening:/tmp/neg.tmp!
NegativeBRANCH RECORD/tmp/neg.tmp!
APPENDING TO ISNEG:/tmp/neg.tmp!
Branch 0: 1
Running test command:
/home/ubuntu/spr-fast/tools/grep-test.py /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-8a025cf8-8f08d8e2/tempworkdir-l/src /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-8a025cf8-8f08d8e2/tempworkdir-l/tests /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-8a025cf8-8f08d8e2/tempworkdir-l 0  > __res
a batched test job starts!
Building merged code:
src_file: src/dfasearch.c
full src: int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); void* memset(void*, int, unsigned long); 
/* dfasearch.c - searching subroutines using dfa and regex for grep.
   Copyright 1992, 1998, 2000, 2007, 2009-2010 Free Software Foundation, Inc.

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 3, or (at your option)
   any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program; if not, write to the Free Software
   Foundation, Inc., 51 Franklin Street - Fifth Floor, Boston, MA
   02110-1301, USA.  */

/* Written August 1992 by Mike Haertel. */

#include <config.h>
#include "search.h"
#include "dfa.h"

/* For -w, we also consider _ to be word constituent.  */
#define WCHAR(C) (ISALNUM(C) || (C) == '_')

/* KWset compiled pattern.  For Ecompile and Gcompile, we compile
   a list of strings, at least one of which is known to occur in
   any string matching the regexp. */
static kwset_t kwset;

/* DFA compiled regexp. */
static struct dfa dfa;

/* The Regex compiled patterns.  */
static struct patterns
{
  /* Regex compiled regexp. */
  struct re_pattern_buffer regexbuf;
  struct re_registers regs; /* This is here on account of a BRAIN-DEAD
			       Q@#%!# library interface in regex.c.  */
} patterns0;

struct patterns *patterns;
size_t pcount;

void
dfaerror (char const *mesg)
{
  error (EXIT_TROUBLE, 0, "%s", mesg);

  /* notreached */
  /* Tell static analyzers that this function does not return.  */
  abort ();
}

/* Number of compiled fixed strings known to exactly match the regexp.
   If kwsexec returns < kwset_exact_matches, then we don't need to
   call the regexp matcher at all. */
static int kwset_exact_matches;

static char const *
kwsincr_case (const char *must)
{
  const char *buf;
  size_t n;

  n = strlen (must);
#ifdef MBS_SUPPORT
  if (match_icase && MB_CUR_MAX > 1)
    buf = mbtolower (must, &n);
  else
#endif
    buf = must;
  return kwsincr (kwset, buf, n);
}

/* If the DFA turns out to have some set of fixed strings one of
   which must occur in the match, then we build a kwset matcher
   to find those strings, and thus quickly filter out impossible
   matches. */
static void
kwsmusts (void)
{
  struct dfamust const *dm;
  char const *err;

  if (dfa.musts)
    {
      kwsinit (&kwset);
      /* First, we compile in the substrings known to be exact
	 matches.  The kwset matcher will return the index
	 of the matching string that it chooses. */
      for (dm = dfa.musts; dm; dm = dm->next)
	{
	  if (!dm->exact)
	    continue;
	  ++kwset_exact_matches;
	  if ((err = kwsincr_case (dm->must)) != NULL)
	    error (EXIT_TROUBLE, 0, "%s", err);
	}
      /* Now, we compile the substrings that will require
	 the use of the regexp matcher.  */
      for (dm = dfa.musts; dm; dm = dm->next)
	{
	  if (dm->exact)
	    continue;
	  if ((err = kwsincr_case (dm->must)) != NULL)
	    error (EXIT_TROUBLE, 0, "%s", err);
	}
      if ((err = kwsprep (kwset)) != NULL)
	error (EXIT_TROUBLE, 0, "%s", err);
    }
}

void
GEAcompile (char const *pattern, size_t size, reg_syntax_t syntax_bits)
{
  const char *err;
  const char *p, *sep;
  size_t total = size;
  char *motif;

  if (match_icase)
    syntax_bits |= RE_ICASE;
  re_set_syntax (syntax_bits);
  dfasyntax (syntax_bits, match_icase, eolbyte);

  /* For GNU regex compiler we have to pass the patterns separately to detect
     errors like "[\nallo\n]\n".  The patterns here are "[", "allo" and "]"
     GNU regex should have raise a syntax error.  The same for backref, where
     the backref should have been local to each pattern.  */
  p = pattern;
  do
    {
      size_t len;
      sep = memchr (p, '\n', total);
      if (sep)
	{
	  len = sep - p;
	  sep++;
	  total -= (len + 1);
	}
      else
	{
	  len = total;
	  total = 0;
	}

      patterns = realloc (patterns, (pcount + 1) * sizeof (*patterns));
      if (patterns == NULL)
	error (EXIT_TROUBLE, errno, _("memory exhausted"));
      patterns[pcount] = patterns0;

      if ((err = re_compile_pattern (p, len,
				    &(patterns[pcount].regexbuf))) != NULL)
	error (EXIT_TROUBLE, 0, "%s", err);
      pcount++;

      p = sep;
    } while (sep && total != 0);

  /* In the match_words and match_lines cases, we use a different pattern
     for the DFA matcher that will quickly throw out cases that won't work.
     Then if DFA succeeds we do some hairy stuff using the regex matcher
     to decide whether the match should really count. */
  if (match_words || match_lines)
    {
      static char const line_beg_no_bk[] = "^(";
      static char const line_end_no_bk[] = ")$";
      static char const word_beg_no_bk[] = "(^|[^[:alnum:]_])(";
      static char const word_end_no_bk[] = ")([^[:alnum:]_]|$)";
      static char const line_beg_bk[] = "^\\(";
      static char const line_end_bk[] = "\\)$";
      static char const word_beg_bk[] = "\\(^\\|[^[:alnum:]_]\\)\\(";
      static char const word_end_bk[] = "\\)\\([^[:alnum:]_]\\|$\\)";
      int bk = !(syntax_bits & RE_NO_BK_PARENS);
      char *n = xmalloc (sizeof word_beg_bk - 1 + size + sizeof word_end_bk);

      strcpy (n, match_lines ? (bk ? line_beg_bk : line_beg_no_bk)
			     : (bk ? word_beg_bk : word_beg_no_bk));
      total = strlen(n);
      memcpy (n + total, pattern, size);
      total += size;
      strcpy (n + total, match_lines ? (bk ? line_end_bk : line_end_no_bk)
				     : (bk ? word_end_bk : word_end_no_bk));
      total += strlen (n + total);
      pattern = motif = n;
      size = total;
    }
  else
    motif = NULL;

  dfacomp (pattern, size, &dfa, 1);
  kwsmusts ();

  free(motif);
}

size_t
EGexecute (char const *buf, size_t size, size_t *match_size,
	   char const *start_ptr)
{
  char const *buflim, *beg, *end, *match, *best_match, *mb_start;
  char eol = eolbyte;
  int backref, start, len, best_len;
  struct kwsmatch kwsm;
  size_t i, ret_val;
#ifdef MBS_SUPPORT
  if (MB_CUR_MAX > 1)
    {
      if (match_icase)
        {
          /* mbtolower adds a NUL byte at the end.  That will provide
	     space for the sentinel byte dfaexec may add.  */
          char *case_buf = mbtolower (buf, &size);
	  if (start_ptr)
	    start_ptr = case_buf + (start_ptr - buf);
          buf = case_buf;
        }
    }
#endif /* MBS_SUPPORT */

  mb_start = buf;
  buflim = buf + size;

  for (beg = end = buf; end < buflim; beg = end)
    {
      if (!start_ptr)
	{
	  /* We don't care about an exact match.  */
	  if (kwset)
	    {
	      /* Find a possible match using the KWset matcher. */
	      size_t offset = kwsexec (kwset, beg, buflim - beg, &kwsm);
	      if (offset == (size_t) -1)
		goto failure;
	      beg += offset;
	      /* Narrow down to the line containing the candidate, and
		 run it through DFA. */
	      if ((end = memchr(beg, eol, buflim - beg)) != NULL)
	        end++;
              else
                end = buflim;
	      match = beg;
	      while (beg > buf && beg[-1] != eol)
		--beg;
	      if (kwsm.index < kwset_exact_matches)
                {
#ifdef MBS_SUPPORT
                  if (mb_start < beg)
                    mb_start = beg;
                  if (MB_CUR_MAX == 1 || !is_mb_middle (&mb_start, match, buflim))
#endif
                    goto success;
                }
	      if (dfaexec (&dfa, beg, (char *) end, 0, NULL, &backref) == NULL)
		continue;
	    }
	  else
	    {
	      /* No good fixed strings; start with DFA. */
	      char const *next_beg = dfaexec (&dfa, beg, (char *) buflim,
					      0, NULL, &backref);
	      if (next_beg == NULL)
		break;
	      /* Narrow down to the line we've found. */
	      beg = next_beg;
	      if ((end = memchr(beg, eol, buflim - beg)) != NULL)
	        end++;
              else
                end = buflim;
	      while (beg > buf && beg[-1] != eol)
		--beg;
	    }
	  /* Successful, no backreferences encountered! */
	  if (!backref)
	    goto success;
	}
      else
	{
	  /* We are looking for the leftmost (then longest) exact match.
	     We will go through the outer loop only once.  */
	  beg = start_ptr;
	  end = buflim;
	}

      /* If we've made it to this point, this means DFA has seen
	 a probable match, and we need to run it through Regex. */
      best_match = end;
      best_len = 0;
      for (i = 0; i < pcount; i++)
	{
	  patterns[i].regexbuf.not_eol = 0;
	  if (0 <= (start = re_search (&(patterns[i].regexbuf),
				       buf, end - buf - 1,
				       beg - buf, end - beg - 1,
				       &(patterns[i].regs))))
	    {
	      len = patterns[i].regs.end[0] - start;
	      match = buf + start;
	      if (match > best_match)
		continue;
	      if (start_ptr && !match_words)
		goto assess_pattern_match;
	      //prophet generated patch
	      if (__get_mutant()==0) {
	      if (((!match_lines && !match_words) || (match_lines && len == end - beg - 1)) && !(__is_neg(25, &(beg), sizeof (beg), &(end), sizeof (end), &(len), sizeof (len), &(match_lines), sizeof (match_lines), &(match_words), sizeof (match_words), &(match), sizeof (match), &(start_ptr), sizeof (start_ptr), &(best_match), sizeof (best_match), &(buf), sizeof (buf), &(start), sizeof (start), &(i), sizeof (i), &(patterns), sizeof (patterns), &(pcount), sizeof (pcount), &(best_len), sizeof (best_len), &(buflim), sizeof (buflim), &(backref), sizeof (backref), &(eol), sizeof (eol), &(mb_start), sizeof (mb_start), &(kwset_exact_matches), sizeof (kwset_exact_matches), &(kwset), sizeof (kwset), &(ret_val), sizeof (ret_val), &(match_size), sizeof (match_size), &(size), sizeof (size), &(match_icase), sizeof (match_icase), &(eolbyte), sizeof (eolbyte)))) {
	          match = beg;
	          len = end - beg;
	          goto assess_pattern_match;
	      }
	      }
	      else if (__get_mutant()==1) {
	      if (((!match_lines && !match_words) || (match_lines && len == end - beg - 1)) || (__is_neg(25, &(beg), sizeof (beg), &(end), sizeof (end), &(len), sizeof (len), &(match_lines), sizeof (match_lines), &(match_words), sizeof (match_words), &(match), sizeof (match), &(start_ptr), sizeof (start_ptr), &(best_match), sizeof (best_match), &(buf), sizeof (buf), &(start), sizeof (start), &(i), sizeof (i), &(patterns), sizeof (patterns), &(pcount), sizeof (pcount), &(best_len), sizeof (best_len), &(buflim), sizeof (buflim), &(backref), sizeof (backref), &(eol), sizeof (eol), &(mb_start), sizeof (mb_start), &(kwset_exact_matches), sizeof (kwset_exact_matches), &(kwset), sizeof (kwset), &(ret_val), sizeof (ret_val), &(match_size), sizeof (match_size), &(size), sizeof (size), &(match_icase), sizeof (match_icase), &(eolbyte), sizeof (eolbyte)))) {
	          match = beg;
	          len = end - beg;
	          goto assess_pattern_match;
	      }
	      }
	      /* If -w, check if the match aligns with word boundaries.
		 We do this iteratively because:
		 (a) the line may contain more than one occurence of the
		 pattern, and
		 (b) Several alternatives in the pattern might be valid at a
		 given point, and we may need to consider a shorter one to
		 find a word boundary.  */
	      if (match_words)
		while (match <= best_match)
		  {
		    if ((match == buf || !WCHAR ((unsigned char) match[-1]))
			&& (len == end - beg - 1
			    || !WCHAR ((unsigned char) match[len])))
		      goto assess_pattern_match;
		    if (len > 0)
		      {
			/* Try a shorter length anchored at the same place. */
			--len;
			patterns[i].regexbuf.not_eol = 1;
			len = re_match (&(patterns[i].regexbuf),
					buf, match + len - beg, match - buf,
					&(patterns[i].regs));
		      }
		    if (len <= 0)
		      {
			/* Try looking further on. */
			if (match == end - 1)
			  break;
			match++;
			patterns[i].regexbuf.not_eol = 0;
			start = re_search (&(patterns[i].regexbuf),
					   buf, end - buf - 1,
					   match - buf, end - match - 1,
					   &(patterns[i].regs));
			if (start < 0)
			  break;
			len = patterns[i].regs.end[0] - start;
			match = buf + start;
		      }
		  } /* while (match <= best_match) */
	      continue;
	    assess_pattern_match:
	      if (!start_ptr)
		{
		  /* Good enough for a non-exact match.
		     No need to look at further patterns, if any.  */
		  beg = match;
		  goto success_in_len;
		}
	      if (match < best_match || (match == best_match && len > best_len))
		{
		  /* Best exact match:  leftmost, then longest.  */
		  best_match = match;
		  best_len = len;
		}
	    } /* if re_search >= 0 */
	} /* for Regex patterns.  */
	if (best_match < end)
	  {
	    /* We have found an exact match.  We were just
	       waiting for the best one (leftmost then longest).  */
	    beg = best_match;
	    len = best_len;
	    goto success_in_len;
	  }
    } /* for (beg = end ..) */

 failure:
  ret_val = -1;
  goto out;

 success:
  len = end - beg;
 success_in_len:
  *match_size = len;
  ret_val = beg - buf;
 out:
  return ret_val;
}

Building:src at:
/home/ubuntu/spr-fast/tests/corebench/grep/grep-case-8a025cf8-8f08d8e2/tempworkdir-l/srcMerged code building succ, going to invoke tester!
CondTester, Testing instance id 19:
//src_file:src/dfasearch.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); void* memset(void*, int, unsigned long); 
/* dfasearch.c - searching subroutines using dfa and regex for grep.
   Copyright 1992, 1998, 2000, 2007, 2009-2010 Free Software Foundation, Inc.

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 3, or (at your option)
   any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program; if not, write to the Free Software
   Foundation, Inc., 51 Franklin Street - Fifth Floor, Boston, MA
   02110-1301, USA.  */

/* Written August 1992 by Mike Haertel. */

#include <config.h>
#include "search.h"
#include "dfa.h"

/* For -w, we also consider _ to be word constituent.  */
#define WCHAR(C) (ISALNUM(C) || (C) == '_')

/* KWset compiled pattern.  For Ecompile and Gcompile, we compile
   a list of strings, at least one of which is known to occur in
   any string matching the regexp. */
static kwset_t kwset;

/* DFA compiled regexp. */
static struct dfa dfa;

/* The Regex compiled patterns.  */
static struct patterns
{
  /* Regex compiled regexp. */
  struct re_pattern_buffer regexbuf;
  struct re_registers regs; /* This is here on account of a BRAIN-DEAD
			       Q@#%!# library interface in regex.c.  */
} patterns0;

struct patterns *patterns;
size_t pcount;

void
dfaerror (char const *mesg)
{
  error (EXIT_TROUBLE, 0, "%s", mesg);

  /* notreached */
  /* Tell static analyzers that this function does not return.  */
  abort ();
}

/* Number of compiled fixed strings known to exactly match the regexp.
   If kwsexec returns < kwset_exact_matches, then we don't need to
   call the regexp matcher at all. */
static int kwset_exact_matches;

static char const *
kwsincr_case (const char *must)
{
  const char *buf;
  size_t n;

  n = strlen (must);
#ifdef MBS_SUPPORT
  if (match_icase && MB_CUR_MAX > 1)
    buf = mbtolower (must, &n);
  else
#endif
    buf = must;
  return kwsincr (kwset, buf, n);
}

/* If the DFA turns out to have some set of fixed strings one of
   which must occur in the match, then we build a kwset matcher
   to find those strings, and thus quickly filter out impossible
   matches. */
static void
kwsmusts (void)
{
  struct dfamust const *dm;
  char const *err;

  if (dfa.musts)
    {
      kwsinit (&kwset);
      /* First, we compile in the substrings known to be exact
	 matches.  The kwset matcher will return the index
	 of the matching string that it chooses. */
      for (dm = dfa.musts; dm; dm = dm->next)
	{
	  if (!dm->exact)
	    continue;
	  ++kwset_exact_matches;
	  if ((err = kwsincr_case (dm->must)) != NULL)
	    error (EXIT_TROUBLE, 0, "%s", err);
	}
      /* Now, we compile the substrings that will require
	 the use of the regexp matcher.  */
      for (dm = dfa.musts; dm; dm = dm->next)
	{
	  if (dm->exact)
	    continue;
	  if ((err = kwsincr_case (dm->must)) != NULL)
	    error (EXIT_TROUBLE, 0, "%s", err);
	}
      if ((err = kwsprep (kwset)) != NULL)
	error (EXIT_TROUBLE, 0, "%s", err);
    }
}

void
GEAcompile (char const *pattern, size_t size, reg_syntax_t syntax_bits)
{
  const char *err;
  const char *p, *sep;
  size_t total = size;
  char *motif;

  if (match_icase)
    syntax_bits |= RE_ICASE;
  re_set_syntax (syntax_bits);
  dfasyntax (syntax_bits, match_icase, eolbyte);

  /* For GNU regex compiler we have to pass the patterns separately to detect
     errors like "[\nallo\n]\n".  The patterns here are "[", "allo" and "]"
     GNU regex should have raise a syntax error.  The same for backref, where
     the backref should have been local to each pattern.  */
  p = pattern;
  do
    {
      size_t len;
      sep = memchr (p, '\n', total);
      if (sep)
	{
	  len = sep - p;
	  sep++;
	  total -= (len + 1);
	}
      else
	{
	  len = total;
	  total = 0;
	}

      patterns = realloc (patterns, (pcount + 1) * sizeof (*patterns));
      if (patterns == NULL)
	error (EXIT_TROUBLE, errno, _("memory exhausted"));
      patterns[pcount] = patterns0;

      if ((err = re_compile_pattern (p, len,
				    &(patterns[pcount].regexbuf))) != NULL)
	error (EXIT_TROUBLE, 0, "%s", err);
      pcount++;

      p = sep;
    } while (sep && total != 0);

  /* In the match_words and match_lines cases, we use a different pattern
     for the DFA matcher that will quickly throw out cases that won't work.
     Then if DFA succeeds we do some hairy stuff using the regex matcher
     to decide whether the match should really count. */
  if (match_words || match_lines)
    {
      static char const line_beg_no_bk[] = "^(";
      static char const line_end_no_bk[] = ")$";
      static char const word_beg_no_bk[] = "(^|[^[:alnum:]_])(";
      static char const word_end_no_bk[] = ")([^[:alnum:]_]|$)";
      static char const line_beg_bk[] = "^\\(";
      static char const line_end_bk[] = "\\)$";
      static char const word_beg_bk[] = "\\(^\\|[^[:alnum:]_]\\)\\(";
      static char const word_end_bk[] = "\\)\\([^[:alnum:]_]\\|$\\)";
      int bk = !(syntax_bits & RE_NO_BK_PARENS);
      char *n = xmalloc (sizeof word_beg_bk - 1 + size + sizeof word_end_bk);

      strcpy (n, match_lines ? (bk ? line_beg_bk : line_beg_no_bk)
			     : (bk ? word_beg_bk : word_beg_no_bk));
      total = strlen(n);
      memcpy (n + total, pattern, size);
      total += size;
      strcpy (n + total, match_lines ? (bk ? line_end_bk : line_end_no_bk)
				     : (bk ? word_end_bk : word_end_no_bk));
      total += strlen (n + total);
      pattern = motif = n;
      size = total;
    }
  else
    motif = NULL;

  dfacomp (pattern, size, &dfa, 1);
  kwsmusts ();

  free(motif);
}

size_t
EGexecute (char const *buf, size_t size, size_t *match_size,
	   char const *start_ptr)
{
  char const *buflim, *beg, *end, *match, *best_match, *mb_start;
  char eol = eolbyte;
  int backref, start, len, best_len;
  struct kwsmatch kwsm;
  size_t i, ret_val;
#ifdef MBS_SUPPORT
  if (MB_CUR_MAX > 1)
    {
      if (match_icase)
        {
          /* mbtolower adds a NUL byte at the end.  That will provide
	     space for the sentinel byte dfaexec may add.  */
          char *case_buf = mbtolower (buf, &size);
	  if (start_ptr)
	    start_ptr = case_buf + (start_ptr - buf);
          buf = case_buf;
        }
    }
#endif /* MBS_SUPPORT */

  mb_start = buf;
  buflim = buf + size;

  for (beg = end = buf; end < buflim; beg = end)
    {
      if (!start_ptr)
	{
	  /* We don't care about an exact match.  */
	  if (kwset)
	    {
	      /* Find a possible match using the KWset matcher. */
	      size_t offset = kwsexec (kwset, beg, buflim - beg, &kwsm);
	      if (offset == (size_t) -1)
		goto failure;
	      beg += offset;
	      /* Narrow down to the line containing the candidate, and
		 run it through DFA. */
	      if ((end = memchr(beg, eol, buflim - beg)) != NULL)
	        end++;
              else
                end = buflim;
	      match = beg;
	      while (beg > buf && beg[-1] != eol)
		--beg;
	      if (kwsm.index < kwset_exact_matches)
                {
#ifdef MBS_SUPPORT
                  if (mb_start < beg)
                    mb_start = beg;
                  if (MB_CUR_MAX == 1 || !is_mb_middle (&mb_start, match, buflim))
#endif
                    goto success;
                }
	      if (dfaexec (&dfa, beg, (char *) end, 0, NULL, &backref) == NULL)
		continue;
	    }
	  else
	    {
	      /* No good fixed strings; start with DFA. */
	      char const *next_beg = dfaexec (&dfa, beg, (char *) buflim,
					      0, NULL, &backref);
	      if (next_beg == NULL)
		break;
	      /* Narrow down to the line we've found. */
	      beg = next_beg;
	      if ((end = memchr(beg, eol, buflim - beg)) != NULL)
	        end++;
              else
                end = buflim;
	      while (beg > buf && beg[-1] != eol)
		--beg;
	    }
	  /* Successful, no backreferences encountered! */
	  if (!backref)
	    goto success;
	}
      else
	{
	  /* We are looking for the leftmost (then longest) exact match.
	     We will go through the outer loop only once.  */
	  beg = start_ptr;
	  end = buflim;
	}

      /* If we've made it to this point, this means DFA has seen
	 a probable match, and we need to run it through Regex. */
      best_match = end;
      best_len = 0;
      for (i = 0; i < pcount; i++)
	{
	  patterns[i].regexbuf.not_eol = 0;
	  if (0 <= (start = re_search (&(patterns[i].regexbuf),
				       buf, end - buf - 1,
				       beg - buf, end - beg - 1,
				       &(patterns[i].regs))))
	    {
	      len = patterns[i].regs.end[0] - start;
	      match = buf + start;
	      if (match > best_match)
		continue;
	      if (start_ptr && !match_words)
		goto assess_pattern_match;
	      
//Patch 0:
if (((!match_lines && !match_words) || (match_lines && len == end - beg - 1)) && !(__is_neg(25, &(beg), sizeof (beg), &(end), sizeof (end), &(len), sizeof (len), &(match_lines), sizeof (match_lines), &(match_words), sizeof (match_words), &(match), sizeof (match), &(start_ptr), sizeof (start_ptr), &(best_match), sizeof (best_match), &(buf), sizeof (buf), &(start), sizeof (start), &(i), sizeof (i), &(patterns), sizeof (patterns), &(pcount), sizeof (pcount), &(best_len), sizeof (best_len), &(buflim), sizeof (buflim), &(backref), sizeof (backref), &(eol), sizeof (eol), &(mb_start), sizeof (mb_start), &(kwset_exact_matches), sizeof (kwset_exact_matches), &(kwset), sizeof (kwset), &(ret_val), sizeof (ret_val), &(match_size), sizeof (match_size), &(size), sizeof (size), &(match_icase), sizeof (match_icase), &(eolbyte), sizeof (eolbyte)))) {
    match = beg;
    len = end - beg;
    goto assess_pattern_match;
}

//CodeSeg 1:
	      /* If -w, check if the match aligns with word boundaries.
		 We do this iteratively because:
		 (a) the line may contain more than one occurence of the
		 pattern, and
		 (b) Several alternatives in the pattern might be valid at a
		 given point, and we may need to consider a shorter one to
		 find a word boundary.  */
	      if (match_words)
		while (match <= best_match)
		  {
		    if ((match == buf || !WCHAR ((unsigned char) match[-1]))
			&& (len == end - beg - 1
			    || !WCHAR ((unsigned char) match[len])))
		      goto assess_pattern_match;
		    if (len > 0)
		      {
			/* Try a shorter length anchored at the same place. */
			--len;
			patterns[i].regexbuf.not_eol = 1;
			len = re_match (&(patterns[i].regexbuf),
					buf, match + len - beg, match - buf,
					&(patterns[i].regs));
		      }
		    if (len <= 0)
		      {
			/* Try looking further on. */
			if (match == end - 1)
			  break;
			match++;
			patterns[i].regexbuf.not_eol = 0;
			start = re_search (&(patterns[i].regexbuf),
					   buf, end - buf - 1,
					   match - buf, end - match - 1,
					   &(patterns[i].regs));
			if (start < 0)
			  break;
			len = patterns[i].regs.end[0] - start;
			match = buf + start;
		      }
		  } /* while (match <= best_match) */
	      continue;
	    assess_pattern_match:
	      if (!start_ptr)
		{
		  /* Good enough for a non-exact match.
		     No need to look at further patterns, if any.  */
		  beg = match;
		  goto success_in_len;
		}
	      if (match < best_match || (match == best_match && len > best_len))
		{
		  /* Best exact match:  leftmost, then longest.  */
		  best_match = match;
		  best_len = len;
		}
	    } /* if re_search >= 0 */
	} /* for Regex patterns.  */
	if (best_match < end)
	  {
	    /* We have found an exact match.  We were just
	       waiting for the best one (leftmost then longest).  */
	    beg = best_match;
	    len = best_len;
	    goto success_in_len;
	  }
    } /* for (beg = end ..) */

 failure:
  ret_val = -1;
  goto out;

 success:
  len = end - beg;
 success_in_len:
  *match_size = len;
  ret_val = beg - buf;
 out:
  return ret_val;
}

Testing negative cases!
Testing 0 (with abstract condition) ENVIS_NEG
Iteration 0
Running test command:
/home/ubuntu/spr-fast/tools/grep-test.py /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-8a025cf8-8f08d8e2/tempworkdir-l/src /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-8a025cf8-8f08d8e2/tempworkdir-l/tests /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-8a025cf8-8f08d8e2/tempworkdir-l 0  > __res
Opening:/tmp/neg.tmp!
NegativeBRANCH RECORD/tmp/neg.tmp!
Not caught by the negative case, give up!
APPENDING TO ISNEG:/tmp/neg.tmp!
Running test command:
/home/ubuntu/spr-fast/tools/grep-test.py /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-8a025cf8-8f08d8e2/tempworkdir-l/src /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-8a025cf8-8f08d8e2/tempworkdir-l/tests /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-8a025cf8-8f08d8e2/tempworkdir-l 0  > __res
CondTester, Testing instance id 20:
//src_file:src/dfasearch.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); void* memset(void*, int, unsigned long); 
/* dfasearch.c - searching subroutines using dfa and regex for grep.
   Copyright 1992, 1998, 2000, 2007, 2009-2010 Free Software Foundation, Inc.

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 3, or (at your option)
   any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program; if not, write to the Free Software
   Foundation, Inc., 51 Franklin Street - Fifth Floor, Boston, MA
   02110-1301, USA.  */

/* Written August 1992 by Mike Haertel. */

#include <config.h>
#include "search.h"
#include "dfa.h"

/* For -w, we also consider _ to be word constituent.  */
#define WCHAR(C) (ISALNUM(C) || (C) == '_')

/* KWset compiled pattern.  For Ecompile and Gcompile, we compile
   a list of strings, at least one of which is known to occur in
   any string matching the regexp. */
static kwset_t kwset;

/* DFA compiled regexp. */
static struct dfa dfa;

/* The Regex compiled patterns.  */
static struct patterns
{
  /* Regex compiled regexp. */
  struct re_pattern_buffer regexbuf;
  struct re_registers regs; /* This is here on account of a BRAIN-DEAD
			       Q@#%!# library interface in regex.c.  */
} patterns0;

struct patterns *patterns;
size_t pcount;

void
dfaerror (char const *mesg)
{
  error (EXIT_TROUBLE, 0, "%s", mesg);

  /* notreached */
  /* Tell static analyzers that this function does not return.  */
  abort ();
}

/* Number of compiled fixed strings known to exactly match the regexp.
   If kwsexec returns < kwset_exact_matches, then we don't need to
   call the regexp matcher at all. */
static int kwset_exact_matches;

static char const *
kwsincr_case (const char *must)
{
  const char *buf;
  size_t n;

  n = strlen (must);
#ifdef MBS_SUPPORT
  if (match_icase && MB_CUR_MAX > 1)
    buf = mbtolower (must, &n);
  else
#endif
    buf = must;
  return kwsincr (kwset, buf, n);
}

/* If the DFA turns out to have some set of fixed strings one of
   which must occur in the match, then we build a kwset matcher
   to find those strings, and thus quickly filter out impossible
   matches. */
static void
kwsmusts (void)
{
  struct dfamust const *dm;
  char const *err;

  if (dfa.musts)
    {
      kwsinit (&kwset);
      /* First, we compile in the substrings known to be exact
	 matches.  The kwset matcher will return the index
	 of the matching string that it chooses. */
      for (dm = dfa.musts; dm; dm = dm->next)
	{
	  if (!dm->exact)
	    continue;
	  ++kwset_exact_matches;
	  if ((err = kwsincr_case (dm->must)) != NULL)
	    error (EXIT_TROUBLE, 0, "%s", err);
	}
      /* Now, we compile the substrings that will require
	 the use of the regexp matcher.  */
      for (dm = dfa.musts; dm; dm = dm->next)
	{
	  if (dm->exact)
	    continue;
	  if ((err = kwsincr_case (dm->must)) != NULL)
	    error (EXIT_TROUBLE, 0, "%s", err);
	}
      if ((err = kwsprep (kwset)) != NULL)
	error (EXIT_TROUBLE, 0, "%s", err);
    }
}

void
GEAcompile (char const *pattern, size_t size, reg_syntax_t syntax_bits)
{
  const char *err;
  const char *p, *sep;
  size_t total = size;
  char *motif;

  if (match_icase)
    syntax_bits |= RE_ICASE;
  re_set_syntax (syntax_bits);
  dfasyntax (syntax_bits, match_icase, eolbyte);

  /* For GNU regex compiler we have to pass the patterns separately to detect
     errors like "[\nallo\n]\n".  The patterns here are "[", "allo" and "]"
     GNU regex should have raise a syntax error.  The same for backref, where
     the backref should have been local to each pattern.  */
  p = pattern;
  do
    {
      size_t len;
      sep = memchr (p, '\n', total);
      if (sep)
	{
	  len = sep - p;
	  sep++;
	  total -= (len + 1);
	}
      else
	{
	  len = total;
	  total = 0;
	}

      patterns = realloc (patterns, (pcount + 1) * sizeof (*patterns));
      if (patterns == NULL)
	error (EXIT_TROUBLE, errno, _("memory exhausted"));
      patterns[pcount] = patterns0;

      if ((err = re_compile_pattern (p, len,
				    &(patterns[pcount].regexbuf))) != NULL)
	error (EXIT_TROUBLE, 0, "%s", err);
      pcount++;

      p = sep;
    } while (sep && total != 0);

  /* In the match_words and match_lines cases, we use a different pattern
     for the DFA matcher that will quickly throw out cases that won't work.
     Then if DFA succeeds we do some hairy stuff using the regex matcher
     to decide whether the match should really count. */
  if (match_words || match_lines)
    {
      static char const line_beg_no_bk[] = "^(";
      static char const line_end_no_bk[] = ")$";
      static char const word_beg_no_bk[] = "(^|[^[:alnum:]_])(";
      static char const word_end_no_bk[] = ")([^[:alnum:]_]|$)";
      static char const line_beg_bk[] = "^\\(";
      static char const line_end_bk[] = "\\)$";
      static char const word_beg_bk[] = "\\(^\\|[^[:alnum:]_]\\)\\(";
      static char const word_end_bk[] = "\\)\\([^[:alnum:]_]\\|$\\)";
      int bk = !(syntax_bits & RE_NO_BK_PARENS);
      char *n = xmalloc (sizeof word_beg_bk - 1 + size + sizeof word_end_bk);

      strcpy (n, match_lines ? (bk ? line_beg_bk : line_beg_no_bk)
			     : (bk ? word_beg_bk : word_beg_no_bk));
      total = strlen(n);
      memcpy (n + total, pattern, size);
      total += size;
      strcpy (n + total, match_lines ? (bk ? line_end_bk : line_end_no_bk)
				     : (bk ? word_end_bk : word_end_no_bk));
      total += strlen (n + total);
      pattern = motif = n;
      size = total;
    }
  else
    motif = NULL;

  dfacomp (pattern, size, &dfa, 1);
  kwsmusts ();

  free(motif);
}

size_t
EGexecute (char const *buf, size_t size, size_t *match_size,
	   char const *start_ptr)
{
  char const *buflim, *beg, *end, *match, *best_match, *mb_start;
  char eol = eolbyte;
  int backref, start, len, best_len;
  struct kwsmatch kwsm;
  size_t i, ret_val;
#ifdef MBS_SUPPORT
  if (MB_CUR_MAX > 1)
    {
      if (match_icase)
        {
          /* mbtolower adds a NUL byte at the end.  That will provide
	     space for the sentinel byte dfaexec may add.  */
          char *case_buf = mbtolower (buf, &size);
	  if (start_ptr)
	    start_ptr = case_buf + (start_ptr - buf);
          buf = case_buf;
        }
    }
#endif /* MBS_SUPPORT */

  mb_start = buf;
  buflim = buf + size;

  for (beg = end = buf; end < buflim; beg = end)
    {
      if (!start_ptr)
	{
	  /* We don't care about an exact match.  */
	  if (kwset)
	    {
	      /* Find a possible match using the KWset matcher. */
	      size_t offset = kwsexec (kwset, beg, buflim - beg, &kwsm);
	      if (offset == (size_t) -1)
		goto failure;
	      beg += offset;
	      /* Narrow down to the line containing the candidate, and
		 run it through DFA. */
	      if ((end = memchr(beg, eol, buflim - beg)) != NULL)
	        end++;
              else
                end = buflim;
	      match = beg;
	      while (beg > buf && beg[-1] != eol)
		--beg;
	      if (kwsm.index < kwset_exact_matches)
                {
#ifdef MBS_SUPPORT
                  if (mb_start < beg)
                    mb_start = beg;
                  if (MB_CUR_MAX == 1 || !is_mb_middle (&mb_start, match, buflim))
#endif
                    goto success;
                }
	      if (dfaexec (&dfa, beg, (char *) end, 0, NULL, &backref) == NULL)
		continue;
	    }
	  else
	    {
	      /* No good fixed strings; start with DFA. */
	      char const *next_beg = dfaexec (&dfa, beg, (char *) buflim,
					      0, NULL, &backref);
	      if (next_beg == NULL)
		break;
	      /* Narrow down to the line we've found. */
	      beg = next_beg;
	      if ((end = memchr(beg, eol, buflim - beg)) != NULL)
	        end++;
              else
                end = buflim;
	      while (beg > buf && beg[-1] != eol)
		--beg;
	    }
	  /* Successful, no backreferences encountered! */
	  if (!backref)
	    goto success;
	}
      else
	{
	  /* We are looking for the leftmost (then longest) exact match.
	     We will go through the outer loop only once.  */
	  beg = start_ptr;
	  end = buflim;
	}

      /* If we've made it to this point, this means DFA has seen
	 a probable match, and we need to run it through Regex. */
      best_match = end;
      best_len = 0;
      for (i = 0; i < pcount; i++)
	{
	  patterns[i].regexbuf.not_eol = 0;
	  if (0 <= (start = re_search (&(patterns[i].regexbuf),
				       buf, end - buf - 1,
				       beg - buf, end - beg - 1,
				       &(patterns[i].regs))))
	    {
	      len = patterns[i].regs.end[0] - start;
	      match = buf + start;
	      if (match > best_match)
		continue;
	      if (start_ptr && !match_words)
		goto assess_pattern_match;
	      
//Patch 0:
if (((!match_lines && !match_words) || (match_lines && len == end - beg - 1)) || (__is_neg(25, &(beg), sizeof (beg), &(end), sizeof (end), &(len), sizeof (len), &(match_lines), sizeof (match_lines), &(match_words), sizeof (match_words), &(match), sizeof (match), &(start_ptr), sizeof (start_ptr), &(best_match), sizeof (best_match), &(buf), sizeof (buf), &(start), sizeof (start), &(i), sizeof (i), &(patterns), sizeof (patterns), &(pcount), sizeof (pcount), &(best_len), sizeof (best_len), &(buflim), sizeof (buflim), &(backref), sizeof (backref), &(eol), sizeof (eol), &(mb_start), sizeof (mb_start), &(kwset_exact_matches), sizeof (kwset_exact_matches), &(kwset), sizeof (kwset), &(ret_val), sizeof (ret_val), &(match_size), sizeof (match_size), &(size), sizeof (size), &(match_icase), sizeof (match_icase), &(eolbyte), sizeof (eolbyte)))) {
    match = beg;
    len = end - beg;
    goto assess_pattern_match;
}

//CodeSeg 1:
	      /* If -w, check if the match aligns with word boundaries.
		 We do this iteratively because:
		 (a) the line may contain more than one occurence of the
		 pattern, and
		 (b) Several alternatives in the pattern might be valid at a
		 given point, and we may need to consider a shorter one to
		 find a word boundary.  */
	      if (match_words)
		while (match <= best_match)
		  {
		    if ((match == buf || !WCHAR ((unsigned char) match[-1]))
			&& (len == end - beg - 1
			    || !WCHAR ((unsigned char) match[len])))
		      goto assess_pattern_match;
		    if (len > 0)
		      {
			/* Try a shorter length anchored at the same place. */
			--len;
			patterns[i].regexbuf.not_eol = 1;
			len = re_match (&(patterns[i].regexbuf),
					buf, match + len - beg, match - buf,
					&(patterns[i].regs));
		      }
		    if (len <= 0)
		      {
			/* Try looking further on. */
			if (match == end - 1)
			  break;
			match++;
			patterns[i].regexbuf.not_eol = 0;
			start = re_search (&(patterns[i].regexbuf),
					   buf, end - buf - 1,
					   match - buf, end - match - 1,
					   &(patterns[i].regs));
			if (start < 0)
			  break;
			len = patterns[i].regs.end[0] - start;
			match = buf + start;
		      }
		  } /* while (match <= best_match) */
	      continue;
	    assess_pattern_match:
	      if (!start_ptr)
		{
		  /* Good enough for a non-exact match.
		     No need to look at further patterns, if any.  */
		  beg = match;
		  goto success_in_len;
		}
	      if (match < best_match || (match == best_match && len > best_len))
		{
		  /* Best exact match:  leftmost, then longest.  */
		  best_match = match;
		  best_len = len;
		}
	    } /* if re_search >= 0 */
	} /* for Regex patterns.  */
	if (best_match < end)
	  {
	    /* We have found an exact match.  We were just
	       waiting for the best one (leftmost then longest).  */
	    beg = best_match;
	    len = best_len;
	    goto success_in_len;
	  }
    } /* for (beg = end ..) */

 failure:
  ret_val = -1;
  goto out;

 success:
  len = end - beg;
 success_in_len:
  *match_size = len;
  ret_val = beg - buf;
 out:
  return ret_val;
}

Testing negative cases!
Testing 0 (with abstract condition) ENVIS_NEG
Iteration 0
Running test command:
/home/ubuntu/spr-fast/tools/grep-test.py /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-8a025cf8-8f08d8e2/tempworkdir-l/src /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-8a025cf8-8f08d8e2/tempworkdir-l/tests /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-8a025cf8-8f08d8e2/tempworkdir-l 0  > __res
Opening:/tmp/neg.tmp!
NegativeBRANCH RECORD/tmp/neg.tmp!
APPENDING TO ISNEG:/tmp/neg.tmp!
Branch 0: 0
Iteration 1
Running test command:
/home/ubuntu/spr-fast/tools/grep-test.py /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-8a025cf8-8f08d8e2/tempworkdir-l/src /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-8a025cf8-8f08d8e2/tempworkdir-l/tests /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-8a025cf8-8f08d8e2/tempworkdir-l 0  > __res
Opening:/tmp/neg.tmp!
NegativeBRANCH RECORD/tmp/neg.tmp!
APPENDING TO ISNEG:/tmp/neg.tmp!
Branch 0: 1
Passed in iteration!
Passed Negative Cases wiht CondTestder!
Testing positive cases!
Running test command:
/home/ubuntu/spr-fast/tools/grep-test.py /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-8a025cf8-8f08d8e2/tempworkdir-l/src /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-8a025cf8-8f08d8e2/tempworkdir-l/tests /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-8a025cf8-8f08d8e2/tempworkdir-l 11  > __res
Running test command:
/home/ubuntu/spr-fast/tools/grep-test.py /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-8a025cf8-8f08d8e2/tempworkdir-l/src /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-8a025cf8-8f08d8e2/tempworkdir-l/tests /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-8a025cf8-8f08d8e2/tempworkdir-l 14  > __res
Running test command:
/home/ubuntu/spr-fast/tools/grep-test.py /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-8a025cf8-8f08d8e2/tempworkdir-l/src /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-8a025cf8-8f08d8e2/tempworkdir-l/tests /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-8a025cf8-8f08d8e2/tempworkdir-l 17  > __res
Running test command:
/home/ubuntu/spr-fast/tools/grep-test.py /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-8a025cf8-8f08d8e2/tempworkdir-l/src /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-8a025cf8-8f08d8e2/tempworkdir-l/tests /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-8a025cf8-8f08d8e2/tempworkdir-l 22  > __res
Passed Positive Cases
Collect values for post processing!
WRITING TO ISNEG:/tmp/neg.tmp!
Running test command:
/home/ubuntu/spr-fast/tools/grep-test.py /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-8a025cf8-8f08d8e2/tempworkdir-l/src /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-8a025cf8-8f08d8e2/tempworkdir-l/tests /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-8a025cf8-8f08d8e2/tempworkdir-l 0  > __res
Running test command:
/home/ubuntu/spr-fast/tools/grep-test.py /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-8a025cf8-8f08d8e2/tempworkdir-l/src /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-8a025cf8-8f08d8e2/tempworkdir-l/tests /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-8a025cf8-8f08d8e2/tempworkdir-l 11  > __res
Running test command:
/home/ubuntu/spr-fast/tools/grep-test.py /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-8a025cf8-8f08d8e2/tempworkdir-l/src /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-8a025cf8-8f08d8e2/tempworkdir-l/tests /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-8a025cf8-8f08d8e2/tempworkdir-l 14  > __res
Running test command:
/home/ubuntu/spr-fast/tools/grep-test.py /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-8a025cf8-8f08d8e2/tempworkdir-l/src /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-8a025cf8-8f08d8e2/tempworkdir-l/tests /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-8a025cf8-8f08d8e2/tempworkdir-l 17  > __res
Running test command:
/home/ubuntu/spr-fast/tools/grep-test.py /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-8a025cf8-8f08d8e2/tempworkdir-l/src /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-8a025cf8-8f08d8e2/tempworkdir-l/tests /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-8a025cf8-8f08d8e2/tempworkdir-l 22  > __res
Passed!
CondTester, Postprocessing instance id 20:
//src_file:src/dfasearch.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); void* memset(void*, int, unsigned long); 
/* dfasearch.c - searching subroutines using dfa and regex for grep.
   Copyright 1992, 1998, 2000, 2007, 2009-2010 Free Software Foundation, Inc.

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 3, or (at your option)
   any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program; if not, write to the Free Software
   Foundation, Inc., 51 Franklin Street - Fifth Floor, Boston, MA
   02110-1301, USA.  */

/* Written August 1992 by Mike Haertel. */

#include <config.h>
#include "search.h"
#include "dfa.h"

/* For -w, we also consider _ to be word constituent.  */
#define WCHAR(C) (ISALNUM(C) || (C) == '_')

/* KWset compiled pattern.  For Ecompile and Gcompile, we compile
   a list of strings, at least one of which is known to occur in
   any string matching the regexp. */
static kwset_t kwset;

/* DFA compiled regexp. */
static struct dfa dfa;

/* The Regex compiled patterns.  */
static struct patterns
{
  /* Regex compiled regexp. */
  struct re_pattern_buffer regexbuf;
  struct re_registers regs; /* This is here on account of a BRAIN-DEAD
			       Q@#%!# library interface in regex.c.  */
} patterns0;

struct patterns *patterns;
size_t pcount;

void
dfaerror (char const *mesg)
{
  error (EXIT_TROUBLE, 0, "%s", mesg);

  /* notreached */
  /* Tell static analyzers that this function does not return.  */
  abort ();
}

/* Number of compiled fixed strings known to exactly match the regexp.
   If kwsexec returns < kwset_exact_matches, then we don't need to
   call the regexp matcher at all. */
static int kwset_exact_matches;

static char const *
kwsincr_case (const char *must)
{
  const char *buf;
  size_t n;

  n = strlen (must);
#ifdef MBS_SUPPORT
  if (match_icase && MB_CUR_MAX > 1)
    buf = mbtolower (must, &n);
  else
#endif
    buf = must;
  return kwsincr (kwset, buf, n);
}

/* If the DFA turns out to have some set of fixed strings one of
   which must occur in the match, then we build a kwset matcher
   to find those strings, and thus quickly filter out impossible
   matches. */
static void
kwsmusts (void)
{
  struct dfamust const *dm;
  char const *err;

  if (dfa.musts)
    {
      kwsinit (&kwset);
      /* First, we compile in the substrings known to be exact
	 matches.  The kwset matcher will return the index
	 of the matching string that it chooses. */
      for (dm = dfa.musts; dm; dm = dm->next)
	{
	  if (!dm->exact)
	    continue;
	  ++kwset_exact_matches;
	  if ((err = kwsincr_case (dm->must)) != NULL)
	    error (EXIT_TROUBLE, 0, "%s", err);
	}
      /* Now, we compile the substrings that will require
	 the use of the regexp matcher.  */
      for (dm = dfa.musts; dm; dm = dm->next)
	{
	  if (dm->exact)
	    continue;
	  if ((err = kwsincr_case (dm->must)) != NULL)
	    error (EXIT_TROUBLE, 0, "%s", err);
	}
      if ((err = kwsprep (kwset)) != NULL)
	error (EXIT_TROUBLE, 0, "%s", err);
    }
}

void
GEAcompile (char const *pattern, size_t size, reg_syntax_t syntax_bits)
{
  const char *err;
  const char *p, *sep;
  size_t total = size;
  char *motif;

  if (match_icase)
    syntax_bits |= RE_ICASE;
  re_set_syntax (syntax_bits);
  dfasyntax (syntax_bits, match_icase, eolbyte);

  /* For GNU regex compiler we have to pass the patterns separately to detect
     errors like "[\nallo\n]\n".  The patterns here are "[", "allo" and "]"
     GNU regex should have raise a syntax error.  The same for backref, where
     the backref should have been local to each pattern.  */
  p = pattern;
  do
    {
      size_t len;
      sep = memchr (p, '\n', total);
      if (sep)
	{
	  len = sep - p;
	  sep++;
	  total -= (len + 1);
	}
      else
	{
	  len = total;
	  total = 0;
	}

      patterns = realloc (patterns, (pcount + 1) * sizeof (*patterns));
      if (patterns == NULL)
	error (EXIT_TROUBLE, errno, _("memory exhausted"));
      patterns[pcount] = patterns0;

      if ((err = re_compile_pattern (p, len,
				    &(patterns[pcount].regexbuf))) != NULL)
	error (EXIT_TROUBLE, 0, "%s", err);
      pcount++;

      p = sep;
    } while (sep && total != 0);

  /* In the match_words and match_lines cases, we use a different pattern
     for the DFA matcher that will quickly throw out cases that won't work.
     Then if DFA succeeds we do some hairy stuff using the regex matcher
     to decide whether the match should really count. */
  if (match_words || match_lines)
    {
      static char const line_beg_no_bk[] = "^(";
      static char const line_end_no_bk[] = ")$";
      static char const word_beg_no_bk[] = "(^|[^[:alnum:]_])(";
      static char const word_end_no_bk[] = ")([^[:alnum:]_]|$)";
      static char const line_beg_bk[] = "^\\(";
      static char const line_end_bk[] = "\\)$";
      static char const word_beg_bk[] = "\\(^\\|[^[:alnum:]_]\\)\\(";
      static char const word_end_bk[] = "\\)\\([^[:alnum:]_]\\|$\\)";
      int bk = !(syntax_bits & RE_NO_BK_PARENS);
      char *n = xmalloc (sizeof word_beg_bk - 1 + size + sizeof word_end_bk);

      strcpy (n, match_lines ? (bk ? line_beg_bk : line_beg_no_bk)
			     : (bk ? word_beg_bk : word_beg_no_bk));
      total = strlen(n);
      memcpy (n + total, pattern, size);
      total += size;
      strcpy (n + total, match_lines ? (bk ? line_end_bk : line_end_no_bk)
				     : (bk ? word_end_bk : word_end_no_bk));
      total += strlen (n + total);
      pattern = motif = n;
      size = total;
    }
  else
    motif = NULL;

  dfacomp (pattern, size, &dfa, 1);
  kwsmusts ();

  free(motif);
}

size_t
EGexecute (char const *buf, size_t size, size_t *match_size,
	   char const *start_ptr)
{
  char const *buflim, *beg, *end, *match, *best_match, *mb_start;
  char eol = eolbyte;
  int backref, start, len, best_len;
  struct kwsmatch kwsm;
  size_t i, ret_val;
#ifdef MBS_SUPPORT
  if (MB_CUR_MAX > 1)
    {
      if (match_icase)
        {
          /* mbtolower adds a NUL byte at the end.  That will provide
	     space for the sentinel byte dfaexec may add.  */
          char *case_buf = mbtolower (buf, &size);
	  if (start_ptr)
	    start_ptr = case_buf + (start_ptr - buf);
          buf = case_buf;
        }
    }
#endif /* MBS_SUPPORT */

  mb_start = buf;
  buflim = buf + size;

  for (beg = end = buf; end < buflim; beg = end)
    {
      if (!start_ptr)
	{
	  /* We don't care about an exact match.  */
	  if (kwset)
	    {
	      /* Find a possible match using the KWset matcher. */
	      size_t offset = kwsexec (kwset, beg, buflim - beg, &kwsm);
	      if (offset == (size_t) -1)
		goto failure;
	      beg += offset;
	      /* Narrow down to the line containing the candidate, and
		 run it through DFA. */
	      if ((end = memchr(beg, eol, buflim - beg)) != NULL)
	        end++;
              else
                end = buflim;
	      match = beg;
	      while (beg > buf && beg[-1] != eol)
		--beg;
	      if (kwsm.index < kwset_exact_matches)
                {
#ifdef MBS_SUPPORT
                  if (mb_start < beg)
                    mb_start = beg;
                  if (MB_CUR_MAX == 1 || !is_mb_middle (&mb_start, match, buflim))
#endif
                    goto success;
                }
	      if (dfaexec (&dfa, beg, (char *) end, 0, NULL, &backref) == NULL)
		continue;
	    }
	  else
	    {
	      /* No good fixed strings; start with DFA. */
	      char const *next_beg = dfaexec (&dfa, beg, (char *) buflim,
					      0, NULL, &backref);
	      if (next_beg == NULL)
		break;
	      /* Narrow down to the line we've found. */
	      beg = next_beg;
	      if ((end = memchr(beg, eol, buflim - beg)) != NULL)
	        end++;
              else
                end = buflim;
	      while (beg > buf && beg[-1] != eol)
		--beg;
	    }
	  /* Successful, no backreferences encountered! */
	  if (!backref)
	    goto success;
	}
      else
	{
	  /* We are looking for the leftmost (then longest) exact match.
	     We will go through the outer loop only once.  */
	  beg = start_ptr;
	  end = buflim;
	}

      /* If we've made it to this point, this means DFA has seen
	 a probable match, and we need to run it through Regex. */
      best_match = end;
      best_len = 0;
      for (i = 0; i < pcount; i++)
	{
	  patterns[i].regexbuf.not_eol = 0;
	  if (0 <= (start = re_search (&(patterns[i].regexbuf),
				       buf, end - buf - 1,
				       beg - buf, end - beg - 1,
				       &(patterns[i].regs))))
	    {
	      len = patterns[i].regs.end[0] - start;
	      match = buf + start;
	      if (match > best_match)
		continue;
	      if (start_ptr && !match_words)
		goto assess_pattern_match;
	      
//Patch 0:
if (((!match_lines && !match_words) || (match_lines && len == end - beg - 1)) || (__is_neg(25, &(beg), sizeof (beg), &(end), sizeof (end), &(len), sizeof (len), &(match_lines), sizeof (match_lines), &(match_words), sizeof (match_words), &(match), sizeof (match), &(start_ptr), sizeof (start_ptr), &(best_match), sizeof (best_match), &(buf), sizeof (buf), &(start), sizeof (start), &(i), sizeof (i), &(patterns), sizeof (patterns), &(pcount), sizeof (pcount), &(best_len), sizeof (best_len), &(buflim), sizeof (buflim), &(backref), sizeof (backref), &(eol), sizeof (eol), &(mb_start), sizeof (mb_start), &(kwset_exact_matches), sizeof (kwset_exact_matches), &(kwset), sizeof (kwset), &(ret_val), sizeof (ret_val), &(match_size), sizeof (match_size), &(size), sizeof (size), &(match_icase), sizeof (match_icase), &(eolbyte), sizeof (eolbyte)))) {
    match = beg;
    len = end - beg;
    goto assess_pattern_match;
}

//CodeSeg 1:
	      /* If -w, check if the match aligns with word boundaries.
		 We do this iteratively because:
		 (a) the line may contain more than one occurence of the
		 pattern, and
		 (b) Several alternatives in the pattern might be valid at a
		 given point, and we may need to consider a shorter one to
		 find a word boundary.  */
	      if (match_words)
		while (match <= best_match)
		  {
		    if ((match == buf || !WCHAR ((unsigned char) match[-1]))
			&& (len == end - beg - 1
			    || !WCHAR ((unsigned char) match[len])))
		      goto assess_pattern_match;
		    if (len > 0)
		      {
			/* Try a shorter length anchored at the same place. */
			--len;
			patterns[i].regexbuf.not_eol = 1;
			len = re_match (&(patterns[i].regexbuf),
					buf, match + len - beg, match - buf,
					&(patterns[i].regs));
		      }
		    if (len <= 0)
		      {
			/* Try looking further on. */
			if (match == end - 1)
			  break;
			match++;
			patterns[i].regexbuf.not_eol = 0;
			start = re_search (&(patterns[i].regexbuf),
					   buf, end - buf - 1,
					   match - buf, end - match - 1,
					   &(patterns[i].regs));
			if (start < 0)
			  break;
			len = patterns[i].regs.end[0] - start;
			match = buf + start;
		      }
		  } /* while (match <= best_match) */
	      continue;
	    assess_pattern_match:
	      if (!start_ptr)
		{
		  /* Good enough for a non-exact match.
		     No need to look at further patterns, if any.  */
		  beg = match;
		  goto success_in_len;
		}
	      if (match < best_match || (match == best_match && len > best_len))
		{
		  /* Best exact match:  leftmost, then longest.  */
		  best_match = match;
		  best_len = len;
		}
	    } /* if re_search >= 0 */
	} /* for Regex patterns.  */
	if (best_match < end)
	  {
	    /* We have found an exact match.  We were just
	       waiting for the best one (leftmost then longest).  */
	    beg = best_match;
	    len = best_len;
	    goto success_in_len;
	  }
    } /* for (beg = end ..) */

 failure:
  ret_val = -1;
  goto out;

 success:
  len = end - beg;
 success_in_len:
  *match_size = len;
  ret_val = beg - buf;
 out:
  return ret_val;
}

Trying a synthesis expr 1
Building:src at:
/home/ubuntu/spr-fast/tests/corebench/grep/grep-case-8a025cf8-8f08d8e2/tempworkdir-l/srcVerifing Negative cases!
Running test command:
/home/ubuntu/spr-fast/tools/grep-test.py /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-8a025cf8-8f08d8e2/tempworkdir-l/src /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-8a025cf8-8f08d8e2/tempworkdir-l/tests /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-8a025cf8-8f08d8e2/tempworkdir-l 0  > __res
Verifying positive cases
Running test command:
/home/ubuntu/spr-fast/tools/grep-test.py /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-8a025cf8-8f08d8e2/tempworkdir-l/src /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-8a025cf8-8f08d8e2/tempworkdir-l/tests /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-8a025cf8-8f08d8e2/tempworkdir-l 11  > __res
Running test command:
/home/ubuntu/spr-fast/tools/grep-test.py /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-8a025cf8-8f08d8e2/tempworkdir-l/src /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-8a025cf8-8f08d8e2/tempworkdir-l/tests /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-8a025cf8-8f08d8e2/tempworkdir-l 14  > __res
Running test command:
/home/ubuntu/spr-fast/tools/grep-test.py /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-8a025cf8-8f08d8e2/tempworkdir-l/src /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-8a025cf8-8f08d8e2/tempworkdir-l/tests /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-8a025cf8-8f08d8e2/tempworkdir-l 17  > __res
Running test command:
/home/ubuntu/spr-fast/tools/grep-test.py /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-8a025cf8-8f08d8e2/tempworkdir-l/src /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-8a025cf8-8f08d8e2/tempworkdir-l/tests /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-8a025cf8-8f08d8e2/tempworkdir-l 22  > __res
Passed Positive Cases
Passed!
Passed with updated best score 19999980.000000
a batched test job starts!
Building merged code:
src_file: src/dfasearch.c
full src: int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); void* memset(void*, int, unsigned long); 
/* dfasearch.c - searching subroutines using dfa and regex for grep.
   Copyright 1992, 1998, 2000, 2007, 2009-2010 Free Software Foundation, Inc.

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 3, or (at your option)
   any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program; if not, write to the Free Software
   Foundation, Inc., 51 Franklin Street - Fifth Floor, Boston, MA
   02110-1301, USA.  */

/* Written August 1992 by Mike Haertel. */

#include <config.h>
#include "search.h"
#include "dfa.h"

/* For -w, we also consider _ to be word constituent.  */
#define WCHAR(C) (ISALNUM(C) || (C) == '_')

/* KWset compiled pattern.  For Ecompile and Gcompile, we compile
   a list of strings, at least one of which is known to occur in
   any string matching the regexp. */
static kwset_t kwset;

/* DFA compiled regexp. */
static struct dfa dfa;

/* The Regex compiled patterns.  */
static struct patterns
{
  /* Regex compiled regexp. */
  struct re_pattern_buffer regexbuf;
  struct re_registers regs; /* This is here on account of a BRAIN-DEAD
			       Q@#%!# library interface in regex.c.  */
} patterns0;

struct patterns *patterns;
size_t pcount;

void
dfaerror (char const *mesg)
{
  error (EXIT_TROUBLE, 0, "%s", mesg);

  /* notreached */
  /* Tell static analyzers that this function does not return.  */
  abort ();
}

/* Number of compiled fixed strings known to exactly match the regexp.
   If kwsexec returns < kwset_exact_matches, then we don't need to
   call the regexp matcher at all. */
static int kwset_exact_matches;

static char const *
kwsincr_case (const char *must)
{
  const char *buf;
  size_t n;

  n = strlen (must);
#ifdef MBS_SUPPORT
  if (match_icase && MB_CUR_MAX > 1)
    buf = mbtolower (must, &n);
  else
#endif
    buf = must;
  return kwsincr (kwset, buf, n);
}

/* If the DFA turns out to have some set of fixed strings one of
   which must occur in the match, then we build a kwset matcher
   to find those strings, and thus quickly filter out impossible
   matches. */
static void
kwsmusts (void)
{
  struct dfamust const *dm;
  char const *err;

  if (dfa.musts)
    {
      kwsinit (&kwset);
      /* First, we compile in the substrings known to be exact
	 matches.  The kwset matcher will return the index
	 of the matching string that it chooses. */
      for (dm = dfa.musts; dm; dm = dm->next)
	{
	  if (!dm->exact)
	    continue;
	  ++kwset_exact_matches;
	  if ((err = kwsincr_case (dm->must)) != NULL)
	    error (EXIT_TROUBLE, 0, "%s", err);
	}
      /* Now, we compile the substrings that will require
	 the use of the regexp matcher.  */
      for (dm = dfa.musts; dm; dm = dm->next)
	{
	  if (dm->exact)
	    continue;
	  if ((err = kwsincr_case (dm->must)) != NULL)
	    error (EXIT_TROUBLE, 0, "%s", err);
	}
      if ((err = kwsprep (kwset)) != NULL)
	error (EXIT_TROUBLE, 0, "%s", err);
    }
}

void
GEAcompile (char const *pattern, size_t size, reg_syntax_t syntax_bits)
{
  const char *err;
  const char *p, *sep;
  size_t total = size;
  char *motif;

  if (match_icase)
    syntax_bits |= RE_ICASE;
  re_set_syntax (syntax_bits);
  dfasyntax (syntax_bits, match_icase, eolbyte);

  /* For GNU regex compiler we have to pass the patterns separately to detect
     errors like "[\nallo\n]\n".  The patterns here are "[", "allo" and "]"
     GNU regex should have raise a syntax error.  The same for backref, where
     the backref should have been local to each pattern.  */
  p = pattern;
  do
    {
      size_t len;
      sep = memchr (p, '\n', total);
      if (sep)
	{
	  len = sep - p;
	  sep++;
	  total -= (len + 1);
	}
      else
	{
	  len = total;
	  total = 0;
	}

      patterns = realloc (patterns, (pcount + 1) * sizeof (*patterns));
      if (patterns == NULL)
	error (EXIT_TROUBLE, errno, _("memory exhausted"));
      patterns[pcount] = patterns0;

      if ((err = re_compile_pattern (p, len,
				    &(patterns[pcount].regexbuf))) != NULL)
	error (EXIT_TROUBLE, 0, "%s", err);
      pcount++;

      p = sep;
    } while (sep && total != 0);

  /* In the match_words and match_lines cases, we use a different pattern
     for the DFA matcher that will quickly throw out cases that won't work.
     Then if DFA succeeds we do some hairy stuff using the regex matcher
     to decide whether the match should really count. */
  if (match_words || match_lines)
    {
      static char const line_beg_no_bk[] = "^(";
      static char const line_end_no_bk[] = ")$";
      static char const word_beg_no_bk[] = "(^|[^[:alnum:]_])(";
      static char const word_end_no_bk[] = ")([^[:alnum:]_]|$)";
      static char const line_beg_bk[] = "^\\(";
      static char const line_end_bk[] = "\\)$";
      static char const word_beg_bk[] = "\\(^\\|[^[:alnum:]_]\\)\\(";
      static char const word_end_bk[] = "\\)\\([^[:alnum:]_]\\|$\\)";
      int bk = !(syntax_bits & RE_NO_BK_PARENS);
      char *n = xmalloc (sizeof word_beg_bk - 1 + size + sizeof word_end_bk);

      strcpy (n, match_lines ? (bk ? line_beg_bk : line_beg_no_bk)
			     : (bk ? word_beg_bk : word_beg_no_bk));
      total = strlen(n);
      memcpy (n + total, pattern, size);
      total += size;
      strcpy (n + total, match_lines ? (bk ? line_end_bk : line_end_no_bk)
				     : (bk ? word_end_bk : word_end_no_bk));
      total += strlen (n + total);
      pattern = motif = n;
      size = total;
    }
  else
    motif = NULL;

  dfacomp (pattern, size, &dfa, 1);
  kwsmusts ();

  free(motif);
}

size_t
EGexecute (char const *buf, size_t size, size_t *match_size,
	   char const *start_ptr)
{
  char const *buflim, *beg, *end, *match, *best_match, *mb_start;
  char eol = eolbyte;
  int backref, start, len, best_len;
  struct kwsmatch kwsm;
  size_t i, ret_val;
#ifdef MBS_SUPPORT
  if (MB_CUR_MAX > 1)
    {
      if (match_icase)
        {
          /* mbtolower adds a NUL byte at the end.  That will provide
	     space for the sentinel byte dfaexec may add.  */
          char *case_buf = mbtolower (buf, &size);
	  if (start_ptr)
	    start_ptr = case_buf + (start_ptr - buf);
          buf = case_buf;
        }
    }
#endif /* MBS_SUPPORT */

  mb_start = buf;
  buflim = buf + size;

  for (beg = end = buf; end < buflim; beg = end)
    {
      if (!start_ptr)
	{
	  /* We don't care about an exact match.  */
	  if (kwset)
	    {
	      /* Find a possible match using the KWset matcher. */
	      size_t offset = kwsexec (kwset, beg, buflim - beg, &kwsm);
	      if (offset == (size_t) -1)
		goto failure;
	      beg += offset;
	      /* Narrow down to the line containing the candidate, and
		 run it through DFA. */
	      if ((end = memchr(beg, eol, buflim - beg)) != NULL)
	        end++;
              else
                end = buflim;
	      match = beg;
	      while (beg > buf && beg[-1] != eol)
		--beg;
	      if (kwsm.index < kwset_exact_matches)
                {
#ifdef MBS_SUPPORT
                  if (mb_start < beg)
                    mb_start = beg;
                  if (MB_CUR_MAX == 1 || !is_mb_middle (&mb_start, match, buflim))
#endif
                    goto success;
                }
	      if (dfaexec (&dfa, beg, (char *) end, 0, NULL, &backref) == NULL)
		continue;
	    }
	  else
	    {
	      /* No good fixed strings; start with DFA. */
	      char const *next_beg = dfaexec (&dfa, beg, (char *) buflim,
					      0, NULL, &backref);
	      if (next_beg == NULL)
		break;
	      /* Narrow down to the line we've found. */
	      beg = next_beg;
	      if ((end = memchr(beg, eol, buflim - beg)) != NULL)
	        end++;
              else
                end = buflim;
	      while (beg > buf && beg[-1] != eol)
		--beg;
	    }
	  /* Successful, no backreferences encountered! */
	  if (!backref)
	    goto success;
	}
      else
	{
	  /* We are looking for the leftmost (then longest) exact match.
	     We will go through the outer loop only once.  */
	  beg = start_ptr;
	  end = buflim;
	}

      /* If we've made it to this point, this means DFA has seen
	 a probable match, and we need to run it through Regex. */
      best_match = end;
      best_len = 0;
      for (i = 0; i < pcount; i++)
	{
	  patterns[i].regexbuf.not_eol = 0;
	  if (0 <= (start = re_search (&(patterns[i].regexbuf),
				       buf, end - buf - 1,
				       beg - buf, end - beg - 1,
				       &(patterns[i].regs))))
	    {
	      len = patterns[i].regs.end[0] - start;
	      match = buf + start;
	      if (match > best_match)
		continue;
	      if (start_ptr && !match_words)
		goto assess_pattern_match;
	      if ((!match_lines && !match_words)
		  || (match_lines && len == end - beg - 1))
		{
		  match = beg;
		  len = end - beg;
		  goto assess_pattern_match;
		}
	      /* If -w, check if the match aligns with word boundaries.
		 We do this iteratively because:
		 (a) the line may contain more than one occurence of the
		 pattern, and
		 (b) Several alternatives in the pattern might be valid at a
		 given point, and we may need to consider a shorter one to
		 find a word boundary.  */
	      //prophet generated patch
	      if (__get_mutant()==0) {
	      if ((match_words) && !(__is_neg(25, &(match_words), sizeof (match_words), &(match), sizeof (match), &(best_match), sizeof (best_match), &(buf), sizeof (buf), &(beg), sizeof (beg), &(end), sizeof (end), &(len), sizeof (len), &(i), sizeof (i), &(patterns), sizeof (patterns), &(match_lines), sizeof (match_lines), &(start_ptr), sizeof (start_ptr), &(start), sizeof (start), &(pcount), sizeof (pcount), &(best_len), sizeof (best_len), &(buflim), sizeof (buflim), &(backref), sizeof (backref), &(eol), sizeof (eol), &(ret_val), sizeof (ret_val), &(match_size), sizeof (match_size), &(mb_start), sizeof (mb_start), &(kwset_exact_matches), sizeof (kwset_exact_matches), &(kwset), sizeof (kwset), &(size), sizeof (size), &(match_icase), sizeof (match_icase), &(eolbyte), sizeof (eolbyte))))
	          while (match <= best_match)
	              {
	                  if ((match == buf || !((1 && ((*__ctype_b_loc())[(int)(((unsigned char)match[-1]))] & (unsigned short)_ISalnum)) || ((unsigned char)match[-1]) == '_')) && (len == end - beg - 1 || !((1 && ((*__ctype_b_loc())[(int)(((unsigned char)match[len]))] & (unsigned short)_ISalnum)) || ((unsigned char)match[len]) == '_')))
	                      goto assess_pattern_match;
	                  if (len > 0) {
	                      --len;
	                      patterns[i].regexbuf.not_eol = 1;
	                      len = rpl_re_match(&(patterns[i].regexbuf), buf, match + len - beg, match - buf, &(patterns[i].regs));
	                  }
	                  if (len <= 0) {
	                      if (match == end - 1)
	                          break;
	                      match++;
	                      patterns[i].regexbuf.not_eol = 0;
	                      start = rpl_re_search(&(patterns[i].regexbuf), buf, end - buf - 1, match - buf, end - match - 1, &(patterns[i].regs));
	                      if (start < 0)
	                          break;
	                      len = patterns[i].regs.end[0] - start;
	                      match = buf + start;
	                  }
	              }
	      }
	      else if (__get_mutant()==1) {
	      if ((match_words) || (__is_neg(25, &(match_words), sizeof (match_words), &(match), sizeof (match), &(best_match), sizeof (best_match), &(buf), sizeof (buf), &(beg), sizeof (beg), &(end), sizeof (end), &(len), sizeof (len), &(i), sizeof (i), &(patterns), sizeof (patterns), &(match_lines), sizeof (match_lines), &(start_ptr), sizeof (start_ptr), &(start), sizeof (start), &(pcount), sizeof (pcount), &(best_len), sizeof (best_len), &(buflim), sizeof (buflim), &(backref), sizeof (backref), &(eol), sizeof (eol), &(ret_val), sizeof (ret_val), &(match_size), sizeof (match_size), &(mb_start), sizeof (mb_start), &(kwset_exact_matches), sizeof (kwset_exact_matches), &(kwset), sizeof (kwset), &(size), sizeof (size), &(match_icase), sizeof (match_icase), &(eolbyte), sizeof (eolbyte))))
	          while (match <= best_match)
	              {
	                  if ((match == buf || !((1 && ((*__ctype_b_loc())[(int)(((unsigned char)match[-1]))] & (unsigned short)_ISalnum)) || ((unsigned char)match[-1]) == '_')) && (len == end - beg - 1 || !((1 && ((*__ctype_b_loc())[(int)(((unsigned char)match[len]))] & (unsigned short)_ISalnum)) || ((unsigned char)match[len]) == '_')))
	                      goto assess_pattern_match;
	                  if (len > 0) {
	                      --len;
	                      patterns[i].regexbuf.not_eol = 1;
	                      len = rpl_re_match(&(patterns[i].regexbuf), buf, match + len - beg, match - buf, &(patterns[i].regs));
	                  }
	                  if (len <= 0) {
	                      if (match == end - 1)
	                          break;
	                      match++;
	                      patterns[i].regexbuf.not_eol = 0;
	                      start = rpl_re_search(&(patterns[i].regexbuf), buf, end - buf - 1, match - buf, end - match - 1, &(patterns[i].regs));
	                      if (start < 0)
	                          break;
	                      len = patterns[i].regs.end[0] - start;
	                      match = buf + start;
	                  }
	              }
	      }
	      continue;
	    assess_pattern_match:
	      if (!start_ptr)
		{
		  /* Good enough for a non-exact match.
		     No need to look at further patterns, if any.  */
		  beg = match;
		  goto success_in_len;
		}
	      if (match < best_match || (match == best_match && len > best_len))
		{
		  /* Best exact match:  leftmost, then longest.  */
		  best_match = match;
		  best_len = len;
		}
	    } /* if re_search >= 0 */
	} /* for Regex patterns.  */
	if (best_match < end)
	  {
	    /* We have found an exact match.  We were just
	       waiting for the best one (leftmost then longest).  */
	    beg = best_match;
	    len = best_len;
	    goto success_in_len;
	  }
    } /* for (beg = end ..) */

 failure:
  ret_val = -1;
  goto out;

 success:
  len = end - beg;
 success_in_len:
  *match_size = len;
  ret_val = beg - buf;
 out:
  return ret_val;
}

Building:src at:
/home/ubuntu/spr-fast/tests/corebench/grep/grep-case-8a025cf8-8f08d8e2/tempworkdir-l/srcMerged code building succ, going to invoke tester!
CondTester, Testing instance id 14:
//src_file:src/dfasearch.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); void* memset(void*, int, unsigned long); 
/* dfasearch.c - searching subroutines using dfa and regex for grep.
   Copyright 1992, 1998, 2000, 2007, 2009-2010 Free Software Foundation, Inc.

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 3, or (at your option)
   any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program; if not, write to the Free Software
   Foundation, Inc., 51 Franklin Street - Fifth Floor, Boston, MA
   02110-1301, USA.  */

/* Written August 1992 by Mike Haertel. */

#include <config.h>
#include "search.h"
#include "dfa.h"

/* For -w, we also consider _ to be word constituent.  */
#define WCHAR(C) (ISALNUM(C) || (C) == '_')

/* KWset compiled pattern.  For Ecompile and Gcompile, we compile
   a list of strings, at least one of which is known to occur in
   any string matching the regexp. */
static kwset_t kwset;

/* DFA compiled regexp. */
static struct dfa dfa;

/* The Regex compiled patterns.  */
static struct patterns
{
  /* Regex compiled regexp. */
  struct re_pattern_buffer regexbuf;
  struct re_registers regs; /* This is here on account of a BRAIN-DEAD
			       Q@#%!# library interface in regex.c.  */
} patterns0;

struct patterns *patterns;
size_t pcount;

void
dfaerror (char const *mesg)
{
  error (EXIT_TROUBLE, 0, "%s", mesg);

  /* notreached */
  /* Tell static analyzers that this function does not return.  */
  abort ();
}

/* Number of compiled fixed strings known to exactly match the regexp.
   If kwsexec returns < kwset_exact_matches, then we don't need to
   call the regexp matcher at all. */
static int kwset_exact_matches;

static char const *
kwsincr_case (const char *must)
{
  const char *buf;
  size_t n;

  n = strlen (must);
#ifdef MBS_SUPPORT
  if (match_icase && MB_CUR_MAX > 1)
    buf = mbtolower (must, &n);
  else
#endif
    buf = must;
  return kwsincr (kwset, buf, n);
}

/* If the DFA turns out to have some set of fixed strings one of
   which must occur in the match, then we build a kwset matcher
   to find those strings, and thus quickly filter out impossible
   matches. */
static void
kwsmusts (void)
{
  struct dfamust const *dm;
  char const *err;

  if (dfa.musts)
    {
      kwsinit (&kwset);
      /* First, we compile in the substrings known to be exact
	 matches.  The kwset matcher will return the index
	 of the matching string that it chooses. */
      for (dm = dfa.musts; dm; dm = dm->next)
	{
	  if (!dm->exact)
	    continue;
	  ++kwset_exact_matches;
	  if ((err = kwsincr_case (dm->must)) != NULL)
	    error (EXIT_TROUBLE, 0, "%s", err);
	}
      /* Now, we compile the substrings that will require
	 the use of the regexp matcher.  */
      for (dm = dfa.musts; dm; dm = dm->next)
	{
	  if (dm->exact)
	    continue;
	  if ((err = kwsincr_case (dm->must)) != NULL)
	    error (EXIT_TROUBLE, 0, "%s", err);
	}
      if ((err = kwsprep (kwset)) != NULL)
	error (EXIT_TROUBLE, 0, "%s", err);
    }
}

void
GEAcompile (char const *pattern, size_t size, reg_syntax_t syntax_bits)
{
  const char *err;
  const char *p, *sep;
  size_t total = size;
  char *motif;

  if (match_icase)
    syntax_bits |= RE_ICASE;
  re_set_syntax (syntax_bits);
  dfasyntax (syntax_bits, match_icase, eolbyte);

  /* For GNU regex compiler we have to pass the patterns separately to detect
     errors like "[\nallo\n]\n".  The patterns here are "[", "allo" and "]"
     GNU regex should have raise a syntax error.  The same for backref, where
     the backref should have been local to each pattern.  */
  p = pattern;
  do
    {
      size_t len;
      sep = memchr (p, '\n', total);
      if (sep)
	{
	  len = sep - p;
	  sep++;
	  total -= (len + 1);
	}
      else
	{
	  len = total;
	  total = 0;
	}

      patterns = realloc (patterns, (pcount + 1) * sizeof (*patterns));
      if (patterns == NULL)
	error (EXIT_TROUBLE, errno, _("memory exhausted"));
      patterns[pcount] = patterns0;

      if ((err = re_compile_pattern (p, len,
				    &(patterns[pcount].regexbuf))) != NULL)
	error (EXIT_TROUBLE, 0, "%s", err);
      pcount++;

      p = sep;
    } while (sep && total != 0);

  /* In the match_words and match_lines cases, we use a different pattern
     for the DFA matcher that will quickly throw out cases that won't work.
     Then if DFA succeeds we do some hairy stuff using the regex matcher
     to decide whether the match should really count. */
  if (match_words || match_lines)
    {
      static char const line_beg_no_bk[] = "^(";
      static char const line_end_no_bk[] = ")$";
      static char const word_beg_no_bk[] = "(^|[^[:alnum:]_])(";
      static char const word_end_no_bk[] = ")([^[:alnum:]_]|$)";
      static char const line_beg_bk[] = "^\\(";
      static char const line_end_bk[] = "\\)$";
      static char const word_beg_bk[] = "\\(^\\|[^[:alnum:]_]\\)\\(";
      static char const word_end_bk[] = "\\)\\([^[:alnum:]_]\\|$\\)";
      int bk = !(syntax_bits & RE_NO_BK_PARENS);
      char *n = xmalloc (sizeof word_beg_bk - 1 + size + sizeof word_end_bk);

      strcpy (n, match_lines ? (bk ? line_beg_bk : line_beg_no_bk)
			     : (bk ? word_beg_bk : word_beg_no_bk));
      total = strlen(n);
      memcpy (n + total, pattern, size);
      total += size;
      strcpy (n + total, match_lines ? (bk ? line_end_bk : line_end_no_bk)
				     : (bk ? word_end_bk : word_end_no_bk));
      total += strlen (n + total);
      pattern = motif = n;
      size = total;
    }
  else
    motif = NULL;

  dfacomp (pattern, size, &dfa, 1);
  kwsmusts ();

  free(motif);
}

size_t
EGexecute (char const *buf, size_t size, size_t *match_size,
	   char const *start_ptr)
{
  char const *buflim, *beg, *end, *match, *best_match, *mb_start;
  char eol = eolbyte;
  int backref, start, len, best_len;
  struct kwsmatch kwsm;
  size_t i, ret_val;
#ifdef MBS_SUPPORT
  if (MB_CUR_MAX > 1)
    {
      if (match_icase)
        {
          /* mbtolower adds a NUL byte at the end.  That will provide
	     space for the sentinel byte dfaexec may add.  */
          char *case_buf = mbtolower (buf, &size);
	  if (start_ptr)
	    start_ptr = case_buf + (start_ptr - buf);
          buf = case_buf;
        }
    }
#endif /* MBS_SUPPORT */

  mb_start = buf;
  buflim = buf + size;

  for (beg = end = buf; end < buflim; beg = end)
    {
      if (!start_ptr)
	{
	  /* We don't care about an exact match.  */
	  if (kwset)
	    {
	      /* Find a possible match using the KWset matcher. */
	      size_t offset = kwsexec (kwset, beg, buflim - beg, &kwsm);
	      if (offset == (size_t) -1)
		goto failure;
	      beg += offset;
	      /* Narrow down to the line containing the candidate, and
		 run it through DFA. */
	      if ((end = memchr(beg, eol, buflim - beg)) != NULL)
	        end++;
              else
                end = buflim;
	      match = beg;
	      while (beg > buf && beg[-1] != eol)
		--beg;
	      if (kwsm.index < kwset_exact_matches)
                {
#ifdef MBS_SUPPORT
                  if (mb_start < beg)
                    mb_start = beg;
                  if (MB_CUR_MAX == 1 || !is_mb_middle (&mb_start, match, buflim))
#endif
                    goto success;
                }
	      if (dfaexec (&dfa, beg, (char *) end, 0, NULL, &backref) == NULL)
		continue;
	    }
	  else
	    {
	      /* No good fixed strings; start with DFA. */
	      char const *next_beg = dfaexec (&dfa, beg, (char *) buflim,
					      0, NULL, &backref);
	      if (next_beg == NULL)
		break;
	      /* Narrow down to the line we've found. */
	      beg = next_beg;
	      if ((end = memchr(beg, eol, buflim - beg)) != NULL)
	        end++;
              else
                end = buflim;
	      while (beg > buf && beg[-1] != eol)
		--beg;
	    }
	  /* Successful, no backreferences encountered! */
	  if (!backref)
	    goto success;
	}
      else
	{
	  /* We are looking for the leftmost (then longest) exact match.
	     We will go through the outer loop only once.  */
	  beg = start_ptr;
	  end = buflim;
	}

      /* If we've made it to this point, this means DFA has seen
	 a probable match, and we need to run it through Regex. */
      best_match = end;
      best_len = 0;
      for (i = 0; i < pcount; i++)
	{
	  patterns[i].regexbuf.not_eol = 0;
	  if (0 <= (start = re_search (&(patterns[i].regexbuf),
				       buf, end - buf - 1,
				       beg - buf, end - beg - 1,
				       &(patterns[i].regs))))
	    {
	      len = patterns[i].regs.end[0] - start;
	      match = buf + start;
	      if (match > best_match)
		continue;
	      if (start_ptr && !match_words)
		goto assess_pattern_match;
	      if ((!match_lines && !match_words)
		  || (match_lines && len == end - beg - 1))
		{
		  match = beg;
		  len = end - beg;
		  goto assess_pattern_match;
		}
	      /* If -w, check if the match aligns with word boundaries.
		 We do this iteratively because:
		 (a) the line may contain more than one occurence of the
		 pattern, and
		 (b) Several alternatives in the pattern might be valid at a
		 given point, and we may need to consider a shorter one to
		 find a word boundary.  */
	      
//Patch 0:
if ((match_words) && !(__is_neg(25, &(match_words), sizeof (match_words), &(match), sizeof (match), &(best_match), sizeof (best_match), &(buf), sizeof (buf), &(beg), sizeof (beg), &(end), sizeof (end), &(len), sizeof (len), &(i), sizeof (i), &(patterns), sizeof (patterns), &(match_lines), sizeof (match_lines), &(start_ptr), sizeof (start_ptr), &(start), sizeof (start), &(pcount), sizeof (pcount), &(best_len), sizeof (best_len), &(buflim), sizeof (buflim), &(backref), sizeof (backref), &(eol), sizeof (eol), &(ret_val), sizeof (ret_val), &(match_size), sizeof (match_size), &(mb_start), sizeof (mb_start), &(kwset_exact_matches), sizeof (kwset_exact_matches), &(kwset), sizeof (kwset), &(size), sizeof (size), &(match_icase), sizeof (match_icase), &(eolbyte), sizeof (eolbyte))))
    while (match <= best_match)
        {
            if ((match == buf || !((1 && ((*__ctype_b_loc())[(int)(((unsigned char)match[-1]))] & (unsigned short)_ISalnum)) || ((unsigned char)match[-1]) == '_')) && (len == end - beg - 1 || !((1 && ((*__ctype_b_loc())[(int)(((unsigned char)match[len]))] & (unsigned short)_ISalnum)) || ((unsigned char)match[len]) == '_')))
                goto assess_pattern_match;
            if (len > 0) {
                --len;
                patterns[i].regexbuf.not_eol = 1;
                len = rpl_re_match(&(patterns[i].regexbuf), buf, match + len - beg, match - buf, &(patterns[i].regs));
            }
            if (len <= 0) {
                if (match == end - 1)
                    break;
                match++;
                patterns[i].regexbuf.not_eol = 0;
                start = rpl_re_search(&(patterns[i].regexbuf), buf, end - buf - 1, match - buf, end - match - 1, &(patterns[i].regs));
                if (start < 0)
                    break;
                len = patterns[i].regs.end[0] - start;
                match = buf + start;
            }
        }

//CodeSeg 1:
	      continue;
	    assess_pattern_match:
	      if (!start_ptr)
		{
		  /* Good enough for a non-exact match.
		     No need to look at further patterns, if any.  */
		  beg = match;
		  goto success_in_len;
		}
	      if (match < best_match || (match == best_match && len > best_len))
		{
		  /* Best exact match:  leftmost, then longest.  */
		  best_match = match;
		  best_len = len;
		}
	    } /* if re_search >= 0 */
	} /* for Regex patterns.  */
	if (best_match < end)
	  {
	    /* We have found an exact match.  We were just
	       waiting for the best one (leftmost then longest).  */
	    beg = best_match;
	    len = best_len;
	    goto success_in_len;
	  }
    } /* for (beg = end ..) */

 failure:
  ret_val = -1;
  goto out;

 success:
  len = end - beg;
 success_in_len:
  *match_size = len;
  ret_val = beg - buf;
 out:
  return ret_val;
}

Testing negative cases!
Testing 0 (with abstract condition) ENVIS_NEG
Iteration 0
Running test command:
/home/ubuntu/spr-fast/tools/grep-test.py /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-8a025cf8-8f08d8e2/tempworkdir-l/src /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-8a025cf8-8f08d8e2/tempworkdir-l/tests /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-8a025cf8-8f08d8e2/tempworkdir-l 0  > __res
Opening:/tmp/neg.tmp!
NegativeBRANCH RECORD/tmp/neg.tmp!
APPENDING TO ISNEG:/tmp/neg.tmp!
Branch 0: 0
Iteration 1
Running test command:
/home/ubuntu/spr-fast/tools/grep-test.py /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-8a025cf8-8f08d8e2/tempworkdir-l/src /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-8a025cf8-8f08d8e2/tempworkdir-l/tests /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-8a025cf8-8f08d8e2/tempworkdir-l 0  > __res
Opening:/tmp/neg.tmp!
NegativeBRANCH RECORD/tmp/neg.tmp!
APPENDING TO ISNEG:/tmp/neg.tmp!
Branch 0: 1
Running test command:
/home/ubuntu/spr-fast/tools/grep-test.py /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-8a025cf8-8f08d8e2/tempworkdir-l/src /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-8a025cf8-8f08d8e2/tempworkdir-l/tests /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-8a025cf8-8f08d8e2/tempworkdir-l 0  > __res
CondTester, Testing instance id 15:
//src_file:src/dfasearch.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); void* memset(void*, int, unsigned long); 
/* dfasearch.c - searching subroutines using dfa and regex for grep.
   Copyright 1992, 1998, 2000, 2007, 2009-2010 Free Software Foundation, Inc.

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 3, or (at your option)
   any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program; if not, write to the Free Software
   Foundation, Inc., 51 Franklin Street - Fifth Floor, Boston, MA
   02110-1301, USA.  */

/* Written August 1992 by Mike Haertel. */

#include <config.h>
#include "search.h"
#include "dfa.h"

/* For -w, we also consider _ to be word constituent.  */
#define WCHAR(C) (ISALNUM(C) || (C) == '_')

/* KWset compiled pattern.  For Ecompile and Gcompile, we compile
   a list of strings, at least one of which is known to occur in
   any string matching the regexp. */
static kwset_t kwset;

/* DFA compiled regexp. */
static struct dfa dfa;

/* The Regex compiled patterns.  */
static struct patterns
{
  /* Regex compiled regexp. */
  struct re_pattern_buffer regexbuf;
  struct re_registers regs; /* This is here on account of a BRAIN-DEAD
			       Q@#%!# library interface in regex.c.  */
} patterns0;

struct patterns *patterns;
size_t pcount;

void
dfaerror (char const *mesg)
{
  error (EXIT_TROUBLE, 0, "%s", mesg);

  /* notreached */
  /* Tell static analyzers that this function does not return.  */
  abort ();
}

/* Number of compiled fixed strings known to exactly match the regexp.
   If kwsexec returns < kwset_exact_matches, then we don't need to
   call the regexp matcher at all. */
static int kwset_exact_matches;

static char const *
kwsincr_case (const char *must)
{
  const char *buf;
  size_t n;

  n = strlen (must);
#ifdef MBS_SUPPORT
  if (match_icase && MB_CUR_MAX > 1)
    buf = mbtolower (must, &n);
  else
#endif
    buf = must;
  return kwsincr (kwset, buf, n);
}

/* If the DFA turns out to have some set of fixed strings one of
   which must occur in the match, then we build a kwset matcher
   to find those strings, and thus quickly filter out impossible
   matches. */
static void
kwsmusts (void)
{
  struct dfamust const *dm;
  char const *err;

  if (dfa.musts)
    {
      kwsinit (&kwset);
      /* First, we compile in the substrings known to be exact
	 matches.  The kwset matcher will return the index
	 of the matching string that it chooses. */
      for (dm = dfa.musts; dm; dm = dm->next)
	{
	  if (!dm->exact)
	    continue;
	  ++kwset_exact_matches;
	  if ((err = kwsincr_case (dm->must)) != NULL)
	    error (EXIT_TROUBLE, 0, "%s", err);
	}
      /* Now, we compile the substrings that will require
	 the use of the regexp matcher.  */
      for (dm = dfa.musts; dm; dm = dm->next)
	{
	  if (dm->exact)
	    continue;
	  if ((err = kwsincr_case (dm->must)) != NULL)
	    error (EXIT_TROUBLE, 0, "%s", err);
	}
      if ((err = kwsprep (kwset)) != NULL)
	error (EXIT_TROUBLE, 0, "%s", err);
    }
}

void
GEAcompile (char const *pattern, size_t size, reg_syntax_t syntax_bits)
{
  const char *err;
  const char *p, *sep;
  size_t total = size;
  char *motif;

  if (match_icase)
    syntax_bits |= RE_ICASE;
  re_set_syntax (syntax_bits);
  dfasyntax (syntax_bits, match_icase, eolbyte);

  /* For GNU regex compiler we have to pass the patterns separately to detect
     errors like "[\nallo\n]\n".  The patterns here are "[", "allo" and "]"
     GNU regex should have raise a syntax error.  The same for backref, where
     the backref should have been local to each pattern.  */
  p = pattern;
  do
    {
      size_t len;
      sep = memchr (p, '\n', total);
      if (sep)
	{
	  len = sep - p;
	  sep++;
	  total -= (len + 1);
	}
      else
	{
	  len = total;
	  total = 0;
	}

      patterns = realloc (patterns, (pcount + 1) * sizeof (*patterns));
      if (patterns == NULL)
	error (EXIT_TROUBLE, errno, _("memory exhausted"));
      patterns[pcount] = patterns0;

      if ((err = re_compile_pattern (p, len,
				    &(patterns[pcount].regexbuf))) != NULL)
	error (EXIT_TROUBLE, 0, "%s", err);
      pcount++;

      p = sep;
    } while (sep && total != 0);

  /* In the match_words and match_lines cases, we use a different pattern
     for the DFA matcher that will quickly throw out cases that won't work.
     Then if DFA succeeds we do some hairy stuff using the regex matcher
     to decide whether the match should really count. */
  if (match_words || match_lines)
    {
      static char const line_beg_no_bk[] = "^(";
      static char const line_end_no_bk[] = ")$";
      static char const word_beg_no_bk[] = "(^|[^[:alnum:]_])(";
      static char const word_end_no_bk[] = ")([^[:alnum:]_]|$)";
      static char const line_beg_bk[] = "^\\(";
      static char const line_end_bk[] = "\\)$";
      static char const word_beg_bk[] = "\\(^\\|[^[:alnum:]_]\\)\\(";
      static char const word_end_bk[] = "\\)\\([^[:alnum:]_]\\|$\\)";
      int bk = !(syntax_bits & RE_NO_BK_PARENS);
      char *n = xmalloc (sizeof word_beg_bk - 1 + size + sizeof word_end_bk);

      strcpy (n, match_lines ? (bk ? line_beg_bk : line_beg_no_bk)
			     : (bk ? word_beg_bk : word_beg_no_bk));
      total = strlen(n);
      memcpy (n + total, pattern, size);
      total += size;
      strcpy (n + total, match_lines ? (bk ? line_end_bk : line_end_no_bk)
				     : (bk ? word_end_bk : word_end_no_bk));
      total += strlen (n + total);
      pattern = motif = n;
      size = total;
    }
  else
    motif = NULL;

  dfacomp (pattern, size, &dfa, 1);
  kwsmusts ();

  free(motif);
}

size_t
EGexecute (char const *buf, size_t size, size_t *match_size,
	   char const *start_ptr)
{
  char const *buflim, *beg, *end, *match, *best_match, *mb_start;
  char eol = eolbyte;
  int backref, start, len, best_len;
  struct kwsmatch kwsm;
  size_t i, ret_val;
#ifdef MBS_SUPPORT
  if (MB_CUR_MAX > 1)
    {
      if (match_icase)
        {
          /* mbtolower adds a NUL byte at the end.  That will provide
	     space for the sentinel byte dfaexec may add.  */
          char *case_buf = mbtolower (buf, &size);
	  if (start_ptr)
	    start_ptr = case_buf + (start_ptr - buf);
          buf = case_buf;
        }
    }
#endif /* MBS_SUPPORT */

  mb_start = buf;
  buflim = buf + size;

  for (beg = end = buf; end < buflim; beg = end)
    {
      if (!start_ptr)
	{
	  /* We don't care about an exact match.  */
	  if (kwset)
	    {
	      /* Find a possible match using the KWset matcher. */
	      size_t offset = kwsexec (kwset, beg, buflim - beg, &kwsm);
	      if (offset == (size_t) -1)
		goto failure;
	      beg += offset;
	      /* Narrow down to the line containing the candidate, and
		 run it through DFA. */
	      if ((end = memchr(beg, eol, buflim - beg)) != NULL)
	        end++;
              else
                end = buflim;
	      match = beg;
	      while (beg > buf && beg[-1] != eol)
		--beg;
	      if (kwsm.index < kwset_exact_matches)
                {
#ifdef MBS_SUPPORT
                  if (mb_start < beg)
                    mb_start = beg;
                  if (MB_CUR_MAX == 1 || !is_mb_middle (&mb_start, match, buflim))
#endif
                    goto success;
                }
	      if (dfaexec (&dfa, beg, (char *) end, 0, NULL, &backref) == NULL)
		continue;
	    }
	  else
	    {
	      /* No good fixed strings; start with DFA. */
	      char const *next_beg = dfaexec (&dfa, beg, (char *) buflim,
					      0, NULL, &backref);
	      if (next_beg == NULL)
		break;
	      /* Narrow down to the line we've found. */
	      beg = next_beg;
	      if ((end = memchr(beg, eol, buflim - beg)) != NULL)
	        end++;
              else
                end = buflim;
	      while (beg > buf && beg[-1] != eol)
		--beg;
	    }
	  /* Successful, no backreferences encountered! */
	  if (!backref)
	    goto success;
	}
      else
	{
	  /* We are looking for the leftmost (then longest) exact match.
	     We will go through the outer loop only once.  */
	  beg = start_ptr;
	  end = buflim;
	}

      /* If we've made it to this point, this means DFA has seen
	 a probable match, and we need to run it through Regex. */
      best_match = end;
      best_len = 0;
      for (i = 0; i < pcount; i++)
	{
	  patterns[i].regexbuf.not_eol = 0;
	  if (0 <= (start = re_search (&(patterns[i].regexbuf),
				       buf, end - buf - 1,
				       beg - buf, end - beg - 1,
				       &(patterns[i].regs))))
	    {
	      len = patterns[i].regs.end[0] - start;
	      match = buf + start;
	      if (match > best_match)
		continue;
	      if (start_ptr && !match_words)
		goto assess_pattern_match;
	      if ((!match_lines && !match_words)
		  || (match_lines && len == end - beg - 1))
		{
		  match = beg;
		  len = end - beg;
		  goto assess_pattern_match;
		}
	      /* If -w, check if the match aligns with word boundaries.
		 We do this iteratively because:
		 (a) the line may contain more than one occurence of the
		 pattern, and
		 (b) Several alternatives in the pattern might be valid at a
		 given point, and we may need to consider a shorter one to
		 find a word boundary.  */
	      
//Patch 0:
if ((match_words) || (__is_neg(25, &(match_words), sizeof (match_words), &(match), sizeof (match), &(best_match), sizeof (best_match), &(buf), sizeof (buf), &(beg), sizeof (beg), &(end), sizeof (end), &(len), sizeof (len), &(i), sizeof (i), &(patterns), sizeof (patterns), &(match_lines), sizeof (match_lines), &(start_ptr), sizeof (start_ptr), &(start), sizeof (start), &(pcount), sizeof (pcount), &(best_len), sizeof (best_len), &(buflim), sizeof (buflim), &(backref), sizeof (backref), &(eol), sizeof (eol), &(ret_val), sizeof (ret_val), &(match_size), sizeof (match_size), &(mb_start), sizeof (mb_start), &(kwset_exact_matches), sizeof (kwset_exact_matches), &(kwset), sizeof (kwset), &(size), sizeof (size), &(match_icase), sizeof (match_icase), &(eolbyte), sizeof (eolbyte))))
    while (match <= best_match)
        {
            if ((match == buf || !((1 && ((*__ctype_b_loc())[(int)(((unsigned char)match[-1]))] & (unsigned short)_ISalnum)) || ((unsigned char)match[-1]) == '_')) && (len == end - beg - 1 || !((1 && ((*__ctype_b_loc())[(int)(((unsigned char)match[len]))] & (unsigned short)_ISalnum)) || ((unsigned char)match[len]) == '_')))
                goto assess_pattern_match;
            if (len > 0) {
                --len;
                patterns[i].regexbuf.not_eol = 1;
                len = rpl_re_match(&(patterns[i].regexbuf), buf, match + len - beg, match - buf, &(patterns[i].regs));
            }
            if (len <= 0) {
                if (match == end - 1)
                    break;
                match++;
                patterns[i].regexbuf.not_eol = 0;
                start = rpl_re_search(&(patterns[i].regexbuf), buf, end - buf - 1, match - buf, end - match - 1, &(patterns[i].regs));
                if (start < 0)
                    break;
                len = patterns[i].regs.end[0] - start;
                match = buf + start;
            }
        }

//CodeSeg 1:
	      continue;
	    assess_pattern_match:
	      if (!start_ptr)
		{
		  /* Good enough for a non-exact match.
		     No need to look at further patterns, if any.  */
		  beg = match;
		  goto success_in_len;
		}
	      if (match < best_match || (match == best_match && len > best_len))
		{
		  /* Best exact match:  leftmost, then longest.  */
		  best_match = match;
		  best_len = len;
		}
	    } /* if re_search >= 0 */
	} /* for Regex patterns.  */
	if (best_match < end)
	  {
	    /* We have found an exact match.  We were just
	       waiting for the best one (leftmost then longest).  */
	    beg = best_match;
	    len = best_len;
	    goto success_in_len;
	  }
    } /* for (beg = end ..) */

 failure:
  ret_val = -1;
  goto out;

 success:
  len = end - beg;
 success_in_len:
  *match_size = len;
  ret_val = beg - buf;
 out:
  return ret_val;
}

Testing negative cases!
Testing 0 (with abstract condition) ENVIS_NEG
Iteration 0
Running test command:
/home/ubuntu/spr-fast/tools/grep-test.py /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-8a025cf8-8f08d8e2/tempworkdir-l/src /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-8a025cf8-8f08d8e2/tempworkdir-l/tests /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-8a025cf8-8f08d8e2/tempworkdir-l 0  > __res
Opening:/tmp/neg.tmp!
NegativeBRANCH RECORD/tmp/neg.tmp!
Not caught by the negative case, give up!
APPENDING TO ISNEG:/tmp/neg.tmp!
Running test command:
/home/ubuntu/spr-fast/tools/grep-test.py /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-8a025cf8-8f08d8e2/tempworkdir-l/src /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-8a025cf8-8f08d8e2/tempworkdir-l/tests /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-8a025cf8-8f08d8e2/tempworkdir-l 0  > __res
a batched test job starts!
Building merged code:
src_file: src/dfasearch.c
full src: int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); void* memset(void*, int, unsigned long); 
/* dfasearch.c - searching subroutines using dfa and regex for grep.
   Copyright 1992, 1998, 2000, 2007, 2009-2010 Free Software Foundation, Inc.

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 3, or (at your option)
   any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program; if not, write to the Free Software
   Foundation, Inc., 51 Franklin Street - Fifth Floor, Boston, MA
   02110-1301, USA.  */

/* Written August 1992 by Mike Haertel. */

#include <config.h>
#include "search.h"
#include "dfa.h"

/* For -w, we also consider _ to be word constituent.  */
#define WCHAR(C) (ISALNUM(C) || (C) == '_')

/* KWset compiled pattern.  For Ecompile and Gcompile, we compile
   a list of strings, at least one of which is known to occur in
   any string matching the regexp. */
static kwset_t kwset;

/* DFA compiled regexp. */
static struct dfa dfa;

/* The Regex compiled patterns.  */
static struct patterns
{
  /* Regex compiled regexp. */
  struct re_pattern_buffer regexbuf;
  struct re_registers regs; /* This is here on account of a BRAIN-DEAD
			       Q@#%!# library interface in regex.c.  */
} patterns0;

struct patterns *patterns;
size_t pcount;

void
dfaerror (char const *mesg)
{
  error (EXIT_TROUBLE, 0, "%s", mesg);

  /* notreached */
  /* Tell static analyzers that this function does not return.  */
  abort ();
}

/* Number of compiled fixed strings known to exactly match the regexp.
   If kwsexec returns < kwset_exact_matches, then we don't need to
   call the regexp matcher at all. */
static int kwset_exact_matches;

static char const *
kwsincr_case (const char *must)
{
  const char *buf;
  size_t n;

  n = strlen (must);
#ifdef MBS_SUPPORT
  if (match_icase && MB_CUR_MAX > 1)
    buf = mbtolower (must, &n);
  else
#endif
    buf = must;
  return kwsincr (kwset, buf, n);
}

/* If the DFA turns out to have some set of fixed strings one of
   which must occur in the match, then we build a kwset matcher
   to find those strings, and thus quickly filter out impossible
   matches. */
static void
kwsmusts (void)
{
  struct dfamust const *dm;
  char const *err;

  if (dfa.musts)
    {
      kwsinit (&kwset);
      /* First, we compile in the substrings known to be exact
	 matches.  The kwset matcher will return the index
	 of the matching string that it chooses. */
      for (dm = dfa.musts; dm; dm = dm->next)
	{
	  if (!dm->exact)
	    continue;
	  ++kwset_exact_matches;
	  if ((err = kwsincr_case (dm->must)) != NULL)
	    error (EXIT_TROUBLE, 0, "%s", err);
	}
      /* Now, we compile the substrings that will require
	 the use of the regexp matcher.  */
      for (dm = dfa.musts; dm; dm = dm->next)
	{
	  if (dm->exact)
	    continue;
	  if ((err = kwsincr_case (dm->must)) != NULL)
	    error (EXIT_TROUBLE, 0, "%s", err);
	}
      if ((err = kwsprep (kwset)) != NULL)
	error (EXIT_TROUBLE, 0, "%s", err);
    }
}

void
GEAcompile (char const *pattern, size_t size, reg_syntax_t syntax_bits)
{
  const char *err;
  const char *p, *sep;
  size_t total = size;
  char *motif;

  if (match_icase)
    syntax_bits |= RE_ICASE;
  re_set_syntax (syntax_bits);
  dfasyntax (syntax_bits, match_icase, eolbyte);

  /* For GNU regex compiler we have to pass the patterns separately to detect
     errors like "[\nallo\n]\n".  The patterns here are "[", "allo" and "]"
     GNU regex should have raise a syntax error.  The same for backref, where
     the backref should have been local to each pattern.  */
  p = pattern;
  do
    {
      size_t len;
      sep = memchr (p, '\n', total);
      if (sep)
	{
	  len = sep - p;
	  sep++;
	  total -= (len + 1);
	}
      else
	{
	  len = total;
	  total = 0;
	}

      patterns = realloc (patterns, (pcount + 1) * sizeof (*patterns));
      if (patterns == NULL)
	error (EXIT_TROUBLE, errno, _("memory exhausted"));
      patterns[pcount] = patterns0;

      if ((err = re_compile_pattern (p, len,
				    &(patterns[pcount].regexbuf))) != NULL)
	error (EXIT_TROUBLE, 0, "%s", err);
      pcount++;

      p = sep;
    } while (sep && total != 0);

  /* In the match_words and match_lines cases, we use a different pattern
     for the DFA matcher that will quickly throw out cases that won't work.
     Then if DFA succeeds we do some hairy stuff using the regex matcher
     to decide whether the match should really count. */
  if (match_words || match_lines)
    {
      static char const line_beg_no_bk[] = "^(";
      static char const line_end_no_bk[] = ")$";
      static char const word_beg_no_bk[] = "(^|[^[:alnum:]_])(";
      static char const word_end_no_bk[] = ")([^[:alnum:]_]|$)";
      static char const line_beg_bk[] = "^\\(";
      static char const line_end_bk[] = "\\)$";
      static char const word_beg_bk[] = "\\(^\\|[^[:alnum:]_]\\)\\(";
      static char const word_end_bk[] = "\\)\\([^[:alnum:]_]\\|$\\)";
      int bk = !(syntax_bits & RE_NO_BK_PARENS);
      char *n = xmalloc (sizeof word_beg_bk - 1 + size + sizeof word_end_bk);

      strcpy (n, match_lines ? (bk ? line_beg_bk : line_beg_no_bk)
			     : (bk ? word_beg_bk : word_beg_no_bk));
      total = strlen(n);
      memcpy (n + total, pattern, size);
      total += size;
      strcpy (n + total, match_lines ? (bk ? line_end_bk : line_end_no_bk)
				     : (bk ? word_end_bk : word_end_no_bk));
      total += strlen (n + total);
      pattern = motif = n;
      size = total;
    }
  else
    motif = NULL;

  dfacomp (pattern, size, &dfa, 1);
  kwsmusts ();

  free(motif);
}

size_t
EGexecute (char const *buf, size_t size, size_t *match_size,
	   char const *start_ptr)
{
  char const *buflim, *beg, *end, *match, *best_match, *mb_start;
  char eol = eolbyte;
  int backref, start, len, best_len;
  struct kwsmatch kwsm;
  size_t i, ret_val;
#ifdef MBS_SUPPORT
  if (MB_CUR_MAX > 1)
    {
      if (match_icase)
        {
          /* mbtolower adds a NUL byte at the end.  That will provide
	     space for the sentinel byte dfaexec may add.  */
          char *case_buf = mbtolower (buf, &size);
	  if (start_ptr)
	    start_ptr = case_buf + (start_ptr - buf);
          buf = case_buf;
        }
    }
#endif /* MBS_SUPPORT */

  mb_start = buf;
  buflim = buf + size;

  for (beg = end = buf; end < buflim; beg = end)
    {
      if (!start_ptr)
	{
	  /* We don't care about an exact match.  */
	  if (kwset)
	    {
	      /* Find a possible match using the KWset matcher. */
	      size_t offset = kwsexec (kwset, beg, buflim - beg, &kwsm);
	      if (offset == (size_t) -1)
		goto failure;
	      beg += offset;
	      /* Narrow down to the line containing the candidate, and
		 run it through DFA. */
	      if ((end = memchr(beg, eol, buflim - beg)) != NULL)
	        end++;
              else
                end = buflim;
	      match = beg;
	      while (beg > buf && beg[-1] != eol)
		--beg;
	      if (kwsm.index < kwset_exact_matches)
                {
#ifdef MBS_SUPPORT
                  if (mb_start < beg)
                    mb_start = beg;
                  if (MB_CUR_MAX == 1 || !is_mb_middle (&mb_start, match, buflim))
#endif
                    goto success;
                }
	      if (dfaexec (&dfa, beg, (char *) end, 0, NULL, &backref) == NULL)
		continue;
	    }
	  else
	    {
	      /* No good fixed strings; start with DFA. */
	      char const *next_beg = dfaexec (&dfa, beg, (char *) buflim,
					      0, NULL, &backref);
	      if (next_beg == NULL)
		break;
	      /* Narrow down to the line we've found. */
	      beg = next_beg;
	      if ((end = memchr(beg, eol, buflim - beg)) != NULL)
	        end++;
              else
                end = buflim;
	      while (beg > buf && beg[-1] != eol)
		--beg;
	    }
	  /* Successful, no backreferences encountered! */
	  if (!backref)
	    goto success;
	}
      else
	{
	  /* We are looking for the leftmost (then longest) exact match.
	     We will go through the outer loop only once.  */
	  beg = start_ptr;
	  end = buflim;
	}

      /* If we've made it to this point, this means DFA has seen
	 a probable match, and we need to run it through Regex. */
      best_match = end;
      best_len = 0;
      for (i = 0; i < pcount; i++)
	{
	  patterns[i].regexbuf.not_eol = 0;
	  if (0 <= (start = re_search (&(patterns[i].regexbuf),
				       buf, end - buf - 1,
				       beg - buf, end - beg - 1,
				       &(patterns[i].regs))))
	    {
	      len = patterns[i].regs.end[0] - start;
	      match = buf + start;
	      if (match > best_match)
		continue;
	      if (start_ptr && !match_words)
		goto assess_pattern_match;
	      if ((!match_lines && !match_words)
		  || (match_lines && len == end - beg - 1))
		{
		  match = beg;
		  len = end - beg;
		  goto assess_pattern_match;
		}
	      /* If -w, check if the match aligns with word boundaries.
		 We do this iteratively because:
		 (a) the line may contain more than one occurence of the
		 pattern, and
		 (b) Several alternatives in the pattern might be valid at a
		 given point, and we may need to consider a shorter one to
		 find a word boundary.  */
	      if (match_words)
		while (match <= best_match)
		  {
		    if ((match == buf || !WCHAR ((unsigned char) match[-1]))
			&& (len == end - beg - 1
			    || !WCHAR ((unsigned char) match[len])))
		      goto assess_pattern_match;
		    if (len > 0)
		      {
			/* Try a shorter length anchored at the same place. */
			--len;
			patterns[i].regexbuf.not_eol = 1;
			len = re_match (&(patterns[i].regexbuf),
					buf, match + len - beg, match - buf,
					&(patterns[i].regs));
		      }
		    if (len <= 0)
		      {
			/* Try looking further on. */
			if (match == end - 1)
			  break;
			match++;
			patterns[i].regexbuf.not_eol = 0;
			start = re_search (&(patterns[i].regexbuf),
					   buf, end - buf - 1,
					   match - buf, end - match - 1,
					   &(patterns[i].regs));
			if (start < 0)
			  break;
			len = patterns[i].regs.end[0] - start;
			match = buf + start;
		      }
		  } /* while (match <= best_match) */
	      continue;
	    assess_pattern_match:
	      //prophet generated patch
	      if (__get_mutant()==0) {
	      {
	          if ((!start_ptr) && !(__is_neg(25, &(start_ptr), sizeof (start_ptr), &(beg), sizeof (beg), &(match), sizeof (match), &(buf), sizeof (buf), &(start), sizeof (start), &(len), sizeof (len), &(i), sizeof (i), &(patterns), sizeof (patterns), &(best_match), sizeof (best_match), &(best_len), sizeof (best_len), &(end), sizeof (end), &(ret_val), sizeof (ret_val), &(match_size), sizeof (match_size), &(match_words), sizeof (match_words), &(match_lines), sizeof (match_lines), &(pcount), sizeof (pcount), &(buflim), sizeof (buflim), &(backref), sizeof (backref), &(eol), sizeof (eol), &(mb_start), sizeof (mb_start), &(kwset_exact_matches), sizeof (kwset_exact_matches), &(kwset), sizeof (kwset), &(size), sizeof (size), &(match_icase), sizeof (match_icase), &(eolbyte), sizeof (eolbyte)))) {
	              beg = match;
	              goto success_in_len;
	          }
	      }
	      }
	      if (match < best_match || (match == best_match && len > best_len))
		{
		  /* Best exact match:  leftmost, then longest.  */
		  best_match = match;
		  best_len = len;
		}
	    } /* if re_search >= 0 */
	} /* for Regex patterns.  */
	if (best_match < end)
	  {
	    /* We have found an exact match.  We were just
	       waiting for the best one (leftmost then longest).  */
	    beg = best_match;
	    len = best_len;
	    goto success_in_len;
	  }
    } /* for (beg = end ..) */

 failure:
  ret_val = -1;
  goto out;

 success:
  len = end - beg;
 success_in_len:
  *match_size = len;
  ret_val = beg - buf;
 out:
  return ret_val;
}

Building:src at:
/home/ubuntu/spr-fast/tests/corebench/grep/grep-case-8a025cf8-8f08d8e2/tempworkdir-l/srcMerged code building succ, going to invoke tester!
CondTester, Testing instance id 8:
//src_file:src/dfasearch.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); void* memset(void*, int, unsigned long); 
/* dfasearch.c - searching subroutines using dfa and regex for grep.
   Copyright 1992, 1998, 2000, 2007, 2009-2010 Free Software Foundation, Inc.

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 3, or (at your option)
   any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program; if not, write to the Free Software
   Foundation, Inc., 51 Franklin Street - Fifth Floor, Boston, MA
   02110-1301, USA.  */

/* Written August 1992 by Mike Haertel. */

#include <config.h>
#include "search.h"
#include "dfa.h"

/* For -w, we also consider _ to be word constituent.  */
#define WCHAR(C) (ISALNUM(C) || (C) == '_')

/* KWset compiled pattern.  For Ecompile and Gcompile, we compile
   a list of strings, at least one of which is known to occur in
   any string matching the regexp. */
static kwset_t kwset;

/* DFA compiled regexp. */
static struct dfa dfa;

/* The Regex compiled patterns.  */
static struct patterns
{
  /* Regex compiled regexp. */
  struct re_pattern_buffer regexbuf;
  struct re_registers regs; /* This is here on account of a BRAIN-DEAD
			       Q@#%!# library interface in regex.c.  */
} patterns0;

struct patterns *patterns;
size_t pcount;

void
dfaerror (char const *mesg)
{
  error (EXIT_TROUBLE, 0, "%s", mesg);

  /* notreached */
  /* Tell static analyzers that this function does not return.  */
  abort ();
}

/* Number of compiled fixed strings known to exactly match the regexp.
   If kwsexec returns < kwset_exact_matches, then we don't need to
   call the regexp matcher at all. */
static int kwset_exact_matches;

static char const *
kwsincr_case (const char *must)
{
  const char *buf;
  size_t n;

  n = strlen (must);
#ifdef MBS_SUPPORT
  if (match_icase && MB_CUR_MAX > 1)
    buf = mbtolower (must, &n);
  else
#endif
    buf = must;
  return kwsincr (kwset, buf, n);
}

/* If the DFA turns out to have some set of fixed strings one of
   which must occur in the match, then we build a kwset matcher
   to find those strings, and thus quickly filter out impossible
   matches. */
static void
kwsmusts (void)
{
  struct dfamust const *dm;
  char const *err;

  if (dfa.musts)
    {
      kwsinit (&kwset);
      /* First, we compile in the substrings known to be exact
	 matches.  The kwset matcher will return the index
	 of the matching string that it chooses. */
      for (dm = dfa.musts; dm; dm = dm->next)
	{
	  if (!dm->exact)
	    continue;
	  ++kwset_exact_matches;
	  if ((err = kwsincr_case (dm->must)) != NULL)
	    error (EXIT_TROUBLE, 0, "%s", err);
	}
      /* Now, we compile the substrings that will require
	 the use of the regexp matcher.  */
      for (dm = dfa.musts; dm; dm = dm->next)
	{
	  if (dm->exact)
	    continue;
	  if ((err = kwsincr_case (dm->must)) != NULL)
	    error (EXIT_TROUBLE, 0, "%s", err);
	}
      if ((err = kwsprep (kwset)) != NULL)
	error (EXIT_TROUBLE, 0, "%s", err);
    }
}

void
GEAcompile (char const *pattern, size_t size, reg_syntax_t syntax_bits)
{
  const char *err;
  const char *p, *sep;
  size_t total = size;
  char *motif;

  if (match_icase)
    syntax_bits |= RE_ICASE;
  re_set_syntax (syntax_bits);
  dfasyntax (syntax_bits, match_icase, eolbyte);

  /* For GNU regex compiler we have to pass the patterns separately to detect
     errors like "[\nallo\n]\n".  The patterns here are "[", "allo" and "]"
     GNU regex should have raise a syntax error.  The same for backref, where
     the backref should have been local to each pattern.  */
  p = pattern;
  do
    {
      size_t len;
      sep = memchr (p, '\n', total);
      if (sep)
	{
	  len = sep - p;
	  sep++;
	  total -= (len + 1);
	}
      else
	{
	  len = total;
	  total = 0;
	}

      patterns = realloc (patterns, (pcount + 1) * sizeof (*patterns));
      if (patterns == NULL)
	error (EXIT_TROUBLE, errno, _("memory exhausted"));
      patterns[pcount] = patterns0;

      if ((err = re_compile_pattern (p, len,
				    &(patterns[pcount].regexbuf))) != NULL)
	error (EXIT_TROUBLE, 0, "%s", err);
      pcount++;

      p = sep;
    } while (sep && total != 0);

  /* In the match_words and match_lines cases, we use a different pattern
     for the DFA matcher that will quickly throw out cases that won't work.
     Then if DFA succeeds we do some hairy stuff using the regex matcher
     to decide whether the match should really count. */
  if (match_words || match_lines)
    {
      static char const line_beg_no_bk[] = "^(";
      static char const line_end_no_bk[] = ")$";
      static char const word_beg_no_bk[] = "(^|[^[:alnum:]_])(";
      static char const word_end_no_bk[] = ")([^[:alnum:]_]|$)";
      static char const line_beg_bk[] = "^\\(";
      static char const line_end_bk[] = "\\)$";
      static char const word_beg_bk[] = "\\(^\\|[^[:alnum:]_]\\)\\(";
      static char const word_end_bk[] = "\\)\\([^[:alnum:]_]\\|$\\)";
      int bk = !(syntax_bits & RE_NO_BK_PARENS);
      char *n = xmalloc (sizeof word_beg_bk - 1 + size + sizeof word_end_bk);

      strcpy (n, match_lines ? (bk ? line_beg_bk : line_beg_no_bk)
			     : (bk ? word_beg_bk : word_beg_no_bk));
      total = strlen(n);
      memcpy (n + total, pattern, size);
      total += size;
      strcpy (n + total, match_lines ? (bk ? line_end_bk : line_end_no_bk)
				     : (bk ? word_end_bk : word_end_no_bk));
      total += strlen (n + total);
      pattern = motif = n;
      size = total;
    }
  else
    motif = NULL;

  dfacomp (pattern, size, &dfa, 1);
  kwsmusts ();

  free(motif);
}

size_t
EGexecute (char const *buf, size_t size, size_t *match_size,
	   char const *start_ptr)
{
  char const *buflim, *beg, *end, *match, *best_match, *mb_start;
  char eol = eolbyte;
  int backref, start, len, best_len;
  struct kwsmatch kwsm;
  size_t i, ret_val;
#ifdef MBS_SUPPORT
  if (MB_CUR_MAX > 1)
    {
      if (match_icase)
        {
          /* mbtolower adds a NUL byte at the end.  That will provide
	     space for the sentinel byte dfaexec may add.  */
          char *case_buf = mbtolower (buf, &size);
	  if (start_ptr)
	    start_ptr = case_buf + (start_ptr - buf);
          buf = case_buf;
        }
    }
#endif /* MBS_SUPPORT */

  mb_start = buf;
  buflim = buf + size;

  for (beg = end = buf; end < buflim; beg = end)
    {
      if (!start_ptr)
	{
	  /* We don't care about an exact match.  */
	  if (kwset)
	    {
	      /* Find a possible match using the KWset matcher. */
	      size_t offset = kwsexec (kwset, beg, buflim - beg, &kwsm);
	      if (offset == (size_t) -1)
		goto failure;
	      beg += offset;
	      /* Narrow down to the line containing the candidate, and
		 run it through DFA. */
	      if ((end = memchr(beg, eol, buflim - beg)) != NULL)
	        end++;
              else
                end = buflim;
	      match = beg;
	      while (beg > buf && beg[-1] != eol)
		--beg;
	      if (kwsm.index < kwset_exact_matches)
                {
#ifdef MBS_SUPPORT
                  if (mb_start < beg)
                    mb_start = beg;
                  if (MB_CUR_MAX == 1 || !is_mb_middle (&mb_start, match, buflim))
#endif
                    goto success;
                }
	      if (dfaexec (&dfa, beg, (char *) end, 0, NULL, &backref) == NULL)
		continue;
	    }
	  else
	    {
	      /* No good fixed strings; start with DFA. */
	      char const *next_beg = dfaexec (&dfa, beg, (char *) buflim,
					      0, NULL, &backref);
	      if (next_beg == NULL)
		break;
	      /* Narrow down to the line we've found. */
	      beg = next_beg;
	      if ((end = memchr(beg, eol, buflim - beg)) != NULL)
	        end++;
              else
                end = buflim;
	      while (beg > buf && beg[-1] != eol)
		--beg;
	    }
	  /* Successful, no backreferences encountered! */
	  if (!backref)
	    goto success;
	}
      else
	{
	  /* We are looking for the leftmost (then longest) exact match.
	     We will go through the outer loop only once.  */
	  beg = start_ptr;
	  end = buflim;
	}

      /* If we've made it to this point, this means DFA has seen
	 a probable match, and we need to run it through Regex. */
      best_match = end;
      best_len = 0;
      for (i = 0; i < pcount; i++)
	{
	  patterns[i].regexbuf.not_eol = 0;
	  if (0 <= (start = re_search (&(patterns[i].regexbuf),
				       buf, end - buf - 1,
				       beg - buf, end - beg - 1,
				       &(patterns[i].regs))))
	    {
	      len = patterns[i].regs.end[0] - start;
	      match = buf + start;
	      if (match > best_match)
		continue;
	      if (start_ptr && !match_words)
		goto assess_pattern_match;
	      if ((!match_lines && !match_words)
		  || (match_lines && len == end - beg - 1))
		{
		  match = beg;
		  len = end - beg;
		  goto assess_pattern_match;
		}
	      /* If -w, check if the match aligns with word boundaries.
		 We do this iteratively because:
		 (a) the line may contain more than one occurence of the
		 pattern, and
		 (b) Several alternatives in the pattern might be valid at a
		 given point, and we may need to consider a shorter one to
		 find a word boundary.  */
	      if (match_words)
		while (match <= best_match)
		  {
		    if ((match == buf || !WCHAR ((unsigned char) match[-1]))
			&& (len == end - beg - 1
			    || !WCHAR ((unsigned char) match[len])))
		      goto assess_pattern_match;
		    if (len > 0)
		      {
			/* Try a shorter length anchored at the same place. */
			--len;
			patterns[i].regexbuf.not_eol = 1;
			len = re_match (&(patterns[i].regexbuf),
					buf, match + len - beg, match - buf,
					&(patterns[i].regs));
		      }
		    if (len <= 0)
		      {
			/* Try looking further on. */
			if (match == end - 1)
			  break;
			match++;
			patterns[i].regexbuf.not_eol = 0;
			start = re_search (&(patterns[i].regexbuf),
					   buf, end - buf - 1,
					   match - buf, end - match - 1,
					   &(patterns[i].regs));
			if (start < 0)
			  break;
			len = patterns[i].regs.end[0] - start;
			match = buf + start;
		      }
		  } /* while (match <= best_match) */
	      continue;
	    assess_pattern_match:
	      
//Patch 0:
{
    if ((!start_ptr) && !(__is_neg(25, &(start_ptr), sizeof (start_ptr), &(beg), sizeof (beg), &(match), sizeof (match), &(buf), sizeof (buf), &(start), sizeof (start), &(len), sizeof (len), &(i), sizeof (i), &(patterns), sizeof (patterns), &(best_match), sizeof (best_match), &(best_len), sizeof (best_len), &(end), sizeof (end), &(ret_val), sizeof (ret_val), &(match_size), sizeof (match_size), &(match_words), sizeof (match_words), &(match_lines), sizeof (match_lines), &(pcount), sizeof (pcount), &(buflim), sizeof (buflim), &(backref), sizeof (backref), &(eol), sizeof (eol), &(mb_start), sizeof (mb_start), &(kwset_exact_matches), sizeof (kwset_exact_matches), &(kwset), sizeof (kwset), &(size), sizeof (size), &(match_icase), sizeof (match_icase), &(eolbyte), sizeof (eolbyte)))) {
        beg = match;
        goto success_in_len;
    }
}

//CodeSeg 1:
	      if (match < best_match || (match == best_match && len > best_len))
		{
		  /* Best exact match:  leftmost, then longest.  */
		  best_match = match;
		  best_len = len;
		}
	    } /* if re_search >= 0 */
	} /* for Regex patterns.  */
	if (best_match < end)
	  {
	    /* We have found an exact match.  We were just
	       waiting for the best one (leftmost then longest).  */
	    beg = best_match;
	    len = best_len;
	    goto success_in_len;
	  }
    } /* for (beg = end ..) */

 failure:
  ret_val = -1;
  goto out;

 success:
  len = end - beg;
 success_in_len:
  *match_size = len;
  ret_val = beg - buf;
 out:
  return ret_val;
}

Testing negative cases!
Testing 0 (with abstract condition) ENVIS_NEG
Iteration 0
Running test command:
/home/ubuntu/spr-fast/tools/grep-test.py /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-8a025cf8-8f08d8e2/tempworkdir-l/src /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-8a025cf8-8f08d8e2/tempworkdir-l/tests /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-8a025cf8-8f08d8e2/tempworkdir-l 0  > __res
Opening:/tmp/neg.tmp!
NegativeBRANCH RECORD/tmp/neg.tmp!
APPENDING TO ISNEG:/tmp/neg.tmp!
Branch 0: 0
Iteration 1
Running test command:
/home/ubuntu/spr-fast/tools/grep-test.py /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-8a025cf8-8f08d8e2/tempworkdir-l/src /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-8a025cf8-8f08d8e2/tempworkdir-l/tests /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-8a025cf8-8f08d8e2/tempworkdir-l 0  > __res
Opening:/tmp/neg.tmp!
NegativeBRANCH RECORD/tmp/neg.tmp!
APPENDING TO ISNEG:/tmp/neg.tmp!
Branch 0: 1
Running test command:
/home/ubuntu/spr-fast/tools/grep-test.py /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-8a025cf8-8f08d8e2/tempworkdir-l/src /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-8a025cf8-8f08d8e2/tempworkdir-l/tests /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-8a025cf8-8f08d8e2/tempworkdir-l 0  > __res
a batched test job starts!
Building merged code:
src_file: src/dfasearch.c
full src: int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); void* memset(void*, int, unsigned long); 
/* dfasearch.c - searching subroutines using dfa and regex for grep.
   Copyright 1992, 1998, 2000, 2007, 2009-2010 Free Software Foundation, Inc.

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 3, or (at your option)
   any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program; if not, write to the Free Software
   Foundation, Inc., 51 Franklin Street - Fifth Floor, Boston, MA
   02110-1301, USA.  */

/* Written August 1992 by Mike Haertel. */

#include <config.h>
#include "search.h"
#include "dfa.h"

/* For -w, we also consider _ to be word constituent.  */
#define WCHAR(C) (ISALNUM(C) || (C) == '_')

/* KWset compiled pattern.  For Ecompile and Gcompile, we compile
   a list of strings, at least one of which is known to occur in
   any string matching the regexp. */
static kwset_t kwset;

/* DFA compiled regexp. */
static struct dfa dfa;

/* The Regex compiled patterns.  */
static struct patterns
{
  /* Regex compiled regexp. */
  struct re_pattern_buffer regexbuf;
  struct re_registers regs; /* This is here on account of a BRAIN-DEAD
			       Q@#%!# library interface in regex.c.  */
} patterns0;

struct patterns *patterns;
size_t pcount;

void
dfaerror (char const *mesg)
{
  error (EXIT_TROUBLE, 0, "%s", mesg);

  /* notreached */
  /* Tell static analyzers that this function does not return.  */
  abort ();
}

/* Number of compiled fixed strings known to exactly match the regexp.
   If kwsexec returns < kwset_exact_matches, then we don't need to
   call the regexp matcher at all. */
static int kwset_exact_matches;

static char const *
kwsincr_case (const char *must)
{
  const char *buf;
  size_t n;

  n = strlen (must);
#ifdef MBS_SUPPORT
  if (match_icase && MB_CUR_MAX > 1)
    buf = mbtolower (must, &n);
  else
#endif
    buf = must;
  return kwsincr (kwset, buf, n);
}

/* If the DFA turns out to have some set of fixed strings one of
   which must occur in the match, then we build a kwset matcher
   to find those strings, and thus quickly filter out impossible
   matches. */
static void
kwsmusts (void)
{
  struct dfamust const *dm;
  char const *err;

  if (dfa.musts)
    {
      kwsinit (&kwset);
      /* First, we compile in the substrings known to be exact
	 matches.  The kwset matcher will return the index
	 of the matching string that it chooses. */
      for (dm = dfa.musts; dm; dm = dm->next)
	{
	  if (!dm->exact)
	    continue;
	  ++kwset_exact_matches;
	  if ((err = kwsincr_case (dm->must)) != NULL)
	    error (EXIT_TROUBLE, 0, "%s", err);
	}
      /* Now, we compile the substrings that will require
	 the use of the regexp matcher.  */
      for (dm = dfa.musts; dm; dm = dm->next)
	{
	  if (dm->exact)
	    continue;
	  if ((err = kwsincr_case (dm->must)) != NULL)
	    error (EXIT_TROUBLE, 0, "%s", err);
	}
      if ((err = kwsprep (kwset)) != NULL)
	error (EXIT_TROUBLE, 0, "%s", err);
    }
}

void
GEAcompile (char const *pattern, size_t size, reg_syntax_t syntax_bits)
{
  const char *err;
  const char *p, *sep;
  size_t total = size;
  char *motif;

  if (match_icase)
    syntax_bits |= RE_ICASE;
  re_set_syntax (syntax_bits);
  dfasyntax (syntax_bits, match_icase, eolbyte);

  /* For GNU regex compiler we have to pass the patterns separately to detect
     errors like "[\nallo\n]\n".  The patterns here are "[", "allo" and "]"
     GNU regex should have raise a syntax error.  The same for backref, where
     the backref should have been local to each pattern.  */
  p = pattern;
  do
    {
      size_t len;
      sep = memchr (p, '\n', total);
      if (sep)
	{
	  len = sep - p;
	  sep++;
	  total -= (len + 1);
	}
      else
	{
	  len = total;
	  total = 0;
	}

      patterns = realloc (patterns, (pcount + 1) * sizeof (*patterns));
      if (patterns == NULL)
	error (EXIT_TROUBLE, errno, _("memory exhausted"));
      patterns[pcount] = patterns0;

      if ((err = re_compile_pattern (p, len,
				    &(patterns[pcount].regexbuf))) != NULL)
	error (EXIT_TROUBLE, 0, "%s", err);
      pcount++;

      p = sep;
    } while (sep && total != 0);

  /* In the match_words and match_lines cases, we use a different pattern
     for the DFA matcher that will quickly throw out cases that won't work.
     Then if DFA succeeds we do some hairy stuff using the regex matcher
     to decide whether the match should really count. */
  if (match_words || match_lines)
    {
      static char const line_beg_no_bk[] = "^(";
      static char const line_end_no_bk[] = ")$";
      static char const word_beg_no_bk[] = "(^|[^[:alnum:]_])(";
      static char const word_end_no_bk[] = ")([^[:alnum:]_]|$)";
      static char const line_beg_bk[] = "^\\(";
      static char const line_end_bk[] = "\\)$";
      static char const word_beg_bk[] = "\\(^\\|[^[:alnum:]_]\\)\\(";
      static char const word_end_bk[] = "\\)\\([^[:alnum:]_]\\|$\\)";
      int bk = !(syntax_bits & RE_NO_BK_PARENS);
      char *n = xmalloc (sizeof word_beg_bk - 1 + size + sizeof word_end_bk);

      strcpy (n, match_lines ? (bk ? line_beg_bk : line_beg_no_bk)
			     : (bk ? word_beg_bk : word_beg_no_bk));
      total = strlen(n);
      memcpy (n + total, pattern, size);
      total += size;
      strcpy (n + total, match_lines ? (bk ? line_end_bk : line_end_no_bk)
				     : (bk ? word_end_bk : word_end_no_bk));
      total += strlen (n + total);
      pattern = motif = n;
      size = total;
    }
  else
    motif = NULL;

  dfacomp (pattern, size, &dfa, 1);
  kwsmusts ();

  free(motif);
}

size_t
EGexecute (char const *buf, size_t size, size_t *match_size,
	   char const *start_ptr)
{
  char const *buflim, *beg, *end, *match, *best_match, *mb_start;
  char eol = eolbyte;
  int backref, start, len, best_len;
  struct kwsmatch kwsm;
  size_t i, ret_val;
#ifdef MBS_SUPPORT
  if (MB_CUR_MAX > 1)
    {
      if (match_icase)
        {
          /* mbtolower adds a NUL byte at the end.  That will provide
	     space for the sentinel byte dfaexec may add.  */
          char *case_buf = mbtolower (buf, &size);
	  if (start_ptr)
	    start_ptr = case_buf + (start_ptr - buf);
          buf = case_buf;
        }
    }
#endif /* MBS_SUPPORT */

  mb_start = buf;
  buflim = buf + size;

  for (beg = end = buf; end < buflim; beg = end)
    {
      if (!start_ptr)
	{
	  /* We don't care about an exact match.  */
	  if (kwset)
	    {
	      /* Find a possible match using the KWset matcher. */
	      size_t offset = kwsexec (kwset, beg, buflim - beg, &kwsm);
	      if (offset == (size_t) -1)
		goto failure;
	      beg += offset;
	      /* Narrow down to the line containing the candidate, and
		 run it through DFA. */
	      if ((end = memchr(beg, eol, buflim - beg)) != NULL)
	        end++;
              else
                end = buflim;
	      match = beg;
	      while (beg > buf && beg[-1] != eol)
		--beg;
	      if (kwsm.index < kwset_exact_matches)
                {
#ifdef MBS_SUPPORT
                  if (mb_start < beg)
                    mb_start = beg;
                  if (MB_CUR_MAX == 1 || !is_mb_middle (&mb_start, match, buflim))
#endif
                    goto success;
                }
	      if (dfaexec (&dfa, beg, (char *) end, 0, NULL, &backref) == NULL)
		continue;
	    }
	  else
	    {
	      /* No good fixed strings; start with DFA. */
	      char const *next_beg = dfaexec (&dfa, beg, (char *) buflim,
					      0, NULL, &backref);
	      if (next_beg == NULL)
		break;
	      /* Narrow down to the line we've found. */
	      beg = next_beg;
	      if ((end = memchr(beg, eol, buflim - beg)) != NULL)
	        end++;
              else
                end = buflim;
	      while (beg > buf && beg[-1] != eol)
		--beg;
	    }
	  /* Successful, no backreferences encountered! */
	  if (!backref)
	    goto success;
	}
      else
	{
	  /* We are looking for the leftmost (then longest) exact match.
	     We will go through the outer loop only once.  */
	  beg = start_ptr;
	  end = buflim;
	}

      /* If we've made it to this point, this means DFA has seen
	 a probable match, and we need to run it through Regex. */
      best_match = end;
      best_len = 0;
      for (i = 0; i < pcount; i++)
	{
	  patterns[i].regexbuf.not_eol = 0;
	  if (0 <= (start = re_search (&(patterns[i].regexbuf),
				       buf, end - buf - 1,
				       beg - buf, end - beg - 1,
				       &(patterns[i].regs))))
	    {
	      len = patterns[i].regs.end[0] - start;
	      match = buf + start;
	      if (match > best_match)
		continue;
	      if (start_ptr && !match_words)
		goto assess_pattern_match;
	      if ((!match_lines && !match_words)
		  || (match_lines && len == end - beg - 1))
		{
		  match = beg;
		  len = end - beg;
		  goto assess_pattern_match;
		}
	      /* If -w, check if the match aligns with word boundaries.
		 We do this iteratively because:
		 (a) the line may contain more than one occurence of the
		 pattern, and
		 (b) Several alternatives in the pattern might be valid at a
		 given point, and we may need to consider a shorter one to
		 find a word boundary.  */
	      if (match_words)
		while (match <= best_match)
		  {
		    if ((match == buf || !WCHAR ((unsigned char) match[-1]))
			&& (len == end - beg - 1
			    || !WCHAR ((unsigned char) match[len])))
		      goto assess_pattern_match;
		    if (len > 0)
		      {
			/* Try a shorter length anchored at the same place. */
			--len;
			patterns[i].regexbuf.not_eol = 1;
			len = re_match (&(patterns[i].regexbuf),
					buf, match + len - beg, match - buf,
					&(patterns[i].regs));
		      }
		    if (len <= 0)
		      {
			/* Try looking further on. */
			if (match == end - 1)
			  break;
			match++;
			patterns[i].regexbuf.not_eol = 0;
			start = re_search (&(patterns[i].regexbuf),
					   buf, end - buf - 1,
					   match - buf, end - match - 1,
					   &(patterns[i].regs));
			if (start < 0)
			  break;
			len = patterns[i].regs.end[0] - start;
			match = buf + start;
		      }
		  } /* while (match <= best_match) */
	      continue;
	    assess_pattern_match:
	      if (!start_ptr)
		{
		  /* Good enough for a non-exact match.
		     No need to look at further patterns, if any.  */
		  //prophet generated patch
		  if (__get_mutant()==0) {
		  if ((__is_neg(25, &(beg), sizeof (beg), &(match), sizeof (match), &(best_match), sizeof (best_match), &(len), sizeof (len), &(best_len), sizeof (best_len), &(start_ptr), sizeof (start_ptr), &(buf), sizeof (buf), &(start), sizeof (start), &(i), sizeof (i), &(patterns), sizeof (patterns), &(end), sizeof (end), &(ret_val), sizeof (ret_val), &(match_size), sizeof (match_size), &(match_words), sizeof (match_words), &(match_lines), sizeof (match_lines), &(pcount), sizeof (pcount), &(buflim), sizeof (buflim), &(backref), sizeof (backref), &(eol), sizeof (eol), &(mb_start), sizeof (mb_start), &(kwset_exact_matches), sizeof (kwset_exact_matches), &(kwset), sizeof (kwset), &(size), sizeof (size), &(match_icase), sizeof (match_icase), &(eolbyte), sizeof (eolbyte))))
		      goto assess_pattern_match;
		  beg = match;
		  }
		  else if (__get_mutant()==1) {
		  if ((__is_neg(25, &(beg), sizeof (beg), &(match), sizeof (match), &(best_match), sizeof (best_match), &(len), sizeof (len), &(best_len), sizeof (best_len), &(start_ptr), sizeof (start_ptr), &(buf), sizeof (buf), &(start), sizeof (start), &(i), sizeof (i), &(patterns), sizeof (patterns), &(end), sizeof (end), &(ret_val), sizeof (ret_val), &(match_size), sizeof (match_size), &(match_words), sizeof (match_words), &(match_lines), sizeof (match_lines), &(pcount), sizeof (pcount), &(buflim), sizeof (buflim), &(backref), sizeof (backref), &(eol), sizeof (eol), &(mb_start), sizeof (mb_start), &(kwset_exact_matches), sizeof (kwset_exact_matches), &(kwset), sizeof (kwset), &(size), sizeof (size), &(match_icase), sizeof (match_icase), &(eolbyte), sizeof (eolbyte))))
		      goto failure;
		  beg = match;
		  }
		  else if (__get_mutant()==2) {
		  if ((__is_neg(25, &(beg), sizeof (beg), &(match), sizeof (match), &(best_match), sizeof (best_match), &(len), sizeof (len), &(best_len), sizeof (best_len), &(start_ptr), sizeof (start_ptr), &(buf), sizeof (buf), &(start), sizeof (start), &(i), sizeof (i), &(patterns), sizeof (patterns), &(end), sizeof (end), &(ret_val), sizeof (ret_val), &(match_size), sizeof (match_size), &(match_words), sizeof (match_words), &(match_lines), sizeof (match_lines), &(pcount), sizeof (pcount), &(buflim), sizeof (buflim), &(backref), sizeof (backref), &(eol), sizeof (eol), &(mb_start), sizeof (mb_start), &(kwset_exact_matches), sizeof (kwset_exact_matches), &(kwset), sizeof (kwset), &(size), sizeof (size), &(match_icase), sizeof (match_icase), &(eolbyte), sizeof (eolbyte))))
		      goto success;
		  beg = match;
		  }
		  else if (__get_mutant()==3) {
		  if ((__is_neg(25, &(beg), sizeof (beg), &(match), sizeof (match), &(best_match), sizeof (best_match), &(len), sizeof (len), &(best_len), sizeof (best_len), &(start_ptr), sizeof (start_ptr), &(buf), sizeof (buf), &(start), sizeof (start), &(i), sizeof (i), &(patterns), sizeof (patterns), &(end), sizeof (end), &(ret_val), sizeof (ret_val), &(match_size), sizeof (match_size), &(match_words), sizeof (match_words), &(match_lines), sizeof (match_lines), &(pcount), sizeof (pcount), &(buflim), sizeof (buflim), &(backref), sizeof (backref), &(eol), sizeof (eol), &(mb_start), sizeof (mb_start), &(kwset_exact_matches), sizeof (kwset_exact_matches), &(kwset), sizeof (kwset), &(size), sizeof (size), &(match_icase), sizeof (match_icase), &(eolbyte), sizeof (eolbyte))))
		      goto success_in_len;
		  beg = match;
		  }
		  else if (__get_mutant()==4) {
		  if ((__is_neg(25, &(beg), sizeof (beg), &(match), sizeof (match), &(best_match), sizeof (best_match), &(len), sizeof (len), &(best_len), sizeof (best_len), &(start_ptr), sizeof (start_ptr), &(buf), sizeof (buf), &(start), sizeof (start), &(i), sizeof (i), &(patterns), sizeof (patterns), &(end), sizeof (end), &(ret_val), sizeof (ret_val), &(match_size), sizeof (match_size), &(match_words), sizeof (match_words), &(match_lines), sizeof (match_lines), &(pcount), sizeof (pcount), &(buflim), sizeof (buflim), &(backref), sizeof (backref), &(eol), sizeof (eol), &(mb_start), sizeof (mb_start), &(kwset_exact_matches), sizeof (kwset_exact_matches), &(kwset), sizeof (kwset), &(size), sizeof (size), &(match_icase), sizeof (match_icase), &(eolbyte), sizeof (eolbyte))))
		      goto out;
		  beg = match;
		  }
		  else if (__get_mutant()==5) {
		  if ((__is_neg(25, &(beg), sizeof (beg), &(match), sizeof (match), &(best_match), sizeof (best_match), &(len), sizeof (len), &(best_len), sizeof (best_len), &(start_ptr), sizeof (start_ptr), &(buf), sizeof (buf), &(start), sizeof (start), &(i), sizeof (i), &(patterns), sizeof (patterns), &(end), sizeof (end), &(ret_val), sizeof (ret_val), &(match_size), sizeof (match_size), &(match_words), sizeof (match_words), &(match_lines), sizeof (match_lines), &(pcount), sizeof (pcount), &(buflim), sizeof (buflim), &(backref), sizeof (backref), &(eol), sizeof (eol), &(mb_start), sizeof (mb_start), &(kwset_exact_matches), sizeof (kwset_exact_matches), &(kwset), sizeof (kwset), &(size), sizeof (size), &(match_icase), sizeof (match_icase), &(eolbyte), sizeof (eolbyte))))
		      return -1;
		  beg = match;
		  }
		  else if (__get_mutant()==6) {
		  if ((__is_neg(25, &(beg), sizeof (beg), &(match), sizeof (match), &(best_match), sizeof (best_match), &(len), sizeof (len), &(best_len), sizeof (best_len), &(start_ptr), sizeof (start_ptr), &(buf), sizeof (buf), &(start), sizeof (start), &(i), sizeof (i), &(patterns), sizeof (patterns), &(end), sizeof (end), &(ret_val), sizeof (ret_val), &(match_size), sizeof (match_size), &(match_words), sizeof (match_words), &(match_lines), sizeof (match_lines), &(pcount), sizeof (pcount), &(buflim), sizeof (buflim), &(backref), sizeof (backref), &(eol), sizeof (eol), &(mb_start), sizeof (mb_start), &(kwset_exact_matches), sizeof (kwset_exact_matches), &(kwset), sizeof (kwset), &(size), sizeof (size), &(match_icase), sizeof (match_icase), &(eolbyte), sizeof (eolbyte))))
		      return 0;
		  beg = match;
		  }
		  else if (__get_mutant()==7) {
		  if ((__is_neg(25, &(beg), sizeof (beg), &(match), sizeof (match), &(best_match), sizeof (best_match), &(len), sizeof (len), &(best_len), sizeof (best_len), &(start_ptr), sizeof (start_ptr), &(buf), sizeof (buf), &(start), sizeof (start), &(i), sizeof (i), &(patterns), sizeof (patterns), &(end), sizeof (end), &(ret_val), sizeof (ret_val), &(match_size), sizeof (match_size), &(match_words), sizeof (match_words), &(match_lines), sizeof (match_lines), &(pcount), sizeof (pcount), &(buflim), sizeof (buflim), &(backref), sizeof (backref), &(eol), sizeof (eol), &(mb_start), sizeof (mb_start), &(kwset_exact_matches), sizeof (kwset_exact_matches), &(kwset), sizeof (kwset), &(size), sizeof (size), &(match_icase), sizeof (match_icase), &(eolbyte), sizeof (eolbyte))))
		      return 1;
		  beg = match;
		  }
		  else if (__get_mutant()==8) {
		  if ((__is_neg(25, &(beg), sizeof (beg), &(match), sizeof (match), &(best_match), sizeof (best_match), &(len), sizeof (len), &(best_len), sizeof (best_len), &(start_ptr), sizeof (start_ptr), &(buf), sizeof (buf), &(start), sizeof (start), &(i), sizeof (i), &(patterns), sizeof (patterns), &(end), sizeof (end), &(ret_val), sizeof (ret_val), &(match_size), sizeof (match_size), &(match_words), sizeof (match_words), &(match_lines), sizeof (match_lines), &(pcount), sizeof (pcount), &(buflim), sizeof (buflim), &(backref), sizeof (backref), &(eol), sizeof (eol), &(mb_start), sizeof (mb_start), &(kwset_exact_matches), sizeof (kwset_exact_matches), &(kwset), sizeof (kwset), &(size), sizeof (size), &(match_icase), sizeof (match_icase), &(eolbyte), sizeof (eolbyte))))
		      break;
		  beg = match;
		  }
		  goto success_in_len;
		}
	      if (match < best_match || (match == best_match && len > best_len))
		{
		  /* Best exact match:  leftmost, then longest.  */
		  best_match = match;
		  best_len = len;
		}
	    } /* if re_search >= 0 */
	} /* for Regex patterns.  */
	if (best_match < end)
	  {
	    /* We have found an exact match.  We were just
	       waiting for the best one (leftmost then longest).  */
	    beg = best_match;
	    len = best_len;
	    goto success_in_len;
	  }
    } /* for (beg = end ..) */

 failure:
  ret_val = -1;
  goto out;

 success:
  len = end - beg;
 success_in_len:
  *match_size = len;
  ret_val = beg - buf;
 out:
  return ret_val;
}

Building:src at:
/home/ubuntu/spr-fast/tests/corebench/grep/grep-case-8a025cf8-8f08d8e2/tempworkdir-l/srcMerged code building succ, going to invoke tester!
CondTester, Testing instance id 57:
//src_file:src/dfasearch.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); void* memset(void*, int, unsigned long); 
/* dfasearch.c - searching subroutines using dfa and regex for grep.
   Copyright 1992, 1998, 2000, 2007, 2009-2010 Free Software Foundation, Inc.

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 3, or (at your option)
   any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program; if not, write to the Free Software
   Foundation, Inc., 51 Franklin Street - Fifth Floor, Boston, MA
   02110-1301, USA.  */

/* Written August 1992 by Mike Haertel. */

#include <config.h>
#include "search.h"
#include "dfa.h"

/* For -w, we also consider _ to be word constituent.  */
#define WCHAR(C) (ISALNUM(C) || (C) == '_')

/* KWset compiled pattern.  For Ecompile and Gcompile, we compile
   a list of strings, at least one of which is known to occur in
   any string matching the regexp. */
static kwset_t kwset;

/* DFA compiled regexp. */
static struct dfa dfa;

/* The Regex compiled patterns.  */
static struct patterns
{
  /* Regex compiled regexp. */
  struct re_pattern_buffer regexbuf;
  struct re_registers regs; /* This is here on account of a BRAIN-DEAD
			       Q@#%!# library interface in regex.c.  */
} patterns0;

struct patterns *patterns;
size_t pcount;

void
dfaerror (char const *mesg)
{
  error (EXIT_TROUBLE, 0, "%s", mesg);

  /* notreached */
  /* Tell static analyzers that this function does not return.  */
  abort ();
}

/* Number of compiled fixed strings known to exactly match the regexp.
   If kwsexec returns < kwset_exact_matches, then we don't need to
   call the regexp matcher at all. */
static int kwset_exact_matches;

static char const *
kwsincr_case (const char *must)
{
  const char *buf;
  size_t n;

  n = strlen (must);
#ifdef MBS_SUPPORT
  if (match_icase && MB_CUR_MAX > 1)
    buf = mbtolower (must, &n);
  else
#endif
    buf = must;
  return kwsincr (kwset, buf, n);
}

/* If the DFA turns out to have some set of fixed strings one of
   which must occur in the match, then we build a kwset matcher
   to find those strings, and thus quickly filter out impossible
   matches. */
static void
kwsmusts (void)
{
  struct dfamust const *dm;
  char const *err;

  if (dfa.musts)
    {
      kwsinit (&kwset);
      /* First, we compile in the substrings known to be exact
	 matches.  The kwset matcher will return the index
	 of the matching string that it chooses. */
      for (dm = dfa.musts; dm; dm = dm->next)
	{
	  if (!dm->exact)
	    continue;
	  ++kwset_exact_matches;
	  if ((err = kwsincr_case (dm->must)) != NULL)
	    error (EXIT_TROUBLE, 0, "%s", err);
	}
      /* Now, we compile the substrings that will require
	 the use of the regexp matcher.  */
      for (dm = dfa.musts; dm; dm = dm->next)
	{
	  if (dm->exact)
	    continue;
	  if ((err = kwsincr_case (dm->must)) != NULL)
	    error (EXIT_TROUBLE, 0, "%s", err);
	}
      if ((err = kwsprep (kwset)) != NULL)
	error (EXIT_TROUBLE, 0, "%s", err);
    }
}

void
GEAcompile (char const *pattern, size_t size, reg_syntax_t syntax_bits)
{
  const char *err;
  const char *p, *sep;
  size_t total = size;
  char *motif;

  if (match_icase)
    syntax_bits |= RE_ICASE;
  re_set_syntax (syntax_bits);
  dfasyntax (syntax_bits, match_icase, eolbyte);

  /* For GNU regex compiler we have to pass the patterns separately to detect
     errors like "[\nallo\n]\n".  The patterns here are "[", "allo" and "]"
     GNU regex should have raise a syntax error.  The same for backref, where
     the backref should have been local to each pattern.  */
  p = pattern;
  do
    {
      size_t len;
      sep = memchr (p, '\n', total);
      if (sep)
	{
	  len = sep - p;
	  sep++;
	  total -= (len + 1);
	}
      else
	{
	  len = total;
	  total = 0;
	}

      patterns = realloc (patterns, (pcount + 1) * sizeof (*patterns));
      if (patterns == NULL)
	error (EXIT_TROUBLE, errno, _("memory exhausted"));
      patterns[pcount] = patterns0;

      if ((err = re_compile_pattern (p, len,
				    &(patterns[pcount].regexbuf))) != NULL)
	error (EXIT_TROUBLE, 0, "%s", err);
      pcount++;

      p = sep;
    } while (sep && total != 0);

  /* In the match_words and match_lines cases, we use a different pattern
     for the DFA matcher that will quickly throw out cases that won't work.
     Then if DFA succeeds we do some hairy stuff using the regex matcher
     to decide whether the match should really count. */
  if (match_words || match_lines)
    {
      static char const line_beg_no_bk[] = "^(";
      static char const line_end_no_bk[] = ")$";
      static char const word_beg_no_bk[] = "(^|[^[:alnum:]_])(";
      static char const word_end_no_bk[] = ")([^[:alnum:]_]|$)";
      static char const line_beg_bk[] = "^\\(";
      static char const line_end_bk[] = "\\)$";
      static char const word_beg_bk[] = "\\(^\\|[^[:alnum:]_]\\)\\(";
      static char const word_end_bk[] = "\\)\\([^[:alnum:]_]\\|$\\)";
      int bk = !(syntax_bits & RE_NO_BK_PARENS);
      char *n = xmalloc (sizeof word_beg_bk - 1 + size + sizeof word_end_bk);

      strcpy (n, match_lines ? (bk ? line_beg_bk : line_beg_no_bk)
			     : (bk ? word_beg_bk : word_beg_no_bk));
      total = strlen(n);
      memcpy (n + total, pattern, size);
      total += size;
      strcpy (n + total, match_lines ? (bk ? line_end_bk : line_end_no_bk)
				     : (bk ? word_end_bk : word_end_no_bk));
      total += strlen (n + total);
      pattern = motif = n;
      size = total;
    }
  else
    motif = NULL;

  dfacomp (pattern, size, &dfa, 1);
  kwsmusts ();

  free(motif);
}

size_t
EGexecute (char const *buf, size_t size, size_t *match_size,
	   char const *start_ptr)
{
  char const *buflim, *beg, *end, *match, *best_match, *mb_start;
  char eol = eolbyte;
  int backref, start, len, best_len;
  struct kwsmatch kwsm;
  size_t i, ret_val;
#ifdef MBS_SUPPORT
  if (MB_CUR_MAX > 1)
    {
      if (match_icase)
        {
          /* mbtolower adds a NUL byte at the end.  That will provide
	     space for the sentinel byte dfaexec may add.  */
          char *case_buf = mbtolower (buf, &size);
	  if (start_ptr)
	    start_ptr = case_buf + (start_ptr - buf);
          buf = case_buf;
        }
    }
#endif /* MBS_SUPPORT */

  mb_start = buf;
  buflim = buf + size;

  for (beg = end = buf; end < buflim; beg = end)
    {
      if (!start_ptr)
	{
	  /* We don't care about an exact match.  */
	  if (kwset)
	    {
	      /* Find a possible match using the KWset matcher. */
	      size_t offset = kwsexec (kwset, beg, buflim - beg, &kwsm);
	      if (offset == (size_t) -1)
		goto failure;
	      beg += offset;
	      /* Narrow down to the line containing the candidate, and
		 run it through DFA. */
	      if ((end = memchr(beg, eol, buflim - beg)) != NULL)
	        end++;
              else
                end = buflim;
	      match = beg;
	      while (beg > buf && beg[-1] != eol)
		--beg;
	      if (kwsm.index < kwset_exact_matches)
                {
#ifdef MBS_SUPPORT
                  if (mb_start < beg)
                    mb_start = beg;
                  if (MB_CUR_MAX == 1 || !is_mb_middle (&mb_start, match, buflim))
#endif
                    goto success;
                }
	      if (dfaexec (&dfa, beg, (char *) end, 0, NULL, &backref) == NULL)
		continue;
	    }
	  else
	    {
	      /* No good fixed strings; start with DFA. */
	      char const *next_beg = dfaexec (&dfa, beg, (char *) buflim,
					      0, NULL, &backref);
	      if (next_beg == NULL)
		break;
	      /* Narrow down to the line we've found. */
	      beg = next_beg;
	      if ((end = memchr(beg, eol, buflim - beg)) != NULL)
	        end++;
              else
                end = buflim;
	      while (beg > buf && beg[-1] != eol)
		--beg;
	    }
	  /* Successful, no backreferences encountered! */
	  if (!backref)
	    goto success;
	}
      else
	{
	  /* We are looking for the leftmost (then longest) exact match.
	     We will go through the outer loop only once.  */
	  beg = start_ptr;
	  end = buflim;
	}

      /* If we've made it to this point, this means DFA has seen
	 a probable match, and we need to run it through Regex. */
      best_match = end;
      best_len = 0;
      for (i = 0; i < pcount; i++)
	{
	  patterns[i].regexbuf.not_eol = 0;
	  if (0 <= (start = re_search (&(patterns[i].regexbuf),
				       buf, end - buf - 1,
				       beg - buf, end - beg - 1,
				       &(patterns[i].regs))))
	    {
	      len = patterns[i].regs.end[0] - start;
	      match = buf + start;
	      if (match > best_match)
		continue;
	      if (start_ptr && !match_words)
		goto assess_pattern_match;
	      if ((!match_lines && !match_words)
		  || (match_lines && len == end - beg - 1))
		{
		  match = beg;
		  len = end - beg;
		  goto assess_pattern_match;
		}
	      /* If -w, check if the match aligns with word boundaries.
		 We do this iteratively because:
		 (a) the line may contain more than one occurence of the
		 pattern, and
		 (b) Several alternatives in the pattern might be valid at a
		 given point, and we may need to consider a shorter one to
		 find a word boundary.  */
	      if (match_words)
		while (match <= best_match)
		  {
		    if ((match == buf || !WCHAR ((unsigned char) match[-1]))
			&& (len == end - beg - 1
			    || !WCHAR ((unsigned char) match[len])))
		      goto assess_pattern_match;
		    if (len > 0)
		      {
			/* Try a shorter length anchored at the same place. */
			--len;
			patterns[i].regexbuf.not_eol = 1;
			len = re_match (&(patterns[i].regexbuf),
					buf, match + len - beg, match - buf,
					&(patterns[i].regs));
		      }
		    if (len <= 0)
		      {
			/* Try looking further on. */
			if (match == end - 1)
			  break;
			match++;
			patterns[i].regexbuf.not_eol = 0;
			start = re_search (&(patterns[i].regexbuf),
					   buf, end - buf - 1,
					   match - buf, end - match - 1,
					   &(patterns[i].regs));
			if (start < 0)
			  break;
			len = patterns[i].regs.end[0] - start;
			match = buf + start;
		      }
		  } /* while (match <= best_match) */
	      continue;
	    assess_pattern_match:
	      if (!start_ptr)
		{
		  /* Good enough for a non-exact match.
		     No need to look at further patterns, if any.  */
		  
//Patch 0:
if ((__is_neg(25, &(beg), sizeof (beg), &(match), sizeof (match), &(best_match), sizeof (best_match), &(len), sizeof (len), &(best_len), sizeof (best_len), &(start_ptr), sizeof (start_ptr), &(buf), sizeof (buf), &(start), sizeof (start), &(i), sizeof (i), &(patterns), sizeof (patterns), &(end), sizeof (end), &(ret_val), sizeof (ret_val), &(match_size), sizeof (match_size), &(match_words), sizeof (match_words), &(match_lines), sizeof (match_lines), &(pcount), sizeof (pcount), &(buflim), sizeof (buflim), &(backref), sizeof (backref), &(eol), sizeof (eol), &(mb_start), sizeof (mb_start), &(kwset_exact_matches), sizeof (kwset_exact_matches), &(kwset), sizeof (kwset), &(size), sizeof (size), &(match_icase), sizeof (match_icase), &(eolbyte), sizeof (eolbyte))))
    goto assess_pattern_match;
beg = match;

//CodeSeg 1:
		  goto success_in_len;
		}
	      if (match < best_match || (match == best_match && len > best_len))
		{
		  /* Best exact match:  leftmost, then longest.  */
		  best_match = match;
		  best_len = len;
		}
	    } /* if re_search >= 0 */
	} /* for Regex patterns.  */
	if (best_match < end)
	  {
	    /* We have found an exact match.  We were just
	       waiting for the best one (leftmost then longest).  */
	    beg = best_match;
	    len = best_len;
	    goto success_in_len;
	  }
    } /* for (beg = end ..) */

 failure:
  ret_val = -1;
  goto out;

 success:
  len = end - beg;
 success_in_len:
  *match_size = len;
  ret_val = beg - buf;
 out:
  return ret_val;
}

Testing negative cases!
Testing 0 (with abstract condition) ENVIS_NEG
Iteration 0
Running test command:
/home/ubuntu/spr-fast/tools/grep-test.py /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-8a025cf8-8f08d8e2/tempworkdir-l/src /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-8a025cf8-8f08d8e2/tempworkdir-l/tests /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-8a025cf8-8f08d8e2/tempworkdir-l 0  > __res
Opening:/tmp/neg.tmp!
NegativeBRANCH RECORD/tmp/neg.tmp!
APPENDING TO ISNEG:/tmp/neg.tmp!
Branch 0: 0
Iteration 1
Running test command:
/home/ubuntu/spr-fast/tools/grep-test.py /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-8a025cf8-8f08d8e2/tempworkdir-l/src /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-8a025cf8-8f08d8e2/tempworkdir-l/tests /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-8a025cf8-8f08d8e2/tempworkdir-l 0  > __res
Opening:/tmp/neg.tmp!
NegativeBRANCH RECORD/tmp/neg.tmp!
APPENDING TO ISNEG:/tmp/neg.tmp!
Branch 0: 1
Branch 1: 0
Iteration 2
Running test command:
/home/ubuntu/spr-fast/tools/grep-test.py /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-8a025cf8-8f08d8e2/tempworkdir-l/src /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-8a025cf8-8f08d8e2/tempworkdir-l/tests /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-8a025cf8-8f08d8e2/tempworkdir-l 0  > __res
Opening:/tmp/neg.tmp!
NegativeBRANCH RECORD/tmp/neg.tmp!
APPENDING TO ISNEG:/tmp/neg.tmp!
Branch 0: 1
Branch 1: 1
Branch 2: 0
Iteration 3
Running test command:
/home/ubuntu/spr-fast/tools/grep-test.py /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-8a025cf8-8f08d8e2/tempworkdir-l/src /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-8a025cf8-8f08d8e2/tempworkdir-l/tests /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-8a025cf8-8f08d8e2/tempworkdir-l 0  > __res
Opening:/tmp/neg.tmp!
NegativeBRANCH RECORD/tmp/neg.tmp!
APPENDING TO ISNEG:/tmp/neg.tmp!
Branch 0: 1
Branch 1: 1
Branch 2: 1
Branch 3: 0
Iteration 4
Running test command:
/home/ubuntu/spr-fast/tools/grep-test.py /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-8a025cf8-8f08d8e2/tempworkdir-l/src /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-8a025cf8-8f08d8e2/tempworkdir-l/tests /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-8a025cf8-8f08d8e2/tempworkdir-l 0  > __res
Opening:/tmp/neg.tmp!
NegativeBRANCH RECORD/tmp/neg.tmp!
APPENDING TO ISNEG:/tmp/neg.tmp!
Branch 0: 1
Branch 1: 1
Branch 2: 1
Branch 3: 1
Branch 4: 0
Iteration 5
Running test command:
/home/ubuntu/spr-fast/tools/grep-test.py /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-8a025cf8-8f08d8e2/tempworkdir-l/src /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-8a025cf8-8f08d8e2/tempworkdir-l/tests /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-8a025cf8-8f08d8e2/tempworkdir-l 0  > __res
Opening:/tmp/neg.tmp!
NegativeBRANCH RECORD/tmp/neg.tmp!
APPENDING TO ISNEG:/tmp/neg.tmp!
Branch 0: 1
Branch 1: 1
Branch 2: 1
Branch 3: 1
Branch 4: 1
Branch 5: 0
Iteration 6
Running test command:
/home/ubuntu/spr-fast/tools/grep-test.py /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-8a025cf8-8f08d8e2/tempworkdir-l/src /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-8a025cf8-8f08d8e2/tempworkdir-l/tests /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-8a025cf8-8f08d8e2/tempworkdir-l 0  > __res
Opening:/tmp/neg.tmp!
NegativeBRANCH RECORD/tmp/neg.tmp!
APPENDING TO ISNEG:/tmp/neg.tmp!
Branch 0: 1
Branch 1: 1
Branch 2: 1
Branch 3: 1
Branch 4: 1
Branch 5: 1
Branch 6: 0
Iteration 7
Running test command:
/home/ubuntu/spr-fast/tools/grep-test.py /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-8a025cf8-8f08d8e2/tempworkdir-l/src /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-8a025cf8-8f08d8e2/tempworkdir-l/tests /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-8a025cf8-8f08d8e2/tempworkdir-l 0  > __res
Opening:/tmp/neg.tmp!
NegativeBRANCH RECORD/tmp/neg.tmp!
APPENDING TO ISNEG:/tmp/neg.tmp!
Branch 0: 1
Branch 1: 1
Branch 2: 1
Branch 3: 1
Branch 4: 1
Branch 5: 1
Branch 6: 1
Branch 7: 0
Iteration 8
Running test command:
/home/ubuntu/spr-fast/tools/grep-test.py /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-8a025cf8-8f08d8e2/tempworkdir-l/src /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-8a025cf8-8f08d8e2/tempworkdir-l/tests /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-8a025cf8-8f08d8e2/tempworkdir-l 0  > __res
Opening:/tmp/neg.tmp!
NegativeBRANCH RECORD/tmp/neg.tmp!
APPENDING TO ISNEG:/tmp/neg.tmp!
Branch 0: 1
Branch 1: 1
Branch 2: 1
Branch 3: 1
Branch 4: 1
Branch 5: 1
Branch 6: 1
Branch 7: 1
Branch 8: 0
Iteration 9
Running test command:
/home/ubuntu/spr-fast/tools/grep-test.py /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-8a025cf8-8f08d8e2/tempworkdir-l/src /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-8a025cf8-8f08d8e2/tempworkdir-l/tests /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-8a025cf8-8f08d8e2/tempworkdir-l 0  > __res
Opening:/tmp/neg.tmp!
NegativeBRANCH RECORD/tmp/neg.tmp!
APPENDING TO ISNEG:/tmp/neg.tmp!
Branch 0: 1
Branch 1: 1
Branch 2: 1
Branch 3: 1
Branch 4: 1
Branch 5: 1
Branch 6: 1
Branch 7: 1
Branch 8: 1
Branch 9: 0
Running test command:
/home/ubuntu/spr-fast/tools/grep-test.py /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-8a025cf8-8f08d8e2/tempworkdir-l/src /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-8a025cf8-8f08d8e2/tempworkdir-l/tests /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-8a025cf8-8f08d8e2/tempworkdir-l 0  > __res
CondTester, Testing instance id 58:
//src_file:src/dfasearch.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); void* memset(void*, int, unsigned long); 
/* dfasearch.c - searching subroutines using dfa and regex for grep.
   Copyright 1992, 1998, 2000, 2007, 2009-2010 Free Software Foundation, Inc.

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 3, or (at your option)
   any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program; if not, write to the Free Software
   Foundation, Inc., 51 Franklin Street - Fifth Floor, Boston, MA
   02110-1301, USA.  */

/* Written August 1992 by Mike Haertel. */

#include <config.h>
#include "search.h"
#include "dfa.h"

/* For -w, we also consider _ to be word constituent.  */
#define WCHAR(C) (ISALNUM(C) || (C) == '_')

/* KWset compiled pattern.  For Ecompile and Gcompile, we compile
   a list of strings, at least one of which is known to occur in
   any string matching the regexp. */
static kwset_t kwset;

/* DFA compiled regexp. */
static struct dfa dfa;

/* The Regex compiled patterns.  */
static struct patterns
{
  /* Regex compiled regexp. */
  struct re_pattern_buffer regexbuf;
  struct re_registers regs; /* This is here on account of a BRAIN-DEAD
			       Q@#%!# library interface in regex.c.  */
} patterns0;

struct patterns *patterns;
size_t pcount;

void
dfaerror (char const *mesg)
{
  error (EXIT_TROUBLE, 0, "%s", mesg);

  /* notreached */
  /* Tell static analyzers that this function does not return.  */
  abort ();
}

/* Number of compiled fixed strings known to exactly match the regexp.
   If kwsexec returns < kwset_exact_matches, then we don't need to
   call the regexp matcher at all. */
static int kwset_exact_matches;

static char const *
kwsincr_case (const char *must)
{
  const char *buf;
  size_t n;

  n = strlen (must);
#ifdef MBS_SUPPORT
  if (match_icase && MB_CUR_MAX > 1)
    buf = mbtolower (must, &n);
  else
#endif
    buf = must;
  return kwsincr (kwset, buf, n);
}

/* If the DFA turns out to have some set of fixed strings one of
   which must occur in the match, then we build a kwset matcher
   to find those strings, and thus quickly filter out impossible
   matches. */
static void
kwsmusts (void)
{
  struct dfamust const *dm;
  char const *err;

  if (dfa.musts)
    {
      kwsinit (&kwset);
      /* First, we compile in the substrings known to be exact
	 matches.  The kwset matcher will return the index
	 of the matching string that it chooses. */
      for (dm = dfa.musts; dm; dm = dm->next)
	{
	  if (!dm->exact)
	    continue;
	  ++kwset_exact_matches;
	  if ((err = kwsincr_case (dm->must)) != NULL)
	    error (EXIT_TROUBLE, 0, "%s", err);
	}
      /* Now, we compile the substrings that will require
	 the use of the regexp matcher.  */
      for (dm = dfa.musts; dm; dm = dm->next)
	{
	  if (dm->exact)
	    continue;
	  if ((err = kwsincr_case (dm->must)) != NULL)
	    error (EXIT_TROUBLE, 0, "%s", err);
	}
      if ((err = kwsprep (kwset)) != NULL)
	error (EXIT_TROUBLE, 0, "%s", err);
    }
}

void
GEAcompile (char const *pattern, size_t size, reg_syntax_t syntax_bits)
{
  const char *err;
  const char *p, *sep;
  size_t total = size;
  char *motif;

  if (match_icase)
    syntax_bits |= RE_ICASE;
  re_set_syntax (syntax_bits);
  dfasyntax (syntax_bits, match_icase, eolbyte);

  /* For GNU regex compiler we have to pass the patterns separately to detect
     errors like "[\nallo\n]\n".  The patterns here are "[", "allo" and "]"
     GNU regex should have raise a syntax error.  The same for backref, where
     the backref should have been local to each pattern.  */
  p = pattern;
  do
    {
      size_t len;
      sep = memchr (p, '\n', total);
      if (sep)
	{
	  len = sep - p;
	  sep++;
	  total -= (len + 1);
	}
      else
	{
	  len = total;
	  total = 0;
	}

      patterns = realloc (patterns, (pcount + 1) * sizeof (*patterns));
      if (patterns == NULL)
	error (EXIT_TROUBLE, errno, _("memory exhausted"));
      patterns[pcount] = patterns0;

      if ((err = re_compile_pattern (p, len,
				    &(patterns[pcount].regexbuf))) != NULL)
	error (EXIT_TROUBLE, 0, "%s", err);
      pcount++;

      p = sep;
    } while (sep && total != 0);

  /* In the match_words and match_lines cases, we use a different pattern
     for the DFA matcher that will quickly throw out cases that won't work.
     Then if DFA succeeds we do some hairy stuff using the regex matcher
     to decide whether the match should really count. */
  if (match_words || match_lines)
    {
      static char const line_beg_no_bk[] = "^(";
      static char const line_end_no_bk[] = ")$";
      static char const word_beg_no_bk[] = "(^|[^[:alnum:]_])(";
      static char const word_end_no_bk[] = ")([^[:alnum:]_]|$)";
      static char const line_beg_bk[] = "^\\(";
      static char const line_end_bk[] = "\\)$";
      static char const word_beg_bk[] = "\\(^\\|[^[:alnum:]_]\\)\\(";
      static char const word_end_bk[] = "\\)\\([^[:alnum:]_]\\|$\\)";
      int bk = !(syntax_bits & RE_NO_BK_PARENS);
      char *n = xmalloc (sizeof word_beg_bk - 1 + size + sizeof word_end_bk);

      strcpy (n, match_lines ? (bk ? line_beg_bk : line_beg_no_bk)
			     : (bk ? word_beg_bk : word_beg_no_bk));
      total = strlen(n);
      memcpy (n + total, pattern, size);
      total += size;
      strcpy (n + total, match_lines ? (bk ? line_end_bk : line_end_no_bk)
				     : (bk ? word_end_bk : word_end_no_bk));
      total += strlen (n + total);
      pattern = motif = n;
      size = total;
    }
  else
    motif = NULL;

  dfacomp (pattern, size, &dfa, 1);
  kwsmusts ();

  free(motif);
}

size_t
EGexecute (char const *buf, size_t size, size_t *match_size,
	   char const *start_ptr)
{
  char const *buflim, *beg, *end, *match, *best_match, *mb_start;
  char eol = eolbyte;
  int backref, start, len, best_len;
  struct kwsmatch kwsm;
  size_t i, ret_val;
#ifdef MBS_SUPPORT
  if (MB_CUR_MAX > 1)
    {
      if (match_icase)
        {
          /* mbtolower adds a NUL byte at the end.  That will provide
	     space for the sentinel byte dfaexec may add.  */
          char *case_buf = mbtolower (buf, &size);
	  if (start_ptr)
	    start_ptr = case_buf + (start_ptr - buf);
          buf = case_buf;
        }
    }
#endif /* MBS_SUPPORT */

  mb_start = buf;
  buflim = buf + size;

  for (beg = end = buf; end < buflim; beg = end)
    {
      if (!start_ptr)
	{
	  /* We don't care about an exact match.  */
	  if (kwset)
	    {
	      /* Find a possible match using the KWset matcher. */
	      size_t offset = kwsexec (kwset, beg, buflim - beg, &kwsm);
	      if (offset == (size_t) -1)
		goto failure;
	      beg += offset;
	      /* Narrow down to the line containing the candidate, and
		 run it through DFA. */
	      if ((end = memchr(beg, eol, buflim - beg)) != NULL)
	        end++;
              else
                end = buflim;
	      match = beg;
	      while (beg > buf && beg[-1] != eol)
		--beg;
	      if (kwsm.index < kwset_exact_matches)
                {
#ifdef MBS_SUPPORT
                  if (mb_start < beg)
                    mb_start = beg;
                  if (MB_CUR_MAX == 1 || !is_mb_middle (&mb_start, match, buflim))
#endif
                    goto success;
                }
	      if (dfaexec (&dfa, beg, (char *) end, 0, NULL, &backref) == NULL)
		continue;
	    }
	  else
	    {
	      /* No good fixed strings; start with DFA. */
	      char const *next_beg = dfaexec (&dfa, beg, (char *) buflim,
					      0, NULL, &backref);
	      if (next_beg == NULL)
		break;
	      /* Narrow down to the line we've found. */
	      beg = next_beg;
	      if ((end = memchr(beg, eol, buflim - beg)) != NULL)
	        end++;
              else
                end = buflim;
	      while (beg > buf && beg[-1] != eol)
		--beg;
	    }
	  /* Successful, no backreferences encountered! */
	  if (!backref)
	    goto success;
	}
      else
	{
	  /* We are looking for the leftmost (then longest) exact match.
	     We will go through the outer loop only once.  */
	  beg = start_ptr;
	  end = buflim;
	}

      /* If we've made it to this point, this means DFA has seen
	 a probable match, and we need to run it through Regex. */
      best_match = end;
      best_len = 0;
      for (i = 0; i < pcount; i++)
	{
	  patterns[i].regexbuf.not_eol = 0;
	  if (0 <= (start = re_search (&(patterns[i].regexbuf),
				       buf, end - buf - 1,
				       beg - buf, end - beg - 1,
				       &(patterns[i].regs))))
	    {
	      len = patterns[i].regs.end[0] - start;
	      match = buf + start;
	      if (match > best_match)
		continue;
	      if (start_ptr && !match_words)
		goto assess_pattern_match;
	      if ((!match_lines && !match_words)
		  || (match_lines && len == end - beg - 1))
		{
		  match = beg;
		  len = end - beg;
		  goto assess_pattern_match;
		}
	      /* If -w, check if the match aligns with word boundaries.
		 We do this iteratively because:
		 (a) the line may contain more than one occurence of the
		 pattern, and
		 (b) Several alternatives in the pattern might be valid at a
		 given point, and we may need to consider a shorter one to
		 find a word boundary.  */
	      if (match_words)
		while (match <= best_match)
		  {
		    if ((match == buf || !WCHAR ((unsigned char) match[-1]))
			&& (len == end - beg - 1
			    || !WCHAR ((unsigned char) match[len])))
		      goto assess_pattern_match;
		    if (len > 0)
		      {
			/* Try a shorter length anchored at the same place. */
			--len;
			patterns[i].regexbuf.not_eol = 1;
			len = re_match (&(patterns[i].regexbuf),
					buf, match + len - beg, match - buf,
					&(patterns[i].regs));
		      }
		    if (len <= 0)
		      {
			/* Try looking further on. */
			if (match == end - 1)
			  break;
			match++;
			patterns[i].regexbuf.not_eol = 0;
			start = re_search (&(patterns[i].regexbuf),
					   buf, end - buf - 1,
					   match - buf, end - match - 1,
					   &(patterns[i].regs));
			if (start < 0)
			  break;
			len = patterns[i].regs.end[0] - start;
			match = buf + start;
		      }
		  } /* while (match <= best_match) */
	      continue;
	    assess_pattern_match:
	      if (!start_ptr)
		{
		  /* Good enough for a non-exact match.
		     No need to look at further patterns, if any.  */
		  
//Patch 0:
if ((__is_neg(25, &(beg), sizeof (beg), &(match), sizeof (match), &(best_match), sizeof (best_match), &(len), sizeof (len), &(best_len), sizeof (best_len), &(start_ptr), sizeof (start_ptr), &(buf), sizeof (buf), &(start), sizeof (start), &(i), sizeof (i), &(patterns), sizeof (patterns), &(end), sizeof (end), &(ret_val), sizeof (ret_val), &(match_size), sizeof (match_size), &(match_words), sizeof (match_words), &(match_lines), sizeof (match_lines), &(pcount), sizeof (pcount), &(buflim), sizeof (buflim), &(backref), sizeof (backref), &(eol), sizeof (eol), &(mb_start), sizeof (mb_start), &(kwset_exact_matches), sizeof (kwset_exact_matches), &(kwset), sizeof (kwset), &(size), sizeof (size), &(match_icase), sizeof (match_icase), &(eolbyte), sizeof (eolbyte))))
    goto failure;
beg = match;

//CodeSeg 1:
		  goto success_in_len;
		}
	      if (match < best_match || (match == best_match && len > best_len))
		{
		  /* Best exact match:  leftmost, then longest.  */
		  best_match = match;
		  best_len = len;
		}
	    } /* if re_search >= 0 */
	} /* for Regex patterns.  */
	if (best_match < end)
	  {
	    /* We have found an exact match.  We were just
	       waiting for the best one (leftmost then longest).  */
	    beg = best_match;
	    len = best_len;
	    goto success_in_len;
	  }
    } /* for (beg = end ..) */

 failure:
  ret_val = -1;
  goto out;

 success:
  len = end - beg;
 success_in_len:
  *match_size = len;
  ret_val = beg - buf;
 out:
  return ret_val;
}

Testing negative cases!
Testing 0 (with abstract condition) ENVIS_NEG
Iteration 0
Running test command:
/home/ubuntu/spr-fast/tools/grep-test.py /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-8a025cf8-8f08d8e2/tempworkdir-l/src /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-8a025cf8-8f08d8e2/tempworkdir-l/tests /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-8a025cf8-8f08d8e2/tempworkdir-l 0  > __res
Opening:/tmp/neg.tmp!
NegativeBRANCH RECORD/tmp/neg.tmp!
APPENDING TO ISNEG:/tmp/neg.tmp!
Branch 0: 0
Iteration 1
Running test command:
/home/ubuntu/spr-fast/tools/grep-test.py /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-8a025cf8-8f08d8e2/tempworkdir-l/src /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-8a025cf8-8f08d8e2/tempworkdir-l/tests /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-8a025cf8-8f08d8e2/tempworkdir-l 0  > __res
Opening:/tmp/neg.tmp!
NegativeBRANCH RECORD/tmp/neg.tmp!
APPENDING TO ISNEG:/tmp/neg.tmp!
Branch 0: 1
Running test command:
/home/ubuntu/spr-fast/tools/grep-test.py /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-8a025cf8-8f08d8e2/tempworkdir-l/src /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-8a025cf8-8f08d8e2/tempworkdir-l/tests /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-8a025cf8-8f08d8e2/tempworkdir-l 0  > __res
CondTester, Testing instance id 59:
//src_file:src/dfasearch.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); void* memset(void*, int, unsigned long); 
/* dfasearch.c - searching subroutines using dfa and regex for grep.
   Copyright 1992, 1998, 2000, 2007, 2009-2010 Free Software Foundation, Inc.

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 3, or (at your option)
   any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program; if not, write to the Free Software
   Foundation, Inc., 51 Franklin Street - Fifth Floor, Boston, MA
   02110-1301, USA.  */

/* Written August 1992 by Mike Haertel. */

#include <config.h>
#include "search.h"
#include "dfa.h"

/* For -w, we also consider _ to be word constituent.  */
#define WCHAR(C) (ISALNUM(C) || (C) == '_')

/* KWset compiled pattern.  For Ecompile and Gcompile, we compile
   a list of strings, at least one of which is known to occur in
   any string matching the regexp. */
static kwset_t kwset;

/* DFA compiled regexp. */
static struct dfa dfa;

/* The Regex compiled patterns.  */
static struct patterns
{
  /* Regex compiled regexp. */
  struct re_pattern_buffer regexbuf;
  struct re_registers regs; /* This is here on account of a BRAIN-DEAD
			       Q@#%!# library interface in regex.c.  */
} patterns0;

struct patterns *patterns;
size_t pcount;

void
dfaerror (char const *mesg)
{
  error (EXIT_TROUBLE, 0, "%s", mesg);

  /* notreached */
  /* Tell static analyzers that this function does not return.  */
  abort ();
}

/* Number of compiled fixed strings known to exactly match the regexp.
   If kwsexec returns < kwset_exact_matches, then we don't need to
   call the regexp matcher at all. */
static int kwset_exact_matches;

static char const *
kwsincr_case (const char *must)
{
  const char *buf;
  size_t n;

  n = strlen (must);
#ifdef MBS_SUPPORT
  if (match_icase && MB_CUR_MAX > 1)
    buf = mbtolower (must, &n);
  else
#endif
    buf = must;
  return kwsincr (kwset, buf, n);
}

/* If the DFA turns out to have some set of fixed strings one of
   which must occur in the match, then we build a kwset matcher
   to find those strings, and thus quickly filter out impossible
   matches. */
static void
kwsmusts (void)
{
  struct dfamust const *dm;
  char const *err;

  if (dfa.musts)
    {
      kwsinit (&kwset);
      /* First, we compile in the substrings known to be exact
	 matches.  The kwset matcher will return the index
	 of the matching string that it chooses. */
      for (dm = dfa.musts; dm; dm = dm->next)
	{
	  if (!dm->exact)
	    continue;
	  ++kwset_exact_matches;
	  if ((err = kwsincr_case (dm->must)) != NULL)
	    error (EXIT_TROUBLE, 0, "%s", err);
	}
      /* Now, we compile the substrings that will require
	 the use of the regexp matcher.  */
      for (dm = dfa.musts; dm; dm = dm->next)
	{
	  if (dm->exact)
	    continue;
	  if ((err = kwsincr_case (dm->must)) != NULL)
	    error (EXIT_TROUBLE, 0, "%s", err);
	}
      if ((err = kwsprep (kwset)) != NULL)
	error (EXIT_TROUBLE, 0, "%s", err);
    }
}

void
GEAcompile (char const *pattern, size_t size, reg_syntax_t syntax_bits)
{
  const char *err;
  const char *p, *sep;
  size_t total = size;
  char *motif;

  if (match_icase)
    syntax_bits |= RE_ICASE;
  re_set_syntax (syntax_bits);
  dfasyntax (syntax_bits, match_icase, eolbyte);

  /* For GNU regex compiler we have to pass the patterns separately to detect
     errors like "[\nallo\n]\n".  The patterns here are "[", "allo" and "]"
     GNU regex should have raise a syntax error.  The same for backref, where
     the backref should have been local to each pattern.  */
  p = pattern;
  do
    {
      size_t len;
      sep = memchr (p, '\n', total);
      if (sep)
	{
	  len = sep - p;
	  sep++;
	  total -= (len + 1);
	}
      else
	{
	  len = total;
	  total = 0;
	}

      patterns = realloc (patterns, (pcount + 1) * sizeof (*patterns));
      if (patterns == NULL)
	error (EXIT_TROUBLE, errno, _("memory exhausted"));
      patterns[pcount] = patterns0;

      if ((err = re_compile_pattern (p, len,
				    &(patterns[pcount].regexbuf))) != NULL)
	error (EXIT_TROUBLE, 0, "%s", err);
      pcount++;

      p = sep;
    } while (sep && total != 0);

  /* In the match_words and match_lines cases, we use a different pattern
     for the DFA matcher that will quickly throw out cases that won't work.
     Then if DFA succeeds we do some hairy stuff using the regex matcher
     to decide whether the match should really count. */
  if (match_words || match_lines)
    {
      static char const line_beg_no_bk[] = "^(";
      static char const line_end_no_bk[] = ")$";
      static char const word_beg_no_bk[] = "(^|[^[:alnum:]_])(";
      static char const word_end_no_bk[] = ")([^[:alnum:]_]|$)";
      static char const line_beg_bk[] = "^\\(";
      static char const line_end_bk[] = "\\)$";
      static char const word_beg_bk[] = "\\(^\\|[^[:alnum:]_]\\)\\(";
      static char const word_end_bk[] = "\\)\\([^[:alnum:]_]\\|$\\)";
      int bk = !(syntax_bits & RE_NO_BK_PARENS);
      char *n = xmalloc (sizeof word_beg_bk - 1 + size + sizeof word_end_bk);

      strcpy (n, match_lines ? (bk ? line_beg_bk : line_beg_no_bk)
			     : (bk ? word_beg_bk : word_beg_no_bk));
      total = strlen(n);
      memcpy (n + total, pattern, size);
      total += size;
      strcpy (n + total, match_lines ? (bk ? line_end_bk : line_end_no_bk)
				     : (bk ? word_end_bk : word_end_no_bk));
      total += strlen (n + total);
      pattern = motif = n;
      size = total;
    }
  else
    motif = NULL;

  dfacomp (pattern, size, &dfa, 1);
  kwsmusts ();

  free(motif);
}

size_t
EGexecute (char const *buf, size_t size, size_t *match_size,
	   char const *start_ptr)
{
  char const *buflim, *beg, *end, *match, *best_match, *mb_start;
  char eol = eolbyte;
  int backref, start, len, best_len;
  struct kwsmatch kwsm;
  size_t i, ret_val;
#ifdef MBS_SUPPORT
  if (MB_CUR_MAX > 1)
    {
      if (match_icase)
        {
          /* mbtolower adds a NUL byte at the end.  That will provide
	     space for the sentinel byte dfaexec may add.  */
          char *case_buf = mbtolower (buf, &size);
	  if (start_ptr)
	    start_ptr = case_buf + (start_ptr - buf);
          buf = case_buf;
        }
    }
#endif /* MBS_SUPPORT */

  mb_start = buf;
  buflim = buf + size;

  for (beg = end = buf; end < buflim; beg = end)
    {
      if (!start_ptr)
	{
	  /* We don't care about an exact match.  */
	  if (kwset)
	    {
	      /* Find a possible match using the KWset matcher. */
	      size_t offset = kwsexec (kwset, beg, buflim - beg, &kwsm);
	      if (offset == (size_t) -1)
		goto failure;
	      beg += offset;
	      /* Narrow down to the line containing the candidate, and
		 run it through DFA. */
	      if ((end = memchr(beg, eol, buflim - beg)) != NULL)
	        end++;
              else
                end = buflim;
	      match = beg;
	      while (beg > buf && beg[-1] != eol)
		--beg;
	      if (kwsm.index < kwset_exact_matches)
                {
#ifdef MBS_SUPPORT
                  if (mb_start < beg)
                    mb_start = beg;
                  if (MB_CUR_MAX == 1 || !is_mb_middle (&mb_start, match, buflim))
#endif
                    goto success;
                }
	      if (dfaexec (&dfa, beg, (char *) end, 0, NULL, &backref) == NULL)
		continue;
	    }
	  else
	    {
	      /* No good fixed strings; start with DFA. */
	      char const *next_beg = dfaexec (&dfa, beg, (char *) buflim,
					      0, NULL, &backref);
	      if (next_beg == NULL)
		break;
	      /* Narrow down to the line we've found. */
	      beg = next_beg;
	      if ((end = memchr(beg, eol, buflim - beg)) != NULL)
	        end++;
              else
                end = buflim;
	      while (beg > buf && beg[-1] != eol)
		--beg;
	    }
	  /* Successful, no backreferences encountered! */
	  if (!backref)
	    goto success;
	}
      else
	{
	  /* We are looking for the leftmost (then longest) exact match.
	     We will go through the outer loop only once.  */
	  beg = start_ptr;
	  end = buflim;
	}

      /* If we've made it to this point, this means DFA has seen
	 a probable match, and we need to run it through Regex. */
      best_match = end;
      best_len = 0;
      for (i = 0; i < pcount; i++)
	{
	  patterns[i].regexbuf.not_eol = 0;
	  if (0 <= (start = re_search (&(patterns[i].regexbuf),
				       buf, end - buf - 1,
				       beg - buf, end - beg - 1,
				       &(patterns[i].regs))))
	    {
	      len = patterns[i].regs.end[0] - start;
	      match = buf + start;
	      if (match > best_match)
		continue;
	      if (start_ptr && !match_words)
		goto assess_pattern_match;
	      if ((!match_lines && !match_words)
		  || (match_lines && len == end - beg - 1))
		{
		  match = beg;
		  len = end - beg;
		  goto assess_pattern_match;
		}
	      /* If -w, check if the match aligns with word boundaries.
		 We do this iteratively because:
		 (a) the line may contain more than one occurence of the
		 pattern, and
		 (b) Several alternatives in the pattern might be valid at a
		 given point, and we may need to consider a shorter one to
		 find a word boundary.  */
	      if (match_words)
		while (match <= best_match)
		  {
		    if ((match == buf || !WCHAR ((unsigned char) match[-1]))
			&& (len == end - beg - 1
			    || !WCHAR ((unsigned char) match[len])))
		      goto assess_pattern_match;
		    if (len > 0)
		      {
			/* Try a shorter length anchored at the same place. */
			--len;
			patterns[i].regexbuf.not_eol = 1;
			len = re_match (&(patterns[i].regexbuf),
					buf, match + len - beg, match - buf,
					&(patterns[i].regs));
		      }
		    if (len <= 0)
		      {
			/* Try looking further on. */
			if (match == end - 1)
			  break;
			match++;
			patterns[i].regexbuf.not_eol = 0;
			start = re_search (&(patterns[i].regexbuf),
					   buf, end - buf - 1,
					   match - buf, end - match - 1,
					   &(patterns[i].regs));
			if (start < 0)
			  break;
			len = patterns[i].regs.end[0] - start;
			match = buf + start;
		      }
		  } /* while (match <= best_match) */
	      continue;
	    assess_pattern_match:
	      if (!start_ptr)
		{
		  /* Good enough for a non-exact match.
		     No need to look at further patterns, if any.  */
		  
//Patch 0:
if ((__is_neg(25, &(beg), sizeof (beg), &(match), sizeof (match), &(best_match), sizeof (best_match), &(len), sizeof (len), &(best_len), sizeof (best_len), &(start_ptr), sizeof (start_ptr), &(buf), sizeof (buf), &(start), sizeof (start), &(i), sizeof (i), &(patterns), sizeof (patterns), &(end), sizeof (end), &(ret_val), sizeof (ret_val), &(match_size), sizeof (match_size), &(match_words), sizeof (match_words), &(match_lines), sizeof (match_lines), &(pcount), sizeof (pcount), &(buflim), sizeof (buflim), &(backref), sizeof (backref), &(eol), sizeof (eol), &(mb_start), sizeof (mb_start), &(kwset_exact_matches), sizeof (kwset_exact_matches), &(kwset), sizeof (kwset), &(size), sizeof (size), &(match_icase), sizeof (match_icase), &(eolbyte), sizeof (eolbyte))))
    goto success;
beg = match;

//CodeSeg 1:
		  goto success_in_len;
		}
	      if (match < best_match || (match == best_match && len > best_len))
		{
		  /* Best exact match:  leftmost, then longest.  */
		  best_match = match;
		  best_len = len;
		}
	    } /* if re_search >= 0 */
	} /* for Regex patterns.  */
	if (best_match < end)
	  {
	    /* We have found an exact match.  We were just
	       waiting for the best one (leftmost then longest).  */
	    beg = best_match;
	    len = best_len;
	    goto success_in_len;
	  }
    } /* for (beg = end ..) */

 failure:
  ret_val = -1;
  goto out;

 success:
  len = end - beg;
 success_in_len:
  *match_size = len;
  ret_val = beg - buf;
 out:
  return ret_val;
}

Testing negative cases!
Testing 0 (with abstract condition) ENVIS_NEG
Iteration 0
Running test command:
/home/ubuntu/spr-fast/tools/grep-test.py /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-8a025cf8-8f08d8e2/tempworkdir-l/src /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-8a025cf8-8f08d8e2/tempworkdir-l/tests /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-8a025cf8-8f08d8e2/tempworkdir-l 0  > __res
Opening:/tmp/neg.tmp!
NegativeBRANCH RECORD/tmp/neg.tmp!
APPENDING TO ISNEG:/tmp/neg.tmp!
Branch 0: 0
Iteration 1
Running test command:
/home/ubuntu/spr-fast/tools/grep-test.py /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-8a025cf8-8f08d8e2/tempworkdir-l/src /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-8a025cf8-8f08d8e2/tempworkdir-l/tests /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-8a025cf8-8f08d8e2/tempworkdir-l 0  > __res
Opening:/tmp/neg.tmp!
NegativeBRANCH RECORD/tmp/neg.tmp!
APPENDING TO ISNEG:/tmp/neg.tmp!
Branch 0: 1
Passed in iteration!
Passed Negative Cases wiht CondTestder!
Testing positive cases!
Running test command:
/home/ubuntu/spr-fast/tools/grep-test.py /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-8a025cf8-8f08d8e2/tempworkdir-l/src /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-8a025cf8-8f08d8e2/tempworkdir-l/tests /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-8a025cf8-8f08d8e2/tempworkdir-l 11  > __res
Running test command:
/home/ubuntu/spr-fast/tools/grep-test.py /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-8a025cf8-8f08d8e2/tempworkdir-l/src /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-8a025cf8-8f08d8e2/tempworkdir-l/tests /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-8a025cf8-8f08d8e2/tempworkdir-l 14  > __res
Running test command:
/home/ubuntu/spr-fast/tools/grep-test.py /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-8a025cf8-8f08d8e2/tempworkdir-l/src /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-8a025cf8-8f08d8e2/tempworkdir-l/tests /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-8a025cf8-8f08d8e2/tempworkdir-l 17  > __res
Running test command:
/home/ubuntu/spr-fast/tools/grep-test.py /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-8a025cf8-8f08d8e2/tempworkdir-l/src /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-8a025cf8-8f08d8e2/tempworkdir-l/tests /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-8a025cf8-8f08d8e2/tempworkdir-l 22  > __res
Passed Positive Cases
Collect values for post processing!
WRITING TO ISNEG:/tmp/neg.tmp!
Running test command:
/home/ubuntu/spr-fast/tools/grep-test.py /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-8a025cf8-8f08d8e2/tempworkdir-l/src /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-8a025cf8-8f08d8e2/tempworkdir-l/tests /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-8a025cf8-8f08d8e2/tempworkdir-l 0  > __res
Running test command:
/home/ubuntu/spr-fast/tools/grep-test.py /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-8a025cf8-8f08d8e2/tempworkdir-l/src /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-8a025cf8-8f08d8e2/tempworkdir-l/tests /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-8a025cf8-8f08d8e2/tempworkdir-l 11  > __res
Running test command:
/home/ubuntu/spr-fast/tools/grep-test.py /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-8a025cf8-8f08d8e2/tempworkdir-l/src /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-8a025cf8-8f08d8e2/tempworkdir-l/tests /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-8a025cf8-8f08d8e2/tempworkdir-l 14  > __res
Running test command:
/home/ubuntu/spr-fast/tools/grep-test.py /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-8a025cf8-8f08d8e2/tempworkdir-l/src /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-8a025cf8-8f08d8e2/tempworkdir-l/tests /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-8a025cf8-8f08d8e2/tempworkdir-l 17  > __res
Running test command:
/home/ubuntu/spr-fast/tools/grep-test.py /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-8a025cf8-8f08d8e2/tempworkdir-l/src /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-8a025cf8-8f08d8e2/tempworkdir-l/tests /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-8a025cf8-8f08d8e2/tempworkdir-l 22  > __res
Passed!
CondTester, Testing instance id 60:
//src_file:src/dfasearch.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); void* memset(void*, int, unsigned long); 
/* dfasearch.c - searching subroutines using dfa and regex for grep.
   Copyright 1992, 1998, 2000, 2007, 2009-2010 Free Software Foundation, Inc.

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 3, or (at your option)
   any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program; if not, write to the Free Software
   Foundation, Inc., 51 Franklin Street - Fifth Floor, Boston, MA
   02110-1301, USA.  */

/* Written August 1992 by Mike Haertel. */

#include <config.h>
#include "search.h"
#include "dfa.h"

/* For -w, we also consider _ to be word constituent.  */
#define WCHAR(C) (ISALNUM(C) || (C) == '_')

/* KWset compiled pattern.  For Ecompile and Gcompile, we compile
   a list of strings, at least one of which is known to occur in
   any string matching the regexp. */
static kwset_t kwset;

/* DFA compiled regexp. */
static struct dfa dfa;

/* The Regex compiled patterns.  */
static struct patterns
{
  /* Regex compiled regexp. */
  struct re_pattern_buffer regexbuf;
  struct re_registers regs; /* This is here on account of a BRAIN-DEAD
			       Q@#%!# library interface in regex.c.  */
} patterns0;

struct patterns *patterns;
size_t pcount;

void
dfaerror (char const *mesg)
{
  error (EXIT_TROUBLE, 0, "%s", mesg);

  /* notreached */
  /* Tell static analyzers that this function does not return.  */
  abort ();
}

/* Number of compiled fixed strings known to exactly match the regexp.
   If kwsexec returns < kwset_exact_matches, then we don't need to
   call the regexp matcher at all. */
static int kwset_exact_matches;

static char const *
kwsincr_case (const char *must)
{
  const char *buf;
  size_t n;

  n = strlen (must);
#ifdef MBS_SUPPORT
  if (match_icase && MB_CUR_MAX > 1)
    buf = mbtolower (must, &n);
  else
#endif
    buf = must;
  return kwsincr (kwset, buf, n);
}

/* If the DFA turns out to have some set of fixed strings one of
   which must occur in the match, then we build a kwset matcher
   to find those strings, and thus quickly filter out impossible
   matches. */
static void
kwsmusts (void)
{
  struct dfamust const *dm;
  char const *err;

  if (dfa.musts)
    {
      kwsinit (&kwset);
      /* First, we compile in the substrings known to be exact
	 matches.  The kwset matcher will return the index
	 of the matching string that it chooses. */
      for (dm = dfa.musts; dm; dm = dm->next)
	{
	  if (!dm->exact)
	    continue;
	  ++kwset_exact_matches;
	  if ((err = kwsincr_case (dm->must)) != NULL)
	    error (EXIT_TROUBLE, 0, "%s", err);
	}
      /* Now, we compile the substrings that will require
	 the use of the regexp matcher.  */
      for (dm = dfa.musts; dm; dm = dm->next)
	{
	  if (dm->exact)
	    continue;
	  if ((err = kwsincr_case (dm->must)) != NULL)
	    error (EXIT_TROUBLE, 0, "%s", err);
	}
      if ((err = kwsprep (kwset)) != NULL)
	error (EXIT_TROUBLE, 0, "%s", err);
    }
}

void
GEAcompile (char const *pattern, size_t size, reg_syntax_t syntax_bits)
{
  const char *err;
  const char *p, *sep;
  size_t total = size;
  char *motif;

  if (match_icase)
    syntax_bits |= RE_ICASE;
  re_set_syntax (syntax_bits);
  dfasyntax (syntax_bits, match_icase, eolbyte);

  /* For GNU regex compiler we have to pass the patterns separately to detect
     errors like "[\nallo\n]\n".  The patterns here are "[", "allo" and "]"
     GNU regex should have raise a syntax error.  The same for backref, where
     the backref should have been local to each pattern.  */
  p = pattern;
  do
    {
      size_t len;
      sep = memchr (p, '\n', total);
      if (sep)
	{
	  len = sep - p;
	  sep++;
	  total -= (len + 1);
	}
      else
	{
	  len = total;
	  total = 0;
	}

      patterns = realloc (patterns, (pcount + 1) * sizeof (*patterns));
      if (patterns == NULL)
	error (EXIT_TROUBLE, errno, _("memory exhausted"));
      patterns[pcount] = patterns0;

      if ((err = re_compile_pattern (p, len,
				    &(patterns[pcount].regexbuf))) != NULL)
	error (EXIT_TROUBLE, 0, "%s", err);
      pcount++;

      p = sep;
    } while (sep && total != 0);

  /* In the match_words and match_lines cases, we use a different pattern
     for the DFA matcher that will quickly throw out cases that won't work.
     Then if DFA succeeds we do some hairy stuff using the regex matcher
     to decide whether the match should really count. */
  if (match_words || match_lines)
    {
      static char const line_beg_no_bk[] = "^(";
      static char const line_end_no_bk[] = ")$";
      static char const word_beg_no_bk[] = "(^|[^[:alnum:]_])(";
      static char const word_end_no_bk[] = ")([^[:alnum:]_]|$)";
      static char const line_beg_bk[] = "^\\(";
      static char const line_end_bk[] = "\\)$";
      static char const word_beg_bk[] = "\\(^\\|[^[:alnum:]_]\\)\\(";
      static char const word_end_bk[] = "\\)\\([^[:alnum:]_]\\|$\\)";
      int bk = !(syntax_bits & RE_NO_BK_PARENS);
      char *n = xmalloc (sizeof word_beg_bk - 1 + size + sizeof word_end_bk);

      strcpy (n, match_lines ? (bk ? line_beg_bk : line_beg_no_bk)
			     : (bk ? word_beg_bk : word_beg_no_bk));
      total = strlen(n);
      memcpy (n + total, pattern, size);
      total += size;
      strcpy (n + total, match_lines ? (bk ? line_end_bk : line_end_no_bk)
				     : (bk ? word_end_bk : word_end_no_bk));
      total += strlen (n + total);
      pattern = motif = n;
      size = total;
    }
  else
    motif = NULL;

  dfacomp (pattern, size, &dfa, 1);
  kwsmusts ();

  free(motif);
}

size_t
EGexecute (char const *buf, size_t size, size_t *match_size,
	   char const *start_ptr)
{
  char const *buflim, *beg, *end, *match, *best_match, *mb_start;
  char eol = eolbyte;
  int backref, start, len, best_len;
  struct kwsmatch kwsm;
  size_t i, ret_val;
#ifdef MBS_SUPPORT
  if (MB_CUR_MAX > 1)
    {
      if (match_icase)
        {
          /* mbtolower adds a NUL byte at the end.  That will provide
	     space for the sentinel byte dfaexec may add.  */
          char *case_buf = mbtolower (buf, &size);
	  if (start_ptr)
	    start_ptr = case_buf + (start_ptr - buf);
          buf = case_buf;
        }
    }
#endif /* MBS_SUPPORT */

  mb_start = buf;
  buflim = buf + size;

  for (beg = end = buf; end < buflim; beg = end)
    {
      if (!start_ptr)
	{
	  /* We don't care about an exact match.  */
	  if (kwset)
	    {
	      /* Find a possible match using the KWset matcher. */
	      size_t offset = kwsexec (kwset, beg, buflim - beg, &kwsm);
	      if (offset == (size_t) -1)
		goto failure;
	      beg += offset;
	      /* Narrow down to the line containing the candidate, and
		 run it through DFA. */
	      if ((end = memchr(beg, eol, buflim - beg)) != NULL)
	        end++;
              else
                end = buflim;
	      match = beg;
	      while (beg > buf && beg[-1] != eol)
		--beg;
	      if (kwsm.index < kwset_exact_matches)
                {
#ifdef MBS_SUPPORT
                  if (mb_start < beg)
                    mb_start = beg;
                  if (MB_CUR_MAX == 1 || !is_mb_middle (&mb_start, match, buflim))
#endif
                    goto success;
                }
	      if (dfaexec (&dfa, beg, (char *) end, 0, NULL, &backref) == NULL)
		continue;
	    }
	  else
	    {
	      /* No good fixed strings; start with DFA. */
	      char const *next_beg = dfaexec (&dfa, beg, (char *) buflim,
					      0, NULL, &backref);
	      if (next_beg == NULL)
		break;
	      /* Narrow down to the line we've found. */
	      beg = next_beg;
	      if ((end = memchr(beg, eol, buflim - beg)) != NULL)
	        end++;
              else
                end = buflim;
	      while (beg > buf && beg[-1] != eol)
		--beg;
	    }
	  /* Successful, no backreferences encountered! */
	  if (!backref)
	    goto success;
	}
      else
	{
	  /* We are looking for the leftmost (then longest) exact match.
	     We will go through the outer loop only once.  */
	  beg = start_ptr;
	  end = buflim;
	}

      /* If we've made it to this point, this means DFA has seen
	 a probable match, and we need to run it through Regex. */
      best_match = end;
      best_len = 0;
      for (i = 0; i < pcount; i++)
	{
	  patterns[i].regexbuf.not_eol = 0;
	  if (0 <= (start = re_search (&(patterns[i].regexbuf),
				       buf, end - buf - 1,
				       beg - buf, end - beg - 1,
				       &(patterns[i].regs))))
	    {
	      len = patterns[i].regs.end[0] - start;
	      match = buf + start;
	      if (match > best_match)
		continue;
	      if (start_ptr && !match_words)
		goto assess_pattern_match;
	      if ((!match_lines && !match_words)
		  || (match_lines && len == end - beg - 1))
		{
		  match = beg;
		  len = end - beg;
		  goto assess_pattern_match;
		}
	      /* If -w, check if the match aligns with word boundaries.
		 We do this iteratively because:
		 (a) the line may contain more than one occurence of the
		 pattern, and
		 (b) Several alternatives in the pattern might be valid at a
		 given point, and we may need to consider a shorter one to
		 find a word boundary.  */
	      if (match_words)
		while (match <= best_match)
		  {
		    if ((match == buf || !WCHAR ((unsigned char) match[-1]))
			&& (len == end - beg - 1
			    || !WCHAR ((unsigned char) match[len])))
		      goto assess_pattern_match;
		    if (len > 0)
		      {
			/* Try a shorter length anchored at the same place. */
			--len;
			patterns[i].regexbuf.not_eol = 1;
			len = re_match (&(patterns[i].regexbuf),
					buf, match + len - beg, match - buf,
					&(patterns[i].regs));
		      }
		    if (len <= 0)
		      {
			/* Try looking further on. */
			if (match == end - 1)
			  break;
			match++;
			patterns[i].regexbuf.not_eol = 0;
			start = re_search (&(patterns[i].regexbuf),
					   buf, end - buf - 1,
					   match - buf, end - match - 1,
					   &(patterns[i].regs));
			if (start < 0)
			  break;
			len = patterns[i].regs.end[0] - start;
			match = buf + start;
		      }
		  } /* while (match <= best_match) */
	      continue;
	    assess_pattern_match:
	      if (!start_ptr)
		{
		  /* Good enough for a non-exact match.
		     No need to look at further patterns, if any.  */
		  
//Patch 0:
if ((__is_neg(25, &(beg), sizeof (beg), &(match), sizeof (match), &(best_match), sizeof (best_match), &(len), sizeof (len), &(best_len), sizeof (best_len), &(start_ptr), sizeof (start_ptr), &(buf), sizeof (buf), &(start), sizeof (start), &(i), sizeof (i), &(patterns), sizeof (patterns), &(end), sizeof (end), &(ret_val), sizeof (ret_val), &(match_size), sizeof (match_size), &(match_words), sizeof (match_words), &(match_lines), sizeof (match_lines), &(pcount), sizeof (pcount), &(buflim), sizeof (buflim), &(backref), sizeof (backref), &(eol), sizeof (eol), &(mb_start), sizeof (mb_start), &(kwset_exact_matches), sizeof (kwset_exact_matches), &(kwset), sizeof (kwset), &(size), sizeof (size), &(match_icase), sizeof (match_icase), &(eolbyte), sizeof (eolbyte))))
    goto success_in_len;
beg = match;

//CodeSeg 1:
		  goto success_in_len;
		}
	      if (match < best_match || (match == best_match && len > best_len))
		{
		  /* Best exact match:  leftmost, then longest.  */
		  best_match = match;
		  best_len = len;
		}
	    } /* if re_search >= 0 */
	} /* for Regex patterns.  */
	if (best_match < end)
	  {
	    /* We have found an exact match.  We were just
	       waiting for the best one (leftmost then longest).  */
	    beg = best_match;
	    len = best_len;
	    goto success_in_len;
	  }
    } /* for (beg = end ..) */

 failure:
  ret_val = -1;
  goto out;

 success:
  len = end - beg;
 success_in_len:
  *match_size = len;
  ret_val = beg - buf;
 out:
  return ret_val;
}

Testing negative cases!
Testing 0 (with abstract condition) ENVIS_NEG
Iteration 0
Running test command:
/home/ubuntu/spr-fast/tools/grep-test.py /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-8a025cf8-8f08d8e2/tempworkdir-l/src /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-8a025cf8-8f08d8e2/tempworkdir-l/tests /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-8a025cf8-8f08d8e2/tempworkdir-l 0  > __res
Opening:/tmp/neg.tmp!
NegativeBRANCH RECORD/tmp/neg.tmp!
APPENDING TO ISNEG:/tmp/neg.tmp!
Branch 0: 0
Iteration 1
Running test command:
/home/ubuntu/spr-fast/tools/grep-test.py /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-8a025cf8-8f08d8e2/tempworkdir-l/src /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-8a025cf8-8f08d8e2/tempworkdir-l/tests /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-8a025cf8-8f08d8e2/tempworkdir-l 0  > __res
Opening:/tmp/neg.tmp!
NegativeBRANCH RECORD/tmp/neg.tmp!
APPENDING TO ISNEG:/tmp/neg.tmp!
Branch 0: 1
Running test command:
/home/ubuntu/spr-fast/tools/grep-test.py /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-8a025cf8-8f08d8e2/tempworkdir-l/src /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-8a025cf8-8f08d8e2/tempworkdir-l/tests /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-8a025cf8-8f08d8e2/tempworkdir-l 0  > __res
CondTester, Testing instance id 61:
//src_file:src/dfasearch.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); void* memset(void*, int, unsigned long); 
/* dfasearch.c - searching subroutines using dfa and regex for grep.
   Copyright 1992, 1998, 2000, 2007, 2009-2010 Free Software Foundation, Inc.

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 3, or (at your option)
   any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program; if not, write to the Free Software
   Foundation, Inc., 51 Franklin Street - Fifth Floor, Boston, MA
   02110-1301, USA.  */

/* Written August 1992 by Mike Haertel. */

#include <config.h>
#include "search.h"
#include "dfa.h"

/* For -w, we also consider _ to be word constituent.  */
#define WCHAR(C) (ISALNUM(C) || (C) == '_')

/* KWset compiled pattern.  For Ecompile and Gcompile, we compile
   a list of strings, at least one of which is known to occur in
   any string matching the regexp. */
static kwset_t kwset;

/* DFA compiled regexp. */
static struct dfa dfa;

/* The Regex compiled patterns.  */
static struct patterns
{
  /* Regex compiled regexp. */
  struct re_pattern_buffer regexbuf;
  struct re_registers regs; /* This is here on account of a BRAIN-DEAD
			       Q@#%!# library interface in regex.c.  */
} patterns0;

struct patterns *patterns;
size_t pcount;

void
dfaerror (char const *mesg)
{
  error (EXIT_TROUBLE, 0, "%s", mesg);

  /* notreached */
  /* Tell static analyzers that this function does not return.  */
  abort ();
}

/* Number of compiled fixed strings known to exactly match the regexp.
   If kwsexec returns < kwset_exact_matches, then we don't need to
   call the regexp matcher at all. */
static int kwset_exact_matches;

static char const *
kwsincr_case (const char *must)
{
  const char *buf;
  size_t n;

  n = strlen (must);
#ifdef MBS_SUPPORT
  if (match_icase && MB_CUR_MAX > 1)
    buf = mbtolower (must, &n);
  else
#endif
    buf = must;
  return kwsincr (kwset, buf, n);
}

/* If the DFA turns out to have some set of fixed strings one of
   which must occur in the match, then we build a kwset matcher
   to find those strings, and thus quickly filter out impossible
   matches. */
static void
kwsmusts (void)
{
  struct dfamust const *dm;
  char const *err;

  if (dfa.musts)
    {
      kwsinit (&kwset);
      /* First, we compile in the substrings known to be exact
	 matches.  The kwset matcher will return the index
	 of the matching string that it chooses. */
      for (dm = dfa.musts; dm; dm = dm->next)
	{
	  if (!dm->exact)
	    continue;
	  ++kwset_exact_matches;
	  if ((err = kwsincr_case (dm->must)) != NULL)
	    error (EXIT_TROUBLE, 0, "%s", err);
	}
      /* Now, we compile the substrings that will require
	 the use of the regexp matcher.  */
      for (dm = dfa.musts; dm; dm = dm->next)
	{
	  if (dm->exact)
	    continue;
	  if ((err = kwsincr_case (dm->must)) != NULL)
	    error (EXIT_TROUBLE, 0, "%s", err);
	}
      if ((err = kwsprep (kwset)) != NULL)
	error (EXIT_TROUBLE, 0, "%s", err);
    }
}

void
GEAcompile (char const *pattern, size_t size, reg_syntax_t syntax_bits)
{
  const char *err;
  const char *p, *sep;
  size_t total = size;
  char *motif;

  if (match_icase)
    syntax_bits |= RE_ICASE;
  re_set_syntax (syntax_bits);
  dfasyntax (syntax_bits, match_icase, eolbyte);

  /* For GNU regex compiler we have to pass the patterns separately to detect
     errors like "[\nallo\n]\n".  The patterns here are "[", "allo" and "]"
     GNU regex should have raise a syntax error.  The same for backref, where
     the backref should have been local to each pattern.  */
  p = pattern;
  do
    {
      size_t len;
      sep = memchr (p, '\n', total);
      if (sep)
	{
	  len = sep - p;
	  sep++;
	  total -= (len + 1);
	}
      else
	{
	  len = total;
	  total = 0;
	}

      patterns = realloc (patterns, (pcount + 1) * sizeof (*patterns));
      if (patterns == NULL)
	error (EXIT_TROUBLE, errno, _("memory exhausted"));
      patterns[pcount] = patterns0;

      if ((err = re_compile_pattern (p, len,
				    &(patterns[pcount].regexbuf))) != NULL)
	error (EXIT_TROUBLE, 0, "%s", err);
      pcount++;

      p = sep;
    } while (sep && total != 0);

  /* In the match_words and match_lines cases, we use a different pattern
     for the DFA matcher that will quickly throw out cases that won't work.
     Then if DFA succeeds we do some hairy stuff using the regex matcher
     to decide whether the match should really count. */
  if (match_words || match_lines)
    {
      static char const line_beg_no_bk[] = "^(";
      static char const line_end_no_bk[] = ")$";
      static char const word_beg_no_bk[] = "(^|[^[:alnum:]_])(";
      static char const word_end_no_bk[] = ")([^[:alnum:]_]|$)";
      static char const line_beg_bk[] = "^\\(";
      static char const line_end_bk[] = "\\)$";
      static char const word_beg_bk[] = "\\(^\\|[^[:alnum:]_]\\)\\(";
      static char const word_end_bk[] = "\\)\\([^[:alnum:]_]\\|$\\)";
      int bk = !(syntax_bits & RE_NO_BK_PARENS);
      char *n = xmalloc (sizeof word_beg_bk - 1 + size + sizeof word_end_bk);

      strcpy (n, match_lines ? (bk ? line_beg_bk : line_beg_no_bk)
			     : (bk ? word_beg_bk : word_beg_no_bk));
      total = strlen(n);
      memcpy (n + total, pattern, size);
      total += size;
      strcpy (n + total, match_lines ? (bk ? line_end_bk : line_end_no_bk)
				     : (bk ? word_end_bk : word_end_no_bk));
      total += strlen (n + total);
      pattern = motif = n;
      size = total;
    }
  else
    motif = NULL;

  dfacomp (pattern, size, &dfa, 1);
  kwsmusts ();

  free(motif);
}

size_t
EGexecute (char const *buf, size_t size, size_t *match_size,
	   char const *start_ptr)
{
  char const *buflim, *beg, *end, *match, *best_match, *mb_start;
  char eol = eolbyte;
  int backref, start, len, best_len;
  struct kwsmatch kwsm;
  size_t i, ret_val;
#ifdef MBS_SUPPORT
  if (MB_CUR_MAX > 1)
    {
      if (match_icase)
        {
          /* mbtolower adds a NUL byte at the end.  That will provide
	     space for the sentinel byte dfaexec may add.  */
          char *case_buf = mbtolower (buf, &size);
	  if (start_ptr)
	    start_ptr = case_buf + (start_ptr - buf);
          buf = case_buf;
        }
    }
#endif /* MBS_SUPPORT */

  mb_start = buf;
  buflim = buf + size;

  for (beg = end = buf; end < buflim; beg = end)
    {
      if (!start_ptr)
	{
	  /* We don't care about an exact match.  */
	  if (kwset)
	    {
	      /* Find a possible match using the KWset matcher. */
	      size_t offset = kwsexec (kwset, beg, buflim - beg, &kwsm);
	      if (offset == (size_t) -1)
		goto failure;
	      beg += offset;
	      /* Narrow down to the line containing the candidate, and
		 run it through DFA. */
	      if ((end = memchr(beg, eol, buflim - beg)) != NULL)
	        end++;
              else
                end = buflim;
	      match = beg;
	      while (beg > buf && beg[-1] != eol)
		--beg;
	      if (kwsm.index < kwset_exact_matches)
                {
#ifdef MBS_SUPPORT
                  if (mb_start < beg)
                    mb_start = beg;
                  if (MB_CUR_MAX == 1 || !is_mb_middle (&mb_start, match, buflim))
#endif
                    goto success;
                }
	      if (dfaexec (&dfa, beg, (char *) end, 0, NULL, &backref) == NULL)
		continue;
	    }
	  else
	    {
	      /* No good fixed strings; start with DFA. */
	      char const *next_beg = dfaexec (&dfa, beg, (char *) buflim,
					      0, NULL, &backref);
	      if (next_beg == NULL)
		break;
	      /* Narrow down to the line we've found. */
	      beg = next_beg;
	      if ((end = memchr(beg, eol, buflim - beg)) != NULL)
	        end++;
              else
                end = buflim;
	      while (beg > buf && beg[-1] != eol)
		--beg;
	    }
	  /* Successful, no backreferences encountered! */
	  if (!backref)
	    goto success;
	}
      else
	{
	  /* We are looking for the leftmost (then longest) exact match.
	     We will go through the outer loop only once.  */
	  beg = start_ptr;
	  end = buflim;
	}

      /* If we've made it to this point, this means DFA has seen
	 a probable match, and we need to run it through Regex. */
      best_match = end;
      best_len = 0;
      for (i = 0; i < pcount; i++)
	{
	  patterns[i].regexbuf.not_eol = 0;
	  if (0 <= (start = re_search (&(patterns[i].regexbuf),
				       buf, end - buf - 1,
				       beg - buf, end - beg - 1,
				       &(patterns[i].regs))))
	    {
	      len = patterns[i].regs.end[0] - start;
	      match = buf + start;
	      if (match > best_match)
		continue;
	      if (start_ptr && !match_words)
		goto assess_pattern_match;
	      if ((!match_lines && !match_words)
		  || (match_lines && len == end - beg - 1))
		{
		  match = beg;
		  len = end - beg;
		  goto assess_pattern_match;
		}
	      /* If -w, check if the match aligns with word boundaries.
		 We do this iteratively because:
		 (a) the line may contain more than one occurence of the
		 pattern, and
		 (b) Several alternatives in the pattern might be valid at a
		 given point, and we may need to consider a shorter one to
		 find a word boundary.  */
	      if (match_words)
		while (match <= best_match)
		  {
		    if ((match == buf || !WCHAR ((unsigned char) match[-1]))
			&& (len == end - beg - 1
			    || !WCHAR ((unsigned char) match[len])))
		      goto assess_pattern_match;
		    if (len > 0)
		      {
			/* Try a shorter length anchored at the same place. */
			--len;
			patterns[i].regexbuf.not_eol = 1;
			len = re_match (&(patterns[i].regexbuf),
					buf, match + len - beg, match - buf,
					&(patterns[i].regs));
		      }
		    if (len <= 0)
		      {
			/* Try looking further on. */
			if (match == end - 1)
			  break;
			match++;
			patterns[i].regexbuf.not_eol = 0;
			start = re_search (&(patterns[i].regexbuf),
					   buf, end - buf - 1,
					   match - buf, end - match - 1,
					   &(patterns[i].regs));
			if (start < 0)
			  break;
			len = patterns[i].regs.end[0] - start;
			match = buf + start;
		      }
		  } /* while (match <= best_match) */
	      continue;
	    assess_pattern_match:
	      if (!start_ptr)
		{
		  /* Good enough for a non-exact match.
		     No need to look at further patterns, if any.  */
		  
//Patch 0:
if ((__is_neg(25, &(beg), sizeof (beg), &(match), sizeof (match), &(best_match), sizeof (best_match), &(len), sizeof (len), &(best_len), sizeof (best_len), &(start_ptr), sizeof (start_ptr), &(buf), sizeof (buf), &(start), sizeof (start), &(i), sizeof (i), &(patterns), sizeof (patterns), &(end), sizeof (end), &(ret_val), sizeof (ret_val), &(match_size), sizeof (match_size), &(match_words), sizeof (match_words), &(match_lines), sizeof (match_lines), &(pcount), sizeof (pcount), &(buflim), sizeof (buflim), &(backref), sizeof (backref), &(eol), sizeof (eol), &(mb_start), sizeof (mb_start), &(kwset_exact_matches), sizeof (kwset_exact_matches), &(kwset), sizeof (kwset), &(size), sizeof (size), &(match_icase), sizeof (match_icase), &(eolbyte), sizeof (eolbyte))))
    goto out;
beg = match;

//CodeSeg 1:
		  goto success_in_len;
		}
	      if (match < best_match || (match == best_match && len > best_len))
		{
		  /* Best exact match:  leftmost, then longest.  */
		  best_match = match;
		  best_len = len;
		}
	    } /* if re_search >= 0 */
	} /* for Regex patterns.  */
	if (best_match < end)
	  {
	    /* We have found an exact match.  We were just
	       waiting for the best one (leftmost then longest).  */
	    beg = best_match;
	    len = best_len;
	    goto success_in_len;
	  }
    } /* for (beg = end ..) */

 failure:
  ret_val = -1;
  goto out;

 success:
  len = end - beg;
 success_in_len:
  *match_size = len;
  ret_val = beg - buf;
 out:
  return ret_val;
}

Testing negative cases!
Testing 0 (with abstract condition) ENVIS_NEG
Iteration 0
Running test command:
/home/ubuntu/spr-fast/tools/grep-test.py /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-8a025cf8-8f08d8e2/tempworkdir-l/src /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-8a025cf8-8f08d8e2/tempworkdir-l/tests /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-8a025cf8-8f08d8e2/tempworkdir-l 0  > __res
Opening:/tmp/neg.tmp!
NegativeBRANCH RECORD/tmp/neg.tmp!
APPENDING TO ISNEG:/tmp/neg.tmp!
Branch 0: 0
Iteration 1
Running test command:
/home/ubuntu/spr-fast/tools/grep-test.py /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-8a025cf8-8f08d8e2/tempworkdir-l/src /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-8a025cf8-8f08d8e2/tempworkdir-l/tests /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-8a025cf8-8f08d8e2/tempworkdir-l 0  > __res
Opening:/tmp/neg.tmp!
NegativeBRANCH RECORD/tmp/neg.tmp!
APPENDING TO ISNEG:/tmp/neg.tmp!
Branch 0: 1
Running test command:
/home/ubuntu/spr-fast/tools/grep-test.py /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-8a025cf8-8f08d8e2/tempworkdir-l/src /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-8a025cf8-8f08d8e2/tempworkdir-l/tests /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-8a025cf8-8f08d8e2/tempworkdir-l 0  > __res
CondTester, Testing instance id 67:
//src_file:src/dfasearch.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); void* memset(void*, int, unsigned long); 
/* dfasearch.c - searching subroutines using dfa and regex for grep.
   Copyright 1992, 1998, 2000, 2007, 2009-2010 Free Software Foundation, Inc.

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 3, or (at your option)
   any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program; if not, write to the Free Software
   Foundation, Inc., 51 Franklin Street - Fifth Floor, Boston, MA
   02110-1301, USA.  */

/* Written August 1992 by Mike Haertel. */

#include <config.h>
#include "search.h"
#include "dfa.h"

/* For -w, we also consider _ to be word constituent.  */
#define WCHAR(C) (ISALNUM(C) || (C) == '_')

/* KWset compiled pattern.  For Ecompile and Gcompile, we compile
   a list of strings, at least one of which is known to occur in
   any string matching the regexp. */
static kwset_t kwset;

/* DFA compiled regexp. */
static struct dfa dfa;

/* The Regex compiled patterns.  */
static struct patterns
{
  /* Regex compiled regexp. */
  struct re_pattern_buffer regexbuf;
  struct re_registers regs; /* This is here on account of a BRAIN-DEAD
			       Q@#%!# library interface in regex.c.  */
} patterns0;

struct patterns *patterns;
size_t pcount;

void
dfaerror (char const *mesg)
{
  error (EXIT_TROUBLE, 0, "%s", mesg);

  /* notreached */
  /* Tell static analyzers that this function does not return.  */
  abort ();
}

/* Number of compiled fixed strings known to exactly match the regexp.
   If kwsexec returns < kwset_exact_matches, then we don't need to
   call the regexp matcher at all. */
static int kwset_exact_matches;

static char const *
kwsincr_case (const char *must)
{
  const char *buf;
  size_t n;

  n = strlen (must);
#ifdef MBS_SUPPORT
  if (match_icase && MB_CUR_MAX > 1)
    buf = mbtolower (must, &n);
  else
#endif
    buf = must;
  return kwsincr (kwset, buf, n);
}

/* If the DFA turns out to have some set of fixed strings one of
   which must occur in the match, then we build a kwset matcher
   to find those strings, and thus quickly filter out impossible
   matches. */
static void
kwsmusts (void)
{
  struct dfamust const *dm;
  char const *err;

  if (dfa.musts)
    {
      kwsinit (&kwset);
      /* First, we compile in the substrings known to be exact
	 matches.  The kwset matcher will return the index
	 of the matching string that it chooses. */
      for (dm = dfa.musts; dm; dm = dm->next)
	{
	  if (!dm->exact)
	    continue;
	  ++kwset_exact_matches;
	  if ((err = kwsincr_case (dm->must)) != NULL)
	    error (EXIT_TROUBLE, 0, "%s", err);
	}
      /* Now, we compile the substrings that will require
	 the use of the regexp matcher.  */
      for (dm = dfa.musts; dm; dm = dm->next)
	{
	  if (dm->exact)
	    continue;
	  if ((err = kwsincr_case (dm->must)) != NULL)
	    error (EXIT_TROUBLE, 0, "%s", err);
	}
      if ((err = kwsprep (kwset)) != NULL)
	error (EXIT_TROUBLE, 0, "%s", err);
    }
}

void
GEAcompile (char const *pattern, size_t size, reg_syntax_t syntax_bits)
{
  const char *err;
  const char *p, *sep;
  size_t total = size;
  char *motif;

  if (match_icase)
    syntax_bits |= RE_ICASE;
  re_set_syntax (syntax_bits);
  dfasyntax (syntax_bits, match_icase, eolbyte);

  /* For GNU regex compiler we have to pass the patterns separately to detect
     errors like "[\nallo\n]\n".  The patterns here are "[", "allo" and "]"
     GNU regex should have raise a syntax error.  The same for backref, where
     the backref should have been local to each pattern.  */
  p = pattern;
  do
    {
      size_t len;
      sep = memchr (p, '\n', total);
      if (sep)
	{
	  len = sep - p;
	  sep++;
	  total -= (len + 1);
	}
      else
	{
	  len = total;
	  total = 0;
	}

      patterns = realloc (patterns, (pcount + 1) * sizeof (*patterns));
      if (patterns == NULL)
	error (EXIT_TROUBLE, errno, _("memory exhausted"));
      patterns[pcount] = patterns0;

      if ((err = re_compile_pattern (p, len,
				    &(patterns[pcount].regexbuf))) != NULL)
	error (EXIT_TROUBLE, 0, "%s", err);
      pcount++;

      p = sep;
    } while (sep && total != 0);

  /* In the match_words and match_lines cases, we use a different pattern
     for the DFA matcher that will quickly throw out cases that won't work.
     Then if DFA succeeds we do some hairy stuff using the regex matcher
     to decide whether the match should really count. */
  if (match_words || match_lines)
    {
      static char const line_beg_no_bk[] = "^(";
      static char const line_end_no_bk[] = ")$";
      static char const word_beg_no_bk[] = "(^|[^[:alnum:]_])(";
      static char const word_end_no_bk[] = ")([^[:alnum:]_]|$)";
      static char const line_beg_bk[] = "^\\(";
      static char const line_end_bk[] = "\\)$";
      static char const word_beg_bk[] = "\\(^\\|[^[:alnum:]_]\\)\\(";
      static char const word_end_bk[] = "\\)\\([^[:alnum:]_]\\|$\\)";
      int bk = !(syntax_bits & RE_NO_BK_PARENS);
      char *n = xmalloc (sizeof word_beg_bk - 1 + size + sizeof word_end_bk);

      strcpy (n, match_lines ? (bk ? line_beg_bk : line_beg_no_bk)
			     : (bk ? word_beg_bk : word_beg_no_bk));
      total = strlen(n);
      memcpy (n + total, pattern, size);
      total += size;
      strcpy (n + total, match_lines ? (bk ? line_end_bk : line_end_no_bk)
				     : (bk ? word_end_bk : word_end_no_bk));
      total += strlen (n + total);
      pattern = motif = n;
      size = total;
    }
  else
    motif = NULL;

  dfacomp (pattern, size, &dfa, 1);
  kwsmusts ();

  free(motif);
}

size_t
EGexecute (char const *buf, size_t size, size_t *match_size,
	   char const *start_ptr)
{
  char const *buflim, *beg, *end, *match, *best_match, *mb_start;
  char eol = eolbyte;
  int backref, start, len, best_len;
  struct kwsmatch kwsm;
  size_t i, ret_val;
#ifdef MBS_SUPPORT
  if (MB_CUR_MAX > 1)
    {
      if (match_icase)
        {
          /* mbtolower adds a NUL byte at the end.  That will provide
	     space for the sentinel byte dfaexec may add.  */
          char *case_buf = mbtolower (buf, &size);
	  if (start_ptr)
	    start_ptr = case_buf + (start_ptr - buf);
          buf = case_buf;
        }
    }
#endif /* MBS_SUPPORT */

  mb_start = buf;
  buflim = buf + size;

  for (beg = end = buf; end < buflim; beg = end)
    {
      if (!start_ptr)
	{
	  /* We don't care about an exact match.  */
	  if (kwset)
	    {
	      /* Find a possible match using the KWset matcher. */
	      size_t offset = kwsexec (kwset, beg, buflim - beg, &kwsm);
	      if (offset == (size_t) -1)
		goto failure;
	      beg += offset;
	      /* Narrow down to the line containing the candidate, and
		 run it through DFA. */
	      if ((end = memchr(beg, eol, buflim - beg)) != NULL)
	        end++;
              else
                end = buflim;
	      match = beg;
	      while (beg > buf && beg[-1] != eol)
		--beg;
	      if (kwsm.index < kwset_exact_matches)
                {
#ifdef MBS_SUPPORT
                  if (mb_start < beg)
                    mb_start = beg;
                  if (MB_CUR_MAX == 1 || !is_mb_middle (&mb_start, match, buflim))
#endif
                    goto success;
                }
	      if (dfaexec (&dfa, beg, (char *) end, 0, NULL, &backref) == NULL)
		continue;
	    }
	  else
	    {
	      /* No good fixed strings; start with DFA. */
	      char const *next_beg = dfaexec (&dfa, beg, (char *) buflim,
					      0, NULL, &backref);
	      if (next_beg == NULL)
		break;
	      /* Narrow down to the line we've found. */
	      beg = next_beg;
	      if ((end = memchr(beg, eol, buflim - beg)) != NULL)
	        end++;
              else
                end = buflim;
	      while (beg > buf && beg[-1] != eol)
		--beg;
	    }
	  /* Successful, no backreferences encountered! */
	  if (!backref)
	    goto success;
	}
      else
	{
	  /* We are looking for the leftmost (then longest) exact match.
	     We will go through the outer loop only once.  */
	  beg = start_ptr;
	  end = buflim;
	}

      /* If we've made it to this point, this means DFA has seen
	 a probable match, and we need to run it through Regex. */
      best_match = end;
      best_len = 0;
      for (i = 0; i < pcount; i++)
	{
	  patterns[i].regexbuf.not_eol = 0;
	  if (0 <= (start = re_search (&(patterns[i].regexbuf),
				       buf, end - buf - 1,
				       beg - buf, end - beg - 1,
				       &(patterns[i].regs))))
	    {
	      len = patterns[i].regs.end[0] - start;
	      match = buf + start;
	      if (match > best_match)
		continue;
	      if (start_ptr && !match_words)
		goto assess_pattern_match;
	      if ((!match_lines && !match_words)
		  || (match_lines && len == end - beg - 1))
		{
		  match = beg;
		  len = end - beg;
		  goto assess_pattern_match;
		}
	      /* If -w, check if the match aligns with word boundaries.
		 We do this iteratively because:
		 (a) the line may contain more than one occurence of the
		 pattern, and
		 (b) Several alternatives in the pattern might be valid at a
		 given point, and we may need to consider a shorter one to
		 find a word boundary.  */
	      if (match_words)
		while (match <= best_match)
		  {
		    if ((match == buf || !WCHAR ((unsigned char) match[-1]))
			&& (len == end - beg - 1
			    || !WCHAR ((unsigned char) match[len])))
		      goto assess_pattern_match;
		    if (len > 0)
		      {
			/* Try a shorter length anchored at the same place. */
			--len;
			patterns[i].regexbuf.not_eol = 1;
			len = re_match (&(patterns[i].regexbuf),
					buf, match + len - beg, match - buf,
					&(patterns[i].regs));
		      }
		    if (len <= 0)
		      {
			/* Try looking further on. */
			if (match == end - 1)
			  break;
			match++;
			patterns[i].regexbuf.not_eol = 0;
			start = re_search (&(patterns[i].regexbuf),
					   buf, end - buf - 1,
					   match - buf, end - match - 1,
					   &(patterns[i].regs));
			if (start < 0)
			  break;
			len = patterns[i].regs.end[0] - start;
			match = buf + start;
		      }
		  } /* while (match <= best_match) */
	      continue;
	    assess_pattern_match:
	      if (!start_ptr)
		{
		  /* Good enough for a non-exact match.
		     No need to look at further patterns, if any.  */
		  
//Patch 0:
if ((__is_neg(25, &(beg), sizeof (beg), &(match), sizeof (match), &(best_match), sizeof (best_match), &(len), sizeof (len), &(best_len), sizeof (best_len), &(start_ptr), sizeof (start_ptr), &(buf), sizeof (buf), &(start), sizeof (start), &(i), sizeof (i), &(patterns), sizeof (patterns), &(end), sizeof (end), &(ret_val), sizeof (ret_val), &(match_size), sizeof (match_size), &(match_words), sizeof (match_words), &(match_lines), sizeof (match_lines), &(pcount), sizeof (pcount), &(buflim), sizeof (buflim), &(backref), sizeof (backref), &(eol), sizeof (eol), &(mb_start), sizeof (mb_start), &(kwset_exact_matches), sizeof (kwset_exact_matches), &(kwset), sizeof (kwset), &(size), sizeof (size), &(match_icase), sizeof (match_icase), &(eolbyte), sizeof (eolbyte))))
    return -1;
beg = match;

//CodeSeg 1:
		  goto success_in_len;
		}
	      if (match < best_match || (match == best_match && len > best_len))
		{
		  /* Best exact match:  leftmost, then longest.  */
		  best_match = match;
		  best_len = len;
		}
	    } /* if re_search >= 0 */
	} /* for Regex patterns.  */
	if (best_match < end)
	  {
	    /* We have found an exact match.  We were just
	       waiting for the best one (leftmost then longest).  */
	    beg = best_match;
	    len = best_len;
	    goto success_in_len;
	  }
    } /* for (beg = end ..) */

 failure:
  ret_val = -1;
  goto out;

 success:
  len = end - beg;
 success_in_len:
  *match_size = len;
  ret_val = beg - buf;
 out:
  return ret_val;
}

Testing negative cases!
Testing 0 (with abstract condition) ENVIS_NEG
Iteration 0
Running test command:
/home/ubuntu/spr-fast/tools/grep-test.py /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-8a025cf8-8f08d8e2/tempworkdir-l/src /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-8a025cf8-8f08d8e2/tempworkdir-l/tests /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-8a025cf8-8f08d8e2/tempworkdir-l 0  > __res
Opening:/tmp/neg.tmp!
NegativeBRANCH RECORD/tmp/neg.tmp!
APPENDING TO ISNEG:/tmp/neg.tmp!
Branch 0: 0
Iteration 1
Running test command:
/home/ubuntu/spr-fast/tools/grep-test.py /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-8a025cf8-8f08d8e2/tempworkdir-l/src /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-8a025cf8-8f08d8e2/tempworkdir-l/tests /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-8a025cf8-8f08d8e2/tempworkdir-l 0  > __res
Opening:/tmp/neg.tmp!
NegativeBRANCH RECORD/tmp/neg.tmp!
APPENDING TO ISNEG:/tmp/neg.tmp!
Branch 0: 1
Running test command:
/home/ubuntu/spr-fast/tools/grep-test.py /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-8a025cf8-8f08d8e2/tempworkdir-l/src /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-8a025cf8-8f08d8e2/tempworkdir-l/tests /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-8a025cf8-8f08d8e2/tempworkdir-l 0  > __res
CondTester, Testing instance id 68:
//src_file:src/dfasearch.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); void* memset(void*, int, unsigned long); 
/* dfasearch.c - searching subroutines using dfa and regex for grep.
   Copyright 1992, 1998, 2000, 2007, 2009-2010 Free Software Foundation, Inc.

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 3, or (at your option)
   any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program; if not, write to the Free Software
   Foundation, Inc., 51 Franklin Street - Fifth Floor, Boston, MA
   02110-1301, USA.  */

/* Written August 1992 by Mike Haertel. */

#include <config.h>
#include "search.h"
#include "dfa.h"

/* For -w, we also consider _ to be word constituent.  */
#define WCHAR(C) (ISALNUM(C) || (C) == '_')

/* KWset compiled pattern.  For Ecompile and Gcompile, we compile
   a list of strings, at least one of which is known to occur in
   any string matching the regexp. */
static kwset_t kwset;

/* DFA compiled regexp. */
static struct dfa dfa;

/* The Regex compiled patterns.  */
static struct patterns
{
  /* Regex compiled regexp. */
  struct re_pattern_buffer regexbuf;
  struct re_registers regs; /* This is here on account of a BRAIN-DEAD
			       Q@#%!# library interface in regex.c.  */
} patterns0;

struct patterns *patterns;
size_t pcount;

void
dfaerror (char const *mesg)
{
  error (EXIT_TROUBLE, 0, "%s", mesg);

  /* notreached */
  /* Tell static analyzers that this function does not return.  */
  abort ();
}

/* Number of compiled fixed strings known to exactly match the regexp.
   If kwsexec returns < kwset_exact_matches, then we don't need to
   call the regexp matcher at all. */
static int kwset_exact_matches;

static char const *
kwsincr_case (const char *must)
{
  const char *buf;
  size_t n;

  n = strlen (must);
#ifdef MBS_SUPPORT
  if (match_icase && MB_CUR_MAX > 1)
    buf = mbtolower (must, &n);
  else
#endif
    buf = must;
  return kwsincr (kwset, buf, n);
}

/* If the DFA turns out to have some set of fixed strings one of
   which must occur in the match, then we build a kwset matcher
   to find those strings, and thus quickly filter out impossible
   matches. */
static void
kwsmusts (void)
{
  struct dfamust const *dm;
  char const *err;

  if (dfa.musts)
    {
      kwsinit (&kwset);
      /* First, we compile in the substrings known to be exact
	 matches.  The kwset matcher will return the index
	 of the matching string that it chooses. */
      for (dm = dfa.musts; dm; dm = dm->next)
	{
	  if (!dm->exact)
	    continue;
	  ++kwset_exact_matches;
	  if ((err = kwsincr_case (dm->must)) != NULL)
	    error (EXIT_TROUBLE, 0, "%s", err);
	}
      /* Now, we compile the substrings that will require
	 the use of the regexp matcher.  */
      for (dm = dfa.musts; dm; dm = dm->next)
	{
	  if (dm->exact)
	    continue;
	  if ((err = kwsincr_case (dm->must)) != NULL)
	    error (EXIT_TROUBLE, 0, "%s", err);
	}
      if ((err = kwsprep (kwset)) != NULL)
	error (EXIT_TROUBLE, 0, "%s", err);
    }
}

void
GEAcompile (char const *pattern, size_t size, reg_syntax_t syntax_bits)
{
  const char *err;
  const char *p, *sep;
  size_t total = size;
  char *motif;

  if (match_icase)
    syntax_bits |= RE_ICASE;
  re_set_syntax (syntax_bits);
  dfasyntax (syntax_bits, match_icase, eolbyte);

  /* For GNU regex compiler we have to pass the patterns separately to detect
     errors like "[\nallo\n]\n".  The patterns here are "[", "allo" and "]"
     GNU regex should have raise a syntax error.  The same for backref, where
     the backref should have been local to each pattern.  */
  p = pattern;
  do
    {
      size_t len;
      sep = memchr (p, '\n', total);
      if (sep)
	{
	  len = sep - p;
	  sep++;
	  total -= (len + 1);
	}
      else
	{
	  len = total;
	  total = 0;
	}

      patterns = realloc (patterns, (pcount + 1) * sizeof (*patterns));
      if (patterns == NULL)
	error (EXIT_TROUBLE, errno, _("memory exhausted"));
      patterns[pcount] = patterns0;

      if ((err = re_compile_pattern (p, len,
				    &(patterns[pcount].regexbuf))) != NULL)
	error (EXIT_TROUBLE, 0, "%s", err);
      pcount++;

      p = sep;
    } while (sep && total != 0);

  /* In the match_words and match_lines cases, we use a different pattern
     for the DFA matcher that will quickly throw out cases that won't work.
     Then if DFA succeeds we do some hairy stuff using the regex matcher
     to decide whether the match should really count. */
  if (match_words || match_lines)
    {
      static char const line_beg_no_bk[] = "^(";
      static char const line_end_no_bk[] = ")$";
      static char const word_beg_no_bk[] = "(^|[^[:alnum:]_])(";
      static char const word_end_no_bk[] = ")([^[:alnum:]_]|$)";
      static char const line_beg_bk[] = "^\\(";
      static char const line_end_bk[] = "\\)$";
      static char const word_beg_bk[] = "\\(^\\|[^[:alnum:]_]\\)\\(";
      static char const word_end_bk[] = "\\)\\([^[:alnum:]_]\\|$\\)";
      int bk = !(syntax_bits & RE_NO_BK_PARENS);
      char *n = xmalloc (sizeof word_beg_bk - 1 + size + sizeof word_end_bk);

      strcpy (n, match_lines ? (bk ? line_beg_bk : line_beg_no_bk)
			     : (bk ? word_beg_bk : word_beg_no_bk));
      total = strlen(n);
      memcpy (n + total, pattern, size);
      total += size;
      strcpy (n + total, match_lines ? (bk ? line_end_bk : line_end_no_bk)
				     : (bk ? word_end_bk : word_end_no_bk));
      total += strlen (n + total);
      pattern = motif = n;
      size = total;
    }
  else
    motif = NULL;

  dfacomp (pattern, size, &dfa, 1);
  kwsmusts ();

  free(motif);
}

size_t
EGexecute (char const *buf, size_t size, size_t *match_size,
	   char const *start_ptr)
{
  char const *buflim, *beg, *end, *match, *best_match, *mb_start;
  char eol = eolbyte;
  int backref, start, len, best_len;
  struct kwsmatch kwsm;
  size_t i, ret_val;
#ifdef MBS_SUPPORT
  if (MB_CUR_MAX > 1)
    {
      if (match_icase)
        {
          /* mbtolower adds a NUL byte at the end.  That will provide
	     space for the sentinel byte dfaexec may add.  */
          char *case_buf = mbtolower (buf, &size);
	  if (start_ptr)
	    start_ptr = case_buf + (start_ptr - buf);
          buf = case_buf;
        }
    }
#endif /* MBS_SUPPORT */

  mb_start = buf;
  buflim = buf + size;

  for (beg = end = buf; end < buflim; beg = end)
    {
      if (!start_ptr)
	{
	  /* We don't care about an exact match.  */
	  if (kwset)
	    {
	      /* Find a possible match using the KWset matcher. */
	      size_t offset = kwsexec (kwset, beg, buflim - beg, &kwsm);
	      if (offset == (size_t) -1)
		goto failure;
	      beg += offset;
	      /* Narrow down to the line containing the candidate, and
		 run it through DFA. */
	      if ((end = memchr(beg, eol, buflim - beg)) != NULL)
	        end++;
              else
                end = buflim;
	      match = beg;
	      while (beg > buf && beg[-1] != eol)
		--beg;
	      if (kwsm.index < kwset_exact_matches)
                {
#ifdef MBS_SUPPORT
                  if (mb_start < beg)
                    mb_start = beg;
                  if (MB_CUR_MAX == 1 || !is_mb_middle (&mb_start, match, buflim))
#endif
                    goto success;
                }
	      if (dfaexec (&dfa, beg, (char *) end, 0, NULL, &backref) == NULL)
		continue;
	    }
	  else
	    {
	      /* No good fixed strings; start with DFA. */
	      char const *next_beg = dfaexec (&dfa, beg, (char *) buflim,
					      0, NULL, &backref);
	      if (next_beg == NULL)
		break;
	      /* Narrow down to the line we've found. */
	      beg = next_beg;
	      if ((end = memchr(beg, eol, buflim - beg)) != NULL)
	        end++;
              else
                end = buflim;
	      while (beg > buf && beg[-1] != eol)
		--beg;
	    }
	  /* Successful, no backreferences encountered! */
	  if (!backref)
	    goto success;
	}
      else
	{
	  /* We are looking for the leftmost (then longest) exact match.
	     We will go through the outer loop only once.  */
	  beg = start_ptr;
	  end = buflim;
	}

      /* If we've made it to this point, this means DFA has seen
	 a probable match, and we need to run it through Regex. */
      best_match = end;
      best_len = 0;
      for (i = 0; i < pcount; i++)
	{
	  patterns[i].regexbuf.not_eol = 0;
	  if (0 <= (start = re_search (&(patterns[i].regexbuf),
				       buf, end - buf - 1,
				       beg - buf, end - beg - 1,
				       &(patterns[i].regs))))
	    {
	      len = patterns[i].regs.end[0] - start;
	      match = buf + start;
	      if (match > best_match)
		continue;
	      if (start_ptr && !match_words)
		goto assess_pattern_match;
	      if ((!match_lines && !match_words)
		  || (match_lines && len == end - beg - 1))
		{
		  match = beg;
		  len = end - beg;
		  goto assess_pattern_match;
		}
	      /* If -w, check if the match aligns with word boundaries.
		 We do this iteratively because:
		 (a) the line may contain more than one occurence of the
		 pattern, and
		 (b) Several alternatives in the pattern might be valid at a
		 given point, and we may need to consider a shorter one to
		 find a word boundary.  */
	      if (match_words)
		while (match <= best_match)
		  {
		    if ((match == buf || !WCHAR ((unsigned char) match[-1]))
			&& (len == end - beg - 1
			    || !WCHAR ((unsigned char) match[len])))
		      goto assess_pattern_match;
		    if (len > 0)
		      {
			/* Try a shorter length anchored at the same place. */
			--len;
			patterns[i].regexbuf.not_eol = 1;
			len = re_match (&(patterns[i].regexbuf),
					buf, match + len - beg, match - buf,
					&(patterns[i].regs));
		      }
		    if (len <= 0)
		      {
			/* Try looking further on. */
			if (match == end - 1)
			  break;
			match++;
			patterns[i].regexbuf.not_eol = 0;
			start = re_search (&(patterns[i].regexbuf),
					   buf, end - buf - 1,
					   match - buf, end - match - 1,
					   &(patterns[i].regs));
			if (start < 0)
			  break;
			len = patterns[i].regs.end[0] - start;
			match = buf + start;
		      }
		  } /* while (match <= best_match) */
	      continue;
	    assess_pattern_match:
	      if (!start_ptr)
		{
		  /* Good enough for a non-exact match.
		     No need to look at further patterns, if any.  */
		  
//Patch 0:
if ((__is_neg(25, &(beg), sizeof (beg), &(match), sizeof (match), &(best_match), sizeof (best_match), &(len), sizeof (len), &(best_len), sizeof (best_len), &(start_ptr), sizeof (start_ptr), &(buf), sizeof (buf), &(start), sizeof (start), &(i), sizeof (i), &(patterns), sizeof (patterns), &(end), sizeof (end), &(ret_val), sizeof (ret_val), &(match_size), sizeof (match_size), &(match_words), sizeof (match_words), &(match_lines), sizeof (match_lines), &(pcount), sizeof (pcount), &(buflim), sizeof (buflim), &(backref), sizeof (backref), &(eol), sizeof (eol), &(mb_start), sizeof (mb_start), &(kwset_exact_matches), sizeof (kwset_exact_matches), &(kwset), sizeof (kwset), &(size), sizeof (size), &(match_icase), sizeof (match_icase), &(eolbyte), sizeof (eolbyte))))
    return 0;
beg = match;

//CodeSeg 1:
		  goto success_in_len;
		}
	      if (match < best_match || (match == best_match && len > best_len))
		{
		  /* Best exact match:  leftmost, then longest.  */
		  best_match = match;
		  best_len = len;
		}
	    } /* if re_search >= 0 */
	} /* for Regex patterns.  */
	if (best_match < end)
	  {
	    /* We have found an exact match.  We were just
	       waiting for the best one (leftmost then longest).  */
	    beg = best_match;
	    len = best_len;
	    goto success_in_len;
	  }
    } /* for (beg = end ..) */

 failure:
  ret_val = -1;
  goto out;

 success:
  len = end - beg;
 success_in_len:
  *match_size = len;
  ret_val = beg - buf;
 out:
  return ret_val;
}

Testing negative cases!
Testing 0 (with abstract condition) ENVIS_NEG
Iteration 0
Running test command:
/home/ubuntu/spr-fast/tools/grep-test.py /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-8a025cf8-8f08d8e2/tempworkdir-l/src /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-8a025cf8-8f08d8e2/tempworkdir-l/tests /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-8a025cf8-8f08d8e2/tempworkdir-l 0  > __res
Opening:/tmp/neg.tmp!
NegativeBRANCH RECORD/tmp/neg.tmp!
APPENDING TO ISNEG:/tmp/neg.tmp!
Branch 0: 0
Iteration 1
Running test command:
/home/ubuntu/spr-fast/tools/grep-test.py /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-8a025cf8-8f08d8e2/tempworkdir-l/src /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-8a025cf8-8f08d8e2/tempworkdir-l/tests /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-8a025cf8-8f08d8e2/tempworkdir-l 0  > __res
Opening:/tmp/neg.tmp!
NegativeBRANCH RECORD/tmp/neg.tmp!
APPENDING TO ISNEG:/tmp/neg.tmp!
Branch 0: 1
Running test command:
/home/ubuntu/spr-fast/tools/grep-test.py /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-8a025cf8-8f08d8e2/tempworkdir-l/src /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-8a025cf8-8f08d8e2/tempworkdir-l/tests /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-8a025cf8-8f08d8e2/tempworkdir-l 0  > __res
CondTester, Testing instance id 69:
//src_file:src/dfasearch.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); void* memset(void*, int, unsigned long); 
/* dfasearch.c - searching subroutines using dfa and regex for grep.
   Copyright 1992, 1998, 2000, 2007, 2009-2010 Free Software Foundation, Inc.

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 3, or (at your option)
   any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program; if not, write to the Free Software
   Foundation, Inc., 51 Franklin Street - Fifth Floor, Boston, MA
   02110-1301, USA.  */

/* Written August 1992 by Mike Haertel. */

#include <config.h>
#include "search.h"
#include "dfa.h"

/* For -w, we also consider _ to be word constituent.  */
#define WCHAR(C) (ISALNUM(C) || (C) == '_')

/* KWset compiled pattern.  For Ecompile and Gcompile, we compile
   a list of strings, at least one of which is known to occur in
   any string matching the regexp. */
static kwset_t kwset;

/* DFA compiled regexp. */
static struct dfa dfa;

/* The Regex compiled patterns.  */
static struct patterns
{
  /* Regex compiled regexp. */
  struct re_pattern_buffer regexbuf;
  struct re_registers regs; /* This is here on account of a BRAIN-DEAD
			       Q@#%!# library interface in regex.c.  */
} patterns0;

struct patterns *patterns;
size_t pcount;

void
dfaerror (char const *mesg)
{
  error (EXIT_TROUBLE, 0, "%s", mesg);

  /* notreached */
  /* Tell static analyzers that this function does not return.  */
  abort ();
}

/* Number of compiled fixed strings known to exactly match the regexp.
   If kwsexec returns < kwset_exact_matches, then we don't need to
   call the regexp matcher at all. */
static int kwset_exact_matches;

static char const *
kwsincr_case (const char *must)
{
  const char *buf;
  size_t n;

  n = strlen (must);
#ifdef MBS_SUPPORT
  if (match_icase && MB_CUR_MAX > 1)
    buf = mbtolower (must, &n);
  else
#endif
    buf = must;
  return kwsincr (kwset, buf, n);
}

/* If the DFA turns out to have some set of fixed strings one of
   which must occur in the match, then we build a kwset matcher
   to find those strings, and thus quickly filter out impossible
   matches. */
static void
kwsmusts (void)
{
  struct dfamust const *dm;
  char const *err;

  if (dfa.musts)
    {
      kwsinit (&kwset);
      /* First, we compile in the substrings known to be exact
	 matches.  The kwset matcher will return the index
	 of the matching string that it chooses. */
      for (dm = dfa.musts; dm; dm = dm->next)
	{
	  if (!dm->exact)
	    continue;
	  ++kwset_exact_matches;
	  if ((err = kwsincr_case (dm->must)) != NULL)
	    error (EXIT_TROUBLE, 0, "%s", err);
	}
      /* Now, we compile the substrings that will require
	 the use of the regexp matcher.  */
      for (dm = dfa.musts; dm; dm = dm->next)
	{
	  if (dm->exact)
	    continue;
	  if ((err = kwsincr_case (dm->must)) != NULL)
	    error (EXIT_TROUBLE, 0, "%s", err);
	}
      if ((err = kwsprep (kwset)) != NULL)
	error (EXIT_TROUBLE, 0, "%s", err);
    }
}

void
GEAcompile (char const *pattern, size_t size, reg_syntax_t syntax_bits)
{
  const char *err;
  const char *p, *sep;
  size_t total = size;
  char *motif;

  if (match_icase)
    syntax_bits |= RE_ICASE;
  re_set_syntax (syntax_bits);
  dfasyntax (syntax_bits, match_icase, eolbyte);

  /* For GNU regex compiler we have to pass the patterns separately to detect
     errors like "[\nallo\n]\n".  The patterns here are "[", "allo" and "]"
     GNU regex should have raise a syntax error.  The same for backref, where
     the backref should have been local to each pattern.  */
  p = pattern;
  do
    {
      size_t len;
      sep = memchr (p, '\n', total);
      if (sep)
	{
	  len = sep - p;
	  sep++;
	  total -= (len + 1);
	}
      else
	{
	  len = total;
	  total = 0;
	}

      patterns = realloc (patterns, (pcount + 1) * sizeof (*patterns));
      if (patterns == NULL)
	error (EXIT_TROUBLE, errno, _("memory exhausted"));
      patterns[pcount] = patterns0;

      if ((err = re_compile_pattern (p, len,
				    &(patterns[pcount].regexbuf))) != NULL)
	error (EXIT_TROUBLE, 0, "%s", err);
      pcount++;

      p = sep;
    } while (sep && total != 0);

  /* In the match_words and match_lines cases, we use a different pattern
     for the DFA matcher that will quickly throw out cases that won't work.
     Then if DFA succeeds we do some hairy stuff using the regex matcher
     to decide whether the match should really count. */
  if (match_words || match_lines)
    {
      static char const line_beg_no_bk[] = "^(";
      static char const line_end_no_bk[] = ")$";
      static char const word_beg_no_bk[] = "(^|[^[:alnum:]_])(";
      static char const word_end_no_bk[] = ")([^[:alnum:]_]|$)";
      static char const line_beg_bk[] = "^\\(";
      static char const line_end_bk[] = "\\)$";
      static char const word_beg_bk[] = "\\(^\\|[^[:alnum:]_]\\)\\(";
      static char const word_end_bk[] = "\\)\\([^[:alnum:]_]\\|$\\)";
      int bk = !(syntax_bits & RE_NO_BK_PARENS);
      char *n = xmalloc (sizeof word_beg_bk - 1 + size + sizeof word_end_bk);

      strcpy (n, match_lines ? (bk ? line_beg_bk : line_beg_no_bk)
			     : (bk ? word_beg_bk : word_beg_no_bk));
      total = strlen(n);
      memcpy (n + total, pattern, size);
      total += size;
      strcpy (n + total, match_lines ? (bk ? line_end_bk : line_end_no_bk)
				     : (bk ? word_end_bk : word_end_no_bk));
      total += strlen (n + total);
      pattern = motif = n;
      size = total;
    }
  else
    motif = NULL;

  dfacomp (pattern, size, &dfa, 1);
  kwsmusts ();

  free(motif);
}

size_t
EGexecute (char const *buf, size_t size, size_t *match_size,
	   char const *start_ptr)
{
  char const *buflim, *beg, *end, *match, *best_match, *mb_start;
  char eol = eolbyte;
  int backref, start, len, best_len;
  struct kwsmatch kwsm;
  size_t i, ret_val;
#ifdef MBS_SUPPORT
  if (MB_CUR_MAX > 1)
    {
      if (match_icase)
        {
          /* mbtolower adds a NUL byte at the end.  That will provide
	     space for the sentinel byte dfaexec may add.  */
          char *case_buf = mbtolower (buf, &size);
	  if (start_ptr)
	    start_ptr = case_buf + (start_ptr - buf);
          buf = case_buf;
        }
    }
#endif /* MBS_SUPPORT */

  mb_start = buf;
  buflim = buf + size;

  for (beg = end = buf; end < buflim; beg = end)
    {
      if (!start_ptr)
	{
	  /* We don't care about an exact match.  */
	  if (kwset)
	    {
	      /* Find a possible match using the KWset matcher. */
	      size_t offset = kwsexec (kwset, beg, buflim - beg, &kwsm);
	      if (offset == (size_t) -1)
		goto failure;
	      beg += offset;
	      /* Narrow down to the line containing the candidate, and
		 run it through DFA. */
	      if ((end = memchr(beg, eol, buflim - beg)) != NULL)
	        end++;
              else
                end = buflim;
	      match = beg;
	      while (beg > buf && beg[-1] != eol)
		--beg;
	      if (kwsm.index < kwset_exact_matches)
                {
#ifdef MBS_SUPPORT
                  if (mb_start < beg)
                    mb_start = beg;
                  if (MB_CUR_MAX == 1 || !is_mb_middle (&mb_start, match, buflim))
#endif
                    goto success;
                }
	      if (dfaexec (&dfa, beg, (char *) end, 0, NULL, &backref) == NULL)
		continue;
	    }
	  else
	    {
	      /* No good fixed strings; start with DFA. */
	      char const *next_beg = dfaexec (&dfa, beg, (char *) buflim,
					      0, NULL, &backref);
	      if (next_beg == NULL)
		break;
	      /* Narrow down to the line we've found. */
	      beg = next_beg;
	      if ((end = memchr(beg, eol, buflim - beg)) != NULL)
	        end++;
              else
                end = buflim;
	      while (beg > buf && beg[-1] != eol)
		--beg;
	    }
	  /* Successful, no backreferences encountered! */
	  if (!backref)
	    goto success;
	}
      else
	{
	  /* We are looking for the leftmost (then longest) exact match.
	     We will go through the outer loop only once.  */
	  beg = start_ptr;
	  end = buflim;
	}

      /* If we've made it to this point, this means DFA has seen
	 a probable match, and we need to run it through Regex. */
      best_match = end;
      best_len = 0;
      for (i = 0; i < pcount; i++)
	{
	  patterns[i].regexbuf.not_eol = 0;
	  if (0 <= (start = re_search (&(patterns[i].regexbuf),
				       buf, end - buf - 1,
				       beg - buf, end - beg - 1,
				       &(patterns[i].regs))))
	    {
	      len = patterns[i].regs.end[0] - start;
	      match = buf + start;
	      if (match > best_match)
		continue;
	      if (start_ptr && !match_words)
		goto assess_pattern_match;
	      if ((!match_lines && !match_words)
		  || (match_lines && len == end - beg - 1))
		{
		  match = beg;
		  len = end - beg;
		  goto assess_pattern_match;
		}
	      /* If -w, check if the match aligns with word boundaries.
		 We do this iteratively because:
		 (a) the line may contain more than one occurence of the
		 pattern, and
		 (b) Several alternatives in the pattern might be valid at a
		 given point, and we may need to consider a shorter one to
		 find a word boundary.  */
	      if (match_words)
		while (match <= best_match)
		  {
		    if ((match == buf || !WCHAR ((unsigned char) match[-1]))
			&& (len == end - beg - 1
			    || !WCHAR ((unsigned char) match[len])))
		      goto assess_pattern_match;
		    if (len > 0)
		      {
			/* Try a shorter length anchored at the same place. */
			--len;
			patterns[i].regexbuf.not_eol = 1;
			len = re_match (&(patterns[i].regexbuf),
					buf, match + len - beg, match - buf,
					&(patterns[i].regs));
		      }
		    if (len <= 0)
		      {
			/* Try looking further on. */
			if (match == end - 1)
			  break;
			match++;
			patterns[i].regexbuf.not_eol = 0;
			start = re_search (&(patterns[i].regexbuf),
					   buf, end - buf - 1,
					   match - buf, end - match - 1,
					   &(patterns[i].regs));
			if (start < 0)
			  break;
			len = patterns[i].regs.end[0] - start;
			match = buf + start;
		      }
		  } /* while (match <= best_match) */
	      continue;
	    assess_pattern_match:
	      if (!start_ptr)
		{
		  /* Good enough for a non-exact match.
		     No need to look at further patterns, if any.  */
		  
//Patch 0:
if ((__is_neg(25, &(beg), sizeof (beg), &(match), sizeof (match), &(best_match), sizeof (best_match), &(len), sizeof (len), &(best_len), sizeof (best_len), &(start_ptr), sizeof (start_ptr), &(buf), sizeof (buf), &(start), sizeof (start), &(i), sizeof (i), &(patterns), sizeof (patterns), &(end), sizeof (end), &(ret_val), sizeof (ret_val), &(match_size), sizeof (match_size), &(match_words), sizeof (match_words), &(match_lines), sizeof (match_lines), &(pcount), sizeof (pcount), &(buflim), sizeof (buflim), &(backref), sizeof (backref), &(eol), sizeof (eol), &(mb_start), sizeof (mb_start), &(kwset_exact_matches), sizeof (kwset_exact_matches), &(kwset), sizeof (kwset), &(size), sizeof (size), &(match_icase), sizeof (match_icase), &(eolbyte), sizeof (eolbyte))))
    return 1;
beg = match;

//CodeSeg 1:
		  goto success_in_len;
		}
	      if (match < best_match || (match == best_match && len > best_len))
		{
		  /* Best exact match:  leftmost, then longest.  */
		  best_match = match;
		  best_len = len;
		}
	    } /* if re_search >= 0 */
	} /* for Regex patterns.  */
	if (best_match < end)
	  {
	    /* We have found an exact match.  We were just
	       waiting for the best one (leftmost then longest).  */
	    beg = best_match;
	    len = best_len;
	    goto success_in_len;
	  }
    } /* for (beg = end ..) */

 failure:
  ret_val = -1;
  goto out;

 success:
  len = end - beg;
 success_in_len:
  *match_size = len;
  ret_val = beg - buf;
 out:
  return ret_val;
}

Testing negative cases!
Testing 0 (with abstract condition) ENVIS_NEG
Iteration 0
Running test command:
/home/ubuntu/spr-fast/tools/grep-test.py /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-8a025cf8-8f08d8e2/tempworkdir-l/src /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-8a025cf8-8f08d8e2/tempworkdir-l/tests /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-8a025cf8-8f08d8e2/tempworkdir-l 0  > __res
Opening:/tmp/neg.tmp!
NegativeBRANCH RECORD/tmp/neg.tmp!
APPENDING TO ISNEG:/tmp/neg.tmp!
Branch 0: 0
Iteration 1
Running test command:
/home/ubuntu/spr-fast/tools/grep-test.py /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-8a025cf8-8f08d8e2/tempworkdir-l/src /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-8a025cf8-8f08d8e2/tempworkdir-l/tests /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-8a025cf8-8f08d8e2/tempworkdir-l 0  > __res
Opening:/tmp/neg.tmp!
NegativeBRANCH RECORD/tmp/neg.tmp!
APPENDING TO ISNEG:/tmp/neg.tmp!
Branch 0: 1
Running test command:
/home/ubuntu/spr-fast/tools/grep-test.py /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-8a025cf8-8f08d8e2/tempworkdir-l/src /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-8a025cf8-8f08d8e2/tempworkdir-l/tests /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-8a025cf8-8f08d8e2/tempworkdir-l 0  > __res
CondTester, Testing instance id 70:
//src_file:src/dfasearch.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); void* memset(void*, int, unsigned long); 
/* dfasearch.c - searching subroutines using dfa and regex for grep.
   Copyright 1992, 1998, 2000, 2007, 2009-2010 Free Software Foundation, Inc.

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 3, or (at your option)
   any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program; if not, write to the Free Software
   Foundation, Inc., 51 Franklin Street - Fifth Floor, Boston, MA
   02110-1301, USA.  */

/* Written August 1992 by Mike Haertel. */

#include <config.h>
#include "search.h"
#include "dfa.h"

/* For -w, we also consider _ to be word constituent.  */
#define WCHAR(C) (ISALNUM(C) || (C) == '_')

/* KWset compiled pattern.  For Ecompile and Gcompile, we compile
   a list of strings, at least one of which is known to occur in
   any string matching the regexp. */
static kwset_t kwset;

/* DFA compiled regexp. */
static struct dfa dfa;

/* The Regex compiled patterns.  */
static struct patterns
{
  /* Regex compiled regexp. */
  struct re_pattern_buffer regexbuf;
  struct re_registers regs; /* This is here on account of a BRAIN-DEAD
			       Q@#%!# library interface in regex.c.  */
} patterns0;

struct patterns *patterns;
size_t pcount;

void
dfaerror (char const *mesg)
{
  error (EXIT_TROUBLE, 0, "%s", mesg);

  /* notreached */
  /* Tell static analyzers that this function does not return.  */
  abort ();
}

/* Number of compiled fixed strings known to exactly match the regexp.
   If kwsexec returns < kwset_exact_matches, then we don't need to
   call the regexp matcher at all. */
static int kwset_exact_matches;

static char const *
kwsincr_case (const char *must)
{
  const char *buf;
  size_t n;

  n = strlen (must);
#ifdef MBS_SUPPORT
  if (match_icase && MB_CUR_MAX > 1)
    buf = mbtolower (must, &n);
  else
#endif
    buf = must;
  return kwsincr (kwset, buf, n);
}

/* If the DFA turns out to have some set of fixed strings one of
   which must occur in the match, then we build a kwset matcher
   to find those strings, and thus quickly filter out impossible
   matches. */
static void
kwsmusts (void)
{
  struct dfamust const *dm;
  char const *err;

  if (dfa.musts)
    {
      kwsinit (&kwset);
      /* First, we compile in the substrings known to be exact
	 matches.  The kwset matcher will return the index
	 of the matching string that it chooses. */
      for (dm = dfa.musts; dm; dm = dm->next)
	{
	  if (!dm->exact)
	    continue;
	  ++kwset_exact_matches;
	  if ((err = kwsincr_case (dm->must)) != NULL)
	    error (EXIT_TROUBLE, 0, "%s", err);
	}
      /* Now, we compile the substrings that will require
	 the use of the regexp matcher.  */
      for (dm = dfa.musts; dm; dm = dm->next)
	{
	  if (dm->exact)
	    continue;
	  if ((err = kwsincr_case (dm->must)) != NULL)
	    error (EXIT_TROUBLE, 0, "%s", err);
	}
      if ((err = kwsprep (kwset)) != NULL)
	error (EXIT_TROUBLE, 0, "%s", err);
    }
}

void
GEAcompile (char const *pattern, size_t size, reg_syntax_t syntax_bits)
{
  const char *err;
  const char *p, *sep;
  size_t total = size;
  char *motif;

  if (match_icase)
    syntax_bits |= RE_ICASE;
  re_set_syntax (syntax_bits);
  dfasyntax (syntax_bits, match_icase, eolbyte);

  /* For GNU regex compiler we have to pass the patterns separately to detect
     errors like "[\nallo\n]\n".  The patterns here are "[", "allo" and "]"
     GNU regex should have raise a syntax error.  The same for backref, where
     the backref should have been local to each pattern.  */
  p = pattern;
  do
    {
      size_t len;
      sep = memchr (p, '\n', total);
      if (sep)
	{
	  len = sep - p;
	  sep++;
	  total -= (len + 1);
	}
      else
	{
	  len = total;
	  total = 0;
	}

      patterns = realloc (patterns, (pcount + 1) * sizeof (*patterns));
      if (patterns == NULL)
	error (EXIT_TROUBLE, errno, _("memory exhausted"));
      patterns[pcount] = patterns0;

      if ((err = re_compile_pattern (p, len,
				    &(patterns[pcount].regexbuf))) != NULL)
	error (EXIT_TROUBLE, 0, "%s", err);
      pcount++;

      p = sep;
    } while (sep && total != 0);

  /* In the match_words and match_lines cases, we use a different pattern
     for the DFA matcher that will quickly throw out cases that won't work.
     Then if DFA succeeds we do some hairy stuff using the regex matcher
     to decide whether the match should really count. */
  if (match_words || match_lines)
    {
      static char const line_beg_no_bk[] = "^(";
      static char const line_end_no_bk[] = ")$";
      static char const word_beg_no_bk[] = "(^|[^[:alnum:]_])(";
      static char const word_end_no_bk[] = ")([^[:alnum:]_]|$)";
      static char const line_beg_bk[] = "^\\(";
      static char const line_end_bk[] = "\\)$";
      static char const word_beg_bk[] = "\\(^\\|[^[:alnum:]_]\\)\\(";
      static char const word_end_bk[] = "\\)\\([^[:alnum:]_]\\|$\\)";
      int bk = !(syntax_bits & RE_NO_BK_PARENS);
      char *n = xmalloc (sizeof word_beg_bk - 1 + size + sizeof word_end_bk);

      strcpy (n, match_lines ? (bk ? line_beg_bk : line_beg_no_bk)
			     : (bk ? word_beg_bk : word_beg_no_bk));
      total = strlen(n);
      memcpy (n + total, pattern, size);
      total += size;
      strcpy (n + total, match_lines ? (bk ? line_end_bk : line_end_no_bk)
				     : (bk ? word_end_bk : word_end_no_bk));
      total += strlen (n + total);
      pattern = motif = n;
      size = total;
    }
  else
    motif = NULL;

  dfacomp (pattern, size, &dfa, 1);
  kwsmusts ();

  free(motif);
}

size_t
EGexecute (char const *buf, size_t size, size_t *match_size,
	   char const *start_ptr)
{
  char const *buflim, *beg, *end, *match, *best_match, *mb_start;
  char eol = eolbyte;
  int backref, start, len, best_len;
  struct kwsmatch kwsm;
  size_t i, ret_val;
#ifdef MBS_SUPPORT
  if (MB_CUR_MAX > 1)
    {
      if (match_icase)
        {
          /* mbtolower adds a NUL byte at the end.  That will provide
	     space for the sentinel byte dfaexec may add.  */
          char *case_buf = mbtolower (buf, &size);
	  if (start_ptr)
	    start_ptr = case_buf + (start_ptr - buf);
          buf = case_buf;
        }
    }
#endif /* MBS_SUPPORT */

  mb_start = buf;
  buflim = buf + size;

  for (beg = end = buf; end < buflim; beg = end)
    {
      if (!start_ptr)
	{
	  /* We don't care about an exact match.  */
	  if (kwset)
	    {
	      /* Find a possible match using the KWset matcher. */
	      size_t offset = kwsexec (kwset, beg, buflim - beg, &kwsm);
	      if (offset == (size_t) -1)
		goto failure;
	      beg += offset;
	      /* Narrow down to the line containing the candidate, and
		 run it through DFA. */
	      if ((end = memchr(beg, eol, buflim - beg)) != NULL)
	        end++;
              else
                end = buflim;
	      match = beg;
	      while (beg > buf && beg[-1] != eol)
		--beg;
	      if (kwsm.index < kwset_exact_matches)
                {
#ifdef MBS_SUPPORT
                  if (mb_start < beg)
                    mb_start = beg;
                  if (MB_CUR_MAX == 1 || !is_mb_middle (&mb_start, match, buflim))
#endif
                    goto success;
                }
	      if (dfaexec (&dfa, beg, (char *) end, 0, NULL, &backref) == NULL)
		continue;
	    }
	  else
	    {
	      /* No good fixed strings; start with DFA. */
	      char const *next_beg = dfaexec (&dfa, beg, (char *) buflim,
					      0, NULL, &backref);
	      if (next_beg == NULL)
		break;
	      /* Narrow down to the line we've found. */
	      beg = next_beg;
	      if ((end = memchr(beg, eol, buflim - beg)) != NULL)
	        end++;
              else
                end = buflim;
	      while (beg > buf && beg[-1] != eol)
		--beg;
	    }
	  /* Successful, no backreferences encountered! */
	  if (!backref)
	    goto success;
	}
      else
	{
	  /* We are looking for the leftmost (then longest) exact match.
	     We will go through the outer loop only once.  */
	  beg = start_ptr;
	  end = buflim;
	}

      /* If we've made it to this point, this means DFA has seen
	 a probable match, and we need to run it through Regex. */
      best_match = end;
      best_len = 0;
      for (i = 0; i < pcount; i++)
	{
	  patterns[i].regexbuf.not_eol = 0;
	  if (0 <= (start = re_search (&(patterns[i].regexbuf),
				       buf, end - buf - 1,
				       beg - buf, end - beg - 1,
				       &(patterns[i].regs))))
	    {
	      len = patterns[i].regs.end[0] - start;
	      match = buf + start;
	      if (match > best_match)
		continue;
	      if (start_ptr && !match_words)
		goto assess_pattern_match;
	      if ((!match_lines && !match_words)
		  || (match_lines && len == end - beg - 1))
		{
		  match = beg;
		  len = end - beg;
		  goto assess_pattern_match;
		}
	      /* If -w, check if the match aligns with word boundaries.
		 We do this iteratively because:
		 (a) the line may contain more than one occurence of the
		 pattern, and
		 (b) Several alternatives in the pattern might be valid at a
		 given point, and we may need to consider a shorter one to
		 find a word boundary.  */
	      if (match_words)
		while (match <= best_match)
		  {
		    if ((match == buf || !WCHAR ((unsigned char) match[-1]))
			&& (len == end - beg - 1
			    || !WCHAR ((unsigned char) match[len])))
		      goto assess_pattern_match;
		    if (len > 0)
		      {
			/* Try a shorter length anchored at the same place. */
			--len;
			patterns[i].regexbuf.not_eol = 1;
			len = re_match (&(patterns[i].regexbuf),
					buf, match + len - beg, match - buf,
					&(patterns[i].regs));
		      }
		    if (len <= 0)
		      {
			/* Try looking further on. */
			if (match == end - 1)
			  break;
			match++;
			patterns[i].regexbuf.not_eol = 0;
			start = re_search (&(patterns[i].regexbuf),
					   buf, end - buf - 1,
					   match - buf, end - match - 1,
					   &(patterns[i].regs));
			if (start < 0)
			  break;
			len = patterns[i].regs.end[0] - start;
			match = buf + start;
		      }
		  } /* while (match <= best_match) */
	      continue;
	    assess_pattern_match:
	      if (!start_ptr)
		{
		  /* Good enough for a non-exact match.
		     No need to look at further patterns, if any.  */
		  
//Patch 0:
if ((__is_neg(25, &(beg), sizeof (beg), &(match), sizeof (match), &(best_match), sizeof (best_match), &(len), sizeof (len), &(best_len), sizeof (best_len), &(start_ptr), sizeof (start_ptr), &(buf), sizeof (buf), &(start), sizeof (start), &(i), sizeof (i), &(patterns), sizeof (patterns), &(end), sizeof (end), &(ret_val), sizeof (ret_val), &(match_size), sizeof (match_size), &(match_words), sizeof (match_words), &(match_lines), sizeof (match_lines), &(pcount), sizeof (pcount), &(buflim), sizeof (buflim), &(backref), sizeof (backref), &(eol), sizeof (eol), &(mb_start), sizeof (mb_start), &(kwset_exact_matches), sizeof (kwset_exact_matches), &(kwset), sizeof (kwset), &(size), sizeof (size), &(match_icase), sizeof (match_icase), &(eolbyte), sizeof (eolbyte))))
    break;
beg = match;

//CodeSeg 1:
		  goto success_in_len;
		}
	      if (match < best_match || (match == best_match && len > best_len))
		{
		  /* Best exact match:  leftmost, then longest.  */
		  best_match = match;
		  best_len = len;
		}
	    } /* if re_search >= 0 */
	} /* for Regex patterns.  */
	if (best_match < end)
	  {
	    /* We have found an exact match.  We were just
	       waiting for the best one (leftmost then longest).  */
	    beg = best_match;
	    len = best_len;
	    goto success_in_len;
	  }
    } /* for (beg = end ..) */

 failure:
  ret_val = -1;
  goto out;

 success:
  len = end - beg;
 success_in_len:
  *match_size = len;
  ret_val = beg - buf;
 out:
  return ret_val;
}

Testing negative cases!
Testing 0 (with abstract condition) ENVIS_NEG
Iteration 0
Running test command:
/home/ubuntu/spr-fast/tools/grep-test.py /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-8a025cf8-8f08d8e2/tempworkdir-l/src /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-8a025cf8-8f08d8e2/tempworkdir-l/tests /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-8a025cf8-8f08d8e2/tempworkdir-l 0  > __res
Opening:/tmp/neg.tmp!
NegativeBRANCH RECORD/tmp/neg.tmp!
APPENDING TO ISNEG:/tmp/neg.tmp!
Branch 0: 0
Iteration 1
Running test command:
/home/ubuntu/spr-fast/tools/grep-test.py /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-8a025cf8-8f08d8e2/tempworkdir-l/src /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-8a025cf8-8f08d8e2/tempworkdir-l/tests /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-8a025cf8-8f08d8e2/tempworkdir-l 0  > __res
Opening:/tmp/neg.tmp!
NegativeBRANCH RECORD/tmp/neg.tmp!
APPENDING TO ISNEG:/tmp/neg.tmp!
Branch 0: 1
Running test command:
/home/ubuntu/spr-fast/tools/grep-test.py /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-8a025cf8-8f08d8e2/tempworkdir-l/src /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-8a025cf8-8f08d8e2/tempworkdir-l/tests /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-8a025cf8-8f08d8e2/tempworkdir-l 0  > __res
CondTester, Postprocessing instance id 59:
//src_file:src/dfasearch.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); void* memset(void*, int, unsigned long); 
/* dfasearch.c - searching subroutines using dfa and regex for grep.
   Copyright 1992, 1998, 2000, 2007, 2009-2010 Free Software Foundation, Inc.

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 3, or (at your option)
   any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program; if not, write to the Free Software
   Foundation, Inc., 51 Franklin Street - Fifth Floor, Boston, MA
   02110-1301, USA.  */

/* Written August 1992 by Mike Haertel. */

#include <config.h>
#include "search.h"
#include "dfa.h"

/* For -w, we also consider _ to be word constituent.  */
#define WCHAR(C) (ISALNUM(C) || (C) == '_')

/* KWset compiled pattern.  For Ecompile and Gcompile, we compile
   a list of strings, at least one of which is known to occur in
   any string matching the regexp. */
static kwset_t kwset;

/* DFA compiled regexp. */
static struct dfa dfa;

/* The Regex compiled patterns.  */
static struct patterns
{
  /* Regex compiled regexp. */
  struct re_pattern_buffer regexbuf;
  struct re_registers regs; /* This is here on account of a BRAIN-DEAD
			       Q@#%!# library interface in regex.c.  */
} patterns0;

struct patterns *patterns;
size_t pcount;

void
dfaerror (char const *mesg)
{
  error (EXIT_TROUBLE, 0, "%s", mesg);

  /* notreached */
  /* Tell static analyzers that this function does not return.  */
  abort ();
}

/* Number of compiled fixed strings known to exactly match the regexp.
   If kwsexec returns < kwset_exact_matches, then we don't need to
   call the regexp matcher at all. */
static int kwset_exact_matches;

static char const *
kwsincr_case (const char *must)
{
  const char *buf;
  size_t n;

  n = strlen (must);
#ifdef MBS_SUPPORT
  if (match_icase && MB_CUR_MAX > 1)
    buf = mbtolower (must, &n);
  else
#endif
    buf = must;
  return kwsincr (kwset, buf, n);
}

/* If the DFA turns out to have some set of fixed strings one of
   which must occur in the match, then we build a kwset matcher
   to find those strings, and thus quickly filter out impossible
   matches. */
static void
kwsmusts (void)
{
  struct dfamust const *dm;
  char const *err;

  if (dfa.musts)
    {
      kwsinit (&kwset);
      /* First, we compile in the substrings known to be exact
	 matches.  The kwset matcher will return the index
	 of the matching string that it chooses. */
      for (dm = dfa.musts; dm; dm = dm->next)
	{
	  if (!dm->exact)
	    continue;
	  ++kwset_exact_matches;
	  if ((err = kwsincr_case (dm->must)) != NULL)
	    error (EXIT_TROUBLE, 0, "%s", err);
	}
      /* Now, we compile the substrings that will require
	 the use of the regexp matcher.  */
      for (dm = dfa.musts; dm; dm = dm->next)
	{
	  if (dm->exact)
	    continue;
	  if ((err = kwsincr_case (dm->must)) != NULL)
	    error (EXIT_TROUBLE, 0, "%s", err);
	}
      if ((err = kwsprep (kwset)) != NULL)
	error (EXIT_TROUBLE, 0, "%s", err);
    }
}

void
GEAcompile (char const *pattern, size_t size, reg_syntax_t syntax_bits)
{
  const char *err;
  const char *p, *sep;
  size_t total = size;
  char *motif;

  if (match_icase)
    syntax_bits |= RE_ICASE;
  re_set_syntax (syntax_bits);
  dfasyntax (syntax_bits, match_icase, eolbyte);

  /* For GNU regex compiler we have to pass the patterns separately to detect
     errors like "[\nallo\n]\n".  The patterns here are "[", "allo" and "]"
     GNU regex should have raise a syntax error.  The same for backref, where
     the backref should have been local to each pattern.  */
  p = pattern;
  do
    {
      size_t len;
      sep = memchr (p, '\n', total);
      if (sep)
	{
	  len = sep - p;
	  sep++;
	  total -= (len + 1);
	}
      else
	{
	  len = total;
	  total = 0;
	}

      patterns = realloc (patterns, (pcount + 1) * sizeof (*patterns));
      if (patterns == NULL)
	error (EXIT_TROUBLE, errno, _("memory exhausted"));
      patterns[pcount] = patterns0;

      if ((err = re_compile_pattern (p, len,
				    &(patterns[pcount].regexbuf))) != NULL)
	error (EXIT_TROUBLE, 0, "%s", err);
      pcount++;

      p = sep;
    } while (sep && total != 0);

  /* In the match_words and match_lines cases, we use a different pattern
     for the DFA matcher that will quickly throw out cases that won't work.
     Then if DFA succeeds we do some hairy stuff using the regex matcher
     to decide whether the match should really count. */
  if (match_words || match_lines)
    {
      static char const line_beg_no_bk[] = "^(";
      static char const line_end_no_bk[] = ")$";
      static char const word_beg_no_bk[] = "(^|[^[:alnum:]_])(";
      static char const word_end_no_bk[] = ")([^[:alnum:]_]|$)";
      static char const line_beg_bk[] = "^\\(";
      static char const line_end_bk[] = "\\)$";
      static char const word_beg_bk[] = "\\(^\\|[^[:alnum:]_]\\)\\(";
      static char const word_end_bk[] = "\\)\\([^[:alnum:]_]\\|$\\)";
      int bk = !(syntax_bits & RE_NO_BK_PARENS);
      char *n = xmalloc (sizeof word_beg_bk - 1 + size + sizeof word_end_bk);

      strcpy (n, match_lines ? (bk ? line_beg_bk : line_beg_no_bk)
			     : (bk ? word_beg_bk : word_beg_no_bk));
      total = strlen(n);
      memcpy (n + total, pattern, size);
      total += size;
      strcpy (n + total, match_lines ? (bk ? line_end_bk : line_end_no_bk)
				     : (bk ? word_end_bk : word_end_no_bk));
      total += strlen (n + total);
      pattern = motif = n;
      size = total;
    }
  else
    motif = NULL;

  dfacomp (pattern, size, &dfa, 1);
  kwsmusts ();

  free(motif);
}

size_t
EGexecute (char const *buf, size_t size, size_t *match_size,
	   char const *start_ptr)
{
  char const *buflim, *beg, *end, *match, *best_match, *mb_start;
  char eol = eolbyte;
  int backref, start, len, best_len;
  struct kwsmatch kwsm;
  size_t i, ret_val;
#ifdef MBS_SUPPORT
  if (MB_CUR_MAX > 1)
    {
      if (match_icase)
        {
          /* mbtolower adds a NUL byte at the end.  That will provide
	     space for the sentinel byte dfaexec may add.  */
          char *case_buf = mbtolower (buf, &size);
	  if (start_ptr)
	    start_ptr = case_buf + (start_ptr - buf);
          buf = case_buf;
        }
    }
#endif /* MBS_SUPPORT */

  mb_start = buf;
  buflim = buf + size;

  for (beg = end = buf; end < buflim; beg = end)
    {
      if (!start_ptr)
	{
	  /* We don't care about an exact match.  */
	  if (kwset)
	    {
	      /* Find a possible match using the KWset matcher. */
	      size_t offset = kwsexec (kwset, beg, buflim - beg, &kwsm);
	      if (offset == (size_t) -1)
		goto failure;
	      beg += offset;
	      /* Narrow down to the line containing the candidate, and
		 run it through DFA. */
	      if ((end = memchr(beg, eol, buflim - beg)) != NULL)
	        end++;
              else
                end = buflim;
	      match = beg;
	      while (beg > buf && beg[-1] != eol)
		--beg;
	      if (kwsm.index < kwset_exact_matches)
                {
#ifdef MBS_SUPPORT
                  if (mb_start < beg)
                    mb_start = beg;
                  if (MB_CUR_MAX == 1 || !is_mb_middle (&mb_start, match, buflim))
#endif
                    goto success;
                }
	      if (dfaexec (&dfa, beg, (char *) end, 0, NULL, &backref) == NULL)
		continue;
	    }
	  else
	    {
	      /* No good fixed strings; start with DFA. */
	      char const *next_beg = dfaexec (&dfa, beg, (char *) buflim,
					      0, NULL, &backref);
	      if (next_beg == NULL)
		break;
	      /* Narrow down to the line we've found. */
	      beg = next_beg;
	      if ((end = memchr(beg, eol, buflim - beg)) != NULL)
	        end++;
              else
                end = buflim;
	      while (beg > buf && beg[-1] != eol)
		--beg;
	    }
	  /* Successful, no backreferences encountered! */
	  if (!backref)
	    goto success;
	}
      else
	{
	  /* We are looking for the leftmost (then longest) exact match.
	     We will go through the outer loop only once.  */
	  beg = start_ptr;
	  end = buflim;
	}

      /* If we've made it to this point, this means DFA has seen
	 a probable match, and we need to run it through Regex. */
      best_match = end;
      best_len = 0;
      for (i = 0; i < pcount; i++)
	{
	  patterns[i].regexbuf.not_eol = 0;
	  if (0 <= (start = re_search (&(patterns[i].regexbuf),
				       buf, end - buf - 1,
				       beg - buf, end - beg - 1,
				       &(patterns[i].regs))))
	    {
	      len = patterns[i].regs.end[0] - start;
	      match = buf + start;
	      if (match > best_match)
		continue;
	      if (start_ptr && !match_words)
		goto assess_pattern_match;
	      if ((!match_lines && !match_words)
		  || (match_lines && len == end - beg - 1))
		{
		  match = beg;
		  len = end - beg;
		  goto assess_pattern_match;
		}
	      /* If -w, check if the match aligns with word boundaries.
		 We do this iteratively because:
		 (a) the line may contain more than one occurence of the
		 pattern, and
		 (b) Several alternatives in the pattern might be valid at a
		 given point, and we may need to consider a shorter one to
		 find a word boundary.  */
	      if (match_words)
		while (match <= best_match)
		  {
		    if ((match == buf || !WCHAR ((unsigned char) match[-1]))
			&& (len == end - beg - 1
			    || !WCHAR ((unsigned char) match[len])))
		      goto assess_pattern_match;
		    if (len > 0)
		      {
			/* Try a shorter length anchored at the same place. */
			--len;
			patterns[i].regexbuf.not_eol = 1;
			len = re_match (&(patterns[i].regexbuf),
					buf, match + len - beg, match - buf,
					&(patterns[i].regs));
		      }
		    if (len <= 0)
		      {
			/* Try looking further on. */
			if (match == end - 1)
			  break;
			match++;
			patterns[i].regexbuf.not_eol = 0;
			start = re_search (&(patterns[i].regexbuf),
					   buf, end - buf - 1,
					   match - buf, end - match - 1,
					   &(patterns[i].regs));
			if (start < 0)
			  break;
			len = patterns[i].regs.end[0] - start;
			match = buf + start;
		      }
		  } /* while (match <= best_match) */
	      continue;
	    assess_pattern_match:
	      if (!start_ptr)
		{
		  /* Good enough for a non-exact match.
		     No need to look at further patterns, if any.  */
		  
//Patch 0:
if ((__is_neg(25, &(beg), sizeof (beg), &(match), sizeof (match), &(best_match), sizeof (best_match), &(len), sizeof (len), &(best_len), sizeof (best_len), &(start_ptr), sizeof (start_ptr), &(buf), sizeof (buf), &(start), sizeof (start), &(i), sizeof (i), &(patterns), sizeof (patterns), &(end), sizeof (end), &(ret_val), sizeof (ret_val), &(match_size), sizeof (match_size), &(match_words), sizeof (match_words), &(match_lines), sizeof (match_lines), &(pcount), sizeof (pcount), &(buflim), sizeof (buflim), &(backref), sizeof (backref), &(eol), sizeof (eol), &(mb_start), sizeof (mb_start), &(kwset_exact_matches), sizeof (kwset_exact_matches), &(kwset), sizeof (kwset), &(size), sizeof (size), &(match_icase), sizeof (match_icase), &(eolbyte), sizeof (eolbyte))))
    goto success;
beg = match;

//CodeSeg 1:
		  goto success_in_len;
		}
	      if (match < best_match || (match == best_match && len > best_len))
		{
		  /* Best exact match:  leftmost, then longest.  */
		  best_match = match;
		  best_len = len;
		}
	    } /* if re_search >= 0 */
	} /* for Regex patterns.  */
	if (best_match < end)
	  {
	    /* We have found an exact match.  We were just
	       waiting for the best one (leftmost then longest).  */
	    beg = best_match;
	    len = best_len;
	    goto success_in_len;
	  }
    } /* for (beg = end ..) */

 failure:
  ret_val = -1;
  goto out;

 success:
  len = end - beg;
 success_in_len:
  *match_size = len;
  ret_val = beg - buf;
 out:
  return ret_val;
}

Postprocessing failed!
Total cnt of passed cond schemas: 7
Total cnt of cond schemas: 103
Counter: 104
Batcher Size:0
The found score 19999980.000000 is greater than current score 8746.000000!
Terminate current session!
Generated a patch at candidate schema no 21
Total cnt of passed cond schemas: 7
Total cnt of cond schemas: 103
Candidate count:0!!
Found a fix! Store to: grep-fix-8a025cf8-8f08d8e2src_dfasearch.c
Found a fix! Store to: grep-fix-8a025cf8-8f08d8e2src_dfasearch.c-1
Found a fix! Store to: grep-fix-8a025cf8-8f08d8e2src_dfasearch.c-2
Found a fix! Store to: grep-fix-8a025cf8-8f08d8e2src_dfasearch.c-3
Repair process ends successfully!
Total 16012 different repair candidate schema!!!!
Total number of compiles: 60
Total number of test eval: 391
