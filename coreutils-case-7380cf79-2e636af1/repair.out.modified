Initialize the program!
Generating repair candidates!
Processing src/cut.c
In dir /home/ubuntu/spr-fast/tests/corebench/coreutils/coreutils-case-7380cf79-2e636af1/tempworkdir/src
BUILDDIR:
BUILDCMD:/home/ubuntu/spr-fast/tools/coreutils-build.py -p /home/ubuntu/spr-fast/benchmarks/coreutils-deps -c -d src/cut.c /home/ubuntu/spr-fast/tests/corebench/coreutils/coreutils-case-7380cf79-2e636af1/tempworkdir/src __args >>/home/ubuntu/spr-fast/tests/corebench/coreutils/coreutils-case-7380cf79-2e636af1/tempworkdir/build.log 2>&1
going to directory /home/ubuntu/spr-fast/tests/corebench/coreutils/coreutils-case-7380cf79-2e636af1/tempworkdir/src
src/cut.c:26:10: fatal error: 'config.h' file not found
#include <config.h>
         ^
IsErr:priority 4981
at location src/cut.c:365
--src file: src/cut.c
fragment 0:
if (!(__abst_hole(fieldstr, in_digits, dash_found, initial, value, lhs_specified, rhs_specified, eol_range_start, field_found, rp, n_rp, n_rp_allocated, operating_mode, max_range_endpoint, i, printable_field, complement, output_delimiter_specified)))
    if (*fieldstr == '-') {
        in_digits = 0;
        if (dash_found)
            do {
                error(0, 0, (gettext("invalid byte or field list")));
                usage(1);
            } while (0);
        dash_found = 1;
        fieldstr++;
        initial = (lhs_specified ? value : 1);
        value = 0;
    } else if (*fieldstr == ',' || ((*__ctype_b_loc())[(int)((to_uchar(*fieldstr)))] & (unsigned short)_isblank) || *fieldstr == '\x00') {
        in_digits = 0;
        if (dash_found) {
            dash_found = 0;
            if (!lhs_specified && !rhs_specified)
                do {
                    error(0, 0, (gettext("invalid range with no endpoint: -")));
                    usage(1);
                } while (0);
            if (!rhs_specified) {
                eol_range_start = initial;
                field_found = 1;
            } else {
                if (value < initial)
                    do {
                        error(0, 0, (gettext("invalid decreasing range")));
                        usage(1);
                    } while (0);
                if (eol_range_start != 0) {
                    if (initial < eol_range_start) {
                        if (eol_range_start <= value) {
                            eol_range_start = initial;
                        } else {
                            do {
                                if (initial == 0 || value == 0)
                                    do {
                                        error(0, 0, (gettext("fields and positions are numbered from 1")));
                                        usage(1);
                                    } while (0);
                                if (n_rp >= n_rp_allocated) {
                                    (rp) = x2nrealloc(rp, &n_rp_allocated, sizeof *(rp));
                                }
                                rp[n_rp].lo = (initial);
                                rp[n_rp].hi = (value);
                                ++n_rp;
                            } while (0);
                        }
                        field_found = 1;
                    }
                } else {
                    do {
                        if (initial == 0 || value == 0)
                            do {
                                error(0, 0, (gettext("fields and positions are numbered from 1")));
                                usage(1);
                            } while (0);
                        if (n_rp >= n_rp_allocated) {
                            (rp) = x2nrealloc(rp, &n_rp_allocated, sizeof *(rp));
                        }
                        rp[n_rp].lo = (initial);
                        rp[n_rp].hi = (value);
                        ++n_rp;
                    } while (0);
                    field_found = 1;
                }
                value = 0;
            }
        } else {
            do {
                if (value == 0 || value == 0)
                    do {
                        error(0, 0, (gettext("fields and positions are numbered from 1")));
                        usage(1);
                    } while (0);
                if (n_rp >= n_rp_allocated) {
                    (rp) = x2nrealloc(rp, &n_rp_allocated, sizeof *(rp));
                }
                rp[n_rp].lo = (value);
                rp[n_rp].hi = (value);
                ++n_rp;
            } while (0);
            value = 0;
            field_found = 1;
        }
        if (*fieldstr == '\x00') {
            break;
        }
        fieldstr++;
        lhs_specified = 0;
        rhs_specified = 0;
    } else if (((unsigned int)(*fieldstr) - '0' <= 9)) {
        static const char *num_start;
        if (!in_digits || !num_start)
            num_start = fieldstr;
        in_digits = 1;
        if (dash_found)
            rhs_specified = 1;
        else
            lhs_specified = 1;
        if (!((void)(&(value) == (size_t *)((void *)0)) , (((size_t)-1 / 10 < (value) || (size_t)((value) * 10 + (*fieldstr - '0')) < (value)) ? 0 : (((value) = (value) * 10 + (*fieldstr - '0')) , 1)))) {
            size_t len = strspn(num_start, "0123456789");
            char *bad_num = xstrndup(num_start, len);
            if (operating_mode == byte_mode)
                error(0, 0, gettext("byte offset %s is too large"), quote(bad_num));
            else
                error(0, 0, gettext("field number %s is too large"), quote(bad_num));
            free(bad_num);
            exit(1);
        }
        fieldstr++;
    } else
        do {
            error(0, 0, (gettext("invalid byte or field list")));
            usage(1);
        } while (0);

....
Skipping error ifguard:Priority 4981
At location src/cut.c:365
--Src File: src/cut.c
Fragment 0:
if (!(__abst_hole(fieldstr, in_digits, dash_found, initial, value, lhs_specified, rhs_specified, eol_range_start, field_found, rp, n_rp, n_rp_allocated, operating_mode, max_range_endpoint, i, printable_field, complement, output_delimiter_specified)))
    if (*fieldstr == '-') {
        in_digits = 0;
        if (dash_found)
            do {
                error(0, 0, (gettext("invalid byte or field list")));
                usage(1);
            } while (0);
        dash_found = 1;
        fieldstr++;
        initial = (lhs_specified ? value : 1);
        value = 0;
    } else if (*fieldstr == ',' || ((*__ctype_b_loc())[(int)((to_uchar(*fieldstr)))] & (unsigned short)_ISblank) || *fieldstr == '\x00') {
        in_digits = 0;
        if (dash_found) {
            dash_found = 0;
            if (!lhs_specified && !rhs_specified)
                do {
                    error(0, 0, (gettext("invalid range with no endpoint: -")));
                    usage(1);
                } while (0);
            if (!rhs_specified) {
                eol_range_start = initial;
                field_found = 1;
            } else {
                if (value < initial)
                    do {
                        error(0, 0, (gettext("invalid decreasing range")));
                        usage(1);
                    } while (0);
                if (eol_range_start != 0) {
                    if (initial < eol_range_start) {
                        if (eol_range_start <= value) {
                            eol_range_start = initial;
                        } else {
                            do {
                                if (initial == 0 || value == 0)
                                    do {
                                        error(0, 0, (gettext("fields and positions are numbered from 1")));
                                        usage(1);
                                    } while (0);
                                if (n_rp >= n_rp_allocated) {
                                    (rp) = x2nrealloc(rp, &n_rp_allocated, sizeof *(rp));
                                }
                                rp[n_rp].lo = (initial);
                                rp[n_rp].hi = (value);
                                ++n_rp;
                            } while (0);
                        }
                        field_found = 1;
                    }
                } else {
                    do {
                        if (initial == 0 || value == 0)
                            do {
                                error(0, 0, (gettext("fields and positions are numbered from 1")));
                                usage(1);
                            } while (0);
                        if (n_rp >= n_rp_allocated) {
                            (rp) = x2nrealloc(rp, &n_rp_allocated, sizeof *(rp));
                        }
                        rp[n_rp].lo = (initial);
                        rp[n_rp].hi = (value);
                        ++n_rp;
                    } while (0);
                    field_found = 1;
                }
                value = 0;
            }
        } else {
            do {
                if (value == 0 || value == 0)
                    do {
                        error(0, 0, (gettext("fields and positions are numbered from 1")));
                        usage(1);
                    } while (0);
                if (n_rp >= n_rp_allocated) {
                    (rp) = x2nrealloc(rp, &n_rp_allocated, sizeof *(rp));
                }
                rp[n_rp].lo = (value);
                rp[n_rp].hi = (value);
                ++n_rp;
            } while (0);
            value = 0;
            field_found = 1;
        }
        if (*fieldstr == '\x00') {
            break;
        }
        fieldstr++;
        lhs_specified = 0;
        rhs_specified = 0;
    } else if (((unsigned int)(*fieldstr) - '0' <= 9)) {
        static const char *num_start;
        if (!in_digits || !num_start)
            num_start = fieldstr;
        in_digits = 1;
        if (dash_found)
            rhs_specified = 1;
        else
            lhs_specified = 1;
        if (!((void)(&(value) == (size_t *)((void *)0)) , (((size_t)-1 / 10 < (value) || (size_t)((value) * 10 + (*fieldstr - '0')) < (value)) ? 0 : (((value) = (value) * 10 + (*fieldstr - '0')) , 1)))) {
            size_t len = strspn(num_start, "0123456789");
            char *bad_num = xstrndup(num_start, len);
            if (operating_mode == byte_mode)
                error(0, 0, gettext("byte offset %s is too large"), quote(bad_num));
            else
                error(0, 0, gettext("field number %s is too large"), quote(bad_num));
            free(bad_num);
            exit(1);
        }
        fieldstr++;
    } else
        do {
            error(0, 0, (gettext("invalid byte or field list")));
            usage(1);
        } while (0);

....
Skipping nonlast addifexit:Priority 9975
At location src/cut.c:367
--Src File: src/cut.c
Fragment 0:
if ((__abst_hole(in_digits, fieldstr, dash_found, initial, value, lhs_specified, rhs_specified, eol_range_start, field_found, rp, n_rp, n_rp_allocated, operating_mode, max_range_endpoint, i, printable_field, complement, output_delimiter_specified)))
    break;
in_digits = 0;

....
IsErr:priority 4976
at location src/cut.c:369
--src file: src/cut.c
fragment 0:
if (!(__abst_hole(dash_found, in_digits, fieldstr, initial, value, lhs_specified, rhs_specified, eol_range_start, field_found, rp, n_rp, n_rp_allocated, operating_mode, max_range_endpoint, i, printable_field, complement, output_delimiter_specified)))
    if (dash_found)
        do {
            error(0, 0, (gettext("invalid byte or field list")));
            usage(1);
        } while (0);

....
Skipping error ifguard:Priority 4976
At location src/cut.c:369
--Src File: src/cut.c
Fragment 0:
if (!(__abst_hole(dash_found, in_digits, fieldstr, initial, value, lhs_specified, rhs_specified, eol_range_start, field_found, rp, n_rp, n_rp_allocated, operating_mode, max_range_endpoint, i, printable_field, complement, output_delimiter_specified)))
    if (dash_found)
        do {
            error(0, 0, (gettext("invalid byte or field list")));
            usage(1);
        } while (0);

....
Skipping nonlast addifexit:Priority 3726
At location src/cut.c:369
--Src File: src/cut.c
Fragment 0:
if ((__abst_hole(dash_found, in_digits, fieldstr, initial, value, lhs_specified, rhs_specified, eol_range_start, field_found, rp, n_rp, n_rp_allocated, operating_mode, max_range_endpoint, i, printable_field, complement, output_delimiter_specified)))
    break;
if (dash_found)
    do {
        error(0, 0, (gettext("invalid byte or field list")));
        usage(1);
    } while (0);

....
Skipping nonlast addifexit:Priority 4977
At location src/cut.c:371
--Src File: src/cut.c
Fragment 0:
if ((__abst_hole(dash_found, fieldstr, initial, value, lhs_specified, in_digits, rhs_specified, eol_range_start, field_found, rp, n_rp, n_rp_allocated, operating_mode, max_range_endpoint, i, printable_field, complement, output_delimiter_specified)))
    break;
dash_found = 1;

....
Skipping nonlast addifexit:Priority 4978
At location src/cut.c:372
--Src File: src/cut.c
Fragment 0:
if ((__abst_hole(fieldstr, dash_found, initial, value, lhs_specified, in_digits, rhs_specified, eol_range_start, field_found, rp, n_rp, n_rp_allocated, operating_mode, max_range_endpoint, i, printable_field, complement, output_delimiter_specified)))
    break;
fieldstr++;

....
Skipping nonlast addifexit:Priority 4979
At location src/cut.c:374
--Src File: src/cut.c
Fragment 0:
if ((__abst_hole(initial, value, lhs_specified, fieldstr, dash_found, in_digits, rhs_specified, eol_range_start, field_found, rp, n_rp, n_rp_allocated, operating_mode, max_range_endpoint, i, printable_field, complement, output_delimiter_specified)))
    break;
initial = (lhs_specified ? value : 1);

....
IsErr:priority 4982
at location src/cut.c:377
--src file: src/cut.c
fragment 0:
{
    if (!(__abst_hole(fieldstr, value, initial, lhs_specified, in_digits, dash_found, rhs_specified, eol_range_start, field_found, rp, n_rp, n_rp_allocated, operating_mode, max_range_endpoint, i, printable_field, complement, output_delimiter_specified)))
        if (*fieldstr == ',' || ((*__ctype_b_loc())[(int)((to_uchar(*fieldstr)))] & (unsigned short)_isblank) || *fieldstr == '\x00') {
            in_digits = 0;
            if (dash_found) {
                dash_found = 0;
                if (!lhs_specified && !rhs_specified)
                    do {
                        error(0, 0, (gettext("invalid range with no endpoint: -")));
                        usage(1);
                    } while (0);
                if (!rhs_specified) {
                    eol_range_start = initial;
                    field_found = 1;
                } else {
                    if (value < initial)
                        do {
                            error(0, 0, (gettext("invalid decreasing range")));
                            usage(1);
                        } while (0);
                    if (eol_range_start != 0) {
                        if (initial < eol_range_start) {
                            if (eol_range_start <= value) {
                                eol_range_start = initial;
                            } else {
                                do {
                                    if (initial == 0 || value == 0)
                                        do {
                                            error(0, 0, (gettext("fields and positions are numbered from 1")));
                                            usage(1);
                                        } while (0);
                                    if (n_rp >= n_rp_allocated) {
                                        (rp) = x2nrealloc(rp, &n_rp_allocated, sizeof *(rp));
                                    }
                                    rp[n_rp].lo = (initial);
                                    rp[n_rp].hi = (value);
                                    ++n_rp;
                                } while (0);
                            }
                            field_found = 1;
                        }
                    } else {
                        do {
                            if (initial == 0 || value == 0)
                                do {
                                    error(0, 0, (gettext("fields and positions are numbered from 1")));
                                    usage(1);
                                } while (0);
                            if (n_rp >= n_rp_allocated) {
                                (rp) = x2nrealloc(rp, &n_rp_allocated, sizeof *(rp));
                            }
                            rp[n_rp].lo = (initial);
                            rp[n_rp].hi = (value);
                            ++n_rp;
                        } while (0);
                        field_found = 1;
                    }
                    value = 0;
                }
            } else {
                do {
                    if (value == 0 || value == 0)
                        do {
                            error(0, 0, (gettext("fields and positions are numbered from 1")));
                            usage(1);
                        } while (0);
                    if (n_rp >= n_rp_allocated) {
                        (rp) = x2nrealloc(rp, &n_rp_allocated, sizeof *(rp));
                    }
                    rp[n_rp].lo = (value);
                    rp[n_rp].hi = (value);
                    ++n_rp;
                } while (0);
                value = 0;
                field_found = 1;
            }
            if (*fieldstr == '\x00') {
                break;
            }
            fieldstr++;
            lhs_specified = 0;
            rhs_specified = 0;
        } else if (((unsigned int)(*fieldstr) - '0' <= 9)) {
            static const char *num_start;
            if (!in_digits || !num_start)
                num_start = fieldstr;
            in_digits = 1;
            if (dash_found)
                rhs_specified = 1;
            else
                lhs_specified = 1;
            if (!((void)(&(value) == (size_t *)((void *)0)) , (((size_t)-1 / 10 < (value) || (size_t)((value) * 10 + (*fieldstr - '0')) < (value)) ? 0 : (((value) = (value) * 10 + (*fieldstr - '0')) , 1)))) {
                size_t len = strspn(num_start, "0123456789");
                char *bad_num = xstrndup(num_start, len);
                if (operating_mode == byte_mode)
                    error(0, 0, gettext("byte offset %s is too large"), quote(bad_num));
                else
                    error(0, 0, gettext("field number %s is too large"), quote(bad_num));
                free(bad_num);
                exit(1);
            }
            fieldstr++;
        } else
            do {
                error(0, 0, (gettext("invalid byte or field list")));
                usage(1);
            } while (0);
}

....
Skipping error ifguard:Priority 4982
At location src/cut.c:377
--Src File: src/cut.c
Fragment 0:
{
    if (!(__abst_hole(fieldstr, value, initial, lhs_specified, in_digits, dash_found, rhs_specified, eol_range_start, field_found, rp, n_rp, n_rp_allocated, operating_mode, max_range_endpoint, i, printable_field, complement, output_delimiter_specified)))
        if (*fieldstr == ',' || ((*__ctype_b_loc())[(int)((to_uchar(*fieldstr)))] & (unsigned short)_ISblank) || *fieldstr == '\x00') {
            in_digits = 0;
            if (dash_found) {
                dash_found = 0;
                if (!lhs_specified && !rhs_specified)
                    do {
                        error(0, 0, (gettext("invalid range with no endpoint: -")));
                        usage(1);
                    } while (0);
                if (!rhs_specified) {
                    eol_range_start = initial;
                    field_found = 1;
                } else {
                    if (value < initial)
                        do {
                            error(0, 0, (gettext("invalid decreasing range")));
                            usage(1);
                        } while (0);
                    if (eol_range_start != 0) {
                        if (initial < eol_range_start) {
                            if (eol_range_start <= value) {
                                eol_range_start = initial;
                            } else {
                                do {
                                    if (initial == 0 || value == 0)
                                        do {
                                            error(0, 0, (gettext("fields and positions are numbered from 1")));
                                            usage(1);
                                        } while (0);
                                    if (n_rp >= n_rp_allocated) {
                                        (rp) = x2nrealloc(rp, &n_rp_allocated, sizeof *(rp));
                                    }
                                    rp[n_rp].lo = (initial);
                                    rp[n_rp].hi = (value);
                                    ++n_rp;
                                } while (0);
                            }
                            field_found = 1;
                        }
                    } else {
                        do {
                            if (initial == 0 || value == 0)
                                do {
                                    error(0, 0, (gettext("fields and positions are numbered from 1")));
                                    usage(1);
                                } while (0);
                            if (n_rp >= n_rp_allocated) {
                                (rp) = x2nrealloc(rp, &n_rp_allocated, sizeof *(rp));
                            }
                            rp[n_rp].lo = (initial);
                            rp[n_rp].hi = (value);
                            ++n_rp;
                        } while (0);
                        field_found = 1;
                    }
                    value = 0;
                }
            } else {
                do {
                    if (value == 0 || value == 0)
                        do {
                            error(0, 0, (gettext("fields and positions are numbered from 1")));
                            usage(1);
                        } while (0);
                    if (n_rp >= n_rp_allocated) {
                        (rp) = x2nrealloc(rp, &n_rp_allocated, sizeof *(rp));
                    }
                    rp[n_rp].lo = (value);
                    rp[n_rp].hi = (value);
                    ++n_rp;
                } while (0);
                value = 0;
                field_found = 1;
            }
            if (*fieldstr == '\x00') {
                break;
            }
            fieldstr++;
            lhs_specified = 0;
            rhs_specified = 0;
        } else if (((unsigned int)(*fieldstr) - '0' <= 9)) {
            static const char *num_start;
            if (!in_digits || !num_start)
                num_start = fieldstr;
            in_digits = 1;
            if (dash_found)
                rhs_specified = 1;
            else
                lhs_specified = 1;
            if (!((void)(&(value) == (size_t *)((void *)0)) , (((size_t)-1 / 10 < (value) || (size_t)((value) * 10 + (*fieldstr - '0')) < (value)) ? 0 : (((value) = (value) * 10 + (*fieldstr - '0')) , 1)))) {
                size_t len = strspn(num_start, "0123456789");
                char *bad_num = xstrndup(num_start, len);
                if (operating_mode == byte_mode)
                    error(0, 0, gettext("byte offset %s is too large"), quote(bad_num));
                else
                    error(0, 0, gettext("field number %s is too large"), quote(bad_num));
                free(bad_num);
                exit(1);
            }
            fieldstr++;
        } else
            do {
                error(0, 0, (gettext("invalid byte or field list")));
                usage(1);
            } while (0);
}

....
Skipping nonlast addifexit:Priority 3732
At location src/cut.c:377
--Src File: src/cut.c
Fragment 0:
{
    if ((__abst_hole(fieldstr, value, initial, lhs_specified, in_digits, dash_found, rhs_specified, eol_range_start, field_found, rp, n_rp, n_rp_allocated, operating_mode, max_range_endpoint, i, printable_field, complement, output_delimiter_specified)))
        break;
    if (*fieldstr == ',' || ((*__ctype_b_loc())[(int)((to_uchar(*fieldstr)))] & (unsigned short)_ISblank) || *fieldstr == '\x00') {
        in_digits = 0;
        if (dash_found) {
            dash_found = 0;
            if (!lhs_specified && !rhs_specified)
                do {
                    error(0, 0, (gettext("invalid range with no endpoint: -")));
                    usage(1);
                } while (0);
            if (!rhs_specified) {
                eol_range_start = initial;
                field_found = 1;
            } else {
                if (value < initial)
                    do {
                        error(0, 0, (gettext("invalid decreasing range")));
                        usage(1);
                    } while (0);
                if (eol_range_start != 0) {
                    if (initial < eol_range_start) {
                        if (eol_range_start <= value) {
                            eol_range_start = initial;
                        } else {
                            do {
                                if (initial == 0 || value == 0)
                                    do {
                                        error(0, 0, (gettext("fields and positions are numbered from 1")));
                                        usage(1);
                                    } while (0);
                                if (n_rp >= n_rp_allocated) {
                                    (rp) = x2nrealloc(rp, &n_rp_allocated, sizeof *(rp));
                                }
                                rp[n_rp].lo = (initial);
                                rp[n_rp].hi = (value);
                                ++n_rp;
                            } while (0);
                        }
                        field_found = 1;
                    }
                } else {
                    do {
                        if (initial == 0 || value == 0)
                            do {
                                error(0, 0, (gettext("fields and positions are numbered from 1")));
                                usage(1);
                            } while (0);
                        if (n_rp >= n_rp_allocated) {
                            (rp) = x2nrealloc(rp, &n_rp_allocated, sizeof *(rp));
                        }
                        rp[n_rp].lo = (initial);
                        rp[n_rp].hi = (value);
                        ++n_rp;
                    } while (0);
                    field_found = 1;
                }
                value = 0;
            }
        } else {
            do {
                if (value == 0 || value == 0)
                    do {
                        error(0, 0, (gettext("fields and positions are numbered from 1")));
                        usage(1);
                    } while (0);
                if (n_rp >= n_rp_allocated) {
                    (rp) = x2nrealloc(rp, &n_rp_allocated, sizeof *(rp));
                }
                rp[n_rp].lo = (value);
                rp[n_rp].hi = (value);
                ++n_rp;
            } while (0);
            value = 0;
            field_found = 1;
        }
        if (*fieldstr == '\x00') {
            break;
        }
        fieldstr++;
        lhs_specified = 0;
        rhs_specified = 0;
    } else if (((unsigned int)(*fieldstr) - '0' <= 9)) {
        static const char *num_start;
        if (!in_digits || !num_start)
            num_start = fieldstr;
        in_digits = 1;
        if (dash_found)
            rhs_specified = 1;
        else
            lhs_specified = 1;
        if (!((void)(&(value) == (size_t *)((void *)0)) , (((size_t)-1 / 10 < (value) || (size_t)((value) * 10 + (*fieldstr - '0')) < (value)) ? 0 : (((value) = (value) * 10 + (*fieldstr - '0')) , 1)))) {
            size_t len = strspn(num_start, "0123456789");
            char *bad_num = xstrndup(num_start, len);
            if (operating_mode == byte_mode)
                error(0, 0, gettext("byte offset %s is too large"), quote(bad_num));
            else
                error(0, 0, gettext("field number %s is too large"), quote(bad_num));
            free(bad_num);
            exit(1);
        }
        fieldstr++;
    } else
        do {
            error(0, 0, (gettext("invalid byte or field list")));
            usage(1);
        } while (0);
}

....
Skipping nonlast addifexit:Priority 9983
At location src/cut.c:380
--Src File: src/cut.c
Fragment 0:
if ((__abst_hole(in_digits, fieldstr, dash_found, value, initial, lhs_specified, rhs_specified, eol_range_start, field_found, rp, n_rp, n_rp_allocated, operating_mode, max_range_endpoint, i, printable_field, complement, output_delimiter_specified)))
    break;
in_digits = 0;

....
IsErr:priority 4984
at location src/cut.c:382
--src file: src/cut.c
fragment 0:
if (!(__abst_hole(dash_found, in_digits, fieldstr, lhs_specified, rhs_specified, value, initial, eol_range_start, field_found, rp, n_rp, n_rp_allocated, operating_mode, max_range_endpoint, i, printable_field, complement, output_delimiter_specified)))
    if (dash_found) {
        dash_found = 0;
        if (!lhs_specified && !rhs_specified)
            do {
                error(0, 0, (gettext("invalid range with no endpoint: -")));
                usage(1);
            } while (0);
        if (!rhs_specified) {
            eol_range_start = initial;
            field_found = 1;
        } else {
            if (value < initial)
                do {
                    error(0, 0, (gettext("invalid decreasing range")));
                    usage(1);
                } while (0);
            if (eol_range_start != 0) {
                if (initial < eol_range_start) {
                    if (eol_range_start <= value) {
                        eol_range_start = initial;
                    } else {
                        do {
                            if (initial == 0 || value == 0)
                                do {
                                    error(0, 0, (gettext("fields and positions are numbered from 1")));
                                    usage(1);
                                } while (0);
                            if (n_rp >= n_rp_allocated) {
                                (rp) = x2nrealloc(rp, &n_rp_allocated, sizeof *(rp));
                            }
                            rp[n_rp].lo = (initial);
                            rp[n_rp].hi = (value);
                            ++n_rp;
                        } while (0);
                    }
                    field_found = 1;
                }
            } else {
                do {
                    if (initial == 0 || value == 0)
                        do {
                            error(0, 0, (gettext("fields and positions are numbered from 1")));
                            usage(1);
                        } while (0);
                    if (n_rp >= n_rp_allocated) {
                        (rp) = x2nrealloc(rp, &n_rp_allocated, sizeof *(rp));
                    }
                    rp[n_rp].lo = (initial);
                    rp[n_rp].hi = (value);
                    ++n_rp;
                } while (0);
                field_found = 1;
            }
            value = 0;
        }
    } else {
        do {
            if (value == 0 || value == 0)
                do {
                    error(0, 0, (gettext("fields and positions are numbered from 1")));
                    usage(1);
                } while (0);
            if (n_rp >= n_rp_allocated) {
                (rp) = x2nrealloc(rp, &n_rp_allocated, sizeof *(rp));
            }
            rp[n_rp].lo = (value);
            rp[n_rp].hi = (value);
            ++n_rp;
        } while (0);
        value = 0;
        field_found = 1;
    }

....
Skipping error ifguard:Priority 4984
At location src/cut.c:382
--Src File: src/cut.c
Fragment 0:
if (!(__abst_hole(dash_found, in_digits, fieldstr, lhs_specified, rhs_specified, value, initial, eol_range_start, field_found, rp, n_rp, n_rp_allocated, operating_mode, max_range_endpoint, i, printable_field, complement, output_delimiter_specified)))
    if (dash_found) {
        dash_found = 0;
        if (!lhs_specified && !rhs_specified)
            do {
                error(0, 0, (gettext("invalid range with no endpoint: -")));
                usage(1);
            } while (0);
        if (!rhs_specified) {
            eol_range_start = initial;
            field_found = 1;
        } else {
            if (value < initial)
                do {
                    error(0, 0, (gettext("invalid decreasing range")));
                    usage(1);
                } while (0);
            if (eol_range_start != 0) {
                if (initial < eol_range_start) {
                    if (eol_range_start <= value) {
                        eol_range_start = initial;
                    } else {
                        do {
                            if (initial == 0 || value == 0)
                                do {
                                    error(0, 0, (gettext("fields and positions are numbered from 1")));
                                    usage(1);
                                } while (0);
                            if (n_rp >= n_rp_allocated) {
                                (rp) = x2nrealloc(rp, &n_rp_allocated, sizeof *(rp));
                            }
                            rp[n_rp].lo = (initial);
                            rp[n_rp].hi = (value);
                            ++n_rp;
                        } while (0);
                    }
                    field_found = 1;
                }
            } else {
                do {
                    if (initial == 0 || value == 0)
                        do {
                            error(0, 0, (gettext("fields and positions are numbered from 1")));
                            usage(1);
                        } while (0);
                    if (n_rp >= n_rp_allocated) {
                        (rp) = x2nrealloc(rp, &n_rp_allocated, sizeof *(rp));
                    }
                    rp[n_rp].lo = (initial);
                    rp[n_rp].hi = (value);
                    ++n_rp;
                } while (0);
                field_found = 1;
            }
            value = 0;
        }
    } else {
        do {
            if (value == 0 || value == 0)
                do {
                    error(0, 0, (gettext("fields and positions are numbered from 1")));
                    usage(1);
                } while (0);
            if (n_rp >= n_rp_allocated) {
                (rp) = x2nrealloc(rp, &n_rp_allocated, sizeof *(rp));
            }
            rp[n_rp].lo = (value);
            rp[n_rp].hi = (value);
            ++n_rp;
        } while (0);
        value = 0;
        field_found = 1;
    }

....
Skipping nonlast addifexit:Priority 3734
At location src/cut.c:382
--Src File: src/cut.c
Fragment 0:
if ((__abst_hole(dash_found, in_digits, fieldstr, lhs_specified, rhs_specified, value, initial, eol_range_start, field_found, rp, n_rp, n_rp_allocated, operating_mode, max_range_endpoint, i, printable_field, complement, output_delimiter_specified)))
    break;
if (dash_found) {
    dash_found = 0;
    if (!lhs_specified && !rhs_specified)
        do {
            error(0, 0, (gettext("invalid range with no endpoint: -")));
            usage(1);
        } while (0);
    if (!rhs_specified) {
        eol_range_start = initial;
        field_found = 1;
    } else {
        if (value < initial)
            do {
                error(0, 0, (gettext("invalid decreasing range")));
                usage(1);
            } while (0);
        if (eol_range_start != 0) {
            if (initial < eol_range_start) {
                if (eol_range_start <= value) {
                    eol_range_start = initial;
                } else {
                    do {
                        if (initial == 0 || value == 0)
                            do {
                                error(0, 0, (gettext("fields and positions are numbered from 1")));
                                usage(1);
                            } while (0);
                        if (n_rp >= n_rp_allocated) {
                            (rp) = x2nrealloc(rp, &n_rp_allocated, sizeof *(rp));
                        }
                        rp[n_rp].lo = (initial);
                        rp[n_rp].hi = (value);
                        ++n_rp;
                    } while (0);
                }
                field_found = 1;
            }
        } else {
            do {
                if (initial == 0 || value == 0)
                    do {
                        error(0, 0, (gettext("fields and positions are numbered from 1")));
                        usage(1);
                    } while (0);
                if (n_rp >= n_rp_allocated) {
                    (rp) = x2nrealloc(rp, &n_rp_allocated, sizeof *(rp));
                }
                rp[n_rp].lo = (initial);
                rp[n_rp].hi = (value);
                ++n_rp;
            } while (0);
            field_found = 1;
        }
        value = 0;
    }
} else {
    do {
        if (value == 0 || value == 0)
            do {
                error(0, 0, (gettext("fields and positions are numbered from 1")));
                usage(1);
            } while (0);
        if (n_rp >= n_rp_allocated) {
            (rp) = x2nrealloc(rp, &n_rp_allocated, sizeof *(rp));
        }
        rp[n_rp].lo = (value);
        rp[n_rp].hi = (value);
        ++n_rp;
    } while (0);
    value = 0;
    field_found = 1;
}

....
Skipping nonlast addifexit:Priority 9985
At location src/cut.c:384
--Src File: src/cut.c
Fragment 0:
if ((__abst_hole(dash_found, lhs_specified, rhs_specified, in_digits, fieldstr, value, initial, eol_range_start, field_found, rp, n_rp, n_rp_allocated, operating_mode, max_range_endpoint, i, printable_field, complement, output_delimiter_specified)))
    break;
dash_found = 0;

....
IsErr:priority 4986
at location src/cut.c:386
--src file: src/cut.c
fragment 0:
if (!(__abst_hole(lhs_specified, rhs_specified, dash_found, in_digits, fieldstr, initial, eol_range_start, field_found, value, rp, n_rp, n_rp_allocated, operating_mode, max_range_endpoint, i, printable_field, complement, output_delimiter_specified)))
    if (!lhs_specified && !rhs_specified)
        do {
            error(0, 0, (gettext("invalid range with no endpoint: -")));
            usage(1);
        } while (0);

....
Skipping error ifguard:Priority 4986
At location src/cut.c:386
--Src File: src/cut.c
Fragment 0:
if (!(__abst_hole(lhs_specified, rhs_specified, dash_found, in_digits, fieldstr, initial, eol_range_start, field_found, value, rp, n_rp, n_rp_allocated, operating_mode, max_range_endpoint, i, printable_field, complement, output_delimiter_specified)))
    if (!lhs_specified && !rhs_specified)
        do {
            error(0, 0, (gettext("invalid range with no endpoint: -")));
            usage(1);
        } while (0);

....
Skipping nonlast addifexit:Priority 3736
At location src/cut.c:386
--Src File: src/cut.c
Fragment 0:
if ((__abst_hole(lhs_specified, rhs_specified, dash_found, in_digits, fieldstr, initial, eol_range_start, field_found, value, rp, n_rp, n_rp_allocated, operating_mode, max_range_endpoint, i, printable_field, complement, output_delimiter_specified)))
    break;
if (!lhs_specified && !rhs_specified)
    do {
        error(0, 0, (gettext("invalid range with no endpoint: -")));
        usage(1);
    } while (0);

....
IsErr:priority 4987
at location src/cut.c:391
--src file: src/cut.c
fragment 0:
if (!(__abst_hole(rhs_specified, initial, eol_range_start, field_found, lhs_specified, dash_found, value, in_digits, fieldstr, rp, n_rp, n_rp_allocated, operating_mode, max_range_endpoint, i, printable_field, complement, output_delimiter_specified)))
    if (!rhs_specified) {
        eol_range_start = initial;
        field_found = 1;
    } else {
        if (value < initial)
            do {
                error(0, 0, (gettext("invalid decreasing range")));
                usage(1);
            } while (0);
        if (eol_range_start != 0) {
            if (initial < eol_range_start) {
                if (eol_range_start <= value) {
                    eol_range_start = initial;
                } else {
                    do {
                        if (initial == 0 || value == 0)
                            do {
                                error(0, 0, (gettext("fields and positions are numbered from 1")));
                                usage(1);
                            } while (0);
                        if (n_rp >= n_rp_allocated) {
                            (rp) = x2nrealloc(rp, &n_rp_allocated, sizeof *(rp));
                        }
                        rp[n_rp].lo = (initial);
                        rp[n_rp].hi = (value);
                        ++n_rp;
                    } while (0);
                }
                field_found = 1;
            }
        } else {
            do {
                if (initial == 0 || value == 0)
                    do {
                        error(0, 0, (gettext("fields and positions are numbered from 1")));
                        usage(1);
                    } while (0);
                if (n_rp >= n_rp_allocated) {
                    (rp) = x2nrealloc(rp, &n_rp_allocated, sizeof *(rp));
                }
                rp[n_rp].lo = (initial);
                rp[n_rp].hi = (value);
                ++n_rp;
            } while (0);
            field_found = 1;
        }
        value = 0;
    }

....
Skipping error ifguard:Priority 4987
At location src/cut.c:391
--Src File: src/cut.c
Fragment 0:
if (!(__abst_hole(rhs_specified, initial, eol_range_start, field_found, lhs_specified, dash_found, value, in_digits, fieldstr, rp, n_rp, n_rp_allocated, operating_mode, max_range_endpoint, i, printable_field, complement, output_delimiter_specified)))
    if (!rhs_specified) {
        eol_range_start = initial;
        field_found = 1;
    } else {
        if (value < initial)
            do {
                error(0, 0, (gettext("invalid decreasing range")));
                usage(1);
            } while (0);
        if (eol_range_start != 0) {
            if (initial < eol_range_start) {
                if (eol_range_start <= value) {
                    eol_range_start = initial;
                } else {
                    do {
                        if (initial == 0 || value == 0)
                            do {
                                error(0, 0, (gettext("fields and positions are numbered from 1")));
                                usage(1);
                            } while (0);
                        if (n_rp >= n_rp_allocated) {
                            (rp) = x2nrealloc(rp, &n_rp_allocated, sizeof *(rp));
                        }
                        rp[n_rp].lo = (initial);
                        rp[n_rp].hi = (value);
                        ++n_rp;
                    } while (0);
                }
                field_found = 1;
            }
        } else {
            do {
                if (initial == 0 || value == 0)
                    do {
                        error(0, 0, (gettext("fields and positions are numbered from 1")));
                        usage(1);
                    } while (0);
                if (n_rp >= n_rp_allocated) {
                    (rp) = x2nrealloc(rp, &n_rp_allocated, sizeof *(rp));
                }
                rp[n_rp].lo = (initial);
                rp[n_rp].hi = (value);
                ++n_rp;
            } while (0);
            field_found = 1;
        }
        value = 0;
    }

....
Skipping nonlast addifexit:Priority 9988
At location src/cut.c:394
--Src File: src/cut.c
Fragment 0:
if ((__abst_hole(initial, eol_range_start, field_found, rhs_specified, value, lhs_specified, dash_found, in_digits, fieldstr, rp, n_rp, n_rp_allocated, operating_mode, max_range_endpoint, i, printable_field, complement, output_delimiter_specified)))
    break;
eol_range_start = initial;

....
Skipping nonlast addifexit:Priority 3740
At location src/cut.c:447
--Src File: src/cut.c
Fragment 0:
if ((__abst_hole(fieldstr, field_found, value, rp, n_rp, n_rp_allocated, lhs_specified, rhs_specified, initial, in_digits, dash_found, eol_range_start, operating_mode, max_range_endpoint, i, printable_field, complement, output_delimiter_specified)))
    break;
if (*fieldstr == '\x00') {
    break;
}

....
IsErr:priority 4967
at location src/cut.c:456
--src file: src/cut.c
fragment 0:
{
    if (!(__abst_hole(fieldstr, rhs_specified, lhs_specified, in_digits, dash_found, field_found, value, rp, n_rp, n_rp_allocated, operating_mode, initial, max_range_endpoint, i, eol_range_start, printable_field, complement, output_delimiter_specified)))
        if (((unsigned int)(*fieldstr) - '0' <= 9)) {
            static const char *num_start;
            if (!in_digits || !num_start)
                num_start = fieldstr;
            in_digits = 1;
            if (dash_found)
                rhs_specified = 1;
            else
                lhs_specified = 1;
            if (!((void)(&(value) == (size_t *)((void *)0)) , (((size_t)-1 / 10 < (value) || (size_t)((value) * 10 + (*fieldstr - '0')) < (value)) ? 0 : (((value) = (value) * 10 + (*fieldstr - '0')) , 1)))) {
                size_t len = strspn(num_start, "0123456789");
                char *bad_num = xstrndup(num_start, len);
                if (operating_mode == byte_mode)
                    error(0, 0, gettext("byte offset %s is too large"), quote(bad_num));
                else
                    error(0, 0, gettext("field number %s is too large"), quote(bad_num));
                free(bad_num);
                exit(1);
            }
            fieldstr++;
        } else
            do {
                error(0, 0, (gettext("invalid byte or field list")));
                usage(1);
            } while (0);
}

....
Skipping error ifguard:Priority 4967
At location src/cut.c:456
--Src File: src/cut.c
Fragment 0:
{
    if (!(__abst_hole(fieldstr, rhs_specified, lhs_specified, in_digits, dash_found, field_found, value, rp, n_rp, n_rp_allocated, operating_mode, initial, max_range_endpoint, i, eol_range_start, printable_field, complement, output_delimiter_specified)))
        if (((unsigned int)(*fieldstr) - '0' <= 9)) {
            static const char *num_start;
            if (!in_digits || !num_start)
                num_start = fieldstr;
            in_digits = 1;
            if (dash_found)
                rhs_specified = 1;
            else
                lhs_specified = 1;
            if (!((void)(&(value) == (size_t *)((void *)0)) , (((size_t)-1 / 10 < (value) || (size_t)((value) * 10 + (*fieldstr - '0')) < (value)) ? 0 : (((value) = (value) * 10 + (*fieldstr - '0')) , 1)))) {
                size_t len = strspn(num_start, "0123456789");
                char *bad_num = xstrndup(num_start, len);
                if (operating_mode == byte_mode)
                    error(0, 0, gettext("byte offset %s is too large"), quote(bad_num));
                else
                    error(0, 0, gettext("field number %s is too large"), quote(bad_num));
                free(bad_num);
                exit(1);
            }
            fieldstr++;
        } else
            do {
                error(0, 0, (gettext("invalid byte or field list")));
                usage(1);
            } while (0);
}

....
Skipping nonlast addifexit:Priority 3717
At location src/cut.c:456
--Src File: src/cut.c
Fragment 0:
{
    if ((__abst_hole(fieldstr, rhs_specified, lhs_specified, in_digits, dash_found, field_found, value, rp, n_rp, n_rp_allocated, operating_mode, initial, max_range_endpoint, i, eol_range_start, printable_field, complement, output_delimiter_specified)))
        break;
    if (((unsigned int)(*fieldstr) - '0' <= 9)) {
        static const char *num_start;
        if (!in_digits || !num_start)
            num_start = fieldstr;
        in_digits = 1;
        if (dash_found)
            rhs_specified = 1;
        else
            lhs_specified = 1;
        if (!((void)(&(value) == (size_t *)((void *)0)) , (((size_t)-1 / 10 < (value) || (size_t)((value) * 10 + (*fieldstr - '0')) < (value)) ? 0 : (((value) = (value) * 10 + (*fieldstr - '0')) , 1)))) {
            size_t len = strspn(num_start, "0123456789");
            char *bad_num = xstrndup(num_start, len);
            if (operating_mode == byte_mode)
                error(0, 0, gettext("byte offset %s is too large"), quote(bad_num));
            else
                error(0, 0, gettext("field number %s is too large"), quote(bad_num));
            free(bad_num);
            exit(1);
        }
        fieldstr++;
    } else
        do {
            error(0, 0, (gettext("invalid byte or field list")));
            usage(1);
        } while (0);
}

....
Skipping nonlast addifexit:Priority 4968
At location src/cut.c:460
--Src File: src/cut.c
Fragment 0:
if ((__abst_hole(in_digits, fieldstr, dash_found, rhs_specified, lhs_specified, value, field_found, rp, n_rp, n_rp_allocated, operating_mode, initial, max_range_endpoint, i, eol_range_start, printable_field, complement, output_delimiter_specified)))
    break;
static const char *num_start;

....
Skipping nonlast addifexit:Priority 8719
At location src/cut.c:461
--Src File: src/cut.c
Fragment 0:
if ((__abst_hole(in_digits, num_start, fieldstr, dash_found, rhs_specified, lhs_specified, value, field_found, operating_mode, rp, n_rp, n_rp_allocated, initial, max_range_endpoint, i, eol_range_start, printable_field, complement, output_delimiter_specified)))
    break;
if (!in_digits || !num_start)
    num_start = fieldstr;

....
Skipping nonlast addifexit:Priority 4966
At location src/cut.c:462
--Src File: src/cut.c
Fragment 0:
{
    if ((__abst_hole(fieldstr, num_start, in_digits, dash_found, rhs_specified, lhs_specified, value, operating_mode, field_found, rp, n_rp, n_rp_allocated, initial, max_range_endpoint, i, printable_field, eol_range_start, complement, output_delimiter_specified)))
        break;
    num_start = fieldstr;
}

....
Skipping nonlast addifexit:Priority 4970
At location src/cut.c:463
--Src File: src/cut.c
Fragment 0:
if ((__abst_hole(in_digits, fieldstr, num_start, dash_found, rhs_specified, lhs_specified, value, operating_mode, field_found, rp, n_rp, n_rp_allocated, initial, max_range_endpoint, i, printable_field, eol_range_start, complement, output_delimiter_specified)))
    break;
in_digits = 1;

....
Skipping nonlast addifexit:Priority 3721
At location src/cut.c:465
--Src File: src/cut.c
Fragment 0:
if ((__abst_hole(dash_found, rhs_specified, in_digits, fieldstr, lhs_specified, num_start, value, operating_mode, field_found, rp, n_rp, n_rp_allocated, max_range_endpoint, i, initial, printable_field, eol_range_start, complement, output_delimiter_specified)))
    break;
if (dash_found)
    rhs_specified = 1;
else
    lhs_specified = 1;

....
Skipping nonlast addifexit:Priority 4972
At location src/cut.c:468
--Src File: src/cut.c
Fragment 0:
{
    if ((__abst_hole(lhs_specified, rhs_specified, fieldstr, value, dash_found, in_digits, num_start, operating_mode, field_found, rp, n_rp, n_rp_allocated, max_range_endpoint, i, initial, printable_field, complement, output_delimiter_specified, eol_range_start)))
        break;
    lhs_specified = 1;
}

....
IsErr:priority 4973
at location src/cut.c:471
--src file: src/cut.c
fragment 0:
if (!(__abst_hole(fieldstr, value, lhs_specified, rhs_specified, num_start, dash_found, operating_mode, in_digits, max_range_endpoint, n_rp, i, rp, field_found, n_rp_allocated, printable_field, initial, complement, output_delimiter_specified, eol_range_start)))
    if (!((void)(&(value) == (size_t *)((void *)0)) , (((size_t)-1 / 10 < (value) || (size_t)((value) * 10 + (*fieldstr - '0')) < (value)) ? 0 : (((value) = (value) * 10 + (*fieldstr - '0')) , 1)))) {
        size_t len = strspn(num_start, "0123456789");
        char *bad_num = xstrndup(num_start, len);
        if (operating_mode == byte_mode)
            error(0, 0, gettext("byte offset %s is too large"), quote(bad_num));
        else
            error(0, 0, gettext("field number %s is too large"), quote(bad_num));
        free(bad_num);
        exit(1);
    }

....
Skipping error ifguard:Priority 4973
At location src/cut.c:471
--Src File: src/cut.c
Fragment 0:
if (!(__abst_hole(fieldstr, value, lhs_specified, rhs_specified, num_start, dash_found, operating_mode, in_digits, max_range_endpoint, n_rp, i, rp, field_found, n_rp_allocated, printable_field, initial, complement, output_delimiter_specified, eol_range_start)))
    if (!((void)(&(value) == (size_t *)((void *)0)) , (((size_t)-1 / 10 < (value) || (size_t)((value) * 10 + (*fieldstr - '0')) < (value)) ? 0 : (((value) = (value) * 10 + (*fieldstr - '0')) , 1)))) {
        size_t len = strspn(num_start, "0123456789");
        char *bad_num = xstrndup(num_start, len);
        if (operating_mode == byte_mode)
            error(0, 0, gettext("byte offset %s is too large"), quote(bad_num));
        else
            error(0, 0, gettext("field number %s is too large"), quote(bad_num));
        free(bad_num);
        exit(1);
    }

....
Skipping nonlast addifexit:Priority 3723
At location src/cut.c:471
--Src File: src/cut.c
Fragment 0:
if ((__abst_hole(fieldstr, value, lhs_specified, rhs_specified, num_start, dash_found, operating_mode, in_digits, max_range_endpoint, n_rp, i, rp, field_found, n_rp_allocated, printable_field, initial, complement, output_delimiter_specified, eol_range_start)))
    break;
if (!((void)(&(value) == (size_t *)((void *)0)) , (((size_t)-1 / 10 < (value) || (size_t)((value) * 10 + (*fieldstr - '0')) < (value)) ? 0 : (((value) = (value) * 10 + (*fieldstr - '0')) , 1)))) {
    size_t len = strspn(num_start, "0123456789");
    char *bad_num = xstrndup(num_start, len);
    if (operating_mode == byte_mode)
        error(0, 0, gettext("byte offset %s is too large"), quote(bad_num));
    else
        error(0, 0, gettext("field number %s is too large"), quote(bad_num));
    free(bad_num);
    exit(1);
}

....
Skipping nonlast addifexit:Priority 4922
At location src/cut.c:760
--Src File: src/cut.c
Fragment 0:
if ((__abst_hole(argv, operating_mode, suppress_non_delimited, delim, have_read_stdin, argc, output_delimiter_specified, output_delimiter_length, output_delimiter_string, complement)))
    return -1;
int optc;

....
Skipping nonlast addifexit:Priority 4922
At location src/cut.c:760
--Src File: src/cut.c
Fragment 0:
if ((__abst_hole(argv, operating_mode, suppress_non_delimited, delim, have_read_stdin, argc, output_delimiter_specified, output_delimiter_length, output_delimiter_string, complement)))
    return 0;
int optc;

....
Skipping nonlast addifexit:Priority 4922
At location src/cut.c:760
--Src File: src/cut.c
Fragment 0:
if ((__abst_hole(argv, operating_mode, suppress_non_delimited, delim, have_read_stdin, argc, output_delimiter_specified, output_delimiter_length, output_delimiter_string, complement)))
    return 1;
int optc;

....
Skipping nonlast addifexit:Priority 4922
At location src/cut.c:760
--Src File: src/cut.c
Fragment 0:
if ((__abst_hole(argv, operating_mode, suppress_non_delimited, delim, have_read_stdin, argc, output_delimiter_specified, output_delimiter_length, output_delimiter_string, complement)))
    return 2;
int optc;

....
Skipping nonlast addifexit:Priority 4922
At location src/cut.c:760
--Src File: src/cut.c
Fragment 0:
if ((__abst_hole(argv, operating_mode, suppress_non_delimited, delim, have_read_stdin, argc, output_delimiter_specified, output_delimiter_length, output_delimiter_string, complement)))
    return 6;
int optc;

....
Skipping nonlast addifexit:Priority 4923
At location src/cut.c:761
--Src File: src/cut.c
Fragment 0:
if ((__abst_hole(argv, operating_mode, suppress_non_delimited, delim, have_read_stdin, argc, optc, output_delimiter_specified, output_delimiter_length, output_delimiter_string, complement)))
    return -1;
bool ok;

....
Skipping nonlast addifexit:Priority 4923
At location src/cut.c:761
--Src File: src/cut.c
Fragment 0:
if ((__abst_hole(argv, operating_mode, suppress_non_delimited, delim, have_read_stdin, argc, optc, output_delimiter_specified, output_delimiter_length, output_delimiter_string, complement)))
    return 0;
bool ok;

....
Skipping nonlast addifexit:Priority 4923
At location src/cut.c:761
--Src File: src/cut.c
Fragment 0:
if ((__abst_hole(argv, operating_mode, suppress_non_delimited, delim, have_read_stdin, argc, optc, output_delimiter_specified, output_delimiter_length, output_delimiter_string, complement)))
    return 1;
bool ok;

....
Skipping nonlast addifexit:Priority 4923
At location src/cut.c:761
--Src File: src/cut.c
Fragment 0:
if ((__abst_hole(argv, operating_mode, suppress_non_delimited, delim, have_read_stdin, argc, optc, output_delimiter_specified, output_delimiter_length, output_delimiter_string, complement)))
    return 2;
bool ok;

....
Skipping nonlast addifexit:Priority 4923
At location src/cut.c:761
--Src File: src/cut.c
Fragment 0:
if ((__abst_hole(argv, operating_mode, suppress_non_delimited, delim, have_read_stdin, argc, optc, output_delimiter_specified, output_delimiter_length, output_delimiter_string, complement)))
    return 6;
bool ok;

....
Skipping nonlast addifexit:Priority 4924
At location src/cut.c:762
--Src File: src/cut.c
Fragment 0:
if ((__abst_hole(argv, operating_mode, suppress_non_delimited, delim, have_read_stdin, argc, optc, output_delimiter_specified, output_delimiter_length, output_delimiter_string, complement, ok)))
    return -1;
bool delim_specified = 0;

....
Skipping nonlast addifexit:Priority 4924
At location src/cut.c:762
--Src File: src/cut.c
Fragment 0:
if ((__abst_hole(argv, operating_mode, suppress_non_delimited, delim, have_read_stdin, argc, optc, output_delimiter_specified, output_delimiter_length, output_delimiter_string, complement, ok)))
    return 0;
bool delim_specified = 0;

....
Skipping nonlast addifexit:Priority 4924
At location src/cut.c:762
--Src File: src/cut.c
Fragment 0:
if ((__abst_hole(argv, operating_mode, suppress_non_delimited, delim, have_read_stdin, argc, optc, output_delimiter_specified, output_delimiter_length, output_delimiter_string, complement, ok)))
    return 1;
bool delim_specified = 0;

....
Skipping nonlast addifexit:Priority 4924
At location src/cut.c:762
--Src File: src/cut.c
Fragment 0:
if ((__abst_hole(argv, operating_mode, suppress_non_delimited, delim, have_read_stdin, argc, optc, output_delimiter_specified, output_delimiter_length, output_delimiter_string, complement, ok)))
    return 2;
bool delim_specified = 0;

....
Skipping nonlast addifexit:Priority 4924
At location src/cut.c:762
--Src File: src/cut.c
Fragment 0:
if ((__abst_hole(argv, operating_mode, suppress_non_delimited, delim, have_read_stdin, argc, optc, output_delimiter_specified, output_delimiter_length, output_delimiter_string, complement, ok)))
    return 6;
bool delim_specified = 0;

....
Skipping nonlast addifexit:Priority 4925
At location src/cut.c:763
--Src File: src/cut.c
Fragment 0:
if ((__abst_hole(argv, operating_mode, suppress_non_delimited, delim, have_read_stdin, argc, optc, delim_specified, output_delimiter_specified, output_delimiter_length, output_delimiter_string, complement, ok)))
    return -1;
char *spec_list_string;

....
Skipping nonlast addifexit:Priority 4925
At location src/cut.c:763
--Src File: src/cut.c
Fragment 0:
if ((__abst_hole(argv, operating_mode, suppress_non_delimited, delim, have_read_stdin, argc, optc, delim_specified, output_delimiter_specified, output_delimiter_length, output_delimiter_string, complement, ok)))
    return 0;
char *spec_list_string;

....
Skipping nonlast addifexit:Priority 4925
At location src/cut.c:763
--Src File: src/cut.c
Fragment 0:
if ((__abst_hole(argv, operating_mode, suppress_non_delimited, delim, have_read_stdin, argc, optc, delim_specified, output_delimiter_specified, output_delimiter_length, output_delimiter_string, complement, ok)))
    return 1;
char *spec_list_string;

....
Skipping nonlast addifexit:Priority 4925
At location src/cut.c:763
--Src File: src/cut.c
Fragment 0:
if ((__abst_hole(argv, operating_mode, suppress_non_delimited, delim, have_read_stdin, argc, optc, delim_specified, output_delimiter_specified, output_delimiter_length, output_delimiter_string, complement, ok)))
    return 2;
char *spec_list_string;

....
Skipping nonlast addifexit:Priority 4925
At location src/cut.c:763
--Src File: src/cut.c
Fragment 0:
if ((__abst_hole(argv, operating_mode, suppress_non_delimited, delim, have_read_stdin, argc, optc, delim_specified, output_delimiter_specified, output_delimiter_length, output_delimiter_string, complement, ok)))
    return 6;
char *spec_list_string;

....
Skipping nonlast addifexit:Priority 4927
At location src/cut.c:766
--Src File: src/cut.c
Fragment 0:
if ((__abst_hole(argv, operating_mode, suppress_non_delimited, delim, have_read_stdin, argc, optc, spec_list_string, delim_specified, output_delimiter_specified, output_delimiter_length, output_delimiter_string, complement, ok)))
    return -1;
set_program_name(argv[0]);

....
Skipping nonlast addifexit:Priority 4927
At location src/cut.c:766
--Src File: src/cut.c
Fragment 0:
if ((__abst_hole(argv, operating_mode, suppress_non_delimited, delim, have_read_stdin, argc, optc, spec_list_string, delim_specified, output_delimiter_specified, output_delimiter_length, output_delimiter_string, complement, ok)))
    return 0;
set_program_name(argv[0]);

....
Skipping nonlast addifexit:Priority 4927
At location src/cut.c:766
--Src File: src/cut.c
Fragment 0:
if ((__abst_hole(argv, operating_mode, suppress_non_delimited, delim, have_read_stdin, argc, optc, spec_list_string, delim_specified, output_delimiter_specified, output_delimiter_length, output_delimiter_string, complement, ok)))
    return 1;
set_program_name(argv[0]);

....
Skipping nonlast addifexit:Priority 4927
At location src/cut.c:766
--Src File: src/cut.c
Fragment 0:
if ((__abst_hole(argv, operating_mode, suppress_non_delimited, delim, have_read_stdin, argc, optc, spec_list_string, delim_specified, output_delimiter_specified, output_delimiter_length, output_delimiter_string, complement, ok)))
    return 2;
set_program_name(argv[0]);

....
Skipping nonlast addifexit:Priority 4927
At location src/cut.c:766
--Src File: src/cut.c
Fragment 0:
if ((__abst_hole(argv, operating_mode, suppress_non_delimited, delim, have_read_stdin, argc, optc, spec_list_string, delim_specified, output_delimiter_specified, output_delimiter_length, output_delimiter_string, complement, ok)))
    return 6;
set_program_name(argv[0]);

....
Skipping nonlast addifexit:Priority 4928
At location src/cut.c:767
--Src File: src/cut.c
Fragment 0:
if ((__abst_hole(argv, operating_mode, suppress_non_delimited, delim, have_read_stdin, argc, optc, spec_list_string, delim_specified, output_delimiter_specified, output_delimiter_length, output_delimiter_string, complement, ok)))
    return -1;
setlocale(6, "");

....
Skipping nonlast addifexit:Priority 4928
At location src/cut.c:767
--Src File: src/cut.c
Fragment 0:
if ((__abst_hole(argv, operating_mode, suppress_non_delimited, delim, have_read_stdin, argc, optc, spec_list_string, delim_specified, output_delimiter_specified, output_delimiter_length, output_delimiter_string, complement, ok)))
    return 0;
setlocale(6, "");

....
Skipping nonlast addifexit:Priority 4928
At location src/cut.c:767
--Src File: src/cut.c
Fragment 0:
if ((__abst_hole(argv, operating_mode, suppress_non_delimited, delim, have_read_stdin, argc, optc, spec_list_string, delim_specified, output_delimiter_specified, output_delimiter_length, output_delimiter_string, complement, ok)))
    return 1;
setlocale(6, "");

....
Skipping nonlast addifexit:Priority 4928
At location src/cut.c:767
--Src File: src/cut.c
Fragment 0:
if ((__abst_hole(argv, operating_mode, suppress_non_delimited, delim, have_read_stdin, argc, optc, spec_list_string, delim_specified, output_delimiter_specified, output_delimiter_length, output_delimiter_string, complement, ok)))
    return 2;
setlocale(6, "");

....
Skipping nonlast addifexit:Priority 4928
At location src/cut.c:767
--Src File: src/cut.c
Fragment 0:
if ((__abst_hole(argv, operating_mode, suppress_non_delimited, delim, have_read_stdin, argc, optc, spec_list_string, delim_specified, output_delimiter_specified, output_delimiter_length, output_delimiter_string, complement, ok)))
    return 6;
setlocale(6, "");

....
Skipping nonlast addifexit:Priority 4932
At location src/cut.c:773
--Src File: src/cut.c
Fragment 0:
if ((__abst_hole(operating_mode, suppress_non_delimited, delim, have_read_stdin, argv, argc, optc, spec_list_string, delim_specified, output_delimiter_specified, output_delimiter_length, output_delimiter_string, complement, ok)))
    return -1;
operating_mode = undefined_mode;

....
Skipping nonlast addifexit:Priority 4932
At location src/cut.c:773
--Src File: src/cut.c
Fragment 0:
if ((__abst_hole(operating_mode, suppress_non_delimited, delim, have_read_stdin, argv, argc, optc, spec_list_string, delim_specified, output_delimiter_specified, output_delimiter_length, output_delimiter_string, complement, ok)))
    return 0;
operating_mode = undefined_mode;

....
Skipping nonlast addifexit:Priority 4932
At location src/cut.c:773
--Src File: src/cut.c
Fragment 0:
if ((__abst_hole(operating_mode, suppress_non_delimited, delim, have_read_stdin, argv, argc, optc, spec_list_string, delim_specified, output_delimiter_specified, output_delimiter_length, output_delimiter_string, complement, ok)))
    return 1;
operating_mode = undefined_mode;

....
Skipping nonlast addifexit:Priority 4932
At location src/cut.c:773
--Src File: src/cut.c
Fragment 0:
if ((__abst_hole(operating_mode, suppress_non_delimited, delim, have_read_stdin, argv, argc, optc, spec_list_string, delim_specified, output_delimiter_specified, output_delimiter_length, output_delimiter_string, complement, ok)))
    return 2;
operating_mode = undefined_mode;

....
Skipping nonlast addifexit:Priority 4932
At location src/cut.c:773
--Src File: src/cut.c
Fragment 0:
if ((__abst_hole(operating_mode, suppress_non_delimited, delim, have_read_stdin, argv, argc, optc, spec_list_string, delim_specified, output_delimiter_specified, output_delimiter_length, output_delimiter_string, complement, ok)))
    return 6;
operating_mode = undefined_mode;

....
Skipping nonlast addifexit:Priority 4933
At location src/cut.c:776
--Src File: src/cut.c
Fragment 0:
if ((__abst_hole(suppress_non_delimited, delim, operating_mode, have_read_stdin, argc, argv, optc, spec_list_string, delim_specified, output_delimiter_specified, output_delimiter_length, output_delimiter_string, complement, ok)))
    return -1;
suppress_non_delimited = 0;

....
Skipping nonlast addifexit:Priority 4933
At location src/cut.c:776
--Src File: src/cut.c
Fragment 0:
if ((__abst_hole(suppress_non_delimited, delim, operating_mode, have_read_stdin, argc, argv, optc, spec_list_string, delim_specified, output_delimiter_specified, output_delimiter_length, output_delimiter_string, complement, ok)))
    return 0;
suppress_non_delimited = 0;

....
Skipping nonlast addifexit:Priority 4933
At location src/cut.c:776
--Src File: src/cut.c
Fragment 0:
if ((__abst_hole(suppress_non_delimited, delim, operating_mode, have_read_stdin, argc, argv, optc, spec_list_string, delim_specified, output_delimiter_specified, output_delimiter_length, output_delimiter_string, complement, ok)))
    return 1;
suppress_non_delimited = 0;

....
Skipping nonlast addifexit:Priority 4933
At location src/cut.c:776
--Src File: src/cut.c
Fragment 0:
if ((__abst_hole(suppress_non_delimited, delim, operating_mode, have_read_stdin, argc, argv, optc, spec_list_string, delim_specified, output_delimiter_specified, output_delimiter_length, output_delimiter_string, complement, ok)))
    return 2;
suppress_non_delimited = 0;

....
Skipping nonlast addifexit:Priority 4933
At location src/cut.c:776
--Src File: src/cut.c
Fragment 0:
if ((__abst_hole(suppress_non_delimited, delim, operating_mode, have_read_stdin, argc, argv, optc, spec_list_string, delim_specified, output_delimiter_specified, output_delimiter_length, output_delimiter_string, complement, ok)))
    return 6;
suppress_non_delimited = 0;

....
Skipping nonlast addifexit:Priority 4934
At location src/cut.c:778
--Src File: src/cut.c
Fragment 0:
if ((__abst_hole(delim, have_read_stdin, suppress_non_delimited, argc, argv, optc, operating_mode, spec_list_string, delim_specified, output_delimiter_specified, output_delimiter_length, output_delimiter_string, complement, ok)))
    return -1;
delim = '\x00';

....
Skipping nonlast addifexit:Priority 4934
At location src/cut.c:778
--Src File: src/cut.c
Fragment 0:
if ((__abst_hole(delim, have_read_stdin, suppress_non_delimited, argc, argv, optc, operating_mode, spec_list_string, delim_specified, output_delimiter_specified, output_delimiter_length, output_delimiter_string, complement, ok)))
    return 0;
delim = '\x00';

....
Skipping nonlast addifexit:Priority 4934
At location src/cut.c:778
--Src File: src/cut.c
Fragment 0:
if ((__abst_hole(delim, have_read_stdin, suppress_non_delimited, argc, argv, optc, operating_mode, spec_list_string, delim_specified, output_delimiter_specified, output_delimiter_length, output_delimiter_string, complement, ok)))
    return 1;
delim = '\x00';

....
Skipping nonlast addifexit:Priority 4934
At location src/cut.c:778
--Src File: src/cut.c
Fragment 0:
if ((__abst_hole(delim, have_read_stdin, suppress_non_delimited, argc, argv, optc, operating_mode, spec_list_string, delim_specified, output_delimiter_specified, output_delimiter_length, output_delimiter_string, complement, ok)))
    return 2;
delim = '\x00';

....
Skipping nonlast addifexit:Priority 4934
At location src/cut.c:778
--Src File: src/cut.c
Fragment 0:
if ((__abst_hole(delim, have_read_stdin, suppress_non_delimited, argc, argv, optc, operating_mode, spec_list_string, delim_specified, output_delimiter_specified, output_delimiter_length, output_delimiter_string, complement, ok)))
    return 6;
delim = '\x00';

....
Skipping nonlast addifexit:Priority 4935
At location src/cut.c:779
--Src File: src/cut.c
Fragment 0:
if ((__abst_hole(have_read_stdin, delim, argc, argv, optc, suppress_non_delimited, operating_mode, spec_list_string, delim_specified, output_delimiter_specified, output_delimiter_length, output_delimiter_string, complement, ok)))
    return -1;
have_read_stdin = 0;

....
Skipping nonlast addifexit:Priority 4935
At location src/cut.c:779
--Src File: src/cut.c
Fragment 0:
if ((__abst_hole(have_read_stdin, delim, argc, argv, optc, suppress_non_delimited, operating_mode, spec_list_string, delim_specified, output_delimiter_specified, output_delimiter_length, output_delimiter_string, complement, ok)))
    return 0;
have_read_stdin = 0;

....
Skipping nonlast addifexit:Priority 4935
At location src/cut.c:779
--Src File: src/cut.c
Fragment 0:
if ((__abst_hole(have_read_stdin, delim, argc, argv, optc, suppress_non_delimited, operating_mode, spec_list_string, delim_specified, output_delimiter_specified, output_delimiter_length, output_delimiter_string, complement, ok)))
    return 1;
have_read_stdin = 0;

....
Skipping nonlast addifexit:Priority 4935
At location src/cut.c:779
--Src File: src/cut.c
Fragment 0:
if ((__abst_hole(have_read_stdin, delim, argc, argv, optc, suppress_non_delimited, operating_mode, spec_list_string, delim_specified, output_delimiter_specified, output_delimiter_length, output_delimiter_string, complement, ok)))
    return 2;
have_read_stdin = 0;

....
Skipping nonlast addifexit:Priority 4935
At location src/cut.c:779
--Src File: src/cut.c
Fragment 0:
if ((__abst_hole(have_read_stdin, delim, argc, argv, optc, suppress_non_delimited, operating_mode, spec_list_string, delim_specified, output_delimiter_specified, output_delimiter_length, output_delimiter_string, complement, ok)))
    return 6;
have_read_stdin = 0;

....
Skipping nonlast addifexit:Priority 4936
At location src/cut.c:781
--Src File: src/cut.c
Fragment 0:
if ((__abst_hole(argc, argv, optc, have_read_stdin, delim, suppress_non_delimited, operating_mode, spec_list_string, delim_specified, output_delimiter_specified, output_delimiter_length, output_delimiter_string, complement, ok)))
    return -1;
while ((optc = getopt_long(argc, argv, "b:c:d:f:ns", longopts, ((void *)0))) != -1)
    {
        switch (optc) {
          case 'b':
          case 'c':
            if (operating_mode != undefined_mode)
                do {
                    error(0, 0, (gettext("only one type of list may be specified")));
                    usage(1);
                } while (0);
            operating_mode = byte_mode;
            spec_list_string = optarg;
            break;
          case 'f':
            if (operating_mode != undefined_mode)
                do {
                    error(0, 0, (gettext("only one type of list may be specified")));
                    usage(1);
                } while (0);
            operating_mode = field_mode;
            spec_list_string = optarg;
            break;
          case 'd':
            if (optarg[0] != '\x00' && optarg[1] != '\x00')
                do {
                    error(0, 0, (gettext("the delimiter must be a single character")));
                    usage(1);
                } while (0);
            delim = optarg[0];
            delim_specified = 1;
            break;
          case OUTPUT_DELIMITER_OPTION:
            output_delimiter_specified = 1;
            output_delimiter_length = (optarg[0] == '\x00' ? 1 : strlen(optarg));
            output_delimiter_string = xstrdup(optarg);
            break;
          case 'n':
            break;
          case 's':
            suppress_non_delimited = 1;
            break;
          case COMPLEMENT_OPTION:
            complement = 1;
            break;
          case GETOPT_HELP_CHAR:
            usage(0);
            break;
            ;
          case GETOPT_VERSION_CHAR:
            ;
            exit(0);
            break;
            ;
          default:
            usage(1);
        }
    }

....
Skipping nonlast addifexit:Priority 4936
At location src/cut.c:781
--Src File: src/cut.c
Fragment 0:
if ((__abst_hole(argc, argv, optc, have_read_stdin, delim, suppress_non_delimited, operating_mode, spec_list_string, delim_specified, output_delimiter_specified, output_delimiter_length, output_delimiter_string, complement, ok)))
    return 0;
while ((optc = getopt_long(argc, argv, "b:c:d:f:ns", longopts, ((void *)0))) != -1)
    {
        switch (optc) {
          case 'b':
          case 'c':
            if (operating_mode != undefined_mode)
                do {
                    error(0, 0, (gettext("only one type of list may be specified")));
                    usage(1);
                } while (0);
            operating_mode = byte_mode;
            spec_list_string = optarg;
            break;
          case 'f':
            if (operating_mode != undefined_mode)
                do {
                    error(0, 0, (gettext("only one type of list may be specified")));
                    usage(1);
                } while (0);
            operating_mode = field_mode;
            spec_list_string = optarg;
            break;
          case 'd':
            if (optarg[0] != '\x00' && optarg[1] != '\x00')
                do {
                    error(0, 0, (gettext("the delimiter must be a single character")));
                    usage(1);
                } while (0);
            delim = optarg[0];
            delim_specified = 1;
            break;
          case OUTPUT_DELIMITER_OPTION:
            output_delimiter_specified = 1;
            output_delimiter_length = (optarg[0] == '\x00' ? 1 : strlen(optarg));
            output_delimiter_string = xstrdup(optarg);
            break;
          case 'n':
            break;
          case 's':
            suppress_non_delimited = 1;
            break;
          case COMPLEMENT_OPTION:
            complement = 1;
            break;
          case GETOPT_HELP_CHAR:
            usage(0);
            break;
            ;
          case GETOPT_VERSION_CHAR:
            ;
            exit(0);
            break;
            ;
          default:
            usage(1);
        }
    }

....
Skipping nonlast addifexit:Priority 4936
At location src/cut.c:781
--Src File: src/cut.c
Fragment 0:
if ((__abst_hole(argc, argv, optc, have_read_stdin, delim, suppress_non_delimited, operating_mode, spec_list_string, delim_specified, output_delimiter_specified, output_delimiter_length, output_delimiter_string, complement, ok)))
    return 1;
while ((optc = getopt_long(argc, argv, "b:c:d:f:ns", longopts, ((void *)0))) != -1)
    {
        switch (optc) {
          case 'b':
          case 'c':
            if (operating_mode != undefined_mode)
                do {
                    error(0, 0, (gettext("only one type of list may be specified")));
                    usage(1);
                } while (0);
            operating_mode = byte_mode;
            spec_list_string = optarg;
            break;
          case 'f':
            if (operating_mode != undefined_mode)
                do {
                    error(0, 0, (gettext("only one type of list may be specified")));
                    usage(1);
                } while (0);
            operating_mode = field_mode;
            spec_list_string = optarg;
            break;
          case 'd':
            if (optarg[0] != '\x00' && optarg[1] != '\x00')
                do {
                    error(0, 0, (gettext("the delimiter must be a single character")));
                    usage(1);
                } while (0);
            delim = optarg[0];
            delim_specified = 1;
            break;
          case OUTPUT_DELIMITER_OPTION:
            output_delimiter_specified = 1;
            output_delimiter_length = (optarg[0] == '\x00' ? 1 : strlen(optarg));
            output_delimiter_string = xstrdup(optarg);
            break;
          case 'n':
            break;
          case 's':
            suppress_non_delimited = 1;
            break;
          case COMPLEMENT_OPTION:
            complement = 1;
            break;
          case GETOPT_HELP_CHAR:
            usage(0);
            break;
            ;
          case GETOPT_VERSION_CHAR:
            ;
            exit(0);
            break;
            ;
          default:
            usage(1);
        }
    }

....
Skipping nonlast addifexit:Priority 4936
At location src/cut.c:781
--Src File: src/cut.c
Fragment 0:
if ((__abst_hole(argc, argv, optc, have_read_stdin, delim, suppress_non_delimited, operating_mode, spec_list_string, delim_specified, output_delimiter_specified, output_delimiter_length, output_delimiter_string, complement, ok)))
    return 2;
while ((optc = getopt_long(argc, argv, "b:c:d:f:ns", longopts, ((void *)0))) != -1)
    {
        switch (optc) {
          case 'b':
          case 'c':
            if (operating_mode != undefined_mode)
                do {
                    error(0, 0, (gettext("only one type of list may be specified")));
                    usage(1);
                } while (0);
            operating_mode = byte_mode;
            spec_list_string = optarg;
            break;
          case 'f':
            if (operating_mode != undefined_mode)
                do {
                    error(0, 0, (gettext("only one type of list may be specified")));
                    usage(1);
                } while (0);
            operating_mode = field_mode;
            spec_list_string = optarg;
            break;
          case 'd':
            if (optarg[0] != '\x00' && optarg[1] != '\x00')
                do {
                    error(0, 0, (gettext("the delimiter must be a single character")));
                    usage(1);
                } while (0);
            delim = optarg[0];
            delim_specified = 1;
            break;
          case OUTPUT_DELIMITER_OPTION:
            output_delimiter_specified = 1;
            output_delimiter_length = (optarg[0] == '\x00' ? 1 : strlen(optarg));
            output_delimiter_string = xstrdup(optarg);
            break;
          case 'n':
            break;
          case 's':
            suppress_non_delimited = 1;
            break;
          case COMPLEMENT_OPTION:
            complement = 1;
            break;
          case GETOPT_HELP_CHAR:
            usage(0);
            break;
            ;
          case GETOPT_VERSION_CHAR:
            ;
            exit(0);
            break;
            ;
          default:
            usage(1);
        }
    }

....
Skipping nonlast addifexit:Priority 4936
At location src/cut.c:781
--Src File: src/cut.c
Fragment 0:
if ((__abst_hole(argc, argv, optc, have_read_stdin, delim, suppress_non_delimited, operating_mode, spec_list_string, delim_specified, output_delimiter_specified, output_delimiter_length, output_delimiter_string, complement, ok)))
    return 6;
while ((optc = getopt_long(argc, argv, "b:c:d:f:ns", longopts, ((void *)0))) != -1)
    {
        switch (optc) {
          case 'b':
          case 'c':
            if (operating_mode != undefined_mode)
                do {
                    error(0, 0, (gettext("only one type of list may be specified")));
                    usage(1);
                } while (0);
            operating_mode = byte_mode;
            spec_list_string = optarg;
            break;
          case 'f':
            if (operating_mode != undefined_mode)
                do {
                    error(0, 0, (gettext("only one type of list may be specified")));
                    usage(1);
                } while (0);
            operating_mode = field_mode;
            spec_list_string = optarg;
            break;
          case 'd':
            if (optarg[0] != '\x00' && optarg[1] != '\x00')
                do {
                    error(0, 0, (gettext("the delimiter must be a single character")));
                    usage(1);
                } while (0);
            delim = optarg[0];
            delim_specified = 1;
            break;
          case OUTPUT_DELIMITER_OPTION:
            output_delimiter_specified = 1;
            output_delimiter_length = (optarg[0] == '\x00' ? 1 : strlen(optarg));
            output_delimiter_string = xstrdup(optarg);
            break;
          case 'n':
            break;
          case 's':
            suppress_non_delimited = 1;
            break;
          case COMPLEMENT_OPTION:
            complement = 1;
            break;
          case GETOPT_HELP_CHAR:
            usage(0);
            break;
            ;
          case GETOPT_VERSION_CHAR:
            ;
            exit(0);
            break;
            ;
          default:
            usage(1);
        }
    }

....
Skipping isstmt addifexit:Priority 9940
At location src/cut.c:783
--Src File: src/cut.c
Fragment 0:
if ((__abst_hole(optc, argc, argv, have_read_stdin, operating_mode, delim, suppress_non_delimited, spec_list_string, delim_specified, output_delimiter_specified, output_delimiter_length, output_delimiter_string, complement, ok)))
    return -1;
switch (optc) {
  case 'b':
  case 'c':
    if (operating_mode != undefined_mode)
        do {
            error(0, 0, (gettext("only one type of list may be specified")));
            usage(1);
        } while (0);
    operating_mode = byte_mode;
    spec_list_string = optarg;
    break;
  case 'f':
    if (operating_mode != undefined_mode)
        do {
            error(0, 0, (gettext("only one type of list may be specified")));
            usage(1);
        } while (0);
    operating_mode = field_mode;
    spec_list_string = optarg;
    break;
  case 'd':
    if (optarg[0] != '\x00' && optarg[1] != '\x00')
        do {
            error(0, 0, (gettext("the delimiter must be a single character")));
            usage(1);
        } while (0);
    delim = optarg[0];
    delim_specified = 1;
    break;
  case OUTPUT_DELIMITER_OPTION:
    output_delimiter_specified = 1;
    output_delimiter_length = (optarg[0] == '\x00' ? 1 : strlen(optarg));
    output_delimiter_string = xstrdup(optarg);
    break;
  case 'n':
    break;
  case 's':
    suppress_non_delimited = 1;
    break;
  case COMPLEMENT_OPTION:
    complement = 1;
    break;
  case GETOPT_HELP_CHAR:
    usage(0);
    break;
    ;
  case GETOPT_VERSION_CHAR:
    ;
    exit(0);
    break;
    ;
  default:
    usage(1);
}

....
Skipping isstmt addifexit:Priority 9940
At location src/cut.c:783
--Src File: src/cut.c
Fragment 0:
if ((__abst_hole(optc, argc, argv, have_read_stdin, operating_mode, delim, suppress_non_delimited, spec_list_string, delim_specified, output_delimiter_specified, output_delimiter_length, output_delimiter_string, complement, ok)))
    return 0;
switch (optc) {
  case 'b':
  case 'c':
    if (operating_mode != undefined_mode)
        do {
            error(0, 0, (gettext("only one type of list may be specified")));
            usage(1);
        } while (0);
    operating_mode = byte_mode;
    spec_list_string = optarg;
    break;
  case 'f':
    if (operating_mode != undefined_mode)
        do {
            error(0, 0, (gettext("only one type of list may be specified")));
            usage(1);
        } while (0);
    operating_mode = field_mode;
    spec_list_string = optarg;
    break;
  case 'd':
    if (optarg[0] != '\x00' && optarg[1] != '\x00')
        do {
            error(0, 0, (gettext("the delimiter must be a single character")));
            usage(1);
        } while (0);
    delim = optarg[0];
    delim_specified = 1;
    break;
  case OUTPUT_DELIMITER_OPTION:
    output_delimiter_specified = 1;
    output_delimiter_length = (optarg[0] == '\x00' ? 1 : strlen(optarg));
    output_delimiter_string = xstrdup(optarg);
    break;
  case 'n':
    break;
  case 's':
    suppress_non_delimited = 1;
    break;
  case COMPLEMENT_OPTION:
    complement = 1;
    break;
  case GETOPT_HELP_CHAR:
    usage(0);
    break;
    ;
  case GETOPT_VERSION_CHAR:
    ;
    exit(0);
    break;
    ;
  default:
    usage(1);
}

....
Skipping isstmt addifexit:Priority 9940
At location src/cut.c:783
--Src File: src/cut.c
Fragment 0:
if ((__abst_hole(optc, argc, argv, have_read_stdin, operating_mode, delim, suppress_non_delimited, spec_list_string, delim_specified, output_delimiter_specified, output_delimiter_length, output_delimiter_string, complement, ok)))
    return 1;
switch (optc) {
  case 'b':
  case 'c':
    if (operating_mode != undefined_mode)
        do {
            error(0, 0, (gettext("only one type of list may be specified")));
            usage(1);
        } while (0);
    operating_mode = byte_mode;
    spec_list_string = optarg;
    break;
  case 'f':
    if (operating_mode != undefined_mode)
        do {
            error(0, 0, (gettext("only one type of list may be specified")));
            usage(1);
        } while (0);
    operating_mode = field_mode;
    spec_list_string = optarg;
    break;
  case 'd':
    if (optarg[0] != '\x00' && optarg[1] != '\x00')
        do {
            error(0, 0, (gettext("the delimiter must be a single character")));
            usage(1);
        } while (0);
    delim = optarg[0];
    delim_specified = 1;
    break;
  case OUTPUT_DELIMITER_OPTION:
    output_delimiter_specified = 1;
    output_delimiter_length = (optarg[0] == '\x00' ? 1 : strlen(optarg));
    output_delimiter_string = xstrdup(optarg);
    break;
  case 'n':
    break;
  case 's':
    suppress_non_delimited = 1;
    break;
  case COMPLEMENT_OPTION:
    complement = 1;
    break;
  case GETOPT_HELP_CHAR:
    usage(0);
    break;
    ;
  case GETOPT_VERSION_CHAR:
    ;
    exit(0);
    break;
    ;
  default:
    usage(1);
}

....
Skipping isstmt addifexit:Priority 9940
At location src/cut.c:783
--Src File: src/cut.c
Fragment 0:
if ((__abst_hole(optc, argc, argv, have_read_stdin, operating_mode, delim, suppress_non_delimited, spec_list_string, delim_specified, output_delimiter_specified, output_delimiter_length, output_delimiter_string, complement, ok)))
    return 2;
switch (optc) {
  case 'b':
  case 'c':
    if (operating_mode != undefined_mode)
        do {
            error(0, 0, (gettext("only one type of list may be specified")));
            usage(1);
        } while (0);
    operating_mode = byte_mode;
    spec_list_string = optarg;
    break;
  case 'f':
    if (operating_mode != undefined_mode)
        do {
            error(0, 0, (gettext("only one type of list may be specified")));
            usage(1);
        } while (0);
    operating_mode = field_mode;
    spec_list_string = optarg;
    break;
  case 'd':
    if (optarg[0] != '\x00' && optarg[1] != '\x00')
        do {
            error(0, 0, (gettext("the delimiter must be a single character")));
            usage(1);
        } while (0);
    delim = optarg[0];
    delim_specified = 1;
    break;
  case OUTPUT_DELIMITER_OPTION:
    output_delimiter_specified = 1;
    output_delimiter_length = (optarg[0] == '\x00' ? 1 : strlen(optarg));
    output_delimiter_string = xstrdup(optarg);
    break;
  case 'n':
    break;
  case 's':
    suppress_non_delimited = 1;
    break;
  case COMPLEMENT_OPTION:
    complement = 1;
    break;
  case GETOPT_HELP_CHAR:
    usage(0);
    break;
    ;
  case GETOPT_VERSION_CHAR:
    ;
    exit(0);
    break;
    ;
  default:
    usage(1);
}

....
Skipping isstmt addifexit:Priority 9940
At location src/cut.c:783
--Src File: src/cut.c
Fragment 0:
if ((__abst_hole(optc, argc, argv, have_read_stdin, operating_mode, delim, suppress_non_delimited, spec_list_string, delim_specified, output_delimiter_specified, output_delimiter_length, output_delimiter_string, complement, ok)))
    return 6;
switch (optc) {
  case 'b':
  case 'c':
    if (operating_mode != undefined_mode)
        do {
            error(0, 0, (gettext("only one type of list may be specified")));
            usage(1);
        } while (0);
    operating_mode = byte_mode;
    spec_list_string = optarg;
    break;
  case 'f':
    if (operating_mode != undefined_mode)
        do {
            error(0, 0, (gettext("only one type of list may be specified")));
            usage(1);
        } while (0);
    operating_mode = field_mode;
    spec_list_string = optarg;
    break;
  case 'd':
    if (optarg[0] != '\x00' && optarg[1] != '\x00')
        do {
            error(0, 0, (gettext("the delimiter must be a single character")));
            usage(1);
        } while (0);
    delim = optarg[0];
    delim_specified = 1;
    break;
  case OUTPUT_DELIMITER_OPTION:
    output_delimiter_specified = 1;
    output_delimiter_length = (optarg[0] == '\x00' ? 1 : strlen(optarg));
    output_delimiter_string = xstrdup(optarg);
    break;
  case 'n':
    break;
  case 's':
    suppress_non_delimited = 1;
    break;
  case COMPLEMENT_OPTION:
    complement = 1;
    break;
  case GETOPT_HELP_CHAR:
    usage(0);
    break;
    ;
  case GETOPT_VERSION_CHAR:
    ;
    exit(0);
    break;
    ;
  default:
    usage(1);
}

....
Skipping isstmt addifexit:Priority 9940
At location src/cut.c:783
--Src File: src/cut.c
Fragment 0:
if ((__abst_hole(optc, argc, argv, have_read_stdin, operating_mode, delim, suppress_non_delimited, spec_list_string, delim_specified, output_delimiter_specified, output_delimiter_length, output_delimiter_string, complement, ok)))
    break;
switch (optc) {
  case 'b':
  case 'c':
    if (operating_mode != undefined_mode)
        do {
            error(0, 0, (gettext("only one type of list may be specified")));
            usage(1);
        } while (0);
    operating_mode = byte_mode;
    spec_list_string = optarg;
    break;
  case 'f':
    if (operating_mode != undefined_mode)
        do {
            error(0, 0, (gettext("only one type of list may be specified")));
            usage(1);
        } while (0);
    operating_mode = field_mode;
    spec_list_string = optarg;
    break;
  case 'd':
    if (optarg[0] != '\x00' && optarg[1] != '\x00')
        do {
            error(0, 0, (gettext("the delimiter must be a single character")));
            usage(1);
        } while (0);
    delim = optarg[0];
    delim_specified = 1;
    break;
  case OUTPUT_DELIMITER_OPTION:
    output_delimiter_specified = 1;
    output_delimiter_length = (optarg[0] == '\x00' ? 1 : strlen(optarg));
    output_delimiter_string = xstrdup(optarg);
    break;
  case 'n':
    break;
  case 's':
    suppress_non_delimited = 1;
    break;
  case COMPLEMENT_OPTION:
    complement = 1;
    break;
  case GETOPT_HELP_CHAR:
    usage(0);
    break;
    ;
  case GETOPT_VERSION_CHAR:
    ;
    exit(0);
    break;
    ;
  default:
    usage(1);
}

....
Skipping nonlast addifexit:Priority 4942
At location src/cut.c:790
--Src File: src/cut.c
Fragment 0:
if ((__abst_hole(operating_mode, spec_list_string, optc, argc, argv, have_read_stdin, delim, suppress_non_delimited, delim_specified, output_delimiter_specified, output_delimiter_length, output_delimiter_string, complement, ok)))
    return -1;
operating_mode = byte_mode;

....
Skipping nonlast addifexit:Priority 4942
At location src/cut.c:790
--Src File: src/cut.c
Fragment 0:
if ((__abst_hole(operating_mode, spec_list_string, optc, argc, argv, have_read_stdin, delim, suppress_non_delimited, delim_specified, output_delimiter_specified, output_delimiter_length, output_delimiter_string, complement, ok)))
    return 0;
operating_mode = byte_mode;

....
Skipping nonlast addifexit:Priority 4942
At location src/cut.c:790
--Src File: src/cut.c
Fragment 0:
if ((__abst_hole(operating_mode, spec_list_string, optc, argc, argv, have_read_stdin, delim, suppress_non_delimited, delim_specified, output_delimiter_specified, output_delimiter_length, output_delimiter_string, complement, ok)))
    return 1;
operating_mode = byte_mode;

....
Skipping nonlast addifexit:Priority 4942
At location src/cut.c:790
--Src File: src/cut.c
Fragment 0:
if ((__abst_hole(operating_mode, spec_list_string, optc, argc, argv, have_read_stdin, delim, suppress_non_delimited, delim_specified, output_delimiter_specified, output_delimiter_length, output_delimiter_string, complement, ok)))
    return 2;
operating_mode = byte_mode;

....
Skipping nonlast addifexit:Priority 4942
At location src/cut.c:790
--Src File: src/cut.c
Fragment 0:
if ((__abst_hole(operating_mode, spec_list_string, optc, argc, argv, have_read_stdin, delim, suppress_non_delimited, delim_specified, output_delimiter_specified, output_delimiter_length, output_delimiter_string, complement, ok)))
    return 6;
operating_mode = byte_mode;

....
Skipping nonlast addifexit:Priority 4942
At location src/cut.c:790
--Src File: src/cut.c
Fragment 0:
if ((__abst_hole(operating_mode, spec_list_string, optc, argc, argv, have_read_stdin, delim, suppress_non_delimited, delim_specified, output_delimiter_specified, output_delimiter_length, output_delimiter_string, complement, ok)))
    break;
operating_mode = byte_mode;

....
Skipping nonlast addifexit:Priority 4944
At location src/cut.c:791
--Src File: src/cut.c
Fragment 0:
if ((__abst_hole(spec_list_string, operating_mode, optc, argc, argv, have_read_stdin, delim, suppress_non_delimited, delim_specified, output_delimiter_specified, output_delimiter_length, output_delimiter_string, complement, ok)))
    return -1;
spec_list_string = optarg;

....
Skipping nonlast addifexit:Priority 4944
At location src/cut.c:791
--Src File: src/cut.c
Fragment 0:
if ((__abst_hole(spec_list_string, operating_mode, optc, argc, argv, have_read_stdin, delim, suppress_non_delimited, delim_specified, output_delimiter_specified, output_delimiter_length, output_delimiter_string, complement, ok)))
    return 0;
spec_list_string = optarg;

....
Skipping nonlast addifexit:Priority 4944
At location src/cut.c:791
--Src File: src/cut.c
Fragment 0:
if ((__abst_hole(spec_list_string, operating_mode, optc, argc, argv, have_read_stdin, delim, suppress_non_delimited, delim_specified, output_delimiter_specified, output_delimiter_length, output_delimiter_string, complement, ok)))
    return 1;
spec_list_string = optarg;

....
Skipping nonlast addifexit:Priority 4944
At location src/cut.c:791
--Src File: src/cut.c
Fragment 0:
if ((__abst_hole(spec_list_string, operating_mode, optc, argc, argv, have_read_stdin, delim, suppress_non_delimited, delim_specified, output_delimiter_specified, output_delimiter_length, output_delimiter_string, complement, ok)))
    return 2;
spec_list_string = optarg;

....
Skipping nonlast addifexit:Priority 4944
At location src/cut.c:791
--Src File: src/cut.c
Fragment 0:
if ((__abst_hole(spec_list_string, operating_mode, optc, argc, argv, have_read_stdin, delim, suppress_non_delimited, delim_specified, output_delimiter_specified, output_delimiter_length, output_delimiter_string, complement, ok)))
    return 6;
spec_list_string = optarg;

....
Skipping nonlast addifexit:Priority 4944
At location src/cut.c:791
--Src File: src/cut.c
Fragment 0:
if ((__abst_hole(spec_list_string, operating_mode, optc, argc, argv, have_read_stdin, delim, suppress_non_delimited, delim_specified, output_delimiter_specified, output_delimiter_length, output_delimiter_string, complement, ok)))
    break;
spec_list_string = optarg;

....
Skipping nonlast addifexit:Priority 4946
At location src/cut.c:792
--Src File: src/cut.c
Fragment 0:
if ((__abst_hole(spec_list_string, operating_mode, optc, argc, argv, have_read_stdin, delim, delim_specified, suppress_non_delimited, output_delimiter_specified, output_delimiter_length, output_delimiter_string, complement, ok)))
    return -1;
break;

....
Skipping nonlast addifexit:Priority 4946
At location src/cut.c:792
--Src File: src/cut.c
Fragment 0:
if ((__abst_hole(spec_list_string, operating_mode, optc, argc, argv, have_read_stdin, delim, delim_specified, suppress_non_delimited, output_delimiter_specified, output_delimiter_length, output_delimiter_string, complement, ok)))
    return 0;
break;

....
Skipping nonlast addifexit:Priority 4946
At location src/cut.c:792
--Src File: src/cut.c
Fragment 0:
if ((__abst_hole(spec_list_string, operating_mode, optc, argc, argv, have_read_stdin, delim, delim_specified, suppress_non_delimited, output_delimiter_specified, output_delimiter_length, output_delimiter_string, complement, ok)))
    return 1;
break;

....
Skipping nonlast addifexit:Priority 4946
At location src/cut.c:792
--Src File: src/cut.c
Fragment 0:
if ((__abst_hole(spec_list_string, operating_mode, optc, argc, argv, have_read_stdin, delim, delim_specified, suppress_non_delimited, output_delimiter_specified, output_delimiter_length, output_delimiter_string, complement, ok)))
    return 2;
break;

....
Skipping nonlast addifexit:Priority 4946
At location src/cut.c:792
--Src File: src/cut.c
Fragment 0:
if ((__abst_hole(spec_list_string, operating_mode, optc, argc, argv, have_read_stdin, delim, delim_specified, suppress_non_delimited, output_delimiter_specified, output_delimiter_length, output_delimiter_string, complement, ok)))
    return 6;
break;

....
Skipping nonlast addifexit:Priority 4946
At location src/cut.c:792
--Src File: src/cut.c
Fragment 0:
if ((__abst_hole(spec_list_string, operating_mode, optc, argc, argv, have_read_stdin, delim, delim_specified, suppress_non_delimited, output_delimiter_specified, output_delimiter_length, output_delimiter_string, complement, ok)))
    break;
break;

....
Skipping nonlast addifexit:Priority 4941
At location src/cut.c:798
--Src File: src/cut.c
Fragment 0:
if ((__abst_hole(operating_mode, spec_list_string, delim, delim_specified, output_delimiter_specified, optc, argc, argv, output_delimiter_length, output_delimiter_string, have_read_stdin, suppress_non_delimited, complement, ok)))
    return -1;
operating_mode = field_mode;

....
Skipping nonlast addifexit:Priority 4941
At location src/cut.c:798
--Src File: src/cut.c
Fragment 0:
if ((__abst_hole(operating_mode, spec_list_string, delim, delim_specified, output_delimiter_specified, optc, argc, argv, output_delimiter_length, output_delimiter_string, have_read_stdin, suppress_non_delimited, complement, ok)))
    return 0;
operating_mode = field_mode;

....
Skipping nonlast addifexit:Priority 4941
At location src/cut.c:798
--Src File: src/cut.c
Fragment 0:
if ((__abst_hole(operating_mode, spec_list_string, delim, delim_specified, output_delimiter_specified, optc, argc, argv, output_delimiter_length, output_delimiter_string, have_read_stdin, suppress_non_delimited, complement, ok)))
    return 1;
operating_mode = field_mode;

....
Skipping nonlast addifexit:Priority 4941
At location src/cut.c:798
--Src File: src/cut.c
Fragment 0:
if ((__abst_hole(operating_mode, spec_list_string, delim, delim_specified, output_delimiter_specified, optc, argc, argv, output_delimiter_length, output_delimiter_string, have_read_stdin, suppress_non_delimited, complement, ok)))
    return 2;
operating_mode = field_mode;

....
Skipping nonlast addifexit:Priority 4941
At location src/cut.c:798
--Src File: src/cut.c
Fragment 0:
if ((__abst_hole(operating_mode, spec_list_string, delim, delim_specified, output_delimiter_specified, optc, argc, argv, output_delimiter_length, output_delimiter_string, have_read_stdin, suppress_non_delimited, complement, ok)))
    return 6;
operating_mode = field_mode;

....
Skipping nonlast addifexit:Priority 4941
At location src/cut.c:798
--Src File: src/cut.c
Fragment 0:
if ((__abst_hole(operating_mode, spec_list_string, delim, delim_specified, output_delimiter_specified, optc, argc, argv, output_delimiter_length, output_delimiter_string, have_read_stdin, suppress_non_delimited, complement, ok)))
    break;
operating_mode = field_mode;

....
Skipping nonlast addifexit:Priority 4943
At location src/cut.c:799
--Src File: src/cut.c
Fragment 0:
if ((__abst_hole(spec_list_string, operating_mode, delim, delim_specified, output_delimiter_specified, optc, output_delimiter_length, argc, argv, output_delimiter_string, have_read_stdin, suppress_non_delimited, complement, ok)))
    return -1;
spec_list_string = optarg;

....
Skipping nonlast addifexit:Priority 4943
At location src/cut.c:799
--Src File: src/cut.c
Fragment 0:
if ((__abst_hole(spec_list_string, operating_mode, delim, delim_specified, output_delimiter_specified, optc, output_delimiter_length, argc, argv, output_delimiter_string, have_read_stdin, suppress_non_delimited, complement, ok)))
    return 0;
spec_list_string = optarg;

....
Skipping nonlast addifexit:Priority 4943
At location src/cut.c:799
--Src File: src/cut.c
Fragment 0:
if ((__abst_hole(spec_list_string, operating_mode, delim, delim_specified, output_delimiter_specified, optc, output_delimiter_length, argc, argv, output_delimiter_string, have_read_stdin, suppress_non_delimited, complement, ok)))
    return 1;
spec_list_string = optarg;

....
Skipping nonlast addifexit:Priority 4943
At location src/cut.c:799
--Src File: src/cut.c
Fragment 0:
if ((__abst_hole(spec_list_string, operating_mode, delim, delim_specified, output_delimiter_specified, optc, output_delimiter_length, argc, argv, output_delimiter_string, have_read_stdin, suppress_non_delimited, complement, ok)))
    return 2;
spec_list_string = optarg;

....
Skipping nonlast addifexit:Priority 4943
At location src/cut.c:799
--Src File: src/cut.c
Fragment 0:
if ((__abst_hole(spec_list_string, operating_mode, delim, delim_specified, output_delimiter_specified, optc, output_delimiter_length, argc, argv, output_delimiter_string, have_read_stdin, suppress_non_delimited, complement, ok)))
    return 6;
spec_list_string = optarg;

....
Skipping nonlast addifexit:Priority 4943
At location src/cut.c:799
--Src File: src/cut.c
Fragment 0:
if ((__abst_hole(spec_list_string, operating_mode, delim, delim_specified, output_delimiter_specified, optc, output_delimiter_length, argc, argv, output_delimiter_string, have_read_stdin, suppress_non_delimited, complement, ok)))
    break;
spec_list_string = optarg;

....
Skipping nonlast addifexit:Priority 4945
At location src/cut.c:800
--Src File: src/cut.c
Fragment 0:
if ((__abst_hole(spec_list_string, operating_mode, delim, delim_specified, output_delimiter_specified, output_delimiter_length, optc, output_delimiter_string, argc, argv, have_read_stdin, suppress_non_delimited, complement, ok)))
    return -1;
break;

....
Skipping nonlast addifexit:Priority 4945
At location src/cut.c:800
--Src File: src/cut.c
Fragment 0:
if ((__abst_hole(spec_list_string, operating_mode, delim, delim_specified, output_delimiter_specified, output_delimiter_length, optc, output_delimiter_string, argc, argv, have_read_stdin, suppress_non_delimited, complement, ok)))
    return 0;
break;

....
Skipping nonlast addifexit:Priority 4945
At location src/cut.c:800
--Src File: src/cut.c
Fragment 0:
if ((__abst_hole(spec_list_string, operating_mode, delim, delim_specified, output_delimiter_specified, output_delimiter_length, optc, output_delimiter_string, argc, argv, have_read_stdin, suppress_non_delimited, complement, ok)))
    return 1;
break;

....
Skipping nonlast addifexit:Priority 4945
At location src/cut.c:800
--Src File: src/cut.c
Fragment 0:
if ((__abst_hole(spec_list_string, operating_mode, delim, delim_specified, output_delimiter_specified, output_delimiter_length, optc, output_delimiter_string, argc, argv, have_read_stdin, suppress_non_delimited, complement, ok)))
    return 2;
break;

....
Skipping nonlast addifexit:Priority 4945
At location src/cut.c:800
--Src File: src/cut.c
Fragment 0:
if ((__abst_hole(spec_list_string, operating_mode, delim, delim_specified, output_delimiter_specified, output_delimiter_length, optc, output_delimiter_string, argc, argv, have_read_stdin, suppress_non_delimited, complement, ok)))
    return 6;
break;

....
Skipping nonlast addifexit:Priority 4945
At location src/cut.c:800
--Src File: src/cut.c
Fragment 0:
if ((__abst_hole(spec_list_string, operating_mode, delim, delim_specified, output_delimiter_specified, output_delimiter_length, optc, output_delimiter_string, argc, argv, have_read_stdin, suppress_non_delimited, complement, ok)))
    break;
break;

....
Skipping nonlast addifexit:Priority 4937
At location src/cut.c:815
--Src File: src/cut.c
Fragment 0:
if ((__abst_hole(output_delimiter_length, output_delimiter_string, output_delimiter_specified, delim_specified, delim, suppress_non_delimited, complement, spec_list_string, operating_mode, optc, argc, argv, have_read_stdin, ok)))
    return -1;
output_delimiter_length = (optarg[0] == '\x00' ? 1 : strlen(optarg));

....
Skipping nonlast addifexit:Priority 4937
At location src/cut.c:815
--Src File: src/cut.c
Fragment 0:
if ((__abst_hole(output_delimiter_length, output_delimiter_string, output_delimiter_specified, delim_specified, delim, suppress_non_delimited, complement, spec_list_string, operating_mode, optc, argc, argv, have_read_stdin, ok)))
    return 0;
output_delimiter_length = (optarg[0] == '\x00' ? 1 : strlen(optarg));

....
Skipping nonlast addifexit:Priority 4937
At location src/cut.c:815
--Src File: src/cut.c
Fragment 0:
if ((__abst_hole(output_delimiter_length, output_delimiter_string, output_delimiter_specified, delim_specified, delim, suppress_non_delimited, complement, spec_list_string, operating_mode, optc, argc, argv, have_read_stdin, ok)))
    return 1;
output_delimiter_length = (optarg[0] == '\x00' ? 1 : strlen(optarg));

....
Skipping nonlast addifexit:Priority 4937
At location src/cut.c:815
--Src File: src/cut.c
Fragment 0:
if ((__abst_hole(output_delimiter_length, output_delimiter_string, output_delimiter_specified, delim_specified, delim, suppress_non_delimited, complement, spec_list_string, operating_mode, optc, argc, argv, have_read_stdin, ok)))
    return 2;
output_delimiter_length = (optarg[0] == '\x00' ? 1 : strlen(optarg));

....
Skipping nonlast addifexit:Priority 4937
At location src/cut.c:815
--Src File: src/cut.c
Fragment 0:
if ((__abst_hole(output_delimiter_length, output_delimiter_string, output_delimiter_specified, delim_specified, delim, suppress_non_delimited, complement, spec_list_string, operating_mode, optc, argc, argv, have_read_stdin, ok)))
    return 6;
output_delimiter_length = (optarg[0] == '\x00' ? 1 : strlen(optarg));

....
Skipping nonlast addifexit:Priority 4937
At location src/cut.c:815
--Src File: src/cut.c
Fragment 0:
if ((__abst_hole(output_delimiter_length, output_delimiter_string, output_delimiter_specified, delim_specified, delim, suppress_non_delimited, complement, spec_list_string, operating_mode, optc, argc, argv, have_read_stdin, ok)))
    break;
output_delimiter_length = (optarg[0] == '\x00' ? 1 : strlen(optarg));

....
Skipping nonlast addifexit:Priority 4938
At location src/cut.c:817
--Src File: src/cut.c
Fragment 0:
if ((__abst_hole(output_delimiter_string, output_delimiter_length, output_delimiter_specified, suppress_non_delimited, delim_specified, delim, complement, spec_list_string, operating_mode, optc, argc, argv, have_read_stdin, ok)))
    return -1;
output_delimiter_string = xstrdup(optarg);

....
Skipping nonlast addifexit:Priority 4938
At location src/cut.c:817
--Src File: src/cut.c
Fragment 0:
if ((__abst_hole(output_delimiter_string, output_delimiter_length, output_delimiter_specified, suppress_non_delimited, delim_specified, delim, complement, spec_list_string, operating_mode, optc, argc, argv, have_read_stdin, ok)))
    return 0;
output_delimiter_string = xstrdup(optarg);

....
Skipping nonlast addifexit:Priority 4938
At location src/cut.c:817
--Src File: src/cut.c
Fragment 0:
if ((__abst_hole(output_delimiter_string, output_delimiter_length, output_delimiter_specified, suppress_non_delimited, delim_specified, delim, complement, spec_list_string, operating_mode, optc, argc, argv, have_read_stdin, ok)))
    return 1;
output_delimiter_string = xstrdup(optarg);

....
Skipping nonlast addifexit:Priority 4938
At location src/cut.c:817
--Src File: src/cut.c
Fragment 0:
if ((__abst_hole(output_delimiter_string, output_delimiter_length, output_delimiter_specified, suppress_non_delimited, delim_specified, delim, complement, spec_list_string, operating_mode, optc, argc, argv, have_read_stdin, ok)))
    return 2;
output_delimiter_string = xstrdup(optarg);

....
Skipping nonlast addifexit:Priority 4938
At location src/cut.c:817
--Src File: src/cut.c
Fragment 0:
if ((__abst_hole(output_delimiter_string, output_delimiter_length, output_delimiter_specified, suppress_non_delimited, delim_specified, delim, complement, spec_list_string, operating_mode, optc, argc, argv, have_read_stdin, ok)))
    return 6;
output_delimiter_string = xstrdup(optarg);

....
Skipping nonlast addifexit:Priority 4938
At location src/cut.c:817
--Src File: src/cut.c
Fragment 0:
if ((__abst_hole(output_delimiter_string, output_delimiter_length, output_delimiter_specified, suppress_non_delimited, delim_specified, delim, complement, spec_list_string, operating_mode, optc, argc, argv, have_read_stdin, ok)))
    break;
output_delimiter_string = xstrdup(optarg);

....
Skipping nonlast addifexit:Priority 4939
At location src/cut.c:818
--Src File: src/cut.c
Fragment 0:
if ((__abst_hole(output_delimiter_string, output_delimiter_length, suppress_non_delimited, output_delimiter_specified, delim_specified, complement, delim, spec_list_string, operating_mode, optc, argc, argv, have_read_stdin, ok)))
    return -1;
break;

....
Skipping nonlast addifexit:Priority 4939
At location src/cut.c:818
--Src File: src/cut.c
Fragment 0:
if ((__abst_hole(output_delimiter_string, output_delimiter_length, suppress_non_delimited, output_delimiter_specified, delim_specified, complement, delim, spec_list_string, operating_mode, optc, argc, argv, have_read_stdin, ok)))
    return 0;
break;

....
Skipping nonlast addifexit:Priority 4939
At location src/cut.c:818
--Src File: src/cut.c
Fragment 0:
if ((__abst_hole(output_delimiter_string, output_delimiter_length, suppress_non_delimited, output_delimiter_specified, delim_specified, complement, delim, spec_list_string, operating_mode, optc, argc, argv, have_read_stdin, ok)))
    return 1;
break;

....
Skipping nonlast addifexit:Priority 4939
At location src/cut.c:818
--Src File: src/cut.c
Fragment 0:
if ((__abst_hole(output_delimiter_string, output_delimiter_length, suppress_non_delimited, output_delimiter_specified, delim_specified, complement, delim, spec_list_string, operating_mode, optc, argc, argv, have_read_stdin, ok)))
    return 2;
break;

....
Skipping nonlast addifexit:Priority 4939
At location src/cut.c:818
--Src File: src/cut.c
Fragment 0:
if ((__abst_hole(output_delimiter_string, output_delimiter_length, suppress_non_delimited, output_delimiter_specified, delim_specified, complement, delim, spec_list_string, operating_mode, optc, argc, argv, have_read_stdin, ok)))
    return 6;
break;

....
Skipping nonlast addifexit:Priority 4939
At location src/cut.c:818
--Src File: src/cut.c
Fragment 0:
if ((__abst_hole(output_delimiter_string, output_delimiter_length, suppress_non_delimited, output_delimiter_specified, delim_specified, complement, delim, spec_list_string, operating_mode, optc, argc, argv, have_read_stdin, ok)))
    break;
break;

....
IsErr:priority 4947
at location src/cut.c:840
--src file: src/cut.c
fragment 0:
if (!(__abst_hole(operating_mode, delim, suppress_non_delimited, output_delimiter_specified, complement, spec_list_string, output_delimiter_string, output_delimiter_length, delim_specified, argc, ok, argv, have_read_stdin, optc)))
    if (operating_mode == undefined_mode)
        do {
            error(0, 0, (gettext("you must specify a list of bytes, characters, or fields")));
            usage(1);
        } while (0);

....
Skipping error ifguard:Priority 4947
At location src/cut.c:840
--Src File: src/cut.c
Fragment 0:
if (!(__abst_hole(operating_mode, delim, suppress_non_delimited, output_delimiter_specified, complement, spec_list_string, output_delimiter_string, output_delimiter_length, delim_specified, argc, ok, argv, have_read_stdin, optc)))
    if (operating_mode == undefined_mode)
        do {
            error(0, 0, (gettext("you must specify a list of bytes, characters, or fields")));
            usage(1);
        } while (0);

....
Skipping nonlast addifexit:Priority 3697
At location src/cut.c:840
--Src File: src/cut.c
Fragment 0:
if ((__abst_hole(operating_mode, delim, suppress_non_delimited, output_delimiter_specified, complement, spec_list_string, output_delimiter_string, output_delimiter_length, delim_specified, argc, ok, argv, have_read_stdin, optc)))
    return -1;
if (operating_mode == undefined_mode)
    do {
        error(0, 0, (gettext("you must specify a list of bytes, characters, or fields")));
        usage(1);
    } while (0);

....
Skipping nonlast addifexit:Priority 3697
At location src/cut.c:840
--Src File: src/cut.c
Fragment 0:
if ((__abst_hole(operating_mode, delim, suppress_non_delimited, output_delimiter_specified, complement, spec_list_string, output_delimiter_string, output_delimiter_length, delim_specified, argc, ok, argv, have_read_stdin, optc)))
    return 0;
if (operating_mode == undefined_mode)
    do {
        error(0, 0, (gettext("you must specify a list of bytes, characters, or fields")));
        usage(1);
    } while (0);

....
Skipping nonlast addifexit:Priority 3697
At location src/cut.c:840
--Src File: src/cut.c
Fragment 0:
if ((__abst_hole(operating_mode, delim, suppress_non_delimited, output_delimiter_specified, complement, spec_list_string, output_delimiter_string, output_delimiter_length, delim_specified, argc, ok, argv, have_read_stdin, optc)))
    return 1;
if (operating_mode == undefined_mode)
    do {
        error(0, 0, (gettext("you must specify a list of bytes, characters, or fields")));
        usage(1);
    } while (0);

....
Skipping nonlast addifexit:Priority 3697
At location src/cut.c:840
--Src File: src/cut.c
Fragment 0:
if ((__abst_hole(operating_mode, delim, suppress_non_delimited, output_delimiter_specified, complement, spec_list_string, output_delimiter_string, output_delimiter_length, delim_specified, argc, ok, argv, have_read_stdin, optc)))
    return 2;
if (operating_mode == undefined_mode)
    do {
        error(0, 0, (gettext("you must specify a list of bytes, characters, or fields")));
        usage(1);
    } while (0);

....
Skipping nonlast addifexit:Priority 3697
At location src/cut.c:840
--Src File: src/cut.c
Fragment 0:
if ((__abst_hole(operating_mode, delim, suppress_non_delimited, output_delimiter_specified, complement, spec_list_string, output_delimiter_string, output_delimiter_length, delim_specified, argc, ok, argv, have_read_stdin, optc)))
    return 6;
if (operating_mode == undefined_mode)
    do {
        error(0, 0, (gettext("you must specify a list of bytes, characters, or fields")));
        usage(1);
    } while (0);

....
IsErr:priority 4948
at location src/cut.c:843
--src file: src/cut.c
fragment 0:
if (!(__abst_hole(operating_mode, delim, suppress_non_delimited, output_delimiter_specified, complement, spec_list_string, delim_specified, output_delimiter_string, output_delimiter_length, argc, ok, argv, have_read_stdin, optc)))
    if (delim != '\x00' && operating_mode != field_mode)
        do {
            error(0, 0, (gettext("an input delimiter may be specified only when operating on fields")));
            usage(1);
        } while (0);

....
Skipping error ifguard:Priority 4948
At location src/cut.c:843
--Src File: src/cut.c
Fragment 0:
if (!(__abst_hole(operating_mode, delim, suppress_non_delimited, output_delimiter_specified, complement, spec_list_string, delim_specified, output_delimiter_string, output_delimiter_length, argc, ok, argv, have_read_stdin, optc)))
    if (delim != '\x00' && operating_mode != field_mode)
        do {
            error(0, 0, (gettext("an input delimiter may be specified only when operating on fields")));
            usage(1);
        } while (0);

....
Skipping nonlast addifexit:Priority 3698
At location src/cut.c:843
--Src File: src/cut.c
Fragment 0:
if ((__abst_hole(operating_mode, delim, suppress_non_delimited, output_delimiter_specified, complement, spec_list_string, delim_specified, output_delimiter_string, output_delimiter_length, argc, ok, argv, have_read_stdin, optc)))
    return -1;
if (delim != '\x00' && operating_mode != field_mode)
    do {
        error(0, 0, (gettext("an input delimiter may be specified only when operating on fields")));
        usage(1);
    } while (0);

....
Skipping nonlast addifexit:Priority 3698
At location src/cut.c:843
--Src File: src/cut.c
Fragment 0:
if ((__abst_hole(operating_mode, delim, suppress_non_delimited, output_delimiter_specified, complement, spec_list_string, delim_specified, output_delimiter_string, output_delimiter_length, argc, ok, argv, have_read_stdin, optc)))
    return 0;
if (delim != '\x00' && operating_mode != field_mode)
    do {
        error(0, 0, (gettext("an input delimiter may be specified only when operating on fields")));
        usage(1);
    } while (0);

....
Skipping nonlast addifexit:Priority 3698
At location src/cut.c:843
--Src File: src/cut.c
Fragment 0:
if ((__abst_hole(operating_mode, delim, suppress_non_delimited, output_delimiter_specified, complement, spec_list_string, delim_specified, output_delimiter_string, output_delimiter_length, argc, ok, argv, have_read_stdin, optc)))
    return 1;
if (delim != '\x00' && operating_mode != field_mode)
    do {
        error(0, 0, (gettext("an input delimiter may be specified only when operating on fields")));
        usage(1);
    } while (0);

....
Skipping nonlast addifexit:Priority 3698
At location src/cut.c:843
--Src File: src/cut.c
Fragment 0:
if ((__abst_hole(operating_mode, delim, suppress_non_delimited, output_delimiter_specified, complement, spec_list_string, delim_specified, output_delimiter_string, output_delimiter_length, argc, ok, argv, have_read_stdin, optc)))
    return 2;
if (delim != '\x00' && operating_mode != field_mode)
    do {
        error(0, 0, (gettext("an input delimiter may be specified only when operating on fields")));
        usage(1);
    } while (0);

....
Skipping nonlast addifexit:Priority 3698
At location src/cut.c:843
--Src File: src/cut.c
Fragment 0:
if ((__abst_hole(operating_mode, delim, suppress_non_delimited, output_delimiter_specified, complement, spec_list_string, delim_specified, output_delimiter_string, output_delimiter_length, argc, ok, argv, have_read_stdin, optc)))
    return 6;
if (delim != '\x00' && operating_mode != field_mode)
    do {
        error(0, 0, (gettext("an input delimiter may be specified only when operating on fields")));
        usage(1);
    } while (0);

....
IsErr:priority 4949
at location src/cut.c:847
--src file: src/cut.c
fragment 0:
if (!(__abst_hole(operating_mode, suppress_non_delimited, delim, output_delimiter_specified, spec_list_string, complement, delim_specified, output_delimiter_string, output_delimiter_length, argc, ok, argv, have_read_stdin, optc)))
    if (suppress_non_delimited && operating_mode != field_mode)
        do {
            error(0, 0, (gettext("suppressing non-delimited lines makes sense\n\tonly when operating on fields")));
            usage(1);
        } while (0);

....
Skipping error ifguard:Priority 4949
At location src/cut.c:847
--Src File: src/cut.c
Fragment 0:
if (!(__abst_hole(operating_mode, suppress_non_delimited, delim, output_delimiter_specified, spec_list_string, complement, delim_specified, output_delimiter_string, output_delimiter_length, argc, ok, argv, have_read_stdin, optc)))
    if (suppress_non_delimited && operating_mode != field_mode)
        do {
            error(0, 0, (gettext("suppressing non-delimited lines makes sense\n\tonly when operating on fields")));
            usage(1);
        } while (0);

....
Skipping nonlast addifexit:Priority 3699
At location src/cut.c:847
--Src File: src/cut.c
Fragment 0:
if ((__abst_hole(operating_mode, suppress_non_delimited, delim, output_delimiter_specified, spec_list_string, complement, delim_specified, output_delimiter_string, output_delimiter_length, argc, ok, argv, have_read_stdin, optc)))
    return -1;
if (suppress_non_delimited && operating_mode != field_mode)
    do {
        error(0, 0, (gettext("suppressing non-delimited lines makes sense\n\tonly when operating on fields")));
        usage(1);
    } while (0);

....
Skipping nonlast addifexit:Priority 3699
At location src/cut.c:847
--Src File: src/cut.c
Fragment 0:
if ((__abst_hole(operating_mode, suppress_non_delimited, delim, output_delimiter_specified, spec_list_string, complement, delim_specified, output_delimiter_string, output_delimiter_length, argc, ok, argv, have_read_stdin, optc)))
    return 0;
if (suppress_non_delimited && operating_mode != field_mode)
    do {
        error(0, 0, (gettext("suppressing non-delimited lines makes sense\n\tonly when operating on fields")));
        usage(1);
    } while (0);

....
Skipping nonlast addifexit:Priority 3699
At location src/cut.c:847
--Src File: src/cut.c
Fragment 0:
if ((__abst_hole(operating_mode, suppress_non_delimited, delim, output_delimiter_specified, spec_list_string, complement, delim_specified, output_delimiter_string, output_delimiter_length, argc, ok, argv, have_read_stdin, optc)))
    return 1;
if (suppress_non_delimited && operating_mode != field_mode)
    do {
        error(0, 0, (gettext("suppressing non-delimited lines makes sense\n\tonly when operating on fields")));
        usage(1);
    } while (0);

....
Skipping nonlast addifexit:Priority 3699
At location src/cut.c:847
--Src File: src/cut.c
Fragment 0:
if ((__abst_hole(operating_mode, suppress_non_delimited, delim, output_delimiter_specified, spec_list_string, complement, delim_specified, output_delimiter_string, output_delimiter_length, argc, ok, argv, have_read_stdin, optc)))
    return 2;
if (suppress_non_delimited && operating_mode != field_mode)
    do {
        error(0, 0, (gettext("suppressing non-delimited lines makes sense\n\tonly when operating on fields")));
        usage(1);
    } while (0);

....
Skipping nonlast addifexit:Priority 3699
At location src/cut.c:847
--Src File: src/cut.c
Fragment 0:
if ((__abst_hole(operating_mode, suppress_non_delimited, delim, output_delimiter_specified, spec_list_string, complement, delim_specified, output_delimiter_string, output_delimiter_length, argc, ok, argv, have_read_stdin, optc)))
    return 6;
if (suppress_non_delimited && operating_mode != field_mode)
    do {
        error(0, 0, (gettext("suppressing non-delimited lines makes sense\n\tonly when operating on fields")));
        usage(1);
    } while (0);

....
Skipping nonlast addifexit:Priority 3700
At location src/cut.c:851
--Src File: src/cut.c
Fragment 0:
if ((__abst_hole(output_delimiter_specified, operating_mode, suppress_non_delimited, delim, spec_list_string, delim_specified, output_delimiter_string, complement, output_delimiter_length, argc, ok, argv, have_read_stdin, optc)))
    return -1;
if (output_delimiter_specified) {
}

....
Skipping nonlast addifexit:Priority 3700
At location src/cut.c:851
--Src File: src/cut.c
Fragment 0:
if ((__abst_hole(output_delimiter_specified, operating_mode, suppress_non_delimited, delim, spec_list_string, delim_specified, output_delimiter_string, complement, output_delimiter_length, argc, ok, argv, have_read_stdin, optc)))
    return 0;
if (output_delimiter_specified) {
}

....
Skipping nonlast addifexit:Priority 3700
At location src/cut.c:851
--Src File: src/cut.c
Fragment 0:
if ((__abst_hole(output_delimiter_specified, operating_mode, suppress_non_delimited, delim, spec_list_string, delim_specified, output_delimiter_string, complement, output_delimiter_length, argc, ok, argv, have_read_stdin, optc)))
    return 1;
if (output_delimiter_specified) {
}

....
Skipping nonlast addifexit:Priority 3700
At location src/cut.c:851
--Src File: src/cut.c
Fragment 0:
if ((__abst_hole(output_delimiter_specified, operating_mode, suppress_non_delimited, delim, spec_list_string, delim_specified, output_delimiter_string, complement, output_delimiter_length, argc, ok, argv, have_read_stdin, optc)))
    return 2;
if (output_delimiter_specified) {
}

....
Skipping nonlast addifexit:Priority 3700
At location src/cut.c:851
--Src File: src/cut.c
Fragment 0:
if ((__abst_hole(output_delimiter_specified, operating_mode, suppress_non_delimited, delim, spec_list_string, delim_specified, output_delimiter_string, complement, output_delimiter_length, argc, ok, argv, have_read_stdin, optc)))
    return 6;
if (output_delimiter_specified) {
}

....
IsErr:priority 4953
at location src/cut.c:861
--src file: src/cut.c
fragment 0:
if (!(__abst_hole(spec_list_string, operating_mode, delim_specified, delim, output_delimiter_specified, output_delimiter_string, suppress_non_delimited, output_delimiter_length, argc, ok, argv, have_read_stdin, complement, optc)))
    if (!set_fields(spec_list_string)) {
        if (operating_mode == field_mode)
            do {
                error(0, 0, (gettext("missing list of fields")));
                usage(1);
            } while (0);
        else
            do {
                error(0, 0, (gettext("missing list of positions")));
                usage(1);
            } while (0);
    }

....
Skipping error ifguard:Priority 4953
At location src/cut.c:861
--Src File: src/cut.c
Fragment 0:
if (!(__abst_hole(spec_list_string, operating_mode, delim_specified, delim, output_delimiter_specified, output_delimiter_string, suppress_non_delimited, output_delimiter_length, argc, ok, argv, have_read_stdin, complement, optc)))
    if (!set_fields(spec_list_string)) {
        if (operating_mode == field_mode)
            do {
                error(0, 0, (gettext("missing list of fields")));
                usage(1);
            } while (0);
        else
            do {
                error(0, 0, (gettext("missing list of positions")));
                usage(1);
            } while (0);
    }

....
Skipping nonlast addifexit:Priority 3703
At location src/cut.c:861
--Src File: src/cut.c
Fragment 0:
if ((__abst_hole(spec_list_string, operating_mode, delim_specified, delim, output_delimiter_specified, output_delimiter_string, suppress_non_delimited, output_delimiter_length, argc, ok, argv, have_read_stdin, complement, optc)))
    return -1;
if (!set_fields(spec_list_string)) {
    if (operating_mode == field_mode)
        do {
            error(0, 0, (gettext("missing list of fields")));
            usage(1);
        } while (0);
    else
        do {
            error(0, 0, (gettext("missing list of positions")));
            usage(1);
        } while (0);
}

....
Skipping nonlast addifexit:Priority 3703
At location src/cut.c:861
--Src File: src/cut.c
Fragment 0:
if ((__abst_hole(spec_list_string, operating_mode, delim_specified, delim, output_delimiter_specified, output_delimiter_string, suppress_non_delimited, output_delimiter_length, argc, ok, argv, have_read_stdin, complement, optc)))
    return 0;
if (!set_fields(spec_list_string)) {
    if (operating_mode == field_mode)
        do {
            error(0, 0, (gettext("missing list of fields")));
            usage(1);
        } while (0);
    else
        do {
            error(0, 0, (gettext("missing list of positions")));
            usage(1);
        } while (0);
}

....
Skipping nonlast addifexit:Priority 3703
At location src/cut.c:861
--Src File: src/cut.c
Fragment 0:
if ((__abst_hole(spec_list_string, operating_mode, delim_specified, delim, output_delimiter_specified, output_delimiter_string, suppress_non_delimited, output_delimiter_length, argc, ok, argv, have_read_stdin, complement, optc)))
    return 1;
if (!set_fields(spec_list_string)) {
    if (operating_mode == field_mode)
        do {
            error(0, 0, (gettext("missing list of fields")));
            usage(1);
        } while (0);
    else
        do {
            error(0, 0, (gettext("missing list of positions")));
            usage(1);
        } while (0);
}

....
Skipping nonlast addifexit:Priority 3703
At location src/cut.c:861
--Src File: src/cut.c
Fragment 0:
if ((__abst_hole(spec_list_string, operating_mode, delim_specified, delim, output_delimiter_specified, output_delimiter_string, suppress_non_delimited, output_delimiter_length, argc, ok, argv, have_read_stdin, complement, optc)))
    return 2;
if (!set_fields(spec_list_string)) {
    if (operating_mode == field_mode)
        do {
            error(0, 0, (gettext("missing list of fields")));
            usage(1);
        } while (0);
    else
        do {
            error(0, 0, (gettext("missing list of positions")));
            usage(1);
        } while (0);
}

....
Skipping nonlast addifexit:Priority 3703
At location src/cut.c:861
--Src File: src/cut.c
Fragment 0:
if ((__abst_hole(spec_list_string, operating_mode, delim_specified, delim, output_delimiter_specified, output_delimiter_string, suppress_non_delimited, output_delimiter_length, argc, ok, argv, have_read_stdin, complement, optc)))
    return 6;
if (!set_fields(spec_list_string)) {
    if (operating_mode == field_mode)
        do {
            error(0, 0, (gettext("missing list of fields")));
            usage(1);
        } while (0);
    else
        do {
            error(0, 0, (gettext("missing list of positions")));
            usage(1);
        } while (0);
}

....
Antipattern stats BEGIN: earlyret => 160
Antipattern stats BEGIN: errorexit => 14
Total 9086 different repair candidate templates!!!!
Total 9086 different repair candidate templates!!!!
Total 10548 different repair candidate!!!
Trying different candidates!
BasicTester pointer: 0x2f8cd20
CondTester pointer: 0x35b62b0
Counter: 1
Batcher Size:0
Preprocess the following candidate with CondTester:
Priority 20000
At location src/cut.c:369
--Src File: src/cut.c
Fragment 0:
if ((dash_found) && !(__abst_hole(dash_found, in_digits, fieldstr, initial, value, lhs_specified, rhs_specified, eol_range_start, field_found, rp, n_rp, n_rp_allocated, operating_mode, max_range_endpoint, i, printable_field, complement, output_delimiter_specified)))
    do {
        error(0, 0, (gettext("invalid byte or field list")));
        usage(1);
    } while (0);


CondTester, a patch instance with id 0:
Spawn 1 instances, now Total 1
Counter: 2
Batcher Size:1
Preprocess the following candidate with CondTester:
Priority 20000
At location src/cut.c:369
--Src File: src/cut.c
Fragment 0:
if ((dash_found) || (__abst_hole(dash_found, in_digits, fieldstr, initial, value, lhs_specified, rhs_specified, eol_range_start, field_found, rp, n_rp, n_rp_allocated, operating_mode, max_range_endpoint, i, printable_field, complement, output_delimiter_specified)))
    do {
        error(0, 0, (gettext("invalid byte or field list")));
        usage(1);
    } while (0);


CondTester, a patch instance with id 1:
Spawn 1 instances, now Total 2
Counter: 3
Batcher Size:2
Preprocess the following candidate with CondTester:
Priority 20000
At location src/cut.c:391
--Src File: src/cut.c
Fragment 0:
if ((!rhs_specified) && !(__abst_hole(rhs_specified, initial, eol_range_start, field_found, lhs_specified, dash_found, value, in_digits, fieldstr, rp, n_rp, n_rp_allocated, operating_mode, max_range_endpoint, i, printable_field, complement, output_delimiter_specified))) {
    eol_range_start = initial;
    field_found = 1;
} else {
    if (value < initial)
        do {
            error(0, 0, (gettext("invalid decreasing range")));
            usage(1);
        } while (0);
    if (eol_range_start != 0) {
        if (initial < eol_range_start) {
            if (eol_range_start <= value) {
                eol_range_start = initial;
            } else {
                do {
                    if (initial == 0 || value == 0)
                        do {
                            error(0, 0, (gettext("fields and positions are numbered from 1")));
                            usage(1);
                        } while (0);
                    if (n_rp >= n_rp_allocated) {
                        (rp) = x2nrealloc(rp, &n_rp_allocated, sizeof *(rp));
                    }
                    rp[n_rp].lo = (initial);
                    rp[n_rp].hi = (value);
                    ++n_rp;
                } while (0);
            }
            field_found = 1;
        }
    } else {
        do {
            if (initial == 0 || value == 0)
                do {
                    error(0, 0, (gettext("fields and positions are numbered from 1")));
                    usage(1);
                } while (0);
            if (n_rp >= n_rp_allocated) {
                (rp) = x2nrealloc(rp, &n_rp_allocated, sizeof *(rp));
            }
            rp[n_rp].lo = (initial);
            rp[n_rp].hi = (value);
            ++n_rp;
        } while (0);
        field_found = 1;
    }
    value = 0;
}


CondTester, a patch instance with id 2:
Spawn 1 instances, now Total 3
Counter: 4
Batcher Size:3
Preprocess the following candidate with CondTester:
Priority 20000
At location src/cut.c:391
--Src File: src/cut.c
Fragment 0:
if ((!rhs_specified) || (__abst_hole(rhs_specified, initial, eol_range_start, field_found, lhs_specified, dash_found, value, in_digits, fieldstr, rp, n_rp, n_rp_allocated, operating_mode, max_range_endpoint, i, printable_field, complement, output_delimiter_specified))) {
    eol_range_start = initial;
    field_found = 1;
} else {
    if (value < initial)
        do {
            error(0, 0, (gettext("invalid decreasing range")));
            usage(1);
        } while (0);
    if (eol_range_start != 0) {
        if (initial < eol_range_start) {
            if (eol_range_start <= value) {
                eol_range_start = initial;
            } else {
                do {
                    if (initial == 0 || value == 0)
                        do {
                            error(0, 0, (gettext("fields and positions are numbered from 1")));
                            usage(1);
                        } while (0);
                    if (n_rp >= n_rp_allocated) {
                        (rp) = x2nrealloc(rp, &n_rp_allocated, sizeof *(rp));
                    }
                    rp[n_rp].lo = (initial);
                    rp[n_rp].hi = (value);
                    ++n_rp;
                } while (0);
            }
            field_found = 1;
        }
    } else {
        do {
            if (initial == 0 || value == 0)
                do {
                    error(0, 0, (gettext("fields and positions are numbered from 1")));
                    usage(1);
                } while (0);
            if (n_rp >= n_rp_allocated) {
                (rp) = x2nrealloc(rp, &n_rp_allocated, sizeof *(rp));
            }
            rp[n_rp].lo = (initial);
            rp[n_rp].hi = (value);
            ++n_rp;
        } while (0);
        field_found = 1;
    }
    value = 0;
}


CondTester, a patch instance with id 3:
Spawn 1 instances, now Total 4
Counter: 5
Batcher Size:4
Preprocess the following candidate with CondTester:
Priority 20000
At location src/cut.c:382
--Src File: src/cut.c
Fragment 0:
if ((dash_found) && !(__abst_hole(dash_found, in_digits, fieldstr, lhs_specified, rhs_specified, value, initial, eol_range_start, field_found, rp, n_rp, n_rp_allocated, operating_mode, max_range_endpoint, i, printable_field, complement, output_delimiter_specified))) {
    dash_found = 0;
    if (!lhs_specified && !rhs_specified)
        do {
            error(0, 0, (gettext("invalid range with no endpoint: -")));
            usage(1);
        } while (0);
    if (!rhs_specified) {
        eol_range_start = initial;
        field_found = 1;
    } else {
        if (value < initial)
            do {
                error(0, 0, (gettext("invalid decreasing range")));
                usage(1);
            } while (0);
        if (eol_range_start != 0) {
            if (initial < eol_range_start) {
                if (eol_range_start <= value) {
                    eol_range_start = initial;
                } else {
                    do {
                        if (initial == 0 || value == 0)
                            do {
                                error(0, 0, (gettext("fields and positions are numbered from 1")));
                                usage(1);
                            } while (0);
                        if (n_rp >= n_rp_allocated) {
                            (rp) = x2nrealloc(rp, &n_rp_allocated, sizeof *(rp));
                        }
                        rp[n_rp].lo = (initial);
                        rp[n_rp].hi = (value);
                        ++n_rp;
                    } while (0);
                }
                field_found = 1;
            }
        } else {
            do {
                if (initial == 0 || value == 0)
                    do {
                        error(0, 0, (gettext("fields and positions are numbered from 1")));
                        usage(1);
                    } while (0);
                if (n_rp >= n_rp_allocated) {
                    (rp) = x2nrealloc(rp, &n_rp_allocated, sizeof *(rp));
                }
                rp[n_rp].lo = (initial);
                rp[n_rp].hi = (value);
                ++n_rp;
            } while (0);
            field_found = 1;
        }
        value = 0;
    }
} else {
    do {
        if (value == 0 || value == 0)
            do {
                error(0, 0, (gettext("fields and positions are numbered from 1")));
                usage(1);
            } while (0);
        if (n_rp >= n_rp_allocated) {
            (rp) = x2nrealloc(rp, &n_rp_allocated, sizeof *(rp));
        }
        rp[n_rp].lo = (value);
        rp[n_rp].hi = (value);
        ++n_rp;
    } while (0);
    value = 0;
    field_found = 1;
}


CondTester, a patch instance with id 4:
Spawn 1 instances, now Total 5
Counter: 6
Batcher Size:5
Preprocess the following candidate with CondTester:
Priority 20000
At location src/cut.c:382
--Src File: src/cut.c
Fragment 0:
if ((dash_found) || (__abst_hole(dash_found, in_digits, fieldstr, lhs_specified, rhs_specified, value, initial, eol_range_start, field_found, rp, n_rp, n_rp_allocated, operating_mode, max_range_endpoint, i, printable_field, complement, output_delimiter_specified))) {
    dash_found = 0;
    if (!lhs_specified && !rhs_specified)
        do {
            error(0, 0, (gettext("invalid range with no endpoint: -")));
            usage(1);
        } while (0);
    if (!rhs_specified) {
        eol_range_start = initial;
        field_found = 1;
    } else {
        if (value < initial)
            do {
                error(0, 0, (gettext("invalid decreasing range")));
                usage(1);
            } while (0);
        if (eol_range_start != 0) {
            if (initial < eol_range_start) {
                if (eol_range_start <= value) {
                    eol_range_start = initial;
                } else {
                    do {
                        if (initial == 0 || value == 0)
                            do {
                                error(0, 0, (gettext("fields and positions are numbered from 1")));
                                usage(1);
                            } while (0);
                        if (n_rp >= n_rp_allocated) {
                            (rp) = x2nrealloc(rp, &n_rp_allocated, sizeof *(rp));
                        }
                        rp[n_rp].lo = (initial);
                        rp[n_rp].hi = (value);
                        ++n_rp;
                    } while (0);
                }
                field_found = 1;
            }
        } else {
            do {
                if (initial == 0 || value == 0)
                    do {
                        error(0, 0, (gettext("fields and positions are numbered from 1")));
                        usage(1);
                    } while (0);
                if (n_rp >= n_rp_allocated) {
                    (rp) = x2nrealloc(rp, &n_rp_allocated, sizeof *(rp));
                }
                rp[n_rp].lo = (initial);
                rp[n_rp].hi = (value);
                ++n_rp;
            } while (0);
            field_found = 1;
        }
        value = 0;
    }
} else {
    do {
        if (value == 0 || value == 0)
            do {
                error(0, 0, (gettext("fields and positions are numbered from 1")));
                usage(1);
            } while (0);
        if (n_rp >= n_rp_allocated) {
            (rp) = x2nrealloc(rp, &n_rp_allocated, sizeof *(rp));
        }
        rp[n_rp].lo = (value);
        rp[n_rp].hi = (value);
        ++n_rp;
    } while (0);
    value = 0;
    field_found = 1;
}


CondTester, a patch instance with id 5:
Spawn 1 instances, now Total 6
Counter: 7
Batcher Size:6
Preprocess the following candidate with CondTester:
Priority 20000
At location src/cut.c:386
--Src File: src/cut.c
Fragment 0:
if ((!lhs_specified && !rhs_specified) && !(__abst_hole(lhs_specified, rhs_specified, dash_found, in_digits, fieldstr, initial, eol_range_start, field_found, value, rp, n_rp, n_rp_allocated, operating_mode, max_range_endpoint, i, printable_field, complement, output_delimiter_specified)))
    do {
        error(0, 0, (gettext("invalid range with no endpoint: -")));
        usage(1);
    } while (0);


CondTester, a patch instance with id 6:
Spawn 1 instances, now Total 7
Counter: 8
Batcher Size:7
Preprocess the following candidate with CondTester:
Priority 20000
At location src/cut.c:386
--Src File: src/cut.c
Fragment 0:
if ((!lhs_specified && !rhs_specified) || (__abst_hole(lhs_specified, rhs_specified, dash_found, in_digits, fieldstr, initial, eol_range_start, field_found, value, rp, n_rp, n_rp_allocated, operating_mode, max_range_endpoint, i, printable_field, complement, output_delimiter_specified)))
    do {
        error(0, 0, (gettext("invalid range with no endpoint: -")));
        usage(1);
    } while (0);


CondTester, a patch instance with id 7:
Spawn 1 instances, now Total 8
Counter: 9
Batcher Size:8
Preprocess the following candidate with CondTester:
Priority 20000
At location src/cut.c:386
--Src File: src/cut.c
Fragment 0:
if (((!lhs_specified) || (__abst_hole(lhs_specified, rhs_specified, dash_found, in_digits, fieldstr, initial, eol_range_start, field_found, value, rp, n_rp, n_rp_allocated, operating_mode, max_range_endpoint, i, printable_field, complement, output_delimiter_specified))) && !rhs_specified)
    do {
        error(0, 0, (gettext("invalid range with no endpoint: -")));
        usage(1);
    } while (0);


CondTester, a patch instance with id 8:
Spawn 1 instances, now Total 9
Counter: 10
Batcher Size:9
Preprocess the following candidate with CondTester:
Priority 20000
At location src/cut.c:526
--Src File: src/cut.c
Fragment 0:
if ((output_delimiter_specified && !complement && eol_range_start && !is_printable_field(eol_range_start)) && !(__abst_hole(eol_range_start, complement, output_delimiter_specified, rp, field_found, i, n_rp, max_range_endpoint, printable_field, fieldstr, operating_mode, value, lhs_specified, rhs_specified, dash_found, in_digits, n_rp_allocated, initial)))
    mark_range_start(eol_range_start);


CondTester, a patch instance with id 9:
Spawn 1 instances, now Total 10
Counter: 11
Batcher Size:10
Preprocess the following candidate with CondTester:
Priority 20000
At location src/cut.c:526
--Src File: src/cut.c
Fragment 0:
if ((output_delimiter_specified && !complement && eol_range_start && !is_printable_field(eol_range_start)) || (__abst_hole(eol_range_start, complement, output_delimiter_specified, rp, field_found, i, n_rp, max_range_endpoint, printable_field, fieldstr, operating_mode, value, lhs_specified, rhs_specified, dash_found, in_digits, n_rp_allocated, initial)))
    mark_range_start(eol_range_start);


CondTester, a patch instance with id 10:
Spawn 1 instances, now Total 11
Counter: 12
Batcher Size:11
Preprocess the following candidate with CondTester:
Priority 20000
At location src/cut.c:526
--Src File: src/cut.c
Fragment 0:
if (((output_delimiter_specified && !complement && eol_range_start) || (__abst_hole(eol_range_start, complement, output_delimiter_specified, rp, field_found, i, n_rp, max_range_endpoint, printable_field, fieldstr, operating_mode, value, lhs_specified, rhs_specified, dash_found, in_digits, n_rp_allocated, initial))) && !is_printable_field(eol_range_start))
    mark_range_start(eol_range_start);


CondTester, a patch instance with id 11:
Spawn 1 instances, now Total 12
Counter: 13
Batcher Size:12
Preprocess the following candidate with CondTester:
Priority 20000
At location src/cut.c:447
--Src File: src/cut.c
Fragment 0:
if ((*fieldstr == '\x00') && !(__abst_hole(fieldstr, field_found, value, rp, n_rp, n_rp_allocated, lhs_specified, rhs_specified, initial, in_digits, dash_found, eol_range_start, operating_mode, max_range_endpoint, i, printable_field, complement, output_delimiter_specified))) {
    break;
}


CondTester, a patch instance with id 12:
Spawn 1 instances, now Total 13
Counter: 14
Batcher Size:13
Preprocess the following candidate with CondTester:
Priority 20000
At location src/cut.c:465
--Src File: src/cut.c
Fragment 0:
if ((dash_found) && !(__abst_hole(dash_found, rhs_specified, in_digits, fieldstr, lhs_specified, num_start, value, operating_mode, field_found, rp, n_rp, n_rp_allocated, max_range_endpoint, i, initial, printable_field, eol_range_start, complement, output_delimiter_specified)))
    rhs_specified = 1;
else
    lhs_specified = 1;


CondTester, a patch instance with id 13:
Spawn 1 instances, now Total 14
Counter: 15
Batcher Size:14
Preprocess the following candidate with CondTester:
Priority 20000
At location src/cut.c:471
--Src File: src/cut.c
Fragment 0:
if ((!((void)(&(value) == (size_t *)((void *)0)) , (((size_t)-1 / 10 < (value) || (size_t)((value) * 10 + (*fieldstr - '0')) < (value)) ? 0 : (((value) = (value) * 10 + (*fieldstr - '0')) , 1)))) && !(__abst_hole(fieldstr, value, lhs_specified, rhs_specified, num_start, dash_found, operating_mode, in_digits, max_range_endpoint, n_rp, i, rp, field_found, n_rp_allocated, printable_field, initial, complement, output_delimiter_specified, eol_range_start))) {
    size_t len = strspn(num_start, "0123456789");
    char *bad_num = xstrndup(num_start, len);
    if (operating_mode == byte_mode)
        error(0, 0, gettext("byte offset %s is too large"), quote(bad_num));
    else
        error(0, 0, gettext("field number %s is too large"), quote(bad_num));
    free(bad_num);
    exit(1);
}


CondTester, a patch instance with id 14:
Spawn 1 instances, now Total 15
Counter: 16
Batcher Size:15
Preprocess the following candidate with CondTester:
Priority 20000
At location src/cut.c:471
--Src File: src/cut.c
Fragment 0:
if ((!((void)(&(value) == (size_t *)((void *)0)) , (((size_t)-1 / 10 < (value) || (size_t)((value) * 10 + (*fieldstr - '0')) < (value)) ? 0 : (((value) = (value) * 10 + (*fieldstr - '0')) , 1)))) || (__abst_hole(fieldstr, value, lhs_specified, rhs_specified, num_start, dash_found, operating_mode, in_digits, max_range_endpoint, n_rp, i, rp, field_found, n_rp_allocated, printable_field, initial, complement, output_delimiter_specified, eol_range_start))) {
    size_t len = strspn(num_start, "0123456789");
    char *bad_num = xstrndup(num_start, len);
    if (operating_mode == byte_mode)
        error(0, 0, gettext("byte offset %s is too large"), quote(bad_num));
    else
        error(0, 0, gettext("field number %s is too large"), quote(bad_num));
    free(bad_num);
    exit(1);
}


CondTester, a patch instance with id 15:
Spawn 1 instances, now Total 16
Counter: 17
Batcher Size:16
Preprocess the following candidate with CondTester:
Priority 20000
At location src/cut.c:456
--Src File: src/cut.c
Fragment 0:
{
    if ((((unsigned int)(*fieldstr) - '0' <= 9)) && !(__abst_hole(fieldstr, rhs_specified, lhs_specified, in_digits, dash_found, field_found, value, rp, n_rp, n_rp_allocated, operating_mode, initial, max_range_endpoint, i, eol_range_start, printable_field, complement, output_delimiter_specified))) {
        static const char *num_start;
        if (!in_digits || !num_start)
            num_start = fieldstr;
        in_digits = 1;
        if (dash_found)
            rhs_specified = 1;
        else
            lhs_specified = 1;
        if (!((void)(&(value) == (size_t *)((void *)0)) , (((size_t)-1 / 10 < (value) || (size_t)((value) * 10 + (*fieldstr - '0')) < (value)) ? 0 : (((value) = (value) * 10 + (*fieldstr - '0')) , 1)))) {
            size_t len = strspn(num_start, "0123456789");
            char *bad_num = xstrndup(num_start, len);
            if (operating_mode == byte_mode)
                error(0, 0, gettext("byte offset %s is too large"), quote(bad_num));
            else
                error(0, 0, gettext("field number %s is too large"), quote(bad_num));
            free(bad_num);
            exit(1);
        }
        fieldstr++;
    } else
        do {
            error(0, 0, (gettext("invalid byte or field list")));
            usage(1);
        } while (0);
}


CondTester, a patch instance with id 16:
Spawn 1 instances, now Total 17
Counter: 18
Batcher Size:17
Preprocess the following candidate with CondTester:
Priority 20000
At location src/cut.c:456
--Src File: src/cut.c
Fragment 0:
{
    if ((((unsigned int)(*fieldstr) - '0' <= 9)) || (__abst_hole(fieldstr, rhs_specified, lhs_specified, in_digits, dash_found, field_found, value, rp, n_rp, n_rp_allocated, operating_mode, initial, max_range_endpoint, i, eol_range_start, printable_field, complement, output_delimiter_specified))) {
        static const char *num_start;
        if (!in_digits || !num_start)
            num_start = fieldstr;
        in_digits = 1;
        if (dash_found)
            rhs_specified = 1;
        else
            lhs_specified = 1;
        if (!((void)(&(value) == (size_t *)((void *)0)) , (((size_t)-1 / 10 < (value) || (size_t)((value) * 10 + (*fieldstr - '0')) < (value)) ? 0 : (((value) = (value) * 10 + (*fieldstr - '0')) , 1)))) {
            size_t len = strspn(num_start, "0123456789");
            char *bad_num = xstrndup(num_start, len);
            if (operating_mode == byte_mode)
                error(0, 0, gettext("byte offset %s is too large"), quote(bad_num));
            else
                error(0, 0, gettext("field number %s is too large"), quote(bad_num));
            free(bad_num);
            exit(1);
        }
        fieldstr++;
    } else
        do {
            error(0, 0, (gettext("invalid byte or field list")));
            usage(1);
        } while (0);
}


CondTester, a patch instance with id 17:
Spawn 1 instances, now Total 18
Counter: 19
Batcher Size:18
Preprocess the following candidate with CondTester:
Priority 20000
At location src/cut.c:377
--Src File: src/cut.c
Fragment 0:
{
    if ((*fieldstr == ',' || ((*__ctype_b_loc())[(int)((to_uchar(*fieldstr)))] & (unsigned short)_ISblank) || *fieldstr == '\x00') && !(__abst_hole(fieldstr, in_digits, value, initial, lhs_specified, dash_found, rhs_specified, eol_range_start, field_found, rp, n_rp, n_rp_allocated, operating_mode, max_range_endpoint, i, printable_field, complement, output_delimiter_specified))) {
        in_digits = 0;
        if (dash_found) {
            dash_found = 0;
            if (!lhs_specified && !rhs_specified)
                do {
                    error(0, 0, (gettext("invalid range with no endpoint: -")));
                    usage(1);
                } while (0);
            if (!rhs_specified) {
                eol_range_start = initial;
                field_found = 1;
            } else {
                if (value < initial)
                    do {
                        error(0, 0, (gettext("invalid decreasing range")));
                        usage(1);
                    } while (0);
                if (eol_range_start != 0) {
                    if (initial < eol_range_start) {
                        if (eol_range_start <= value) {
                            eol_range_start = initial;
                        } else {
                            do {
                                if (initial == 0 || value == 0)
                                    do {
                                        error(0, 0, (gettext("fields and positions are numbered from 1")));
                                        usage(1);
                                    } while (0);
                                if (n_rp >= n_rp_allocated) {
                                    (rp) = x2nrealloc(rp, &n_rp_allocated, sizeof *(rp));
                                }
                                rp[n_rp].lo = (initial);
                                rp[n_rp].hi = (value);
                                ++n_rp;
                            } while (0);
                        }
                        field_found = 1;
                    }
                } else {
                    do {
                        if (initial == 0 || value == 0)
                            do {
                                error(0, 0, (gettext("fields and positions are numbered from 1")));
                                usage(1);
                            } while (0);
                        if (n_rp >= n_rp_allocated) {
                            (rp) = x2nrealloc(rp, &n_rp_allocated, sizeof *(rp));
                        }
                        rp[n_rp].lo = (initial);
                        rp[n_rp].hi = (value);
                        ++n_rp;
                    } while (0);
                    field_found = 1;
                }
                value = 0;
            }
        } else {
            do {
                if (value == 0 || value == 0)
                    do {
                        error(0, 0, (gettext("fields and positions are numbered from 1")));
                        usage(1);
                    } while (0);
                if (n_rp >= n_rp_allocated) {
                    (rp) = x2nrealloc(rp, &n_rp_allocated, sizeof *(rp));
                }
                rp[n_rp].lo = (value);
                rp[n_rp].hi = (value);
                ++n_rp;
            } while (0);
            value = 0;
            field_found = 1;
        }
        if (*fieldstr == '\x00') {
            break;
        }
        fieldstr++;
        lhs_specified = 0;
        rhs_specified = 0;
    } else if (((unsigned int)(*fieldstr) - '0' <= 9)) {
        static const char *num_start;
        if (!in_digits || !num_start)
            num_start = fieldstr;
        in_digits = 1;
        if (dash_found)
            rhs_specified = 1;
        else
            lhs_specified = 1;
        if (!((void)(&(value) == (size_t *)((void *)0)) , (((size_t)-1 / 10 < (value) || (size_t)((value) * 10 + (*fieldstr - '0')) < (value)) ? 0 : (((value) = (value) * 10 + (*fieldstr - '0')) , 1)))) {
            size_t len = strspn(num_start, "0123456789");
            char *bad_num = xstrndup(num_start, len);
            if (operating_mode == byte_mode)
                error(0, 0, gettext("byte offset %s is too large"), quote(bad_num));
            else
                error(0, 0, gettext("field number %s is too large"), quote(bad_num));
            free(bad_num);
            exit(1);
        }
        fieldstr++;
    } else
        do {
            error(0, 0, (gettext("invalid byte or field list")));
            usage(1);
        } while (0);
}


CondTester, a patch instance with id 18:
Spawn 1 instances, now Total 19
Counter: 20
Batcher Size:19
Preprocess the following candidate with CondTester:
Priority 20000
At location src/cut.c:377
--Src File: src/cut.c
Fragment 0:
{
    if ((*fieldstr == ',' || ((*__ctype_b_loc())[(int)((to_uchar(*fieldstr)))] & (unsigned short)_ISblank) || *fieldstr == '\x00') || (__abst_hole(fieldstr, in_digits, value, initial, lhs_specified, dash_found, rhs_specified, eol_range_start, field_found, rp, n_rp, n_rp_allocated, operating_mode, max_range_endpoint, i, printable_field, complement, output_delimiter_specified))) {
        in_digits = 0;
        if (dash_found) {
            dash_found = 0;
            if (!lhs_specified && !rhs_specified)
                do {
                    error(0, 0, (gettext("invalid range with no endpoint: -")));
                    usage(1);
                } while (0);
            if (!rhs_specified) {
                eol_range_start = initial;
                field_found = 1;
            } else {
                if (value < initial)
                    do {
                        error(0, 0, (gettext("invalid decreasing range")));
                        usage(1);
                    } while (0);
                if (eol_range_start != 0) {
                    if (initial < eol_range_start) {
                        if (eol_range_start <= value) {
                            eol_range_start = initial;
                        } else {
                            do {
                                if (initial == 0 || value == 0)
                                    do {
                                        error(0, 0, (gettext("fields and positions are numbered from 1")));
                                        usage(1);
                                    } while (0);
                                if (n_rp >= n_rp_allocated) {
                                    (rp) = x2nrealloc(rp, &n_rp_allocated, sizeof *(rp));
                                }
                                rp[n_rp].lo = (initial);
                                rp[n_rp].hi = (value);
                                ++n_rp;
                            } while (0);
                        }
                        field_found = 1;
                    }
                } else {
                    do {
                        if (initial == 0 || value == 0)
                            do {
                                error(0, 0, (gettext("fields and positions are numbered from 1")));
                                usage(1);
                            } while (0);
                        if (n_rp >= n_rp_allocated) {
                            (rp) = x2nrealloc(rp, &n_rp_allocated, sizeof *(rp));
                        }
                        rp[n_rp].lo = (initial);
                        rp[n_rp].hi = (value);
                        ++n_rp;
                    } while (0);
                    field_found = 1;
                }
                value = 0;
            }
        } else {
            do {
                if (value == 0 || value == 0)
                    do {
                        error(0, 0, (gettext("fields and positions are numbered from 1")));
                        usage(1);
                    } while (0);
                if (n_rp >= n_rp_allocated) {
                    (rp) = x2nrealloc(rp, &n_rp_allocated, sizeof *(rp));
                }
                rp[n_rp].lo = (value);
                rp[n_rp].hi = (value);
                ++n_rp;
            } while (0);
            value = 0;
            field_found = 1;
        }
        if (*fieldstr == '\x00') {
            break;
        }
        fieldstr++;
        lhs_specified = 0;
        rhs_specified = 0;
    } else if (((unsigned int)(*fieldstr) - '0' <= 9)) {
        static const char *num_start;
        if (!in_digits || !num_start)
            num_start = fieldstr;
        in_digits = 1;
        if (dash_found)
            rhs_specified = 1;
        else
            lhs_specified = 1;
        if (!((void)(&(value) == (size_t *)((void *)0)) , (((size_t)-1 / 10 < (value) || (size_t)((value) * 10 + (*fieldstr - '0')) < (value)) ? 0 : (((value) = (value) * 10 + (*fieldstr - '0')) , 1)))) {
            size_t len = strspn(num_start, "0123456789");
            char *bad_num = xstrndup(num_start, len);
            if (operating_mode == byte_mode)
                error(0, 0, gettext("byte offset %s is too large"), quote(bad_num));
            else
                error(0, 0, gettext("field number %s is too large"), quote(bad_num));
            free(bad_num);
            exit(1);
        }
        fieldstr++;
    } else
        do {
            error(0, 0, (gettext("invalid byte or field list")));
            usage(1);
        } while (0);
}


CondTester, a patch instance with id 19:
Spawn 1 instances, now Total 20
Counter: 21
Batcher Size:20
Preprocess the following candidate with CondTester:
Priority 20000
At location src/cut.c:365
--Src File: src/cut.c
Fragment 0:
if ((*fieldstr == '-') && !(__abst_hole(fieldstr, in_digits, dash_found, initial, value, lhs_specified, rhs_specified, eol_range_start, field_found, rp, n_rp, n_rp_allocated, operating_mode, max_range_endpoint, i, printable_field, complement, output_delimiter_specified))) {
    in_digits = 0;
    if (dash_found)
        do {
            error(0, 0, (gettext("invalid byte or field list")));
            usage(1);
        } while (0);
    dash_found = 1;
    fieldstr++;
    initial = (lhs_specified ? value : 1);
    value = 0;
} else if (*fieldstr == ',' || ((*__ctype_b_loc())[(int)((to_uchar(*fieldstr)))] & (unsigned short)_ISblank) || *fieldstr == '\x00') {
    in_digits = 0;
    if (dash_found) {
        dash_found = 0;
        if (!lhs_specified && !rhs_specified)
            do {
                error(0, 0, (gettext("invalid range with no endpoint: -")));
                usage(1);
            } while (0);
        if (!rhs_specified) {
            eol_range_start = initial;
            field_found = 1;
        } else {
            if (value < initial)
                do {
                    error(0, 0, (gettext("invalid decreasing range")));
                    usage(1);
                } while (0);
            if (eol_range_start != 0) {
                if (initial < eol_range_start) {
                    if (eol_range_start <= value) {
                        eol_range_start = initial;
                    } else {
                        do {
                            if (initial == 0 || value == 0)
                                do {
                                    error(0, 0, (gettext("fields and positions are numbered from 1")));
                                    usage(1);
                                } while (0);
                            if (n_rp >= n_rp_allocated) {
                                (rp) = x2nrealloc(rp, &n_rp_allocated, sizeof *(rp));
                            }
                            rp[n_rp].lo = (initial);
                            rp[n_rp].hi = (value);
                            ++n_rp;
                        } while (0);
                    }
                    field_found = 1;
                }
            } else {
                do {
                    if (initial == 0 || value == 0)
                        do {
                            error(0, 0, (gettext("fields and positions are numbered from 1")));
                            usage(1);
                        } while (0);
                    if (n_rp >= n_rp_allocated) {
                        (rp) = x2nrealloc(rp, &n_rp_allocated, sizeof *(rp));
                    }
                    rp[n_rp].lo = (initial);
                    rp[n_rp].hi = (value);
                    ++n_rp;
                } while (0);
                field_found = 1;
            }
            value = 0;
        }
    } else {
        do {
            if (value == 0 || value == 0)
                do {
                    error(0, 0, (gettext("fields and positions are numbered from 1")));
                    usage(1);
                } while (0);
            if (n_rp >= n_rp_allocated) {
                (rp) = x2nrealloc(rp, &n_rp_allocated, sizeof *(rp));
            }
            rp[n_rp].lo = (value);
            rp[n_rp].hi = (value);
            ++n_rp;
        } while (0);
        value = 0;
        field_found = 1;
    }
    if (*fieldstr == '\x00') {
        break;
    }
    fieldstr++;
    lhs_specified = 0;
    rhs_specified = 0;
} else if (((unsigned int)(*fieldstr) - '0' <= 9)) {
    static const char *num_start;
    if (!in_digits || !num_start)
        num_start = fieldstr;
    in_digits = 1;
    if (dash_found)
        rhs_specified = 1;
    else
        lhs_specified = 1;
    if (!((void)(&(value) == (size_t *)((void *)0)) , (((size_t)-1 / 10 < (value) || (size_t)((value) * 10 + (*fieldstr - '0')) < (value)) ? 0 : (((value) = (value) * 10 + (*fieldstr - '0')) , 1)))) {
        size_t len = strspn(num_start, "0123456789");
        char *bad_num = xstrndup(num_start, len);
        if (operating_mode == byte_mode)
            error(0, 0, gettext("byte offset %s is too large"), quote(bad_num));
        else
            error(0, 0, gettext("field number %s is too large"), quote(bad_num));
        free(bad_num);
        exit(1);
    }
    fieldstr++;
} else
    do {
        error(0, 0, (gettext("invalid byte or field list")));
        usage(1);
    } while (0);


CondTester, a patch instance with id 20:
Spawn 1 instances, now Total 21
Counter: 22
Batcher Size:21
Preprocess the following candidate with CondTester:
Priority 20000
At location src/cut.c:365
--Src File: src/cut.c
Fragment 0:
if ((*fieldstr == '-') || (__abst_hole(fieldstr, in_digits, dash_found, initial, value, lhs_specified, rhs_specified, eol_range_start, field_found, rp, n_rp, n_rp_allocated, operating_mode, max_range_endpoint, i, printable_field, complement, output_delimiter_specified))) {
    in_digits = 0;
    if (dash_found)
        do {
            error(0, 0, (gettext("invalid byte or field list")));
            usage(1);
        } while (0);
    dash_found = 1;
    fieldstr++;
    initial = (lhs_specified ? value : 1);
    value = 0;
} else if (*fieldstr == ',' || ((*__ctype_b_loc())[(int)((to_uchar(*fieldstr)))] & (unsigned short)_ISblank) || *fieldstr == '\x00') {
    in_digits = 0;
    if (dash_found) {
        dash_found = 0;
        if (!lhs_specified && !rhs_specified)
            do {
                error(0, 0, (gettext("invalid range with no endpoint: -")));
                usage(1);
            } while (0);
        if (!rhs_specified) {
            eol_range_start = initial;
            field_found = 1;
        } else {
            if (value < initial)
                do {
                    error(0, 0, (gettext("invalid decreasing range")));
                    usage(1);
                } while (0);
            if (eol_range_start != 0) {
                if (initial < eol_range_start) {
                    if (eol_range_start <= value) {
                        eol_range_start = initial;
                    } else {
                        do {
                            if (initial == 0 || value == 0)
                                do {
                                    error(0, 0, (gettext("fields and positions are numbered from 1")));
                                    usage(1);
                                } while (0);
                            if (n_rp >= n_rp_allocated) {
                                (rp) = x2nrealloc(rp, &n_rp_allocated, sizeof *(rp));
                            }
                            rp[n_rp].lo = (initial);
                            rp[n_rp].hi = (value);
                            ++n_rp;
                        } while (0);
                    }
                    field_found = 1;
                }
            } else {
                do {
                    if (initial == 0 || value == 0)
                        do {
                            error(0, 0, (gettext("fields and positions are numbered from 1")));
                            usage(1);
                        } while (0);
                    if (n_rp >= n_rp_allocated) {
                        (rp) = x2nrealloc(rp, &n_rp_allocated, sizeof *(rp));
                    }
                    rp[n_rp].lo = (initial);
                    rp[n_rp].hi = (value);
                    ++n_rp;
                } while (0);
                field_found = 1;
            }
            value = 0;
        }
    } else {
        do {
            if (value == 0 || value == 0)
                do {
                    error(0, 0, (gettext("fields and positions are numbered from 1")));
                    usage(1);
                } while (0);
            if (n_rp >= n_rp_allocated) {
                (rp) = x2nrealloc(rp, &n_rp_allocated, sizeof *(rp));
            }
            rp[n_rp].lo = (value);
            rp[n_rp].hi = (value);
            ++n_rp;
        } while (0);
        value = 0;
        field_found = 1;
    }
    if (*fieldstr == '\x00') {
        break;
    }
    fieldstr++;
    lhs_specified = 0;
    rhs_specified = 0;
} else if (((unsigned int)(*fieldstr) - '0' <= 9)) {
    static const char *num_start;
    if (!in_digits || !num_start)
        num_start = fieldstr;
    in_digits = 1;
    if (dash_found)
        rhs_specified = 1;
    else
        lhs_specified = 1;
    if (!((void)(&(value) == (size_t *)((void *)0)) , (((size_t)-1 / 10 < (value) || (size_t)((value) * 10 + (*fieldstr - '0')) < (value)) ? 0 : (((value) = (value) * 10 + (*fieldstr - '0')) , 1)))) {
        size_t len = strspn(num_start, "0123456789");
        char *bad_num = xstrndup(num_start, len);
        if (operating_mode == byte_mode)
            error(0, 0, gettext("byte offset %s is too large"), quote(bad_num));
        else
            error(0, 0, gettext("field number %s is too large"), quote(bad_num));
        free(bad_num);
        exit(1);
    }
    fieldstr++;
} else
    do {
        error(0, 0, (gettext("invalid byte or field list")));
        usage(1);
    } while (0);


CondTester, a patch instance with id 21:
Spawn 1 instances, now Total 22
Counter: 23
Batcher Size:22
Preprocess the following candidate with CondTester:
Priority 20000
At location src/cut.c:465
--Src File: src/cut.c
Fragment 0:
if ((dash_found) || (__abst_hole(dash_found, rhs_specified, in_digits, fieldstr, lhs_specified, num_start, value, operating_mode, field_found, rp, n_rp, n_rp_allocated, max_range_endpoint, i, initial, printable_field, eol_range_start, complement, output_delimiter_specified)))
    rhs_specified = 1;
else
    lhs_specified = 1;


CondTester, a patch instance with id 22:
Spawn 1 instances, now Total 23
Counter: 24
Batcher Size:23
Preprocess the following candidate with CondTester:
Priority 20000
At location src/cut.c:447
--Src File: src/cut.c
Fragment 0:
if ((*fieldstr == '\x00') || (__abst_hole(fieldstr, field_found, value, rp, n_rp, n_rp_allocated, lhs_specified, rhs_specified, initial, in_digits, dash_found, eol_range_start, operating_mode, max_range_endpoint, i, printable_field, complement, output_delimiter_specified))) {
    break;
}


CondTester, a patch instance with id 23:
Spawn 1 instances, now Total 24
Counter: 25
Batcher Size:24
Preprocess the following candidate with CondTester:
Priority 20000
At location src/cut.c:461
--Src File: src/cut.c
Fragment 0:
if ((!in_digits || !num_start) && !(__abst_hole(in_digits, num_start, fieldstr, dash_found, rhs_specified, lhs_specified, value, field_found, operating_mode, rp, n_rp, n_rp_allocated, initial, max_range_endpoint, i, eol_range_start, printable_field, complement, output_delimiter_specified)))
    num_start = fieldstr;


CondTester, a patch instance with id 24:
Spawn 1 instances, now Total 25
Counter: 26
Batcher Size:25
Preprocess the following candidate with CondTester:
Priority 20000
At location src/cut.c:461
--Src File: src/cut.c
Fragment 0:
if ((!in_digits || !num_start) || (__abst_hole(in_digits, num_start, fieldstr, dash_found, rhs_specified, lhs_specified, value, field_found, operating_mode, rp, n_rp, n_rp_allocated, initial, max_range_endpoint, i, eol_range_start, printable_field, complement, output_delimiter_specified)))
    num_start = fieldstr;


CondTester, a patch instance with id 25:
Spawn 1 instances, now Total 26
Counter: 27
Batcher Size:26
Preprocess the following candidate with CondTester:
Priority 20000
At location src/cut.c:840
--Src File: src/cut.c
Fragment 0:
if ((operating_mode == undefined_mode) && !(__abst_hole(operating_mode, delim, suppress_non_delimited, output_delimiter_specified, complement, spec_list_string, output_delimiter_string, output_delimiter_length, delim_specified, argc, ok, argv, have_read_stdin, optc)))
    do {
        error(0, 0, (gettext("you must specify a list of bytes, characters, or fields")));
        usage(1);
    } while (0);


CondTester, a patch instance with id 26:
Spawn 1 instances, now Total 27
Counter: 28
Batcher Size:27
Preprocess the following candidate with CondTester:
Priority 20000
At location src/cut.c:840
--Src File: src/cut.c
Fragment 0:
if ((operating_mode == undefined_mode) || (__abst_hole(operating_mode, delim, suppress_non_delimited, output_delimiter_specified, complement, spec_list_string, output_delimiter_string, output_delimiter_length, delim_specified, argc, ok, argv, have_read_stdin, optc)))
    do {
        error(0, 0, (gettext("you must specify a list of bytes, characters, or fields")));
        usage(1);
    } while (0);


CondTester, a patch instance with id 27:
Spawn 1 instances, now Total 28
Counter: 29
Batcher Size:28
Preprocess the following candidate with CondTester:
Priority 20000
At location src/cut.c:851
--Src File: src/cut.c
Fragment 0:
if ((output_delimiter_specified) && !(__abst_hole(output_delimiter_specified, operating_mode, suppress_non_delimited, delim, spec_list_string, delim_specified, output_delimiter_string, complement, output_delimiter_length, argc, ok, argv, have_read_stdin, optc))) {
}


CondTester, a patch instance with id 28:
Spawn 1 instances, now Total 29
Counter: 30
Batcher Size:29
Preprocess the following candidate with CondTester:
Priority 20000
At location src/cut.c:851
--Src File: src/cut.c
Fragment 0:
if ((output_delimiter_specified) || (__abst_hole(output_delimiter_specified, operating_mode, suppress_non_delimited, delim, spec_list_string, delim_specified, output_delimiter_string, complement, output_delimiter_length, argc, ok, argv, have_read_stdin, optc))) {
}


CondTester, a patch instance with id 29:
Spawn 1 instances, now Total 30
Counter: 31
Batcher Size:30
Preprocess the following candidate with CondTester:
Priority 20000
At location src/cut.c:861
--Src File: src/cut.c
Fragment 0:
if ((!set_fields(spec_list_string)) && !(__abst_hole(spec_list_string, operating_mode, delim_specified, delim, output_delimiter_specified, output_delimiter_string, suppress_non_delimited, output_delimiter_length, argc, ok, argv, have_read_stdin, complement, optc))) {
    if (operating_mode == field_mode)
        do {
            error(0, 0, (gettext("missing list of fields")));
            usage(1);
        } while (0);
    else
        do {
            error(0, 0, (gettext("missing list of positions")));
            usage(1);
        } while (0);
}


CondTester, a patch instance with id 30:
Spawn 1 instances, now Total 31
Counter: 32
Batcher Size:31
Preprocess the following candidate with CondTester:
Priority 20000
At location src/cut.c:861
--Src File: src/cut.c
Fragment 0:
if ((!set_fields(spec_list_string)) || (__abst_hole(spec_list_string, operating_mode, delim_specified, delim, output_delimiter_specified, output_delimiter_string, suppress_non_delimited, output_delimiter_length, argc, ok, argv, have_read_stdin, complement, optc))) {
    if (operating_mode == field_mode)
        do {
            error(0, 0, (gettext("missing list of fields")));
            usage(1);
        } while (0);
    else
        do {
            error(0, 0, (gettext("missing list of positions")));
            usage(1);
        } while (0);
}


CondTester, a patch instance with id 31:
Spawn 1 instances, now Total 32
Counter: 33
Batcher Size:32
Preprocess the following candidate with CondTester:
Priority 20000
At location src/cut.c:843
--Src File: src/cut.c
Fragment 0:
if ((delim != '\x00' && operating_mode != field_mode) && !(__abst_hole(operating_mode, delim, suppress_non_delimited, output_delimiter_specified, complement, spec_list_string, delim_specified, output_delimiter_string, output_delimiter_length, argc, ok, argv, have_read_stdin, optc)))
    do {
        error(0, 0, (gettext("an input delimiter may be specified only when operating on fields")));
        usage(1);
    } while (0);


CondTester, a patch instance with id 32:
Spawn 1 instances, now Total 33
Counter: 34
Batcher Size:33
Preprocess the following candidate with CondTester:
Priority 20000
At location src/cut.c:847
--Src File: src/cut.c
Fragment 0:
if ((suppress_non_delimited && operating_mode != field_mode) && !(__abst_hole(operating_mode, suppress_non_delimited, delim, output_delimiter_specified, spec_list_string, complement, delim_specified, output_delimiter_string, output_delimiter_length, argc, ok, argv, have_read_stdin, optc)))
    do {
        error(0, 0, (gettext("suppressing non-delimited lines makes sense\n\tonly when operating on fields")));
        usage(1);
    } while (0);


CondTester, a patch instance with id 33:
Spawn 1 instances, now Total 34
Counter: 35
Batcher Size:34
Preprocess the following candidate with CondTester:
Priority 20000
At location src/cut.c:847
--Src File: src/cut.c
Fragment 0:
if ((suppress_non_delimited && operating_mode != field_mode) || (__abst_hole(operating_mode, suppress_non_delimited, delim, output_delimiter_specified, spec_list_string, complement, delim_specified, output_delimiter_string, output_delimiter_length, argc, ok, argv, have_read_stdin, optc)))
    do {
        error(0, 0, (gettext("suppressing non-delimited lines makes sense\n\tonly when operating on fields")));
        usage(1);
    } while (0);


CondTester, a patch instance with id 34:
Spawn 1 instances, now Total 35
Counter: 36
Batcher Size:35
Preprocess the following candidate with CondTester:
Priority 20000
At location src/cut.c:847
--Src File: src/cut.c
Fragment 0:
if (((suppress_non_delimited) || (__abst_hole(operating_mode, suppress_non_delimited, delim, output_delimiter_specified, spec_list_string, complement, delim_specified, output_delimiter_string, output_delimiter_length, argc, ok, argv, have_read_stdin, optc))) && operating_mode != field_mode)
    do {
        error(0, 0, (gettext("suppressing non-delimited lines makes sense\n\tonly when operating on fields")));
        usage(1);
    } while (0);


CondTester, a patch instance with id 35:
Spawn 1 instances, now Total 36
Counter: 37
Batcher Size:36
Preprocess the following candidate with CondTester:
Priority 20000
At location src/cut.c:843
--Src File: src/cut.c
Fragment 0:
if ((delim != '\x00' && operating_mode != field_mode) || (__abst_hole(operating_mode, delim, suppress_non_delimited, output_delimiter_specified, complement, spec_list_string, delim_specified, output_delimiter_string, output_delimiter_length, argc, ok, argv, have_read_stdin, optc)))
    do {
        error(0, 0, (gettext("an input delimiter may be specified only when operating on fields")));
        usage(1);
    } while (0);


CondTester, a patch instance with id 36:
Spawn 1 instances, now Total 37
Counter: 38
Batcher Size:37
Preprocess the following candidate with CondTester:
Priority 20000
At location src/cut.c:843
--Src File: src/cut.c
Fragment 0:
if (((delim != '\x00') || (__abst_hole(operating_mode, delim, suppress_non_delimited, output_delimiter_specified, complement, spec_list_string, delim_specified, output_delimiter_string, output_delimiter_length, argc, ok, argv, have_read_stdin, optc))) && operating_mode != field_mode)
    do {
        error(0, 0, (gettext("an input delimiter may be specified only when operating on fields")));
        usage(1);
    } while (0);


CondTester, a patch instance with id 37:
Spawn 1 instances, now Total 38
Counter: 39
Batcher Size:38
Preprocess the following candidate with CondTester:
Priority 9991
At location src/cut.c:449
--Src File: src/cut.c
Fragment 0:
if ((__abst_hole(fieldstr, lhs_specified, rhs_specified, field_found, value, rp, n_rp, n_rp_allocated, in_digits, initial, dash_found, operating_mode, eol_range_start, max_range_endpoint, i, printable_field, complement, output_delimiter_specified)))
    break;
break;


CondTester, a patch instance with id 38:
Spawn 1 instances, now Total 39
Counter: 40
Batcher Size:39
Preprocess the following candidate with CondTester:
Priority 8731
At location src/cut.c:365
--Src File: src/cut.c
Fragment 0:
if ((__abst_hole(fieldstr, in_digits, dash_found, initial, value, lhs_specified, rhs_specified, eol_range_start, field_found, rp, n_rp, n_rp_allocated, operating_mode, max_range_endpoint, i, printable_field, complement, output_delimiter_specified)))
    break;
if (*fieldstr == '-') {
    in_digits = 0;
    if (dash_found)
        do {
            error(0, 0, (gettext("invalid byte or field list")));
            usage(1);
        } while (0);
    dash_found = 1;
    fieldstr++;
    initial = (lhs_specified ? value : 1);
    value = 0;
} else if (*fieldstr == ',' || ((*__ctype_b_loc())[(int)((to_uchar(*fieldstr)))] & (unsigned short)_ISblank) || *fieldstr == '\x00') {
    in_digits = 0;
    if (dash_found) {
        dash_found = 0;
        if (!lhs_specified && !rhs_specified)
            do {
                error(0, 0, (gettext("invalid range with no endpoint: -")));
                usage(1);
            } while (0);
        if (!rhs_specified) {
            eol_range_start = initial;
            field_found = 1;
        } else {
            if (value < initial)
                do {
                    error(0, 0, (gettext("invalid decreasing range")));
                    usage(1);
                } while (0);
            if (eol_range_start != 0) {
                if (initial < eol_range_start) {
                    if (eol_range_start <= value) {
                        eol_range_start = initial;
                    } else {
                        do {
                            if (initial == 0 || value == 0)
                                do {
                                    error(0, 0, (gettext("fields and positions are numbered from 1")));
                                    usage(1);
                                } while (0);
                            if (n_rp >= n_rp_allocated) {
                                (rp) = x2nrealloc(rp, &n_rp_allocated, sizeof *(rp));
                            }
                            rp[n_rp].lo = (initial);
                            rp[n_rp].hi = (value);
                            ++n_rp;
                        } while (0);
                    }
                    field_found = 1;
                }
            } else {
                do {
                    if (initial == 0 || value == 0)
                        do {
                            error(0, 0, (gettext("fields and positions are numbered from 1")));
                            usage(1);
                        } while (0);
                    if (n_rp >= n_rp_allocated) {
                        (rp) = x2nrealloc(rp, &n_rp_allocated, sizeof *(rp));
                    }
                    rp[n_rp].lo = (initial);
                    rp[n_rp].hi = (value);
                    ++n_rp;
                } while (0);
                field_found = 1;
            }
            value = 0;
        }
    } else {
        do {
            if (value == 0 || value == 0)
                do {
                    error(0, 0, (gettext("fields and positions are numbered from 1")));
                    usage(1);
                } while (0);
            if (n_rp >= n_rp_allocated) {
                (rp) = x2nrealloc(rp, &n_rp_allocated, sizeof *(rp));
            }
            rp[n_rp].lo = (value);
            rp[n_rp].hi = (value);
            ++n_rp;
        } while (0);
        value = 0;
        field_found = 1;
    }
    if (*fieldstr == '\x00') {
        break;
    }
    fieldstr++;
    lhs_specified = 0;
    rhs_specified = 0;
} else if (((unsigned int)(*fieldstr) - '0' <= 9)) {
    static const char *num_start;
    if (!in_digits || !num_start)
        num_start = fieldstr;
    in_digits = 1;
    if (dash_found)
        rhs_specified = 1;
    else
        lhs_specified = 1;
    if (!((void)(&(value) == (size_t *)((void *)0)) , (((size_t)-1 / 10 < (value) || (size_t)((value) * 10 + (*fieldstr - '0')) < (value)) ? 0 : (((value) = (value) * 10 + (*fieldstr - '0')) , 1)))) {
        size_t len = strspn(num_start, "0123456789");
        char *bad_num = xstrndup(num_start, len);
        if (operating_mode == byte_mode)
            error(0, 0, gettext("byte offset %s is too large"), quote(bad_num));
        else
            error(0, 0, gettext("field number %s is too large"), quote(bad_num));
        free(bad_num);
        exit(1);
    }
    fieldstr++;
} else
    do {
        error(0, 0, (gettext("invalid byte or field list")));
        usage(1);
    } while (0);


CondTester, a patch instance with id 39:
Spawn 1 instances, now Total 40
Counter: 41
Batcher Size:40
Preprocess the following candidate with BasicTester:
Priority 7500
At location src/cut.c:269
--Src File: src/cut.c
Fragment 0:
eol_range_start = (1);
return (printable_field[n] >> (i % 8)) & 1;


BasicTester, a patch instance with id 0:
Spawn 1 instances, now Total 41
Counter: 42
Batcher Size:41
Preprocess the following candidate with BasicTester:
Priority 7500
At location src/cut.c:269
--Src File: src/cut.c
Fragment 0:
(*__errno_location()) = (0);
return (printable_field[n] >> (i % 8)) & 1;


BasicTester, a patch instance with id 1:
Spawn 1 instances, now Total 42
Counter: 43
Batcher Size:42
Preprocess the following candidate with BasicTester:
Priority 7500
At location src/cut.c:269
--Src File: src/cut.c
Fragment 0:
delim = '\t';
return (printable_field[n] >> (i % 8)) & 1;


BasicTester, a patch instance with id 2:
Spawn 1 instances, now Total 43
Counter: 44
Batcher Size:43
Preprocess the following candidate with BasicTester:
Priority 7500
At location src/cut.c:269
--Src File: src/cut.c
Fragment 0:
delim = (8);
return (printable_field[n] >> (i % 8)) & 1;


BasicTester, a patch instance with id 3:
Spawn 1 instances, now Total 44
Counter: 45
Batcher Size:44
Preprocess the following candidate with BasicTester:
Priority 7500
At location src/cut.c:269
--Src File: src/cut.c
Fragment 0:
eol_range_start = (0);
return (printable_field[n] >> (i % 8)) & 1;


BasicTester, a patch instance with id 4:
Spawn 1 instances, now Total 45
Counter: 46
Batcher Size:45
Preprocess the following candidate with BasicTester:
Priority 7500
At location src/cut.c:269
--Src File: src/cut.c
Fragment 0:
emit_ancillary_info();
return (printable_field[n] >> (i % 8)) & 1;


BasicTester, a patch instance with id 5:
Spawn 1 instances, now Total 46
Counter: 47
Batcher Size:46
Preprocess the following candidate with BasicTester:
Priority 7500
At location src/cut.c:269
--Src File: src/cut.c
Fragment 0:
delim = '\x00';
return (printable_field[n] >> (i % 8)) & 1;


BasicTester, a patch instance with id 6:
Spawn 1 instances, now Total 47
Counter: 48
Batcher Size:47
Preprocess the following candidate with BasicTester:
Priority 7500
At location src/cut.c:269
--Src File: src/cut.c
Fragment 0:
delim = (0);
return (printable_field[n] >> (i % 8)) & 1;


BasicTester, a patch instance with id 7:
Spawn 1 instances, now Total 48
Counter: 49
Batcher Size:48
Preprocess the following candidate with BasicTester:
Priority 7500
At location src/cut.c:269
--Src File: src/cut.c
Fragment 0:
delim = (1);
return (printable_field[n] >> (i % 8)) & 1;


BasicTester, a patch instance with id 8:
Spawn 1 instances, now Total 49
Counter: 50
Batcher Size:49
Preprocess the following candidate with BasicTester:
Priority 7500
At location src/cut.c:269
--Src File: src/cut.c
Fragment 0:
(*__errno_location()) = (1);
return (printable_field[n] >> (i % 8)) & 1;


BasicTester, a patch instance with id 9:
Spawn 1 instances, now Total 50
a batched test job starts!
Building:src at:
/home/ubuntu/spr-fast/tests/corebench/coreutils/coreutils-case-7380cf79-2e636af1/tempworkdir/srcMerged code building succ, going to invoke tester!
BasicTester, Testing instance id 0:
Running test command:
/home/ubuntu/spr-fast/tools/coreutils-test.py /home/ubuntu/spr-fast/tests/corebench/coreutils/coreutils-case-7380cf79-2e636af1/tempworkdir/src /home/ubuntu/spr-fast/tests/corebench/coreutils/coreutils-case-7380cf79-2e636af1/tempworkdir/tests /home/ubuntu/spr-fast/tests/corebench/coreutils/coreutils-case-7380cf79-2e636af1/tempworkdir 0  > __res
BasicTester, Testing instance id 1:
Running test command:
/home/ubuntu/spr-fast/tools/coreutils-test.py /home/ubuntu/spr-fast/tests/corebench/coreutils/coreutils-case-7380cf79-2e636af1/tempworkdir/src /home/ubuntu/spr-fast/tests/corebench/coreutils/coreutils-case-7380cf79-2e636af1/tempworkdir/tests /home/ubuntu/spr-fast/tests/corebench/coreutils/coreutils-case-7380cf79-2e636af1/tempworkdir 0  > __res
BasicTester, Testing instance id 2:
Running test command:
/home/ubuntu/spr-fast/tools/coreutils-test.py /home/ubuntu/spr-fast/tests/corebench/coreutils/coreutils-case-7380cf79-2e636af1/tempworkdir/src /home/ubuntu/spr-fast/tests/corebench/coreutils/coreutils-case-7380cf79-2e636af1/tempworkdir/tests /home/ubuntu/spr-fast/tests/corebench/coreutils/coreutils-case-7380cf79-2e636af1/tempworkdir 0  > __res
BasicTester, Testing instance id 3:
Running test command:
/home/ubuntu/spr-fast/tools/coreutils-test.py /home/ubuntu/spr-fast/tests/corebench/coreutils/coreutils-case-7380cf79-2e636af1/tempworkdir/src /home/ubuntu/spr-fast/tests/corebench/coreutils/coreutils-case-7380cf79-2e636af1/tempworkdir/tests /home/ubuntu/spr-fast/tests/corebench/coreutils/coreutils-case-7380cf79-2e636af1/tempworkdir 0  > __res
BasicTester, Testing instance id 4:
Running test command:
/home/ubuntu/spr-fast/tools/coreutils-test.py /home/ubuntu/spr-fast/tests/corebench/coreutils/coreutils-case-7380cf79-2e636af1/tempworkdir/src /home/ubuntu/spr-fast/tests/corebench/coreutils/coreutils-case-7380cf79-2e636af1/tempworkdir/tests /home/ubuntu/spr-fast/tests/corebench/coreutils/coreutils-case-7380cf79-2e636af1/tempworkdir 0  > __res
BasicTester, Testing instance id 5:
Running test command:
/home/ubuntu/spr-fast/tools/coreutils-test.py /home/ubuntu/spr-fast/tests/corebench/coreutils/coreutils-case-7380cf79-2e636af1/tempworkdir/src /home/ubuntu/spr-fast/tests/corebench/coreutils/coreutils-case-7380cf79-2e636af1/tempworkdir/tests /home/ubuntu/spr-fast/tests/corebench/coreutils/coreutils-case-7380cf79-2e636af1/tempworkdir 0  > __res
BasicTester, Testing instance id 6:
Running test command:
/home/ubuntu/spr-fast/tools/coreutils-test.py /home/ubuntu/spr-fast/tests/corebench/coreutils/coreutils-case-7380cf79-2e636af1/tempworkdir/src /home/ubuntu/spr-fast/tests/corebench/coreutils/coreutils-case-7380cf79-2e636af1/tempworkdir/tests /home/ubuntu/spr-fast/tests/corebench/coreutils/coreutils-case-7380cf79-2e636af1/tempworkdir 0  > __res
BasicTester, Testing instance id 7:
Running test command:
/home/ubuntu/spr-fast/tools/coreutils-test.py /home/ubuntu/spr-fast/tests/corebench/coreutils/coreutils-case-7380cf79-2e636af1/tempworkdir/src /home/ubuntu/spr-fast/tests/corebench/coreutils/coreutils-case-7380cf79-2e636af1/tempworkdir/tests /home/ubuntu/spr-fast/tests/corebench/coreutils/coreutils-case-7380cf79-2e636af1/tempworkdir 0  > __res
BasicTester, Testing instance id 8:
Running test command:
/home/ubuntu/spr-fast/tools/coreutils-test.py /home/ubuntu/spr-fast/tests/corebench/coreutils/coreutils-case-7380cf79-2e636af1/tempworkdir/src /home/ubuntu/spr-fast/tests/corebench/coreutils/coreutils-case-7380cf79-2e636af1/tempworkdir/tests /home/ubuntu/spr-fast/tests/corebench/coreutils/coreutils-case-7380cf79-2e636af1/tempworkdir 0  > __res
BasicTester, Testing instance id 9:
Running test command:
/home/ubuntu/spr-fast/tools/coreutils-test.py /home/ubuntu/spr-fast/tests/corebench/coreutils/coreutils-case-7380cf79-2e636af1/tempworkdir/src /home/ubuntu/spr-fast/tests/corebench/coreutils/coreutils-case-7380cf79-2e636af1/tempworkdir/tests /home/ubuntu/spr-fast/tests/corebench/coreutils/coreutils-case-7380cf79-2e636af1/tempworkdir 0  > __res
Counter: 51
Batcher Size:40
Preprocess the following candidate with BasicTester:
Priority 7500
At location src/cut.c:269
--Src File: src/cut.c
Fragment 0:
(*__errno_location()) = (8);
return (printable_field[n] >> (i % 8)) & 1;


BasicTester, a patch instance with id 10:
Spawn 1 instances, now Total 51
Counter: 52
Batcher Size:41
Preprocess the following candidate with BasicTester:
Priority 7500
At location src/cut.c:269
--Src File: src/cut.c
Fragment 0:
(*__errno_location()) = 0;
return (printable_field[n] >> (i % 8)) & 1;


BasicTester, a patch instance with id 11:
Spawn 1 instances, now Total 52
Counter: 53
Batcher Size:42
Preprocess the following candidate with BasicTester:
Priority 7500
At location src/cut.c:269
--Src File: src/cut.c
Fragment 0:
xalloc_die();
return (printable_field[n] >> (i % 8)) & 1;


BasicTester, a patch instance with id 12:
Spawn 1 instances, now Total 53
Counter: 54
Batcher Size:43
Preprocess the following candidate with BasicTester:
Priority 7500
At location src/cut.c:269
--Src File: src/cut.c
Fragment 0:
output_delimiter_length = (i);
return (printable_field[n] >> (i % 8)) & 1;


BasicTester, a patch instance with id 13:
Spawn 1 instances, now Total 54
Counter: 55
Batcher Size:44
Preprocess the following candidate with BasicTester:
Priority 7500
At location src/cut.c:269
--Src File: src/cut.c
Fragment 0:
printable_field = xzalloc(max_range_endpoint / 8 + 1);
return (printable_field[n] >> (i % 8)) & 1;


BasicTester, a patch instance with id 14:
Spawn 1 instances, now Total 55
Counter: 56
Batcher Size:45
Preprocess the following candidate with BasicTester:
Priority 7500
At location src/cut.c:269
--Src File: src/cut.c
Fragment 0:
setlocale(6, "");
return (printable_field[n] >> (i % 8)) & 1;


BasicTester, a patch instance with id 15:
Spawn 1 instances, now Total 56
Counter: 57
Batcher Size:46
Preprocess the following candidate with BasicTester:
Priority 7500
At location src/cut.c:269
--Src File: src/cut.c
Fragment 0:
suppress_non_delimited = 0;
return (printable_field[n] >> (i % 8)) & 1;


BasicTester, a patch instance with id 16:
Spawn 1 instances, now Total 57
Counter: 58
Batcher Size:47
Preprocess the following candidate with BasicTester:
Priority 7500
At location src/cut.c:269
--Src File: src/cut.c
Fragment 0:
putchar('\n');
return (printable_field[n] >> (i % 8)) & 1;


BasicTester, a patch instance with id 17:
Spawn 1 instances, now Total 58
Counter: 59
Batcher Size:48
Preprocess the following candidate with BasicTester:
Priority 7500
At location src/cut.c:269
--Src File: src/cut.c
Fragment 0:
output_delimiter_length = (n);
return (printable_field[n] >> (i % 8)) & 1;


BasicTester, a patch instance with id 18:
Spawn 1 instances, now Total 59
Counter: 60
Batcher Size:49
Preprocess the following candidate with BasicTester:
Priority 7500
At location src/cut.c:269
--Src File: src/cut.c
Fragment 0:
output_delimiter_length = (optarg[0] == '\x00' ? 1 : strlen(optarg));
return (printable_field[n] >> (i % 8)) & 1;


BasicTester, a patch instance with id 19:
Spawn 1 instances, now Total 60
a batched test job starts!
Building:src at:
/home/ubuntu/spr-fast/tests/corebench/coreutils/coreutils-case-7380cf79-2e636af1/tempworkdir/srcMerged code building succ, going to invoke tester!
BasicTester, Testing instance id 10:
Running test command:
/home/ubuntu/spr-fast/tools/coreutils-test.py /home/ubuntu/spr-fast/tests/corebench/coreutils/coreutils-case-7380cf79-2e636af1/tempworkdir/src /home/ubuntu/spr-fast/tests/corebench/coreutils/coreutils-case-7380cf79-2e636af1/tempworkdir/tests /home/ubuntu/spr-fast/tests/corebench/coreutils/coreutils-case-7380cf79-2e636af1/tempworkdir 0  > __res
BasicTester, Testing instance id 11:
Running test command:
/home/ubuntu/spr-fast/tools/coreutils-test.py /home/ubuntu/spr-fast/tests/corebench/coreutils/coreutils-case-7380cf79-2e636af1/tempworkdir/src /home/ubuntu/spr-fast/tests/corebench/coreutils/coreutils-case-7380cf79-2e636af1/tempworkdir/tests /home/ubuntu/spr-fast/tests/corebench/coreutils/coreutils-case-7380cf79-2e636af1/tempworkdir 0  > __res
BasicTester, Testing instance id 12:
Running test command:
/home/ubuntu/spr-fast/tools/coreutils-test.py /home/ubuntu/spr-fast/tests/corebench/coreutils/coreutils-case-7380cf79-2e636af1/tempworkdir/src /home/ubuntu/spr-fast/tests/corebench/coreutils/coreutils-case-7380cf79-2e636af1/tempworkdir/tests /home/ubuntu/spr-fast/tests/corebench/coreutils/coreutils-case-7380cf79-2e636af1/tempworkdir 0  > __res
BasicTester, Testing instance id 13:
Running test command:
/home/ubuntu/spr-fast/tools/coreutils-test.py /home/ubuntu/spr-fast/tests/corebench/coreutils/coreutils-case-7380cf79-2e636af1/tempworkdir/src /home/ubuntu/spr-fast/tests/corebench/coreutils/coreutils-case-7380cf79-2e636af1/tempworkdir/tests /home/ubuntu/spr-fast/tests/corebench/coreutils/coreutils-case-7380cf79-2e636af1/tempworkdir 0  > __res
BasicTester, Testing instance id 14:
Running test command:
/home/ubuntu/spr-fast/tools/coreutils-test.py /home/ubuntu/spr-fast/tests/corebench/coreutils/coreutils-case-7380cf79-2e636af1/tempworkdir/src /home/ubuntu/spr-fast/tests/corebench/coreutils/coreutils-case-7380cf79-2e636af1/tempworkdir/tests /home/ubuntu/spr-fast/tests/corebench/coreutils/coreutils-case-7380cf79-2e636af1/tempworkdir 0  > __res
BasicTester, Testing instance id 15:
Running test command:
/home/ubuntu/spr-fast/tools/coreutils-test.py /home/ubuntu/spr-fast/tests/corebench/coreutils/coreutils-case-7380cf79-2e636af1/tempworkdir/src /home/ubuntu/spr-fast/tests/corebench/coreutils/coreutils-case-7380cf79-2e636af1/tempworkdir/tests /home/ubuntu/spr-fast/tests/corebench/coreutils/coreutils-case-7380cf79-2e636af1/tempworkdir 0  > __res
BasicTester, Testing instance id 16:
Running test command:
/home/ubuntu/spr-fast/tools/coreutils-test.py /home/ubuntu/spr-fast/tests/corebench/coreutils/coreutils-case-7380cf79-2e636af1/tempworkdir/src /home/ubuntu/spr-fast/tests/corebench/coreutils/coreutils-case-7380cf79-2e636af1/tempworkdir/tests /home/ubuntu/spr-fast/tests/corebench/coreutils/coreutils-case-7380cf79-2e636af1/tempworkdir 0  > __res
BasicTester, Testing instance id 17:
Running test command:
/home/ubuntu/spr-fast/tools/coreutils-test.py /home/ubuntu/spr-fast/tests/corebench/coreutils/coreutils-case-7380cf79-2e636af1/tempworkdir/src /home/ubuntu/spr-fast/tests/corebench/coreutils/coreutils-case-7380cf79-2e636af1/tempworkdir/tests /home/ubuntu/spr-fast/tests/corebench/coreutils/coreutils-case-7380cf79-2e636af1/tempworkdir 0  > __res
BasicTester, Testing instance id 18:
Running test command:
/home/ubuntu/spr-fast/tools/coreutils-test.py /home/ubuntu/spr-fast/tests/corebench/coreutils/coreutils-case-7380cf79-2e636af1/tempworkdir/src /home/ubuntu/spr-fast/tests/corebench/coreutils/coreutils-case-7380cf79-2e636af1/tempworkdir/tests /home/ubuntu/spr-fast/tests/corebench/coreutils/coreutils-case-7380cf79-2e636af1/tempworkdir 0  > __res
BasicTester, Testing instance id 19:
Running test command:
/home/ubuntu/spr-fast/tools/coreutils-test.py /home/ubuntu/spr-fast/tests/corebench/coreutils/coreutils-case-7380cf79-2e636af1/tempworkdir/src /home/ubuntu/spr-fast/tests/corebench/coreutils/coreutils-case-7380cf79-2e636af1/tempworkdir/tests /home/ubuntu/spr-fast/tests/corebench/coreutils/coreutils-case-7380cf79-2e636af1/tempworkdir 0  > __res
Counter: 61
Batcher Size:40
Preprocess the following candidate with BasicTester:
Priority 7500
At location src/cut.c:269
--Src File: src/cut.c
Fragment 0:
output_delimiter_length = 1;
return (printable_field[n] >> (i % 8)) & 1;


BasicTester, a patch instance with id 20:
Spawn 1 instances, now Total 61
Counter: 62
Batcher Size:41
Preprocess the following candidate with BasicTester:
Priority 7500
At location src/cut.c:269
--Src File: src/cut.c
Fragment 0:
operating_mode = undefined_mode;
return (printable_field[n] >> (i % 8)) & 1;


BasicTester, a patch instance with id 21:
Spawn 1 instances, now Total 62
Counter: 63
Batcher Size:42
Preprocess the following candidate with BasicTester:
Priority 7500
At location src/cut.c:269
--Src File: src/cut.c
Fragment 0:
output_delimiter_length = (1);
return (printable_field[n] >> (i % 8)) & 1;


BasicTester, a patch instance with id 22:
Spawn 1 instances, now Total 63
Counter: 64
Batcher Size:43
Preprocess the following candidate with BasicTester:
Priority 7500
At location src/cut.c:269
--Src File: src/cut.c
Fragment 0:
output_delimiter_length = (8);
return (printable_field[n] >> (i % 8)) & 1;


BasicTester, a patch instance with id 23:
Spawn 1 instances, now Total 64
Counter: 65
Batcher Size:44
Preprocess the following candidate with BasicTester:
Priority 7500
At location src/cut.c:269
--Src File: src/cut.c
Fragment 0:
output_delimiter_length = (0);
return (printable_field[n] >> (i % 8)) & 1;


BasicTester, a patch instance with id 24:
Spawn 1 instances, now Total 65
Counter: 66
Batcher Size:45
Preprocess the following candidate with BasicTester:
Priority 7500
At location src/cut.c:269
--Src File: src/cut.c
Fragment 0:
operating_mode = byte_mode;
return (printable_field[n] >> (i % 8)) & 1;


BasicTester, a patch instance with id 25:
Spawn 1 instances, now Total 66
Counter: 67
Batcher Size:46
Preprocess the following candidate with BasicTester:
Priority 7500
At location src/cut.c:269
--Src File: src/cut.c
Fragment 0:
operating_mode = field_mode;
return (printable_field[n] >> (i % 8)) & 1;


BasicTester, a patch instance with id 26:
Spawn 1 instances, now Total 67
Counter: 68
Batcher Size:47
Preprocess the following candidate with BasicTester:
Priority 7500
At location src/cut.c:269
--Src File: src/cut.c
Fragment 0:
operating_mode = (field_mode);
return (printable_field[n] >> (i % 8)) & 1;


BasicTester, a patch instance with id 27:
Spawn 1 instances, now Total 68
Counter: 69
Batcher Size:48
Preprocess the following candidate with BasicTester:
Priority 7500
At location src/cut.c:269
--Src File: src/cut.c
Fragment 0:
operating_mode = (undefined_mode);
return (printable_field[n] >> (i % 8)) & 1;


BasicTester, a patch instance with id 28:
Spawn 1 instances, now Total 69
Counter: 70
Batcher Size:49
Preprocess the following candidate with BasicTester:
Priority 7500
At location src/cut.c:269
--Src File: src/cut.c
Fragment 0:
max_range_endpoint = (i);
return (printable_field[n] >> (i % 8)) & 1;


BasicTester, a patch instance with id 29:
Spawn 1 instances, now Total 70
a batched test job starts!
Building:src at:
/home/ubuntu/spr-fast/tests/corebench/coreutils/coreutils-case-7380cf79-2e636af1/tempworkdir/srcMerged code building succ, going to invoke tester!
BasicTester, Testing instance id 20:
Running test command:
/home/ubuntu/spr-fast/tools/coreutils-test.py /home/ubuntu/spr-fast/tests/corebench/coreutils/coreutils-case-7380cf79-2e636af1/tempworkdir/src /home/ubuntu/spr-fast/tests/corebench/coreutils/coreutils-case-7380cf79-2e636af1/tempworkdir/tests /home/ubuntu/spr-fast/tests/corebench/coreutils/coreutils-case-7380cf79-2e636af1/tempworkdir 0  > __res
BasicTester, Testing instance id 21:
Running test command:
/home/ubuntu/spr-fast/tools/coreutils-test.py /home/ubuntu/spr-fast/tests/corebench/coreutils/coreutils-case-7380cf79-2e636af1/tempworkdir/src /home/ubuntu/spr-fast/tests/corebench/coreutils/coreutils-case-7380cf79-2e636af1/tempworkdir/tests /home/ubuntu/spr-fast/tests/corebench/coreutils/coreutils-case-7380cf79-2e636af1/tempworkdir 0  > __res
BasicTester, Testing instance id 22:
Running test command:
/home/ubuntu/spr-fast/tools/coreutils-test.py /home/ubuntu/spr-fast/tests/corebench/coreutils/coreutils-case-7380cf79-2e636af1/tempworkdir/src /home/ubuntu/spr-fast/tests/corebench/coreutils/coreutils-case-7380cf79-2e636af1/tempworkdir/tests /home/ubuntu/spr-fast/tests/corebench/coreutils/coreutils-case-7380cf79-2e636af1/tempworkdir 0  > __res
BasicTester, Testing instance id 23:
Running test command:
/home/ubuntu/spr-fast/tools/coreutils-test.py /home/ubuntu/spr-fast/tests/corebench/coreutils/coreutils-case-7380cf79-2e636af1/tempworkdir/src /home/ubuntu/spr-fast/tests/corebench/coreutils/coreutils-case-7380cf79-2e636af1/tempworkdir/tests /home/ubuntu/spr-fast/tests/corebench/coreutils/coreutils-case-7380cf79-2e636af1/tempworkdir 0  > __res
BasicTester, Testing instance id 24:
Running test command:
/home/ubuntu/spr-fast/tools/coreutils-test.py /home/ubuntu/spr-fast/tests/corebench/coreutils/coreutils-case-7380cf79-2e636af1/tempworkdir/src /home/ubuntu/spr-fast/tests/corebench/coreutils/coreutils-case-7380cf79-2e636af1/tempworkdir/tests /home/ubuntu/spr-fast/tests/corebench/coreutils/coreutils-case-7380cf79-2e636af1/tempworkdir 0  > __res
BasicTester, Testing instance id 25:
Running test command:
/home/ubuntu/spr-fast/tools/coreutils-test.py /home/ubuntu/spr-fast/tests/corebench/coreutils/coreutils-case-7380cf79-2e636af1/tempworkdir/src /home/ubuntu/spr-fast/tests/corebench/coreutils/coreutils-case-7380cf79-2e636af1/tempworkdir/tests /home/ubuntu/spr-fast/tests/corebench/coreutils/coreutils-case-7380cf79-2e636af1/tempworkdir 0  > __res
BasicTester, Testing instance id 26:
Running test command:
/home/ubuntu/spr-fast/tools/coreutils-test.py /home/ubuntu/spr-fast/tests/corebench/coreutils/coreutils-case-7380cf79-2e636af1/tempworkdir/src /home/ubuntu/spr-fast/tests/corebench/coreutils/coreutils-case-7380cf79-2e636af1/tempworkdir/tests /home/ubuntu/spr-fast/tests/corebench/coreutils/coreutils-case-7380cf79-2e636af1/tempworkdir 0  > __res
BasicTester, Testing instance id 27:
Running test command:
/home/ubuntu/spr-fast/tools/coreutils-test.py /home/ubuntu/spr-fast/tests/corebench/coreutils/coreutils-case-7380cf79-2e636af1/tempworkdir/src /home/ubuntu/spr-fast/tests/corebench/coreutils/coreutils-case-7380cf79-2e636af1/tempworkdir/tests /home/ubuntu/spr-fast/tests/corebench/coreutils/coreutils-case-7380cf79-2e636af1/tempworkdir 0  > __res
BasicTester, Testing instance id 28:
Running test command:
/home/ubuntu/spr-fast/tools/coreutils-test.py /home/ubuntu/spr-fast/tests/corebench/coreutils/coreutils-case-7380cf79-2e636af1/tempworkdir/src /home/ubuntu/spr-fast/tests/corebench/coreutils/coreutils-case-7380cf79-2e636af1/tempworkdir/tests /home/ubuntu/spr-fast/tests/corebench/coreutils/coreutils-case-7380cf79-2e636af1/tempworkdir 0  > __res
BasicTester, Testing instance id 29:
Running test command:
/home/ubuntu/spr-fast/tools/coreutils-test.py /home/ubuntu/spr-fast/tests/corebench/coreutils/coreutils-case-7380cf79-2e636af1/tempworkdir/src /home/ubuntu/spr-fast/tests/corebench/coreutils/coreutils-case-7380cf79-2e636af1/tempworkdir/tests /home/ubuntu/spr-fast/tests/corebench/coreutils/coreutils-case-7380cf79-2e636af1/tempworkdir 0  > __res
Counter: 71
Batcher Size:40
Preprocess the following candidate with BasicTester:
Priority 7500
At location src/cut.c:269
--Src File: src/cut.c
Fragment 0:
operating_mode = (8);
return (printable_field[n] >> (i % 8)) & 1;


BasicTester, a patch instance with id 30:
Spawn 1 instances, now Total 71
Counter: 72
Batcher Size:41
Preprocess the following candidate with BasicTester:
Priority 7500
At location src/cut.c:269
--Src File: src/cut.c
Fragment 0:
operating_mode = (byte_mode);
return (printable_field[n] >> (i % 8)) & 1;


BasicTester, a patch instance with id 31:
Spawn 1 instances, now Total 72
Counter: 73
Batcher Size:42
Preprocess the following candidate with BasicTester:
Priority 7500
At location src/cut.c:269
--Src File: src/cut.c
Fragment 0:
max_range_endpoint = (n);
return (printable_field[n] >> (i % 8)) & 1;


BasicTester, a patch instance with id 32:
Spawn 1 instances, now Total 73
Counter: 74
Batcher Size:43
Preprocess the following candidate with BasicTester:
Priority 7500
At location src/cut.c:269
--Src File: src/cut.c
Fragment 0:
operating_mode = (0);
return (printable_field[n] >> (i % 8)) & 1;


BasicTester, a patch instance with id 33:
Spawn 1 instances, now Total 74
Counter: 75
Batcher Size:44
Preprocess the following candidate with BasicTester:
Priority 7500
At location src/cut.c:269
--Src File: src/cut.c
Fragment 0:
operating_mode = (1);
return (printable_field[n] >> (i % 8)) & 1;


BasicTester, a patch instance with id 34:
Spawn 1 instances, now Total 75
Counter: 76
Batcher Size:45
Preprocess the following candidate with BasicTester:
Priority 7500
At location src/cut.c:269
--Src File: src/cut.c
Fragment 0:
max_range_endpoint = 0;
return (printable_field[n] >> (i % 8)) & 1;


BasicTester, a patch instance with id 35:
Spawn 1 instances, now Total 76
Counter: 77
Batcher Size:46
Preprocess the following candidate with BasicTester:
Priority 7500
At location src/cut.c:269
--Src File: src/cut.c
Fragment 0:
max_range_endpoint = rp[i].hi;
return (printable_field[n] >> (i % 8)) & 1;


BasicTester, a patch instance with id 36:
Spawn 1 instances, now Total 77
Counter: 78
Batcher Size:47
Preprocess the following candidate with BasicTester:
Priority 7500
At location src/cut.c:269
--Src File: src/cut.c
Fragment 0:
max_range_endpoint = (1);
return (printable_field[n] >> (i % 8)) & 1;


BasicTester, a patch instance with id 37:
Spawn 1 instances, now Total 78
Counter: 79
Batcher Size:48
Preprocess the following candidate with BasicTester:
Priority 7500
At location src/cut.c:269
--Src File: src/cut.c
Fragment 0:
max_range_endpoint = (8);
return (printable_field[n] >> (i % 8)) & 1;


BasicTester, a patch instance with id 38:
Spawn 1 instances, now Total 79
Counter: 80
Batcher Size:49
Preprocess the following candidate with BasicTester:
Priority 7500
At location src/cut.c:269
--Src File: src/cut.c
Fragment 0:
have_read_stdin = 0;
return (printable_field[n] >> (i % 8)) & 1;


BasicTester, a patch instance with id 39:
Spawn 1 instances, now Total 80
a batched test job starts!
Building:src at:
/home/ubuntu/spr-fast/tests/corebench/coreutils/coreutils-case-7380cf79-2e636af1/tempworkdir/srcMerged code building failed! Going to build saperately!
Building:src at:
/home/ubuntu/spr-fast/tests/corebench/coreutils/coreutils-case-7380cf79-2e636af1/tempworkdir/srcBasicTester, Testing instance id 30:
Running test command:
/home/ubuntu/spr-fast/tools/coreutils-test.py /home/ubuntu/spr-fast/tests/corebench/coreutils/coreutils-case-7380cf79-2e636af1/tempworkdir/src /home/ubuntu/spr-fast/tests/corebench/coreutils/coreutils-case-7380cf79-2e636af1/tempworkdir/tests /home/ubuntu/spr-fast/tests/corebench/coreutils/coreutils-case-7380cf79-2e636af1/tempworkdir 0  > __res
Building:src at:
/home/ubuntu/spr-fast/tests/corebench/coreutils/coreutils-case-7380cf79-2e636af1/tempworkdir/srcBasicTester, Testing instance id 31:
Running test command:
/home/ubuntu/spr-fast/tools/coreutils-test.py /home/ubuntu/spr-fast/tests/corebench/coreutils/coreutils-case-7380cf79-2e636af1/tempworkdir/src /home/ubuntu/spr-fast/tests/corebench/coreutils/coreutils-case-7380cf79-2e636af1/tempworkdir/tests /home/ubuntu/spr-fast/tests/corebench/coreutils/coreutils-case-7380cf79-2e636af1/tempworkdir 0  > __res
Building:src at:
/home/ubuntu/spr-fast/tests/corebench/coreutils/coreutils-case-7380cf79-2e636af1/tempworkdir/srcBasicTester, Testing instance id 32:
Running test command:
/home/ubuntu/spr-fast/tools/coreutils-test.py /home/ubuntu/spr-fast/tests/corebench/coreutils/coreutils-case-7380cf79-2e636af1/tempworkdir/src /home/ubuntu/spr-fast/tests/corebench/coreutils/coreutils-case-7380cf79-2e636af1/tempworkdir/tests /home/ubuntu/spr-fast/tests/corebench/coreutils/coreutils-case-7380cf79-2e636af1/tempworkdir 0  > __res
Building:src at:
/home/ubuntu/spr-fast/tests/corebench/coreutils/coreutils-case-7380cf79-2e636af1/tempworkdir/srcBasicTester, Testing instance id 33:
Running test command:
/home/ubuntu/spr-fast/tools/coreutils-test.py /home/ubuntu/spr-fast/tests/corebench/coreutils/coreutils-case-7380cf79-2e636af1/tempworkdir/src /home/ubuntu/spr-fast/tests/corebench/coreutils/coreutils-case-7380cf79-2e636af1/tempworkdir/tests /home/ubuntu/spr-fast/tests/corebench/coreutils/coreutils-case-7380cf79-2e636af1/tempworkdir 0  > __res
Building:src at:
/home/ubuntu/spr-fast/tests/corebench/coreutils/coreutils-case-7380cf79-2e636af1/tempworkdir/srcBasicTester, Testing instance id 34:
Running test command:
/home/ubuntu/spr-fast/tools/coreutils-test.py /home/ubuntu/spr-fast/tests/corebench/coreutils/coreutils-case-7380cf79-2e636af1/tempworkdir/src /home/ubuntu/spr-fast/tests/corebench/coreutils/coreutils-case-7380cf79-2e636af1/tempworkdir/tests /home/ubuntu/spr-fast/tests/corebench/coreutils/coreutils-case-7380cf79-2e636af1/tempworkdir 0  > __res
Building:src at:
/home/ubuntu/spr-fast/tests/corebench/coreutils/coreutils-case-7380cf79-2e636af1/tempworkdir/srcBasicTester, Testing instance id 35:
Running test command:
/home/ubuntu/spr-fast/tools/coreutils-test.py /home/ubuntu/spr-fast/tests/corebench/coreutils/coreutils-case-7380cf79-2e636af1/tempworkdir/src /home/ubuntu/spr-fast/tests/corebench/coreutils/coreutils-case-7380cf79-2e636af1/tempworkdir/tests /home/ubuntu/spr-fast/tests/corebench/coreutils/coreutils-case-7380cf79-2e636af1/tempworkdir 0  > __res
Building:src at:
/home/ubuntu/spr-fast/tests/corebench/coreutils/coreutils-case-7380cf79-2e636af1/tempworkdir/srcSingle building for Tester 0x2f8cd20 id 36 failed as well!
Building:src at:
/home/ubuntu/spr-fast/tests/corebench/coreutils/coreutils-case-7380cf79-2e636af1/tempworkdir/srcBasicTester, Testing instance id 37:
Running test command:
/home/ubuntu/spr-fast/tools/coreutils-test.py /home/ubuntu/spr-fast/tests/corebench/coreutils/coreutils-case-7380cf79-2e636af1/tempworkdir/src /home/ubuntu/spr-fast/tests/corebench/coreutils/coreutils-case-7380cf79-2e636af1/tempworkdir/tests /home/ubuntu/spr-fast/tests/corebench/coreutils/coreutils-case-7380cf79-2e636af1/tempworkdir 0  > __res
Building:src at:
/home/ubuntu/spr-fast/tests/corebench/coreutils/coreutils-case-7380cf79-2e636af1/tempworkdir/srcBasicTester, Testing instance id 38:
Running test command:
/home/ubuntu/spr-fast/tools/coreutils-test.py /home/ubuntu/spr-fast/tests/corebench/coreutils/coreutils-case-7380cf79-2e636af1/tempworkdir/src /home/ubuntu/spr-fast/tests/corebench/coreutils/coreutils-case-7380cf79-2e636af1/tempworkdir/tests /home/ubuntu/spr-fast/tests/corebench/coreutils/coreutils-case-7380cf79-2e636af1/tempworkdir 0  > __res
Building:src at:
/home/ubuntu/spr-fast/tests/corebench/coreutils/coreutils-case-7380cf79-2e636af1/tempworkdir/srcBasicTester, Testing instance id 39:
Running test command:
/home/ubuntu/spr-fast/tools/coreutils-test.py /home/ubuntu/spr-fast/tests/corebench/coreutils/coreutils-case-7380cf79-2e636af1/tempworkdir/src /home/ubuntu/spr-fast/tests/corebench/coreutils/coreutils-case-7380cf79-2e636af1/tempworkdir/tests /home/ubuntu/spr-fast/tests/corebench/coreutils/coreutils-case-7380cf79-2e636af1/tempworkdir 0  > __res
Counter: 81
Batcher Size:40
Preprocess the following candidate with BasicTester:
Priority 7500
At location src/cut.c:269
--Src File: src/cut.c
Fragment 0:
mark_range_start(eol_range_start);
return (printable_field[n] >> (i % 8)) & 1;


BasicTester, a patch instance with id 40:
Spawn 1 instances, now Total 81
Counter: 82
Batcher Size:41
Preprocess the following candidate with BasicTester:
Priority 7500
At location src/cut.c:269
--Src File: src/cut.c
Fragment 0:
max_range_endpoint = (0);
return (printable_field[n] >> (i % 8)) & 1;


BasicTester, a patch instance with id 41:
Spawn 1 instances, now Total 82
Counter: 83
Batcher Size:42
Preprocess the following candidate with BasicTester:
Priority 7500
At location src/cut.c:269
--Src File: src/cut.c
Fragment 0:
have_read_stdin = 1;
return (printable_field[n] >> (i % 8)) & 1;


BasicTester, a patch instance with id 42:
Spawn 1 instances, now Total 83
Counter: 84
Batcher Size:43
Preprocess the following candidate with BasicTester:
Priority 7500
At location src/cut.c:269
--Src File: src/cut.c
Fragment 0:
if (output_delimiter_specified && !complement && eol_range_start && !is_printable_field(eol_range_start))
    mark_range_start(eol_range_start);
return (printable_field[n] >> (i % 8)) & 1;


BasicTester, a patch instance with id 43:
Spawn 1 instances, now Total 84
Counter: 85
Batcher Size:44
Preprocess the following candidate with BasicTester:
Priority 7500
At location src/cut.c:269
--Src File: src/cut.c
Fragment 0:
if (output_delimiter_specified) {
}
return (printable_field[n] >> (i % 8)) & 1;


BasicTester, a patch instance with id 44:
Spawn 1 instances, now Total 85
Counter: 86
Batcher Size:45
Preprocess the following candidate with BasicTester:
Priority 7500
At location src/cut.c:269
--Src File: src/cut.c
Fragment 0:
free(field_1_buffer);
return (printable_field[n] >> (i % 8)) & 1;


BasicTester, a patch instance with id 45:
Spawn 1 instances, now Total 86
Counter: 87
Batcher Size:46
Preprocess the following candidate with BasicTester:
Priority 7500
At location src/cut.c:269
--Src File: src/cut.c
Fragment 0:
field_1_buffer = ((void *)0);
return (printable_field[n] >> (i % 8)) & 1;


BasicTester, a patch instance with id 46:
Spawn 1 instances, now Total 87
Counter: 88
Batcher Size:47
Preprocess the following candidate with BasicTester:
Priority 7500
At location src/cut.c:269
--Src File: src/cut.c
Fragment 0:
exit(0);
return (printable_field[n] >> (i % 8)) & 1;


BasicTester, a patch instance with id 47:
Spawn 1 instances, now Total 88
Counter: 89
Batcher Size:48
Preprocess the following candidate with BasicTester:
Priority 7500
At location src/cut.c:269
--Src File: src/cut.c
Fragment 0:
exit(1);
return (printable_field[n] >> (i % 8)) & 1;


BasicTester, a patch instance with id 48:
Spawn 1 instances, now Total 89
Counter: 90
Batcher Size:49
Preprocess the following candidate with BasicTester:
Priority 7500
At location src/cut.c:269
--Src File: src/cut.c
Fragment 0:
eol_range_start = (8);
return (printable_field[n] >> (i % 8)) & 1;


BasicTester, a patch instance with id 49:
Spawn 1 instances, now Total 90
a batched test job starts!
Building:src at:
/home/ubuntu/spr-fast/tests/corebench/coreutils/coreutils-case-7380cf79-2e636af1/tempworkdir/srcMerged code building succ, going to invoke tester!
BasicTester, Testing instance id 40:
Running test command:
/home/ubuntu/spr-fast/tools/coreutils-test.py /home/ubuntu/spr-fast/tests/corebench/coreutils/coreutils-case-7380cf79-2e636af1/tempworkdir/src /home/ubuntu/spr-fast/tests/corebench/coreutils/coreutils-case-7380cf79-2e636af1/tempworkdir/tests /home/ubuntu/spr-fast/tests/corebench/coreutils/coreutils-case-7380cf79-2e636af1/tempworkdir 0  > __res
BasicTester, Testing instance id 41:
Running test command:
/home/ubuntu/spr-fast/tools/coreutils-test.py /home/ubuntu/spr-fast/tests/corebench/coreutils/coreutils-case-7380cf79-2e636af1/tempworkdir/src /home/ubuntu/spr-fast/tests/corebench/coreutils/coreutils-case-7380cf79-2e636af1/tempworkdir/tests /home/ubuntu/spr-fast/tests/corebench/coreutils/coreutils-case-7380cf79-2e636af1/tempworkdir 0  > __res
BasicTester, Testing instance id 42:
Running test command:
/home/ubuntu/spr-fast/tools/coreutils-test.py /home/ubuntu/spr-fast/tests/corebench/coreutils/coreutils-case-7380cf79-2e636af1/tempworkdir/src /home/ubuntu/spr-fast/tests/corebench/coreutils/coreutils-case-7380cf79-2e636af1/tempworkdir/tests /home/ubuntu/spr-fast/tests/corebench/coreutils/coreutils-case-7380cf79-2e636af1/tempworkdir 0  > __res
BasicTester, Testing instance id 43:
Running test command:
/home/ubuntu/spr-fast/tools/coreutils-test.py /home/ubuntu/spr-fast/tests/corebench/coreutils/coreutils-case-7380cf79-2e636af1/tempworkdir/src /home/ubuntu/spr-fast/tests/corebench/coreutils/coreutils-case-7380cf79-2e636af1/tempworkdir/tests /home/ubuntu/spr-fast/tests/corebench/coreutils/coreutils-case-7380cf79-2e636af1/tempworkdir 0  > __res
BasicTester, Testing instance id 44:
Running test command:
/home/ubuntu/spr-fast/tools/coreutils-test.py /home/ubuntu/spr-fast/tests/corebench/coreutils/coreutils-case-7380cf79-2e636af1/tempworkdir/src /home/ubuntu/spr-fast/tests/corebench/coreutils/coreutils-case-7380cf79-2e636af1/tempworkdir/tests /home/ubuntu/spr-fast/tests/corebench/coreutils/coreutils-case-7380cf79-2e636af1/tempworkdir 0  > __res
BasicTester, Testing instance id 45:
Running test command:
/home/ubuntu/spr-fast/tools/coreutils-test.py /home/ubuntu/spr-fast/tests/corebench/coreutils/coreutils-case-7380cf79-2e636af1/tempworkdir/src /home/ubuntu/spr-fast/tests/corebench/coreutils/coreutils-case-7380cf79-2e636af1/tempworkdir/tests /home/ubuntu/spr-fast/tests/corebench/coreutils/coreutils-case-7380cf79-2e636af1/tempworkdir 0  > __res
BasicTester, Testing instance id 46:
Running test command:
/home/ubuntu/spr-fast/tools/coreutils-test.py /home/ubuntu/spr-fast/tests/corebench/coreutils/coreutils-case-7380cf79-2e636af1/tempworkdir/src /home/ubuntu/spr-fast/tests/corebench/coreutils/coreutils-case-7380cf79-2e636af1/tempworkdir/tests /home/ubuntu/spr-fast/tests/corebench/coreutils/coreutils-case-7380cf79-2e636af1/tempworkdir 0  > __res
BasicTester, Testing instance id 47:
Running test command:
/home/ubuntu/spr-fast/tools/coreutils-test.py /home/ubuntu/spr-fast/tests/corebench/coreutils/coreutils-case-7380cf79-2e636af1/tempworkdir/src /home/ubuntu/spr-fast/tests/corebench/coreutils/coreutils-case-7380cf79-2e636af1/tempworkdir/tests /home/ubuntu/spr-fast/tests/corebench/coreutils/coreutils-case-7380cf79-2e636af1/tempworkdir 0  > __res
Passed Negative Cases with BasicTester
Running test command:
/home/ubuntu/spr-fast/tools/coreutils-test.py /home/ubuntu/spr-fast/tests/corebench/coreutils/coreutils-case-7380cf79-2e636af1/tempworkdir/src /home/ubuntu/spr-fast/tests/corebench/coreutils/coreutils-case-7380cf79-2e636af1/tempworkdir/tests /home/ubuntu/spr-fast/tests/corebench/coreutils/coreutils-case-7380cf79-2e636af1/tempworkdir 3  > __res
Running test command:
/home/ubuntu/spr-fast/tools/coreutils-test.py /home/ubuntu/spr-fast/tests/corebench/coreutils/coreutils-case-7380cf79-2e636af1/tempworkdir/src /home/ubuntu/spr-fast/tests/corebench/coreutils/coreutils-case-7380cf79-2e636af1/tempworkdir/tests /home/ubuntu/spr-fast/tests/corebench/coreutils/coreutils-case-7380cf79-2e636af1/tempworkdir 4  > __res
Running test command:
/home/ubuntu/spr-fast/tools/coreutils-test.py /home/ubuntu/spr-fast/tests/corebench/coreutils/coreutils-case-7380cf79-2e636af1/tempworkdir/src /home/ubuntu/spr-fast/tests/corebench/coreutils/coreutils-case-7380cf79-2e636af1/tempworkdir/tests /home/ubuntu/spr-fast/tests/corebench/coreutils/coreutils-case-7380cf79-2e636af1/tempworkdir 7  > __res
Running test command:
/home/ubuntu/spr-fast/tools/coreutils-test.py /home/ubuntu/spr-fast/tests/corebench/coreutils/coreutils-case-7380cf79-2e636af1/tempworkdir/src /home/ubuntu/spr-fast/tests/corebench/coreutils/coreutils-case-7380cf79-2e636af1/tempworkdir/tests /home/ubuntu/spr-fast/tests/corebench/coreutils/coreutils-case-7380cf79-2e636af1/tempworkdir 8  > __res
Running test command:
/home/ubuntu/spr-fast/tools/coreutils-test.py /home/ubuntu/spr-fast/tests/corebench/coreutils/coreutils-case-7380cf79-2e636af1/tempworkdir/src /home/ubuntu/spr-fast/tests/corebench/coreutils/coreutils-case-7380cf79-2e636af1/tempworkdir/tests /home/ubuntu/spr-fast/tests/corebench/coreutils/coreutils-case-7380cf79-2e636af1/tempworkdir 10  > __res
Running test command:
/home/ubuntu/spr-fast/tools/coreutils-test.py /home/ubuntu/spr-fast/tests/corebench/coreutils/coreutils-case-7380cf79-2e636af1/tempworkdir/src /home/ubuntu/spr-fast/tests/corebench/coreutils/coreutils-case-7380cf79-2e636af1/tempworkdir/tests /home/ubuntu/spr-fast/tests/corebench/coreutils/coreutils-case-7380cf79-2e636af1/tempworkdir 14  > __res
Running test command:
/home/ubuntu/spr-fast/tools/coreutils-test.py /home/ubuntu/spr-fast/tests/corebench/coreutils/coreutils-case-7380cf79-2e636af1/tempworkdir/src /home/ubuntu/spr-fast/tests/corebench/coreutils/coreutils-case-7380cf79-2e636af1/tempworkdir/tests /home/ubuntu/spr-fast/tests/corebench/coreutils/coreutils-case-7380cf79-2e636af1/tempworkdir 16  > __res
Running test command:
/home/ubuntu/spr-fast/tools/coreutils-test.py /home/ubuntu/spr-fast/tests/corebench/coreutils/coreutils-case-7380cf79-2e636af1/tempworkdir/src /home/ubuntu/spr-fast/tests/corebench/coreutils/coreutils-case-7380cf79-2e636af1/tempworkdir/tests /home/ubuntu/spr-fast/tests/corebench/coreutils/coreutils-case-7380cf79-2e636af1/tempworkdir 18  > __res
Running test command:
/home/ubuntu/spr-fast/tools/coreutils-test.py /home/ubuntu/spr-fast/tests/corebench/coreutils/coreutils-case-7380cf79-2e636af1/tempworkdir/src /home/ubuntu/spr-fast/tests/corebench/coreutils/coreutils-case-7380cf79-2e636af1/tempworkdir/tests /home/ubuntu/spr-fast/tests/corebench/coreutils/coreutils-case-7380cf79-2e636af1/tempworkdir 19  > __res
Failed positive case 19
BasicTester, Testing instance id 48:
Running test command:
/home/ubuntu/spr-fast/tools/coreutils-test.py /home/ubuntu/spr-fast/tests/corebench/coreutils/coreutils-case-7380cf79-2e636af1/tempworkdir/src /home/ubuntu/spr-fast/tests/corebench/coreutils/coreutils-case-7380cf79-2e636af1/tempworkdir/tests /home/ubuntu/spr-fast/tests/corebench/coreutils/coreutils-case-7380cf79-2e636af1/tempworkdir 0  > __res
BasicTester, Testing instance id 49:
Running test command:
/home/ubuntu/spr-fast/tools/coreutils-test.py /home/ubuntu/spr-fast/tests/corebench/coreutils/coreutils-case-7380cf79-2e636af1/tempworkdir/src /home/ubuntu/spr-fast/tests/corebench/coreutils/coreutils-case-7380cf79-2e636af1/tempworkdir/tests /home/ubuntu/spr-fast/tests/corebench/coreutils/coreutils-case-7380cf79-2e636af1/tempworkdir 0  > __res
Counter: 91
Batcher Size:40
Preprocess the following candidate with BasicTester:
Priority 7500
At location src/cut.c:269
--Src File: src/cut.c
Fragment 0:
eol_range_start = (i);
return (printable_field[n] >> (i % 8)) & 1;


BasicTester, a patch instance with id 50:
Spawn 1 instances, now Total 91
Counter: 92
Batcher Size:41
Preprocess the following candidate with BasicTester:
Priority 7500
At location src/cut.c:269
--Src File: src/cut.c
Fragment 0:
eol_range_start = (n);
return (printable_field[n] >> (i % 8)) & 1;


BasicTester, a patch instance with id 51:
Spawn 1 instances, now Total 92
Counter: 93
Batcher Size:42
Preprocess the following candidate with BasicTester:
Priority 7500
At location src/cut.c:269
--Src File: src/cut.c
Fragment 0:
error(0, (*__errno_location()), "-");
return (printable_field[n] >> (i % 8)) & 1;


BasicTester, a patch instance with id 52:
Spawn 1 instances, now Total 93
Counter: 94
Batcher Size:43
Preprocess the following candidate with BasicTester:
Priority 7465
At location src/cut.c:363
--Src File: src/cut.c
Fragment 0:
suppress_non_delimited = (lhs_specified);
while (1)
    {
        if (*fieldstr == '-') {
            in_digits = 0;
            if (dash_found)
                do {
                    error(0, 0, (gettext("invalid byte or field list")));
                    usage(1);
                } while (0);
            dash_found = 1;
            fieldstr++;
            initial = (lhs_specified ? value : 1);
            value = 0;
        } else if (*fieldstr == ',' || ((*__ctype_b_loc())[(int)((to_uchar(*fieldstr)))] & (unsigned short)_ISblank) || *fieldstr == '\x00') {
            in_digits = 0;
            if (dash_found) {
                dash_found = 0;
                if (!lhs_specified && !rhs_specified)
                    do {
                        error(0, 0, (gettext("invalid range with no endpoint: -")));
                        usage(1);
                    } while (0);
                if (!rhs_specified) {
                    eol_range_start = initial;
                    field_found = 1;
                } else {
                    if (value < initial)
                        do {
                            error(0, 0, (gettext("invalid decreasing range")));
                            usage(1);
                        } while (0);
                    if (eol_range_start != 0) {
                        if (initial < eol_range_start) {
                            if (eol_range_start <= value) {
                                eol_range_start = initial;
                            } else {
                                do {
                                    if (initial == 0 || value == 0)
                                        do {
                                            error(0, 0, (gettext("fields and positions are numbered from 1")));
                                            usage(1);
                                        } while (0);
                                    if (n_rp >= n_rp_allocated) {
                                        (rp) = x2nrealloc(rp, &n_rp_allocated, sizeof *(rp));
                                    }
                                    rp[n_rp].lo = (initial);
                                    rp[n_rp].hi = (value);
                                    ++n_rp;
                                } while (0);
                            }
                            field_found = 1;
                        }
                    } else {
                        do {
                            if (initial == 0 || value == 0)
                                do {
                                    error(0, 0, (gettext("fields and positions are numbered from 1")));
                                    usage(1);
                                } while (0);
                            if (n_rp >= n_rp_allocated) {
                                (rp) = x2nrealloc(rp, &n_rp_allocated, sizeof *(rp));
                            }
                            rp[n_rp].lo = (initial);
                            rp[n_rp].hi = (value);
                            ++n_rp;
                        } while (0);
                        field_found = 1;
                    }
                    value = 0;
                }
            } else {
                do {
                    if (value == 0 || value == 0)
                        do {
                            error(0, 0, (gettext("fields and positions are numbered from 1")));
                            usage(1);
                        } while (0);
                    if (n_rp >= n_rp_allocated) {
                        (rp) = x2nrealloc(rp, &n_rp_allocated, sizeof *(rp));
                    }
                    rp[n_rp].lo = (value);
                    rp[n_rp].hi = (value);
                    ++n_rp;
                } while (0);
                value = 0;
                field_found = 1;
            }
            if (*fieldstr == '\x00') {
                break;
            }
            fieldstr++;
            lhs_specified = 0;
            rhs_specified = 0;
        } else if (((unsigned int)(*fieldstr) - '0' <= 9)) {
            static const char *num_start;
            if (!in_digits || !num_start)
                num_start = fieldstr;
            in_digits = 1;
            if (dash_found)
                rhs_specified = 1;
            else
                lhs_specified = 1;
            if (!((void)(&(value) == (size_t *)((void *)0)) , (((size_t)-1 / 10 < (value) || (size_t)((value) * 10 + (*fieldstr - '0')) < (value)) ? 0 : (((value) = (value) * 10 + (*fieldstr - '0')) , 1)))) {
                size_t len = strspn(num_start, "0123456789");
                char *bad_num = xstrndup(num_start, len);
                if (operating_mode == byte_mode)
                    error(0, 0, gettext("byte offset %s is too large"), quote(bad_num));
                else
                    error(0, 0, gettext("field number %s is too large"), quote(bad_num));
                free(bad_num);
                exit(1);
            }
            fieldstr++;
        } else
            do {
                error(0, 0, (gettext("invalid byte or field list")));
                usage(1);
            } while (0);
    }


BasicTester, a patch instance with id 53:
Spawn 1 instances, now Total 94
Counter: 95
Batcher Size:44
Preprocess the following candidate with BasicTester:
Priority 7465
At location src/cut.c:363
--Src File: src/cut.c
Fragment 0:
value = (9);
while (1)
    {
        if (*fieldstr == '-') {
            in_digits = 0;
            if (dash_found)
                do {
                    error(0, 0, (gettext("invalid byte or field list")));
                    usage(1);
                } while (0);
            dash_found = 1;
            fieldstr++;
            initial = (lhs_specified ? value : 1);
            value = 0;
        } else if (*fieldstr == ',' || ((*__ctype_b_loc())[(int)((to_uchar(*fieldstr)))] & (unsigned short)_ISblank) || *fieldstr == '\x00') {
            in_digits = 0;
            if (dash_found) {
                dash_found = 0;
                if (!lhs_specified && !rhs_specified)
                    do {
                        error(0, 0, (gettext("invalid range with no endpoint: -")));
                        usage(1);
                    } while (0);
                if (!rhs_specified) {
                    eol_range_start = initial;
                    field_found = 1;
                } else {
                    if (value < initial)
                        do {
                            error(0, 0, (gettext("invalid decreasing range")));
                            usage(1);
                        } while (0);
                    if (eol_range_start != 0) {
                        if (initial < eol_range_start) {
                            if (eol_range_start <= value) {
                                eol_range_start = initial;
                            } else {
                                do {
                                    if (initial == 0 || value == 0)
                                        do {
                                            error(0, 0, (gettext("fields and positions are numbered from 1")));
                                            usage(1);
                                        } while (0);
                                    if (n_rp >= n_rp_allocated) {
                                        (rp) = x2nrealloc(rp, &n_rp_allocated, sizeof *(rp));
                                    }
                                    rp[n_rp].lo = (initial);
                                    rp[n_rp].hi = (value);
                                    ++n_rp;
                                } while (0);
                            }
                            field_found = 1;
                        }
                    } else {
                        do {
                            if (initial == 0 || value == 0)
                                do {
                                    error(0, 0, (gettext("fields and positions are numbered from 1")));
                                    usage(1);
                                } while (0);
                            if (n_rp >= n_rp_allocated) {
                                (rp) = x2nrealloc(rp, &n_rp_allocated, sizeof *(rp));
                            }
                            rp[n_rp].lo = (initial);
                            rp[n_rp].hi = (value);
                            ++n_rp;
                        } while (0);
                        field_found = 1;
                    }
                    value = 0;
                }
            } else {
                do {
                    if (value == 0 || value == 0)
                        do {
                            error(0, 0, (gettext("fields and positions are numbered from 1")));
                            usage(1);
                        } while (0);
                    if (n_rp >= n_rp_allocated) {
                        (rp) = x2nrealloc(rp, &n_rp_allocated, sizeof *(rp));
                    }
                    rp[n_rp].lo = (value);
                    rp[n_rp].hi = (value);
                    ++n_rp;
                } while (0);
                value = 0;
                field_found = 1;
            }
            if (*fieldstr == '\x00') {
                break;
            }
            fieldstr++;
            lhs_specified = 0;
            rhs_specified = 0;
        } else if (((unsigned int)(*fieldstr) - '0' <= 9)) {
            static const char *num_start;
            if (!in_digits || !num_start)
                num_start = fieldstr;
            in_digits = 1;
            if (dash_found)
                rhs_specified = 1;
            else
                lhs_specified = 1;
            if (!((void)(&(value) == (size_t *)((void *)0)) , (((size_t)-1 / 10 < (value) || (size_t)((value) * 10 + (*fieldstr - '0')) < (value)) ? 0 : (((value) = (value) * 10 + (*fieldstr - '0')) , 1)))) {
                size_t len = strspn(num_start, "0123456789");
                char *bad_num = xstrndup(num_start, len);
                if (operating_mode == byte_mode)
                    error(0, 0, gettext("byte offset %s is too large"), quote(bad_num));
                else
                    error(0, 0, gettext("field number %s is too large"), quote(bad_num));
                free(bad_num);
                exit(1);
            }
            fieldstr++;
        } else
            do {
                error(0, 0, (gettext("invalid byte or field list")));
                usage(1);
            } while (0);
    }


BasicTester, a patch instance with id 54:
Spawn 1 instances, now Total 95
Counter: 96
Batcher Size:45
Preprocess the following candidate with BasicTester:
Priority 7465
At location src/cut.c:363
--Src File: src/cut.c
Fragment 0:
value = (n_rp_allocated);
while (1)
    {
        if (*fieldstr == '-') {
            in_digits = 0;
            if (dash_found)
                do {
                    error(0, 0, (gettext("invalid byte or field list")));
                    usage(1);
                } while (0);
            dash_found = 1;
            fieldstr++;
            initial = (lhs_specified ? value : 1);
            value = 0;
        } else if (*fieldstr == ',' || ((*__ctype_b_loc())[(int)((to_uchar(*fieldstr)))] & (unsigned short)_ISblank) || *fieldstr == '\x00') {
            in_digits = 0;
            if (dash_found) {
                dash_found = 0;
                if (!lhs_specified && !rhs_specified)
                    do {
                        error(0, 0, (gettext("invalid range with no endpoint: -")));
                        usage(1);
                    } while (0);
                if (!rhs_specified) {
                    eol_range_start = initial;
                    field_found = 1;
                } else {
                    if (value < initial)
                        do {
                            error(0, 0, (gettext("invalid decreasing range")));
                            usage(1);
                        } while (0);
                    if (eol_range_start != 0) {
                        if (initial < eol_range_start) {
                            if (eol_range_start <= value) {
                                eol_range_start = initial;
                            } else {
                                do {
                                    if (initial == 0 || value == 0)
                                        do {
                                            error(0, 0, (gettext("fields and positions are numbered from 1")));
                                            usage(1);
                                        } while (0);
                                    if (n_rp >= n_rp_allocated) {
                                        (rp) = x2nrealloc(rp, &n_rp_allocated, sizeof *(rp));
                                    }
                                    rp[n_rp].lo = (initial);
                                    rp[n_rp].hi = (value);
                                    ++n_rp;
                                } while (0);
                            }
                            field_found = 1;
                        }
                    } else {
                        do {
                            if (initial == 0 || value == 0)
                                do {
                                    error(0, 0, (gettext("fields and positions are numbered from 1")));
                                    usage(1);
                                } while (0);
                            if (n_rp >= n_rp_allocated) {
                                (rp) = x2nrealloc(rp, &n_rp_allocated, sizeof *(rp));
                            }
                            rp[n_rp].lo = (initial);
                            rp[n_rp].hi = (value);
                            ++n_rp;
                        } while (0);
                        field_found = 1;
                    }
                    value = 0;
                }
            } else {
                do {
                    if (value == 0 || value == 0)
                        do {
                            error(0, 0, (gettext("fields and positions are numbered from 1")));
                            usage(1);
                        } while (0);
                    if (n_rp >= n_rp_allocated) {
                        (rp) = x2nrealloc(rp, &n_rp_allocated, sizeof *(rp));
                    }
                    rp[n_rp].lo = (value);
                    rp[n_rp].hi = (value);
                    ++n_rp;
                } while (0);
                value = 0;
                field_found = 1;
            }
            if (*fieldstr == '\x00') {
                break;
            }
            fieldstr++;
            lhs_specified = 0;
            rhs_specified = 0;
        } else if (((unsigned int)(*fieldstr) - '0' <= 9)) {
            static const char *num_start;
            if (!in_digits || !num_start)
                num_start = fieldstr;
            in_digits = 1;
            if (dash_found)
                rhs_specified = 1;
            else
                lhs_specified = 1;
            if (!((void)(&(value) == (size_t *)((void *)0)) , (((size_t)-1 / 10 < (value) || (size_t)((value) * 10 + (*fieldstr - '0')) < (value)) ? 0 : (((value) = (value) * 10 + (*fieldstr - '0')) , 1)))) {
                size_t len = strspn(num_start, "0123456789");
                char *bad_num = xstrndup(num_start, len);
                if (operating_mode == byte_mode)
                    error(0, 0, gettext("byte offset %s is too large"), quote(bad_num));
                else
                    error(0, 0, gettext("field number %s is too large"), quote(bad_num));
                free(bad_num);
                exit(1);
            }
            fieldstr++;
        } else
            do {
                error(0, 0, (gettext("invalid byte or field list")));
                usage(1);
            } while (0);
    }


BasicTester, a patch instance with id 55:
Spawn 1 instances, now Total 96
Counter: 97
Batcher Size:46
Preprocess the following candidate with BasicTester:
Priority 7465
At location src/cut.c:363
--Src File: src/cut.c
Fragment 0:
value = 0;
while (1)
    {
        if (*fieldstr == '-') {
            in_digits = 0;
            if (dash_found)
                do {
                    error(0, 0, (gettext("invalid byte or field list")));
                    usage(1);
                } while (0);
            dash_found = 1;
            fieldstr++;
            initial = (lhs_specified ? value : 1);
            value = 0;
        } else if (*fieldstr == ',' || ((*__ctype_b_loc())[(int)((to_uchar(*fieldstr)))] & (unsigned short)_ISblank) || *fieldstr == '\x00') {
            in_digits = 0;
            if (dash_found) {
                dash_found = 0;
                if (!lhs_specified && !rhs_specified)
                    do {
                        error(0, 0, (gettext("invalid range with no endpoint: -")));
                        usage(1);
                    } while (0);
                if (!rhs_specified) {
                    eol_range_start = initial;
                    field_found = 1;
                } else {
                    if (value < initial)
                        do {
                            error(0, 0, (gettext("invalid decreasing range")));
                            usage(1);
                        } while (0);
                    if (eol_range_start != 0) {
                        if (initial < eol_range_start) {
                            if (eol_range_start <= value) {
                                eol_range_start = initial;
                            } else {
                                do {
                                    if (initial == 0 || value == 0)
                                        do {
                                            error(0, 0, (gettext("fields and positions are numbered from 1")));
                                            usage(1);
                                        } while (0);
                                    if (n_rp >= n_rp_allocated) {
                                        (rp) = x2nrealloc(rp, &n_rp_allocated, sizeof *(rp));
                                    }
                                    rp[n_rp].lo = (initial);
                                    rp[n_rp].hi = (value);
                                    ++n_rp;
                                } while (0);
                            }
                            field_found = 1;
                        }
                    } else {
                        do {
                            if (initial == 0 || value == 0)
                                do {
                                    error(0, 0, (gettext("fields and positions are numbered from 1")));
                                    usage(1);
                                } while (0);
                            if (n_rp >= n_rp_allocated) {
                                (rp) = x2nrealloc(rp, &n_rp_allocated, sizeof *(rp));
                            }
                            rp[n_rp].lo = (initial);
                            rp[n_rp].hi = (value);
                            ++n_rp;
                        } while (0);
                        field_found = 1;
                    }
                    value = 0;
                }
            } else {
                do {
                    if (value == 0 || value == 0)
                        do {
                            error(0, 0, (gettext("fields and positions are numbered from 1")));
                            usage(1);
                        } while (0);
                    if (n_rp >= n_rp_allocated) {
                        (rp) = x2nrealloc(rp, &n_rp_allocated, sizeof *(rp));
                    }
                    rp[n_rp].lo = (value);
                    rp[n_rp].hi = (value);
                    ++n_rp;
                } while (0);
                value = 0;
                field_found = 1;
            }
            if (*fieldstr == '\x00') {
                break;
            }
            fieldstr++;
            lhs_specified = 0;
            rhs_specified = 0;
        } else if (((unsigned int)(*fieldstr) - '0' <= 9)) {
            static const char *num_start;
            if (!in_digits || !num_start)
                num_start = fieldstr;
            in_digits = 1;
            if (dash_found)
                rhs_specified = 1;
            else
                lhs_specified = 1;
            if (!((void)(&(value) == (size_t *)((void *)0)) , (((size_t)-1 / 10 < (value) || (size_t)((value) * 10 + (*fieldstr - '0')) < (value)) ? 0 : (((value) = (value) * 10 + (*fieldstr - '0')) , 1)))) {
                size_t len = strspn(num_start, "0123456789");
                char *bad_num = xstrndup(num_start, len);
                if (operating_mode == byte_mode)
                    error(0, 0, gettext("byte offset %s is too large"), quote(bad_num));
                else
                    error(0, 0, gettext("field number %s is too large"), quote(bad_num));
                free(bad_num);
                exit(1);
            }
            fieldstr++;
        } else
            do {
                error(0, 0, (gettext("invalid byte or field list")));
                usage(1);
            } while (0);
    }


BasicTester, a patch instance with id 56:
Spawn 1 instances, now Total 97
Counter: 98
Batcher Size:47
Preprocess the following candidate with BasicTester:
Priority 7465
At location src/cut.c:363
--Src File: src/cut.c
Fragment 0:
xalloc_die();
while (1)
    {
        if (*fieldstr == '-') {
            in_digits = 0;
            if (dash_found)
                do {
                    error(0, 0, (gettext("invalid byte or field list")));
                    usage(1);
                } while (0);
            dash_found = 1;
            fieldstr++;
            initial = (lhs_specified ? value : 1);
            value = 0;
        } else if (*fieldstr == ',' || ((*__ctype_b_loc())[(int)((to_uchar(*fieldstr)))] & (unsigned short)_ISblank) || *fieldstr == '\x00') {
            in_digits = 0;
            if (dash_found) {
                dash_found = 0;
                if (!lhs_specified && !rhs_specified)
                    do {
                        error(0, 0, (gettext("invalid range with no endpoint: -")));
                        usage(1);
                    } while (0);
                if (!rhs_specified) {
                    eol_range_start = initial;
                    field_found = 1;
                } else {
                    if (value < initial)
                        do {
                            error(0, 0, (gettext("invalid decreasing range")));
                            usage(1);
                        } while (0);
                    if (eol_range_start != 0) {
                        if (initial < eol_range_start) {
                            if (eol_range_start <= value) {
                                eol_range_start = initial;
                            } else {
                                do {
                                    if (initial == 0 || value == 0)
                                        do {
                                            error(0, 0, (gettext("fields and positions are numbered from 1")));
                                            usage(1);
                                        } while (0);
                                    if (n_rp >= n_rp_allocated) {
                                        (rp) = x2nrealloc(rp, &n_rp_allocated, sizeof *(rp));
                                    }
                                    rp[n_rp].lo = (initial);
                                    rp[n_rp].hi = (value);
                                    ++n_rp;
                                } while (0);
                            }
                            field_found = 1;
                        }
                    } else {
                        do {
                            if (initial == 0 || value == 0)
                                do {
                                    error(0, 0, (gettext("fields and positions are numbered from 1")));
                                    usage(1);
                                } while (0);
                            if (n_rp >= n_rp_allocated) {
                                (rp) = x2nrealloc(rp, &n_rp_allocated, sizeof *(rp));
                            }
                            rp[n_rp].lo = (initial);
                            rp[n_rp].hi = (value);
                            ++n_rp;
                        } while (0);
                        field_found = 1;
                    }
                    value = 0;
                }
            } else {
                do {
                    if (value == 0 || value == 0)
                        do {
                            error(0, 0, (gettext("fields and positions are numbered from 1")));
                            usage(1);
                        } while (0);
                    if (n_rp >= n_rp_allocated) {
                        (rp) = x2nrealloc(rp, &n_rp_allocated, sizeof *(rp));
                    }
                    rp[n_rp].lo = (value);
                    rp[n_rp].hi = (value);
                    ++n_rp;
                } while (0);
                value = 0;
                field_found = 1;
            }
            if (*fieldstr == '\x00') {
                break;
            }
            fieldstr++;
            lhs_specified = 0;
            rhs_specified = 0;
        } else if (((unsigned int)(*fieldstr) - '0' <= 9)) {
            static const char *num_start;
            if (!in_digits || !num_start)
                num_start = fieldstr;
            in_digits = 1;
            if (dash_found)
                rhs_specified = 1;
            else
                lhs_specified = 1;
            if (!((void)(&(value) == (size_t *)((void *)0)) , (((size_t)-1 / 10 < (value) || (size_t)((value) * 10 + (*fieldstr - '0')) < (value)) ? 0 : (((value) = (value) * 10 + (*fieldstr - '0')) , 1)))) {
                size_t len = strspn(num_start, "0123456789");
                char *bad_num = xstrndup(num_start, len);
                if (operating_mode == byte_mode)
                    error(0, 0, gettext("byte offset %s is too large"), quote(bad_num));
                else
                    error(0, 0, gettext("field number %s is too large"), quote(bad_num));
                free(bad_num);
                exit(1);
            }
            fieldstr++;
        } else
            do {
                error(0, 0, (gettext("invalid byte or field list")));
                usage(1);
            } while (0);
    }


BasicTester, a patch instance with id 57:
Spawn 1 instances, now Total 98
Counter: 99
Batcher Size:48
Preprocess the following candidate with BasicTester:
Priority 7465
At location src/cut.c:363
--Src File: src/cut.c
Fragment 0:
value = (value);
while (1)
    {
        if (*fieldstr == '-') {
            in_digits = 0;
            if (dash_found)
                do {
                    error(0, 0, (gettext("invalid byte or field list")));
                    usage(1);
                } while (0);
            dash_found = 1;
            fieldstr++;
            initial = (lhs_specified ? value : 1);
            value = 0;
        } else if (*fieldstr == ',' || ((*__ctype_b_loc())[(int)((to_uchar(*fieldstr)))] & (unsigned short)_ISblank) || *fieldstr == '\x00') {
            in_digits = 0;
            if (dash_found) {
                dash_found = 0;
                if (!lhs_specified && !rhs_specified)
                    do {
                        error(0, 0, (gettext("invalid range with no endpoint: -")));
                        usage(1);
                    } while (0);
                if (!rhs_specified) {
                    eol_range_start = initial;
                    field_found = 1;
                } else {
                    if (value < initial)
                        do {
                            error(0, 0, (gettext("invalid decreasing range")));
                            usage(1);
                        } while (0);
                    if (eol_range_start != 0) {
                        if (initial < eol_range_start) {
                            if (eol_range_start <= value) {
                                eol_range_start = initial;
                            } else {
                                do {
                                    if (initial == 0 || value == 0)
                                        do {
                                            error(0, 0, (gettext("fields and positions are numbered from 1")));
                                            usage(1);
                                        } while (0);
                                    if (n_rp >= n_rp_allocated) {
                                        (rp) = x2nrealloc(rp, &n_rp_allocated, sizeof *(rp));
                                    }
                                    rp[n_rp].lo = (initial);
                                    rp[n_rp].hi = (value);
                                    ++n_rp;
                                } while (0);
                            }
                            field_found = 1;
                        }
                    } else {
                        do {
                            if (initial == 0 || value == 0)
                                do {
                                    error(0, 0, (gettext("fields and positions are numbered from 1")));
                                    usage(1);
                                } while (0);
                            if (n_rp >= n_rp_allocated) {
                                (rp) = x2nrealloc(rp, &n_rp_allocated, sizeof *(rp));
                            }
                            rp[n_rp].lo = (initial);
                            rp[n_rp].hi = (value);
                            ++n_rp;
                        } while (0);
                        field_found = 1;
                    }
                    value = 0;
                }
            } else {
                do {
                    if (value == 0 || value == 0)
                        do {
                            error(0, 0, (gettext("fields and positions are numbered from 1")));
                            usage(1);
                        } while (0);
                    if (n_rp >= n_rp_allocated) {
                        (rp) = x2nrealloc(rp, &n_rp_allocated, sizeof *(rp));
                    }
                    rp[n_rp].lo = (value);
                    rp[n_rp].hi = (value);
                    ++n_rp;
                } while (0);
                value = 0;
                field_found = 1;
            }
            if (*fieldstr == '\x00') {
                break;
            }
            fieldstr++;
            lhs_specified = 0;
            rhs_specified = 0;
        } else if (((unsigned int)(*fieldstr) - '0' <= 9)) {
            static const char *num_start;
            if (!in_digits || !num_start)
                num_start = fieldstr;
            in_digits = 1;
            if (dash_found)
                rhs_specified = 1;
            else
                lhs_specified = 1;
            if (!((void)(&(value) == (size_t *)((void *)0)) , (((size_t)-1 / 10 < (value) || (size_t)((value) * 10 + (*fieldstr - '0')) < (value)) ? 0 : (((value) = (value) * 10 + (*fieldstr - '0')) , 1)))) {
                size_t len = strspn(num_start, "0123456789");
                char *bad_num = xstrndup(num_start, len);
                if (operating_mode == byte_mode)
                    error(0, 0, gettext("byte offset %s is too large"), quote(bad_num));
                else
                    error(0, 0, gettext("field number %s is too large"), quote(bad_num));
                free(bad_num);
                exit(1);
            }
            fieldstr++;
        } else
            do {
                error(0, 0, (gettext("invalid byte or field list")));
                usage(1);
            } while (0);
    }


BasicTester, a patch instance with id 58:
Spawn 1 instances, now Total 99
Counter: 100
Batcher Size:49
Preprocess the following candidate with BasicTester:
Priority 7465
At location src/cut.c:363
--Src File: src/cut.c
Fragment 0:
value = (i);
while (1)
    {
        if (*fieldstr == '-') {
            in_digits = 0;
            if (dash_found)
                do {
                    error(0, 0, (gettext("invalid byte or field list")));
                    usage(1);
                } while (0);
            dash_found = 1;
            fieldstr++;
            initial = (lhs_specified ? value : 1);
            value = 0;
        } else if (*fieldstr == ',' || ((*__ctype_b_loc())[(int)((to_uchar(*fieldstr)))] & (unsigned short)_ISblank) || *fieldstr == '\x00') {
            in_digits = 0;
            if (dash_found) {
                dash_found = 0;
                if (!lhs_specified && !rhs_specified)
                    do {
                        error(0, 0, (gettext("invalid range with no endpoint: -")));
                        usage(1);
                    } while (0);
                if (!rhs_specified) {
                    eol_range_start = initial;
                    field_found = 1;
                } else {
                    if (value < initial)
                        do {
                            error(0, 0, (gettext("invalid decreasing range")));
                            usage(1);
                        } while (0);
                    if (eol_range_start != 0) {
                        if (initial < eol_range_start) {
                            if (eol_range_start <= value) {
                                eol_range_start = initial;
                            } else {
                                do {
                                    if (initial == 0 || value == 0)
                                        do {
                                            error(0, 0, (gettext("fields and positions are numbered from 1")));
                                            usage(1);
                                        } while (0);
                                    if (n_rp >= n_rp_allocated) {
                                        (rp) = x2nrealloc(rp, &n_rp_allocated, sizeof *(rp));
                                    }
                                    rp[n_rp].lo = (initial);
                                    rp[n_rp].hi = (value);
                                    ++n_rp;
                                } while (0);
                            }
                            field_found = 1;
                        }
                    } else {
                        do {
                            if (initial == 0 || value == 0)
                                do {
                                    error(0, 0, (gettext("fields and positions are numbered from 1")));
                                    usage(1);
                                } while (0);
                            if (n_rp >= n_rp_allocated) {
                                (rp) = x2nrealloc(rp, &n_rp_allocated, sizeof *(rp));
                            }
                            rp[n_rp].lo = (initial);
                            rp[n_rp].hi = (value);
                            ++n_rp;
                        } while (0);
                        field_found = 1;
                    }
                    value = 0;
                }
            } else {
                do {
                    if (value == 0 || value == 0)
                        do {
                            error(0, 0, (gettext("fields and positions are numbered from 1")));
                            usage(1);
                        } while (0);
                    if (n_rp >= n_rp_allocated) {
                        (rp) = x2nrealloc(rp, &n_rp_allocated, sizeof *(rp));
                    }
                    rp[n_rp].lo = (value);
                    rp[n_rp].hi = (value);
                    ++n_rp;
                } while (0);
                value = 0;
                field_found = 1;
            }
            if (*fieldstr == '\x00') {
                break;
            }
            fieldstr++;
            lhs_specified = 0;
            rhs_specified = 0;
        } else if (((unsigned int)(*fieldstr) - '0' <= 9)) {
            static const char *num_start;
            if (!in_digits || !num_start)
                num_start = fieldstr;
            in_digits = 1;
            if (dash_found)
                rhs_specified = 1;
            else
                lhs_specified = 1;
            if (!((void)(&(value) == (size_t *)((void *)0)) , (((size_t)-1 / 10 < (value) || (size_t)((value) * 10 + (*fieldstr - '0')) < (value)) ? 0 : (((value) = (value) * 10 + (*fieldstr - '0')) , 1)))) {
                size_t len = strspn(num_start, "0123456789");
                char *bad_num = xstrndup(num_start, len);
                if (operating_mode == byte_mode)
                    error(0, 0, gettext("byte offset %s is too large"), quote(bad_num));
                else
                    error(0, 0, gettext("field number %s is too large"), quote(bad_num));
                free(bad_num);
                exit(1);
            }
            fieldstr++;
        } else
            do {
                error(0, 0, (gettext("invalid byte or field list")));
                usage(1);
            } while (0);
    }


BasicTester, a patch instance with id 59:
Spawn 1 instances, now Total 100
Counter: 101
Batcher Size:50
Preprocess the following candidate with BasicTester:
Priority 7465
At location src/cut.c:363
--Src File: src/cut.c
Fragment 0:
value = (initial);
while (1)
    {
        if (*fieldstr == '-') {
            in_digits = 0;
            if (dash_found)
                do {
                    error(0, 0, (gettext("invalid byte or field list")));
                    usage(1);
                } while (0);
            dash_found = 1;
            fieldstr++;
            initial = (lhs_specified ? value : 1);
            value = 0;
        } else if (*fieldstr == ',' || ((*__ctype_b_loc())[(int)((to_uchar(*fieldstr)))] & (unsigned short)_ISblank) || *fieldstr == '\x00') {
            in_digits = 0;
            if (dash_found) {
                dash_found = 0;
                if (!lhs_specified && !rhs_specified)
                    do {
                        error(0, 0, (gettext("invalid range with no endpoint: -")));
                        usage(1);
                    } while (0);
                if (!rhs_specified) {
                    eol_range_start = initial;
                    field_found = 1;
                } else {
                    if (value < initial)
                        do {
                            error(0, 0, (gettext("invalid decreasing range")));
                            usage(1);
                        } while (0);
                    if (eol_range_start != 0) {
                        if (initial < eol_range_start) {
                            if (eol_range_start <= value) {
                                eol_range_start = initial;
                            } else {
                                do {
                                    if (initial == 0 || value == 0)
                                        do {
                                            error(0, 0, (gettext("fields and positions are numbered from 1")));
                                            usage(1);
                                        } while (0);
                                    if (n_rp >= n_rp_allocated) {
                                        (rp) = x2nrealloc(rp, &n_rp_allocated, sizeof *(rp));
                                    }
                                    rp[n_rp].lo = (initial);
                                    rp[n_rp].hi = (value);
                                    ++n_rp;
                                } while (0);
                            }
                            field_found = 1;
                        }
                    } else {
                        do {
                            if (initial == 0 || value == 0)
                                do {
                                    error(0, 0, (gettext("fields and positions are numbered from 1")));
                                    usage(1);
                                } while (0);
                            if (n_rp >= n_rp_allocated) {
                                (rp) = x2nrealloc(rp, &n_rp_allocated, sizeof *(rp));
                            }
                            rp[n_rp].lo = (initial);
                            rp[n_rp].hi = (value);
                            ++n_rp;
                        } while (0);
                        field_found = 1;
                    }
                    value = 0;
                }
            } else {
                do {
                    if (value == 0 || value == 0)
                        do {
                            error(0, 0, (gettext("fields and positions are numbered from 1")));
                            usage(1);
                        } while (0);
                    if (n_rp >= n_rp_allocated) {
                        (rp) = x2nrealloc(rp, &n_rp_allocated, sizeof *(rp));
                    }
                    rp[n_rp].lo = (value);
                    rp[n_rp].hi = (value);
                    ++n_rp;
                } while (0);
                value = 0;
                field_found = 1;
            }
            if (*fieldstr == '\x00') {
                break;
            }
            fieldstr++;
            lhs_specified = 0;
            rhs_specified = 0;
        } else if (((unsigned int)(*fieldstr) - '0' <= 9)) {
            static const char *num_start;
            if (!in_digits || !num_start)
                num_start = fieldstr;
            in_digits = 1;
            if (dash_found)
                rhs_specified = 1;
            else
                lhs_specified = 1;
            if (!((void)(&(value) == (size_t *)((void *)0)) , (((size_t)-1 / 10 < (value) || (size_t)((value) * 10 + (*fieldstr - '0')) < (value)) ? 0 : (((value) = (value) * 10 + (*fieldstr - '0')) , 1)))) {
                size_t len = strspn(num_start, "0123456789");
                char *bad_num = xstrndup(num_start, len);
                if (operating_mode == byte_mode)
                    error(0, 0, gettext("byte offset %s is too large"), quote(bad_num));
                else
                    error(0, 0, gettext("field number %s is too large"), quote(bad_num));
                free(bad_num);
                exit(1);
            }
            fieldstr++;
        } else
            do {
                error(0, 0, (gettext("invalid byte or field list")));
                usage(1);
            } while (0);
    }


BasicTester, a patch instance with id 60:
Spawn 1 instances, now Total 101
Counter: 102
Batcher Size:51
Preprocess the following candidate with BasicTester:
Priority 7465
At location src/cut.c:363
--Src File: src/cut.c
Fragment 0:
value = (n_rp);
while (1)
    {
        if (*fieldstr == '-') {
            in_digits = 0;
            if (dash_found)
                do {
                    error(0, 0, (gettext("invalid byte or field list")));
                    usage(1);
                } while (0);
            dash_found = 1;
            fieldstr++;
            initial = (lhs_specified ? value : 1);
            value = 0;
        } else if (*fieldstr == ',' || ((*__ctype_b_loc())[(int)((to_uchar(*fieldstr)))] & (unsigned short)_ISblank) || *fieldstr == '\x00') {
            in_digits = 0;
            if (dash_found) {
                dash_found = 0;
                if (!lhs_specified && !rhs_specified)
                    do {
                        error(0, 0, (gettext("invalid range with no endpoint: -")));
                        usage(1);
                    } while (0);
                if (!rhs_specified) {
                    eol_range_start = initial;
                    field_found = 1;
                } else {
                    if (value < initial)
                        do {
                            error(0, 0, (gettext("invalid decreasing range")));
                            usage(1);
                        } while (0);
                    if (eol_range_start != 0) {
                        if (initial < eol_range_start) {
                            if (eol_range_start <= value) {
                                eol_range_start = initial;
                            } else {
                                do {
                                    if (initial == 0 || value == 0)
                                        do {
                                            error(0, 0, (gettext("fields and positions are numbered from 1")));
                                            usage(1);
                                        } while (0);
                                    if (n_rp >= n_rp_allocated) {
                                        (rp) = x2nrealloc(rp, &n_rp_allocated, sizeof *(rp));
                                    }
                                    rp[n_rp].lo = (initial);
                                    rp[n_rp].hi = (value);
                                    ++n_rp;
                                } while (0);
                            }
                            field_found = 1;
                        }
                    } else {
                        do {
                            if (initial == 0 || value == 0)
                                do {
                                    error(0, 0, (gettext("fields and positions are numbered from 1")));
                                    usage(1);
                                } while (0);
                            if (n_rp >= n_rp_allocated) {
                                (rp) = x2nrealloc(rp, &n_rp_allocated, sizeof *(rp));
                            }
                            rp[n_rp].lo = (initial);
                            rp[n_rp].hi = (value);
                            ++n_rp;
                        } while (0);
                        field_found = 1;
                    }
                    value = 0;
                }
            } else {
                do {
                    if (value == 0 || value == 0)
                        do {
                            error(0, 0, (gettext("fields and positions are numbered from 1")));
                            usage(1);
                        } while (0);
                    if (n_rp >= n_rp_allocated) {
                        (rp) = x2nrealloc(rp, &n_rp_allocated, sizeof *(rp));
                    }
                    rp[n_rp].lo = (value);
                    rp[n_rp].hi = (value);
                    ++n_rp;
                } while (0);
                value = 0;
                field_found = 1;
            }
            if (*fieldstr == '\x00') {
                break;
            }
            fieldstr++;
            lhs_specified = 0;
            rhs_specified = 0;
        } else if (((unsigned int)(*fieldstr) - '0' <= 9)) {
            static const char *num_start;
            if (!in_digits || !num_start)
                num_start = fieldstr;
            in_digits = 1;
            if (dash_found)
                rhs_specified = 1;
            else
                lhs_specified = 1;
            if (!((void)(&(value) == (size_t *)((void *)0)) , (((size_t)-1 / 10 < (value) || (size_t)((value) * 10 + (*fieldstr - '0')) < (value)) ? 0 : (((value) = (value) * 10 + (*fieldstr - '0')) , 1)))) {
                size_t len = strspn(num_start, "0123456789");
                char *bad_num = xstrndup(num_start, len);
                if (operating_mode == byte_mode)
                    error(0, 0, gettext("byte offset %s is too large"), quote(bad_num));
                else
                    error(0, 0, gettext("field number %s is too large"), quote(bad_num));
                free(bad_num);
                exit(1);
            }
            fieldstr++;
        } else
            do {
                error(0, 0, (gettext("invalid byte or field list")));
                usage(1);
            } while (0);
    }


BasicTester, a patch instance with id 61:
Spawn 1 instances, now Total 102
Counter: 103
Batcher Size:52
Preprocess the following candidate with BasicTester:
Priority 7465
At location src/cut.c:363
--Src File: src/cut.c
Fragment 0:
suppress_non_delimited = (rhs_specified);
while (1)
    {
        if (*fieldstr == '-') {
            in_digits = 0;
            if (dash_found)
                do {
                    error(0, 0, (gettext("invalid byte or field list")));
                    usage(1);
                } while (0);
            dash_found = 1;
            fieldstr++;
            initial = (lhs_specified ? value : 1);
            value = 0;
        } else if (*fieldstr == ',' || ((*__ctype_b_loc())[(int)((to_uchar(*fieldstr)))] & (unsigned short)_ISblank) || *fieldstr == '\x00') {
            in_digits = 0;
            if (dash_found) {
                dash_found = 0;
                if (!lhs_specified && !rhs_specified)
                    do {
                        error(0, 0, (gettext("invalid range with no endpoint: -")));
                        usage(1);
                    } while (0);
                if (!rhs_specified) {
                    eol_range_start = initial;
                    field_found = 1;
                } else {
                    if (value < initial)
                        do {
                            error(0, 0, (gettext("invalid decreasing range")));
                            usage(1);
                        } while (0);
                    if (eol_range_start != 0) {
                        if (initial < eol_range_start) {
                            if (eol_range_start <= value) {
                                eol_range_start = initial;
                            } else {
                                do {
                                    if (initial == 0 || value == 0)
                                        do {
                                            error(0, 0, (gettext("fields and positions are numbered from 1")));
                                            usage(1);
                                        } while (0);
                                    if (n_rp >= n_rp_allocated) {
                                        (rp) = x2nrealloc(rp, &n_rp_allocated, sizeof *(rp));
                                    }
                                    rp[n_rp].lo = (initial);
                                    rp[n_rp].hi = (value);
                                    ++n_rp;
                                } while (0);
                            }
                            field_found = 1;
                        }
                    } else {
                        do {
                            if (initial == 0 || value == 0)
                                do {
                                    error(0, 0, (gettext("fields and positions are numbered from 1")));
                                    usage(1);
                                } while (0);
                            if (n_rp >= n_rp_allocated) {
                                (rp) = x2nrealloc(rp, &n_rp_allocated, sizeof *(rp));
                            }
                            rp[n_rp].lo = (initial);
                            rp[n_rp].hi = (value);
                            ++n_rp;
                        } while (0);
                        field_found = 1;
                    }
                    value = 0;
                }
            } else {
                do {
                    if (value == 0 || value == 0)
                        do {
                            error(0, 0, (gettext("fields and positions are numbered from 1")));
                            usage(1);
                        } while (0);
                    if (n_rp >= n_rp_allocated) {
                        (rp) = x2nrealloc(rp, &n_rp_allocated, sizeof *(rp));
                    }
                    rp[n_rp].lo = (value);
                    rp[n_rp].hi = (value);
                    ++n_rp;
                } while (0);
                value = 0;
                field_found = 1;
            }
            if (*fieldstr == '\x00') {
                break;
            }
            fieldstr++;
            lhs_specified = 0;
            rhs_specified = 0;
        } else if (((unsigned int)(*fieldstr) - '0' <= 9)) {
            static const char *num_start;
            if (!in_digits || !num_start)
                num_start = fieldstr;
            in_digits = 1;
            if (dash_found)
                rhs_specified = 1;
            else
                lhs_specified = 1;
            if (!((void)(&(value) == (size_t *)((void *)0)) , (((size_t)-1 / 10 < (value) || (size_t)((value) * 10 + (*fieldstr - '0')) < (value)) ? 0 : (((value) = (value) * 10 + (*fieldstr - '0')) , 1)))) {
                size_t len = strspn(num_start, "0123456789");
                char *bad_num = xstrndup(num_start, len);
                if (operating_mode == byte_mode)
                    error(0, 0, gettext("byte offset %s is too large"), quote(bad_num));
                else
                    error(0, 0, gettext("field number %s is too large"), quote(bad_num));
                free(bad_num);
                exit(1);
            }
            fieldstr++;
        } else
            do {
                error(0, 0, (gettext("invalid byte or field list")));
                usage(1);
            } while (0);
    }


BasicTester, a patch instance with id 62:
Spawn 1 instances, now Total 103
a batched test job starts!
Building:src at:
/home/ubuntu/spr-fast/tests/corebench/coreutils/coreutils-case-7380cf79-2e636af1/tempworkdir/srcMerged code building succ, going to invoke tester!
BasicTester, Testing instance id 53:
Running test command:
/home/ubuntu/spr-fast/tools/coreutils-test.py /home/ubuntu/spr-fast/tests/corebench/coreutils/coreutils-case-7380cf79-2e636af1/tempworkdir/src /home/ubuntu/spr-fast/tests/corebench/coreutils/coreutils-case-7380cf79-2e636af1/tempworkdir/tests /home/ubuntu/spr-fast/tests/corebench/coreutils/coreutils-case-7380cf79-2e636af1/tempworkdir 0  > __res
BasicTester, Testing instance id 54:
Running test command:
/home/ubuntu/spr-fast/tools/coreutils-test.py /home/ubuntu/spr-fast/tests/corebench/coreutils/coreutils-case-7380cf79-2e636af1/tempworkdir/src /home/ubuntu/spr-fast/tests/corebench/coreutils/coreutils-case-7380cf79-2e636af1/tempworkdir/tests /home/ubuntu/spr-fast/tests/corebench/coreutils/coreutils-case-7380cf79-2e636af1/tempworkdir 0  > __res
BasicTester, Testing instance id 55:
Running test command:
/home/ubuntu/spr-fast/tools/coreutils-test.py /home/ubuntu/spr-fast/tests/corebench/coreutils/coreutils-case-7380cf79-2e636af1/tempworkdir/src /home/ubuntu/spr-fast/tests/corebench/coreutils/coreutils-case-7380cf79-2e636af1/tempworkdir/tests /home/ubuntu/spr-fast/tests/corebench/coreutils/coreutils-case-7380cf79-2e636af1/tempworkdir 0  > __res
BasicTester, Testing instance id 56:
Running test command:
/home/ubuntu/spr-fast/tools/coreutils-test.py /home/ubuntu/spr-fast/tests/corebench/coreutils/coreutils-case-7380cf79-2e636af1/tempworkdir/src /home/ubuntu/spr-fast/tests/corebench/coreutils/coreutils-case-7380cf79-2e636af1/tempworkdir/tests /home/ubuntu/spr-fast/tests/corebench/coreutils/coreutils-case-7380cf79-2e636af1/tempworkdir 0  > __res
BasicTester, Testing instance id 57:
Running test command:
/home/ubuntu/spr-fast/tools/coreutils-test.py /home/ubuntu/spr-fast/tests/corebench/coreutils/coreutils-case-7380cf79-2e636af1/tempworkdir/src /home/ubuntu/spr-fast/tests/corebench/coreutils/coreutils-case-7380cf79-2e636af1/tempworkdir/tests /home/ubuntu/spr-fast/tests/corebench/coreutils/coreutils-case-7380cf79-2e636af1/tempworkdir 0  > __res
BasicTester, Testing instance id 58:
Running test command:
/home/ubuntu/spr-fast/tools/coreutils-test.py /home/ubuntu/spr-fast/tests/corebench/coreutils/coreutils-case-7380cf79-2e636af1/tempworkdir/src /home/ubuntu/spr-fast/tests/corebench/coreutils/coreutils-case-7380cf79-2e636af1/tempworkdir/tests /home/ubuntu/spr-fast/tests/corebench/coreutils/coreutils-case-7380cf79-2e636af1/tempworkdir 0  > __res
BasicTester, Testing instance id 59:
Running test command:
/home/ubuntu/spr-fast/tools/coreutils-test.py /home/ubuntu/spr-fast/tests/corebench/coreutils/coreutils-case-7380cf79-2e636af1/tempworkdir/src /home/ubuntu/spr-fast/tests/corebench/coreutils/coreutils-case-7380cf79-2e636af1/tempworkdir/tests /home/ubuntu/spr-fast/tests/corebench/coreutils/coreutils-case-7380cf79-2e636af1/tempworkdir 0  > __res
BasicTester, Testing instance id 60:
Running test command:
/home/ubuntu/spr-fast/tools/coreutils-test.py /home/ubuntu/spr-fast/tests/corebench/coreutils/coreutils-case-7380cf79-2e636af1/tempworkdir/src /home/ubuntu/spr-fast/tests/corebench/coreutils/coreutils-case-7380cf79-2e636af1/tempworkdir/tests /home/ubuntu/spr-fast/tests/corebench/coreutils/coreutils-case-7380cf79-2e636af1/tempworkdir 0  > __res
BasicTester, Testing instance id 61:
Running test command:
/home/ubuntu/spr-fast/tools/coreutils-test.py /home/ubuntu/spr-fast/tests/corebench/coreutils/coreutils-case-7380cf79-2e636af1/tempworkdir/src /home/ubuntu/spr-fast/tests/corebench/coreutils/coreutils-case-7380cf79-2e636af1/tempworkdir/tests /home/ubuntu/spr-fast/tests/corebench/coreutils/coreutils-case-7380cf79-2e636af1/tempworkdir 0  > __res
BasicTester, Testing instance id 62:
Running test command:
/home/ubuntu/spr-fast/tools/coreutils-test.py /home/ubuntu/spr-fast/tests/corebench/coreutils/coreutils-case-7380cf79-2e636af1/tempworkdir/src /home/ubuntu/spr-fast/tests/corebench/coreutils/coreutils-case-7380cf79-2e636af1/tempworkdir/tests /home/ubuntu/spr-fast/tests/corebench/coreutils/coreutils-case-7380cf79-2e636af1/tempworkdir 0  > __res
Counter: 104
Batcher Size:43
Preprocess the following candidate with BasicTester:
Priority 7465
At location src/cut.c:363
--Src File: src/cut.c
Fragment 0:
value = (0);
while (1)
    {
        if (*fieldstr == '-') {
            in_digits = 0;
            if (dash_found)
                do {
                    error(0, 0, (gettext("invalid byte or field list")));
                    usage(1);
                } while (0);
            dash_found = 1;
            fieldstr++;
            initial = (lhs_specified ? value : 1);
            value = 0;
        } else if (*fieldstr == ',' || ((*__ctype_b_loc())[(int)((to_uchar(*fieldstr)))] & (unsigned short)_ISblank) || *fieldstr == '\x00') {
            in_digits = 0;
            if (dash_found) {
                dash_found = 0;
                if (!lhs_specified && !rhs_specified)
                    do {
                        error(0, 0, (gettext("invalid range with no endpoint: -")));
                        usage(1);
                    } while (0);
                if (!rhs_specified) {
                    eol_range_start = initial;
                    field_found = 1;
                } else {
                    if (value < initial)
                        do {
                            error(0, 0, (gettext("invalid decreasing range")));
                            usage(1);
                        } while (0);
                    if (eol_range_start != 0) {
                        if (initial < eol_range_start) {
                            if (eol_range_start <= value) {
                                eol_range_start = initial;
                            } else {
                                do {
                                    if (initial == 0 || value == 0)
                                        do {
                                            error(0, 0, (gettext("fields and positions are numbered from 1")));
                                            usage(1);
                                        } while (0);
                                    if (n_rp >= n_rp_allocated) {
                                        (rp) = x2nrealloc(rp, &n_rp_allocated, sizeof *(rp));
                                    }
                                    rp[n_rp].lo = (initial);
                                    rp[n_rp].hi = (value);
                                    ++n_rp;
                                } while (0);
                            }
                            field_found = 1;
                        }
                    } else {
                        do {
                            if (initial == 0 || value == 0)
                                do {
                                    error(0, 0, (gettext("fields and positions are numbered from 1")));
                                    usage(1);
                                } while (0);
                            if (n_rp >= n_rp_allocated) {
                                (rp) = x2nrealloc(rp, &n_rp_allocated, sizeof *(rp));
                            }
                            rp[n_rp].lo = (initial);
                            rp[n_rp].hi = (value);
                            ++n_rp;
                        } while (0);
                        field_found = 1;
                    }
                    value = 0;
                }
            } else {
                do {
                    if (value == 0 || value == 0)
                        do {
                            error(0, 0, (gettext("fields and positions are numbered from 1")));
                            usage(1);
                        } while (0);
                    if (n_rp >= n_rp_allocated) {
                        (rp) = x2nrealloc(rp, &n_rp_allocated, sizeof *(rp));
                    }
                    rp[n_rp].lo = (value);
                    rp[n_rp].hi = (value);
                    ++n_rp;
                } while (0);
                value = 0;
                field_found = 1;
            }
            if (*fieldstr == '\x00') {
                break;
            }
            fieldstr++;
            lhs_specified = 0;
            rhs_specified = 0;
        } else if (((unsigned int)(*fieldstr) - '0' <= 9)) {
            static const char *num_start;
            if (!in_digits || !num_start)
                num_start = fieldstr;
            in_digits = 1;
            if (dash_found)
                rhs_specified = 1;
            else
                lhs_specified = 1;
            if (!((void)(&(value) == (size_t *)((void *)0)) , (((size_t)-1 / 10 < (value) || (size_t)((value) * 10 + (*fieldstr - '0')) < (value)) ? 0 : (((value) = (value) * 10 + (*fieldstr - '0')) , 1)))) {
                size_t len = strspn(num_start, "0123456789");
                char *bad_num = xstrndup(num_start, len);
                if (operating_mode == byte_mode)
                    error(0, 0, gettext("byte offset %s is too large"), quote(bad_num));
                else
                    error(0, 0, gettext("field number %s is too large"), quote(bad_num));
                free(bad_num);
                exit(1);
            }
            fieldstr++;
        } else
            do {
                error(0, 0, (gettext("invalid byte or field list")));
                usage(1);
            } while (0);
    }


BasicTester, a patch instance with id 63:
Spawn 1 instances, now Total 104
Counter: 105
Batcher Size:44
Preprocess the following candidate with BasicTester:
Priority 7465
At location src/cut.c:363
--Src File: src/cut.c
Fragment 0:
value = (10);
while (1)
    {
        if (*fieldstr == '-') {
            in_digits = 0;
            if (dash_found)
                do {
                    error(0, 0, (gettext("invalid byte or field list")));
                    usage(1);
                } while (0);
            dash_found = 1;
            fieldstr++;
            initial = (lhs_specified ? value : 1);
            value = 0;
        } else if (*fieldstr == ',' || ((*__ctype_b_loc())[(int)((to_uchar(*fieldstr)))] & (unsigned short)_ISblank) || *fieldstr == '\x00') {
            in_digits = 0;
            if (dash_found) {
                dash_found = 0;
                if (!lhs_specified && !rhs_specified)
                    do {
                        error(0, 0, (gettext("invalid range with no endpoint: -")));
                        usage(1);
                    } while (0);
                if (!rhs_specified) {
                    eol_range_start = initial;
                    field_found = 1;
                } else {
                    if (value < initial)
                        do {
                            error(0, 0, (gettext("invalid decreasing range")));
                            usage(1);
                        } while (0);
                    if (eol_range_start != 0) {
                        if (initial < eol_range_start) {
                            if (eol_range_start <= value) {
                                eol_range_start = initial;
                            } else {
                                do {
                                    if (initial == 0 || value == 0)
                                        do {
                                            error(0, 0, (gettext("fields and positions are numbered from 1")));
                                            usage(1);
                                        } while (0);
                                    if (n_rp >= n_rp_allocated) {
                                        (rp) = x2nrealloc(rp, &n_rp_allocated, sizeof *(rp));
                                    }
                                    rp[n_rp].lo = (initial);
                                    rp[n_rp].hi = (value);
                                    ++n_rp;
                                } while (0);
                            }
                            field_found = 1;
                        }
                    } else {
                        do {
                            if (initial == 0 || value == 0)
                                do {
                                    error(0, 0, (gettext("fields and positions are numbered from 1")));
                                    usage(1);
                                } while (0);
                            if (n_rp >= n_rp_allocated) {
                                (rp) = x2nrealloc(rp, &n_rp_allocated, sizeof *(rp));
                            }
                            rp[n_rp].lo = (initial);
                            rp[n_rp].hi = (value);
                            ++n_rp;
                        } while (0);
                        field_found = 1;
                    }
                    value = 0;
                }
            } else {
                do {
                    if (value == 0 || value == 0)
                        do {
                            error(0, 0, (gettext("fields and positions are numbered from 1")));
                            usage(1);
                        } while (0);
                    if (n_rp >= n_rp_allocated) {
                        (rp) = x2nrealloc(rp, &n_rp_allocated, sizeof *(rp));
                    }
                    rp[n_rp].lo = (value);
                    rp[n_rp].hi = (value);
                    ++n_rp;
                } while (0);
                value = 0;
                field_found = 1;
            }
            if (*fieldstr == '\x00') {
                break;
            }
            fieldstr++;
            lhs_specified = 0;
            rhs_specified = 0;
        } else if (((unsigned int)(*fieldstr) - '0' <= 9)) {
            static const char *num_start;
            if (!in_digits || !num_start)
                num_start = fieldstr;
            in_digits = 1;
            if (dash_found)
                rhs_specified = 1;
            else
                lhs_specified = 1;
            if (!((void)(&(value) == (size_t *)((void *)0)) , (((size_t)-1 / 10 < (value) || (size_t)((value) * 10 + (*fieldstr - '0')) < (value)) ? 0 : (((value) = (value) * 10 + (*fieldstr - '0')) , 1)))) {
                size_t len = strspn(num_start, "0123456789");
                char *bad_num = xstrndup(num_start, len);
                if (operating_mode == byte_mode)
                    error(0, 0, gettext("byte offset %s is too large"), quote(bad_num));
                else
                    error(0, 0, gettext("field number %s is too large"), quote(bad_num));
                free(bad_num);
                exit(1);
            }
            fieldstr++;
        } else
            do {
                error(0, 0, (gettext("invalid byte or field list")));
                usage(1);
            } while (0);
    }


BasicTester, a patch instance with id 64:
Spawn 1 instances, now Total 105
Counter: 106
Batcher Size:45
Preprocess the following candidate with BasicTester:
Priority 7465
At location src/cut.c:363
--Src File: src/cut.c
Fragment 0:
value = (8);
while (1)
    {
        if (*fieldstr == '-') {
            in_digits = 0;
            if (dash_found)
                do {
                    error(0, 0, (gettext("invalid byte or field list")));
                    usage(1);
                } while (0);
            dash_found = 1;
            fieldstr++;
            initial = (lhs_specified ? value : 1);
            value = 0;
        } else if (*fieldstr == ',' || ((*__ctype_b_loc())[(int)((to_uchar(*fieldstr)))] & (unsigned short)_ISblank) || *fieldstr == '\x00') {
            in_digits = 0;
            if (dash_found) {
                dash_found = 0;
                if (!lhs_specified && !rhs_specified)
                    do {
                        error(0, 0, (gettext("invalid range with no endpoint: -")));
                        usage(1);
                    } while (0);
                if (!rhs_specified) {
                    eol_range_start = initial;
                    field_found = 1;
                } else {
                    if (value < initial)
                        do {
                            error(0, 0, (gettext("invalid decreasing range")));
                            usage(1);
                        } while (0);
                    if (eol_range_start != 0) {
                        if (initial < eol_range_start) {
                            if (eol_range_start <= value) {
                                eol_range_start = initial;
                            } else {
                                do {
                                    if (initial == 0 || value == 0)
                                        do {
                                            error(0, 0, (gettext("fields and positions are numbered from 1")));
                                            usage(1);
                                        } while (0);
                                    if (n_rp >= n_rp_allocated) {
                                        (rp) = x2nrealloc(rp, &n_rp_allocated, sizeof *(rp));
                                    }
                                    rp[n_rp].lo = (initial);
                                    rp[n_rp].hi = (value);
                                    ++n_rp;
                                } while (0);
                            }
                            field_found = 1;
                        }
                    } else {
                        do {
                            if (initial == 0 || value == 0)
                                do {
                                    error(0, 0, (gettext("fields and positions are numbered from 1")));
                                    usage(1);
                                } while (0);
                            if (n_rp >= n_rp_allocated) {
                                (rp) = x2nrealloc(rp, &n_rp_allocated, sizeof *(rp));
                            }
                            rp[n_rp].lo = (initial);
                            rp[n_rp].hi = (value);
                            ++n_rp;
                        } while (0);
                        field_found = 1;
                    }
                    value = 0;
                }
            } else {
                do {
                    if (value == 0 || value == 0)
                        do {
                            error(0, 0, (gettext("fields and positions are numbered from 1")));
                            usage(1);
                        } while (0);
                    if (n_rp >= n_rp_allocated) {
                        (rp) = x2nrealloc(rp, &n_rp_allocated, sizeof *(rp));
                    }
                    rp[n_rp].lo = (value);
                    rp[n_rp].hi = (value);
                    ++n_rp;
                } while (0);
                value = 0;
                field_found = 1;
            }
            if (*fieldstr == '\x00') {
                break;
            }
            fieldstr++;
            lhs_specified = 0;
            rhs_specified = 0;
        } else if (((unsigned int)(*fieldstr) - '0' <= 9)) {
            static const char *num_start;
            if (!in_digits || !num_start)
                num_start = fieldstr;
            in_digits = 1;
            if (dash_found)
                rhs_specified = 1;
            else
                lhs_specified = 1;
            if (!((void)(&(value) == (size_t *)((void *)0)) , (((size_t)-1 / 10 < (value) || (size_t)((value) * 10 + (*fieldstr - '0')) < (value)) ? 0 : (((value) = (value) * 10 + (*fieldstr - '0')) , 1)))) {
                size_t len = strspn(num_start, "0123456789");
                char *bad_num = xstrndup(num_start, len);
                if (operating_mode == byte_mode)
                    error(0, 0, gettext("byte offset %s is too large"), quote(bad_num));
                else
                    error(0, 0, gettext("field number %s is too large"), quote(bad_num));
                free(bad_num);
                exit(1);
            }
            fieldstr++;
        } else
            do {
                error(0, 0, (gettext("invalid byte or field list")));
                usage(1);
            } while (0);
    }


BasicTester, a patch instance with id 65:
Spawn 1 instances, now Total 106
Counter: 107
Batcher Size:46
Preprocess the following candidate with BasicTester:
Priority 7465
At location src/cut.c:363
--Src File: src/cut.c
Fragment 0:
value = (1);
while (1)
    {
        if (*fieldstr == '-') {
            in_digits = 0;
            if (dash_found)
                do {
                    error(0, 0, (gettext("invalid byte or field list")));
                    usage(1);
                } while (0);
            dash_found = 1;
            fieldstr++;
            initial = (lhs_specified ? value : 1);
            value = 0;
        } else if (*fieldstr == ',' || ((*__ctype_b_loc())[(int)((to_uchar(*fieldstr)))] & (unsigned short)_ISblank) || *fieldstr == '\x00') {
            in_digits = 0;
            if (dash_found) {
                dash_found = 0;
                if (!lhs_specified && !rhs_specified)
                    do {
                        error(0, 0, (gettext("invalid range with no endpoint: -")));
                        usage(1);
                    } while (0);
                if (!rhs_specified) {
                    eol_range_start = initial;
                    field_found = 1;
                } else {
                    if (value < initial)
                        do {
                            error(0, 0, (gettext("invalid decreasing range")));
                            usage(1);
                        } while (0);
                    if (eol_range_start != 0) {
                        if (initial < eol_range_start) {
                            if (eol_range_start <= value) {
                                eol_range_start = initial;
                            } else {
                                do {
                                    if (initial == 0 || value == 0)
                                        do {
                                            error(0, 0, (gettext("fields and positions are numbered from 1")));
                                            usage(1);
                                        } while (0);
                                    if (n_rp >= n_rp_allocated) {
                                        (rp) = x2nrealloc(rp, &n_rp_allocated, sizeof *(rp));
                                    }
                                    rp[n_rp].lo = (initial);
                                    rp[n_rp].hi = (value);
                                    ++n_rp;
                                } while (0);
                            }
                            field_found = 1;
                        }
                    } else {
                        do {
                            if (initial == 0 || value == 0)
                                do {
                                    error(0, 0, (gettext("fields and positions are numbered from 1")));
                                    usage(1);
                                } while (0);
                            if (n_rp >= n_rp_allocated) {
                                (rp) = x2nrealloc(rp, &n_rp_allocated, sizeof *(rp));
                            }
                            rp[n_rp].lo = (initial);
                            rp[n_rp].hi = (value);
                            ++n_rp;
                        } while (0);
                        field_found = 1;
                    }
                    value = 0;
                }
            } else {
                do {
                    if (value == 0 || value == 0)
                        do {
                            error(0, 0, (gettext("fields and positions are numbered from 1")));
                            usage(1);
                        } while (0);
                    if (n_rp >= n_rp_allocated) {
                        (rp) = x2nrealloc(rp, &n_rp_allocated, sizeof *(rp));
                    }
                    rp[n_rp].lo = (value);
                    rp[n_rp].hi = (value);
                    ++n_rp;
                } while (0);
                value = 0;
                field_found = 1;
            }
            if (*fieldstr == '\x00') {
                break;
            }
            fieldstr++;
            lhs_specified = 0;
            rhs_specified = 0;
        } else if (((unsigned int)(*fieldstr) - '0' <= 9)) {
            static const char *num_start;
            if (!in_digits || !num_start)
                num_start = fieldstr;
            in_digits = 1;
            if (dash_found)
                rhs_specified = 1;
            else
                lhs_specified = 1;
            if (!((void)(&(value) == (size_t *)((void *)0)) , (((size_t)-1 / 10 < (value) || (size_t)((value) * 10 + (*fieldstr - '0')) < (value)) ? 0 : (((value) = (value) * 10 + (*fieldstr - '0')) , 1)))) {
                size_t len = strspn(num_start, "0123456789");
                char *bad_num = xstrndup(num_start, len);
                if (operating_mode == byte_mode)
                    error(0, 0, gettext("byte offset %s is too large"), quote(bad_num));
                else
                    error(0, 0, gettext("field number %s is too large"), quote(bad_num));
                free(bad_num);
                exit(1);
            }
            fieldstr++;
        } else
            do {
                error(0, 0, (gettext("invalid byte or field list")));
                usage(1);
            } while (0);
    }


BasicTester, a patch instance with id 66:
Spawn 1 instances, now Total 107
Counter: 108
Batcher Size:47
Preprocess the following candidate with BasicTester:
Priority 7465
At location src/cut.c:363
--Src File: src/cut.c
Fragment 0:
suppress_non_delimited = 0;
while (1)
    {
        if (*fieldstr == '-') {
            in_digits = 0;
            if (dash_found)
                do {
                    error(0, 0, (gettext("invalid byte or field list")));
                    usage(1);
                } while (0);
            dash_found = 1;
            fieldstr++;
            initial = (lhs_specified ? value : 1);
            value = 0;
        } else if (*fieldstr == ',' || ((*__ctype_b_loc())[(int)((to_uchar(*fieldstr)))] & (unsigned short)_ISblank) || *fieldstr == '\x00') {
            in_digits = 0;
            if (dash_found) {
                dash_found = 0;
                if (!lhs_specified && !rhs_specified)
                    do {
                        error(0, 0, (gettext("invalid range with no endpoint: -")));
                        usage(1);
                    } while (0);
                if (!rhs_specified) {
                    eol_range_start = initial;
                    field_found = 1;
                } else {
                    if (value < initial)
                        do {
                            error(0, 0, (gettext("invalid decreasing range")));
                            usage(1);
                        } while (0);
                    if (eol_range_start != 0) {
                        if (initial < eol_range_start) {
                            if (eol_range_start <= value) {
                                eol_range_start = initial;
                            } else {
                                do {
                                    if (initial == 0 || value == 0)
                                        do {
                                            error(0, 0, (gettext("fields and positions are numbered from 1")));
                                            usage(1);
                                        } while (0);
                                    if (n_rp >= n_rp_allocated) {
                                        (rp) = x2nrealloc(rp, &n_rp_allocated, sizeof *(rp));
                                    }
                                    rp[n_rp].lo = (initial);
                                    rp[n_rp].hi = (value);
                                    ++n_rp;
                                } while (0);
                            }
                            field_found = 1;
                        }
                    } else {
                        do {
                            if (initial == 0 || value == 0)
                                do {
                                    error(0, 0, (gettext("fields and positions are numbered from 1")));
                                    usage(1);
                                } while (0);
                            if (n_rp >= n_rp_allocated) {
                                (rp) = x2nrealloc(rp, &n_rp_allocated, sizeof *(rp));
                            }
                            rp[n_rp].lo = (initial);
                            rp[n_rp].hi = (value);
                            ++n_rp;
                        } while (0);
                        field_found = 1;
                    }
                    value = 0;
                }
            } else {
                do {
                    if (value == 0 || value == 0)
                        do {
                            error(0, 0, (gettext("fields and positions are numbered from 1")));
                            usage(1);
                        } while (0);
                    if (n_rp >= n_rp_allocated) {
                        (rp) = x2nrealloc(rp, &n_rp_allocated, sizeof *(rp));
                    }
                    rp[n_rp].lo = (value);
                    rp[n_rp].hi = (value);
                    ++n_rp;
                } while (0);
                value = 0;
                field_found = 1;
            }
            if (*fieldstr == '\x00') {
                break;
            }
            fieldstr++;
            lhs_specified = 0;
            rhs_specified = 0;
        } else if (((unsigned int)(*fieldstr) - '0' <= 9)) {
            static const char *num_start;
            if (!in_digits || !num_start)
                num_start = fieldstr;
            in_digits = 1;
            if (dash_found)
                rhs_specified = 1;
            else
                lhs_specified = 1;
            if (!((void)(&(value) == (size_t *)((void *)0)) , (((size_t)-1 / 10 < (value) || (size_t)((value) * 10 + (*fieldstr - '0')) < (value)) ? 0 : (((value) = (value) * 10 + (*fieldstr - '0')) , 1)))) {
                size_t len = strspn(num_start, "0123456789");
                char *bad_num = xstrndup(num_start, len);
                if (operating_mode == byte_mode)
                    error(0, 0, gettext("byte offset %s is too large"), quote(bad_num));
                else
                    error(0, 0, gettext("field number %s is too large"), quote(bad_num));
                free(bad_num);
                exit(1);
            }
            fieldstr++;
        } else
            do {
                error(0, 0, (gettext("invalid byte or field list")));
                usage(1);
            } while (0);
    }


BasicTester, a patch instance with id 67:
Spawn 1 instances, now Total 108
Counter: 109
Batcher Size:48
Preprocess the following candidate with BasicTester:
Priority 7465
At location src/cut.c:363
--Src File: src/cut.c
Fragment 0:
value = (-1);
while (1)
    {
        if (*fieldstr == '-') {
            in_digits = 0;
            if (dash_found)
                do {
                    error(0, 0, (gettext("invalid byte or field list")));
                    usage(1);
                } while (0);
            dash_found = 1;
            fieldstr++;
            initial = (lhs_specified ? value : 1);
            value = 0;
        } else if (*fieldstr == ',' || ((*__ctype_b_loc())[(int)((to_uchar(*fieldstr)))] & (unsigned short)_ISblank) || *fieldstr == '\x00') {
            in_digits = 0;
            if (dash_found) {
                dash_found = 0;
                if (!lhs_specified && !rhs_specified)
                    do {
                        error(0, 0, (gettext("invalid range with no endpoint: -")));
                        usage(1);
                    } while (0);
                if (!rhs_specified) {
                    eol_range_start = initial;
                    field_found = 1;
                } else {
                    if (value < initial)
                        do {
                            error(0, 0, (gettext("invalid decreasing range")));
                            usage(1);
                        } while (0);
                    if (eol_range_start != 0) {
                        if (initial < eol_range_start) {
                            if (eol_range_start <= value) {
                                eol_range_start = initial;
                            } else {
                                do {
                                    if (initial == 0 || value == 0)
                                        do {
                                            error(0, 0, (gettext("fields and positions are numbered from 1")));
                                            usage(1);
                                        } while (0);
                                    if (n_rp >= n_rp_allocated) {
                                        (rp) = x2nrealloc(rp, &n_rp_allocated, sizeof *(rp));
                                    }
                                    rp[n_rp].lo = (initial);
                                    rp[n_rp].hi = (value);
                                    ++n_rp;
                                } while (0);
                            }
                            field_found = 1;
                        }
                    } else {
                        do {
                            if (initial == 0 || value == 0)
                                do {
                                    error(0, 0, (gettext("fields and positions are numbered from 1")));
                                    usage(1);
                                } while (0);
                            if (n_rp >= n_rp_allocated) {
                                (rp) = x2nrealloc(rp, &n_rp_allocated, sizeof *(rp));
                            }
                            rp[n_rp].lo = (initial);
                            rp[n_rp].hi = (value);
                            ++n_rp;
                        } while (0);
                        field_found = 1;
                    }
                    value = 0;
                }
            } else {
                do {
                    if (value == 0 || value == 0)
                        do {
                            error(0, 0, (gettext("fields and positions are numbered from 1")));
                            usage(1);
                        } while (0);
                    if (n_rp >= n_rp_allocated) {
                        (rp) = x2nrealloc(rp, &n_rp_allocated, sizeof *(rp));
                    }
                    rp[n_rp].lo = (value);
                    rp[n_rp].hi = (value);
                    ++n_rp;
                } while (0);
                value = 0;
                field_found = 1;
            }
            if (*fieldstr == '\x00') {
                break;
            }
            fieldstr++;
            lhs_specified = 0;
            rhs_specified = 0;
        } else if (((unsigned int)(*fieldstr) - '0' <= 9)) {
            static const char *num_start;
            if (!in_digits || !num_start)
                num_start = fieldstr;
            in_digits = 1;
            if (dash_found)
                rhs_specified = 1;
            else
                lhs_specified = 1;
            if (!((void)(&(value) == (size_t *)((void *)0)) , (((size_t)-1 / 10 < (value) || (size_t)((value) * 10 + (*fieldstr - '0')) < (value)) ? 0 : (((value) = (value) * 10 + (*fieldstr - '0')) , 1)))) {
                size_t len = strspn(num_start, "0123456789");
                char *bad_num = xstrndup(num_start, len);
                if (operating_mode == byte_mode)
                    error(0, 0, gettext("byte offset %s is too large"), quote(bad_num));
                else
                    error(0, 0, gettext("field number %s is too large"), quote(bad_num));
                free(bad_num);
                exit(1);
            }
            fieldstr++;
        } else
            do {
                error(0, 0, (gettext("invalid byte or field list")));
                usage(1);
            } while (0);
    }


BasicTester, a patch instance with id 68:
Spawn 1 instances, now Total 109
Counter: 110
Batcher Size:49
Preprocess the following candidate with BasicTester:
Priority 7465
At location src/cut.c:363
--Src File: src/cut.c
Fragment 0:
printable_field = xzalloc(max_range_endpoint / 8 + 1);
while (1)
    {
        if (*fieldstr == '-') {
            in_digits = 0;
            if (dash_found)
                do {
                    error(0, 0, (gettext("invalid byte or field list")));
                    usage(1);
                } while (0);
            dash_found = 1;
            fieldstr++;
            initial = (lhs_specified ? value : 1);
            value = 0;
        } else if (*fieldstr == ',' || ((*__ctype_b_loc())[(int)((to_uchar(*fieldstr)))] & (unsigned short)_ISblank) || *fieldstr == '\x00') {
            in_digits = 0;
            if (dash_found) {
                dash_found = 0;
                if (!lhs_specified && !rhs_specified)
                    do {
                        error(0, 0, (gettext("invalid range with no endpoint: -")));
                        usage(1);
                    } while (0);
                if (!rhs_specified) {
                    eol_range_start = initial;
                    field_found = 1;
                } else {
                    if (value < initial)
                        do {
                            error(0, 0, (gettext("invalid decreasing range")));
                            usage(1);
                        } while (0);
                    if (eol_range_start != 0) {
                        if (initial < eol_range_start) {
                            if (eol_range_start <= value) {
                                eol_range_start = initial;
                            } else {
                                do {
                                    if (initial == 0 || value == 0)
                                        do {
                                            error(0, 0, (gettext("fields and positions are numbered from 1")));
                                            usage(1);
                                        } while (0);
                                    if (n_rp >= n_rp_allocated) {
                                        (rp) = x2nrealloc(rp, &n_rp_allocated, sizeof *(rp));
                                    }
                                    rp[n_rp].lo = (initial);
                                    rp[n_rp].hi = (value);
                                    ++n_rp;
                                } while (0);
                            }
                            field_found = 1;
                        }
                    } else {
                        do {
                            if (initial == 0 || value == 0)
                                do {
                                    error(0, 0, (gettext("fields and positions are numbered from 1")));
                                    usage(1);
                                } while (0);
                            if (n_rp >= n_rp_allocated) {
                                (rp) = x2nrealloc(rp, &n_rp_allocated, sizeof *(rp));
                            }
                            rp[n_rp].lo = (initial);
                            rp[n_rp].hi = (value);
                            ++n_rp;
                        } while (0);
                        field_found = 1;
                    }
                    value = 0;
                }
            } else {
                do {
                    if (value == 0 || value == 0)
                        do {
                            error(0, 0, (gettext("fields and positions are numbered from 1")));
                            usage(1);
                        } while (0);
                    if (n_rp >= n_rp_allocated) {
                        (rp) = x2nrealloc(rp, &n_rp_allocated, sizeof *(rp));
                    }
                    rp[n_rp].lo = (value);
                    rp[n_rp].hi = (value);
                    ++n_rp;
                } while (0);
                value = 0;
                field_found = 1;
            }
            if (*fieldstr == '\x00') {
                break;
            }
            fieldstr++;
            lhs_specified = 0;
            rhs_specified = 0;
        } else if (((unsigned int)(*fieldstr) - '0' <= 9)) {
            static const char *num_start;
            if (!in_digits || !num_start)
                num_start = fieldstr;
            in_digits = 1;
            if (dash_found)
                rhs_specified = 1;
            else
                lhs_specified = 1;
            if (!((void)(&(value) == (size_t *)((void *)0)) , (((size_t)-1 / 10 < (value) || (size_t)((value) * 10 + (*fieldstr - '0')) < (value)) ? 0 : (((value) = (value) * 10 + (*fieldstr - '0')) , 1)))) {
                size_t len = strspn(num_start, "0123456789");
                char *bad_num = xstrndup(num_start, len);
                if (operating_mode == byte_mode)
                    error(0, 0, gettext("byte offset %s is too large"), quote(bad_num));
                else
                    error(0, 0, gettext("field number %s is too large"), quote(bad_num));
                free(bad_num);
                exit(1);
            }
            fieldstr++;
        } else
            do {
                error(0, 0, (gettext("invalid byte or field list")));
                usage(1);
            } while (0);
    }


BasicTester, a patch instance with id 69:
Spawn 1 instances, now Total 110
Counter: 111
Batcher Size:50
Preprocess the following candidate with BasicTester:
Priority 7465
At location src/cut.c:363
--Src File: src/cut.c
Fragment 0:
rhs_specified = (lhs_specified);
while (1)
    {
        if (*fieldstr == '-') {
            in_digits = 0;
            if (dash_found)
                do {
                    error(0, 0, (gettext("invalid byte or field list")));
                    usage(1);
                } while (0);
            dash_found = 1;
            fieldstr++;
            initial = (lhs_specified ? value : 1);
            value = 0;
        } else if (*fieldstr == ',' || ((*__ctype_b_loc())[(int)((to_uchar(*fieldstr)))] & (unsigned short)_ISblank) || *fieldstr == '\x00') {
            in_digits = 0;
            if (dash_found) {
                dash_found = 0;
                if (!lhs_specified && !rhs_specified)
                    do {
                        error(0, 0, (gettext("invalid range with no endpoint: -")));
                        usage(1);
                    } while (0);
                if (!rhs_specified) {
                    eol_range_start = initial;
                    field_found = 1;
                } else {
                    if (value < initial)
                        do {
                            error(0, 0, (gettext("invalid decreasing range")));
                            usage(1);
                        } while (0);
                    if (eol_range_start != 0) {
                        if (initial < eol_range_start) {
                            if (eol_range_start <= value) {
                                eol_range_start = initial;
                            } else {
                                do {
                                    if (initial == 0 || value == 0)
                                        do {
                                            error(0, 0, (gettext("fields and positions are numbered from 1")));
                                            usage(1);
                                        } while (0);
                                    if (n_rp >= n_rp_allocated) {
                                        (rp) = x2nrealloc(rp, &n_rp_allocated, sizeof *(rp));
                                    }
                                    rp[n_rp].lo = (initial);
                                    rp[n_rp].hi = (value);
                                    ++n_rp;
                                } while (0);
                            }
                            field_found = 1;
                        }
                    } else {
                        do {
                            if (initial == 0 || value == 0)
                                do {
                                    error(0, 0, (gettext("fields and positions are numbered from 1")));
                                    usage(1);
                                } while (0);
                            if (n_rp >= n_rp_allocated) {
                                (rp) = x2nrealloc(rp, &n_rp_allocated, sizeof *(rp));
                            }
                            rp[n_rp].lo = (initial);
                            rp[n_rp].hi = (value);
                            ++n_rp;
                        } while (0);
                        field_found = 1;
                    }
                    value = 0;
                }
            } else {
                do {
                    if (value == 0 || value == 0)
                        do {
                            error(0, 0, (gettext("fields and positions are numbered from 1")));
                            usage(1);
                        } while (0);
                    if (n_rp >= n_rp_allocated) {
                        (rp) = x2nrealloc(rp, &n_rp_allocated, sizeof *(rp));
                    }
                    rp[n_rp].lo = (value);
                    rp[n_rp].hi = (value);
                    ++n_rp;
                } while (0);
                value = 0;
                field_found = 1;
            }
            if (*fieldstr == '\x00') {
                break;
            }
            fieldstr++;
            lhs_specified = 0;
            rhs_specified = 0;
        } else if (((unsigned int)(*fieldstr) - '0' <= 9)) {
            static const char *num_start;
            if (!in_digits || !num_start)
                num_start = fieldstr;
            in_digits = 1;
            if (dash_found)
                rhs_specified = 1;
            else
                lhs_specified = 1;
            if (!((void)(&(value) == (size_t *)((void *)0)) , (((size_t)-1 / 10 < (value) || (size_t)((value) * 10 + (*fieldstr - '0')) < (value)) ? 0 : (((value) = (value) * 10 + (*fieldstr - '0')) , 1)))) {
                size_t len = strspn(num_start, "0123456789");
                char *bad_num = xstrndup(num_start, len);
                if (operating_mode == byte_mode)
                    error(0, 0, gettext("byte offset %s is too large"), quote(bad_num));
                else
                    error(0, 0, gettext("field number %s is too large"), quote(bad_num));
                free(bad_num);
                exit(1);
            }
            fieldstr++;
        } else
            do {
                error(0, 0, (gettext("invalid byte or field list")));
                usage(1);
            } while (0);
    }


BasicTester, a patch instance with id 70:
Spawn 1 instances, now Total 111
Counter: 112
Batcher Size:51
Preprocess the following candidate with BasicTester:
Priority 7465
At location src/cut.c:363
--Src File: src/cut.c
Fragment 0:
setlocale(6, "");
while (1)
    {
        if (*fieldstr == '-') {
            in_digits = 0;
            if (dash_found)
                do {
                    error(0, 0, (gettext("invalid byte or field list")));
                    usage(1);
                } while (0);
            dash_found = 1;
            fieldstr++;
            initial = (lhs_specified ? value : 1);
            value = 0;
        } else if (*fieldstr == ',' || ((*__ctype_b_loc())[(int)((to_uchar(*fieldstr)))] & (unsigned short)_ISblank) || *fieldstr == '\x00') {
            in_digits = 0;
            if (dash_found) {
                dash_found = 0;
                if (!lhs_specified && !rhs_specified)
                    do {
                        error(0, 0, (gettext("invalid range with no endpoint: -")));
                        usage(1);
                    } while (0);
                if (!rhs_specified) {
                    eol_range_start = initial;
                    field_found = 1;
                } else {
                    if (value < initial)
                        do {
                            error(0, 0, (gettext("invalid decreasing range")));
                            usage(1);
                        } while (0);
                    if (eol_range_start != 0) {
                        if (initial < eol_range_start) {
                            if (eol_range_start <= value) {
                                eol_range_start = initial;
                            } else {
                                do {
                                    if (initial == 0 || value == 0)
                                        do {
                                            error(0, 0, (gettext("fields and positions are numbered from 1")));
                                            usage(1);
                                        } while (0);
                                    if (n_rp >= n_rp_allocated) {
                                        (rp) = x2nrealloc(rp, &n_rp_allocated, sizeof *(rp));
                                    }
                                    rp[n_rp].lo = (initial);
                                    rp[n_rp].hi = (value);
                                    ++n_rp;
                                } while (0);
                            }
                            field_found = 1;
                        }
                    } else {
                        do {
                            if (initial == 0 || value == 0)
                                do {
                                    error(0, 0, (gettext("fields and positions are numbered from 1")));
                                    usage(1);
                                } while (0);
                            if (n_rp >= n_rp_allocated) {
                                (rp) = x2nrealloc(rp, &n_rp_allocated, sizeof *(rp));
                            }
                            rp[n_rp].lo = (initial);
                            rp[n_rp].hi = (value);
                            ++n_rp;
                        } while (0);
                        field_found = 1;
                    }
                    value = 0;
                }
            } else {
                do {
                    if (value == 0 || value == 0)
                        do {
                            error(0, 0, (gettext("fields and positions are numbered from 1")));
                            usage(1);
                        } while (0);
                    if (n_rp >= n_rp_allocated) {
                        (rp) = x2nrealloc(rp, &n_rp_allocated, sizeof *(rp));
                    }
                    rp[n_rp].lo = (value);
                    rp[n_rp].hi = (value);
                    ++n_rp;
                } while (0);
                value = 0;
                field_found = 1;
            }
            if (*fieldstr == '\x00') {
                break;
            }
            fieldstr++;
            lhs_specified = 0;
            rhs_specified = 0;
        } else if (((unsigned int)(*fieldstr) - '0' <= 9)) {
            static const char *num_start;
            if (!in_digits || !num_start)
                num_start = fieldstr;
            in_digits = 1;
            if (dash_found)
                rhs_specified = 1;
            else
                lhs_specified = 1;
            if (!((void)(&(value) == (size_t *)((void *)0)) , (((size_t)-1 / 10 < (value) || (size_t)((value) * 10 + (*fieldstr - '0')) < (value)) ? 0 : (((value) = (value) * 10 + (*fieldstr - '0')) , 1)))) {
                size_t len = strspn(num_start, "0123456789");
                char *bad_num = xstrndup(num_start, len);
                if (operating_mode == byte_mode)
                    error(0, 0, gettext("byte offset %s is too large"), quote(bad_num));
                else
                    error(0, 0, gettext("field number %s is too large"), quote(bad_num));
                free(bad_num);
                exit(1);
            }
            fieldstr++;
        } else
            do {
                error(0, 0, (gettext("invalid byte or field list")));
                usage(1);
            } while (0);
    }


BasicTester, a patch instance with id 71:
Spawn 1 instances, now Total 112
Counter: 113
Batcher Size:52
Preprocess the following candidate with BasicTester:
Priority 7465
At location src/cut.c:363
--Src File: src/cut.c
Fragment 0:
suppress_non_delimited = (field_found);
while (1)
    {
        if (*fieldstr == '-') {
            in_digits = 0;
            if (dash_found)
                do {
                    error(0, 0, (gettext("invalid byte or field list")));
                    usage(1);
                } while (0);
            dash_found = 1;
            fieldstr++;
            initial = (lhs_specified ? value : 1);
            value = 0;
        } else if (*fieldstr == ',' || ((*__ctype_b_loc())[(int)((to_uchar(*fieldstr)))] & (unsigned short)_ISblank) || *fieldstr == '\x00') {
            in_digits = 0;
            if (dash_found) {
                dash_found = 0;
                if (!lhs_specified && !rhs_specified)
                    do {
                        error(0, 0, (gettext("invalid range with no endpoint: -")));
                        usage(1);
                    } while (0);
                if (!rhs_specified) {
                    eol_range_start = initial;
                    field_found = 1;
                } else {
                    if (value < initial)
                        do {
                            error(0, 0, (gettext("invalid decreasing range")));
                            usage(1);
                        } while (0);
                    if (eol_range_start != 0) {
                        if (initial < eol_range_start) {
                            if (eol_range_start <= value) {
                                eol_range_start = initial;
                            } else {
                                do {
                                    if (initial == 0 || value == 0)
                                        do {
                                            error(0, 0, (gettext("fields and positions are numbered from 1")));
                                            usage(1);
                                        } while (0);
                                    if (n_rp >= n_rp_allocated) {
                                        (rp) = x2nrealloc(rp, &n_rp_allocated, sizeof *(rp));
                                    }
                                    rp[n_rp].lo = (initial);
                                    rp[n_rp].hi = (value);
                                    ++n_rp;
                                } while (0);
                            }
                            field_found = 1;
                        }
                    } else {
                        do {
                            if (initial == 0 || value == 0)
                                do {
                                    error(0, 0, (gettext("fields and positions are numbered from 1")));
                                    usage(1);
                                } while (0);
                            if (n_rp >= n_rp_allocated) {
                                (rp) = x2nrealloc(rp, &n_rp_allocated, sizeof *(rp));
                            }
                            rp[n_rp].lo = (initial);
                            rp[n_rp].hi = (value);
                            ++n_rp;
                        } while (0);
                        field_found = 1;
                    }
                    value = 0;
                }
            } else {
                do {
                    if (value == 0 || value == 0)
                        do {
                            error(0, 0, (gettext("fields and positions are numbered from 1")));
                            usage(1);
                        } while (0);
                    if (n_rp >= n_rp_allocated) {
                        (rp) = x2nrealloc(rp, &n_rp_allocated, sizeof *(rp));
                    }
                    rp[n_rp].lo = (value);
                    rp[n_rp].hi = (value);
                    ++n_rp;
                } while (0);
                value = 0;
                field_found = 1;
            }
            if (*fieldstr == '\x00') {
                break;
            }
            fieldstr++;
            lhs_specified = 0;
            rhs_specified = 0;
        } else if (((unsigned int)(*fieldstr) - '0' <= 9)) {
            static const char *num_start;
            if (!in_digits || !num_start)
                num_start = fieldstr;
            in_digits = 1;
            if (dash_found)
                rhs_specified = 1;
            else
                lhs_specified = 1;
            if (!((void)(&(value) == (size_t *)((void *)0)) , (((size_t)-1 / 10 < (value) || (size_t)((value) * 10 + (*fieldstr - '0')) < (value)) ? 0 : (((value) = (value) * 10 + (*fieldstr - '0')) , 1)))) {
                size_t len = strspn(num_start, "0123456789");
                char *bad_num = xstrndup(num_start, len);
                if (operating_mode == byte_mode)
                    error(0, 0, gettext("byte offset %s is too large"), quote(bad_num));
                else
                    error(0, 0, gettext("field number %s is too large"), quote(bad_num));
                free(bad_num);
                exit(1);
            }
            fieldstr++;
        } else
            do {
                error(0, 0, (gettext("invalid byte or field list")));
                usage(1);
            } while (0);
    }


BasicTester, a patch instance with id 72:
Spawn 1 instances, now Total 113
a batched test job starts!
Building:src at:
/home/ubuntu/spr-fast/tests/corebench/coreutils/coreutils-case-7380cf79-2e636af1/tempworkdir/srcMerged code building succ, going to invoke tester!
BasicTester, Testing instance id 63:
Running test command:
/home/ubuntu/spr-fast/tools/coreutils-test.py /home/ubuntu/spr-fast/tests/corebench/coreutils/coreutils-case-7380cf79-2e636af1/tempworkdir/src /home/ubuntu/spr-fast/tests/corebench/coreutils/coreutils-case-7380cf79-2e636af1/tempworkdir/tests /home/ubuntu/spr-fast/tests/corebench/coreutils/coreutils-case-7380cf79-2e636af1/tempworkdir 0  > __res
BasicTester, Testing instance id 64:
Running test command:
/home/ubuntu/spr-fast/tools/coreutils-test.py /home/ubuntu/spr-fast/tests/corebench/coreutils/coreutils-case-7380cf79-2e636af1/tempworkdir/src /home/ubuntu/spr-fast/tests/corebench/coreutils/coreutils-case-7380cf79-2e636af1/tempworkdir/tests /home/ubuntu/spr-fast/tests/corebench/coreutils/coreutils-case-7380cf79-2e636af1/tempworkdir 0  > __res
BasicTester, Testing instance id 65:
Running test command:
/home/ubuntu/spr-fast/tools/coreutils-test.py /home/ubuntu/spr-fast/tests/corebench/coreutils/coreutils-case-7380cf79-2e636af1/tempworkdir/src /home/ubuntu/spr-fast/tests/corebench/coreutils/coreutils-case-7380cf79-2e636af1/tempworkdir/tests /home/ubuntu/spr-fast/tests/corebench/coreutils/coreutils-case-7380cf79-2e636af1/tempworkdir 0  > __res
BasicTester, Testing instance id 66:
Running test command:
/home/ubuntu/spr-fast/tools/coreutils-test.py /home/ubuntu/spr-fast/tests/corebench/coreutils/coreutils-case-7380cf79-2e636af1/tempworkdir/src /home/ubuntu/spr-fast/tests/corebench/coreutils/coreutils-case-7380cf79-2e636af1/tempworkdir/tests /home/ubuntu/spr-fast/tests/corebench/coreutils/coreutils-case-7380cf79-2e636af1/tempworkdir 0  > __res
BasicTester, Testing instance id 67:
Running test command:
/home/ubuntu/spr-fast/tools/coreutils-test.py /home/ubuntu/spr-fast/tests/corebench/coreutils/coreutils-case-7380cf79-2e636af1/tempworkdir/src /home/ubuntu/spr-fast/tests/corebench/coreutils/coreutils-case-7380cf79-2e636af1/tempworkdir/tests /home/ubuntu/spr-fast/tests/corebench/coreutils/coreutils-case-7380cf79-2e636af1/tempworkdir 0  > __res
BasicTester, Testing instance id 68:
Running test command:
/home/ubuntu/spr-fast/tools/coreutils-test.py /home/ubuntu/spr-fast/tests/corebench/coreutils/coreutils-case-7380cf79-2e636af1/tempworkdir/src /home/ubuntu/spr-fast/tests/corebench/coreutils/coreutils-case-7380cf79-2e636af1/tempworkdir/tests /home/ubuntu/spr-fast/tests/corebench/coreutils/coreutils-case-7380cf79-2e636af1/tempworkdir 0  > __res
BasicTester, Testing instance id 69:
Running test command:
/home/ubuntu/spr-fast/tools/coreutils-test.py /home/ubuntu/spr-fast/tests/corebench/coreutils/coreutils-case-7380cf79-2e636af1/tempworkdir/src /home/ubuntu/spr-fast/tests/corebench/coreutils/coreutils-case-7380cf79-2e636af1/tempworkdir/tests /home/ubuntu/spr-fast/tests/corebench/coreutils/coreutils-case-7380cf79-2e636af1/tempworkdir 0  > __res
BasicTester, Testing instance id 70:
Running test command:
/home/ubuntu/spr-fast/tools/coreutils-test.py /home/ubuntu/spr-fast/tests/corebench/coreutils/coreutils-case-7380cf79-2e636af1/tempworkdir/src /home/ubuntu/spr-fast/tests/corebench/coreutils/coreutils-case-7380cf79-2e636af1/tempworkdir/tests /home/ubuntu/spr-fast/tests/corebench/coreutils/coreutils-case-7380cf79-2e636af1/tempworkdir 0  > __res
BasicTester, Testing instance id 71:
Running test command:
/home/ubuntu/spr-fast/tools/coreutils-test.py /home/ubuntu/spr-fast/tests/corebench/coreutils/coreutils-case-7380cf79-2e636af1/tempworkdir/src /home/ubuntu/spr-fast/tests/corebench/coreutils/coreutils-case-7380cf79-2e636af1/tempworkdir/tests /home/ubuntu/spr-fast/tests/corebench/coreutils/coreutils-case-7380cf79-2e636af1/tempworkdir 0  > __res
BasicTester, Testing instance id 72:
Running test command:
/home/ubuntu/spr-fast/tools/coreutils-test.py /home/ubuntu/spr-fast/tests/corebench/coreutils/coreutils-case-7380cf79-2e636af1/tempworkdir/src /home/ubuntu/spr-fast/tests/corebench/coreutils/coreutils-case-7380cf79-2e636af1/tempworkdir/tests /home/ubuntu/spr-fast/tests/corebench/coreutils/coreutils-case-7380cf79-2e636af1/tempworkdir 0  > __res
Counter: 114
Batcher Size:43
Preprocess the following candidate with BasicTester:
Priority 7465
At location src/cut.c:363
--Src File: src/cut.c
Fragment 0:
suppress_non_delimited = (in_digits);
while (1)
    {
        if (*fieldstr == '-') {
            in_digits = 0;
            if (dash_found)
                do {
                    error(0, 0, (gettext("invalid byte or field list")));
                    usage(1);
                } while (0);
            dash_found = 1;
            fieldstr++;
            initial = (lhs_specified ? value : 1);
            value = 0;
        } else if (*fieldstr == ',' || ((*__ctype_b_loc())[(int)((to_uchar(*fieldstr)))] & (unsigned short)_ISblank) || *fieldstr == '\x00') {
            in_digits = 0;
            if (dash_found) {
                dash_found = 0;
                if (!lhs_specified && !rhs_specified)
                    do {
                        error(0, 0, (gettext("invalid range with no endpoint: -")));
                        usage(1);
                    } while (0);
                if (!rhs_specified) {
                    eol_range_start = initial;
                    field_found = 1;
                } else {
                    if (value < initial)
                        do {
                            error(0, 0, (gettext("invalid decreasing range")));
                            usage(1);
                        } while (0);
                    if (eol_range_start != 0) {
                        if (initial < eol_range_start) {
                            if (eol_range_start <= value) {
                                eol_range_start = initial;
                            } else {
                                do {
                                    if (initial == 0 || value == 0)
                                        do {
                                            error(0, 0, (gettext("fields and positions are numbered from 1")));
                                            usage(1);
                                        } while (0);
                                    if (n_rp >= n_rp_allocated) {
                                        (rp) = x2nrealloc(rp, &n_rp_allocated, sizeof *(rp));
                                    }
                                    rp[n_rp].lo = (initial);
                                    rp[n_rp].hi = (value);
                                    ++n_rp;
                                } while (0);
                            }
                            field_found = 1;
                        }
                    } else {
                        do {
                            if (initial == 0 || value == 0)
                                do {
                                    error(0, 0, (gettext("fields and positions are numbered from 1")));
                                    usage(1);
                                } while (0);
                            if (n_rp >= n_rp_allocated) {
                                (rp) = x2nrealloc(rp, &n_rp_allocated, sizeof *(rp));
                            }
                            rp[n_rp].lo = (initial);
                            rp[n_rp].hi = (value);
                            ++n_rp;
                        } while (0);
                        field_found = 1;
                    }
                    value = 0;
                }
            } else {
                do {
                    if (value == 0 || value == 0)
                        do {
                            error(0, 0, (gettext("fields and positions are numbered from 1")));
                            usage(1);
                        } while (0);
                    if (n_rp >= n_rp_allocated) {
                        (rp) = x2nrealloc(rp, &n_rp_allocated, sizeof *(rp));
                    }
                    rp[n_rp].lo = (value);
                    rp[n_rp].hi = (value);
                    ++n_rp;
                } while (0);
                value = 0;
                field_found = 1;
            }
            if (*fieldstr == '\x00') {
                break;
            }
            fieldstr++;
            lhs_specified = 0;
            rhs_specified = 0;
        } else if (((unsigned int)(*fieldstr) - '0' <= 9)) {
            static const char *num_start;
            if (!in_digits || !num_start)
                num_start = fieldstr;
            in_digits = 1;
            if (dash_found)
                rhs_specified = 1;
            else
                lhs_specified = 1;
            if (!((void)(&(value) == (size_t *)((void *)0)) , (((size_t)-1 / 10 < (value) || (size_t)((value) * 10 + (*fieldstr - '0')) < (value)) ? 0 : (((value) = (value) * 10 + (*fieldstr - '0')) , 1)))) {
                size_t len = strspn(num_start, "0123456789");
                char *bad_num = xstrndup(num_start, len);
                if (operating_mode == byte_mode)
                    error(0, 0, gettext("byte offset %s is too large"), quote(bad_num));
                else
                    error(0, 0, gettext("field number %s is too large"), quote(bad_num));
                free(bad_num);
                exit(1);
            }
            fieldstr++;
        } else
            do {
                error(0, 0, (gettext("invalid byte or field list")));
                usage(1);
            } while (0);
    }


BasicTester, a patch instance with id 73:
Spawn 1 instances, now Total 114
Counter: 115
Batcher Size:44
Preprocess the following candidate with BasicTester:
Priority 7465
At location src/cut.c:363
--Src File: src/cut.c
Fragment 0:
suppress_non_delimited = (dash_found);
while (1)
    {
        if (*fieldstr == '-') {
            in_digits = 0;
            if (dash_found)
                do {
                    error(0, 0, (gettext("invalid byte or field list")));
                    usage(1);
                } while (0);
            dash_found = 1;
            fieldstr++;
            initial = (lhs_specified ? value : 1);
            value = 0;
        } else if (*fieldstr == ',' || ((*__ctype_b_loc())[(int)((to_uchar(*fieldstr)))] & (unsigned short)_ISblank) || *fieldstr == '\x00') {
            in_digits = 0;
            if (dash_found) {
                dash_found = 0;
                if (!lhs_specified && !rhs_specified)
                    do {
                        error(0, 0, (gettext("invalid range with no endpoint: -")));
                        usage(1);
                    } while (0);
                if (!rhs_specified) {
                    eol_range_start = initial;
                    field_found = 1;
                } else {
                    if (value < initial)
                        do {
                            error(0, 0, (gettext("invalid decreasing range")));
                            usage(1);
                        } while (0);
                    if (eol_range_start != 0) {
                        if (initial < eol_range_start) {
                            if (eol_range_start <= value) {
                                eol_range_start = initial;
                            } else {
                                do {
                                    if (initial == 0 || value == 0)
                                        do {
                                            error(0, 0, (gettext("fields and positions are numbered from 1")));
                                            usage(1);
                                        } while (0);
                                    if (n_rp >= n_rp_allocated) {
                                        (rp) = x2nrealloc(rp, &n_rp_allocated, sizeof *(rp));
                                    }
                                    rp[n_rp].lo = (initial);
                                    rp[n_rp].hi = (value);
                                    ++n_rp;
                                } while (0);
                            }
                            field_found = 1;
                        }
                    } else {
                        do {
                            if (initial == 0 || value == 0)
                                do {
                                    error(0, 0, (gettext("fields and positions are numbered from 1")));
                                    usage(1);
                                } while (0);
                            if (n_rp >= n_rp_allocated) {
                                (rp) = x2nrealloc(rp, &n_rp_allocated, sizeof *(rp));
                            }
                            rp[n_rp].lo = (initial);
                            rp[n_rp].hi = (value);
                            ++n_rp;
                        } while (0);
                        field_found = 1;
                    }
                    value = 0;
                }
            } else {
                do {
                    if (value == 0 || value == 0)
                        do {
                            error(0, 0, (gettext("fields and positions are numbered from 1")));
                            usage(1);
                        } while (0);
                    if (n_rp >= n_rp_allocated) {
                        (rp) = x2nrealloc(rp, &n_rp_allocated, sizeof *(rp));
                    }
                    rp[n_rp].lo = (value);
                    rp[n_rp].hi = (value);
                    ++n_rp;
                } while (0);
                value = 0;
                field_found = 1;
            }
            if (*fieldstr == '\x00') {
                break;
            }
            fieldstr++;
            lhs_specified = 0;
            rhs_specified = 0;
        } else if (((unsigned int)(*fieldstr) - '0' <= 9)) {
            static const char *num_start;
            if (!in_digits || !num_start)
                num_start = fieldstr;
            in_digits = 1;
            if (dash_found)
                rhs_specified = 1;
            else
                lhs_specified = 1;
            if (!((void)(&(value) == (size_t *)((void *)0)) , (((size_t)-1 / 10 < (value) || (size_t)((value) * 10 + (*fieldstr - '0')) < (value)) ? 0 : (((value) = (value) * 10 + (*fieldstr - '0')) , 1)))) {
                size_t len = strspn(num_start, "0123456789");
                char *bad_num = xstrndup(num_start, len);
                if (operating_mode == byte_mode)
                    error(0, 0, gettext("byte offset %s is too large"), quote(bad_num));
                else
                    error(0, 0, gettext("field number %s is too large"), quote(bad_num));
                free(bad_num);
                exit(1);
            }
            fieldstr++;
        } else
            do {
                error(0, 0, (gettext("invalid byte or field list")));
                usage(1);
            } while (0);
    }


BasicTester, a patch instance with id 74:
Spawn 1 instances, now Total 115
Counter: 116
Batcher Size:45
Preprocess the following candidate with BasicTester:
Priority 7465
At location src/cut.c:363
--Src File: src/cut.c
Fragment 0:
rhs_specified = (rhs_specified);
while (1)
    {
        if (*fieldstr == '-') {
            in_digits = 0;
            if (dash_found)
                do {
                    error(0, 0, (gettext("invalid byte or field list")));
                    usage(1);
                } while (0);
            dash_found = 1;
            fieldstr++;
            initial = (lhs_specified ? value : 1);
            value = 0;
        } else if (*fieldstr == ',' || ((*__ctype_b_loc())[(int)((to_uchar(*fieldstr)))] & (unsigned short)_ISblank) || *fieldstr == '\x00') {
            in_digits = 0;
            if (dash_found) {
                dash_found = 0;
                if (!lhs_specified && !rhs_specified)
                    do {
                        error(0, 0, (gettext("invalid range with no endpoint: -")));
                        usage(1);
                    } while (0);
                if (!rhs_specified) {
                    eol_range_start = initial;
                    field_found = 1;
                } else {
                    if (value < initial)
                        do {
                            error(0, 0, (gettext("invalid decreasing range")));
                            usage(1);
                        } while (0);
                    if (eol_range_start != 0) {
                        if (initial < eol_range_start) {
                            if (eol_range_start <= value) {
                                eol_range_start = initial;
                            } else {
                                do {
                                    if (initial == 0 || value == 0)
                                        do {
                                            error(0, 0, (gettext("fields and positions are numbered from 1")));
                                            usage(1);
                                        } while (0);
                                    if (n_rp >= n_rp_allocated) {
                                        (rp) = x2nrealloc(rp, &n_rp_allocated, sizeof *(rp));
                                    }
                                    rp[n_rp].lo = (initial);
                                    rp[n_rp].hi = (value);
                                    ++n_rp;
                                } while (0);
                            }
                            field_found = 1;
                        }
                    } else {
                        do {
                            if (initial == 0 || value == 0)
                                do {
                                    error(0, 0, (gettext("fields and positions are numbered from 1")));
                                    usage(1);
                                } while (0);
                            if (n_rp >= n_rp_allocated) {
                                (rp) = x2nrealloc(rp, &n_rp_allocated, sizeof *(rp));
                            }
                            rp[n_rp].lo = (initial);
                            rp[n_rp].hi = (value);
                            ++n_rp;
                        } while (0);
                        field_found = 1;
                    }
                    value = 0;
                }
            } else {
                do {
                    if (value == 0 || value == 0)
                        do {
                            error(0, 0, (gettext("fields and positions are numbered from 1")));
                            usage(1);
                        } while (0);
                    if (n_rp >= n_rp_allocated) {
                        (rp) = x2nrealloc(rp, &n_rp_allocated, sizeof *(rp));
                    }
                    rp[n_rp].lo = (value);
                    rp[n_rp].hi = (value);
                    ++n_rp;
                } while (0);
                value = 0;
                field_found = 1;
            }
            if (*fieldstr == '\x00') {
                break;
            }
            fieldstr++;
            lhs_specified = 0;
            rhs_specified = 0;
        } else if (((unsigned int)(*fieldstr) - '0' <= 9)) {
            static const char *num_start;
            if (!in_digits || !num_start)
                num_start = fieldstr;
            in_digits = 1;
            if (dash_found)
                rhs_specified = 1;
            else
                lhs_specified = 1;
            if (!((void)(&(value) == (size_t *)((void *)0)) , (((size_t)-1 / 10 < (value) || (size_t)((value) * 10 + (*fieldstr - '0')) < (value)) ? 0 : (((value) = (value) * 10 + (*fieldstr - '0')) , 1)))) {
                size_t len = strspn(num_start, "0123456789");
                char *bad_num = xstrndup(num_start, len);
                if (operating_mode == byte_mode)
                    error(0, 0, gettext("byte offset %s is too large"), quote(bad_num));
                else
                    error(0, 0, gettext("field number %s is too large"), quote(bad_num));
                free(bad_num);
                exit(1);
            }
            fieldstr++;
        } else
            do {
                error(0, 0, (gettext("invalid byte or field list")));
                usage(1);
            } while (0);
    }


BasicTester, a patch instance with id 75:
Spawn 1 instances, now Total 116
Counter: 117
Batcher Size:46
Preprocess the following candidate with BasicTester:
Priority 7465
At location src/cut.c:363
--Src File: src/cut.c
Fragment 0:
rhs_specified = 0;
while (1)
    {
        if (*fieldstr == '-') {
            in_digits = 0;
            if (dash_found)
                do {
                    error(0, 0, (gettext("invalid byte or field list")));
                    usage(1);
                } while (0);
            dash_found = 1;
            fieldstr++;
            initial = (lhs_specified ? value : 1);
            value = 0;
        } else if (*fieldstr == ',' || ((*__ctype_b_loc())[(int)((to_uchar(*fieldstr)))] & (unsigned short)_ISblank) || *fieldstr == '\x00') {
            in_digits = 0;
            if (dash_found) {
                dash_found = 0;
                if (!lhs_specified && !rhs_specified)
                    do {
                        error(0, 0, (gettext("invalid range with no endpoint: -")));
                        usage(1);
                    } while (0);
                if (!rhs_specified) {
                    eol_range_start = initial;
                    field_found = 1;
                } else {
                    if (value < initial)
                        do {
                            error(0, 0, (gettext("invalid decreasing range")));
                            usage(1);
                        } while (0);
                    if (eol_range_start != 0) {
                        if (initial < eol_range_start) {
                            if (eol_range_start <= value) {
                                eol_range_start = initial;
                            } else {
                                do {
                                    if (initial == 0 || value == 0)
                                        do {
                                            error(0, 0, (gettext("fields and positions are numbered from 1")));
                                            usage(1);
                                        } while (0);
                                    if (n_rp >= n_rp_allocated) {
                                        (rp) = x2nrealloc(rp, &n_rp_allocated, sizeof *(rp));
                                    }
                                    rp[n_rp].lo = (initial);
                                    rp[n_rp].hi = (value);
                                    ++n_rp;
                                } while (0);
                            }
                            field_found = 1;
                        }
                    } else {
                        do {
                            if (initial == 0 || value == 0)
                                do {
                                    error(0, 0, (gettext("fields and positions are numbered from 1")));
                                    usage(1);
                                } while (0);
                            if (n_rp >= n_rp_allocated) {
                                (rp) = x2nrealloc(rp, &n_rp_allocated, sizeof *(rp));
                            }
                            rp[n_rp].lo = (initial);
                            rp[n_rp].hi = (value);
                            ++n_rp;
                        } while (0);
                        field_found = 1;
                    }
                    value = 0;
                }
            } else {
                do {
                    if (value == 0 || value == 0)
                        do {
                            error(0, 0, (gettext("fields and positions are numbered from 1")));
                            usage(1);
                        } while (0);
                    if (n_rp >= n_rp_allocated) {
                        (rp) = x2nrealloc(rp, &n_rp_allocated, sizeof *(rp));
                    }
                    rp[n_rp].lo = (value);
                    rp[n_rp].hi = (value);
                    ++n_rp;
                } while (0);
                value = 0;
                field_found = 1;
            }
            if (*fieldstr == '\x00') {
                break;
            }
            fieldstr++;
            lhs_specified = 0;
            rhs_specified = 0;
        } else if (((unsigned int)(*fieldstr) - '0' <= 9)) {
            static const char *num_start;
            if (!in_digits || !num_start)
                num_start = fieldstr;
            in_digits = 1;
            if (dash_found)
                rhs_specified = 1;
            else
                lhs_specified = 1;
            if (!((void)(&(value) == (size_t *)((void *)0)) , (((size_t)-1 / 10 < (value) || (size_t)((value) * 10 + (*fieldstr - '0')) < (value)) ? 0 : (((value) = (value) * 10 + (*fieldstr - '0')) , 1)))) {
                size_t len = strspn(num_start, "0123456789");
                char *bad_num = xstrndup(num_start, len);
                if (operating_mode == byte_mode)
                    error(0, 0, gettext("byte offset %s is too large"), quote(bad_num));
                else
                    error(0, 0, gettext("field number %s is too large"), quote(bad_num));
                free(bad_num);
                exit(1);
            }
            fieldstr++;
        } else
            do {
                error(0, 0, (gettext("invalid byte or field list")));
                usage(1);
            } while (0);
    }


BasicTester, a patch instance with id 76:
Spawn 1 instances, now Total 117
Counter: 118
Batcher Size:47
Preprocess the following candidate with BasicTester:
Priority 7465
At location src/cut.c:363
--Src File: src/cut.c
Fragment 0:
rhs_specified = 1;
while (1)
    {
        if (*fieldstr == '-') {
            in_digits = 0;
            if (dash_found)
                do {
                    error(0, 0, (gettext("invalid byte or field list")));
                    usage(1);
                } while (0);
            dash_found = 1;
            fieldstr++;
            initial = (lhs_specified ? value : 1);
            value = 0;
        } else if (*fieldstr == ',' || ((*__ctype_b_loc())[(int)((to_uchar(*fieldstr)))] & (unsigned short)_ISblank) || *fieldstr == '\x00') {
            in_digits = 0;
            if (dash_found) {
                dash_found = 0;
                if (!lhs_specified && !rhs_specified)
                    do {
                        error(0, 0, (gettext("invalid range with no endpoint: -")));
                        usage(1);
                    } while (0);
                if (!rhs_specified) {
                    eol_range_start = initial;
                    field_found = 1;
                } else {
                    if (value < initial)
                        do {
                            error(0, 0, (gettext("invalid decreasing range")));
                            usage(1);
                        } while (0);
                    if (eol_range_start != 0) {
                        if (initial < eol_range_start) {
                            if (eol_range_start <= value) {
                                eol_range_start = initial;
                            } else {
                                do {
                                    if (initial == 0 || value == 0)
                                        do {
                                            error(0, 0, (gettext("fields and positions are numbered from 1")));
                                            usage(1);
                                        } while (0);
                                    if (n_rp >= n_rp_allocated) {
                                        (rp) = x2nrealloc(rp, &n_rp_allocated, sizeof *(rp));
                                    }
                                    rp[n_rp].lo = (initial);
                                    rp[n_rp].hi = (value);
                                    ++n_rp;
                                } while (0);
                            }
                            field_found = 1;
                        }
                    } else {
                        do {
                            if (initial == 0 || value == 0)
                                do {
                                    error(0, 0, (gettext("fields and positions are numbered from 1")));
                                    usage(1);
                                } while (0);
                            if (n_rp >= n_rp_allocated) {
                                (rp) = x2nrealloc(rp, &n_rp_allocated, sizeof *(rp));
                            }
                            rp[n_rp].lo = (initial);
                            rp[n_rp].hi = (value);
                            ++n_rp;
                        } while (0);
                        field_found = 1;
                    }
                    value = 0;
                }
            } else {
                do {
                    if (value == 0 || value == 0)
                        do {
                            error(0, 0, (gettext("fields and positions are numbered from 1")));
                            usage(1);
                        } while (0);
                    if (n_rp >= n_rp_allocated) {
                        (rp) = x2nrealloc(rp, &n_rp_allocated, sizeof *(rp));
                    }
                    rp[n_rp].lo = (value);
                    rp[n_rp].hi = (value);
                    ++n_rp;
                } while (0);
                value = 0;
                field_found = 1;
            }
            if (*fieldstr == '\x00') {
                break;
            }
            fieldstr++;
            lhs_specified = 0;
            rhs_specified = 0;
        } else if (((unsigned int)(*fieldstr) - '0' <= 9)) {
            static const char *num_start;
            if (!in_digits || !num_start)
                num_start = fieldstr;
            in_digits = 1;
            if (dash_found)
                rhs_specified = 1;
            else
                lhs_specified = 1;
            if (!((void)(&(value) == (size_t *)((void *)0)) , (((size_t)-1 / 10 < (value) || (size_t)((value) * 10 + (*fieldstr - '0')) < (value)) ? 0 : (((value) = (value) * 10 + (*fieldstr - '0')) , 1)))) {
                size_t len = strspn(num_start, "0123456789");
                char *bad_num = xstrndup(num_start, len);
                if (operating_mode == byte_mode)
                    error(0, 0, gettext("byte offset %s is too large"), quote(bad_num));
                else
                    error(0, 0, gettext("field number %s is too large"), quote(bad_num));
                free(bad_num);
                exit(1);
            }
            fieldstr++;
        } else
            do {
                error(0, 0, (gettext("invalid byte or field list")));
                usage(1);
            } while (0);
    }


BasicTester, a patch instance with id 77:
Spawn 1 instances, now Total 118
Counter: 119
Batcher Size:48
Preprocess the following candidate with BasicTester:
Priority 7465
At location src/cut.c:363
--Src File: src/cut.c
Fragment 0:
printf(gettext("\nDisplay values are in units of the first available SIZE from --block-size,\nand the %s_BLOCK_SIZE, BLOCK_SIZE and BLOCKSIZE environment variables.\nOtherwise, units default to 1024 bytes (or 512 if POSIXLY_CORRECT is set).\n"), (fieldstr));
while (1)
    {
        if (*fieldstr == '-') {
            in_digits = 0;
            if (dash_found)
                do {
                    error(0, 0, (gettext("invalid byte or field list")));
                    usage(1);
                } while (0);
            dash_found = 1;
            fieldstr++;
            initial = (lhs_specified ? value : 1);
            value = 0;
        } else if (*fieldstr == ',' || ((*__ctype_b_loc())[(int)((to_uchar(*fieldstr)))] & (unsigned short)_ISblank) || *fieldstr == '\x00') {
            in_digits = 0;
            if (dash_found) {
                dash_found = 0;
                if (!lhs_specified && !rhs_specified)
                    do {
                        error(0, 0, (gettext("invalid range with no endpoint: -")));
                        usage(1);
                    } while (0);
                if (!rhs_specified) {
                    eol_range_start = initial;
                    field_found = 1;
                } else {
                    if (value < initial)
                        do {
                            error(0, 0, (gettext("invalid decreasing range")));
                            usage(1);
                        } while (0);
                    if (eol_range_start != 0) {
                        if (initial < eol_range_start) {
                            if (eol_range_start <= value) {
                                eol_range_start = initial;
                            } else {
                                do {
                                    if (initial == 0 || value == 0)
                                        do {
                                            error(0, 0, (gettext("fields and positions are numbered from 1")));
                                            usage(1);
                                        } while (0);
                                    if (n_rp >= n_rp_allocated) {
                                        (rp) = x2nrealloc(rp, &n_rp_allocated, sizeof *(rp));
                                    }
                                    rp[n_rp].lo = (initial);
                                    rp[n_rp].hi = (value);
                                    ++n_rp;
                                } while (0);
                            }
                            field_found = 1;
                        }
                    } else {
                        do {
                            if (initial == 0 || value == 0)
                                do {
                                    error(0, 0, (gettext("fields and positions are numbered from 1")));
                                    usage(1);
                                } while (0);
                            if (n_rp >= n_rp_allocated) {
                                (rp) = x2nrealloc(rp, &n_rp_allocated, sizeof *(rp));
                            }
                            rp[n_rp].lo = (initial);
                            rp[n_rp].hi = (value);
                            ++n_rp;
                        } while (0);
                        field_found = 1;
                    }
                    value = 0;
                }
            } else {
                do {
                    if (value == 0 || value == 0)
                        do {
                            error(0, 0, (gettext("fields and positions are numbered from 1")));
                            usage(1);
                        } while (0);
                    if (n_rp >= n_rp_allocated) {
                        (rp) = x2nrealloc(rp, &n_rp_allocated, sizeof *(rp));
                    }
                    rp[n_rp].lo = (value);
                    rp[n_rp].hi = (value);
                    ++n_rp;
                } while (0);
                value = 0;
                field_found = 1;
            }
            if (*fieldstr == '\x00') {
                break;
            }
            fieldstr++;
            lhs_specified = 0;
            rhs_specified = 0;
        } else if (((unsigned int)(*fieldstr) - '0' <= 9)) {
            static const char *num_start;
            if (!in_digits || !num_start)
                num_start = fieldstr;
            in_digits = 1;
            if (dash_found)
                rhs_specified = 1;
            else
                lhs_specified = 1;
            if (!((void)(&(value) == (size_t *)((void *)0)) , (((size_t)-1 / 10 < (value) || (size_t)((value) * 10 + (*fieldstr - '0')) < (value)) ? 0 : (((value) = (value) * 10 + (*fieldstr - '0')) , 1)))) {
                size_t len = strspn(num_start, "0123456789");
                char *bad_num = xstrndup(num_start, len);
                if (operating_mode == byte_mode)
                    error(0, 0, gettext("byte offset %s is too large"), quote(bad_num));
                else
                    error(0, 0, gettext("field number %s is too large"), quote(bad_num));
                free(bad_num);
                exit(1);
            }
            fieldstr++;
        } else
            do {
                error(0, 0, (gettext("invalid byte or field list")));
                usage(1);
            } while (0);
    }


BasicTester, a patch instance with id 78:
Spawn 1 instances, now Total 119
Counter: 120
Batcher Size:49
Preprocess the following candidate with BasicTester:
Priority 7465
At location src/cut.c:363
--Src File: src/cut.c
Fragment 0:
qsort(rp, n_rp, sizeof (rp[0]), compare_ranges);
while (1)
    {
        if (*fieldstr == '-') {
            in_digits = 0;
            if (dash_found)
                do {
                    error(0, 0, (gettext("invalid byte or field list")));
                    usage(1);
                } while (0);
            dash_found = 1;
            fieldstr++;
            initial = (lhs_specified ? value : 1);
            value = 0;
        } else if (*fieldstr == ',' || ((*__ctype_b_loc())[(int)((to_uchar(*fieldstr)))] & (unsigned short)_ISblank) || *fieldstr == '\x00') {
            in_digits = 0;
            if (dash_found) {
                dash_found = 0;
                if (!lhs_specified && !rhs_specified)
                    do {
                        error(0, 0, (gettext("invalid range with no endpoint: -")));
                        usage(1);
                    } while (0);
                if (!rhs_specified) {
                    eol_range_start = initial;
                    field_found = 1;
                } else {
                    if (value < initial)
                        do {
                            error(0, 0, (gettext("invalid decreasing range")));
                            usage(1);
                        } while (0);
                    if (eol_range_start != 0) {
                        if (initial < eol_range_start) {
                            if (eol_range_start <= value) {
                                eol_range_start = initial;
                            } else {
                                do {
                                    if (initial == 0 || value == 0)
                                        do {
                                            error(0, 0, (gettext("fields and positions are numbered from 1")));
                                            usage(1);
                                        } while (0);
                                    if (n_rp >= n_rp_allocated) {
                                        (rp) = x2nrealloc(rp, &n_rp_allocated, sizeof *(rp));
                                    }
                                    rp[n_rp].lo = (initial);
                                    rp[n_rp].hi = (value);
                                    ++n_rp;
                                } while (0);
                            }
                            field_found = 1;
                        }
                    } else {
                        do {
                            if (initial == 0 || value == 0)
                                do {
                                    error(0, 0, (gettext("fields and positions are numbered from 1")));
                                    usage(1);
                                } while (0);
                            if (n_rp >= n_rp_allocated) {
                                (rp) = x2nrealloc(rp, &n_rp_allocated, sizeof *(rp));
                            }
                            rp[n_rp].lo = (initial);
                            rp[n_rp].hi = (value);
                            ++n_rp;
                        } while (0);
                        field_found = 1;
                    }
                    value = 0;
                }
            } else {
                do {
                    if (value == 0 || value == 0)
                        do {
                            error(0, 0, (gettext("fields and positions are numbered from 1")));
                            usage(1);
                        } while (0);
                    if (n_rp >= n_rp_allocated) {
                        (rp) = x2nrealloc(rp, &n_rp_allocated, sizeof *(rp));
                    }
                    rp[n_rp].lo = (value);
                    rp[n_rp].hi = (value);
                    ++n_rp;
                } while (0);
                value = 0;
                field_found = 1;
            }
            if (*fieldstr == '\x00') {
                break;
            }
            fieldstr++;
            lhs_specified = 0;
            rhs_specified = 0;
        } else if (((unsigned int)(*fieldstr) - '0' <= 9)) {
            static const char *num_start;
            if (!in_digits || !num_start)
                num_start = fieldstr;
            in_digits = 1;
            if (dash_found)
                rhs_specified = 1;
            else
                lhs_specified = 1;
            if (!((void)(&(value) == (size_t *)((void *)0)) , (((size_t)-1 / 10 < (value) || (size_t)((value) * 10 + (*fieldstr - '0')) < (value)) ? 0 : (((value) = (value) * 10 + (*fieldstr - '0')) , 1)))) {
                size_t len = strspn(num_start, "0123456789");
                char *bad_num = xstrndup(num_start, len);
                if (operating_mode == byte_mode)
                    error(0, 0, gettext("byte offset %s is too large"), quote(bad_num));
                else
                    error(0, 0, gettext("field number %s is too large"), quote(bad_num));
                free(bad_num);
                exit(1);
            }
            fieldstr++;
        } else
            do {
                error(0, 0, (gettext("invalid byte or field list")));
                usage(1);
            } while (0);
    }


BasicTester, a patch instance with id 79:
Spawn 1 instances, now Total 120
Counter: 121
Batcher Size:50
Preprocess the following candidate with BasicTester:
Priority 7465
At location src/cut.c:363
--Src File: src/cut.c
Fragment 0:
rhs_specified = (field_found);
while (1)
    {
        if (*fieldstr == '-') {
            in_digits = 0;
            if (dash_found)
                do {
                    error(0, 0, (gettext("invalid byte or field list")));
                    usage(1);
                } while (0);
            dash_found = 1;
            fieldstr++;
            initial = (lhs_specified ? value : 1);
            value = 0;
        } else if (*fieldstr == ',' || ((*__ctype_b_loc())[(int)((to_uchar(*fieldstr)))] & (unsigned short)_ISblank) || *fieldstr == '\x00') {
            in_digits = 0;
            if (dash_found) {
                dash_found = 0;
                if (!lhs_specified && !rhs_specified)
                    do {
                        error(0, 0, (gettext("invalid range with no endpoint: -")));
                        usage(1);
                    } while (0);
                if (!rhs_specified) {
                    eol_range_start = initial;
                    field_found = 1;
                } else {
                    if (value < initial)
                        do {
                            error(0, 0, (gettext("invalid decreasing range")));
                            usage(1);
                        } while (0);
                    if (eol_range_start != 0) {
                        if (initial < eol_range_start) {
                            if (eol_range_start <= value) {
                                eol_range_start = initial;
                            } else {
                                do {
                                    if (initial == 0 || value == 0)
                                        do {
                                            error(0, 0, (gettext("fields and positions are numbered from 1")));
                                            usage(1);
                                        } while (0);
                                    if (n_rp >= n_rp_allocated) {
                                        (rp) = x2nrealloc(rp, &n_rp_allocated, sizeof *(rp));
                                    }
                                    rp[n_rp].lo = (initial);
                                    rp[n_rp].hi = (value);
                                    ++n_rp;
                                } while (0);
                            }
                            field_found = 1;
                        }
                    } else {
                        do {
                            if (initial == 0 || value == 0)
                                do {
                                    error(0, 0, (gettext("fields and positions are numbered from 1")));
                                    usage(1);
                                } while (0);
                            if (n_rp >= n_rp_allocated) {
                                (rp) = x2nrealloc(rp, &n_rp_allocated, sizeof *(rp));
                            }
                            rp[n_rp].lo = (initial);
                            rp[n_rp].hi = (value);
                            ++n_rp;
                        } while (0);
                        field_found = 1;
                    }
                    value = 0;
                }
            } else {
                do {
                    if (value == 0 || value == 0)
                        do {
                            error(0, 0, (gettext("fields and positions are numbered from 1")));
                            usage(1);
                        } while (0);
                    if (n_rp >= n_rp_allocated) {
                        (rp) = x2nrealloc(rp, &n_rp_allocated, sizeof *(rp));
                    }
                    rp[n_rp].lo = (value);
                    rp[n_rp].hi = (value);
                    ++n_rp;
                } while (0);
                value = 0;
                field_found = 1;
            }
            if (*fieldstr == '\x00') {
                break;
            }
            fieldstr++;
            lhs_specified = 0;
            rhs_specified = 0;
        } else if (((unsigned int)(*fieldstr) - '0' <= 9)) {
            static const char *num_start;
            if (!in_digits || !num_start)
                num_start = fieldstr;
            in_digits = 1;
            if (dash_found)
                rhs_specified = 1;
            else
                lhs_specified = 1;
            if (!((void)(&(value) == (size_t *)((void *)0)) , (((size_t)-1 / 10 < (value) || (size_t)((value) * 10 + (*fieldstr - '0')) < (value)) ? 0 : (((value) = (value) * 10 + (*fieldstr - '0')) , 1)))) {
                size_t len = strspn(num_start, "0123456789");
                char *bad_num = xstrndup(num_start, len);
                if (operating_mode == byte_mode)
                    error(0, 0, gettext("byte offset %s is too large"), quote(bad_num));
                else
                    error(0, 0, gettext("field number %s is too large"), quote(bad_num));
                free(bad_num);
                exit(1);
            }
            fieldstr++;
        } else
            do {
                error(0, 0, (gettext("invalid byte or field list")));
                usage(1);
            } while (0);
    }


BasicTester, a patch instance with id 80:
Spawn 1 instances, now Total 121
Counter: 122
Batcher Size:51
Preprocess the following candidate with BasicTester:
Priority 7465
At location src/cut.c:363
--Src File: src/cut.c
Fragment 0:
rhs_specified = (in_digits);
while (1)
    {
        if (*fieldstr == '-') {
            in_digits = 0;
            if (dash_found)
                do {
                    error(0, 0, (gettext("invalid byte or field list")));
                    usage(1);
                } while (0);
            dash_found = 1;
            fieldstr++;
            initial = (lhs_specified ? value : 1);
            value = 0;
        } else if (*fieldstr == ',' || ((*__ctype_b_loc())[(int)((to_uchar(*fieldstr)))] & (unsigned short)_ISblank) || *fieldstr == '\x00') {
            in_digits = 0;
            if (dash_found) {
                dash_found = 0;
                if (!lhs_specified && !rhs_specified)
                    do {
                        error(0, 0, (gettext("invalid range with no endpoint: -")));
                        usage(1);
                    } while (0);
                if (!rhs_specified) {
                    eol_range_start = initial;
                    field_found = 1;
                } else {
                    if (value < initial)
                        do {
                            error(0, 0, (gettext("invalid decreasing range")));
                            usage(1);
                        } while (0);
                    if (eol_range_start != 0) {
                        if (initial < eol_range_start) {
                            if (eol_range_start <= value) {
                                eol_range_start = initial;
                            } else {
                                do {
                                    if (initial == 0 || value == 0)
                                        do {
                                            error(0, 0, (gettext("fields and positions are numbered from 1")));
                                            usage(1);
                                        } while (0);
                                    if (n_rp >= n_rp_allocated) {
                                        (rp) = x2nrealloc(rp, &n_rp_allocated, sizeof *(rp));
                                    }
                                    rp[n_rp].lo = (initial);
                                    rp[n_rp].hi = (value);
                                    ++n_rp;
                                } while (0);
                            }
                            field_found = 1;
                        }
                    } else {
                        do {
                            if (initial == 0 || value == 0)
                                do {
                                    error(0, 0, (gettext("fields and positions are numbered from 1")));
                                    usage(1);
                                } while (0);
                            if (n_rp >= n_rp_allocated) {
                                (rp) = x2nrealloc(rp, &n_rp_allocated, sizeof *(rp));
                            }
                            rp[n_rp].lo = (initial);
                            rp[n_rp].hi = (value);
                            ++n_rp;
                        } while (0);
                        field_found = 1;
                    }
                    value = 0;
                }
            } else {
                do {
                    if (value == 0 || value == 0)
                        do {
                            error(0, 0, (gettext("fields and positions are numbered from 1")));
                            usage(1);
                        } while (0);
                    if (n_rp >= n_rp_allocated) {
                        (rp) = x2nrealloc(rp, &n_rp_allocated, sizeof *(rp));
                    }
                    rp[n_rp].lo = (value);
                    rp[n_rp].hi = (value);
                    ++n_rp;
                } while (0);
                value = 0;
                field_found = 1;
            }
            if (*fieldstr == '\x00') {
                break;
            }
            fieldstr++;
            lhs_specified = 0;
            rhs_specified = 0;
        } else if (((unsigned int)(*fieldstr) - '0' <= 9)) {
            static const char *num_start;
            if (!in_digits || !num_start)
                num_start = fieldstr;
            in_digits = 1;
            if (dash_found)
                rhs_specified = 1;
            else
                lhs_specified = 1;
            if (!((void)(&(value) == (size_t *)((void *)0)) , (((size_t)-1 / 10 < (value) || (size_t)((value) * 10 + (*fieldstr - '0')) < (value)) ? 0 : (((value) = (value) * 10 + (*fieldstr - '0')) , 1)))) {
                size_t len = strspn(num_start, "0123456789");
                char *bad_num = xstrndup(num_start, len);
                if (operating_mode == byte_mode)
                    error(0, 0, gettext("byte offset %s is too large"), quote(bad_num));
                else
                    error(0, 0, gettext("field number %s is too large"), quote(bad_num));
                free(bad_num);
                exit(1);
            }
            fieldstr++;
        } else
            do {
                error(0, 0, (gettext("invalid byte or field list")));
                usage(1);
            } while (0);
    }


BasicTester, a patch instance with id 81:
Spawn 1 instances, now Total 122
Counter: 123
Batcher Size:52
Preprocess the following candidate with BasicTester:
Priority 7465
At location src/cut.c:363
--Src File: src/cut.c
Fragment 0:
rhs_specified = (dash_found);
while (1)
    {
        if (*fieldstr == '-') {
            in_digits = 0;
            if (dash_found)
                do {
                    error(0, 0, (gettext("invalid byte or field list")));
                    usage(1);
                } while (0);
            dash_found = 1;
            fieldstr++;
            initial = (lhs_specified ? value : 1);
            value = 0;
        } else if (*fieldstr == ',' || ((*__ctype_b_loc())[(int)((to_uchar(*fieldstr)))] & (unsigned short)_ISblank) || *fieldstr == '\x00') {
            in_digits = 0;
            if (dash_found) {
                dash_found = 0;
                if (!lhs_specified && !rhs_specified)
                    do {
                        error(0, 0, (gettext("invalid range with no endpoint: -")));
                        usage(1);
                    } while (0);
                if (!rhs_specified) {
                    eol_range_start = initial;
                    field_found = 1;
                } else {
                    if (value < initial)
                        do {
                            error(0, 0, (gettext("invalid decreasing range")));
                            usage(1);
                        } while (0);
                    if (eol_range_start != 0) {
                        if (initial < eol_range_start) {
                            if (eol_range_start <= value) {
                                eol_range_start = initial;
                            } else {
                                do {
                                    if (initial == 0 || value == 0)
                                        do {
                                            error(0, 0, (gettext("fields and positions are numbered from 1")));
                                            usage(1);
                                        } while (0);
                                    if (n_rp >= n_rp_allocated) {
                                        (rp) = x2nrealloc(rp, &n_rp_allocated, sizeof *(rp));
                                    }
                                    rp[n_rp].lo = (initial);
                                    rp[n_rp].hi = (value);
                                    ++n_rp;
                                } while (0);
                            }
                            field_found = 1;
                        }
                    } else {
                        do {
                            if (initial == 0 || value == 0)
                                do {
                                    error(0, 0, (gettext("fields and positions are numbered from 1")));
                                    usage(1);
                                } while (0);
                            if (n_rp >= n_rp_allocated) {
                                (rp) = x2nrealloc(rp, &n_rp_allocated, sizeof *(rp));
                            }
                            rp[n_rp].lo = (initial);
                            rp[n_rp].hi = (value);
                            ++n_rp;
                        } while (0);
                        field_found = 1;
                    }
                    value = 0;
                }
            } else {
                do {
                    if (value == 0 || value == 0)
                        do {
                            error(0, 0, (gettext("fields and positions are numbered from 1")));
                            usage(1);
                        } while (0);
                    if (n_rp >= n_rp_allocated) {
                        (rp) = x2nrealloc(rp, &n_rp_allocated, sizeof *(rp));
                    }
                    rp[n_rp].lo = (value);
                    rp[n_rp].hi = (value);
                    ++n_rp;
                } while (0);
                value = 0;
                field_found = 1;
            }
            if (*fieldstr == '\x00') {
                break;
            }
            fieldstr++;
            lhs_specified = 0;
            rhs_specified = 0;
        } else if (((unsigned int)(*fieldstr) - '0' <= 9)) {
            static const char *num_start;
            if (!in_digits || !num_start)
                num_start = fieldstr;
            in_digits = 1;
            if (dash_found)
                rhs_specified = 1;
            else
                lhs_specified = 1;
            if (!((void)(&(value) == (size_t *)((void *)0)) , (((size_t)-1 / 10 < (value) || (size_t)((value) * 10 + (*fieldstr - '0')) < (value)) ? 0 : (((value) = (value) * 10 + (*fieldstr - '0')) , 1)))) {
                size_t len = strspn(num_start, "0123456789");
                char *bad_num = xstrndup(num_start, len);
                if (operating_mode == byte_mode)
                    error(0, 0, gettext("byte offset %s is too large"), quote(bad_num));
                else
                    error(0, 0, gettext("field number %s is too large"), quote(bad_num));
                free(bad_num);
                exit(1);
            }
            fieldstr++;
        } else
            do {
                error(0, 0, (gettext("invalid byte or field list")));
                usage(1);
            } while (0);
    }


BasicTester, a patch instance with id 82:
Spawn 1 instances, now Total 123
a batched test job starts!
Building:src at:
/home/ubuntu/spr-fast/tests/corebench/coreutils/coreutils-case-7380cf79-2e636af1/tempworkdir/srcMerged code building succ, going to invoke tester!
BasicTester, Testing instance id 73:
Running test command:
/home/ubuntu/spr-fast/tools/coreutils-test.py /home/ubuntu/spr-fast/tests/corebench/coreutils/coreutils-case-7380cf79-2e636af1/tempworkdir/src /home/ubuntu/spr-fast/tests/corebench/coreutils/coreutils-case-7380cf79-2e636af1/tempworkdir/tests /home/ubuntu/spr-fast/tests/corebench/coreutils/coreutils-case-7380cf79-2e636af1/tempworkdir 0  > __res
BasicTester, Testing instance id 74:
Running test command:
/home/ubuntu/spr-fast/tools/coreutils-test.py /home/ubuntu/spr-fast/tests/corebench/coreutils/coreutils-case-7380cf79-2e636af1/tempworkdir/src /home/ubuntu/spr-fast/tests/corebench/coreutils/coreutils-case-7380cf79-2e636af1/tempworkdir/tests /home/ubuntu/spr-fast/tests/corebench/coreutils/coreutils-case-7380cf79-2e636af1/tempworkdir 0  > __res
BasicTester, Testing instance id 75:
Running test command:
/home/ubuntu/spr-fast/tools/coreutils-test.py /home/ubuntu/spr-fast/tests/corebench/coreutils/coreutils-case-7380cf79-2e636af1/tempworkdir/src /home/ubuntu/spr-fast/tests/corebench/coreutils/coreutils-case-7380cf79-2e636af1/tempworkdir/tests /home/ubuntu/spr-fast/tests/corebench/coreutils/coreutils-case-7380cf79-2e636af1/tempworkdir 0  > __res
BasicTester, Testing instance id 76:
Running test command:
/home/ubuntu/spr-fast/tools/coreutils-test.py /home/ubuntu/spr-fast/tests/corebench/coreutils/coreutils-case-7380cf79-2e636af1/tempworkdir/src /home/ubuntu/spr-fast/tests/corebench/coreutils/coreutils-case-7380cf79-2e636af1/tempworkdir/tests /home/ubuntu/spr-fast/tests/corebench/coreutils/coreutils-case-7380cf79-2e636af1/tempworkdir 0  > __res
BasicTester, Testing instance id 77:
Running test command:
/home/ubuntu/spr-fast/tools/coreutils-test.py /home/ubuntu/spr-fast/tests/corebench/coreutils/coreutils-case-7380cf79-2e636af1/tempworkdir/src /home/ubuntu/spr-fast/tests/corebench/coreutils/coreutils-case-7380cf79-2e636af1/tempworkdir/tests /home/ubuntu/spr-fast/tests/corebench/coreutils/coreutils-case-7380cf79-2e636af1/tempworkdir 0  > __res
BasicTester, Testing instance id 78:
Running test command:
/home/ubuntu/spr-fast/tools/coreutils-test.py /home/ubuntu/spr-fast/tests/corebench/coreutils/coreutils-case-7380cf79-2e636af1/tempworkdir/src /home/ubuntu/spr-fast/tests/corebench/coreutils/coreutils-case-7380cf79-2e636af1/tempworkdir/tests /home/ubuntu/spr-fast/tests/corebench/coreutils/coreutils-case-7380cf79-2e636af1/tempworkdir 0  > __res
BasicTester, Testing instance id 79:
Running test command:
/home/ubuntu/spr-fast/tools/coreutils-test.py /home/ubuntu/spr-fast/tests/corebench/coreutils/coreutils-case-7380cf79-2e636af1/tempworkdir/src /home/ubuntu/spr-fast/tests/corebench/coreutils/coreutils-case-7380cf79-2e636af1/tempworkdir/tests /home/ubuntu/spr-fast/tests/corebench/coreutils/coreutils-case-7380cf79-2e636af1/tempworkdir 0  > __res
BasicTester, Testing instance id 80:
Running test command:
/home/ubuntu/spr-fast/tools/coreutils-test.py /home/ubuntu/spr-fast/tests/corebench/coreutils/coreutils-case-7380cf79-2e636af1/tempworkdir/src /home/ubuntu/spr-fast/tests/corebench/coreutils/coreutils-case-7380cf79-2e636af1/tempworkdir/tests /home/ubuntu/spr-fast/tests/corebench/coreutils/coreutils-case-7380cf79-2e636af1/tempworkdir 0  > __res
BasicTester, Testing instance id 81:
Running test command:
/home/ubuntu/spr-fast/tools/coreutils-test.py /home/ubuntu/spr-fast/tests/corebench/coreutils/coreutils-case-7380cf79-2e636af1/tempworkdir/src /home/ubuntu/spr-fast/tests/corebench/coreutils/coreutils-case-7380cf79-2e636af1/tempworkdir/tests /home/ubuntu/spr-fast/tests/corebench/coreutils/coreutils-case-7380cf79-2e636af1/tempworkdir 0  > __res
BasicTester, Testing instance id 82:
Running test command:
/home/ubuntu/spr-fast/tools/coreutils-test.py /home/ubuntu/spr-fast/tests/corebench/coreutils/coreutils-case-7380cf79-2e636af1/tempworkdir/src /home/ubuntu/spr-fast/tests/corebench/coreutils/coreutils-case-7380cf79-2e636af1/tempworkdir/tests /home/ubuntu/spr-fast/tests/corebench/coreutils/coreutils-case-7380cf79-2e636af1/tempworkdir 0  > __res
Counter: 124
Batcher Size:43
Preprocess the following candidate with BasicTester:
Priority 7465
At location src/cut.c:363
--Src File: src/cut.c
Fragment 0:
putchar('\n');
while (1)
    {
        if (*fieldstr == '-') {
            in_digits = 0;
            if (dash_found)
                do {
                    error(0, 0, (gettext("invalid byte or field list")));
                    usage(1);
                } while (0);
            dash_found = 1;
            fieldstr++;
            initial = (lhs_specified ? value : 1);
            value = 0;
        } else if (*fieldstr == ',' || ((*__ctype_b_loc())[(int)((to_uchar(*fieldstr)))] & (unsigned short)_ISblank) || *fieldstr == '\x00') {
            in_digits = 0;
            if (dash_found) {
                dash_found = 0;
                if (!lhs_specified && !rhs_specified)
                    do {
                        error(0, 0, (gettext("invalid range with no endpoint: -")));
                        usage(1);
                    } while (0);
                if (!rhs_specified) {
                    eol_range_start = initial;
                    field_found = 1;
                } else {
                    if (value < initial)
                        do {
                            error(0, 0, (gettext("invalid decreasing range")));
                            usage(1);
                        } while (0);
                    if (eol_range_start != 0) {
                        if (initial < eol_range_start) {
                            if (eol_range_start <= value) {
                                eol_range_start = initial;
                            } else {
                                do {
                                    if (initial == 0 || value == 0)
                                        do {
                                            error(0, 0, (gettext("fields and positions are numbered from 1")));
                                            usage(1);
                                        } while (0);
                                    if (n_rp >= n_rp_allocated) {
                                        (rp) = x2nrealloc(rp, &n_rp_allocated, sizeof *(rp));
                                    }
                                    rp[n_rp].lo = (initial);
                                    rp[n_rp].hi = (value);
                                    ++n_rp;
                                } while (0);
                            }
                            field_found = 1;
                        }
                    } else {
                        do {
                            if (initial == 0 || value == 0)
                                do {
                                    error(0, 0, (gettext("fields and positions are numbered from 1")));
                                    usage(1);
                                } while (0);
                            if (n_rp >= n_rp_allocated) {
                                (rp) = x2nrealloc(rp, &n_rp_allocated, sizeof *(rp));
                            }
                            rp[n_rp].lo = (initial);
                            rp[n_rp].hi = (value);
                            ++n_rp;
                        } while (0);
                        field_found = 1;
                    }
                    value = 0;
                }
            } else {
                do {
                    if (value == 0 || value == 0)
                        do {
                            error(0, 0, (gettext("fields and positions are numbered from 1")));
                            usage(1);
                        } while (0);
                    if (n_rp >= n_rp_allocated) {
                        (rp) = x2nrealloc(rp, &n_rp_allocated, sizeof *(rp));
                    }
                    rp[n_rp].lo = (value);
                    rp[n_rp].hi = (value);
                    ++n_rp;
                } while (0);
                value = 0;
                field_found = 1;
            }
            if (*fieldstr == '\x00') {
                break;
            }
            fieldstr++;
            lhs_specified = 0;
            rhs_specified = 0;
        } else if (((unsigned int)(*fieldstr) - '0' <= 9)) {
            static const char *num_start;
            if (!in_digits || !num_start)
                num_start = fieldstr;
            in_digits = 1;
            if (dash_found)
                rhs_specified = 1;
            else
                lhs_specified = 1;
            if (!((void)(&(value) == (size_t *)((void *)0)) , (((size_t)-1 / 10 < (value) || (size_t)((value) * 10 + (*fieldstr - '0')) < (value)) ? 0 : (((value) = (value) * 10 + (*fieldstr - '0')) , 1)))) {
                size_t len = strspn(num_start, "0123456789");
                char *bad_num = xstrndup(num_start, len);
                if (operating_mode == byte_mode)
                    error(0, 0, gettext("byte offset %s is too large"), quote(bad_num));
                else
                    error(0, 0, gettext("field number %s is too large"), quote(bad_num));
                free(bad_num);
                exit(1);
            }
            fieldstr++;
        } else
            do {
                error(0, 0, (gettext("invalid byte or field list")));
                usage(1);
            } while (0);
    }


BasicTester, a patch instance with id 83:
Spawn 1 instances, now Total 124
Counter: 125
Batcher Size:44
Preprocess the following candidate with BasicTester:
Priority 7465
At location src/cut.c:363
--Src File: src/cut.c
Fragment 0:
qsort((rp), n_rp, sizeof (rp[0]), compare_ranges);
while (1)
    {
        if (*fieldstr == '-') {
            in_digits = 0;
            if (dash_found)
                do {
                    error(0, 0, (gettext("invalid byte or field list")));
                    usage(1);
                } while (0);
            dash_found = 1;
            fieldstr++;
            initial = (lhs_specified ? value : 1);
            value = 0;
        } else if (*fieldstr == ',' || ((*__ctype_b_loc())[(int)((to_uchar(*fieldstr)))] & (unsigned short)_ISblank) || *fieldstr == '\x00') {
            in_digits = 0;
            if (dash_found) {
                dash_found = 0;
                if (!lhs_specified && !rhs_specified)
                    do {
                        error(0, 0, (gettext("invalid range with no endpoint: -")));
                        usage(1);
                    } while (0);
                if (!rhs_specified) {
                    eol_range_start = initial;
                    field_found = 1;
                } else {
                    if (value < initial)
                        do {
                            error(0, 0, (gettext("invalid decreasing range")));
                            usage(1);
                        } while (0);
                    if (eol_range_start != 0) {
                        if (initial < eol_range_start) {
                            if (eol_range_start <= value) {
                                eol_range_start = initial;
                            } else {
                                do {
                                    if (initial == 0 || value == 0)
                                        do {
                                            error(0, 0, (gettext("fields and positions are numbered from 1")));
                                            usage(1);
                                        } while (0);
                                    if (n_rp >= n_rp_allocated) {
                                        (rp) = x2nrealloc(rp, &n_rp_allocated, sizeof *(rp));
                                    }
                                    rp[n_rp].lo = (initial);
                                    rp[n_rp].hi = (value);
                                    ++n_rp;
                                } while (0);
                            }
                            field_found = 1;
                        }
                    } else {
                        do {
                            if (initial == 0 || value == 0)
                                do {
                                    error(0, 0, (gettext("fields and positions are numbered from 1")));
                                    usage(1);
                                } while (0);
                            if (n_rp >= n_rp_allocated) {
                                (rp) = x2nrealloc(rp, &n_rp_allocated, sizeof *(rp));
                            }
                            rp[n_rp].lo = (initial);
                            rp[n_rp].hi = (value);
                            ++n_rp;
                        } while (0);
                        field_found = 1;
                    }
                    value = 0;
                }
            } else {
                do {
                    if (value == 0 || value == 0)
                        do {
                            error(0, 0, (gettext("fields and positions are numbered from 1")));
                            usage(1);
                        } while (0);
                    if (n_rp >= n_rp_allocated) {
                        (rp) = x2nrealloc(rp, &n_rp_allocated, sizeof *(rp));
                    }
                    rp[n_rp].lo = (value);
                    rp[n_rp].hi = (value);
                    ++n_rp;
                } while (0);
                value = 0;
                field_found = 1;
            }
            if (*fieldstr == '\x00') {
                break;
            }
            fieldstr++;
            lhs_specified = 0;
            rhs_specified = 0;
        } else if (((unsigned int)(*fieldstr) - '0' <= 9)) {
            static const char *num_start;
            if (!in_digits || !num_start)
                num_start = fieldstr;
            in_digits = 1;
            if (dash_found)
                rhs_specified = 1;
            else
                lhs_specified = 1;
            if (!((void)(&(value) == (size_t *)((void *)0)) , (((size_t)-1 / 10 < (value) || (size_t)((value) * 10 + (*fieldstr - '0')) < (value)) ? 0 : (((value) = (value) * 10 + (*fieldstr - '0')) , 1)))) {
                size_t len = strspn(num_start, "0123456789");
                char *bad_num = xstrndup(num_start, len);
                if (operating_mode == byte_mode)
                    error(0, 0, gettext("byte offset %s is too large"), quote(bad_num));
                else
                    error(0, 0, gettext("field number %s is too large"), quote(bad_num));
                free(bad_num);
                exit(1);
            }
            fieldstr++;
        } else
            do {
                error(0, 0, (gettext("invalid byte or field list")));
                usage(1);
            } while (0);
    }


BasicTester, a patch instance with id 84:
Spawn 1 instances, now Total 125
Counter: 126
Batcher Size:45
Preprocess the following candidate with BasicTester:
Priority 7465
At location src/cut.c:363
--Src File: src/cut.c
Fragment 0:
output_delimiter_length = (9);
while (1)
    {
        if (*fieldstr == '-') {
            in_digits = 0;
            if (dash_found)
                do {
                    error(0, 0, (gettext("invalid byte or field list")));
                    usage(1);
                } while (0);
            dash_found = 1;
            fieldstr++;
            initial = (lhs_specified ? value : 1);
            value = 0;
        } else if (*fieldstr == ',' || ((*__ctype_b_loc())[(int)((to_uchar(*fieldstr)))] & (unsigned short)_ISblank) || *fieldstr == '\x00') {
            in_digits = 0;
            if (dash_found) {
                dash_found = 0;
                if (!lhs_specified && !rhs_specified)
                    do {
                        error(0, 0, (gettext("invalid range with no endpoint: -")));
                        usage(1);
                    } while (0);
                if (!rhs_specified) {
                    eol_range_start = initial;
                    field_found = 1;
                } else {
                    if (value < initial)
                        do {
                            error(0, 0, (gettext("invalid decreasing range")));
                            usage(1);
                        } while (0);
                    if (eol_range_start != 0) {
                        if (initial < eol_range_start) {
                            if (eol_range_start <= value) {
                                eol_range_start = initial;
                            } else {
                                do {
                                    if (initial == 0 || value == 0)
                                        do {
                                            error(0, 0, (gettext("fields and positions are numbered from 1")));
                                            usage(1);
                                        } while (0);
                                    if (n_rp >= n_rp_allocated) {
                                        (rp) = x2nrealloc(rp, &n_rp_allocated, sizeof *(rp));
                                    }
                                    rp[n_rp].lo = (initial);
                                    rp[n_rp].hi = (value);
                                    ++n_rp;
                                } while (0);
                            }
                            field_found = 1;
                        }
                    } else {
                        do {
                            if (initial == 0 || value == 0)
                                do {
                                    error(0, 0, (gettext("fields and positions are numbered from 1")));
                                    usage(1);
                                } while (0);
                            if (n_rp >= n_rp_allocated) {
                                (rp) = x2nrealloc(rp, &n_rp_allocated, sizeof *(rp));
                            }
                            rp[n_rp].lo = (initial);
                            rp[n_rp].hi = (value);
                            ++n_rp;
                        } while (0);
                        field_found = 1;
                    }
                    value = 0;
                }
            } else {
                do {
                    if (value == 0 || value == 0)
                        do {
                            error(0, 0, (gettext("fields and positions are numbered from 1")));
                            usage(1);
                        } while (0);
                    if (n_rp >= n_rp_allocated) {
                        (rp) = x2nrealloc(rp, &n_rp_allocated, sizeof *(rp));
                    }
                    rp[n_rp].lo = (value);
                    rp[n_rp].hi = (value);
                    ++n_rp;
                } while (0);
                value = 0;
                field_found = 1;
            }
            if (*fieldstr == '\x00') {
                break;
            }
            fieldstr++;
            lhs_specified = 0;
            rhs_specified = 0;
        } else if (((unsigned int)(*fieldstr) - '0' <= 9)) {
            static const char *num_start;
            if (!in_digits || !num_start)
                num_start = fieldstr;
            in_digits = 1;
            if (dash_found)
                rhs_specified = 1;
            else
                lhs_specified = 1;
            if (!((void)(&(value) == (size_t *)((void *)0)) , (((size_t)-1 / 10 < (value) || (size_t)((value) * 10 + (*fieldstr - '0')) < (value)) ? 0 : (((value) = (value) * 10 + (*fieldstr - '0')) , 1)))) {
                size_t len = strspn(num_start, "0123456789");
                char *bad_num = xstrndup(num_start, len);
                if (operating_mode == byte_mode)
                    error(0, 0, gettext("byte offset %s is too large"), quote(bad_num));
                else
                    error(0, 0, gettext("field number %s is too large"), quote(bad_num));
                free(bad_num);
                exit(1);
            }
            fieldstr++;
        } else
            do {
                error(0, 0, (gettext("invalid byte or field list")));
                usage(1);
            } while (0);
    }


BasicTester, a patch instance with id 85:
Spawn 1 instances, now Total 126
Counter: 127
Batcher Size:46
Preprocess the following candidate with BasicTester:
Priority 7465
At location src/cut.c:363
--Src File: src/cut.c
Fragment 0:
output_delimiter_length = (n_rp_allocated);
while (1)
    {
        if (*fieldstr == '-') {
            in_digits = 0;
            if (dash_found)
                do {
                    error(0, 0, (gettext("invalid byte or field list")));
                    usage(1);
                } while (0);
            dash_found = 1;
            fieldstr++;
            initial = (lhs_specified ? value : 1);
            value = 0;
        } else if (*fieldstr == ',' || ((*__ctype_b_loc())[(int)((to_uchar(*fieldstr)))] & (unsigned short)_ISblank) || *fieldstr == '\x00') {
            in_digits = 0;
            if (dash_found) {
                dash_found = 0;
                if (!lhs_specified && !rhs_specified)
                    do {
                        error(0, 0, (gettext("invalid range with no endpoint: -")));
                        usage(1);
                    } while (0);
                if (!rhs_specified) {
                    eol_range_start = initial;
                    field_found = 1;
                } else {
                    if (value < initial)
                        do {
                            error(0, 0, (gettext("invalid decreasing range")));
                            usage(1);
                        } while (0);
                    if (eol_range_start != 0) {
                        if (initial < eol_range_start) {
                            if (eol_range_start <= value) {
                                eol_range_start = initial;
                            } else {
                                do {
                                    if (initial == 0 || value == 0)
                                        do {
                                            error(0, 0, (gettext("fields and positions are numbered from 1")));
                                            usage(1);
                                        } while (0);
                                    if (n_rp >= n_rp_allocated) {
                                        (rp) = x2nrealloc(rp, &n_rp_allocated, sizeof *(rp));
                                    }
                                    rp[n_rp].lo = (initial);
                                    rp[n_rp].hi = (value);
                                    ++n_rp;
                                } while (0);
                            }
                            field_found = 1;
                        }
                    } else {
                        do {
                            if (initial == 0 || value == 0)
                                do {
                                    error(0, 0, (gettext("fields and positions are numbered from 1")));
                                    usage(1);
                                } while (0);
                            if (n_rp >= n_rp_allocated) {
                                (rp) = x2nrealloc(rp, &n_rp_allocated, sizeof *(rp));
                            }
                            rp[n_rp].lo = (initial);
                            rp[n_rp].hi = (value);
                            ++n_rp;
                        } while (0);
                        field_found = 1;
                    }
                    value = 0;
                }
            } else {
                do {
                    if (value == 0 || value == 0)
                        do {
                            error(0, 0, (gettext("fields and positions are numbered from 1")));
                            usage(1);
                        } while (0);
                    if (n_rp >= n_rp_allocated) {
                        (rp) = x2nrealloc(rp, &n_rp_allocated, sizeof *(rp));
                    }
                    rp[n_rp].lo = (value);
                    rp[n_rp].hi = (value);
                    ++n_rp;
                } while (0);
                value = 0;
                field_found = 1;
            }
            if (*fieldstr == '\x00') {
                break;
            }
            fieldstr++;
            lhs_specified = 0;
            rhs_specified = 0;
        } else if (((unsigned int)(*fieldstr) - '0' <= 9)) {
            static const char *num_start;
            if (!in_digits || !num_start)
                num_start = fieldstr;
            in_digits = 1;
            if (dash_found)
                rhs_specified = 1;
            else
                lhs_specified = 1;
            if (!((void)(&(value) == (size_t *)((void *)0)) , (((size_t)-1 / 10 < (value) || (size_t)((value) * 10 + (*fieldstr - '0')) < (value)) ? 0 : (((value) = (value) * 10 + (*fieldstr - '0')) , 1)))) {
                size_t len = strspn(num_start, "0123456789");
                char *bad_num = xstrndup(num_start, len);
                if (operating_mode == byte_mode)
                    error(0, 0, gettext("byte offset %s is too large"), quote(bad_num));
                else
                    error(0, 0, gettext("field number %s is too large"), quote(bad_num));
                free(bad_num);
                exit(1);
            }
            fieldstr++;
        } else
            do {
                error(0, 0, (gettext("invalid byte or field list")));
                usage(1);
            } while (0);
    }


BasicTester, a patch instance with id 86:
Spawn 1 instances, now Total 127
Counter: 128
Batcher Size:47
Preprocess the following candidate with BasicTester:
Priority 7465
At location src/cut.c:363
--Src File: src/cut.c
Fragment 0:
output_delimiter_length = (value);
while (1)
    {
        if (*fieldstr == '-') {
            in_digits = 0;
            if (dash_found)
                do {
                    error(0, 0, (gettext("invalid byte or field list")));
                    usage(1);
                } while (0);
            dash_found = 1;
            fieldstr++;
            initial = (lhs_specified ? value : 1);
            value = 0;
        } else if (*fieldstr == ',' || ((*__ctype_b_loc())[(int)((to_uchar(*fieldstr)))] & (unsigned short)_ISblank) || *fieldstr == '\x00') {
            in_digits = 0;
            if (dash_found) {
                dash_found = 0;
                if (!lhs_specified && !rhs_specified)
                    do {
                        error(0, 0, (gettext("invalid range with no endpoint: -")));
                        usage(1);
                    } while (0);
                if (!rhs_specified) {
                    eol_range_start = initial;
                    field_found = 1;
                } else {
                    if (value < initial)
                        do {
                            error(0, 0, (gettext("invalid decreasing range")));
                            usage(1);
                        } while (0);
                    if (eol_range_start != 0) {
                        if (initial < eol_range_start) {
                            if (eol_range_start <= value) {
                                eol_range_start = initial;
                            } else {
                                do {
                                    if (initial == 0 || value == 0)
                                        do {
                                            error(0, 0, (gettext("fields and positions are numbered from 1")));
                                            usage(1);
                                        } while (0);
                                    if (n_rp >= n_rp_allocated) {
                                        (rp) = x2nrealloc(rp, &n_rp_allocated, sizeof *(rp));
                                    }
                                    rp[n_rp].lo = (initial);
                                    rp[n_rp].hi = (value);
                                    ++n_rp;
                                } while (0);
                            }
                            field_found = 1;
                        }
                    } else {
                        do {
                            if (initial == 0 || value == 0)
                                do {
                                    error(0, 0, (gettext("fields and positions are numbered from 1")));
                                    usage(1);
                                } while (0);
                            if (n_rp >= n_rp_allocated) {
                                (rp) = x2nrealloc(rp, &n_rp_allocated, sizeof *(rp));
                            }
                            rp[n_rp].lo = (initial);
                            rp[n_rp].hi = (value);
                            ++n_rp;
                        } while (0);
                        field_found = 1;
                    }
                    value = 0;
                }
            } else {
                do {
                    if (value == 0 || value == 0)
                        do {
                            error(0, 0, (gettext("fields and positions are numbered from 1")));
                            usage(1);
                        } while (0);
                    if (n_rp >= n_rp_allocated) {
                        (rp) = x2nrealloc(rp, &n_rp_allocated, sizeof *(rp));
                    }
                    rp[n_rp].lo = (value);
                    rp[n_rp].hi = (value);
                    ++n_rp;
                } while (0);
                value = 0;
                field_found = 1;
            }
            if (*fieldstr == '\x00') {
                break;
            }
            fieldstr++;
            lhs_specified = 0;
            rhs_specified = 0;
        } else if (((unsigned int)(*fieldstr) - '0' <= 9)) {
            static const char *num_start;
            if (!in_digits || !num_start)
                num_start = fieldstr;
            in_digits = 1;
            if (dash_found)
                rhs_specified = 1;
            else
                lhs_specified = 1;
            if (!((void)(&(value) == (size_t *)((void *)0)) , (((size_t)-1 / 10 < (value) || (size_t)((value) * 10 + (*fieldstr - '0')) < (value)) ? 0 : (((value) = (value) * 10 + (*fieldstr - '0')) , 1)))) {
                size_t len = strspn(num_start, "0123456789");
                char *bad_num = xstrndup(num_start, len);
                if (operating_mode == byte_mode)
                    error(0, 0, gettext("byte offset %s is too large"), quote(bad_num));
                else
                    error(0, 0, gettext("field number %s is too large"), quote(bad_num));
                free(bad_num);
                exit(1);
            }
            fieldstr++;
        } else
            do {
                error(0, 0, (gettext("invalid byte or field list")));
                usage(1);
            } while (0);
    }


BasicTester, a patch instance with id 87:
Spawn 1 instances, now Total 128
Counter: 129
Batcher Size:48
Preprocess the following candidate with BasicTester:
Priority 7465
At location src/cut.c:363
--Src File: src/cut.c
Fragment 0:
output_delimiter_length = 1;
while (1)
    {
        if (*fieldstr == '-') {
            in_digits = 0;
            if (dash_found)
                do {
                    error(0, 0, (gettext("invalid byte or field list")));
                    usage(1);
                } while (0);
            dash_found = 1;
            fieldstr++;
            initial = (lhs_specified ? value : 1);
            value = 0;
        } else if (*fieldstr == ',' || ((*__ctype_b_loc())[(int)((to_uchar(*fieldstr)))] & (unsigned short)_ISblank) || *fieldstr == '\x00') {
            in_digits = 0;
            if (dash_found) {
                dash_found = 0;
                if (!lhs_specified && !rhs_specified)
                    do {
                        error(0, 0, (gettext("invalid range with no endpoint: -")));
                        usage(1);
                    } while (0);
                if (!rhs_specified) {
                    eol_range_start = initial;
                    field_found = 1;
                } else {
                    if (value < initial)
                        do {
                            error(0, 0, (gettext("invalid decreasing range")));
                            usage(1);
                        } while (0);
                    if (eol_range_start != 0) {
                        if (initial < eol_range_start) {
                            if (eol_range_start <= value) {
                                eol_range_start = initial;
                            } else {
                                do {
                                    if (initial == 0 || value == 0)
                                        do {
                                            error(0, 0, (gettext("fields and positions are numbered from 1")));
                                            usage(1);
                                        } while (0);
                                    if (n_rp >= n_rp_allocated) {
                                        (rp) = x2nrealloc(rp, &n_rp_allocated, sizeof *(rp));
                                    }
                                    rp[n_rp].lo = (initial);
                                    rp[n_rp].hi = (value);
                                    ++n_rp;
                                } while (0);
                            }
                            field_found = 1;
                        }
                    } else {
                        do {
                            if (initial == 0 || value == 0)
                                do {
                                    error(0, 0, (gettext("fields and positions are numbered from 1")));
                                    usage(1);
                                } while (0);
                            if (n_rp >= n_rp_allocated) {
                                (rp) = x2nrealloc(rp, &n_rp_allocated, sizeof *(rp));
                            }
                            rp[n_rp].lo = (initial);
                            rp[n_rp].hi = (value);
                            ++n_rp;
                        } while (0);
                        field_found = 1;
                    }
                    value = 0;
                }
            } else {
                do {
                    if (value == 0 || value == 0)
                        do {
                            error(0, 0, (gettext("fields and positions are numbered from 1")));
                            usage(1);
                        } while (0);
                    if (n_rp >= n_rp_allocated) {
                        (rp) = x2nrealloc(rp, &n_rp_allocated, sizeof *(rp));
                    }
                    rp[n_rp].lo = (value);
                    rp[n_rp].hi = (value);
                    ++n_rp;
                } while (0);
                value = 0;
                field_found = 1;
            }
            if (*fieldstr == '\x00') {
                break;
            }
            fieldstr++;
            lhs_specified = 0;
            rhs_specified = 0;
        } else if (((unsigned int)(*fieldstr) - '0' <= 9)) {
            static const char *num_start;
            if (!in_digits || !num_start)
                num_start = fieldstr;
            in_digits = 1;
            if (dash_found)
                rhs_specified = 1;
            else
                lhs_specified = 1;
            if (!((void)(&(value) == (size_t *)((void *)0)) , (((size_t)-1 / 10 < (value) || (size_t)((value) * 10 + (*fieldstr - '0')) < (value)) ? 0 : (((value) = (value) * 10 + (*fieldstr - '0')) , 1)))) {
                size_t len = strspn(num_start, "0123456789");
                char *bad_num = xstrndup(num_start, len);
                if (operating_mode == byte_mode)
                    error(0, 0, gettext("byte offset %s is too large"), quote(bad_num));
                else
                    error(0, 0, gettext("field number %s is too large"), quote(bad_num));
                free(bad_num);
                exit(1);
            }
            fieldstr++;
        } else
            do {
                error(0, 0, (gettext("invalid byte or field list")));
                usage(1);
            } while (0);
    }


BasicTester, a patch instance with id 88:
Spawn 1 instances, now Total 129
Counter: 130
Batcher Size:49
Preprocess the following candidate with BasicTester:
Priority 7465
At location src/cut.c:363
--Src File: src/cut.c
Fragment 0:
output_delimiter_length = (optarg[0] == '\x00' ? 1 : strlen(optarg));
while (1)
    {
        if (*fieldstr == '-') {
            in_digits = 0;
            if (dash_found)
                do {
                    error(0, 0, (gettext("invalid byte or field list")));
                    usage(1);
                } while (0);
            dash_found = 1;
            fieldstr++;
            initial = (lhs_specified ? value : 1);
            value = 0;
        } else if (*fieldstr == ',' || ((*__ctype_b_loc())[(int)((to_uchar(*fieldstr)))] & (unsigned short)_ISblank) || *fieldstr == '\x00') {
            in_digits = 0;
            if (dash_found) {
                dash_found = 0;
                if (!lhs_specified && !rhs_specified)
                    do {
                        error(0, 0, (gettext("invalid range with no endpoint: -")));
                        usage(1);
                    } while (0);
                if (!rhs_specified) {
                    eol_range_start = initial;
                    field_found = 1;
                } else {
                    if (value < initial)
                        do {
                            error(0, 0, (gettext("invalid decreasing range")));
                            usage(1);
                        } while (0);
                    if (eol_range_start != 0) {
                        if (initial < eol_range_start) {
                            if (eol_range_start <= value) {
                                eol_range_start = initial;
                            } else {
                                do {
                                    if (initial == 0 || value == 0)
                                        do {
                                            error(0, 0, (gettext("fields and positions are numbered from 1")));
                                            usage(1);
                                        } while (0);
                                    if (n_rp >= n_rp_allocated) {
                                        (rp) = x2nrealloc(rp, &n_rp_allocated, sizeof *(rp));
                                    }
                                    rp[n_rp].lo = (initial);
                                    rp[n_rp].hi = (value);
                                    ++n_rp;
                                } while (0);
                            }
                            field_found = 1;
                        }
                    } else {
                        do {
                            if (initial == 0 || value == 0)
                                do {
                                    error(0, 0, (gettext("fields and positions are numbered from 1")));
                                    usage(1);
                                } while (0);
                            if (n_rp >= n_rp_allocated) {
                                (rp) = x2nrealloc(rp, &n_rp_allocated, sizeof *(rp));
                            }
                            rp[n_rp].lo = (initial);
                            rp[n_rp].hi = (value);
                            ++n_rp;
                        } while (0);
                        field_found = 1;
                    }
                    value = 0;
                }
            } else {
                do {
                    if (value == 0 || value == 0)
                        do {
                            error(0, 0, (gettext("fields and positions are numbered from 1")));
                            usage(1);
                        } while (0);
                    if (n_rp >= n_rp_allocated) {
                        (rp) = x2nrealloc(rp, &n_rp_allocated, sizeof *(rp));
                    }
                    rp[n_rp].lo = (value);
                    rp[n_rp].hi = (value);
                    ++n_rp;
                } while (0);
                value = 0;
                field_found = 1;
            }
            if (*fieldstr == '\x00') {
                break;
            }
            fieldstr++;
            lhs_specified = 0;
            rhs_specified = 0;
        } else if (((unsigned int)(*fieldstr) - '0' <= 9)) {
            static const char *num_start;
            if (!in_digits || !num_start)
                num_start = fieldstr;
            in_digits = 1;
            if (dash_found)
                rhs_specified = 1;
            else
                lhs_specified = 1;
            if (!((void)(&(value) == (size_t *)((void *)0)) , (((size_t)-1 / 10 < (value) || (size_t)((value) * 10 + (*fieldstr - '0')) < (value)) ? 0 : (((value) = (value) * 10 + (*fieldstr - '0')) , 1)))) {
                size_t len = strspn(num_start, "0123456789");
                char *bad_num = xstrndup(num_start, len);
                if (operating_mode == byte_mode)
                    error(0, 0, gettext("byte offset %s is too large"), quote(bad_num));
                else
                    error(0, 0, gettext("field number %s is too large"), quote(bad_num));
                free(bad_num);
                exit(1);
            }
            fieldstr++;
        } else
            do {
                error(0, 0, (gettext("invalid byte or field list")));
                usage(1);
            } while (0);
    }


BasicTester, a patch instance with id 89:
Spawn 1 instances, now Total 130
Counter: 131
Batcher Size:50
Preprocess the following candidate with BasicTester:
Priority 7465
At location src/cut.c:363
--Src File: src/cut.c
Fragment 0:
output_delimiter_length = (i);
while (1)
    {
        if (*fieldstr == '-') {
            in_digits = 0;
            if (dash_found)
                do {
                    error(0, 0, (gettext("invalid byte or field list")));
                    usage(1);
                } while (0);
            dash_found = 1;
            fieldstr++;
            initial = (lhs_specified ? value : 1);
            value = 0;
        } else if (*fieldstr == ',' || ((*__ctype_b_loc())[(int)((to_uchar(*fieldstr)))] & (unsigned short)_ISblank) || *fieldstr == '\x00') {
            in_digits = 0;
            if (dash_found) {
                dash_found = 0;
                if (!lhs_specified && !rhs_specified)
                    do {
                        error(0, 0, (gettext("invalid range with no endpoint: -")));
                        usage(1);
                    } while (0);
                if (!rhs_specified) {
                    eol_range_start = initial;
                    field_found = 1;
                } else {
                    if (value < initial)
                        do {
                            error(0, 0, (gettext("invalid decreasing range")));
                            usage(1);
                        } while (0);
                    if (eol_range_start != 0) {
                        if (initial < eol_range_start) {
                            if (eol_range_start <= value) {
                                eol_range_start = initial;
                            } else {
                                do {
                                    if (initial == 0 || value == 0)
                                        do {
                                            error(0, 0, (gettext("fields and positions are numbered from 1")));
                                            usage(1);
                                        } while (0);
                                    if (n_rp >= n_rp_allocated) {
                                        (rp) = x2nrealloc(rp, &n_rp_allocated, sizeof *(rp));
                                    }
                                    rp[n_rp].lo = (initial);
                                    rp[n_rp].hi = (value);
                                    ++n_rp;
                                } while (0);
                            }
                            field_found = 1;
                        }
                    } else {
                        do {
                            if (initial == 0 || value == 0)
                                do {
                                    error(0, 0, (gettext("fields and positions are numbered from 1")));
                                    usage(1);
                                } while (0);
                            if (n_rp >= n_rp_allocated) {
                                (rp) = x2nrealloc(rp, &n_rp_allocated, sizeof *(rp));
                            }
                            rp[n_rp].lo = (initial);
                            rp[n_rp].hi = (value);
                            ++n_rp;
                        } while (0);
                        field_found = 1;
                    }
                    value = 0;
                }
            } else {
                do {
                    if (value == 0 || value == 0)
                        do {
                            error(0, 0, (gettext("fields and positions are numbered from 1")));
                            usage(1);
                        } while (0);
                    if (n_rp >= n_rp_allocated) {
                        (rp) = x2nrealloc(rp, &n_rp_allocated, sizeof *(rp));
                    }
                    rp[n_rp].lo = (value);
                    rp[n_rp].hi = (value);
                    ++n_rp;
                } while (0);
                value = 0;
                field_found = 1;
            }
            if (*fieldstr == '\x00') {
                break;
            }
            fieldstr++;
            lhs_specified = 0;
            rhs_specified = 0;
        } else if (((unsigned int)(*fieldstr) - '0' <= 9)) {
            static const char *num_start;
            if (!in_digits || !num_start)
                num_start = fieldstr;
            in_digits = 1;
            if (dash_found)
                rhs_specified = 1;
            else
                lhs_specified = 1;
            if (!((void)(&(value) == (size_t *)((void *)0)) , (((size_t)-1 / 10 < (value) || (size_t)((value) * 10 + (*fieldstr - '0')) < (value)) ? 0 : (((value) = (value) * 10 + (*fieldstr - '0')) , 1)))) {
                size_t len = strspn(num_start, "0123456789");
                char *bad_num = xstrndup(num_start, len);
                if (operating_mode == byte_mode)
                    error(0, 0, gettext("byte offset %s is too large"), quote(bad_num));
                else
                    error(0, 0, gettext("field number %s is too large"), quote(bad_num));
                free(bad_num);
                exit(1);
            }
            fieldstr++;
        } else
            do {
                error(0, 0, (gettext("invalid byte or field list")));
                usage(1);
            } while (0);
    }


BasicTester, a patch instance with id 90:
Spawn 1 instances, now Total 131
Counter: 132
Batcher Size:51
Preprocess the following candidate with BasicTester:
Priority 7465
At location src/cut.c:363
--Src File: src/cut.c
Fragment 0:
output_delimiter_length = (initial);
while (1)
    {
        if (*fieldstr == '-') {
            in_digits = 0;
            if (dash_found)
                do {
                    error(0, 0, (gettext("invalid byte or field list")));
                    usage(1);
                } while (0);
            dash_found = 1;
            fieldstr++;
            initial = (lhs_specified ? value : 1);
            value = 0;
        } else if (*fieldstr == ',' || ((*__ctype_b_loc())[(int)((to_uchar(*fieldstr)))] & (unsigned short)_ISblank) || *fieldstr == '\x00') {
            in_digits = 0;
            if (dash_found) {
                dash_found = 0;
                if (!lhs_specified && !rhs_specified)
                    do {
                        error(0, 0, (gettext("invalid range with no endpoint: -")));
                        usage(1);
                    } while (0);
                if (!rhs_specified) {
                    eol_range_start = initial;
                    field_found = 1;
                } else {
                    if (value < initial)
                        do {
                            error(0, 0, (gettext("invalid decreasing range")));
                            usage(1);
                        } while (0);
                    if (eol_range_start != 0) {
                        if (initial < eol_range_start) {
                            if (eol_range_start <= value) {
                                eol_range_start = initial;
                            } else {
                                do {
                                    if (initial == 0 || value == 0)
                                        do {
                                            error(0, 0, (gettext("fields and positions are numbered from 1")));
                                            usage(1);
                                        } while (0);
                                    if (n_rp >= n_rp_allocated) {
                                        (rp) = x2nrealloc(rp, &n_rp_allocated, sizeof *(rp));
                                    }
                                    rp[n_rp].lo = (initial);
                                    rp[n_rp].hi = (value);
                                    ++n_rp;
                                } while (0);
                            }
                            field_found = 1;
                        }
                    } else {
                        do {
                            if (initial == 0 || value == 0)
                                do {
                                    error(0, 0, (gettext("fields and positions are numbered from 1")));
                                    usage(1);
                                } while (0);
                            if (n_rp >= n_rp_allocated) {
                                (rp) = x2nrealloc(rp, &n_rp_allocated, sizeof *(rp));
                            }
                            rp[n_rp].lo = (initial);
                            rp[n_rp].hi = (value);
                            ++n_rp;
                        } while (0);
                        field_found = 1;
                    }
                    value = 0;
                }
            } else {
                do {
                    if (value == 0 || value == 0)
                        do {
                            error(0, 0, (gettext("fields and positions are numbered from 1")));
                            usage(1);
                        } while (0);
                    if (n_rp >= n_rp_allocated) {
                        (rp) = x2nrealloc(rp, &n_rp_allocated, sizeof *(rp));
                    }
                    rp[n_rp].lo = (value);
                    rp[n_rp].hi = (value);
                    ++n_rp;
                } while (0);
                value = 0;
                field_found = 1;
            }
            if (*fieldstr == '\x00') {
                break;
            }
            fieldstr++;
            lhs_specified = 0;
            rhs_specified = 0;
        } else if (((unsigned int)(*fieldstr) - '0' <= 9)) {
            static const char *num_start;
            if (!in_digits || !num_start)
                num_start = fieldstr;
            in_digits = 1;
            if (dash_found)
                rhs_specified = 1;
            else
                lhs_specified = 1;
            if (!((void)(&(value) == (size_t *)((void *)0)) , (((size_t)-1 / 10 < (value) || (size_t)((value) * 10 + (*fieldstr - '0')) < (value)) ? 0 : (((value) = (value) * 10 + (*fieldstr - '0')) , 1)))) {
                size_t len = strspn(num_start, "0123456789");
                char *bad_num = xstrndup(num_start, len);
                if (operating_mode == byte_mode)
                    error(0, 0, gettext("byte offset %s is too large"), quote(bad_num));
                else
                    error(0, 0, gettext("field number %s is too large"), quote(bad_num));
                free(bad_num);
                exit(1);
            }
            fieldstr++;
        } else
            do {
                error(0, 0, (gettext("invalid byte or field list")));
                usage(1);
            } while (0);
    }


BasicTester, a patch instance with id 91:
Spawn 1 instances, now Total 132
Counter: 133
Batcher Size:52
Preprocess the following candidate with BasicTester:
Priority 7465
At location src/cut.c:363
--Src File: src/cut.c
Fragment 0:
output_delimiter_length = (n_rp);
while (1)
    {
        if (*fieldstr == '-') {
            in_digits = 0;
            if (dash_found)
                do {
                    error(0, 0, (gettext("invalid byte or field list")));
                    usage(1);
                } while (0);
            dash_found = 1;
            fieldstr++;
            initial = (lhs_specified ? value : 1);
            value = 0;
        } else if (*fieldstr == ',' || ((*__ctype_b_loc())[(int)((to_uchar(*fieldstr)))] & (unsigned short)_ISblank) || *fieldstr == '\x00') {
            in_digits = 0;
            if (dash_found) {
                dash_found = 0;
                if (!lhs_specified && !rhs_specified)
                    do {
                        error(0, 0, (gettext("invalid range with no endpoint: -")));
                        usage(1);
                    } while (0);
                if (!rhs_specified) {
                    eol_range_start = initial;
                    field_found = 1;
                } else {
                    if (value < initial)
                        do {
                            error(0, 0, (gettext("invalid decreasing range")));
                            usage(1);
                        } while (0);
                    if (eol_range_start != 0) {
                        if (initial < eol_range_start) {
                            if (eol_range_start <= value) {
                                eol_range_start = initial;
                            } else {
                                do {
                                    if (initial == 0 || value == 0)
                                        do {
                                            error(0, 0, (gettext("fields and positions are numbered from 1")));
                                            usage(1);
                                        } while (0);
                                    if (n_rp >= n_rp_allocated) {
                                        (rp) = x2nrealloc(rp, &n_rp_allocated, sizeof *(rp));
                                    }
                                    rp[n_rp].lo = (initial);
                                    rp[n_rp].hi = (value);
                                    ++n_rp;
                                } while (0);
                            }
                            field_found = 1;
                        }
                    } else {
                        do {
                            if (initial == 0 || value == 0)
                                do {
                                    error(0, 0, (gettext("fields and positions are numbered from 1")));
                                    usage(1);
                                } while (0);
                            if (n_rp >= n_rp_allocated) {
                                (rp) = x2nrealloc(rp, &n_rp_allocated, sizeof *(rp));
                            }
                            rp[n_rp].lo = (initial);
                            rp[n_rp].hi = (value);
                            ++n_rp;
                        } while (0);
                        field_found = 1;
                    }
                    value = 0;
                }
            } else {
                do {
                    if (value == 0 || value == 0)
                        do {
                            error(0, 0, (gettext("fields and positions are numbered from 1")));
                            usage(1);
                        } while (0);
                    if (n_rp >= n_rp_allocated) {
                        (rp) = x2nrealloc(rp, &n_rp_allocated, sizeof *(rp));
                    }
                    rp[n_rp].lo = (value);
                    rp[n_rp].hi = (value);
                    ++n_rp;
                } while (0);
                value = 0;
                field_found = 1;
            }
            if (*fieldstr == '\x00') {
                break;
            }
            fieldstr++;
            lhs_specified = 0;
            rhs_specified = 0;
        } else if (((unsigned int)(*fieldstr) - '0' <= 9)) {
            static const char *num_start;
            if (!in_digits || !num_start)
                num_start = fieldstr;
            in_digits = 1;
            if (dash_found)
                rhs_specified = 1;
            else
                lhs_specified = 1;
            if (!((void)(&(value) == (size_t *)((void *)0)) , (((size_t)-1 / 10 < (value) || (size_t)((value) * 10 + (*fieldstr - '0')) < (value)) ? 0 : (((value) = (value) * 10 + (*fieldstr - '0')) , 1)))) {
                size_t len = strspn(num_start, "0123456789");
                char *bad_num = xstrndup(num_start, len);
                if (operating_mode == byte_mode)
                    error(0, 0, gettext("byte offset %s is too large"), quote(bad_num));
                else
                    error(0, 0, gettext("field number %s is too large"), quote(bad_num));
                free(bad_num);
                exit(1);
            }
            fieldstr++;
        } else
            do {
                error(0, 0, (gettext("invalid byte or field list")));
                usage(1);
            } while (0);
    }


BasicTester, a patch instance with id 92:
Spawn 1 instances, now Total 133
a batched test job starts!
Building:src at:
/home/ubuntu/spr-fast/tests/corebench/coreutils/coreutils-case-7380cf79-2e636af1/tempworkdir/srcMerged code building succ, going to invoke tester!
BasicTester, Testing instance id 83:
Running test command:
/home/ubuntu/spr-fast/tools/coreutils-test.py /home/ubuntu/spr-fast/tests/corebench/coreutils/coreutils-case-7380cf79-2e636af1/tempworkdir/src /home/ubuntu/spr-fast/tests/corebench/coreutils/coreutils-case-7380cf79-2e636af1/tempworkdir/tests /home/ubuntu/spr-fast/tests/corebench/coreutils/coreutils-case-7380cf79-2e636af1/tempworkdir 0  > __res
BasicTester, Testing instance id 84:
Running test command:
/home/ubuntu/spr-fast/tools/coreutils-test.py /home/ubuntu/spr-fast/tests/corebench/coreutils/coreutils-case-7380cf79-2e636af1/tempworkdir/src /home/ubuntu/spr-fast/tests/corebench/coreutils/coreutils-case-7380cf79-2e636af1/tempworkdir/tests /home/ubuntu/spr-fast/tests/corebench/coreutils/coreutils-case-7380cf79-2e636af1/tempworkdir 0  > __res
BasicTester, Testing instance id 85:
Running test command:
/home/ubuntu/spr-fast/tools/coreutils-test.py /home/ubuntu/spr-fast/tests/corebench/coreutils/coreutils-case-7380cf79-2e636af1/tempworkdir/src /home/ubuntu/spr-fast/tests/corebench/coreutils/coreutils-case-7380cf79-2e636af1/tempworkdir/tests /home/ubuntu/spr-fast/tests/corebench/coreutils/coreutils-case-7380cf79-2e636af1/tempworkdir 0  > __res
BasicTester, Testing instance id 86:
Running test command:
/home/ubuntu/spr-fast/tools/coreutils-test.py /home/ubuntu/spr-fast/tests/corebench/coreutils/coreutils-case-7380cf79-2e636af1/tempworkdir/src /home/ubuntu/spr-fast/tests/corebench/coreutils/coreutils-case-7380cf79-2e636af1/tempworkdir/tests /home/ubuntu/spr-fast/tests/corebench/coreutils/coreutils-case-7380cf79-2e636af1/tempworkdir 0  > __res
BasicTester, Testing instance id 87:
Running test command:
/home/ubuntu/spr-fast/tools/coreutils-test.py /home/ubuntu/spr-fast/tests/corebench/coreutils/coreutils-case-7380cf79-2e636af1/tempworkdir/src /home/ubuntu/spr-fast/tests/corebench/coreutils/coreutils-case-7380cf79-2e636af1/tempworkdir/tests /home/ubuntu/spr-fast/tests/corebench/coreutils/coreutils-case-7380cf79-2e636af1/tempworkdir 0  > __res
BasicTester, Testing instance id 88:
Running test command:
/home/ubuntu/spr-fast/tools/coreutils-test.py /home/ubuntu/spr-fast/tests/corebench/coreutils/coreutils-case-7380cf79-2e636af1/tempworkdir/src /home/ubuntu/spr-fast/tests/corebench/coreutils/coreutils-case-7380cf79-2e636af1/tempworkdir/tests /home/ubuntu/spr-fast/tests/corebench/coreutils/coreutils-case-7380cf79-2e636af1/tempworkdir 0  > __res
BasicTester, Testing instance id 89:
Running test command:
/home/ubuntu/spr-fast/tools/coreutils-test.py /home/ubuntu/spr-fast/tests/corebench/coreutils/coreutils-case-7380cf79-2e636af1/tempworkdir/src /home/ubuntu/spr-fast/tests/corebench/coreutils/coreutils-case-7380cf79-2e636af1/tempworkdir/tests /home/ubuntu/spr-fast/tests/corebench/coreutils/coreutils-case-7380cf79-2e636af1/tempworkdir 0  > __res
BasicTester, Testing instance id 90:
Running test command:
/home/ubuntu/spr-fast/tools/coreutils-test.py /home/ubuntu/spr-fast/tests/corebench/coreutils/coreutils-case-7380cf79-2e636af1/tempworkdir/src /home/ubuntu/spr-fast/tests/corebench/coreutils/coreutils-case-7380cf79-2e636af1/tempworkdir/tests /home/ubuntu/spr-fast/tests/corebench/coreutils/coreutils-case-7380cf79-2e636af1/tempworkdir 0  > __res
BasicTester, Testing instance id 91:
Running test command:
/home/ubuntu/spr-fast/tools/coreutils-test.py /home/ubuntu/spr-fast/tests/corebench/coreutils/coreutils-case-7380cf79-2e636af1/tempworkdir/src /home/ubuntu/spr-fast/tests/corebench/coreutils/coreutils-case-7380cf79-2e636af1/tempworkdir/tests /home/ubuntu/spr-fast/tests/corebench/coreutils/coreutils-case-7380cf79-2e636af1/tempworkdir 0  > __res
BasicTester, Testing instance id 92:
Running test command:
/home/ubuntu/spr-fast/tools/coreutils-test.py /home/ubuntu/spr-fast/tests/corebench/coreutils/coreutils-case-7380cf79-2e636af1/tempworkdir/src /home/ubuntu/spr-fast/tests/corebench/coreutils/coreutils-case-7380cf79-2e636af1/tempworkdir/tests /home/ubuntu/spr-fast/tests/corebench/coreutils/coreutils-case-7380cf79-2e636af1/tempworkdir 0  > __res
Counter: 134
Batcher Size:43
Preprocess the following candidate with BasicTester:
Priority 7465
At location src/cut.c:363
--Src File: src/cut.c
Fragment 0:
output_delimiter_length = (10);
while (1)
    {
        if (*fieldstr == '-') {
            in_digits = 0;
            if (dash_found)
                do {
                    error(0, 0, (gettext("invalid byte or field list")));
                    usage(1);
                } while (0);
            dash_found = 1;
            fieldstr++;
            initial = (lhs_specified ? value : 1);
            value = 0;
        } else if (*fieldstr == ',' || ((*__ctype_b_loc())[(int)((to_uchar(*fieldstr)))] & (unsigned short)_ISblank) || *fieldstr == '\x00') {
            in_digits = 0;
            if (dash_found) {
                dash_found = 0;
                if (!lhs_specified && !rhs_specified)
                    do {
                        error(0, 0, (gettext("invalid range with no endpoint: -")));
                        usage(1);
                    } while (0);
                if (!rhs_specified) {
                    eol_range_start = initial;
                    field_found = 1;
                } else {
                    if (value < initial)
                        do {
                            error(0, 0, (gettext("invalid decreasing range")));
                            usage(1);
                        } while (0);
                    if (eol_range_start != 0) {
                        if (initial < eol_range_start) {
                            if (eol_range_start <= value) {
                                eol_range_start = initial;
                            } else {
                                do {
                                    if (initial == 0 || value == 0)
                                        do {
                                            error(0, 0, (gettext("fields and positions are numbered from 1")));
                                            usage(1);
                                        } while (0);
                                    if (n_rp >= n_rp_allocated) {
                                        (rp) = x2nrealloc(rp, &n_rp_allocated, sizeof *(rp));
                                    }
                                    rp[n_rp].lo = (initial);
                                    rp[n_rp].hi = (value);
                                    ++n_rp;
                                } while (0);
                            }
                            field_found = 1;
                        }
                    } else {
                        do {
                            if (initial == 0 || value == 0)
                                do {
                                    error(0, 0, (gettext("fields and positions are numbered from 1")));
                                    usage(1);
                                } while (0);
                            if (n_rp >= n_rp_allocated) {
                                (rp) = x2nrealloc(rp, &n_rp_allocated, sizeof *(rp));
                            }
                            rp[n_rp].lo = (initial);
                            rp[n_rp].hi = (value);
                            ++n_rp;
                        } while (0);
                        field_found = 1;
                    }
                    value = 0;
                }
            } else {
                do {
                    if (value == 0 || value == 0)
                        do {
                            error(0, 0, (gettext("fields and positions are numbered from 1")));
                            usage(1);
                        } while (0);
                    if (n_rp >= n_rp_allocated) {
                        (rp) = x2nrealloc(rp, &n_rp_allocated, sizeof *(rp));
                    }
                    rp[n_rp].lo = (value);
                    rp[n_rp].hi = (value);
                    ++n_rp;
                } while (0);
                value = 0;
                field_found = 1;
            }
            if (*fieldstr == '\x00') {
                break;
            }
            fieldstr++;
            lhs_specified = 0;
            rhs_specified = 0;
        } else if (((unsigned int)(*fieldstr) - '0' <= 9)) {
            static const char *num_start;
            if (!in_digits || !num_start)
                num_start = fieldstr;
            in_digits = 1;
            if (dash_found)
                rhs_specified = 1;
            else
                lhs_specified = 1;
            if (!((void)(&(value) == (size_t *)((void *)0)) , (((size_t)-1 / 10 < (value) || (size_t)((value) * 10 + (*fieldstr - '0')) < (value)) ? 0 : (((value) = (value) * 10 + (*fieldstr - '0')) , 1)))) {
                size_t len = strspn(num_start, "0123456789");
                char *bad_num = xstrndup(num_start, len);
                if (operating_mode == byte_mode)
                    error(0, 0, gettext("byte offset %s is too large"), quote(bad_num));
                else
                    error(0, 0, gettext("field number %s is too large"), quote(bad_num));
                free(bad_num);
                exit(1);
            }
            fieldstr++;
        } else
            do {
                error(0, 0, (gettext("invalid byte or field list")));
                usage(1);
            } while (0);
    }


BasicTester, a patch instance with id 93:
Spawn 1 instances, now Total 134
Counter: 135
Batcher Size:44
Preprocess the following candidate with BasicTester:
Priority 7465
At location src/cut.c:363
--Src File: src/cut.c
Fragment 0:
output_delimiter_length = (8);
while (1)
    {
        if (*fieldstr == '-') {
            in_digits = 0;
            if (dash_found)
                do {
                    error(0, 0, (gettext("invalid byte or field list")));
                    usage(1);
                } while (0);
            dash_found = 1;
            fieldstr++;
            initial = (lhs_specified ? value : 1);
            value = 0;
        } else if (*fieldstr == ',' || ((*__ctype_b_loc())[(int)((to_uchar(*fieldstr)))] & (unsigned short)_ISblank) || *fieldstr == '\x00') {
            in_digits = 0;
            if (dash_found) {
                dash_found = 0;
                if (!lhs_specified && !rhs_specified)
                    do {
                        error(0, 0, (gettext("invalid range with no endpoint: -")));
                        usage(1);
                    } while (0);
                if (!rhs_specified) {
                    eol_range_start = initial;
                    field_found = 1;
                } else {
                    if (value < initial)
                        do {
                            error(0, 0, (gettext("invalid decreasing range")));
                            usage(1);
                        } while (0);
                    if (eol_range_start != 0) {
                        if (initial < eol_range_start) {
                            if (eol_range_start <= value) {
                                eol_range_start = initial;
                            } else {
                                do {
                                    if (initial == 0 || value == 0)
                                        do {
                                            error(0, 0, (gettext("fields and positions are numbered from 1")));
                                            usage(1);
                                        } while (0);
                                    if (n_rp >= n_rp_allocated) {
                                        (rp) = x2nrealloc(rp, &n_rp_allocated, sizeof *(rp));
                                    }
                                    rp[n_rp].lo = (initial);
                                    rp[n_rp].hi = (value);
                                    ++n_rp;
                                } while (0);
                            }
                            field_found = 1;
                        }
                    } else {
                        do {
                            if (initial == 0 || value == 0)
                                do {
                                    error(0, 0, (gettext("fields and positions are numbered from 1")));
                                    usage(1);
                                } while (0);
                            if (n_rp >= n_rp_allocated) {
                                (rp) = x2nrealloc(rp, &n_rp_allocated, sizeof *(rp));
                            }
                            rp[n_rp].lo = (initial);
                            rp[n_rp].hi = (value);
                            ++n_rp;
                        } while (0);
                        field_found = 1;
                    }
                    value = 0;
                }
            } else {
                do {
                    if (value == 0 || value == 0)
                        do {
                            error(0, 0, (gettext("fields and positions are numbered from 1")));
                            usage(1);
                        } while (0);
                    if (n_rp >= n_rp_allocated) {
                        (rp) = x2nrealloc(rp, &n_rp_allocated, sizeof *(rp));
                    }
                    rp[n_rp].lo = (value);
                    rp[n_rp].hi = (value);
                    ++n_rp;
                } while (0);
                value = 0;
                field_found = 1;
            }
            if (*fieldstr == '\x00') {
                break;
            }
            fieldstr++;
            lhs_specified = 0;
            rhs_specified = 0;
        } else if (((unsigned int)(*fieldstr) - '0' <= 9)) {
            static const char *num_start;
            if (!in_digits || !num_start)
                num_start = fieldstr;
            in_digits = 1;
            if (dash_found)
                rhs_specified = 1;
            else
                lhs_specified = 1;
            if (!((void)(&(value) == (size_t *)((void *)0)) , (((size_t)-1 / 10 < (value) || (size_t)((value) * 10 + (*fieldstr - '0')) < (value)) ? 0 : (((value) = (value) * 10 + (*fieldstr - '0')) , 1)))) {
                size_t len = strspn(num_start, "0123456789");
                char *bad_num = xstrndup(num_start, len);
                if (operating_mode == byte_mode)
                    error(0, 0, gettext("byte offset %s is too large"), quote(bad_num));
                else
                    error(0, 0, gettext("field number %s is too large"), quote(bad_num));
                free(bad_num);
                exit(1);
            }
            fieldstr++;
        } else
            do {
                error(0, 0, (gettext("invalid byte or field list")));
                usage(1);
            } while (0);
    }


BasicTester, a patch instance with id 94:
Spawn 1 instances, now Total 135
Counter: 136
Batcher Size:45
Preprocess the following candidate with BasicTester:
Priority 7465
At location src/cut.c:363
--Src File: src/cut.c
Fragment 0:
output_delimiter_length = (0);
while (1)
    {
        if (*fieldstr == '-') {
            in_digits = 0;
            if (dash_found)
                do {
                    error(0, 0, (gettext("invalid byte or field list")));
                    usage(1);
                } while (0);
            dash_found = 1;
            fieldstr++;
            initial = (lhs_specified ? value : 1);
            value = 0;
        } else if (*fieldstr == ',' || ((*__ctype_b_loc())[(int)((to_uchar(*fieldstr)))] & (unsigned short)_ISblank) || *fieldstr == '\x00') {
            in_digits = 0;
            if (dash_found) {
                dash_found = 0;
                if (!lhs_specified && !rhs_specified)
                    do {
                        error(0, 0, (gettext("invalid range with no endpoint: -")));
                        usage(1);
                    } while (0);
                if (!rhs_specified) {
                    eol_range_start = initial;
                    field_found = 1;
                } else {
                    if (value < initial)
                        do {
                            error(0, 0, (gettext("invalid decreasing range")));
                            usage(1);
                        } while (0);
                    if (eol_range_start != 0) {
                        if (initial < eol_range_start) {
                            if (eol_range_start <= value) {
                                eol_range_start = initial;
                            } else {
                                do {
                                    if (initial == 0 || value == 0)
                                        do {
                                            error(0, 0, (gettext("fields and positions are numbered from 1")));
                                            usage(1);
                                        } while (0);
                                    if (n_rp >= n_rp_allocated) {
                                        (rp) = x2nrealloc(rp, &n_rp_allocated, sizeof *(rp));
                                    }
                                    rp[n_rp].lo = (initial);
                                    rp[n_rp].hi = (value);
                                    ++n_rp;
                                } while (0);
                            }
                            field_found = 1;
                        }
                    } else {
                        do {
                            if (initial == 0 || value == 0)
                                do {
                                    error(0, 0, (gettext("fields and positions are numbered from 1")));
                                    usage(1);
                                } while (0);
                            if (n_rp >= n_rp_allocated) {
                                (rp) = x2nrealloc(rp, &n_rp_allocated, sizeof *(rp));
                            }
                            rp[n_rp].lo = (initial);
                            rp[n_rp].hi = (value);
                            ++n_rp;
                        } while (0);
                        field_found = 1;
                    }
                    value = 0;
                }
            } else {
                do {
                    if (value == 0 || value == 0)
                        do {
                            error(0, 0, (gettext("fields and positions are numbered from 1")));
                            usage(1);
                        } while (0);
                    if (n_rp >= n_rp_allocated) {
                        (rp) = x2nrealloc(rp, &n_rp_allocated, sizeof *(rp));
                    }
                    rp[n_rp].lo = (value);
                    rp[n_rp].hi = (value);
                    ++n_rp;
                } while (0);
                value = 0;
                field_found = 1;
            }
            if (*fieldstr == '\x00') {
                break;
            }
            fieldstr++;
            lhs_specified = 0;
            rhs_specified = 0;
        } else if (((unsigned int)(*fieldstr) - '0' <= 9)) {
            static const char *num_start;
            if (!in_digits || !num_start)
                num_start = fieldstr;
            in_digits = 1;
            if (dash_found)
                rhs_specified = 1;
            else
                lhs_specified = 1;
            if (!((void)(&(value) == (size_t *)((void *)0)) , (((size_t)-1 / 10 < (value) || (size_t)((value) * 10 + (*fieldstr - '0')) < (value)) ? 0 : (((value) = (value) * 10 + (*fieldstr - '0')) , 1)))) {
                size_t len = strspn(num_start, "0123456789");
                char *bad_num = xstrndup(num_start, len);
                if (operating_mode == byte_mode)
                    error(0, 0, gettext("byte offset %s is too large"), quote(bad_num));
                else
                    error(0, 0, gettext("field number %s is too large"), quote(bad_num));
                free(bad_num);
                exit(1);
            }
            fieldstr++;
        } else
            do {
                error(0, 0, (gettext("invalid byte or field list")));
                usage(1);
            } while (0);
    }


BasicTester, a patch instance with id 95:
Spawn 1 instances, now Total 136
Counter: 137
Batcher Size:46
Preprocess the following candidate with BasicTester:
Priority 7465
At location src/cut.c:363
--Src File: src/cut.c
Fragment 0:
output_delimiter_length = (1);
while (1)
    {
        if (*fieldstr == '-') {
            in_digits = 0;
            if (dash_found)
                do {
                    error(0, 0, (gettext("invalid byte or field list")));
                    usage(1);
                } while (0);
            dash_found = 1;
            fieldstr++;
            initial = (lhs_specified ? value : 1);
            value = 0;
        } else if (*fieldstr == ',' || ((*__ctype_b_loc())[(int)((to_uchar(*fieldstr)))] & (unsigned short)_ISblank) || *fieldstr == '\x00') {
            in_digits = 0;
            if (dash_found) {
                dash_found = 0;
                if (!lhs_specified && !rhs_specified)
                    do {
                        error(0, 0, (gettext("invalid range with no endpoint: -")));
                        usage(1);
                    } while (0);
                if (!rhs_specified) {
                    eol_range_start = initial;
                    field_found = 1;
                } else {
                    if (value < initial)
                        do {
                            error(0, 0, (gettext("invalid decreasing range")));
                            usage(1);
                        } while (0);
                    if (eol_range_start != 0) {
                        if (initial < eol_range_start) {
                            if (eol_range_start <= value) {
                                eol_range_start = initial;
                            } else {
                                do {
                                    if (initial == 0 || value == 0)
                                        do {
                                            error(0, 0, (gettext("fields and positions are numbered from 1")));
                                            usage(1);
                                        } while (0);
                                    if (n_rp >= n_rp_allocated) {
                                        (rp) = x2nrealloc(rp, &n_rp_allocated, sizeof *(rp));
                                    }
                                    rp[n_rp].lo = (initial);
                                    rp[n_rp].hi = (value);
                                    ++n_rp;
                                } while (0);
                            }
                            field_found = 1;
                        }
                    } else {
                        do {
                            if (initial == 0 || value == 0)
                                do {
                                    error(0, 0, (gettext("fields and positions are numbered from 1")));
                                    usage(1);
                                } while (0);
                            if (n_rp >= n_rp_allocated) {
                                (rp) = x2nrealloc(rp, &n_rp_allocated, sizeof *(rp));
                            }
                            rp[n_rp].lo = (initial);
                            rp[n_rp].hi = (value);
                            ++n_rp;
                        } while (0);
                        field_found = 1;
                    }
                    value = 0;
                }
            } else {
                do {
                    if (value == 0 || value == 0)
                        do {
                            error(0, 0, (gettext("fields and positions are numbered from 1")));
                            usage(1);
                        } while (0);
                    if (n_rp >= n_rp_allocated) {
                        (rp) = x2nrealloc(rp, &n_rp_allocated, sizeof *(rp));
                    }
                    rp[n_rp].lo = (value);
                    rp[n_rp].hi = (value);
                    ++n_rp;
                } while (0);
                value = 0;
                field_found = 1;
            }
            if (*fieldstr == '\x00') {
                break;
            }
            fieldstr++;
            lhs_specified = 0;
            rhs_specified = 0;
        } else if (((unsigned int)(*fieldstr) - '0' <= 9)) {
            static const char *num_start;
            if (!in_digits || !num_start)
                num_start = fieldstr;
            in_digits = 1;
            if (dash_found)
                rhs_specified = 1;
            else
                lhs_specified = 1;
            if (!((void)(&(value) == (size_t *)((void *)0)) , (((size_t)-1 / 10 < (value) || (size_t)((value) * 10 + (*fieldstr - '0')) < (value)) ? 0 : (((value) = (value) * 10 + (*fieldstr - '0')) , 1)))) {
                size_t len = strspn(num_start, "0123456789");
                char *bad_num = xstrndup(num_start, len);
                if (operating_mode == byte_mode)
                    error(0, 0, gettext("byte offset %s is too large"), quote(bad_num));
                else
                    error(0, 0, gettext("field number %s is too large"), quote(bad_num));
                free(bad_num);
                exit(1);
            }
            fieldstr++;
        } else
            do {
                error(0, 0, (gettext("invalid byte or field list")));
                usage(1);
            } while (0);
    }


BasicTester, a patch instance with id 96:
Spawn 1 instances, now Total 137
Counter: 138
Batcher Size:47
Preprocess the following candidate with BasicTester:
Priority 7465
At location src/cut.c:363
--Src File: src/cut.c
Fragment 0:
operating_mode = byte_mode;
while (1)
    {
        if (*fieldstr == '-') {
            in_digits = 0;
            if (dash_found)
                do {
                    error(0, 0, (gettext("invalid byte or field list")));
                    usage(1);
                } while (0);
            dash_found = 1;
            fieldstr++;
            initial = (lhs_specified ? value : 1);
            value = 0;
        } else if (*fieldstr == ',' || ((*__ctype_b_loc())[(int)((to_uchar(*fieldstr)))] & (unsigned short)_ISblank) || *fieldstr == '\x00') {
            in_digits = 0;
            if (dash_found) {
                dash_found = 0;
                if (!lhs_specified && !rhs_specified)
                    do {
                        error(0, 0, (gettext("invalid range with no endpoint: -")));
                        usage(1);
                    } while (0);
                if (!rhs_specified) {
                    eol_range_start = initial;
                    field_found = 1;
                } else {
                    if (value < initial)
                        do {
                            error(0, 0, (gettext("invalid decreasing range")));
                            usage(1);
                        } while (0);
                    if (eol_range_start != 0) {
                        if (initial < eol_range_start) {
                            if (eol_range_start <= value) {
                                eol_range_start = initial;
                            } else {
                                do {
                                    if (initial == 0 || value == 0)
                                        do {
                                            error(0, 0, (gettext("fields and positions are numbered from 1")));
                                            usage(1);
                                        } while (0);
                                    if (n_rp >= n_rp_allocated) {
                                        (rp) = x2nrealloc(rp, &n_rp_allocated, sizeof *(rp));
                                    }
                                    rp[n_rp].lo = (initial);
                                    rp[n_rp].hi = (value);
                                    ++n_rp;
                                } while (0);
                            }
                            field_found = 1;
                        }
                    } else {
                        do {
                            if (initial == 0 || value == 0)
                                do {
                                    error(0, 0, (gettext("fields and positions are numbered from 1")));
                                    usage(1);
                                } while (0);
                            if (n_rp >= n_rp_allocated) {
                                (rp) = x2nrealloc(rp, &n_rp_allocated, sizeof *(rp));
                            }
                            rp[n_rp].lo = (initial);
                            rp[n_rp].hi = (value);
                            ++n_rp;
                        } while (0);
                        field_found = 1;
                    }
                    value = 0;
                }
            } else {
                do {
                    if (value == 0 || value == 0)
                        do {
                            error(0, 0, (gettext("fields and positions are numbered from 1")));
                            usage(1);
                        } while (0);
                    if (n_rp >= n_rp_allocated) {
                        (rp) = x2nrealloc(rp, &n_rp_allocated, sizeof *(rp));
                    }
                    rp[n_rp].lo = (value);
                    rp[n_rp].hi = (value);
                    ++n_rp;
                } while (0);
                value = 0;
                field_found = 1;
            }
            if (*fieldstr == '\x00') {
                break;
            }
            fieldstr++;
            lhs_specified = 0;
            rhs_specified = 0;
        } else if (((unsigned int)(*fieldstr) - '0' <= 9)) {
            static const char *num_start;
            if (!in_digits || !num_start)
                num_start = fieldstr;
            in_digits = 1;
            if (dash_found)
                rhs_specified = 1;
            else
                lhs_specified = 1;
            if (!((void)(&(value) == (size_t *)((void *)0)) , (((size_t)-1 / 10 < (value) || (size_t)((value) * 10 + (*fieldstr - '0')) < (value)) ? 0 : (((value) = (value) * 10 + (*fieldstr - '0')) , 1)))) {
                size_t len = strspn(num_start, "0123456789");
                char *bad_num = xstrndup(num_start, len);
                if (operating_mode == byte_mode)
                    error(0, 0, gettext("byte offset %s is too large"), quote(bad_num));
                else
                    error(0, 0, gettext("field number %s is too large"), quote(bad_num));
                free(bad_num);
                exit(1);
            }
            fieldstr++;
        } else
            do {
                error(0, 0, (gettext("invalid byte or field list")));
                usage(1);
            } while (0);
    }


BasicTester, a patch instance with id 97:
Spawn 1 instances, now Total 138
Counter: 139
Batcher Size:48
Preprocess the following candidate with BasicTester:
Priority 7465
At location src/cut.c:363
--Src File: src/cut.c
Fragment 0:
operating_mode = field_mode;
while (1)
    {
        if (*fieldstr == '-') {
            in_digits = 0;
            if (dash_found)
                do {
                    error(0, 0, (gettext("invalid byte or field list")));
                    usage(1);
                } while (0);
            dash_found = 1;
            fieldstr++;
            initial = (lhs_specified ? value : 1);
            value = 0;
        } else if (*fieldstr == ',' || ((*__ctype_b_loc())[(int)((to_uchar(*fieldstr)))] & (unsigned short)_ISblank) || *fieldstr == '\x00') {
            in_digits = 0;
            if (dash_found) {
                dash_found = 0;
                if (!lhs_specified && !rhs_specified)
                    do {
                        error(0, 0, (gettext("invalid range with no endpoint: -")));
                        usage(1);
                    } while (0);
                if (!rhs_specified) {
                    eol_range_start = initial;
                    field_found = 1;
                } else {
                    if (value < initial)
                        do {
                            error(0, 0, (gettext("invalid decreasing range")));
                            usage(1);
                        } while (0);
                    if (eol_range_start != 0) {
                        if (initial < eol_range_start) {
                            if (eol_range_start <= value) {
                                eol_range_start = initial;
                            } else {
                                do {
                                    if (initial == 0 || value == 0)
                                        do {
                                            error(0, 0, (gettext("fields and positions are numbered from 1")));
                                            usage(1);
                                        } while (0);
                                    if (n_rp >= n_rp_allocated) {
                                        (rp) = x2nrealloc(rp, &n_rp_allocated, sizeof *(rp));
                                    }
                                    rp[n_rp].lo = (initial);
                                    rp[n_rp].hi = (value);
                                    ++n_rp;
                                } while (0);
                            }
                            field_found = 1;
                        }
                    } else {
                        do {
                            if (initial == 0 || value == 0)
                                do {
                                    error(0, 0, (gettext("fields and positions are numbered from 1")));
                                    usage(1);
                                } while (0);
                            if (n_rp >= n_rp_allocated) {
                                (rp) = x2nrealloc(rp, &n_rp_allocated, sizeof *(rp));
                            }
                            rp[n_rp].lo = (initial);
                            rp[n_rp].hi = (value);
                            ++n_rp;
                        } while (0);
                        field_found = 1;
                    }
                    value = 0;
                }
            } else {
                do {
                    if (value == 0 || value == 0)
                        do {
                            error(0, 0, (gettext("fields and positions are numbered from 1")));
                            usage(1);
                        } while (0);
                    if (n_rp >= n_rp_allocated) {
                        (rp) = x2nrealloc(rp, &n_rp_allocated, sizeof *(rp));
                    }
                    rp[n_rp].lo = (value);
                    rp[n_rp].hi = (value);
                    ++n_rp;
                } while (0);
                value = 0;
                field_found = 1;
            }
            if (*fieldstr == '\x00') {
                break;
            }
            fieldstr++;
            lhs_specified = 0;
            rhs_specified = 0;
        } else if (((unsigned int)(*fieldstr) - '0' <= 9)) {
            static const char *num_start;
            if (!in_digits || !num_start)
                num_start = fieldstr;
            in_digits = 1;
            if (dash_found)
                rhs_specified = 1;
            else
                lhs_specified = 1;
            if (!((void)(&(value) == (size_t *)((void *)0)) , (((size_t)-1 / 10 < (value) || (size_t)((value) * 10 + (*fieldstr - '0')) < (value)) ? 0 : (((value) = (value) * 10 + (*fieldstr - '0')) , 1)))) {
                size_t len = strspn(num_start, "0123456789");
                char *bad_num = xstrndup(num_start, len);
                if (operating_mode == byte_mode)
                    error(0, 0, gettext("byte offset %s is too large"), quote(bad_num));
                else
                    error(0, 0, gettext("field number %s is too large"), quote(bad_num));
                free(bad_num);
                exit(1);
            }
            fieldstr++;
        } else
            do {
                error(0, 0, (gettext("invalid byte or field list")));
                usage(1);
            } while (0);
    }


BasicTester, a patch instance with id 98:
Spawn 1 instances, now Total 139
Counter: 140
Batcher Size:49
Preprocess the following candidate with BasicTester:
Priority 7465
At location src/cut.c:363
--Src File: src/cut.c
Fragment 0:
operating_mode = undefined_mode;
while (1)
    {
        if (*fieldstr == '-') {
            in_digits = 0;
            if (dash_found)
                do {
                    error(0, 0, (gettext("invalid byte or field list")));
                    usage(1);
                } while (0);
            dash_found = 1;
            fieldstr++;
            initial = (lhs_specified ? value : 1);
            value = 0;
        } else if (*fieldstr == ',' || ((*__ctype_b_loc())[(int)((to_uchar(*fieldstr)))] & (unsigned short)_ISblank) || *fieldstr == '\x00') {
            in_digits = 0;
            if (dash_found) {
                dash_found = 0;
                if (!lhs_specified && !rhs_specified)
                    do {
                        error(0, 0, (gettext("invalid range with no endpoint: -")));
                        usage(1);
                    } while (0);
                if (!rhs_specified) {
                    eol_range_start = initial;
                    field_found = 1;
                } else {
                    if (value < initial)
                        do {
                            error(0, 0, (gettext("invalid decreasing range")));
                            usage(1);
                        } while (0);
                    if (eol_range_start != 0) {
                        if (initial < eol_range_start) {
                            if (eol_range_start <= value) {
                                eol_range_start = initial;
                            } else {
                                do {
                                    if (initial == 0 || value == 0)
                                        do {
                                            error(0, 0, (gettext("fields and positions are numbered from 1")));
                                            usage(1);
                                        } while (0);
                                    if (n_rp >= n_rp_allocated) {
                                        (rp) = x2nrealloc(rp, &n_rp_allocated, sizeof *(rp));
                                    }
                                    rp[n_rp].lo = (initial);
                                    rp[n_rp].hi = (value);
                                    ++n_rp;
                                } while (0);
                            }
                            field_found = 1;
                        }
                    } else {
                        do {
                            if (initial == 0 || value == 0)
                                do {
                                    error(0, 0, (gettext("fields and positions are numbered from 1")));
                                    usage(1);
                                } while (0);
                            if (n_rp >= n_rp_allocated) {
                                (rp) = x2nrealloc(rp, &n_rp_allocated, sizeof *(rp));
                            }
                            rp[n_rp].lo = (initial);
                            rp[n_rp].hi = (value);
                            ++n_rp;
                        } while (0);
                        field_found = 1;
                    }
                    value = 0;
                }
            } else {
                do {
                    if (value == 0 || value == 0)
                        do {
                            error(0, 0, (gettext("fields and positions are numbered from 1")));
                            usage(1);
                        } while (0);
                    if (n_rp >= n_rp_allocated) {
                        (rp) = x2nrealloc(rp, &n_rp_allocated, sizeof *(rp));
                    }
                    rp[n_rp].lo = (value);
                    rp[n_rp].hi = (value);
                    ++n_rp;
                } while (0);
                value = 0;
                field_found = 1;
            }
            if (*fieldstr == '\x00') {
                break;
            }
            fieldstr++;
            lhs_specified = 0;
            rhs_specified = 0;
        } else if (((unsigned int)(*fieldstr) - '0' <= 9)) {
            static const char *num_start;
            if (!in_digits || !num_start)
                num_start = fieldstr;
            in_digits = 1;
            if (dash_found)
                rhs_specified = 1;
            else
                lhs_specified = 1;
            if (!((void)(&(value) == (size_t *)((void *)0)) , (((size_t)-1 / 10 < (value) || (size_t)((value) * 10 + (*fieldstr - '0')) < (value)) ? 0 : (((value) = (value) * 10 + (*fieldstr - '0')) , 1)))) {
                size_t len = strspn(num_start, "0123456789");
                char *bad_num = xstrndup(num_start, len);
                if (operating_mode == byte_mode)
                    error(0, 0, gettext("byte offset %s is too large"), quote(bad_num));
                else
                    error(0, 0, gettext("field number %s is too large"), quote(bad_num));
                free(bad_num);
                exit(1);
            }
            fieldstr++;
        } else
            do {
                error(0, 0, (gettext("invalid byte or field list")));
                usage(1);
            } while (0);
    }


BasicTester, a patch instance with id 99:
Spawn 1 instances, now Total 140
Counter: 141
Batcher Size:50
Preprocess the following candidate with BasicTester:
Priority 7465
At location src/cut.c:363
--Src File: src/cut.c
Fragment 0:
output_delimiter_length = (-1);
while (1)
    {
        if (*fieldstr == '-') {
            in_digits = 0;
            if (dash_found)
                do {
                    error(0, 0, (gettext("invalid byte or field list")));
                    usage(1);
                } while (0);
            dash_found = 1;
            fieldstr++;
            initial = (lhs_specified ? value : 1);
            value = 0;
        } else if (*fieldstr == ',' || ((*__ctype_b_loc())[(int)((to_uchar(*fieldstr)))] & (unsigned short)_ISblank) || *fieldstr == '\x00') {
            in_digits = 0;
            if (dash_found) {
                dash_found = 0;
                if (!lhs_specified && !rhs_specified)
                    do {
                        error(0, 0, (gettext("invalid range with no endpoint: -")));
                        usage(1);
                    } while (0);
                if (!rhs_specified) {
                    eol_range_start = initial;
                    field_found = 1;
                } else {
                    if (value < initial)
                        do {
                            error(0, 0, (gettext("invalid decreasing range")));
                            usage(1);
                        } while (0);
                    if (eol_range_start != 0) {
                        if (initial < eol_range_start) {
                            if (eol_range_start <= value) {
                                eol_range_start = initial;
                            } else {
                                do {
                                    if (initial == 0 || value == 0)
                                        do {
                                            error(0, 0, (gettext("fields and positions are numbered from 1")));
                                            usage(1);
                                        } while (0);
                                    if (n_rp >= n_rp_allocated) {
                                        (rp) = x2nrealloc(rp, &n_rp_allocated, sizeof *(rp));
                                    }
                                    rp[n_rp].lo = (initial);
                                    rp[n_rp].hi = (value);
                                    ++n_rp;
                                } while (0);
                            }
                            field_found = 1;
                        }
                    } else {
                        do {
                            if (initial == 0 || value == 0)
                                do {
                                    error(0, 0, (gettext("fields and positions are numbered from 1")));
                                    usage(1);
                                } while (0);
                            if (n_rp >= n_rp_allocated) {
                                (rp) = x2nrealloc(rp, &n_rp_allocated, sizeof *(rp));
                            }
                            rp[n_rp].lo = (initial);
                            rp[n_rp].hi = (value);
                            ++n_rp;
                        } while (0);
                        field_found = 1;
                    }
                    value = 0;
                }
            } else {
                do {
                    if (value == 0 || value == 0)
                        do {
                            error(0, 0, (gettext("fields and positions are numbered from 1")));
                            usage(1);
                        } while (0);
                    if (n_rp >= n_rp_allocated) {
                        (rp) = x2nrealloc(rp, &n_rp_allocated, sizeof *(rp));
                    }
                    rp[n_rp].lo = (value);
                    rp[n_rp].hi = (value);
                    ++n_rp;
                } while (0);
                value = 0;
                field_found = 1;
            }
            if (*fieldstr == '\x00') {
                break;
            }
            fieldstr++;
            lhs_specified = 0;
            rhs_specified = 0;
        } else if (((unsigned int)(*fieldstr) - '0' <= 9)) {
            static const char *num_start;
            if (!in_digits || !num_start)
                num_start = fieldstr;
            in_digits = 1;
            if (dash_found)
                rhs_specified = 1;
            else
                lhs_specified = 1;
            if (!((void)(&(value) == (size_t *)((void *)0)) , (((size_t)-1 / 10 < (value) || (size_t)((value) * 10 + (*fieldstr - '0')) < (value)) ? 0 : (((value) = (value) * 10 + (*fieldstr - '0')) , 1)))) {
                size_t len = strspn(num_start, "0123456789");
                char *bad_num = xstrndup(num_start, len);
                if (operating_mode == byte_mode)
                    error(0, 0, gettext("byte offset %s is too large"), quote(bad_num));
                else
                    error(0, 0, gettext("field number %s is too large"), quote(bad_num));
                free(bad_num);
                exit(1);
            }
            fieldstr++;
        } else
            do {
                error(0, 0, (gettext("invalid byte or field list")));
                usage(1);
            } while (0);
    }


BasicTester, a patch instance with id 100:
Spawn 1 instances, now Total 141
Counter: 142
Batcher Size:51
Preprocess the following candidate with BasicTester:
Priority 7465
At location src/cut.c:363
--Src File: src/cut.c
Fragment 0:
max_range_endpoint = (initial);
while (1)
    {
        if (*fieldstr == '-') {
            in_digits = 0;
            if (dash_found)
                do {
                    error(0, 0, (gettext("invalid byte or field list")));
                    usage(1);
                } while (0);
            dash_found = 1;
            fieldstr++;
            initial = (lhs_specified ? value : 1);
            value = 0;
        } else if (*fieldstr == ',' || ((*__ctype_b_loc())[(int)((to_uchar(*fieldstr)))] & (unsigned short)_ISblank) || *fieldstr == '\x00') {
            in_digits = 0;
            if (dash_found) {
                dash_found = 0;
                if (!lhs_specified && !rhs_specified)
                    do {
                        error(0, 0, (gettext("invalid range with no endpoint: -")));
                        usage(1);
                    } while (0);
                if (!rhs_specified) {
                    eol_range_start = initial;
                    field_found = 1;
                } else {
                    if (value < initial)
                        do {
                            error(0, 0, (gettext("invalid decreasing range")));
                            usage(1);
                        } while (0);
                    if (eol_range_start != 0) {
                        if (initial < eol_range_start) {
                            if (eol_range_start <= value) {
                                eol_range_start = initial;
                            } else {
                                do {
                                    if (initial == 0 || value == 0)
                                        do {
                                            error(0, 0, (gettext("fields and positions are numbered from 1")));
                                            usage(1);
                                        } while (0);
                                    if (n_rp >= n_rp_allocated) {
                                        (rp) = x2nrealloc(rp, &n_rp_allocated, sizeof *(rp));
                                    }
                                    rp[n_rp].lo = (initial);
                                    rp[n_rp].hi = (value);
                                    ++n_rp;
                                } while (0);
                            }
                            field_found = 1;
                        }
                    } else {
                        do {
                            if (initial == 0 || value == 0)
                                do {
                                    error(0, 0, (gettext("fields and positions are numbered from 1")));
                                    usage(1);
                                } while (0);
                            if (n_rp >= n_rp_allocated) {
                                (rp) = x2nrealloc(rp, &n_rp_allocated, sizeof *(rp));
                            }
                            rp[n_rp].lo = (initial);
                            rp[n_rp].hi = (value);
                            ++n_rp;
                        } while (0);
                        field_found = 1;
                    }
                    value = 0;
                }
            } else {
                do {
                    if (value == 0 || value == 0)
                        do {
                            error(0, 0, (gettext("fields and positions are numbered from 1")));
                            usage(1);
                        } while (0);
                    if (n_rp >= n_rp_allocated) {
                        (rp) = x2nrealloc(rp, &n_rp_allocated, sizeof *(rp));
                    }
                    rp[n_rp].lo = (value);
                    rp[n_rp].hi = (value);
                    ++n_rp;
                } while (0);
                value = 0;
                field_found = 1;
            }
            if (*fieldstr == '\x00') {
                break;
            }
            fieldstr++;
            lhs_specified = 0;
            rhs_specified = 0;
        } else if (((unsigned int)(*fieldstr) - '0' <= 9)) {
            static const char *num_start;
            if (!in_digits || !num_start)
                num_start = fieldstr;
            in_digits = 1;
            if (dash_found)
                rhs_specified = 1;
            else
                lhs_specified = 1;
            if (!((void)(&(value) == (size_t *)((void *)0)) , (((size_t)-1 / 10 < (value) || (size_t)((value) * 10 + (*fieldstr - '0')) < (value)) ? 0 : (((value) = (value) * 10 + (*fieldstr - '0')) , 1)))) {
                size_t len = strspn(num_start, "0123456789");
                char *bad_num = xstrndup(num_start, len);
                if (operating_mode == byte_mode)
                    error(0, 0, gettext("byte offset %s is too large"), quote(bad_num));
                else
                    error(0, 0, gettext("field number %s is too large"), quote(bad_num));
                free(bad_num);
                exit(1);
            }
            fieldstr++;
        } else
            do {
                error(0, 0, (gettext("invalid byte or field list")));
                usage(1);
            } while (0);
    }


BasicTester, a patch instance with id 101:
Spawn 1 instances, now Total 142
Counter: 143
Batcher Size:52
Preprocess the following candidate with BasicTester:
Priority 7465
At location src/cut.c:363
--Src File: src/cut.c
Fragment 0:
operating_mode = (0);
while (1)
    {
        if (*fieldstr == '-') {
            in_digits = 0;
            if (dash_found)
                do {
                    error(0, 0, (gettext("invalid byte or field list")));
                    usage(1);
                } while (0);
            dash_found = 1;
            fieldstr++;
            initial = (lhs_specified ? value : 1);
            value = 0;
        } else if (*fieldstr == ',' || ((*__ctype_b_loc())[(int)((to_uchar(*fieldstr)))] & (unsigned short)_ISblank) || *fieldstr == '\x00') {
            in_digits = 0;
            if (dash_found) {
                dash_found = 0;
                if (!lhs_specified && !rhs_specified)
                    do {
                        error(0, 0, (gettext("invalid range with no endpoint: -")));
                        usage(1);
                    } while (0);
                if (!rhs_specified) {
                    eol_range_start = initial;
                    field_found = 1;
                } else {
                    if (value < initial)
                        do {
                            error(0, 0, (gettext("invalid decreasing range")));
                            usage(1);
                        } while (0);
                    if (eol_range_start != 0) {
                        if (initial < eol_range_start) {
                            if (eol_range_start <= value) {
                                eol_range_start = initial;
                            } else {
                                do {
                                    if (initial == 0 || value == 0)
                                        do {
                                            error(0, 0, (gettext("fields and positions are numbered from 1")));
                                            usage(1);
                                        } while (0);
                                    if (n_rp >= n_rp_allocated) {
                                        (rp) = x2nrealloc(rp, &n_rp_allocated, sizeof *(rp));
                                    }
                                    rp[n_rp].lo = (initial);
                                    rp[n_rp].hi = (value);
                                    ++n_rp;
                                } while (0);
                            }
                            field_found = 1;
                        }
                    } else {
                        do {
                            if (initial == 0 || value == 0)
                                do {
                                    error(0, 0, (gettext("fields and positions are numbered from 1")));
                                    usage(1);
                                } while (0);
                            if (n_rp >= n_rp_allocated) {
                                (rp) = x2nrealloc(rp, &n_rp_allocated, sizeof *(rp));
                            }
                            rp[n_rp].lo = (initial);
                            rp[n_rp].hi = (value);
                            ++n_rp;
                        } while (0);
                        field_found = 1;
                    }
                    value = 0;
                }
            } else {
                do {
                    if (value == 0 || value == 0)
                        do {
                            error(0, 0, (gettext("fields and positions are numbered from 1")));
                            usage(1);
                        } while (0);
                    if (n_rp >= n_rp_allocated) {
                        (rp) = x2nrealloc(rp, &n_rp_allocated, sizeof *(rp));
                    }
                    rp[n_rp].lo = (value);
                    rp[n_rp].hi = (value);
                    ++n_rp;
                } while (0);
                value = 0;
                field_found = 1;
            }
            if (*fieldstr == '\x00') {
                break;
            }
            fieldstr++;
            lhs_specified = 0;
            rhs_specified = 0;
        } else if (((unsigned int)(*fieldstr) - '0' <= 9)) {
            static const char *num_start;
            if (!in_digits || !num_start)
                num_start = fieldstr;
            in_digits = 1;
            if (dash_found)
                rhs_specified = 1;
            else
                lhs_specified = 1;
            if (!((void)(&(value) == (size_t *)((void *)0)) , (((size_t)-1 / 10 < (value) || (size_t)((value) * 10 + (*fieldstr - '0')) < (value)) ? 0 : (((value) = (value) * 10 + (*fieldstr - '0')) , 1)))) {
                size_t len = strspn(num_start, "0123456789");
                char *bad_num = xstrndup(num_start, len);
                if (operating_mode == byte_mode)
                    error(0, 0, gettext("byte offset %s is too large"), quote(bad_num));
                else
                    error(0, 0, gettext("field number %s is too large"), quote(bad_num));
                free(bad_num);
                exit(1);
            }
            fieldstr++;
        } else
            do {
                error(0, 0, (gettext("invalid byte or field list")));
                usage(1);
            } while (0);
    }


BasicTester, a patch instance with id 102:
Spawn 1 instances, now Total 143
a batched test job starts!
Building:src at:
/home/ubuntu/spr-fast/tests/corebench/coreutils/coreutils-case-7380cf79-2e636af1/tempworkdir/srcMerged code building succ, going to invoke tester!
BasicTester, Testing instance id 93:
Running test command:
/home/ubuntu/spr-fast/tools/coreutils-test.py /home/ubuntu/spr-fast/tests/corebench/coreutils/coreutils-case-7380cf79-2e636af1/tempworkdir/src /home/ubuntu/spr-fast/tests/corebench/coreutils/coreutils-case-7380cf79-2e636af1/tempworkdir/tests /home/ubuntu/spr-fast/tests/corebench/coreutils/coreutils-case-7380cf79-2e636af1/tempworkdir 0  > __res
BasicTester, Testing instance id 94:
Running test command:
/home/ubuntu/spr-fast/tools/coreutils-test.py /home/ubuntu/spr-fast/tests/corebench/coreutils/coreutils-case-7380cf79-2e636af1/tempworkdir/src /home/ubuntu/spr-fast/tests/corebench/coreutils/coreutils-case-7380cf79-2e636af1/tempworkdir/tests /home/ubuntu/spr-fast/tests/corebench/coreutils/coreutils-case-7380cf79-2e636af1/tempworkdir 0  > __res
BasicTester, Testing instance id 95:
Running test command:
/home/ubuntu/spr-fast/tools/coreutils-test.py /home/ubuntu/spr-fast/tests/corebench/coreutils/coreutils-case-7380cf79-2e636af1/tempworkdir/src /home/ubuntu/spr-fast/tests/corebench/coreutils/coreutils-case-7380cf79-2e636af1/tempworkdir/tests /home/ubuntu/spr-fast/tests/corebench/coreutils/coreutils-case-7380cf79-2e636af1/tempworkdir 0  > __res
BasicTester, Testing instance id 96:
Running test command:
/home/ubuntu/spr-fast/tools/coreutils-test.py /home/ubuntu/spr-fast/tests/corebench/coreutils/coreutils-case-7380cf79-2e636af1/tempworkdir/src /home/ubuntu/spr-fast/tests/corebench/coreutils/coreutils-case-7380cf79-2e636af1/tempworkdir/tests /home/ubuntu/spr-fast/tests/corebench/coreutils/coreutils-case-7380cf79-2e636af1/tempworkdir 0  > __res
BasicTester, Testing instance id 97:
Running test command:
/home/ubuntu/spr-fast/tools/coreutils-test.py /home/ubuntu/spr-fast/tests/corebench/coreutils/coreutils-case-7380cf79-2e636af1/tempworkdir/src /home/ubuntu/spr-fast/tests/corebench/coreutils/coreutils-case-7380cf79-2e636af1/tempworkdir/tests /home/ubuntu/spr-fast/tests/corebench/coreutils/coreutils-case-7380cf79-2e636af1/tempworkdir 0  > __res
BasicTester, Testing instance id 98:
Running test command:
/home/ubuntu/spr-fast/tools/coreutils-test.py /home/ubuntu/spr-fast/tests/corebench/coreutils/coreutils-case-7380cf79-2e636af1/tempworkdir/src /home/ubuntu/spr-fast/tests/corebench/coreutils/coreutils-case-7380cf79-2e636af1/tempworkdir/tests /home/ubuntu/spr-fast/tests/corebench/coreutils/coreutils-case-7380cf79-2e636af1/tempworkdir 0  > __res
BasicTester, Testing instance id 99:
Running test command:
/home/ubuntu/spr-fast/tools/coreutils-test.py /home/ubuntu/spr-fast/tests/corebench/coreutils/coreutils-case-7380cf79-2e636af1/tempworkdir/src /home/ubuntu/spr-fast/tests/corebench/coreutils/coreutils-case-7380cf79-2e636af1/tempworkdir/tests /home/ubuntu/spr-fast/tests/corebench/coreutils/coreutils-case-7380cf79-2e636af1/tempworkdir 0  > __res
BasicTester, Testing instance id 100:
Running test command:
/home/ubuntu/spr-fast/tools/coreutils-test.py /home/ubuntu/spr-fast/tests/corebench/coreutils/coreutils-case-7380cf79-2e636af1/tempworkdir/src /home/ubuntu/spr-fast/tests/corebench/coreutils/coreutils-case-7380cf79-2e636af1/tempworkdir/tests /home/ubuntu/spr-fast/tests/corebench/coreutils/coreutils-case-7380cf79-2e636af1/tempworkdir 0  > __res
BasicTester, Testing instance id 101:
Running test command:
/home/ubuntu/spr-fast/tools/coreutils-test.py /home/ubuntu/spr-fast/tests/corebench/coreutils/coreutils-case-7380cf79-2e636af1/tempworkdir/src /home/ubuntu/spr-fast/tests/corebench/coreutils/coreutils-case-7380cf79-2e636af1/tempworkdir/tests /home/ubuntu/spr-fast/tests/corebench/coreutils/coreutils-case-7380cf79-2e636af1/tempworkdir 0  > __res
BasicTester, Testing instance id 102:
Running test command:
/home/ubuntu/spr-fast/tools/coreutils-test.py /home/ubuntu/spr-fast/tests/corebench/coreutils/coreutils-case-7380cf79-2e636af1/tempworkdir/src /home/ubuntu/spr-fast/tests/corebench/coreutils/coreutils-case-7380cf79-2e636af1/tempworkdir/tests /home/ubuntu/spr-fast/tests/corebench/coreutils/coreutils-case-7380cf79-2e636af1/tempworkdir 0  > __res
Counter: 144
Batcher Size:43
Preprocess the following candidate with BasicTester:
Priority 7465
At location src/cut.c:363
--Src File: src/cut.c
Fragment 0:
operating_mode = (9);
while (1)
    {
        if (*fieldstr == '-') {
            in_digits = 0;
            if (dash_found)
                do {
                    error(0, 0, (gettext("invalid byte or field list")));
                    usage(1);
                } while (0);
            dash_found = 1;
            fieldstr++;
            initial = (lhs_specified ? value : 1);
            value = 0;
        } else if (*fieldstr == ',' || ((*__ctype_b_loc())[(int)((to_uchar(*fieldstr)))] & (unsigned short)_ISblank) || *fieldstr == '\x00') {
            in_digits = 0;
            if (dash_found) {
                dash_found = 0;
                if (!lhs_specified && !rhs_specified)
                    do {
                        error(0, 0, (gettext("invalid range with no endpoint: -")));
                        usage(1);
                    } while (0);
                if (!rhs_specified) {
                    eol_range_start = initial;
                    field_found = 1;
                } else {
                    if (value < initial)
                        do {
                            error(0, 0, (gettext("invalid decreasing range")));
                            usage(1);
                        } while (0);
                    if (eol_range_start != 0) {
                        if (initial < eol_range_start) {
                            if (eol_range_start <= value) {
                                eol_range_start = initial;
                            } else {
                                do {
                                    if (initial == 0 || value == 0)
                                        do {
                                            error(0, 0, (gettext("fields and positions are numbered from 1")));
                                            usage(1);
                                        } while (0);
                                    if (n_rp >= n_rp_allocated) {
                                        (rp) = x2nrealloc(rp, &n_rp_allocated, sizeof *(rp));
                                    }
                                    rp[n_rp].lo = (initial);
                                    rp[n_rp].hi = (value);
                                    ++n_rp;
                                } while (0);
                            }
                            field_found = 1;
                        }
                    } else {
                        do {
                            if (initial == 0 || value == 0)
                                do {
                                    error(0, 0, (gettext("fields and positions are numbered from 1")));
                                    usage(1);
                                } while (0);
                            if (n_rp >= n_rp_allocated) {
                                (rp) = x2nrealloc(rp, &n_rp_allocated, sizeof *(rp));
                            }
                            rp[n_rp].lo = (initial);
                            rp[n_rp].hi = (value);
                            ++n_rp;
                        } while (0);
                        field_found = 1;
                    }
                    value = 0;
                }
            } else {
                do {
                    if (value == 0 || value == 0)
                        do {
                            error(0, 0, (gettext("fields and positions are numbered from 1")));
                            usage(1);
                        } while (0);
                    if (n_rp >= n_rp_allocated) {
                        (rp) = x2nrealloc(rp, &n_rp_allocated, sizeof *(rp));
                    }
                    rp[n_rp].lo = (value);
                    rp[n_rp].hi = (value);
                    ++n_rp;
                } while (0);
                value = 0;
                field_found = 1;
            }
            if (*fieldstr == '\x00') {
                break;
            }
            fieldstr++;
            lhs_specified = 0;
            rhs_specified = 0;
        } else if (((unsigned int)(*fieldstr) - '0' <= 9)) {
            static const char *num_start;
            if (!in_digits || !num_start)
                num_start = fieldstr;
            in_digits = 1;
            if (dash_found)
                rhs_specified = 1;
            else
                lhs_specified = 1;
            if (!((void)(&(value) == (size_t *)((void *)0)) , (((size_t)-1 / 10 < (value) || (size_t)((value) * 10 + (*fieldstr - '0')) < (value)) ? 0 : (((value) = (value) * 10 + (*fieldstr - '0')) , 1)))) {
                size_t len = strspn(num_start, "0123456789");
                char *bad_num = xstrndup(num_start, len);
                if (operating_mode == byte_mode)
                    error(0, 0, gettext("byte offset %s is too large"), quote(bad_num));
                else
                    error(0, 0, gettext("field number %s is too large"), quote(bad_num));
                free(bad_num);
                exit(1);
            }
            fieldstr++;
        } else
            do {
                error(0, 0, (gettext("invalid byte or field list")));
                usage(1);
            } while (0);
    }


BasicTester, a patch instance with id 103:
Spawn 1 instances, now Total 144
Counter: 145
Batcher Size:44
Preprocess the following candidate with BasicTester:
Priority 7465
At location src/cut.c:363
--Src File: src/cut.c
Fragment 0:
operating_mode = (field_mode);
while (1)
    {
        if (*fieldstr == '-') {
            in_digits = 0;
            if (dash_found)
                do {
                    error(0, 0, (gettext("invalid byte or field list")));
                    usage(1);
                } while (0);
            dash_found = 1;
            fieldstr++;
            initial = (lhs_specified ? value : 1);
            value = 0;
        } else if (*fieldstr == ',' || ((*__ctype_b_loc())[(int)((to_uchar(*fieldstr)))] & (unsigned short)_ISblank) || *fieldstr == '\x00') {
            in_digits = 0;
            if (dash_found) {
                dash_found = 0;
                if (!lhs_specified && !rhs_specified)
                    do {
                        error(0, 0, (gettext("invalid range with no endpoint: -")));
                        usage(1);
                    } while (0);
                if (!rhs_specified) {
                    eol_range_start = initial;
                    field_found = 1;
                } else {
                    if (value < initial)
                        do {
                            error(0, 0, (gettext("invalid decreasing range")));
                            usage(1);
                        } while (0);
                    if (eol_range_start != 0) {
                        if (initial < eol_range_start) {
                            if (eol_range_start <= value) {
                                eol_range_start = initial;
                            } else {
                                do {
                                    if (initial == 0 || value == 0)
                                        do {
                                            error(0, 0, (gettext("fields and positions are numbered from 1")));
                                            usage(1);
                                        } while (0);
                                    if (n_rp >= n_rp_allocated) {
                                        (rp) = x2nrealloc(rp, &n_rp_allocated, sizeof *(rp));
                                    }
                                    rp[n_rp].lo = (initial);
                                    rp[n_rp].hi = (value);
                                    ++n_rp;
                                } while (0);
                            }
                            field_found = 1;
                        }
                    } else {
                        do {
                            if (initial == 0 || value == 0)
                                do {
                                    error(0, 0, (gettext("fields and positions are numbered from 1")));
                                    usage(1);
                                } while (0);
                            if (n_rp >= n_rp_allocated) {
                                (rp) = x2nrealloc(rp, &n_rp_allocated, sizeof *(rp));
                            }
                            rp[n_rp].lo = (initial);
                            rp[n_rp].hi = (value);
                            ++n_rp;
                        } while (0);
                        field_found = 1;
                    }
                    value = 0;
                }
            } else {
                do {
                    if (value == 0 || value == 0)
                        do {
                            error(0, 0, (gettext("fields and positions are numbered from 1")));
                            usage(1);
                        } while (0);
                    if (n_rp >= n_rp_allocated) {
                        (rp) = x2nrealloc(rp, &n_rp_allocated, sizeof *(rp));
                    }
                    rp[n_rp].lo = (value);
                    rp[n_rp].hi = (value);
                    ++n_rp;
                } while (0);
                value = 0;
                field_found = 1;
            }
            if (*fieldstr == '\x00') {
                break;
            }
            fieldstr++;
            lhs_specified = 0;
            rhs_specified = 0;
        } else if (((unsigned int)(*fieldstr) - '0' <= 9)) {
            static const char *num_start;
            if (!in_digits || !num_start)
                num_start = fieldstr;
            in_digits = 1;
            if (dash_found)
                rhs_specified = 1;
            else
                lhs_specified = 1;
            if (!((void)(&(value) == (size_t *)((void *)0)) , (((size_t)-1 / 10 < (value) || (size_t)((value) * 10 + (*fieldstr - '0')) < (value)) ? 0 : (((value) = (value) * 10 + (*fieldstr - '0')) , 1)))) {
                size_t len = strspn(num_start, "0123456789");
                char *bad_num = xstrndup(num_start, len);
                if (operating_mode == byte_mode)
                    error(0, 0, gettext("byte offset %s is too large"), quote(bad_num));
                else
                    error(0, 0, gettext("field number %s is too large"), quote(bad_num));
                free(bad_num);
                exit(1);
            }
            fieldstr++;
        } else
            do {
                error(0, 0, (gettext("invalid byte or field list")));
                usage(1);
            } while (0);
    }


BasicTester, a patch instance with id 104:
Spawn 1 instances, now Total 145
Counter: 146
Batcher Size:45
Preprocess the following candidate with BasicTester:
Priority 7465
At location src/cut.c:363
--Src File: src/cut.c
Fragment 0:
operating_mode = (undefined_mode);
while (1)
    {
        if (*fieldstr == '-') {
            in_digits = 0;
            if (dash_found)
                do {
                    error(0, 0, (gettext("invalid byte or field list")));
                    usage(1);
                } while (0);
            dash_found = 1;
            fieldstr++;
            initial = (lhs_specified ? value : 1);
            value = 0;
        } else if (*fieldstr == ',' || ((*__ctype_b_loc())[(int)((to_uchar(*fieldstr)))] & (unsigned short)_ISblank) || *fieldstr == '\x00') {
            in_digits = 0;
            if (dash_found) {
                dash_found = 0;
                if (!lhs_specified && !rhs_specified)
                    do {
                        error(0, 0, (gettext("invalid range with no endpoint: -")));
                        usage(1);
                    } while (0);
                if (!rhs_specified) {
                    eol_range_start = initial;
                    field_found = 1;
                } else {
                    if (value < initial)
                        do {
                            error(0, 0, (gettext("invalid decreasing range")));
                            usage(1);
                        } while (0);
                    if (eol_range_start != 0) {
                        if (initial < eol_range_start) {
                            if (eol_range_start <= value) {
                                eol_range_start = initial;
                            } else {
                                do {
                                    if (initial == 0 || value == 0)
                                        do {
                                            error(0, 0, (gettext("fields and positions are numbered from 1")));
                                            usage(1);
                                        } while (0);
                                    if (n_rp >= n_rp_allocated) {
                                        (rp) = x2nrealloc(rp, &n_rp_allocated, sizeof *(rp));
                                    }
                                    rp[n_rp].lo = (initial);
                                    rp[n_rp].hi = (value);
                                    ++n_rp;
                                } while (0);
                            }
                            field_found = 1;
                        }
                    } else {
                        do {
                            if (initial == 0 || value == 0)
                                do {
                                    error(0, 0, (gettext("fields and positions are numbered from 1")));
                                    usage(1);
                                } while (0);
                            if (n_rp >= n_rp_allocated) {
                                (rp) = x2nrealloc(rp, &n_rp_allocated, sizeof *(rp));
                            }
                            rp[n_rp].lo = (initial);
                            rp[n_rp].hi = (value);
                            ++n_rp;
                        } while (0);
                        field_found = 1;
                    }
                    value = 0;
                }
            } else {
                do {
                    if (value == 0 || value == 0)
                        do {
                            error(0, 0, (gettext("fields and positions are numbered from 1")));
                            usage(1);
                        } while (0);
                    if (n_rp >= n_rp_allocated) {
                        (rp) = x2nrealloc(rp, &n_rp_allocated, sizeof *(rp));
                    }
                    rp[n_rp].lo = (value);
                    rp[n_rp].hi = (value);
                    ++n_rp;
                } while (0);
                value = 0;
                field_found = 1;
            }
            if (*fieldstr == '\x00') {
                break;
            }
            fieldstr++;
            lhs_specified = 0;
            rhs_specified = 0;
        } else if (((unsigned int)(*fieldstr) - '0' <= 9)) {
            static const char *num_start;
            if (!in_digits || !num_start)
                num_start = fieldstr;
            in_digits = 1;
            if (dash_found)
                rhs_specified = 1;
            else
                lhs_specified = 1;
            if (!((void)(&(value) == (size_t *)((void *)0)) , (((size_t)-1 / 10 < (value) || (size_t)((value) * 10 + (*fieldstr - '0')) < (value)) ? 0 : (((value) = (value) * 10 + (*fieldstr - '0')) , 1)))) {
                size_t len = strspn(num_start, "0123456789");
                char *bad_num = xstrndup(num_start, len);
                if (operating_mode == byte_mode)
                    error(0, 0, gettext("byte offset %s is too large"), quote(bad_num));
                else
                    error(0, 0, gettext("field number %s is too large"), quote(bad_num));
                free(bad_num);
                exit(1);
            }
            fieldstr++;
        } else
            do {
                error(0, 0, (gettext("invalid byte or field list")));
                usage(1);
            } while (0);
    }


BasicTester, a patch instance with id 105:
Spawn 1 instances, now Total 146
Counter: 147
Batcher Size:46
Preprocess the following candidate with BasicTester:
Priority 7465
At location src/cut.c:363
--Src File: src/cut.c
Fragment 0:
operating_mode = (byte_mode);
while (1)
    {
        if (*fieldstr == '-') {
            in_digits = 0;
            if (dash_found)
                do {
                    error(0, 0, (gettext("invalid byte or field list")));
                    usage(1);
                } while (0);
            dash_found = 1;
            fieldstr++;
            initial = (lhs_specified ? value : 1);
            value = 0;
        } else if (*fieldstr == ',' || ((*__ctype_b_loc())[(int)((to_uchar(*fieldstr)))] & (unsigned short)_ISblank) || *fieldstr == '\x00') {
            in_digits = 0;
            if (dash_found) {
                dash_found = 0;
                if (!lhs_specified && !rhs_specified)
                    do {
                        error(0, 0, (gettext("invalid range with no endpoint: -")));
                        usage(1);
                    } while (0);
                if (!rhs_specified) {
                    eol_range_start = initial;
                    field_found = 1;
                } else {
                    if (value < initial)
                        do {
                            error(0, 0, (gettext("invalid decreasing range")));
                            usage(1);
                        } while (0);
                    if (eol_range_start != 0) {
                        if (initial < eol_range_start) {
                            if (eol_range_start <= value) {
                                eol_range_start = initial;
                            } else {
                                do {
                                    if (initial == 0 || value == 0)
                                        do {
                                            error(0, 0, (gettext("fields and positions are numbered from 1")));
                                            usage(1);
                                        } while (0);
                                    if (n_rp >= n_rp_allocated) {
                                        (rp) = x2nrealloc(rp, &n_rp_allocated, sizeof *(rp));
                                    }
                                    rp[n_rp].lo = (initial);
                                    rp[n_rp].hi = (value);
                                    ++n_rp;
                                } while (0);
                            }
                            field_found = 1;
                        }
                    } else {
                        do {
                            if (initial == 0 || value == 0)
                                do {
                                    error(0, 0, (gettext("fields and positions are numbered from 1")));
                                    usage(1);
                                } while (0);
                            if (n_rp >= n_rp_allocated) {
                                (rp) = x2nrealloc(rp, &n_rp_allocated, sizeof *(rp));
                            }
                            rp[n_rp].lo = (initial);
                            rp[n_rp].hi = (value);
                            ++n_rp;
                        } while (0);
                        field_found = 1;
                    }
                    value = 0;
                }
            } else {
                do {
                    if (value == 0 || value == 0)
                        do {
                            error(0, 0, (gettext("fields and positions are numbered from 1")));
                            usage(1);
                        } while (0);
                    if (n_rp >= n_rp_allocated) {
                        (rp) = x2nrealloc(rp, &n_rp_allocated, sizeof *(rp));
                    }
                    rp[n_rp].lo = (value);
                    rp[n_rp].hi = (value);
                    ++n_rp;
                } while (0);
                value = 0;
                field_found = 1;
            }
            if (*fieldstr == '\x00') {
                break;
            }
            fieldstr++;
            lhs_specified = 0;
            rhs_specified = 0;
        } else if (((unsigned int)(*fieldstr) - '0' <= 9)) {
            static const char *num_start;
            if (!in_digits || !num_start)
                num_start = fieldstr;
            in_digits = 1;
            if (dash_found)
                rhs_specified = 1;
            else
                lhs_specified = 1;
            if (!((void)(&(value) == (size_t *)((void *)0)) , (((size_t)-1 / 10 < (value) || (size_t)((value) * 10 + (*fieldstr - '0')) < (value)) ? 0 : (((value) = (value) * 10 + (*fieldstr - '0')) , 1)))) {
                size_t len = strspn(num_start, "0123456789");
                char *bad_num = xstrndup(num_start, len);
                if (operating_mode == byte_mode)
                    error(0, 0, gettext("byte offset %s is too large"), quote(bad_num));
                else
                    error(0, 0, gettext("field number %s is too large"), quote(bad_num));
                free(bad_num);
                exit(1);
            }
            fieldstr++;
        } else
            do {
                error(0, 0, (gettext("invalid byte or field list")));
                usage(1);
            } while (0);
    }


BasicTester, a patch instance with id 106:
Spawn 1 instances, now Total 147
Counter: 148
Batcher Size:47
Preprocess the following candidate with BasicTester:
Priority 7465
At location src/cut.c:363
--Src File: src/cut.c
Fragment 0:
operating_mode = (1);
while (1)
    {
        if (*fieldstr == '-') {
            in_digits = 0;
            if (dash_found)
                do {
                    error(0, 0, (gettext("invalid byte or field list")));
                    usage(1);
                } while (0);
            dash_found = 1;
            fieldstr++;
            initial = (lhs_specified ? value : 1);
            value = 0;
        } else if (*fieldstr == ',' || ((*__ctype_b_loc())[(int)((to_uchar(*fieldstr)))] & (unsigned short)_ISblank) || *fieldstr == '\x00') {
            in_digits = 0;
            if (dash_found) {
                dash_found = 0;
                if (!lhs_specified && !rhs_specified)
                    do {
                        error(0, 0, (gettext("invalid range with no endpoint: -")));
                        usage(1);
                    } while (0);
                if (!rhs_specified) {
                    eol_range_start = initial;
                    field_found = 1;
                } else {
                    if (value < initial)
                        do {
                            error(0, 0, (gettext("invalid decreasing range")));
                            usage(1);
                        } while (0);
                    if (eol_range_start != 0) {
                        if (initial < eol_range_start) {
                            if (eol_range_start <= value) {
                                eol_range_start = initial;
                            } else {
                                do {
                                    if (initial == 0 || value == 0)
                                        do {
                                            error(0, 0, (gettext("fields and positions are numbered from 1")));
                                            usage(1);
                                        } while (0);
                                    if (n_rp >= n_rp_allocated) {
                                        (rp) = x2nrealloc(rp, &n_rp_allocated, sizeof *(rp));
                                    }
                                    rp[n_rp].lo = (initial);
                                    rp[n_rp].hi = (value);
                                    ++n_rp;
                                } while (0);
                            }
                            field_found = 1;
                        }
                    } else {
                        do {
                            if (initial == 0 || value == 0)
                                do {
                                    error(0, 0, (gettext("fields and positions are numbered from 1")));
                                    usage(1);
                                } while (0);
                            if (n_rp >= n_rp_allocated) {
                                (rp) = x2nrealloc(rp, &n_rp_allocated, sizeof *(rp));
                            }
                            rp[n_rp].lo = (initial);
                            rp[n_rp].hi = (value);
                            ++n_rp;
                        } while (0);
                        field_found = 1;
                    }
                    value = 0;
                }
            } else {
                do {
                    if (value == 0 || value == 0)
                        do {
                            error(0, 0, (gettext("fields and positions are numbered from 1")));
                            usage(1);
                        } while (0);
                    if (n_rp >= n_rp_allocated) {
                        (rp) = x2nrealloc(rp, &n_rp_allocated, sizeof *(rp));
                    }
                    rp[n_rp].lo = (value);
                    rp[n_rp].hi = (value);
                    ++n_rp;
                } while (0);
                value = 0;
                field_found = 1;
            }
            if (*fieldstr == '\x00') {
                break;
            }
            fieldstr++;
            lhs_specified = 0;
            rhs_specified = 0;
        } else if (((unsigned int)(*fieldstr) - '0' <= 9)) {
            static const char *num_start;
            if (!in_digits || !num_start)
                num_start = fieldstr;
            in_digits = 1;
            if (dash_found)
                rhs_specified = 1;
            else
                lhs_specified = 1;
            if (!((void)(&(value) == (size_t *)((void *)0)) , (((size_t)-1 / 10 < (value) || (size_t)((value) * 10 + (*fieldstr - '0')) < (value)) ? 0 : (((value) = (value) * 10 + (*fieldstr - '0')) , 1)))) {
                size_t len = strspn(num_start, "0123456789");
                char *bad_num = xstrndup(num_start, len);
                if (operating_mode == byte_mode)
                    error(0, 0, gettext("byte offset %s is too large"), quote(bad_num));
                else
                    error(0, 0, gettext("field number %s is too large"), quote(bad_num));
                free(bad_num);
                exit(1);
            }
            fieldstr++;
        } else
            do {
                error(0, 0, (gettext("invalid byte or field list")));
                usage(1);
            } while (0);
    }


BasicTester, a patch instance with id 107:
Spawn 1 instances, now Total 148
Counter: 149
Batcher Size:48
Preprocess the following candidate with BasicTester:
Priority 7465
At location src/cut.c:363
--Src File: src/cut.c
Fragment 0:
operating_mode = (10);
while (1)
    {
        if (*fieldstr == '-') {
            in_digits = 0;
            if (dash_found)
                do {
                    error(0, 0, (gettext("invalid byte or field list")));
                    usage(1);
                } while (0);
            dash_found = 1;
            fieldstr++;
            initial = (lhs_specified ? value : 1);
            value = 0;
        } else if (*fieldstr == ',' || ((*__ctype_b_loc())[(int)((to_uchar(*fieldstr)))] & (unsigned short)_ISblank) || *fieldstr == '\x00') {
            in_digits = 0;
            if (dash_found) {
                dash_found = 0;
                if (!lhs_specified && !rhs_specified)
                    do {
                        error(0, 0, (gettext("invalid range with no endpoint: -")));
                        usage(1);
                    } while (0);
                if (!rhs_specified) {
                    eol_range_start = initial;
                    field_found = 1;
                } else {
                    if (value < initial)
                        do {
                            error(0, 0, (gettext("invalid decreasing range")));
                            usage(1);
                        } while (0);
                    if (eol_range_start != 0) {
                        if (initial < eol_range_start) {
                            if (eol_range_start <= value) {
                                eol_range_start = initial;
                            } else {
                                do {
                                    if (initial == 0 || value == 0)
                                        do {
                                            error(0, 0, (gettext("fields and positions are numbered from 1")));
                                            usage(1);
                                        } while (0);
                                    if (n_rp >= n_rp_allocated) {
                                        (rp) = x2nrealloc(rp, &n_rp_allocated, sizeof *(rp));
                                    }
                                    rp[n_rp].lo = (initial);
                                    rp[n_rp].hi = (value);
                                    ++n_rp;
                                } while (0);
                            }
                            field_found = 1;
                        }
                    } else {
                        do {
                            if (initial == 0 || value == 0)
                                do {
                                    error(0, 0, (gettext("fields and positions are numbered from 1")));
                                    usage(1);
                                } while (0);
                            if (n_rp >= n_rp_allocated) {
                                (rp) = x2nrealloc(rp, &n_rp_allocated, sizeof *(rp));
                            }
                            rp[n_rp].lo = (initial);
                            rp[n_rp].hi = (value);
                            ++n_rp;
                        } while (0);
                        field_found = 1;
                    }
                    value = 0;
                }
            } else {
                do {
                    if (value == 0 || value == 0)
                        do {
                            error(0, 0, (gettext("fields and positions are numbered from 1")));
                            usage(1);
                        } while (0);
                    if (n_rp >= n_rp_allocated) {
                        (rp) = x2nrealloc(rp, &n_rp_allocated, sizeof *(rp));
                    }
                    rp[n_rp].lo = (value);
                    rp[n_rp].hi = (value);
                    ++n_rp;
                } while (0);
                value = 0;
                field_found = 1;
            }
            if (*fieldstr == '\x00') {
                break;
            }
            fieldstr++;
            lhs_specified = 0;
            rhs_specified = 0;
        } else if (((unsigned int)(*fieldstr) - '0' <= 9)) {
            static const char *num_start;
            if (!in_digits || !num_start)
                num_start = fieldstr;
            in_digits = 1;
            if (dash_found)
                rhs_specified = 1;
            else
                lhs_specified = 1;
            if (!((void)(&(value) == (size_t *)((void *)0)) , (((size_t)-1 / 10 < (value) || (size_t)((value) * 10 + (*fieldstr - '0')) < (value)) ? 0 : (((value) = (value) * 10 + (*fieldstr - '0')) , 1)))) {
                size_t len = strspn(num_start, "0123456789");
                char *bad_num = xstrndup(num_start, len);
                if (operating_mode == byte_mode)
                    error(0, 0, gettext("byte offset %s is too large"), quote(bad_num));
                else
                    error(0, 0, gettext("field number %s is too large"), quote(bad_num));
                free(bad_num);
                exit(1);
            }
            fieldstr++;
        } else
            do {
                error(0, 0, (gettext("invalid byte or field list")));
                usage(1);
            } while (0);
    }


BasicTester, a patch instance with id 108:
Spawn 1 instances, now Total 149
Counter: 150
Batcher Size:49
Preprocess the following candidate with BasicTester:
Priority 7465
At location src/cut.c:363
--Src File: src/cut.c
Fragment 0:
operating_mode = (8);
while (1)
    {
        if (*fieldstr == '-') {
            in_digits = 0;
            if (dash_found)
                do {
                    error(0, 0, (gettext("invalid byte or field list")));
                    usage(1);
                } while (0);
            dash_found = 1;
            fieldstr++;
            initial = (lhs_specified ? value : 1);
            value = 0;
        } else if (*fieldstr == ',' || ((*__ctype_b_loc())[(int)((to_uchar(*fieldstr)))] & (unsigned short)_ISblank) || *fieldstr == '\x00') {
            in_digits = 0;
            if (dash_found) {
                dash_found = 0;
                if (!lhs_specified && !rhs_specified)
                    do {
                        error(0, 0, (gettext("invalid range with no endpoint: -")));
                        usage(1);
                    } while (0);
                if (!rhs_specified) {
                    eol_range_start = initial;
                    field_found = 1;
                } else {
                    if (value < initial)
                        do {
                            error(0, 0, (gettext("invalid decreasing range")));
                            usage(1);
                        } while (0);
                    if (eol_range_start != 0) {
                        if (initial < eol_range_start) {
                            if (eol_range_start <= value) {
                                eol_range_start = initial;
                            } else {
                                do {
                                    if (initial == 0 || value == 0)
                                        do {
                                            error(0, 0, (gettext("fields and positions are numbered from 1")));
                                            usage(1);
                                        } while (0);
                                    if (n_rp >= n_rp_allocated) {
                                        (rp) = x2nrealloc(rp, &n_rp_allocated, sizeof *(rp));
                                    }
                                    rp[n_rp].lo = (initial);
                                    rp[n_rp].hi = (value);
                                    ++n_rp;
                                } while (0);
                            }
                            field_found = 1;
                        }
                    } else {
                        do {
                            if (initial == 0 || value == 0)
                                do {
                                    error(0, 0, (gettext("fields and positions are numbered from 1")));
                                    usage(1);
                                } while (0);
                            if (n_rp >= n_rp_allocated) {
                                (rp) = x2nrealloc(rp, &n_rp_allocated, sizeof *(rp));
                            }
                            rp[n_rp].lo = (initial);
                            rp[n_rp].hi = (value);
                            ++n_rp;
                        } while (0);
                        field_found = 1;
                    }
                    value = 0;
                }
            } else {
                do {
                    if (value == 0 || value == 0)
                        do {
                            error(0, 0, (gettext("fields and positions are numbered from 1")));
                            usage(1);
                        } while (0);
                    if (n_rp >= n_rp_allocated) {
                        (rp) = x2nrealloc(rp, &n_rp_allocated, sizeof *(rp));
                    }
                    rp[n_rp].lo = (value);
                    rp[n_rp].hi = (value);
                    ++n_rp;
                } while (0);
                value = 0;
                field_found = 1;
            }
            if (*fieldstr == '\x00') {
                break;
            }
            fieldstr++;
            lhs_specified = 0;
            rhs_specified = 0;
        } else if (((unsigned int)(*fieldstr) - '0' <= 9)) {
            static const char *num_start;
            if (!in_digits || !num_start)
                num_start = fieldstr;
            in_digits = 1;
            if (dash_found)
                rhs_specified = 1;
            else
                lhs_specified = 1;
            if (!((void)(&(value) == (size_t *)((void *)0)) , (((size_t)-1 / 10 < (value) || (size_t)((value) * 10 + (*fieldstr - '0')) < (value)) ? 0 : (((value) = (value) * 10 + (*fieldstr - '0')) , 1)))) {
                size_t len = strspn(num_start, "0123456789");
                char *bad_num = xstrndup(num_start, len);
                if (operating_mode == byte_mode)
                    error(0, 0, gettext("byte offset %s is too large"), quote(bad_num));
                else
                    error(0, 0, gettext("field number %s is too large"), quote(bad_num));
                free(bad_num);
                exit(1);
            }
            fieldstr++;
        } else
            do {
                error(0, 0, (gettext("invalid byte or field list")));
                usage(1);
            } while (0);
    }


BasicTester, a patch instance with id 109:
Spawn 1 instances, now Total 150
Counter: 151
Batcher Size:50
Preprocess the following candidate with BasicTester:
Priority 7465
At location src/cut.c:363
--Src File: src/cut.c
Fragment 0:
max_range_endpoint = (n_rp);
while (1)
    {
        if (*fieldstr == '-') {
            in_digits = 0;
            if (dash_found)
                do {
                    error(0, 0, (gettext("invalid byte or field list")));
                    usage(1);
                } while (0);
            dash_found = 1;
            fieldstr++;
            initial = (lhs_specified ? value : 1);
            value = 0;
        } else if (*fieldstr == ',' || ((*__ctype_b_loc())[(int)((to_uchar(*fieldstr)))] & (unsigned short)_ISblank) || *fieldstr == '\x00') {
            in_digits = 0;
            if (dash_found) {
                dash_found = 0;
                if (!lhs_specified && !rhs_specified)
                    do {
                        error(0, 0, (gettext("invalid range with no endpoint: -")));
                        usage(1);
                    } while (0);
                if (!rhs_specified) {
                    eol_range_start = initial;
                    field_found = 1;
                } else {
                    if (value < initial)
                        do {
                            error(0, 0, (gettext("invalid decreasing range")));
                            usage(1);
                        } while (0);
                    if (eol_range_start != 0) {
                        if (initial < eol_range_start) {
                            if (eol_range_start <= value) {
                                eol_range_start = initial;
                            } else {
                                do {
                                    if (initial == 0 || value == 0)
                                        do {
                                            error(0, 0, (gettext("fields and positions are numbered from 1")));
                                            usage(1);
                                        } while (0);
                                    if (n_rp >= n_rp_allocated) {
                                        (rp) = x2nrealloc(rp, &n_rp_allocated, sizeof *(rp));
                                    }
                                    rp[n_rp].lo = (initial);
                                    rp[n_rp].hi = (value);
                                    ++n_rp;
                                } while (0);
                            }
                            field_found = 1;
                        }
                    } else {
                        do {
                            if (initial == 0 || value == 0)
                                do {
                                    error(0, 0, (gettext("fields and positions are numbered from 1")));
                                    usage(1);
                                } while (0);
                            if (n_rp >= n_rp_allocated) {
                                (rp) = x2nrealloc(rp, &n_rp_allocated, sizeof *(rp));
                            }
                            rp[n_rp].lo = (initial);
                            rp[n_rp].hi = (value);
                            ++n_rp;
                        } while (0);
                        field_found = 1;
                    }
                    value = 0;
                }
            } else {
                do {
                    if (value == 0 || value == 0)
                        do {
                            error(0, 0, (gettext("fields and positions are numbered from 1")));
                            usage(1);
                        } while (0);
                    if (n_rp >= n_rp_allocated) {
                        (rp) = x2nrealloc(rp, &n_rp_allocated, sizeof *(rp));
                    }
                    rp[n_rp].lo = (value);
                    rp[n_rp].hi = (value);
                    ++n_rp;
                } while (0);
                value = 0;
                field_found = 1;
            }
            if (*fieldstr == '\x00') {
                break;
            }
            fieldstr++;
            lhs_specified = 0;
            rhs_specified = 0;
        } else if (((unsigned int)(*fieldstr) - '0' <= 9)) {
            static const char *num_start;
            if (!in_digits || !num_start)
                num_start = fieldstr;
            in_digits = 1;
            if (dash_found)
                rhs_specified = 1;
            else
                lhs_specified = 1;
            if (!((void)(&(value) == (size_t *)((void *)0)) , (((size_t)-1 / 10 < (value) || (size_t)((value) * 10 + (*fieldstr - '0')) < (value)) ? 0 : (((value) = (value) * 10 + (*fieldstr - '0')) , 1)))) {
                size_t len = strspn(num_start, "0123456789");
                char *bad_num = xstrndup(num_start, len);
                if (operating_mode == byte_mode)
                    error(0, 0, gettext("byte offset %s is too large"), quote(bad_num));
                else
                    error(0, 0, gettext("field number %s is too large"), quote(bad_num));
                free(bad_num);
                exit(1);
            }
            fieldstr++;
        } else
            do {
                error(0, 0, (gettext("invalid byte or field list")));
                usage(1);
            } while (0);
    }


BasicTester, a patch instance with id 110:
Spawn 1 instances, now Total 151
Counter: 152
Batcher Size:51
Preprocess the following candidate with BasicTester:
Priority 7465
At location src/cut.c:363
--Src File: src/cut.c
Fragment 0:
max_range_endpoint = (value);
while (1)
    {
        if (*fieldstr == '-') {
            in_digits = 0;
            if (dash_found)
                do {
                    error(0, 0, (gettext("invalid byte or field list")));
                    usage(1);
                } while (0);
            dash_found = 1;
            fieldstr++;
            initial = (lhs_specified ? value : 1);
            value = 0;
        } else if (*fieldstr == ',' || ((*__ctype_b_loc())[(int)((to_uchar(*fieldstr)))] & (unsigned short)_ISblank) || *fieldstr == '\x00') {
            in_digits = 0;
            if (dash_found) {
                dash_found = 0;
                if (!lhs_specified && !rhs_specified)
                    do {
                        error(0, 0, (gettext("invalid range with no endpoint: -")));
                        usage(1);
                    } while (0);
                if (!rhs_specified) {
                    eol_range_start = initial;
                    field_found = 1;
                } else {
                    if (value < initial)
                        do {
                            error(0, 0, (gettext("invalid decreasing range")));
                            usage(1);
                        } while (0);
                    if (eol_range_start != 0) {
                        if (initial < eol_range_start) {
                            if (eol_range_start <= value) {
                                eol_range_start = initial;
                            } else {
                                do {
                                    if (initial == 0 || value == 0)
                                        do {
                                            error(0, 0, (gettext("fields and positions are numbered from 1")));
                                            usage(1);
                                        } while (0);
                                    if (n_rp >= n_rp_allocated) {
                                        (rp) = x2nrealloc(rp, &n_rp_allocated, sizeof *(rp));
                                    }
                                    rp[n_rp].lo = (initial);
                                    rp[n_rp].hi = (value);
                                    ++n_rp;
                                } while (0);
                            }
                            field_found = 1;
                        }
                    } else {
                        do {
                            if (initial == 0 || value == 0)
                                do {
                                    error(0, 0, (gettext("fields and positions are numbered from 1")));
                                    usage(1);
                                } while (0);
                            if (n_rp >= n_rp_allocated) {
                                (rp) = x2nrealloc(rp, &n_rp_allocated, sizeof *(rp));
                            }
                            rp[n_rp].lo = (initial);
                            rp[n_rp].hi = (value);
                            ++n_rp;
                        } while (0);
                        field_found = 1;
                    }
                    value = 0;
                }
            } else {
                do {
                    if (value == 0 || value == 0)
                        do {
                            error(0, 0, (gettext("fields and positions are numbered from 1")));
                            usage(1);
                        } while (0);
                    if (n_rp >= n_rp_allocated) {
                        (rp) = x2nrealloc(rp, &n_rp_allocated, sizeof *(rp));
                    }
                    rp[n_rp].lo = (value);
                    rp[n_rp].hi = (value);
                    ++n_rp;
                } while (0);
                value = 0;
                field_found = 1;
            }
            if (*fieldstr == '\x00') {
                break;
            }
            fieldstr++;
            lhs_specified = 0;
            rhs_specified = 0;
        } else if (((unsigned int)(*fieldstr) - '0' <= 9)) {
            static const char *num_start;
            if (!in_digits || !num_start)
                num_start = fieldstr;
            in_digits = 1;
            if (dash_found)
                rhs_specified = 1;
            else
                lhs_specified = 1;
            if (!((void)(&(value) == (size_t *)((void *)0)) , (((size_t)-1 / 10 < (value) || (size_t)((value) * 10 + (*fieldstr - '0')) < (value)) ? 0 : (((value) = (value) * 10 + (*fieldstr - '0')) , 1)))) {
                size_t len = strspn(num_start, "0123456789");
                char *bad_num = xstrndup(num_start, len);
                if (operating_mode == byte_mode)
                    error(0, 0, gettext("byte offset %s is too large"), quote(bad_num));
                else
                    error(0, 0, gettext("field number %s is too large"), quote(bad_num));
                free(bad_num);
                exit(1);
            }
            fieldstr++;
        } else
            do {
                error(0, 0, (gettext("invalid byte or field list")));
                usage(1);
            } while (0);
    }


BasicTester, a patch instance with id 111:
Spawn 1 instances, now Total 152
Counter: 153
Batcher Size:52
Preprocess the following candidate with BasicTester:
Priority 7465
At location src/cut.c:363
--Src File: src/cut.c
Fragment 0:
max_range_endpoint = rp[i].hi;
while (1)
    {
        if (*fieldstr == '-') {
            in_digits = 0;
            if (dash_found)
                do {
                    error(0, 0, (gettext("invalid byte or field list")));
                    usage(1);
                } while (0);
            dash_found = 1;
            fieldstr++;
            initial = (lhs_specified ? value : 1);
            value = 0;
        } else if (*fieldstr == ',' || ((*__ctype_b_loc())[(int)((to_uchar(*fieldstr)))] & (unsigned short)_ISblank) || *fieldstr == '\x00') {
            in_digits = 0;
            if (dash_found) {
                dash_found = 0;
                if (!lhs_specified && !rhs_specified)
                    do {
                        error(0, 0, (gettext("invalid range with no endpoint: -")));
                        usage(1);
                    } while (0);
                if (!rhs_specified) {
                    eol_range_start = initial;
                    field_found = 1;
                } else {
                    if (value < initial)
                        do {
                            error(0, 0, (gettext("invalid decreasing range")));
                            usage(1);
                        } while (0);
                    if (eol_range_start != 0) {
                        if (initial < eol_range_start) {
                            if (eol_range_start <= value) {
                                eol_range_start = initial;
                            } else {
                                do {
                                    if (initial == 0 || value == 0)
                                        do {
                                            error(0, 0, (gettext("fields and positions are numbered from 1")));
                                            usage(1);
                                        } while (0);
                                    if (n_rp >= n_rp_allocated) {
                                        (rp) = x2nrealloc(rp, &n_rp_allocated, sizeof *(rp));
                                    }
                                    rp[n_rp].lo = (initial);
                                    rp[n_rp].hi = (value);
                                    ++n_rp;
                                } while (0);
                            }
                            field_found = 1;
                        }
                    } else {
                        do {
                            if (initial == 0 || value == 0)
                                do {
                                    error(0, 0, (gettext("fields and positions are numbered from 1")));
                                    usage(1);
                                } while (0);
                            if (n_rp >= n_rp_allocated) {
                                (rp) = x2nrealloc(rp, &n_rp_allocated, sizeof *(rp));
                            }
                            rp[n_rp].lo = (initial);
                            rp[n_rp].hi = (value);
                            ++n_rp;
                        } while (0);
                        field_found = 1;
                    }
                    value = 0;
                }
            } else {
                do {
                    if (value == 0 || value == 0)
                        do {
                            error(0, 0, (gettext("fields and positions are numbered from 1")));
                            usage(1);
                        } while (0);
                    if (n_rp >= n_rp_allocated) {
                        (rp) = x2nrealloc(rp, &n_rp_allocated, sizeof *(rp));
                    }
                    rp[n_rp].lo = (value);
                    rp[n_rp].hi = (value);
                    ++n_rp;
                } while (0);
                value = 0;
                field_found = 1;
            }
            if (*fieldstr == '\x00') {
                break;
            }
            fieldstr++;
            lhs_specified = 0;
            rhs_specified = 0;
        } else if (((unsigned int)(*fieldstr) - '0' <= 9)) {
            static const char *num_start;
            if (!in_digits || !num_start)
                num_start = fieldstr;
            in_digits = 1;
            if (dash_found)
                rhs_specified = 1;
            else
                lhs_specified = 1;
            if (!((void)(&(value) == (size_t *)((void *)0)) , (((size_t)-1 / 10 < (value) || (size_t)((value) * 10 + (*fieldstr - '0')) < (value)) ? 0 : (((value) = (value) * 10 + (*fieldstr - '0')) , 1)))) {
                size_t len = strspn(num_start, "0123456789");
                char *bad_num = xstrndup(num_start, len);
                if (operating_mode == byte_mode)
                    error(0, 0, gettext("byte offset %s is too large"), quote(bad_num));
                else
                    error(0, 0, gettext("field number %s is too large"), quote(bad_num));
                free(bad_num);
                exit(1);
            }
            fieldstr++;
        } else
            do {
                error(0, 0, (gettext("invalid byte or field list")));
                usage(1);
            } while (0);
    }


BasicTester, a patch instance with id 112:
Spawn 1 instances, now Total 153
a batched test job starts!
Building:src at:
/home/ubuntu/spr-fast/tests/corebench/coreutils/coreutils-case-7380cf79-2e636af1/tempworkdir/srcMerged code building succ, going to invoke tester!
BasicTester, Testing instance id 103:
Running test command:
/home/ubuntu/spr-fast/tools/coreutils-test.py /home/ubuntu/spr-fast/tests/corebench/coreutils/coreutils-case-7380cf79-2e636af1/tempworkdir/src /home/ubuntu/spr-fast/tests/corebench/coreutils/coreutils-case-7380cf79-2e636af1/tempworkdir/tests /home/ubuntu/spr-fast/tests/corebench/coreutils/coreutils-case-7380cf79-2e636af1/tempworkdir 0  > __res
BasicTester, Testing instance id 104:
Running test command:
/home/ubuntu/spr-fast/tools/coreutils-test.py /home/ubuntu/spr-fast/tests/corebench/coreutils/coreutils-case-7380cf79-2e636af1/tempworkdir/src /home/ubuntu/spr-fast/tests/corebench/coreutils/coreutils-case-7380cf79-2e636af1/tempworkdir/tests /home/ubuntu/spr-fast/tests/corebench/coreutils/coreutils-case-7380cf79-2e636af1/tempworkdir 0  > __res
BasicTester, Testing instance id 105:
Running test command:
/home/ubuntu/spr-fast/tools/coreutils-test.py /home/ubuntu/spr-fast/tests/corebench/coreutils/coreutils-case-7380cf79-2e636af1/tempworkdir/src /home/ubuntu/spr-fast/tests/corebench/coreutils/coreutils-case-7380cf79-2e636af1/tempworkdir/tests /home/ubuntu/spr-fast/tests/corebench/coreutils/coreutils-case-7380cf79-2e636af1/tempworkdir 0  > __res
BasicTester, Testing instance id 106:
Running test command:
/home/ubuntu/spr-fast/tools/coreutils-test.py /home/ubuntu/spr-fast/tests/corebench/coreutils/coreutils-case-7380cf79-2e636af1/tempworkdir/src /home/ubuntu/spr-fast/tests/corebench/coreutils/coreutils-case-7380cf79-2e636af1/tempworkdir/tests /home/ubuntu/spr-fast/tests/corebench/coreutils/coreutils-case-7380cf79-2e636af1/tempworkdir 0  > __res
BasicTester, Testing instance id 107:
Running test command:
/home/ubuntu/spr-fast/tools/coreutils-test.py /home/ubuntu/spr-fast/tests/corebench/coreutils/coreutils-case-7380cf79-2e636af1/tempworkdir/src /home/ubuntu/spr-fast/tests/corebench/coreutils/coreutils-case-7380cf79-2e636af1/tempworkdir/tests /home/ubuntu/spr-fast/tests/corebench/coreutils/coreutils-case-7380cf79-2e636af1/tempworkdir 0  > __res
BasicTester, Testing instance id 108:
Running test command:
/home/ubuntu/spr-fast/tools/coreutils-test.py /home/ubuntu/spr-fast/tests/corebench/coreutils/coreutils-case-7380cf79-2e636af1/tempworkdir/src /home/ubuntu/spr-fast/tests/corebench/coreutils/coreutils-case-7380cf79-2e636af1/tempworkdir/tests /home/ubuntu/spr-fast/tests/corebench/coreutils/coreutils-case-7380cf79-2e636af1/tempworkdir 0  > __res
BasicTester, Testing instance id 109:
Running test command:
/home/ubuntu/spr-fast/tools/coreutils-test.py /home/ubuntu/spr-fast/tests/corebench/coreutils/coreutils-case-7380cf79-2e636af1/tempworkdir/src /home/ubuntu/spr-fast/tests/corebench/coreutils/coreutils-case-7380cf79-2e636af1/tempworkdir/tests /home/ubuntu/spr-fast/tests/corebench/coreutils/coreutils-case-7380cf79-2e636af1/tempworkdir 0  > __res
BasicTester, Testing instance id 110:
Running test command:
/home/ubuntu/spr-fast/tools/coreutils-test.py /home/ubuntu/spr-fast/tests/corebench/coreutils/coreutils-case-7380cf79-2e636af1/tempworkdir/src /home/ubuntu/spr-fast/tests/corebench/coreutils/coreutils-case-7380cf79-2e636af1/tempworkdir/tests /home/ubuntu/spr-fast/tests/corebench/coreutils/coreutils-case-7380cf79-2e636af1/tempworkdir 0  > __res
BasicTester, Testing instance id 111:
Running test command:
/home/ubuntu/spr-fast/tools/coreutils-test.py /home/ubuntu/spr-fast/tests/corebench/coreutils/coreutils-case-7380cf79-2e636af1/tempworkdir/src /home/ubuntu/spr-fast/tests/corebench/coreutils/coreutils-case-7380cf79-2e636af1/tempworkdir/tests /home/ubuntu/spr-fast/tests/corebench/coreutils/coreutils-case-7380cf79-2e636af1/tempworkdir 0  > __res
BasicTester, Testing instance id 112:
Running test command:
/home/ubuntu/spr-fast/tools/coreutils-test.py /home/ubuntu/spr-fast/tests/corebench/coreutils/coreutils-case-7380cf79-2e636af1/tempworkdir/src /home/ubuntu/spr-fast/tests/corebench/coreutils/coreutils-case-7380cf79-2e636af1/tempworkdir/tests /home/ubuntu/spr-fast/tests/corebench/coreutils/coreutils-case-7380cf79-2e636af1/tempworkdir 0  > __res
Counter: 154
Batcher Size:43
Preprocess the following candidate with BasicTester:
Priority 7465
At location src/cut.c:363
--Src File: src/cut.c
Fragment 0:
operating_mode = (-1);
while (1)
    {
        if (*fieldstr == '-') {
            in_digits = 0;
            if (dash_found)
                do {
                    error(0, 0, (gettext("invalid byte or field list")));
                    usage(1);
                } while (0);
            dash_found = 1;
            fieldstr++;
            initial = (lhs_specified ? value : 1);
            value = 0;
        } else if (*fieldstr == ',' || ((*__ctype_b_loc())[(int)((to_uchar(*fieldstr)))] & (unsigned short)_ISblank) || *fieldstr == '\x00') {
            in_digits = 0;
            if (dash_found) {
                dash_found = 0;
                if (!lhs_specified && !rhs_specified)
                    do {
                        error(0, 0, (gettext("invalid range with no endpoint: -")));
                        usage(1);
                    } while (0);
                if (!rhs_specified) {
                    eol_range_start = initial;
                    field_found = 1;
                } else {
                    if (value < initial)
                        do {
                            error(0, 0, (gettext("invalid decreasing range")));
                            usage(1);
                        } while (0);
                    if (eol_range_start != 0) {
                        if (initial < eol_range_start) {
                            if (eol_range_start <= value) {
                                eol_range_start = initial;
                            } else {
                                do {
                                    if (initial == 0 || value == 0)
                                        do {
                                            error(0, 0, (gettext("fields and positions are numbered from 1")));
                                            usage(1);
                                        } while (0);
                                    if (n_rp >= n_rp_allocated) {
                                        (rp) = x2nrealloc(rp, &n_rp_allocated, sizeof *(rp));
                                    }
                                    rp[n_rp].lo = (initial);
                                    rp[n_rp].hi = (value);
                                    ++n_rp;
                                } while (0);
                            }
                            field_found = 1;
                        }
                    } else {
                        do {
                            if (initial == 0 || value == 0)
                                do {
                                    error(0, 0, (gettext("fields and positions are numbered from 1")));
                                    usage(1);
                                } while (0);
                            if (n_rp >= n_rp_allocated) {
                                (rp) = x2nrealloc(rp, &n_rp_allocated, sizeof *(rp));
                            }
                            rp[n_rp].lo = (initial);
                            rp[n_rp].hi = (value);
                            ++n_rp;
                        } while (0);
                        field_found = 1;
                    }
                    value = 0;
                }
            } else {
                do {
                    if (value == 0 || value == 0)
                        do {
                            error(0, 0, (gettext("fields and positions are numbered from 1")));
                            usage(1);
                        } while (0);
                    if (n_rp >= n_rp_allocated) {
                        (rp) = x2nrealloc(rp, &n_rp_allocated, sizeof *(rp));
                    }
                    rp[n_rp].lo = (value);
                    rp[n_rp].hi = (value);
                    ++n_rp;
                } while (0);
                value = 0;
                field_found = 1;
            }
            if (*fieldstr == '\x00') {
                break;
            }
            fieldstr++;
            lhs_specified = 0;
            rhs_specified = 0;
        } else if (((unsigned int)(*fieldstr) - '0' <= 9)) {
            static const char *num_start;
            if (!in_digits || !num_start)
                num_start = fieldstr;
            in_digits = 1;
            if (dash_found)
                rhs_specified = 1;
            else
                lhs_specified = 1;
            if (!((void)(&(value) == (size_t *)((void *)0)) , (((size_t)-1 / 10 < (value) || (size_t)((value) * 10 + (*fieldstr - '0')) < (value)) ? 0 : (((value) = (value) * 10 + (*fieldstr - '0')) , 1)))) {
                size_t len = strspn(num_start, "0123456789");
                char *bad_num = xstrndup(num_start, len);
                if (operating_mode == byte_mode)
                    error(0, 0, gettext("byte offset %s is too large"), quote(bad_num));
                else
                    error(0, 0, gettext("field number %s is too large"), quote(bad_num));
                free(bad_num);
                exit(1);
            }
            fieldstr++;
        } else
            do {
                error(0, 0, (gettext("invalid byte or field list")));
                usage(1);
            } while (0);
    }


BasicTester, a patch instance with id 113:
Spawn 1 instances, now Total 154
Counter: 155
Batcher Size:44
Preprocess the following candidate with BasicTester:
Priority 7465
At location src/cut.c:363
--Src File: src/cut.c
Fragment 0:
max_range_endpoint = 0;
while (1)
    {
        if (*fieldstr == '-') {
            in_digits = 0;
            if (dash_found)
                do {
                    error(0, 0, (gettext("invalid byte or field list")));
                    usage(1);
                } while (0);
            dash_found = 1;
            fieldstr++;
            initial = (lhs_specified ? value : 1);
            value = 0;
        } else if (*fieldstr == ',' || ((*__ctype_b_loc())[(int)((to_uchar(*fieldstr)))] & (unsigned short)_ISblank) || *fieldstr == '\x00') {
            in_digits = 0;
            if (dash_found) {
                dash_found = 0;
                if (!lhs_specified && !rhs_specified)
                    do {
                        error(0, 0, (gettext("invalid range with no endpoint: -")));
                        usage(1);
                    } while (0);
                if (!rhs_specified) {
                    eol_range_start = initial;
                    field_found = 1;
                } else {
                    if (value < initial)
                        do {
                            error(0, 0, (gettext("invalid decreasing range")));
                            usage(1);
                        } while (0);
                    if (eol_range_start != 0) {
                        if (initial < eol_range_start) {
                            if (eol_range_start <= value) {
                                eol_range_start = initial;
                            } else {
                                do {
                                    if (initial == 0 || value == 0)
                                        do {
                                            error(0, 0, (gettext("fields and positions are numbered from 1")));
                                            usage(1);
                                        } while (0);
                                    if (n_rp >= n_rp_allocated) {
                                        (rp) = x2nrealloc(rp, &n_rp_allocated, sizeof *(rp));
                                    }
                                    rp[n_rp].lo = (initial);
                                    rp[n_rp].hi = (value);
                                    ++n_rp;
                                } while (0);
                            }
                            field_found = 1;
                        }
                    } else {
                        do {
                            if (initial == 0 || value == 0)
                                do {
                                    error(0, 0, (gettext("fields and positions are numbered from 1")));
                                    usage(1);
                                } while (0);
                            if (n_rp >= n_rp_allocated) {
                                (rp) = x2nrealloc(rp, &n_rp_allocated, sizeof *(rp));
                            }
                            rp[n_rp].lo = (initial);
                            rp[n_rp].hi = (value);
                            ++n_rp;
                        } while (0);
                        field_found = 1;
                    }
                    value = 0;
                }
            } else {
                do {
                    if (value == 0 || value == 0)
                        do {
                            error(0, 0, (gettext("fields and positions are numbered from 1")));
                            usage(1);
                        } while (0);
                    if (n_rp >= n_rp_allocated) {
                        (rp) = x2nrealloc(rp, &n_rp_allocated, sizeof *(rp));
                    }
                    rp[n_rp].lo = (value);
                    rp[n_rp].hi = (value);
                    ++n_rp;
                } while (0);
                value = 0;
                field_found = 1;
            }
            if (*fieldstr == '\x00') {
                break;
            }
            fieldstr++;
            lhs_specified = 0;
            rhs_specified = 0;
        } else if (((unsigned int)(*fieldstr) - '0' <= 9)) {
            static const char *num_start;
            if (!in_digits || !num_start)
                num_start = fieldstr;
            in_digits = 1;
            if (dash_found)
                rhs_specified = 1;
            else
                lhs_specified = 1;
            if (!((void)(&(value) == (size_t *)((void *)0)) , (((size_t)-1 / 10 < (value) || (size_t)((value) * 10 + (*fieldstr - '0')) < (value)) ? 0 : (((value) = (value) * 10 + (*fieldstr - '0')) , 1)))) {
                size_t len = strspn(num_start, "0123456789");
                char *bad_num = xstrndup(num_start, len);
                if (operating_mode == byte_mode)
                    error(0, 0, gettext("byte offset %s is too large"), quote(bad_num));
                else
                    error(0, 0, gettext("field number %s is too large"), quote(bad_num));
                free(bad_num);
                exit(1);
            }
            fieldstr++;
        } else
            do {
                error(0, 0, (gettext("invalid byte or field list")));
                usage(1);
            } while (0);
    }


BasicTester, a patch instance with id 114:
Spawn 1 instances, now Total 155
Counter: 156
Batcher Size:45
Preprocess the following candidate with BasicTester:
Priority 7465
At location src/cut.c:363
--Src File: src/cut.c
Fragment 0:
max_range_endpoint = (n_rp_allocated);
while (1)
    {
        if (*fieldstr == '-') {
            in_digits = 0;
            if (dash_found)
                do {
                    error(0, 0, (gettext("invalid byte or field list")));
                    usage(1);
                } while (0);
            dash_found = 1;
            fieldstr++;
            initial = (lhs_specified ? value : 1);
            value = 0;
        } else if (*fieldstr == ',' || ((*__ctype_b_loc())[(int)((to_uchar(*fieldstr)))] & (unsigned short)_ISblank) || *fieldstr == '\x00') {
            in_digits = 0;
            if (dash_found) {
                dash_found = 0;
                if (!lhs_specified && !rhs_specified)
                    do {
                        error(0, 0, (gettext("invalid range with no endpoint: -")));
                        usage(1);
                    } while (0);
                if (!rhs_specified) {
                    eol_range_start = initial;
                    field_found = 1;
                } else {
                    if (value < initial)
                        do {
                            error(0, 0, (gettext("invalid decreasing range")));
                            usage(1);
                        } while (0);
                    if (eol_range_start != 0) {
                        if (initial < eol_range_start) {
                            if (eol_range_start <= value) {
                                eol_range_start = initial;
                            } else {
                                do {
                                    if (initial == 0 || value == 0)
                                        do {
                                            error(0, 0, (gettext("fields and positions are numbered from 1")));
                                            usage(1);
                                        } while (0);
                                    if (n_rp >= n_rp_allocated) {
                                        (rp) = x2nrealloc(rp, &n_rp_allocated, sizeof *(rp));
                                    }
                                    rp[n_rp].lo = (initial);
                                    rp[n_rp].hi = (value);
                                    ++n_rp;
                                } while (0);
                            }
                            field_found = 1;
                        }
                    } else {
                        do {
                            if (initial == 0 || value == 0)
                                do {
                                    error(0, 0, (gettext("fields and positions are numbered from 1")));
                                    usage(1);
                                } while (0);
                            if (n_rp >= n_rp_allocated) {
                                (rp) = x2nrealloc(rp, &n_rp_allocated, sizeof *(rp));
                            }
                            rp[n_rp].lo = (initial);
                            rp[n_rp].hi = (value);
                            ++n_rp;
                        } while (0);
                        field_found = 1;
                    }
                    value = 0;
                }
            } else {
                do {
                    if (value == 0 || value == 0)
                        do {
                            error(0, 0, (gettext("fields and positions are numbered from 1")));
                            usage(1);
                        } while (0);
                    if (n_rp >= n_rp_allocated) {
                        (rp) = x2nrealloc(rp, &n_rp_allocated, sizeof *(rp));
                    }
                    rp[n_rp].lo = (value);
                    rp[n_rp].hi = (value);
                    ++n_rp;
                } while (0);
                value = 0;
                field_found = 1;
            }
            if (*fieldstr == '\x00') {
                break;
            }
            fieldstr++;
            lhs_specified = 0;
            rhs_specified = 0;
        } else if (((unsigned int)(*fieldstr) - '0' <= 9)) {
            static const char *num_start;
            if (!in_digits || !num_start)
                num_start = fieldstr;
            in_digits = 1;
            if (dash_found)
                rhs_specified = 1;
            else
                lhs_specified = 1;
            if (!((void)(&(value) == (size_t *)((void *)0)) , (((size_t)-1 / 10 < (value) || (size_t)((value) * 10 + (*fieldstr - '0')) < (value)) ? 0 : (((value) = (value) * 10 + (*fieldstr - '0')) , 1)))) {
                size_t len = strspn(num_start, "0123456789");
                char *bad_num = xstrndup(num_start, len);
                if (operating_mode == byte_mode)
                    error(0, 0, gettext("byte offset %s is too large"), quote(bad_num));
                else
                    error(0, 0, gettext("field number %s is too large"), quote(bad_num));
                free(bad_num);
                exit(1);
            }
            fieldstr++;
        } else
            do {
                error(0, 0, (gettext("invalid byte or field list")));
                usage(1);
            } while (0);
    }


BasicTester, a patch instance with id 115:
Spawn 1 instances, now Total 156
Counter: 157
Batcher Size:46
Preprocess the following candidate with BasicTester:
Priority 7465
At location src/cut.c:363
--Src File: src/cut.c
Fragment 0:
max_range_endpoint = (rp)[i].hi;
while (1)
    {
        if (*fieldstr == '-') {
            in_digits = 0;
            if (dash_found)
                do {
                    error(0, 0, (gettext("invalid byte or field list")));
                    usage(1);
                } while (0);
            dash_found = 1;
            fieldstr++;
            initial = (lhs_specified ? value : 1);
            value = 0;
        } else if (*fieldstr == ',' || ((*__ctype_b_loc())[(int)((to_uchar(*fieldstr)))] & (unsigned short)_ISblank) || *fieldstr == '\x00') {
            in_digits = 0;
            if (dash_found) {
                dash_found = 0;
                if (!lhs_specified && !rhs_specified)
                    do {
                        error(0, 0, (gettext("invalid range with no endpoint: -")));
                        usage(1);
                    } while (0);
                if (!rhs_specified) {
                    eol_range_start = initial;
                    field_found = 1;
                } else {
                    if (value < initial)
                        do {
                            error(0, 0, (gettext("invalid decreasing range")));
                            usage(1);
                        } while (0);
                    if (eol_range_start != 0) {
                        if (initial < eol_range_start) {
                            if (eol_range_start <= value) {
                                eol_range_start = initial;
                            } else {
                                do {
                                    if (initial == 0 || value == 0)
                                        do {
                                            error(0, 0, (gettext("fields and positions are numbered from 1")));
                                            usage(1);
                                        } while (0);
                                    if (n_rp >= n_rp_allocated) {
                                        (rp) = x2nrealloc(rp, &n_rp_allocated, sizeof *(rp));
                                    }
                                    rp[n_rp].lo = (initial);
                                    rp[n_rp].hi = (value);
                                    ++n_rp;
                                } while (0);
                            }
                            field_found = 1;
                        }
                    } else {
                        do {
                            if (initial == 0 || value == 0)
                                do {
                                    error(0, 0, (gettext("fields and positions are numbered from 1")));
                                    usage(1);
                                } while (0);
                            if (n_rp >= n_rp_allocated) {
                                (rp) = x2nrealloc(rp, &n_rp_allocated, sizeof *(rp));
                            }
                            rp[n_rp].lo = (initial);
                            rp[n_rp].hi = (value);
                            ++n_rp;
                        } while (0);
                        field_found = 1;
                    }
                    value = 0;
                }
            } else {
                do {
                    if (value == 0 || value == 0)
                        do {
                            error(0, 0, (gettext("fields and positions are numbered from 1")));
                            usage(1);
                        } while (0);
                    if (n_rp >= n_rp_allocated) {
                        (rp) = x2nrealloc(rp, &n_rp_allocated, sizeof *(rp));
                    }
                    rp[n_rp].lo = (value);
                    rp[n_rp].hi = (value);
                    ++n_rp;
                } while (0);
                value = 0;
                field_found = 1;
            }
            if (*fieldstr == '\x00') {
                break;
            }
            fieldstr++;
            lhs_specified = 0;
            rhs_specified = 0;
        } else if (((unsigned int)(*fieldstr) - '0' <= 9)) {
            static const char *num_start;
            if (!in_digits || !num_start)
                num_start = fieldstr;
            in_digits = 1;
            if (dash_found)
                rhs_specified = 1;
            else
                lhs_specified = 1;
            if (!((void)(&(value) == (size_t *)((void *)0)) , (((size_t)-1 / 10 < (value) || (size_t)((value) * 10 + (*fieldstr - '0')) < (value)) ? 0 : (((value) = (value) * 10 + (*fieldstr - '0')) , 1)))) {
                size_t len = strspn(num_start, "0123456789");
                char *bad_num = xstrndup(num_start, len);
                if (operating_mode == byte_mode)
                    error(0, 0, gettext("byte offset %s is too large"), quote(bad_num));
                else
                    error(0, 0, gettext("field number %s is too large"), quote(bad_num));
                free(bad_num);
                exit(1);
            }
            fieldstr++;
        } else
            do {
                error(0, 0, (gettext("invalid byte or field list")));
                usage(1);
            } while (0);
    }


BasicTester, a patch instance with id 116:
Spawn 1 instances, now Total 157
Counter: 158
Batcher Size:47
Preprocess the following candidate with BasicTester:
Priority 7465
At location src/cut.c:363
--Src File: src/cut.c
Fragment 0:
initial = (value);
while (1)
    {
        if (*fieldstr == '-') {
            in_digits = 0;
            if (dash_found)
                do {
                    error(0, 0, (gettext("invalid byte or field list")));
                    usage(1);
                } while (0);
            dash_found = 1;
            fieldstr++;
            initial = (lhs_specified ? value : 1);
            value = 0;
        } else if (*fieldstr == ',' || ((*__ctype_b_loc())[(int)((to_uchar(*fieldstr)))] & (unsigned short)_ISblank) || *fieldstr == '\x00') {
            in_digits = 0;
            if (dash_found) {
                dash_found = 0;
                if (!lhs_specified && !rhs_specified)
                    do {
                        error(0, 0, (gettext("invalid range with no endpoint: -")));
                        usage(1);
                    } while (0);
                if (!rhs_specified) {
                    eol_range_start = initial;
                    field_found = 1;
                } else {
                    if (value < initial)
                        do {
                            error(0, 0, (gettext("invalid decreasing range")));
                            usage(1);
                        } while (0);
                    if (eol_range_start != 0) {
                        if (initial < eol_range_start) {
                            if (eol_range_start <= value) {
                                eol_range_start = initial;
                            } else {
                                do {
                                    if (initial == 0 || value == 0)
                                        do {
                                            error(0, 0, (gettext("fields and positions are numbered from 1")));
                                            usage(1);
                                        } while (0);
                                    if (n_rp >= n_rp_allocated) {
                                        (rp) = x2nrealloc(rp, &n_rp_allocated, sizeof *(rp));
                                    }
                                    rp[n_rp].lo = (initial);
                                    rp[n_rp].hi = (value);
                                    ++n_rp;
                                } while (0);
                            }
                            field_found = 1;
                        }
                    } else {
                        do {
                            if (initial == 0 || value == 0)
                                do {
                                    error(0, 0, (gettext("fields and positions are numbered from 1")));
                                    usage(1);
                                } while (0);
                            if (n_rp >= n_rp_allocated) {
                                (rp) = x2nrealloc(rp, &n_rp_allocated, sizeof *(rp));
                            }
                            rp[n_rp].lo = (initial);
                            rp[n_rp].hi = (value);
                            ++n_rp;
                        } while (0);
                        field_found = 1;
                    }
                    value = 0;
                }
            } else {
                do {
                    if (value == 0 || value == 0)
                        do {
                            error(0, 0, (gettext("fields and positions are numbered from 1")));
                            usage(1);
                        } while (0);
                    if (n_rp >= n_rp_allocated) {
                        (rp) = x2nrealloc(rp, &n_rp_allocated, sizeof *(rp));
                    }
                    rp[n_rp].lo = (value);
                    rp[n_rp].hi = (value);
                    ++n_rp;
                } while (0);
                value = 0;
                field_found = 1;
            }
            if (*fieldstr == '\x00') {
                break;
            }
            fieldstr++;
            lhs_specified = 0;
            rhs_specified = 0;
        } else if (((unsigned int)(*fieldstr) - '0' <= 9)) {
            static const char *num_start;
            if (!in_digits || !num_start)
                num_start = fieldstr;
            in_digits = 1;
            if (dash_found)
                rhs_specified = 1;
            else
                lhs_specified = 1;
            if (!((void)(&(value) == (size_t *)((void *)0)) , (((size_t)-1 / 10 < (value) || (size_t)((value) * 10 + (*fieldstr - '0')) < (value)) ? 0 : (((value) = (value) * 10 + (*fieldstr - '0')) , 1)))) {
                size_t len = strspn(num_start, "0123456789");
                char *bad_num = xstrndup(num_start, len);
                if (operating_mode == byte_mode)
                    error(0, 0, gettext("byte offset %s is too large"), quote(bad_num));
                else
                    error(0, 0, gettext("field number %s is too large"), quote(bad_num));
                free(bad_num);
                exit(1);
            }
            fieldstr++;
        } else
            do {
                error(0, 0, (gettext("invalid byte or field list")));
                usage(1);
            } while (0);
    }


BasicTester, a patch instance with id 117:
Spawn 1 instances, now Total 158
Counter: 159
Batcher Size:48
Preprocess the following candidate with BasicTester:
Priority 7465
At location src/cut.c:363
--Src File: src/cut.c
Fragment 0:
mark_range_start(eol_range_start);
while (1)
    {
        if (*fieldstr == '-') {
            in_digits = 0;
            if (dash_found)
                do {
                    error(0, 0, (gettext("invalid byte or field list")));
                    usage(1);
                } while (0);
            dash_found = 1;
            fieldstr++;
            initial = (lhs_specified ? value : 1);
            value = 0;
        } else if (*fieldstr == ',' || ((*__ctype_b_loc())[(int)((to_uchar(*fieldstr)))] & (unsigned short)_ISblank) || *fieldstr == '\x00') {
            in_digits = 0;
            if (dash_found) {
                dash_found = 0;
                if (!lhs_specified && !rhs_specified)
                    do {
                        error(0, 0, (gettext("invalid range with no endpoint: -")));
                        usage(1);
                    } while (0);
                if (!rhs_specified) {
                    eol_range_start = initial;
                    field_found = 1;
                } else {
                    if (value < initial)
                        do {
                            error(0, 0, (gettext("invalid decreasing range")));
                            usage(1);
                        } while (0);
                    if (eol_range_start != 0) {
                        if (initial < eol_range_start) {
                            if (eol_range_start <= value) {
                                eol_range_start = initial;
                            } else {
                                do {
                                    if (initial == 0 || value == 0)
                                        do {
                                            error(0, 0, (gettext("fields and positions are numbered from 1")));
                                            usage(1);
                                        } while (0);
                                    if (n_rp >= n_rp_allocated) {
                                        (rp) = x2nrealloc(rp, &n_rp_allocated, sizeof *(rp));
                                    }
                                    rp[n_rp].lo = (initial);
                                    rp[n_rp].hi = (value);
                                    ++n_rp;
                                } while (0);
                            }
                            field_found = 1;
                        }
                    } else {
                        do {
                            if (initial == 0 || value == 0)
                                do {
                                    error(0, 0, (gettext("fields and positions are numbered from 1")));
                                    usage(1);
                                } while (0);
                            if (n_rp >= n_rp_allocated) {
                                (rp) = x2nrealloc(rp, &n_rp_allocated, sizeof *(rp));
                            }
                            rp[n_rp].lo = (initial);
                            rp[n_rp].hi = (value);
                            ++n_rp;
                        } while (0);
                        field_found = 1;
                    }
                    value = 0;
                }
            } else {
                do {
                    if (value == 0 || value == 0)
                        do {
                            error(0, 0, (gettext("fields and positions are numbered from 1")));
                            usage(1);
                        } while (0);
                    if (n_rp >= n_rp_allocated) {
                        (rp) = x2nrealloc(rp, &n_rp_allocated, sizeof *(rp));
                    }
                    rp[n_rp].lo = (value);
                    rp[n_rp].hi = (value);
                    ++n_rp;
                } while (0);
                value = 0;
                field_found = 1;
            }
            if (*fieldstr == '\x00') {
                break;
            }
            fieldstr++;
            lhs_specified = 0;
            rhs_specified = 0;
        } else if (((unsigned int)(*fieldstr) - '0' <= 9)) {
            static const char *num_start;
            if (!in_digits || !num_start)
                num_start = fieldstr;
            in_digits = 1;
            if (dash_found)
                rhs_specified = 1;
            else
                lhs_specified = 1;
            if (!((void)(&(value) == (size_t *)((void *)0)) , (((size_t)-1 / 10 < (value) || (size_t)((value) * 10 + (*fieldstr - '0')) < (value)) ? 0 : (((value) = (value) * 10 + (*fieldstr - '0')) , 1)))) {
                size_t len = strspn(num_start, "0123456789");
                char *bad_num = xstrndup(num_start, len);
                if (operating_mode == byte_mode)
                    error(0, 0, gettext("byte offset %s is too large"), quote(bad_num));
                else
                    error(0, 0, gettext("field number %s is too large"), quote(bad_num));
                free(bad_num);
                exit(1);
            }
            fieldstr++;
        } else
            do {
                error(0, 0, (gettext("invalid byte or field list")));
                usage(1);
            } while (0);
    }


BasicTester, a patch instance with id 118:
Spawn 1 instances, now Total 159
Counter: 160
Batcher Size:49
Preprocess the following candidate with BasicTester:
Priority 7465
At location src/cut.c:363
--Src File: src/cut.c
Fragment 0:
max_range_endpoint = (10);
while (1)
    {
        if (*fieldstr == '-') {
            in_digits = 0;
            if (dash_found)
                do {
                    error(0, 0, (gettext("invalid byte or field list")));
                    usage(1);
                } while (0);
            dash_found = 1;
            fieldstr++;
            initial = (lhs_specified ? value : 1);
            value = 0;
        } else if (*fieldstr == ',' || ((*__ctype_b_loc())[(int)((to_uchar(*fieldstr)))] & (unsigned short)_ISblank) || *fieldstr == '\x00') {
            in_digits = 0;
            if (dash_found) {
                dash_found = 0;
                if (!lhs_specified && !rhs_specified)
                    do {
                        error(0, 0, (gettext("invalid range with no endpoint: -")));
                        usage(1);
                    } while (0);
                if (!rhs_specified) {
                    eol_range_start = initial;
                    field_found = 1;
                } else {
                    if (value < initial)
                        do {
                            error(0, 0, (gettext("invalid decreasing range")));
                            usage(1);
                        } while (0);
                    if (eol_range_start != 0) {
                        if (initial < eol_range_start) {
                            if (eol_range_start <= value) {
                                eol_range_start = initial;
                            } else {
                                do {
                                    if (initial == 0 || value == 0)
                                        do {
                                            error(0, 0, (gettext("fields and positions are numbered from 1")));
                                            usage(1);
                                        } while (0);
                                    if (n_rp >= n_rp_allocated) {
                                        (rp) = x2nrealloc(rp, &n_rp_allocated, sizeof *(rp));
                                    }
                                    rp[n_rp].lo = (initial);
                                    rp[n_rp].hi = (value);
                                    ++n_rp;
                                } while (0);
                            }
                            field_found = 1;
                        }
                    } else {
                        do {
                            if (initial == 0 || value == 0)
                                do {
                                    error(0, 0, (gettext("fields and positions are numbered from 1")));
                                    usage(1);
                                } while (0);
                            if (n_rp >= n_rp_allocated) {
                                (rp) = x2nrealloc(rp, &n_rp_allocated, sizeof *(rp));
                            }
                            rp[n_rp].lo = (initial);
                            rp[n_rp].hi = (value);
                            ++n_rp;
                        } while (0);
                        field_found = 1;
                    }
                    value = 0;
                }
            } else {
                do {
                    if (value == 0 || value == 0)
                        do {
                            error(0, 0, (gettext("fields and positions are numbered from 1")));
                            usage(1);
                        } while (0);
                    if (n_rp >= n_rp_allocated) {
                        (rp) = x2nrealloc(rp, &n_rp_allocated, sizeof *(rp));
                    }
                    rp[n_rp].lo = (value);
                    rp[n_rp].hi = (value);
                    ++n_rp;
                } while (0);
                value = 0;
                field_found = 1;
            }
            if (*fieldstr == '\x00') {
                break;
            }
            fieldstr++;
            lhs_specified = 0;
            rhs_specified = 0;
        } else if (((unsigned int)(*fieldstr) - '0' <= 9)) {
            static const char *num_start;
            if (!in_digits || !num_start)
                num_start = fieldstr;
            in_digits = 1;
            if (dash_found)
                rhs_specified = 1;
            else
                lhs_specified = 1;
            if (!((void)(&(value) == (size_t *)((void *)0)) , (((size_t)-1 / 10 < (value) || (size_t)((value) * 10 + (*fieldstr - '0')) < (value)) ? 0 : (((value) = (value) * 10 + (*fieldstr - '0')) , 1)))) {
                size_t len = strspn(num_start, "0123456789");
                char *bad_num = xstrndup(num_start, len);
                if (operating_mode == byte_mode)
                    error(0, 0, gettext("byte offset %s is too large"), quote(bad_num));
                else
                    error(0, 0, gettext("field number %s is too large"), quote(bad_num));
                free(bad_num);
                exit(1);
            }
            fieldstr++;
        } else
            do {
                error(0, 0, (gettext("invalid byte or field list")));
                usage(1);
            } while (0);
    }


BasicTester, a patch instance with id 119:
Spawn 1 instances, now Total 160
Counter: 161
Batcher Size:50
Preprocess the following candidate with BasicTester:
Priority 7465
At location src/cut.c:363
--Src File: src/cut.c
Fragment 0:
max_range_endpoint = (9);
while (1)
    {
        if (*fieldstr == '-') {
            in_digits = 0;
            if (dash_found)
                do {
                    error(0, 0, (gettext("invalid byte or field list")));
                    usage(1);
                } while (0);
            dash_found = 1;
            fieldstr++;
            initial = (lhs_specified ? value : 1);
            value = 0;
        } else if (*fieldstr == ',' || ((*__ctype_b_loc())[(int)((to_uchar(*fieldstr)))] & (unsigned short)_ISblank) || *fieldstr == '\x00') {
            in_digits = 0;
            if (dash_found) {
                dash_found = 0;
                if (!lhs_specified && !rhs_specified)
                    do {
                        error(0, 0, (gettext("invalid range with no endpoint: -")));
                        usage(1);
                    } while (0);
                if (!rhs_specified) {
                    eol_range_start = initial;
                    field_found = 1;
                } else {
                    if (value < initial)
                        do {
                            error(0, 0, (gettext("invalid decreasing range")));
                            usage(1);
                        } while (0);
                    if (eol_range_start != 0) {
                        if (initial < eol_range_start) {
                            if (eol_range_start <= value) {
                                eol_range_start = initial;
                            } else {
                                do {
                                    if (initial == 0 || value == 0)
                                        do {
                                            error(0, 0, (gettext("fields and positions are numbered from 1")));
                                            usage(1);
                                        } while (0);
                                    if (n_rp >= n_rp_allocated) {
                                        (rp) = x2nrealloc(rp, &n_rp_allocated, sizeof *(rp));
                                    }
                                    rp[n_rp].lo = (initial);
                                    rp[n_rp].hi = (value);
                                    ++n_rp;
                                } while (0);
                            }
                            field_found = 1;
                        }
                    } else {
                        do {
                            if (initial == 0 || value == 0)
                                do {
                                    error(0, 0, (gettext("fields and positions are numbered from 1")));
                                    usage(1);
                                } while (0);
                            if (n_rp >= n_rp_allocated) {
                                (rp) = x2nrealloc(rp, &n_rp_allocated, sizeof *(rp));
                            }
                            rp[n_rp].lo = (initial);
                            rp[n_rp].hi = (value);
                            ++n_rp;
                        } while (0);
                        field_found = 1;
                    }
                    value = 0;
                }
            } else {
                do {
                    if (value == 0 || value == 0)
                        do {
                            error(0, 0, (gettext("fields and positions are numbered from 1")));
                            usage(1);
                        } while (0);
                    if (n_rp >= n_rp_allocated) {
                        (rp) = x2nrealloc(rp, &n_rp_allocated, sizeof *(rp));
                    }
                    rp[n_rp].lo = (value);
                    rp[n_rp].hi = (value);
                    ++n_rp;
                } while (0);
                value = 0;
                field_found = 1;
            }
            if (*fieldstr == '\x00') {
                break;
            }
            fieldstr++;
            lhs_specified = 0;
            rhs_specified = 0;
        } else if (((unsigned int)(*fieldstr) - '0' <= 9)) {
            static const char *num_start;
            if (!in_digits || !num_start)
                num_start = fieldstr;
            in_digits = 1;
            if (dash_found)
                rhs_specified = 1;
            else
                lhs_specified = 1;
            if (!((void)(&(value) == (size_t *)((void *)0)) , (((size_t)-1 / 10 < (value) || (size_t)((value) * 10 + (*fieldstr - '0')) < (value)) ? 0 : (((value) = (value) * 10 + (*fieldstr - '0')) , 1)))) {
                size_t len = strspn(num_start, "0123456789");
                char *bad_num = xstrndup(num_start, len);
                if (operating_mode == byte_mode)
                    error(0, 0, gettext("byte offset %s is too large"), quote(bad_num));
                else
                    error(0, 0, gettext("field number %s is too large"), quote(bad_num));
                free(bad_num);
                exit(1);
            }
            fieldstr++;
        } else
            do {
                error(0, 0, (gettext("invalid byte or field list")));
                usage(1);
            } while (0);
    }


BasicTester, a patch instance with id 120:
Spawn 1 instances, now Total 161
Counter: 162
Batcher Size:51
Preprocess the following candidate with BasicTester:
Priority 7465
At location src/cut.c:363
--Src File: src/cut.c
Fragment 0:
max_range_endpoint = (i);
while (1)
    {
        if (*fieldstr == '-') {
            in_digits = 0;
            if (dash_found)
                do {
                    error(0, 0, (gettext("invalid byte or field list")));
                    usage(1);
                } while (0);
            dash_found = 1;
            fieldstr++;
            initial = (lhs_specified ? value : 1);
            value = 0;
        } else if (*fieldstr == ',' || ((*__ctype_b_loc())[(int)((to_uchar(*fieldstr)))] & (unsigned short)_ISblank) || *fieldstr == '\x00') {
            in_digits = 0;
            if (dash_found) {
                dash_found = 0;
                if (!lhs_specified && !rhs_specified)
                    do {
                        error(0, 0, (gettext("invalid range with no endpoint: -")));
                        usage(1);
                    } while (0);
                if (!rhs_specified) {
                    eol_range_start = initial;
                    field_found = 1;
                } else {
                    if (value < initial)
                        do {
                            error(0, 0, (gettext("invalid decreasing range")));
                            usage(1);
                        } while (0);
                    if (eol_range_start != 0) {
                        if (initial < eol_range_start) {
                            if (eol_range_start <= value) {
                                eol_range_start = initial;
                            } else {
                                do {
                                    if (initial == 0 || value == 0)
                                        do {
                                            error(0, 0, (gettext("fields and positions are numbered from 1")));
                                            usage(1);
                                        } while (0);
                                    if (n_rp >= n_rp_allocated) {
                                        (rp) = x2nrealloc(rp, &n_rp_allocated, sizeof *(rp));
                                    }
                                    rp[n_rp].lo = (initial);
                                    rp[n_rp].hi = (value);
                                    ++n_rp;
                                } while (0);
                            }
                            field_found = 1;
                        }
                    } else {
                        do {
                            if (initial == 0 || value == 0)
                                do {
                                    error(0, 0, (gettext("fields and positions are numbered from 1")));
                                    usage(1);
                                } while (0);
                            if (n_rp >= n_rp_allocated) {
                                (rp) = x2nrealloc(rp, &n_rp_allocated, sizeof *(rp));
                            }
                            rp[n_rp].lo = (initial);
                            rp[n_rp].hi = (value);
                            ++n_rp;
                        } while (0);
                        field_found = 1;
                    }
                    value = 0;
                }
            } else {
                do {
                    if (value == 0 || value == 0)
                        do {
                            error(0, 0, (gettext("fields and positions are numbered from 1")));
                            usage(1);
                        } while (0);
                    if (n_rp >= n_rp_allocated) {
                        (rp) = x2nrealloc(rp, &n_rp_allocated, sizeof *(rp));
                    }
                    rp[n_rp].lo = (value);
                    rp[n_rp].hi = (value);
                    ++n_rp;
                } while (0);
                value = 0;
                field_found = 1;
            }
            if (*fieldstr == '\x00') {
                break;
            }
            fieldstr++;
            lhs_specified = 0;
            rhs_specified = 0;
        } else if (((unsigned int)(*fieldstr) - '0' <= 9)) {
            static const char *num_start;
            if (!in_digits || !num_start)
                num_start = fieldstr;
            in_digits = 1;
            if (dash_found)
                rhs_specified = 1;
            else
                lhs_specified = 1;
            if (!((void)(&(value) == (size_t *)((void *)0)) , (((size_t)-1 / 10 < (value) || (size_t)((value) * 10 + (*fieldstr - '0')) < (value)) ? 0 : (((value) = (value) * 10 + (*fieldstr - '0')) , 1)))) {
                size_t len = strspn(num_start, "0123456789");
                char *bad_num = xstrndup(num_start, len);
                if (operating_mode == byte_mode)
                    error(0, 0, gettext("byte offset %s is too large"), quote(bad_num));
                else
                    error(0, 0, gettext("field number %s is too large"), quote(bad_num));
                free(bad_num);
                exit(1);
            }
            fieldstr++;
        } else
            do {
                error(0, 0, (gettext("invalid byte or field list")));
                usage(1);
            } while (0);
    }


BasicTester, a patch instance with id 121:
Spawn 1 instances, now Total 162
Counter: 163
Batcher Size:52
Preprocess the following candidate with BasicTester:
Priority 7465
At location src/cut.c:363
--Src File: src/cut.c
Fragment 0:
max_range_endpoint = (8);
while (1)
    {
        if (*fieldstr == '-') {
            in_digits = 0;
            if (dash_found)
                do {
                    error(0, 0, (gettext("invalid byte or field list")));
                    usage(1);
                } while (0);
            dash_found = 1;
            fieldstr++;
            initial = (lhs_specified ? value : 1);
            value = 0;
        } else if (*fieldstr == ',' || ((*__ctype_b_loc())[(int)((to_uchar(*fieldstr)))] & (unsigned short)_ISblank) || *fieldstr == '\x00') {
            in_digits = 0;
            if (dash_found) {
                dash_found = 0;
                if (!lhs_specified && !rhs_specified)
                    do {
                        error(0, 0, (gettext("invalid range with no endpoint: -")));
                        usage(1);
                    } while (0);
                if (!rhs_specified) {
                    eol_range_start = initial;
                    field_found = 1;
                } else {
                    if (value < initial)
                        do {
                            error(0, 0, (gettext("invalid decreasing range")));
                            usage(1);
                        } while (0);
                    if (eol_range_start != 0) {
                        if (initial < eol_range_start) {
                            if (eol_range_start <= value) {
                                eol_range_start = initial;
                            } else {
                                do {
                                    if (initial == 0 || value == 0)
                                        do {
                                            error(0, 0, (gettext("fields and positions are numbered from 1")));
                                            usage(1);
                                        } while (0);
                                    if (n_rp >= n_rp_allocated) {
                                        (rp) = x2nrealloc(rp, &n_rp_allocated, sizeof *(rp));
                                    }
                                    rp[n_rp].lo = (initial);
                                    rp[n_rp].hi = (value);
                                    ++n_rp;
                                } while (0);
                            }
                            field_found = 1;
                        }
                    } else {
                        do {
                            if (initial == 0 || value == 0)
                                do {
                                    error(0, 0, (gettext("fields and positions are numbered from 1")));
                                    usage(1);
                                } while (0);
                            if (n_rp >= n_rp_allocated) {
                                (rp) = x2nrealloc(rp, &n_rp_allocated, sizeof *(rp));
                            }
                            rp[n_rp].lo = (initial);
                            rp[n_rp].hi = (value);
                            ++n_rp;
                        } while (0);
                        field_found = 1;
                    }
                    value = 0;
                }
            } else {
                do {
                    if (value == 0 || value == 0)
                        do {
                            error(0, 0, (gettext("fields and positions are numbered from 1")));
                            usage(1);
                        } while (0);
                    if (n_rp >= n_rp_allocated) {
                        (rp) = x2nrealloc(rp, &n_rp_allocated, sizeof *(rp));
                    }
                    rp[n_rp].lo = (value);
                    rp[n_rp].hi = (value);
                    ++n_rp;
                } while (0);
                value = 0;
                field_found = 1;
            }
            if (*fieldstr == '\x00') {
                break;
            }
            fieldstr++;
            lhs_specified = 0;
            rhs_specified = 0;
        } else if (((unsigned int)(*fieldstr) - '0' <= 9)) {
            static const char *num_start;
            if (!in_digits || !num_start)
                num_start = fieldstr;
            in_digits = 1;
            if (dash_found)
                rhs_specified = 1;
            else
                lhs_specified = 1;
            if (!((void)(&(value) == (size_t *)((void *)0)) , (((size_t)-1 / 10 < (value) || (size_t)((value) * 10 + (*fieldstr - '0')) < (value)) ? 0 : (((value) = (value) * 10 + (*fieldstr - '0')) , 1)))) {
                size_t len = strspn(num_start, "0123456789");
                char *bad_num = xstrndup(num_start, len);
                if (operating_mode == byte_mode)
                    error(0, 0, gettext("byte offset %s is too large"), quote(bad_num));
                else
                    error(0, 0, gettext("field number %s is too large"), quote(bad_num));
                free(bad_num);
                exit(1);
            }
            fieldstr++;
        } else
            do {
                error(0, 0, (gettext("invalid byte or field list")));
                usage(1);
            } while (0);
    }


BasicTester, a patch instance with id 122:
Spawn 1 instances, now Total 163
a batched test job starts!
Building:src at:
/home/ubuntu/spr-fast/tests/corebench/coreutils/coreutils-case-7380cf79-2e636af1/tempworkdir/srcMerged code building succ, going to invoke tester!
BasicTester, Testing instance id 113:
Running test command:
/home/ubuntu/spr-fast/tools/coreutils-test.py /home/ubuntu/spr-fast/tests/corebench/coreutils/coreutils-case-7380cf79-2e636af1/tempworkdir/src /home/ubuntu/spr-fast/tests/corebench/coreutils/coreutils-case-7380cf79-2e636af1/tempworkdir/tests /home/ubuntu/spr-fast/tests/corebench/coreutils/coreutils-case-7380cf79-2e636af1/tempworkdir 0  > __res
BasicTester, Testing instance id 114:
Running test command:
/home/ubuntu/spr-fast/tools/coreutils-test.py /home/ubuntu/spr-fast/tests/corebench/coreutils/coreutils-case-7380cf79-2e636af1/tempworkdir/src /home/ubuntu/spr-fast/tests/corebench/coreutils/coreutils-case-7380cf79-2e636af1/tempworkdir/tests /home/ubuntu/spr-fast/tests/corebench/coreutils/coreutils-case-7380cf79-2e636af1/tempworkdir 0  > __res
BasicTester, Testing instance id 115:
Running test command:
/home/ubuntu/spr-fast/tools/coreutils-test.py /home/ubuntu/spr-fast/tests/corebench/coreutils/coreutils-case-7380cf79-2e636af1/tempworkdir/src /home/ubuntu/spr-fast/tests/corebench/coreutils/coreutils-case-7380cf79-2e636af1/tempworkdir/tests /home/ubuntu/spr-fast/tests/corebench/coreutils/coreutils-case-7380cf79-2e636af1/tempworkdir 0  > __res
BasicTester, Testing instance id 116:
Running test command:
/home/ubuntu/spr-fast/tools/coreutils-test.py /home/ubuntu/spr-fast/tests/corebench/coreutils/coreutils-case-7380cf79-2e636af1/tempworkdir/src /home/ubuntu/spr-fast/tests/corebench/coreutils/coreutils-case-7380cf79-2e636af1/tempworkdir/tests /home/ubuntu/spr-fast/tests/corebench/coreutils/coreutils-case-7380cf79-2e636af1/tempworkdir 0  > __res
BasicTester, Testing instance id 117:
Running test command:
/home/ubuntu/spr-fast/tools/coreutils-test.py /home/ubuntu/spr-fast/tests/corebench/coreutils/coreutils-case-7380cf79-2e636af1/tempworkdir/src /home/ubuntu/spr-fast/tests/corebench/coreutils/coreutils-case-7380cf79-2e636af1/tempworkdir/tests /home/ubuntu/spr-fast/tests/corebench/coreutils/coreutils-case-7380cf79-2e636af1/tempworkdir 0  > __res
BasicTester, Testing instance id 118:
Running test command:
/home/ubuntu/spr-fast/tools/coreutils-test.py /home/ubuntu/spr-fast/tests/corebench/coreutils/coreutils-case-7380cf79-2e636af1/tempworkdir/src /home/ubuntu/spr-fast/tests/corebench/coreutils/coreutils-case-7380cf79-2e636af1/tempworkdir/tests /home/ubuntu/spr-fast/tests/corebench/coreutils/coreutils-case-7380cf79-2e636af1/tempworkdir 0  > __res
BasicTester, Testing instance id 119:
Running test command:
/home/ubuntu/spr-fast/tools/coreutils-test.py /home/ubuntu/spr-fast/tests/corebench/coreutils/coreutils-case-7380cf79-2e636af1/tempworkdir/src /home/ubuntu/spr-fast/tests/corebench/coreutils/coreutils-case-7380cf79-2e636af1/tempworkdir/tests /home/ubuntu/spr-fast/tests/corebench/coreutils/coreutils-case-7380cf79-2e636af1/tempworkdir 0  > __res
BasicTester, Testing instance id 120:
Running test command:
/home/ubuntu/spr-fast/tools/coreutils-test.py /home/ubuntu/spr-fast/tests/corebench/coreutils/coreutils-case-7380cf79-2e636af1/tempworkdir/src /home/ubuntu/spr-fast/tests/corebench/coreutils/coreutils-case-7380cf79-2e636af1/tempworkdir/tests /home/ubuntu/spr-fast/tests/corebench/coreutils/coreutils-case-7380cf79-2e636af1/tempworkdir 0  > __res
BasicTester, Testing instance id 121:
Running test command:
/home/ubuntu/spr-fast/tools/coreutils-test.py /home/ubuntu/spr-fast/tests/corebench/coreutils/coreutils-case-7380cf79-2e636af1/tempworkdir/src /home/ubuntu/spr-fast/tests/corebench/coreutils/coreutils-case-7380cf79-2e636af1/tempworkdir/tests /home/ubuntu/spr-fast/tests/corebench/coreutils/coreutils-case-7380cf79-2e636af1/tempworkdir 0  > __res
BasicTester, Testing instance id 122:
Running test command:
/home/ubuntu/spr-fast/tools/coreutils-test.py /home/ubuntu/spr-fast/tests/corebench/coreutils/coreutils-case-7380cf79-2e636af1/tempworkdir/src /home/ubuntu/spr-fast/tests/corebench/coreutils/coreutils-case-7380cf79-2e636af1/tempworkdir/tests /home/ubuntu/spr-fast/tests/corebench/coreutils/coreutils-case-7380cf79-2e636af1/tempworkdir 0  > __res
Counter: 164
Batcher Size:43
Preprocess the following candidate with BasicTester:
Priority 7465
At location src/cut.c:363
--Src File: src/cut.c
Fragment 0:
max_range_endpoint = (-1);
while (1)
    {
        if (*fieldstr == '-') {
            in_digits = 0;
            if (dash_found)
                do {
                    error(0, 0, (gettext("invalid byte or field list")));
                    usage(1);
                } while (0);
            dash_found = 1;
            fieldstr++;
            initial = (lhs_specified ? value : 1);
            value = 0;
        } else if (*fieldstr == ',' || ((*__ctype_b_loc())[(int)((to_uchar(*fieldstr)))] & (unsigned short)_ISblank) || *fieldstr == '\x00') {
            in_digits = 0;
            if (dash_found) {
                dash_found = 0;
                if (!lhs_specified && !rhs_specified)
                    do {
                        error(0, 0, (gettext("invalid range with no endpoint: -")));
                        usage(1);
                    } while (0);
                if (!rhs_specified) {
                    eol_range_start = initial;
                    field_found = 1;
                } else {
                    if (value < initial)
                        do {
                            error(0, 0, (gettext("invalid decreasing range")));
                            usage(1);
                        } while (0);
                    if (eol_range_start != 0) {
                        if (initial < eol_range_start) {
                            if (eol_range_start <= value) {
                                eol_range_start = initial;
                            } else {
                                do {
                                    if (initial == 0 || value == 0)
                                        do {
                                            error(0, 0, (gettext("fields and positions are numbered from 1")));
                                            usage(1);
                                        } while (0);
                                    if (n_rp >= n_rp_allocated) {
                                        (rp) = x2nrealloc(rp, &n_rp_allocated, sizeof *(rp));
                                    }
                                    rp[n_rp].lo = (initial);
                                    rp[n_rp].hi = (value);
                                    ++n_rp;
                                } while (0);
                            }
                            field_found = 1;
                        }
                    } else {
                        do {
                            if (initial == 0 || value == 0)
                                do {
                                    error(0, 0, (gettext("fields and positions are numbered from 1")));
                                    usage(1);
                                } while (0);
                            if (n_rp >= n_rp_allocated) {
                                (rp) = x2nrealloc(rp, &n_rp_allocated, sizeof *(rp));
                            }
                            rp[n_rp].lo = (initial);
                            rp[n_rp].hi = (value);
                            ++n_rp;
                        } while (0);
                        field_found = 1;
                    }
                    value = 0;
                }
            } else {
                do {
                    if (value == 0 || value == 0)
                        do {
                            error(0, 0, (gettext("fields and positions are numbered from 1")));
                            usage(1);
                        } while (0);
                    if (n_rp >= n_rp_allocated) {
                        (rp) = x2nrealloc(rp, &n_rp_allocated, sizeof *(rp));
                    }
                    rp[n_rp].lo = (value);
                    rp[n_rp].hi = (value);
                    ++n_rp;
                } while (0);
                value = 0;
                field_found = 1;
            }
            if (*fieldstr == '\x00') {
                break;
            }
            fieldstr++;
            lhs_specified = 0;
            rhs_specified = 0;
        } else if (((unsigned int)(*fieldstr) - '0' <= 9)) {
            static const char *num_start;
            if (!in_digits || !num_start)
                num_start = fieldstr;
            in_digits = 1;
            if (dash_found)
                rhs_specified = 1;
            else
                lhs_specified = 1;
            if (!((void)(&(value) == (size_t *)((void *)0)) , (((size_t)-1 / 10 < (value) || (size_t)((value) * 10 + (*fieldstr - '0')) < (value)) ? 0 : (((value) = (value) * 10 + (*fieldstr - '0')) , 1)))) {
                size_t len = strspn(num_start, "0123456789");
                char *bad_num = xstrndup(num_start, len);
                if (operating_mode == byte_mode)
                    error(0, 0, gettext("byte offset %s is too large"), quote(bad_num));
                else
                    error(0, 0, gettext("field number %s is too large"), quote(bad_num));
                free(bad_num);
                exit(1);
            }
            fieldstr++;
        } else
            do {
                error(0, 0, (gettext("invalid byte or field list")));
                usage(1);
            } while (0);
    }


BasicTester, a patch instance with id 123:
Spawn 1 instances, now Total 164
Counter: 165
Batcher Size:44
Preprocess the following candidate with BasicTester:
Priority 7465
At location src/cut.c:363
--Src File: src/cut.c
Fragment 0:
max_range_endpoint = (0);
while (1)
    {
        if (*fieldstr == '-') {
            in_digits = 0;
            if (dash_found)
                do {
                    error(0, 0, (gettext("invalid byte or field list")));
                    usage(1);
                } while (0);
            dash_found = 1;
            fieldstr++;
            initial = (lhs_specified ? value : 1);
            value = 0;
        } else if (*fieldstr == ',' || ((*__ctype_b_loc())[(int)((to_uchar(*fieldstr)))] & (unsigned short)_ISblank) || *fieldstr == '\x00') {
            in_digits = 0;
            if (dash_found) {
                dash_found = 0;
                if (!lhs_specified && !rhs_specified)
                    do {
                        error(0, 0, (gettext("invalid range with no endpoint: -")));
                        usage(1);
                    } while (0);
                if (!rhs_specified) {
                    eol_range_start = initial;
                    field_found = 1;
                } else {
                    if (value < initial)
                        do {
                            error(0, 0, (gettext("invalid decreasing range")));
                            usage(1);
                        } while (0);
                    if (eol_range_start != 0) {
                        if (initial < eol_range_start) {
                            if (eol_range_start <= value) {
                                eol_range_start = initial;
                            } else {
                                do {
                                    if (initial == 0 || value == 0)
                                        do {
                                            error(0, 0, (gettext("fields and positions are numbered from 1")));
                                            usage(1);
                                        } while (0);
                                    if (n_rp >= n_rp_allocated) {
                                        (rp) = x2nrealloc(rp, &n_rp_allocated, sizeof *(rp));
                                    }
                                    rp[n_rp].lo = (initial);
                                    rp[n_rp].hi = (value);
                                    ++n_rp;
                                } while (0);
                            }
                            field_found = 1;
                        }
                    } else {
                        do {
                            if (initial == 0 || value == 0)
                                do {
                                    error(0, 0, (gettext("fields and positions are numbered from 1")));
                                    usage(1);
                                } while (0);
                            if (n_rp >= n_rp_allocated) {
                                (rp) = x2nrealloc(rp, &n_rp_allocated, sizeof *(rp));
                            }
                            rp[n_rp].lo = (initial);
                            rp[n_rp].hi = (value);
                            ++n_rp;
                        } while (0);
                        field_found = 1;
                    }
                    value = 0;
                }
            } else {
                do {
                    if (value == 0 || value == 0)
                        do {
                            error(0, 0, (gettext("fields and positions are numbered from 1")));
                            usage(1);
                        } while (0);
                    if (n_rp >= n_rp_allocated) {
                        (rp) = x2nrealloc(rp, &n_rp_allocated, sizeof *(rp));
                    }
                    rp[n_rp].lo = (value);
                    rp[n_rp].hi = (value);
                    ++n_rp;
                } while (0);
                value = 0;
                field_found = 1;
            }
            if (*fieldstr == '\x00') {
                break;
            }
            fieldstr++;
            lhs_specified = 0;
            rhs_specified = 0;
        } else if (((unsigned int)(*fieldstr) - '0' <= 9)) {
            static const char *num_start;
            if (!in_digits || !num_start)
                num_start = fieldstr;
            in_digits = 1;
            if (dash_found)
                rhs_specified = 1;
            else
                lhs_specified = 1;
            if (!((void)(&(value) == (size_t *)((void *)0)) , (((size_t)-1 / 10 < (value) || (size_t)((value) * 10 + (*fieldstr - '0')) < (value)) ? 0 : (((value) = (value) * 10 + (*fieldstr - '0')) , 1)))) {
                size_t len = strspn(num_start, "0123456789");
                char *bad_num = xstrndup(num_start, len);
                if (operating_mode == byte_mode)
                    error(0, 0, gettext("byte offset %s is too large"), quote(bad_num));
                else
                    error(0, 0, gettext("field number %s is too large"), quote(bad_num));
                free(bad_num);
                exit(1);
            }
            fieldstr++;
        } else
            do {
                error(0, 0, (gettext("invalid byte or field list")));
                usage(1);
            } while (0);
    }


BasicTester, a patch instance with id 124:
Spawn 1 instances, now Total 165
Counter: 166
Batcher Size:45
Preprocess the following candidate with BasicTester:
Priority 7465
At location src/cut.c:363
--Src File: src/cut.c
Fragment 0:
max_range_endpoint = (1);
while (1)
    {
        if (*fieldstr == '-') {
            in_digits = 0;
            if (dash_found)
                do {
                    error(0, 0, (gettext("invalid byte or field list")));
                    usage(1);
                } while (0);
            dash_found = 1;
            fieldstr++;
            initial = (lhs_specified ? value : 1);
            value = 0;
        } else if (*fieldstr == ',' || ((*__ctype_b_loc())[(int)((to_uchar(*fieldstr)))] & (unsigned short)_ISblank) || *fieldstr == '\x00') {
            in_digits = 0;
            if (dash_found) {
                dash_found = 0;
                if (!lhs_specified && !rhs_specified)
                    do {
                        error(0, 0, (gettext("invalid range with no endpoint: -")));
                        usage(1);
                    } while (0);
                if (!rhs_specified) {
                    eol_range_start = initial;
                    field_found = 1;
                } else {
                    if (value < initial)
                        do {
                            error(0, 0, (gettext("invalid decreasing range")));
                            usage(1);
                        } while (0);
                    if (eol_range_start != 0) {
                        if (initial < eol_range_start) {
                            if (eol_range_start <= value) {
                                eol_range_start = initial;
                            } else {
                                do {
                                    if (initial == 0 || value == 0)
                                        do {
                                            error(0, 0, (gettext("fields and positions are numbered from 1")));
                                            usage(1);
                                        } while (0);
                                    if (n_rp >= n_rp_allocated) {
                                        (rp) = x2nrealloc(rp, &n_rp_allocated, sizeof *(rp));
                                    }
                                    rp[n_rp].lo = (initial);
                                    rp[n_rp].hi = (value);
                                    ++n_rp;
                                } while (0);
                            }
                            field_found = 1;
                        }
                    } else {
                        do {
                            if (initial == 0 || value == 0)
                                do {
                                    error(0, 0, (gettext("fields and positions are numbered from 1")));
                                    usage(1);
                                } while (0);
                            if (n_rp >= n_rp_allocated) {
                                (rp) = x2nrealloc(rp, &n_rp_allocated, sizeof *(rp));
                            }
                            rp[n_rp].lo = (initial);
                            rp[n_rp].hi = (value);
                            ++n_rp;
                        } while (0);
                        field_found = 1;
                    }
                    value = 0;
                }
            } else {
                do {
                    if (value == 0 || value == 0)
                        do {
                            error(0, 0, (gettext("fields and positions are numbered from 1")));
                            usage(1);
                        } while (0);
                    if (n_rp >= n_rp_allocated) {
                        (rp) = x2nrealloc(rp, &n_rp_allocated, sizeof *(rp));
                    }
                    rp[n_rp].lo = (value);
                    rp[n_rp].hi = (value);
                    ++n_rp;
                } while (0);
                value = 0;
                field_found = 1;
            }
            if (*fieldstr == '\x00') {
                break;
            }
            fieldstr++;
            lhs_specified = 0;
            rhs_specified = 0;
        } else if (((unsigned int)(*fieldstr) - '0' <= 9)) {
            static const char *num_start;
            if (!in_digits || !num_start)
                num_start = fieldstr;
            in_digits = 1;
            if (dash_found)
                rhs_specified = 1;
            else
                lhs_specified = 1;
            if (!((void)(&(value) == (size_t *)((void *)0)) , (((size_t)-1 / 10 < (value) || (size_t)((value) * 10 + (*fieldstr - '0')) < (value)) ? 0 : (((value) = (value) * 10 + (*fieldstr - '0')) , 1)))) {
                size_t len = strspn(num_start, "0123456789");
                char *bad_num = xstrndup(num_start, len);
                if (operating_mode == byte_mode)
                    error(0, 0, gettext("byte offset %s is too large"), quote(bad_num));
                else
                    error(0, 0, gettext("field number %s is too large"), quote(bad_num));
                free(bad_num);
                exit(1);
            }
            fieldstr++;
        } else
            do {
                error(0, 0, (gettext("invalid byte or field list")));
                usage(1);
            } while (0);
    }


BasicTester, a patch instance with id 125:
Spawn 1 instances, now Total 166
Counter: 167
Batcher Size:46
Preprocess the following candidate with BasicTester:
Priority 7465
At location src/cut.c:363
--Src File: src/cut.c
Fragment 0:
lhs_specified = (dash_found);
while (1)
    {
        if (*fieldstr == '-') {
            in_digits = 0;
            if (dash_found)
                do {
                    error(0, 0, (gettext("invalid byte or field list")));
                    usage(1);
                } while (0);
            dash_found = 1;
            fieldstr++;
            initial = (lhs_specified ? value : 1);
            value = 0;
        } else if (*fieldstr == ',' || ((*__ctype_b_loc())[(int)((to_uchar(*fieldstr)))] & (unsigned short)_ISblank) || *fieldstr == '\x00') {
            in_digits = 0;
            if (dash_found) {
                dash_found = 0;
                if (!lhs_specified && !rhs_specified)
                    do {
                        error(0, 0, (gettext("invalid range with no endpoint: -")));
                        usage(1);
                    } while (0);
                if (!rhs_specified) {
                    eol_range_start = initial;
                    field_found = 1;
                } else {
                    if (value < initial)
                        do {
                            error(0, 0, (gettext("invalid decreasing range")));
                            usage(1);
                        } while (0);
                    if (eol_range_start != 0) {
                        if (initial < eol_range_start) {
                            if (eol_range_start <= value) {
                                eol_range_start = initial;
                            } else {
                                do {
                                    if (initial == 0 || value == 0)
                                        do {
                                            error(0, 0, (gettext("fields and positions are numbered from 1")));
                                            usage(1);
                                        } while (0);
                                    if (n_rp >= n_rp_allocated) {
                                        (rp) = x2nrealloc(rp, &n_rp_allocated, sizeof *(rp));
                                    }
                                    rp[n_rp].lo = (initial);
                                    rp[n_rp].hi = (value);
                                    ++n_rp;
                                } while (0);
                            }
                            field_found = 1;
                        }
                    } else {
                        do {
                            if (initial == 0 || value == 0)
                                do {
                                    error(0, 0, (gettext("fields and positions are numbered from 1")));
                                    usage(1);
                                } while (0);
                            if (n_rp >= n_rp_allocated) {
                                (rp) = x2nrealloc(rp, &n_rp_allocated, sizeof *(rp));
                            }
                            rp[n_rp].lo = (initial);
                            rp[n_rp].hi = (value);
                            ++n_rp;
                        } while (0);
                        field_found = 1;
                    }
                    value = 0;
                }
            } else {
                do {
                    if (value == 0 || value == 0)
                        do {
                            error(0, 0, (gettext("fields and positions are numbered from 1")));
                            usage(1);
                        } while (0);
                    if (n_rp >= n_rp_allocated) {
                        (rp) = x2nrealloc(rp, &n_rp_allocated, sizeof *(rp));
                    }
                    rp[n_rp].lo = (value);
                    rp[n_rp].hi = (value);
                    ++n_rp;
                } while (0);
                value = 0;
                field_found = 1;
            }
            if (*fieldstr == '\x00') {
                break;
            }
            fieldstr++;
            lhs_specified = 0;
            rhs_specified = 0;
        } else if (((unsigned int)(*fieldstr) - '0' <= 9)) {
            static const char *num_start;
            if (!in_digits || !num_start)
                num_start = fieldstr;
            in_digits = 1;
            if (dash_found)
                rhs_specified = 1;
            else
                lhs_specified = 1;
            if (!((void)(&(value) == (size_t *)((void *)0)) , (((size_t)-1 / 10 < (value) || (size_t)((value) * 10 + (*fieldstr - '0')) < (value)) ? 0 : (((value) = (value) * 10 + (*fieldstr - '0')) , 1)))) {
                size_t len = strspn(num_start, "0123456789");
                char *bad_num = xstrndup(num_start, len);
                if (operating_mode == byte_mode)
                    error(0, 0, gettext("byte offset %s is too large"), quote(bad_num));
                else
                    error(0, 0, gettext("field number %s is too large"), quote(bad_num));
                free(bad_num);
                exit(1);
            }
            fieldstr++;
        } else
            do {
                error(0, 0, (gettext("invalid byte or field list")));
                usage(1);
            } while (0);
    }


BasicTester, a patch instance with id 126:
Spawn 1 instances, now Total 167
Counter: 168
Batcher Size:47
Preprocess the following candidate with BasicTester:
Priority 7465
At location src/cut.c:363
--Src File: src/cut.c
Fragment 0:
lhs_specified = (lhs_specified);
while (1)
    {
        if (*fieldstr == '-') {
            in_digits = 0;
            if (dash_found)
                do {
                    error(0, 0, (gettext("invalid byte or field list")));
                    usage(1);
                } while (0);
            dash_found = 1;
            fieldstr++;
            initial = (lhs_specified ? value : 1);
            value = 0;
        } else if (*fieldstr == ',' || ((*__ctype_b_loc())[(int)((to_uchar(*fieldstr)))] & (unsigned short)_ISblank) || *fieldstr == '\x00') {
            in_digits = 0;
            if (dash_found) {
                dash_found = 0;
                if (!lhs_specified && !rhs_specified)
                    do {
                        error(0, 0, (gettext("invalid range with no endpoint: -")));
                        usage(1);
                    } while (0);
                if (!rhs_specified) {
                    eol_range_start = initial;
                    field_found = 1;
                } else {
                    if (value < initial)
                        do {
                            error(0, 0, (gettext("invalid decreasing range")));
                            usage(1);
                        } while (0);
                    if (eol_range_start != 0) {
                        if (initial < eol_range_start) {
                            if (eol_range_start <= value) {
                                eol_range_start = initial;
                            } else {
                                do {
                                    if (initial == 0 || value == 0)
                                        do {
                                            error(0, 0, (gettext("fields and positions are numbered from 1")));
                                            usage(1);
                                        } while (0);
                                    if (n_rp >= n_rp_allocated) {
                                        (rp) = x2nrealloc(rp, &n_rp_allocated, sizeof *(rp));
                                    }
                                    rp[n_rp].lo = (initial);
                                    rp[n_rp].hi = (value);
                                    ++n_rp;
                                } while (0);
                            }
                            field_found = 1;
                        }
                    } else {
                        do {
                            if (initial == 0 || value == 0)
                                do {
                                    error(0, 0, (gettext("fields and positions are numbered from 1")));
                                    usage(1);
                                } while (0);
                            if (n_rp >= n_rp_allocated) {
                                (rp) = x2nrealloc(rp, &n_rp_allocated, sizeof *(rp));
                            }
                            rp[n_rp].lo = (initial);
                            rp[n_rp].hi = (value);
                            ++n_rp;
                        } while (0);
                        field_found = 1;
                    }
                    value = 0;
                }
            } else {
                do {
                    if (value == 0 || value == 0)
                        do {
                            error(0, 0, (gettext("fields and positions are numbered from 1")));
                            usage(1);
                        } while (0);
                    if (n_rp >= n_rp_allocated) {
                        (rp) = x2nrealloc(rp, &n_rp_allocated, sizeof *(rp));
                    }
                    rp[n_rp].lo = (value);
                    rp[n_rp].hi = (value);
                    ++n_rp;
                } while (0);
                value = 0;
                field_found = 1;
            }
            if (*fieldstr == '\x00') {
                break;
            }
            fieldstr++;
            lhs_specified = 0;
            rhs_specified = 0;
        } else if (((unsigned int)(*fieldstr) - '0' <= 9)) {
            static const char *num_start;
            if (!in_digits || !num_start)
                num_start = fieldstr;
            in_digits = 1;
            if (dash_found)
                rhs_specified = 1;
            else
                lhs_specified = 1;
            if (!((void)(&(value) == (size_t *)((void *)0)) , (((size_t)-1 / 10 < (value) || (size_t)((value) * 10 + (*fieldstr - '0')) < (value)) ? 0 : (((value) = (value) * 10 + (*fieldstr - '0')) , 1)))) {
                size_t len = strspn(num_start, "0123456789");
                char *bad_num = xstrndup(num_start, len);
                if (operating_mode == byte_mode)
                    error(0, 0, gettext("byte offset %s is too large"), quote(bad_num));
                else
                    error(0, 0, gettext("field number %s is too large"), quote(bad_num));
                free(bad_num);
                exit(1);
            }
            fieldstr++;
        } else
            do {
                error(0, 0, (gettext("invalid byte or field list")));
                usage(1);
            } while (0);
    }


BasicTester, a patch instance with id 127:
Spawn 1 instances, now Total 168
Counter: 169
Batcher Size:48
Preprocess the following candidate with BasicTester:
Priority 7465
At location src/cut.c:363
--Src File: src/cut.c
Fragment 0:
lhs_specified = 0;
while (1)
    {
        if (*fieldstr == '-') {
            in_digits = 0;
            if (dash_found)
                do {
                    error(0, 0, (gettext("invalid byte or field list")));
                    usage(1);
                } while (0);
            dash_found = 1;
            fieldstr++;
            initial = (lhs_specified ? value : 1);
            value = 0;
        } else if (*fieldstr == ',' || ((*__ctype_b_loc())[(int)((to_uchar(*fieldstr)))] & (unsigned short)_ISblank) || *fieldstr == '\x00') {
            in_digits = 0;
            if (dash_found) {
                dash_found = 0;
                if (!lhs_specified && !rhs_specified)
                    do {
                        error(0, 0, (gettext("invalid range with no endpoint: -")));
                        usage(1);
                    } while (0);
                if (!rhs_specified) {
                    eol_range_start = initial;
                    field_found = 1;
                } else {
                    if (value < initial)
                        do {
                            error(0, 0, (gettext("invalid decreasing range")));
                            usage(1);
                        } while (0);
                    if (eol_range_start != 0) {
                        if (initial < eol_range_start) {
                            if (eol_range_start <= value) {
                                eol_range_start = initial;
                            } else {
                                do {
                                    if (initial == 0 || value == 0)
                                        do {
                                            error(0, 0, (gettext("fields and positions are numbered from 1")));
                                            usage(1);
                                        } while (0);
                                    if (n_rp >= n_rp_allocated) {
                                        (rp) = x2nrealloc(rp, &n_rp_allocated, sizeof *(rp));
                                    }
                                    rp[n_rp].lo = (initial);
                                    rp[n_rp].hi = (value);
                                    ++n_rp;
                                } while (0);
                            }
                            field_found = 1;
                        }
                    } else {
                        do {
                            if (initial == 0 || value == 0)
                                do {
                                    error(0, 0, (gettext("fields and positions are numbered from 1")));
                                    usage(1);
                                } while (0);
                            if (n_rp >= n_rp_allocated) {
                                (rp) = x2nrealloc(rp, &n_rp_allocated, sizeof *(rp));
                            }
                            rp[n_rp].lo = (initial);
                            rp[n_rp].hi = (value);
                            ++n_rp;
                        } while (0);
                        field_found = 1;
                    }
                    value = 0;
                }
            } else {
                do {
                    if (value == 0 || value == 0)
                        do {
                            error(0, 0, (gettext("fields and positions are numbered from 1")));
                            usage(1);
                        } while (0);
                    if (n_rp >= n_rp_allocated) {
                        (rp) = x2nrealloc(rp, &n_rp_allocated, sizeof *(rp));
                    }
                    rp[n_rp].lo = (value);
                    rp[n_rp].hi = (value);
                    ++n_rp;
                } while (0);
                value = 0;
                field_found = 1;
            }
            if (*fieldstr == '\x00') {
                break;
            }
            fieldstr++;
            lhs_specified = 0;
            rhs_specified = 0;
        } else if (((unsigned int)(*fieldstr) - '0' <= 9)) {
            static const char *num_start;
            if (!in_digits || !num_start)
                num_start = fieldstr;
            in_digits = 1;
            if (dash_found)
                rhs_specified = 1;
            else
                lhs_specified = 1;
            if (!((void)(&(value) == (size_t *)((void *)0)) , (((size_t)-1 / 10 < (value) || (size_t)((value) * 10 + (*fieldstr - '0')) < (value)) ? 0 : (((value) = (value) * 10 + (*fieldstr - '0')) , 1)))) {
                size_t len = strspn(num_start, "0123456789");
                char *bad_num = xstrndup(num_start, len);
                if (operating_mode == byte_mode)
                    error(0, 0, gettext("byte offset %s is too large"), quote(bad_num));
                else
                    error(0, 0, gettext("field number %s is too large"), quote(bad_num));
                free(bad_num);
                exit(1);
            }
            fieldstr++;
        } else
            do {
                error(0, 0, (gettext("invalid byte or field list")));
                usage(1);
            } while (0);
    }


BasicTester, a patch instance with id 128:
Spawn 1 instances, now Total 169
Counter: 170
Batcher Size:49
Preprocess the following candidate with BasicTester:
Priority 7465
At location src/cut.c:363
--Src File: src/cut.c
Fragment 0:
lhs_specified = 1;
while (1)
    {
        if (*fieldstr == '-') {
            in_digits = 0;
            if (dash_found)
                do {
                    error(0, 0, (gettext("invalid byte or field list")));
                    usage(1);
                } while (0);
            dash_found = 1;
            fieldstr++;
            initial = (lhs_specified ? value : 1);
            value = 0;
        } else if (*fieldstr == ',' || ((*__ctype_b_loc())[(int)((to_uchar(*fieldstr)))] & (unsigned short)_ISblank) || *fieldstr == '\x00') {
            in_digits = 0;
            if (dash_found) {
                dash_found = 0;
                if (!lhs_specified && !rhs_specified)
                    do {
                        error(0, 0, (gettext("invalid range with no endpoint: -")));
                        usage(1);
                    } while (0);
                if (!rhs_specified) {
                    eol_range_start = initial;
                    field_found = 1;
                } else {
                    if (value < initial)
                        do {
                            error(0, 0, (gettext("invalid decreasing range")));
                            usage(1);
                        } while (0);
                    if (eol_range_start != 0) {
                        if (initial < eol_range_start) {
                            if (eol_range_start <= value) {
                                eol_range_start = initial;
                            } else {
                                do {
                                    if (initial == 0 || value == 0)
                                        do {
                                            error(0, 0, (gettext("fields and positions are numbered from 1")));
                                            usage(1);
                                        } while (0);
                                    if (n_rp >= n_rp_allocated) {
                                        (rp) = x2nrealloc(rp, &n_rp_allocated, sizeof *(rp));
                                    }
                                    rp[n_rp].lo = (initial);
                                    rp[n_rp].hi = (value);
                                    ++n_rp;
                                } while (0);
                            }
                            field_found = 1;
                        }
                    } else {
                        do {
                            if (initial == 0 || value == 0)
                                do {
                                    error(0, 0, (gettext("fields and positions are numbered from 1")));
                                    usage(1);
                                } while (0);
                            if (n_rp >= n_rp_allocated) {
                                (rp) = x2nrealloc(rp, &n_rp_allocated, sizeof *(rp));
                            }
                            rp[n_rp].lo = (initial);
                            rp[n_rp].hi = (value);
                            ++n_rp;
                        } while (0);
                        field_found = 1;
                    }
                    value = 0;
                }
            } else {
                do {
                    if (value == 0 || value == 0)
                        do {
                            error(0, 0, (gettext("fields and positions are numbered from 1")));
                            usage(1);
                        } while (0);
                    if (n_rp >= n_rp_allocated) {
                        (rp) = x2nrealloc(rp, &n_rp_allocated, sizeof *(rp));
                    }
                    rp[n_rp].lo = (value);
                    rp[n_rp].hi = (value);
                    ++n_rp;
                } while (0);
                value = 0;
                field_found = 1;
            }
            if (*fieldstr == '\x00') {
                break;
            }
            fieldstr++;
            lhs_specified = 0;
            rhs_specified = 0;
        } else if (((unsigned int)(*fieldstr) - '0' <= 9)) {
            static const char *num_start;
            if (!in_digits || !num_start)
                num_start = fieldstr;
            in_digits = 1;
            if (dash_found)
                rhs_specified = 1;
            else
                lhs_specified = 1;
            if (!((void)(&(value) == (size_t *)((void *)0)) , (((size_t)-1 / 10 < (value) || (size_t)((value) * 10 + (*fieldstr - '0')) < (value)) ? 0 : (((value) = (value) * 10 + (*fieldstr - '0')) , 1)))) {
                size_t len = strspn(num_start, "0123456789");
                char *bad_num = xstrndup(num_start, len);
                if (operating_mode == byte_mode)
                    error(0, 0, gettext("byte offset %s is too large"), quote(bad_num));
                else
                    error(0, 0, gettext("field number %s is too large"), quote(bad_num));
                free(bad_num);
                exit(1);
            }
            fieldstr++;
        } else
            do {
                error(0, 0, (gettext("invalid byte or field list")));
                usage(1);
            } while (0);
    }


BasicTester, a patch instance with id 129:
Spawn 1 instances, now Total 170
Counter: 171
Batcher Size:50
Preprocess the following candidate with BasicTester:
Priority 7465
At location src/cut.c:363
--Src File: src/cut.c
Fragment 0:
lhs_specified = (rhs_specified);
while (1)
    {
        if (*fieldstr == '-') {
            in_digits = 0;
            if (dash_found)
                do {
                    error(0, 0, (gettext("invalid byte or field list")));
                    usage(1);
                } while (0);
            dash_found = 1;
            fieldstr++;
            initial = (lhs_specified ? value : 1);
            value = 0;
        } else if (*fieldstr == ',' || ((*__ctype_b_loc())[(int)((to_uchar(*fieldstr)))] & (unsigned short)_ISblank) || *fieldstr == '\x00') {
            in_digits = 0;
            if (dash_found) {
                dash_found = 0;
                if (!lhs_specified && !rhs_specified)
                    do {
                        error(0, 0, (gettext("invalid range with no endpoint: -")));
                        usage(1);
                    } while (0);
                if (!rhs_specified) {
                    eol_range_start = initial;
                    field_found = 1;
                } else {
                    if (value < initial)
                        do {
                            error(0, 0, (gettext("invalid decreasing range")));
                            usage(1);
                        } while (0);
                    if (eol_range_start != 0) {
                        if (initial < eol_range_start) {
                            if (eol_range_start <= value) {
                                eol_range_start = initial;
                            } else {
                                do {
                                    if (initial == 0 || value == 0)
                                        do {
                                            error(0, 0, (gettext("fields and positions are numbered from 1")));
                                            usage(1);
                                        } while (0);
                                    if (n_rp >= n_rp_allocated) {
                                        (rp) = x2nrealloc(rp, &n_rp_allocated, sizeof *(rp));
                                    }
                                    rp[n_rp].lo = (initial);
                                    rp[n_rp].hi = (value);
                                    ++n_rp;
                                } while (0);
                            }
                            field_found = 1;
                        }
                    } else {
                        do {
                            if (initial == 0 || value == 0)
                                do {
                                    error(0, 0, (gettext("fields and positions are numbered from 1")));
                                    usage(1);
                                } while (0);
                            if (n_rp >= n_rp_allocated) {
                                (rp) = x2nrealloc(rp, &n_rp_allocated, sizeof *(rp));
                            }
                            rp[n_rp].lo = (initial);
                            rp[n_rp].hi = (value);
                            ++n_rp;
                        } while (0);
                        field_found = 1;
                    }
                    value = 0;
                }
            } else {
                do {
                    if (value == 0 || value == 0)
                        do {
                            error(0, 0, (gettext("fields and positions are numbered from 1")));
                            usage(1);
                        } while (0);
                    if (n_rp >= n_rp_allocated) {
                        (rp) = x2nrealloc(rp, &n_rp_allocated, sizeof *(rp));
                    }
                    rp[n_rp].lo = (value);
                    rp[n_rp].hi = (value);
                    ++n_rp;
                } while (0);
                value = 0;
                field_found = 1;
            }
            if (*fieldstr == '\x00') {
                break;
            }
            fieldstr++;
            lhs_specified = 0;
            rhs_specified = 0;
        } else if (((unsigned int)(*fieldstr) - '0' <= 9)) {
            static const char *num_start;
            if (!in_digits || !num_start)
                num_start = fieldstr;
            in_digits = 1;
            if (dash_found)
                rhs_specified = 1;
            else
                lhs_specified = 1;
            if (!((void)(&(value) == (size_t *)((void *)0)) , (((size_t)-1 / 10 < (value) || (size_t)((value) * 10 + (*fieldstr - '0')) < (value)) ? 0 : (((value) = (value) * 10 + (*fieldstr - '0')) , 1)))) {
                size_t len = strspn(num_start, "0123456789");
                char *bad_num = xstrndup(num_start, len);
                if (operating_mode == byte_mode)
                    error(0, 0, gettext("byte offset %s is too large"), quote(bad_num));
                else
                    error(0, 0, gettext("field number %s is too large"), quote(bad_num));
                free(bad_num);
                exit(1);
            }
            fieldstr++;
        } else
            do {
                error(0, 0, (gettext("invalid byte or field list")));
                usage(1);
            } while (0);
    }


BasicTester, a patch instance with id 130:
Spawn 1 instances, now Total 171
Counter: 172
Batcher Size:51
Preprocess the following candidate with BasicTester:
Priority 7465
At location src/cut.c:363
--Src File: src/cut.c
Fragment 0:
lhs_specified = (field_found);
while (1)
    {
        if (*fieldstr == '-') {
            in_digits = 0;
            if (dash_found)
                do {
                    error(0, 0, (gettext("invalid byte or field list")));
                    usage(1);
                } while (0);
            dash_found = 1;
            fieldstr++;
            initial = (lhs_specified ? value : 1);
            value = 0;
        } else if (*fieldstr == ',' || ((*__ctype_b_loc())[(int)((to_uchar(*fieldstr)))] & (unsigned short)_ISblank) || *fieldstr == '\x00') {
            in_digits = 0;
            if (dash_found) {
                dash_found = 0;
                if (!lhs_specified && !rhs_specified)
                    do {
                        error(0, 0, (gettext("invalid range with no endpoint: -")));
                        usage(1);
                    } while (0);
                if (!rhs_specified) {
                    eol_range_start = initial;
                    field_found = 1;
                } else {
                    if (value < initial)
                        do {
                            error(0, 0, (gettext("invalid decreasing range")));
                            usage(1);
                        } while (0);
                    if (eol_range_start != 0) {
                        if (initial < eol_range_start) {
                            if (eol_range_start <= value) {
                                eol_range_start = initial;
                            } else {
                                do {
                                    if (initial == 0 || value == 0)
                                        do {
                                            error(0, 0, (gettext("fields and positions are numbered from 1")));
                                            usage(1);
                                        } while (0);
                                    if (n_rp >= n_rp_allocated) {
                                        (rp) = x2nrealloc(rp, &n_rp_allocated, sizeof *(rp));
                                    }
                                    rp[n_rp].lo = (initial);
                                    rp[n_rp].hi = (value);
                                    ++n_rp;
                                } while (0);
                            }
                            field_found = 1;
                        }
                    } else {
                        do {
                            if (initial == 0 || value == 0)
                                do {
                                    error(0, 0, (gettext("fields and positions are numbered from 1")));
                                    usage(1);
                                } while (0);
                            if (n_rp >= n_rp_allocated) {
                                (rp) = x2nrealloc(rp, &n_rp_allocated, sizeof *(rp));
                            }
                            rp[n_rp].lo = (initial);
                            rp[n_rp].hi = (value);
                            ++n_rp;
                        } while (0);
                        field_found = 1;
                    }
                    value = 0;
                }
            } else {
                do {
                    if (value == 0 || value == 0)
                        do {
                            error(0, 0, (gettext("fields and positions are numbered from 1")));
                            usage(1);
                        } while (0);
                    if (n_rp >= n_rp_allocated) {
                        (rp) = x2nrealloc(rp, &n_rp_allocated, sizeof *(rp));
                    }
                    rp[n_rp].lo = (value);
                    rp[n_rp].hi = (value);
                    ++n_rp;
                } while (0);
                value = 0;
                field_found = 1;
            }
            if (*fieldstr == '\x00') {
                break;
            }
            fieldstr++;
            lhs_specified = 0;
            rhs_specified = 0;
        } else if (((unsigned int)(*fieldstr) - '0' <= 9)) {
            static const char *num_start;
            if (!in_digits || !num_start)
                num_start = fieldstr;
            in_digits = 1;
            if (dash_found)
                rhs_specified = 1;
            else
                lhs_specified = 1;
            if (!((void)(&(value) == (size_t *)((void *)0)) , (((size_t)-1 / 10 < (value) || (size_t)((value) * 10 + (*fieldstr - '0')) < (value)) ? 0 : (((value) = (value) * 10 + (*fieldstr - '0')) , 1)))) {
                size_t len = strspn(num_start, "0123456789");
                char *bad_num = xstrndup(num_start, len);
                if (operating_mode == byte_mode)
                    error(0, 0, gettext("byte offset %s is too large"), quote(bad_num));
                else
                    error(0, 0, gettext("field number %s is too large"), quote(bad_num));
                free(bad_num);
                exit(1);
            }
            fieldstr++;
        } else
            do {
                error(0, 0, (gettext("invalid byte or field list")));
                usage(1);
            } while (0);
    }


BasicTester, a patch instance with id 131:
Spawn 1 instances, now Total 172
Counter: 173
Batcher Size:52
Preprocess the following candidate with BasicTester:
Priority 7465
At location src/cut.c:363
--Src File: src/cut.c
Fragment 0:
lhs_specified = (in_digits);
while (1)
    {
        if (*fieldstr == '-') {
            in_digits = 0;
            if (dash_found)
                do {
                    error(0, 0, (gettext("invalid byte or field list")));
                    usage(1);
                } while (0);
            dash_found = 1;
            fieldstr++;
            initial = (lhs_specified ? value : 1);
            value = 0;
        } else if (*fieldstr == ',' || ((*__ctype_b_loc())[(int)((to_uchar(*fieldstr)))] & (unsigned short)_ISblank) || *fieldstr == '\x00') {
            in_digits = 0;
            if (dash_found) {
                dash_found = 0;
                if (!lhs_specified && !rhs_specified)
                    do {
                        error(0, 0, (gettext("invalid range with no endpoint: -")));
                        usage(1);
                    } while (0);
                if (!rhs_specified) {
                    eol_range_start = initial;
                    field_found = 1;
                } else {
                    if (value < initial)
                        do {
                            error(0, 0, (gettext("invalid decreasing range")));
                            usage(1);
                        } while (0);
                    if (eol_range_start != 0) {
                        if (initial < eol_range_start) {
                            if (eol_range_start <= value) {
                                eol_range_start = initial;
                            } else {
                                do {
                                    if (initial == 0 || value == 0)
                                        do {
                                            error(0, 0, (gettext("fields and positions are numbered from 1")));
                                            usage(1);
                                        } while (0);
                                    if (n_rp >= n_rp_allocated) {
                                        (rp) = x2nrealloc(rp, &n_rp_allocated, sizeof *(rp));
                                    }
                                    rp[n_rp].lo = (initial);
                                    rp[n_rp].hi = (value);
                                    ++n_rp;
                                } while (0);
                            }
                            field_found = 1;
                        }
                    } else {
                        do {
                            if (initial == 0 || value == 0)
                                do {
                                    error(0, 0, (gettext("fields and positions are numbered from 1")));
                                    usage(1);
                                } while (0);
                            if (n_rp >= n_rp_allocated) {
                                (rp) = x2nrealloc(rp, &n_rp_allocated, sizeof *(rp));
                            }
                            rp[n_rp].lo = (initial);
                            rp[n_rp].hi = (value);
                            ++n_rp;
                        } while (0);
                        field_found = 1;
                    }
                    value = 0;
                }
            } else {
                do {
                    if (value == 0 || value == 0)
                        do {
                            error(0, 0, (gettext("fields and positions are numbered from 1")));
                            usage(1);
                        } while (0);
                    if (n_rp >= n_rp_allocated) {
                        (rp) = x2nrealloc(rp, &n_rp_allocated, sizeof *(rp));
                    }
                    rp[n_rp].lo = (value);
                    rp[n_rp].hi = (value);
                    ++n_rp;
                } while (0);
                value = 0;
                field_found = 1;
            }
            if (*fieldstr == '\x00') {
                break;
            }
            fieldstr++;
            lhs_specified = 0;
            rhs_specified = 0;
        } else if (((unsigned int)(*fieldstr) - '0' <= 9)) {
            static const char *num_start;
            if (!in_digits || !num_start)
                num_start = fieldstr;
            in_digits = 1;
            if (dash_found)
                rhs_specified = 1;
            else
                lhs_specified = 1;
            if (!((void)(&(value) == (size_t *)((void *)0)) , (((size_t)-1 / 10 < (value) || (size_t)((value) * 10 + (*fieldstr - '0')) < (value)) ? 0 : (((value) = (value) * 10 + (*fieldstr - '0')) , 1)))) {
                size_t len = strspn(num_start, "0123456789");
                char *bad_num = xstrndup(num_start, len);
                if (operating_mode == byte_mode)
                    error(0, 0, gettext("byte offset %s is too large"), quote(bad_num));
                else
                    error(0, 0, gettext("field number %s is too large"), quote(bad_num));
                free(bad_num);
                exit(1);
            }
            fieldstr++;
        } else
            do {
                error(0, 0, (gettext("invalid byte or field list")));
                usage(1);
            } while (0);
    }


BasicTester, a patch instance with id 132:
Spawn 1 instances, now Total 173
a batched test job starts!
Building:src at:
/home/ubuntu/spr-fast/tests/corebench/coreutils/coreutils-case-7380cf79-2e636af1/tempworkdir/srcMerged code building succ, going to invoke tester!
BasicTester, Testing instance id 123:
Running test command:
/home/ubuntu/spr-fast/tools/coreutils-test.py /home/ubuntu/spr-fast/tests/corebench/coreutils/coreutils-case-7380cf79-2e636af1/tempworkdir/src /home/ubuntu/spr-fast/tests/corebench/coreutils/coreutils-case-7380cf79-2e636af1/tempworkdir/tests /home/ubuntu/spr-fast/tests/corebench/coreutils/coreutils-case-7380cf79-2e636af1/tempworkdir 0  > __res
BasicTester, Testing instance id 124:
Running test command:
/home/ubuntu/spr-fast/tools/coreutils-test.py /home/ubuntu/spr-fast/tests/corebench/coreutils/coreutils-case-7380cf79-2e636af1/tempworkdir/src /home/ubuntu/spr-fast/tests/corebench/coreutils/coreutils-case-7380cf79-2e636af1/tempworkdir/tests /home/ubuntu/spr-fast/tests/corebench/coreutils/coreutils-case-7380cf79-2e636af1/tempworkdir 0  > __res
BasicTester, Testing instance id 125:
Running test command:
/home/ubuntu/spr-fast/tools/coreutils-test.py /home/ubuntu/spr-fast/tests/corebench/coreutils/coreutils-case-7380cf79-2e636af1/tempworkdir/src /home/ubuntu/spr-fast/tests/corebench/coreutils/coreutils-case-7380cf79-2e636af1/tempworkdir/tests /home/ubuntu/spr-fast/tests/corebench/coreutils/coreutils-case-7380cf79-2e636af1/tempworkdir 0  > __res
BasicTester, Testing instance id 126:
Running test command:
/home/ubuntu/spr-fast/tools/coreutils-test.py /home/ubuntu/spr-fast/tests/corebench/coreutils/coreutils-case-7380cf79-2e636af1/tempworkdir/src /home/ubuntu/spr-fast/tests/corebench/coreutils/coreutils-case-7380cf79-2e636af1/tempworkdir/tests /home/ubuntu/spr-fast/tests/corebench/coreutils/coreutils-case-7380cf79-2e636af1/tempworkdir 0  > __res
BasicTester, Testing instance id 127:
Running test command:
/home/ubuntu/spr-fast/tools/coreutils-test.py /home/ubuntu/spr-fast/tests/corebench/coreutils/coreutils-case-7380cf79-2e636af1/tempworkdir/src /home/ubuntu/spr-fast/tests/corebench/coreutils/coreutils-case-7380cf79-2e636af1/tempworkdir/tests /home/ubuntu/spr-fast/tests/corebench/coreutils/coreutils-case-7380cf79-2e636af1/tempworkdir 0  > __res
BasicTester, Testing instance id 128:
Running test command:
/home/ubuntu/spr-fast/tools/coreutils-test.py /home/ubuntu/spr-fast/tests/corebench/coreutils/coreutils-case-7380cf79-2e636af1/tempworkdir/src /home/ubuntu/spr-fast/tests/corebench/coreutils/coreutils-case-7380cf79-2e636af1/tempworkdir/tests /home/ubuntu/spr-fast/tests/corebench/coreutils/coreutils-case-7380cf79-2e636af1/tempworkdir 0  > __res
BasicTester, Testing instance id 129:
Running test command:
/home/ubuntu/spr-fast/tools/coreutils-test.py /home/ubuntu/spr-fast/tests/corebench/coreutils/coreutils-case-7380cf79-2e636af1/tempworkdir/src /home/ubuntu/spr-fast/tests/corebench/coreutils/coreutils-case-7380cf79-2e636af1/tempworkdir/tests /home/ubuntu/spr-fast/tests/corebench/coreutils/coreutils-case-7380cf79-2e636af1/tempworkdir 0  > __res
BasicTester, Testing instance id 130:
Running test command:
/home/ubuntu/spr-fast/tools/coreutils-test.py /home/ubuntu/spr-fast/tests/corebench/coreutils/coreutils-case-7380cf79-2e636af1/tempworkdir/src /home/ubuntu/spr-fast/tests/corebench/coreutils/coreutils-case-7380cf79-2e636af1/tempworkdir/tests /home/ubuntu/spr-fast/tests/corebench/coreutils/coreutils-case-7380cf79-2e636af1/tempworkdir 0  > __res
BasicTester, Testing instance id 131:
Running test command:
/home/ubuntu/spr-fast/tools/coreutils-test.py /home/ubuntu/spr-fast/tests/corebench/coreutils/coreutils-case-7380cf79-2e636af1/tempworkdir/src /home/ubuntu/spr-fast/tests/corebench/coreutils/coreutils-case-7380cf79-2e636af1/tempworkdir/tests /home/ubuntu/spr-fast/tests/corebench/coreutils/coreutils-case-7380cf79-2e636af1/tempworkdir 0  > __res
BasicTester, Testing instance id 132:
Running test command:
/home/ubuntu/spr-fast/tools/coreutils-test.py /home/ubuntu/spr-fast/tests/corebench/coreutils/coreutils-case-7380cf79-2e636af1/tempworkdir/src /home/ubuntu/spr-fast/tests/corebench/coreutils/coreutils-case-7380cf79-2e636af1/tempworkdir/tests /home/ubuntu/spr-fast/tests/corebench/coreutils/coreutils-case-7380cf79-2e636af1/tempworkdir 0  > __res
Counter: 174
Batcher Size:43
Preprocess the following candidate with BasicTester:
Priority 7465
At location src/cut.c:363
--Src File: src/cut.c
Fragment 0:
in_digits = (in_digits);
while (1)
    {
        if (*fieldstr == '-') {
            in_digits = 0;
            if (dash_found)
                do {
                    error(0, 0, (gettext("invalid byte or field list")));
                    usage(1);
                } while (0);
            dash_found = 1;
            fieldstr++;
            initial = (lhs_specified ? value : 1);
            value = 0;
        } else if (*fieldstr == ',' || ((*__ctype_b_loc())[(int)((to_uchar(*fieldstr)))] & (unsigned short)_ISblank) || *fieldstr == '\x00') {
            in_digits = 0;
            if (dash_found) {
                dash_found = 0;
                if (!lhs_specified && !rhs_specified)
                    do {
                        error(0, 0, (gettext("invalid range with no endpoint: -")));
                        usage(1);
                    } while (0);
                if (!rhs_specified) {
                    eol_range_start = initial;
                    field_found = 1;
                } else {
                    if (value < initial)
                        do {
                            error(0, 0, (gettext("invalid decreasing range")));
                            usage(1);
                        } while (0);
                    if (eol_range_start != 0) {
                        if (initial < eol_range_start) {
                            if (eol_range_start <= value) {
                                eol_range_start = initial;
                            } else {
                                do {
                                    if (initial == 0 || value == 0)
                                        do {
                                            error(0, 0, (gettext("fields and positions are numbered from 1")));
                                            usage(1);
                                        } while (0);
                                    if (n_rp >= n_rp_allocated) {
                                        (rp) = x2nrealloc(rp, &n_rp_allocated, sizeof *(rp));
                                    }
                                    rp[n_rp].lo = (initial);
                                    rp[n_rp].hi = (value);
                                    ++n_rp;
                                } while (0);
                            }
                            field_found = 1;
                        }
                    } else {
                        do {
                            if (initial == 0 || value == 0)
                                do {
                                    error(0, 0, (gettext("fields and positions are numbered from 1")));
                                    usage(1);
                                } while (0);
                            if (n_rp >= n_rp_allocated) {
                                (rp) = x2nrealloc(rp, &n_rp_allocated, sizeof *(rp));
                            }
                            rp[n_rp].lo = (initial);
                            rp[n_rp].hi = (value);
                            ++n_rp;
                        } while (0);
                        field_found = 1;
                    }
                    value = 0;
                }
            } else {
                do {
                    if (value == 0 || value == 0)
                        do {
                            error(0, 0, (gettext("fields and positions are numbered from 1")));
                            usage(1);
                        } while (0);
                    if (n_rp >= n_rp_allocated) {
                        (rp) = x2nrealloc(rp, &n_rp_allocated, sizeof *(rp));
                    }
                    rp[n_rp].lo = (value);
                    rp[n_rp].hi = (value);
                    ++n_rp;
                } while (0);
                value = 0;
                field_found = 1;
            }
            if (*fieldstr == '\x00') {
                break;
            }
            fieldstr++;
            lhs_specified = 0;
            rhs_specified = 0;
        } else if (((unsigned int)(*fieldstr) - '0' <= 9)) {
            static const char *num_start;
            if (!in_digits || !num_start)
                num_start = fieldstr;
            in_digits = 1;
            if (dash_found)
                rhs_specified = 1;
            else
                lhs_specified = 1;
            if (!((void)(&(value) == (size_t *)((void *)0)) , (((size_t)-1 / 10 < (value) || (size_t)((value) * 10 + (*fieldstr - '0')) < (value)) ? 0 : (((value) = (value) * 10 + (*fieldstr - '0')) , 1)))) {
                size_t len = strspn(num_start, "0123456789");
                char *bad_num = xstrndup(num_start, len);
                if (operating_mode == byte_mode)
                    error(0, 0, gettext("byte offset %s is too large"), quote(bad_num));
                else
                    error(0, 0, gettext("field number %s is too large"), quote(bad_num));
                free(bad_num);
                exit(1);
            }
            fieldstr++;
        } else
            do {
                error(0, 0, (gettext("invalid byte or field list")));
                usage(1);
            } while (0);
    }


BasicTester, a patch instance with id 133:
Spawn 1 instances, now Total 174
Counter: 175
Batcher Size:44
Preprocess the following candidate with BasicTester:
Priority 7465
At location src/cut.c:363
--Src File: src/cut.c
Fragment 0:
initial = (initial);
while (1)
    {
        if (*fieldstr == '-') {
            in_digits = 0;
            if (dash_found)
                do {
                    error(0, 0, (gettext("invalid byte or field list")));
                    usage(1);
                } while (0);
            dash_found = 1;
            fieldstr++;
            initial = (lhs_specified ? value : 1);
            value = 0;
        } else if (*fieldstr == ',' || ((*__ctype_b_loc())[(int)((to_uchar(*fieldstr)))] & (unsigned short)_ISblank) || *fieldstr == '\x00') {
            in_digits = 0;
            if (dash_found) {
                dash_found = 0;
                if (!lhs_specified && !rhs_specified)
                    do {
                        error(0, 0, (gettext("invalid range with no endpoint: -")));
                        usage(1);
                    } while (0);
                if (!rhs_specified) {
                    eol_range_start = initial;
                    field_found = 1;
                } else {
                    if (value < initial)
                        do {
                            error(0, 0, (gettext("invalid decreasing range")));
                            usage(1);
                        } while (0);
                    if (eol_range_start != 0) {
                        if (initial < eol_range_start) {
                            if (eol_range_start <= value) {
                                eol_range_start = initial;
                            } else {
                                do {
                                    if (initial == 0 || value == 0)
                                        do {
                                            error(0, 0, (gettext("fields and positions are numbered from 1")));
                                            usage(1);
                                        } while (0);
                                    if (n_rp >= n_rp_allocated) {
                                        (rp) = x2nrealloc(rp, &n_rp_allocated, sizeof *(rp));
                                    }
                                    rp[n_rp].lo = (initial);
                                    rp[n_rp].hi = (value);
                                    ++n_rp;
                                } while (0);
                            }
                            field_found = 1;
                        }
                    } else {
                        do {
                            if (initial == 0 || value == 0)
                                do {
                                    error(0, 0, (gettext("fields and positions are numbered from 1")));
                                    usage(1);
                                } while (0);
                            if (n_rp >= n_rp_allocated) {
                                (rp) = x2nrealloc(rp, &n_rp_allocated, sizeof *(rp));
                            }
                            rp[n_rp].lo = (initial);
                            rp[n_rp].hi = (value);
                            ++n_rp;
                        } while (0);
                        field_found = 1;
                    }
                    value = 0;
                }
            } else {
                do {
                    if (value == 0 || value == 0)
                        do {
                            error(0, 0, (gettext("fields and positions are numbered from 1")));
                            usage(1);
                        } while (0);
                    if (n_rp >= n_rp_allocated) {
                        (rp) = x2nrealloc(rp, &n_rp_allocated, sizeof *(rp));
                    }
                    rp[n_rp].lo = (value);
                    rp[n_rp].hi = (value);
                    ++n_rp;
                } while (0);
                value = 0;
                field_found = 1;
            }
            if (*fieldstr == '\x00') {
                break;
            }
            fieldstr++;
            lhs_specified = 0;
            rhs_specified = 0;
        } else if (((unsigned int)(*fieldstr) - '0' <= 9)) {
            static const char *num_start;
            if (!in_digits || !num_start)
                num_start = fieldstr;
            in_digits = 1;
            if (dash_found)
                rhs_specified = 1;
            else
                lhs_specified = 1;
            if (!((void)(&(value) == (size_t *)((void *)0)) , (((size_t)-1 / 10 < (value) || (size_t)((value) * 10 + (*fieldstr - '0')) < (value)) ? 0 : (((value) = (value) * 10 + (*fieldstr - '0')) , 1)))) {
                size_t len = strspn(num_start, "0123456789");
                char *bad_num = xstrndup(num_start, len);
                if (operating_mode == byte_mode)
                    error(0, 0, gettext("byte offset %s is too large"), quote(bad_num));
                else
                    error(0, 0, gettext("field number %s is too large"), quote(bad_num));
                free(bad_num);
                exit(1);
            }
            fieldstr++;
        } else
            do {
                error(0, 0, (gettext("invalid byte or field list")));
                usage(1);
            } while (0);
    }


BasicTester, a patch instance with id 134:
Spawn 1 instances, now Total 175
Counter: 176
Batcher Size:45
Preprocess the following candidate with BasicTester:
Priority 7465
At location src/cut.c:363
--Src File: src/cut.c
Fragment 0:
initial = (n_rp);
while (1)
    {
        if (*fieldstr == '-') {
            in_digits = 0;
            if (dash_found)
                do {
                    error(0, 0, (gettext("invalid byte or field list")));
                    usage(1);
                } while (0);
            dash_found = 1;
            fieldstr++;
            initial = (lhs_specified ? value : 1);
            value = 0;
        } else if (*fieldstr == ',' || ((*__ctype_b_loc())[(int)((to_uchar(*fieldstr)))] & (unsigned short)_ISblank) || *fieldstr == '\x00') {
            in_digits = 0;
            if (dash_found) {
                dash_found = 0;
                if (!lhs_specified && !rhs_specified)
                    do {
                        error(0, 0, (gettext("invalid range with no endpoint: -")));
                        usage(1);
                    } while (0);
                if (!rhs_specified) {
                    eol_range_start = initial;
                    field_found = 1;
                } else {
                    if (value < initial)
                        do {
                            error(0, 0, (gettext("invalid decreasing range")));
                            usage(1);
                        } while (0);
                    if (eol_range_start != 0) {
                        if (initial < eol_range_start) {
                            if (eol_range_start <= value) {
                                eol_range_start = initial;
                            } else {
                                do {
                                    if (initial == 0 || value == 0)
                                        do {
                                            error(0, 0, (gettext("fields and positions are numbered from 1")));
                                            usage(1);
                                        } while (0);
                                    if (n_rp >= n_rp_allocated) {
                                        (rp) = x2nrealloc(rp, &n_rp_allocated, sizeof *(rp));
                                    }
                                    rp[n_rp].lo = (initial);
                                    rp[n_rp].hi = (value);
                                    ++n_rp;
                                } while (0);
                            }
                            field_found = 1;
                        }
                    } else {
                        do {
                            if (initial == 0 || value == 0)
                                do {
                                    error(0, 0, (gettext("fields and positions are numbered from 1")));
                                    usage(1);
                                } while (0);
                            if (n_rp >= n_rp_allocated) {
                                (rp) = x2nrealloc(rp, &n_rp_allocated, sizeof *(rp));
                            }
                            rp[n_rp].lo = (initial);
                            rp[n_rp].hi = (value);
                            ++n_rp;
                        } while (0);
                        field_found = 1;
                    }
                    value = 0;
                }
            } else {
                do {
                    if (value == 0 || value == 0)
                        do {
                            error(0, 0, (gettext("fields and positions are numbered from 1")));
                            usage(1);
                        } while (0);
                    if (n_rp >= n_rp_allocated) {
                        (rp) = x2nrealloc(rp, &n_rp_allocated, sizeof *(rp));
                    }
                    rp[n_rp].lo = (value);
                    rp[n_rp].hi = (value);
                    ++n_rp;
                } while (0);
                value = 0;
                field_found = 1;
            }
            if (*fieldstr == '\x00') {
                break;
            }
            fieldstr++;
            lhs_specified = 0;
            rhs_specified = 0;
        } else if (((unsigned int)(*fieldstr) - '0' <= 9)) {
            static const char *num_start;
            if (!in_digits || !num_start)
                num_start = fieldstr;
            in_digits = 1;
            if (dash_found)
                rhs_specified = 1;
            else
                lhs_specified = 1;
            if (!((void)(&(value) == (size_t *)((void *)0)) , (((size_t)-1 / 10 < (value) || (size_t)((value) * 10 + (*fieldstr - '0')) < (value)) ? 0 : (((value) = (value) * 10 + (*fieldstr - '0')) , 1)))) {
                size_t len = strspn(num_start, "0123456789");
                char *bad_num = xstrndup(num_start, len);
                if (operating_mode == byte_mode)
                    error(0, 0, gettext("byte offset %s is too large"), quote(bad_num));
                else
                    error(0, 0, gettext("field number %s is too large"), quote(bad_num));
                free(bad_num);
                exit(1);
            }
            fieldstr++;
        } else
            do {
                error(0, 0, (gettext("invalid byte or field list")));
                usage(1);
            } while (0);
    }


BasicTester, a patch instance with id 135:
Spawn 1 instances, now Total 176
Counter: 177
Batcher Size:46
Preprocess the following candidate with BasicTester:
Priority 7465
At location src/cut.c:363
--Src File: src/cut.c
Fragment 0:
initial = (n_rp_allocated);
while (1)
    {
        if (*fieldstr == '-') {
            in_digits = 0;
            if (dash_found)
                do {
                    error(0, 0, (gettext("invalid byte or field list")));
                    usage(1);
                } while (0);
            dash_found = 1;
            fieldstr++;
            initial = (lhs_specified ? value : 1);
            value = 0;
        } else if (*fieldstr == ',' || ((*__ctype_b_loc())[(int)((to_uchar(*fieldstr)))] & (unsigned short)_ISblank) || *fieldstr == '\x00') {
            in_digits = 0;
            if (dash_found) {
                dash_found = 0;
                if (!lhs_specified && !rhs_specified)
                    do {
                        error(0, 0, (gettext("invalid range with no endpoint: -")));
                        usage(1);
                    } while (0);
                if (!rhs_specified) {
                    eol_range_start = initial;
                    field_found = 1;
                } else {
                    if (value < initial)
                        do {
                            error(0, 0, (gettext("invalid decreasing range")));
                            usage(1);
                        } while (0);
                    if (eol_range_start != 0) {
                        if (initial < eol_range_start) {
                            if (eol_range_start <= value) {
                                eol_range_start = initial;
                            } else {
                                do {
                                    if (initial == 0 || value == 0)
                                        do {
                                            error(0, 0, (gettext("fields and positions are numbered from 1")));
                                            usage(1);
                                        } while (0);
                                    if (n_rp >= n_rp_allocated) {
                                        (rp) = x2nrealloc(rp, &n_rp_allocated, sizeof *(rp));
                                    }
                                    rp[n_rp].lo = (initial);
                                    rp[n_rp].hi = (value);
                                    ++n_rp;
                                } while (0);
                            }
                            field_found = 1;
                        }
                    } else {
                        do {
                            if (initial == 0 || value == 0)
                                do {
                                    error(0, 0, (gettext("fields and positions are numbered from 1")));
                                    usage(1);
                                } while (0);
                            if (n_rp >= n_rp_allocated) {
                                (rp) = x2nrealloc(rp, &n_rp_allocated, sizeof *(rp));
                            }
                            rp[n_rp].lo = (initial);
                            rp[n_rp].hi = (value);
                            ++n_rp;
                        } while (0);
                        field_found = 1;
                    }
                    value = 0;
                }
            } else {
                do {
                    if (value == 0 || value == 0)
                        do {
                            error(0, 0, (gettext("fields and positions are numbered from 1")));
                            usage(1);
                        } while (0);
                    if (n_rp >= n_rp_allocated) {
                        (rp) = x2nrealloc(rp, &n_rp_allocated, sizeof *(rp));
                    }
                    rp[n_rp].lo = (value);
                    rp[n_rp].hi = (value);
                    ++n_rp;
                } while (0);
                value = 0;
                field_found = 1;
            }
            if (*fieldstr == '\x00') {
                break;
            }
            fieldstr++;
            lhs_specified = 0;
            rhs_specified = 0;
        } else if (((unsigned int)(*fieldstr) - '0' <= 9)) {
            static const char *num_start;
            if (!in_digits || !num_start)
                num_start = fieldstr;
            in_digits = 1;
            if (dash_found)
                rhs_specified = 1;
            else
                lhs_specified = 1;
            if (!((void)(&(value) == (size_t *)((void *)0)) , (((size_t)-1 / 10 < (value) || (size_t)((value) * 10 + (*fieldstr - '0')) < (value)) ? 0 : (((value) = (value) * 10 + (*fieldstr - '0')) , 1)))) {
                size_t len = strspn(num_start, "0123456789");
                char *bad_num = xstrndup(num_start, len);
                if (operating_mode == byte_mode)
                    error(0, 0, gettext("byte offset %s is too large"), quote(bad_num));
                else
                    error(0, 0, gettext("field number %s is too large"), quote(bad_num));
                free(bad_num);
                exit(1);
            }
            fieldstr++;
        } else
            do {
                error(0, 0, (gettext("invalid byte or field list")));
                usage(1);
            } while (0);
    }


BasicTester, a patch instance with id 136:
Spawn 1 instances, now Total 177
Counter: 178
Batcher Size:47
Preprocess the following candidate with BasicTester:
Priority 7465
At location src/cut.c:363
--Src File: src/cut.c
Fragment 0:
initial = (lhs_specified ? value : 1);
while (1)
    {
        if (*fieldstr == '-') {
            in_digits = 0;
            if (dash_found)
                do {
                    error(0, 0, (gettext("invalid byte or field list")));
                    usage(1);
                } while (0);
            dash_found = 1;
            fieldstr++;
            initial = (lhs_specified ? value : 1);
            value = 0;
        } else if (*fieldstr == ',' || ((*__ctype_b_loc())[(int)((to_uchar(*fieldstr)))] & (unsigned short)_ISblank) || *fieldstr == '\x00') {
            in_digits = 0;
            if (dash_found) {
                dash_found = 0;
                if (!lhs_specified && !rhs_specified)
                    do {
                        error(0, 0, (gettext("invalid range with no endpoint: -")));
                        usage(1);
                    } while (0);
                if (!rhs_specified) {
                    eol_range_start = initial;
                    field_found = 1;
                } else {
                    if (value < initial)
                        do {
                            error(0, 0, (gettext("invalid decreasing range")));
                            usage(1);
                        } while (0);
                    if (eol_range_start != 0) {
                        if (initial < eol_range_start) {
                            if (eol_range_start <= value) {
                                eol_range_start = initial;
                            } else {
                                do {
                                    if (initial == 0 || value == 0)
                                        do {
                                            error(0, 0, (gettext("fields and positions are numbered from 1")));
                                            usage(1);
                                        } while (0);
                                    if (n_rp >= n_rp_allocated) {
                                        (rp) = x2nrealloc(rp, &n_rp_allocated, sizeof *(rp));
                                    }
                                    rp[n_rp].lo = (initial);
                                    rp[n_rp].hi = (value);
                                    ++n_rp;
                                } while (0);
                            }
                            field_found = 1;
                        }
                    } else {
                        do {
                            if (initial == 0 || value == 0)
                                do {
                                    error(0, 0, (gettext("fields and positions are numbered from 1")));
                                    usage(1);
                                } while (0);
                            if (n_rp >= n_rp_allocated) {
                                (rp) = x2nrealloc(rp, &n_rp_allocated, sizeof *(rp));
                            }
                            rp[n_rp].lo = (initial);
                            rp[n_rp].hi = (value);
                            ++n_rp;
                        } while (0);
                        field_found = 1;
                    }
                    value = 0;
                }
            } else {
                do {
                    if (value == 0 || value == 0)
                        do {
                            error(0, 0, (gettext("fields and positions are numbered from 1")));
                            usage(1);
                        } while (0);
                    if (n_rp >= n_rp_allocated) {
                        (rp) = x2nrealloc(rp, &n_rp_allocated, sizeof *(rp));
                    }
                    rp[n_rp].lo = (value);
                    rp[n_rp].hi = (value);
                    ++n_rp;
                } while (0);
                value = 0;
                field_found = 1;
            }
            if (*fieldstr == '\x00') {
                break;
            }
            fieldstr++;
            lhs_specified = 0;
            rhs_specified = 0;
        } else if (((unsigned int)(*fieldstr) - '0' <= 9)) {
            static const char *num_start;
            if (!in_digits || !num_start)
                num_start = fieldstr;
            in_digits = 1;
            if (dash_found)
                rhs_specified = 1;
            else
                lhs_specified = 1;
            if (!((void)(&(value) == (size_t *)((void *)0)) , (((size_t)-1 / 10 < (value) || (size_t)((value) * 10 + (*fieldstr - '0')) < (value)) ? 0 : (((value) = (value) * 10 + (*fieldstr - '0')) , 1)))) {
                size_t len = strspn(num_start, "0123456789");
                char *bad_num = xstrndup(num_start, len);
                if (operating_mode == byte_mode)
                    error(0, 0, gettext("byte offset %s is too large"), quote(bad_num));
                else
                    error(0, 0, gettext("field number %s is too large"), quote(bad_num));
                free(bad_num);
                exit(1);
            }
            fieldstr++;
        } else
            do {
                error(0, 0, (gettext("invalid byte or field list")));
                usage(1);
            } while (0);
    }


BasicTester, a patch instance with id 137:
Spawn 1 instances, now Total 178
Counter: 179
Batcher Size:48
Preprocess the following candidate with BasicTester:
Priority 7465
At location src/cut.c:363
--Src File: src/cut.c
Fragment 0:
in_digits = (lhs_specified);
while (1)
    {
        if (*fieldstr == '-') {
            in_digits = 0;
            if (dash_found)
                do {
                    error(0, 0, (gettext("invalid byte or field list")));
                    usage(1);
                } while (0);
            dash_found = 1;
            fieldstr++;
            initial = (lhs_specified ? value : 1);
            value = 0;
        } else if (*fieldstr == ',' || ((*__ctype_b_loc())[(int)((to_uchar(*fieldstr)))] & (unsigned short)_ISblank) || *fieldstr == '\x00') {
            in_digits = 0;
            if (dash_found) {
                dash_found = 0;
                if (!lhs_specified && !rhs_specified)
                    do {
                        error(0, 0, (gettext("invalid range with no endpoint: -")));
                        usage(1);
                    } while (0);
                if (!rhs_specified) {
                    eol_range_start = initial;
                    field_found = 1;
                } else {
                    if (value < initial)
                        do {
                            error(0, 0, (gettext("invalid decreasing range")));
                            usage(1);
                        } while (0);
                    if (eol_range_start != 0) {
                        if (initial < eol_range_start) {
                            if (eol_range_start <= value) {
                                eol_range_start = initial;
                            } else {
                                do {
                                    if (initial == 0 || value == 0)
                                        do {
                                            error(0, 0, (gettext("fields and positions are numbered from 1")));
                                            usage(1);
                                        } while (0);
                                    if (n_rp >= n_rp_allocated) {
                                        (rp) = x2nrealloc(rp, &n_rp_allocated, sizeof *(rp));
                                    }
                                    rp[n_rp].lo = (initial);
                                    rp[n_rp].hi = (value);
                                    ++n_rp;
                                } while (0);
                            }
                            field_found = 1;
                        }
                    } else {
                        do {
                            if (initial == 0 || value == 0)
                                do {
                                    error(0, 0, (gettext("fields and positions are numbered from 1")));
                                    usage(1);
                                } while (0);
                            if (n_rp >= n_rp_allocated) {
                                (rp) = x2nrealloc(rp, &n_rp_allocated, sizeof *(rp));
                            }
                            rp[n_rp].lo = (initial);
                            rp[n_rp].hi = (value);
                            ++n_rp;
                        } while (0);
                        field_found = 1;
                    }
                    value = 0;
                }
            } else {
                do {
                    if (value == 0 || value == 0)
                        do {
                            error(0, 0, (gettext("fields and positions are numbered from 1")));
                            usage(1);
                        } while (0);
                    if (n_rp >= n_rp_allocated) {
                        (rp) = x2nrealloc(rp, &n_rp_allocated, sizeof *(rp));
                    }
                    rp[n_rp].lo = (value);
                    rp[n_rp].hi = (value);
                    ++n_rp;
                } while (0);
                value = 0;
                field_found = 1;
            }
            if (*fieldstr == '\x00') {
                break;
            }
            fieldstr++;
            lhs_specified = 0;
            rhs_specified = 0;
        } else if (((unsigned int)(*fieldstr) - '0' <= 9)) {
            static const char *num_start;
            if (!in_digits || !num_start)
                num_start = fieldstr;
            in_digits = 1;
            if (dash_found)
                rhs_specified = 1;
            else
                lhs_specified = 1;
            if (!((void)(&(value) == (size_t *)((void *)0)) , (((size_t)-1 / 10 < (value) || (size_t)((value) * 10 + (*fieldstr - '0')) < (value)) ? 0 : (((value) = (value) * 10 + (*fieldstr - '0')) , 1)))) {
                size_t len = strspn(num_start, "0123456789");
                char *bad_num = xstrndup(num_start, len);
                if (operating_mode == byte_mode)
                    error(0, 0, gettext("byte offset %s is too large"), quote(bad_num));
                else
                    error(0, 0, gettext("field number %s is too large"), quote(bad_num));
                free(bad_num);
                exit(1);
            }
            fieldstr++;
        } else
            do {
                error(0, 0, (gettext("invalid byte or field list")));
                usage(1);
            } while (0);
    }


BasicTester, a patch instance with id 138:
Spawn 1 instances, now Total 179
Counter: 180
Batcher Size:49
Preprocess the following candidate with BasicTester:
Priority 7465
At location src/cut.c:363
--Src File: src/cut.c
Fragment 0:
initial = (9);
while (1)
    {
        if (*fieldstr == '-') {
            in_digits = 0;
            if (dash_found)
                do {
                    error(0, 0, (gettext("invalid byte or field list")));
                    usage(1);
                } while (0);
            dash_found = 1;
            fieldstr++;
            initial = (lhs_specified ? value : 1);
            value = 0;
        } else if (*fieldstr == ',' || ((*__ctype_b_loc())[(int)((to_uchar(*fieldstr)))] & (unsigned short)_ISblank) || *fieldstr == '\x00') {
            in_digits = 0;
            if (dash_found) {
                dash_found = 0;
                if (!lhs_specified && !rhs_specified)
                    do {
                        error(0, 0, (gettext("invalid range with no endpoint: -")));
                        usage(1);
                    } while (0);
                if (!rhs_specified) {
                    eol_range_start = initial;
                    field_found = 1;
                } else {
                    if (value < initial)
                        do {
                            error(0, 0, (gettext("invalid decreasing range")));
                            usage(1);
                        } while (0);
                    if (eol_range_start != 0) {
                        if (initial < eol_range_start) {
                            if (eol_range_start <= value) {
                                eol_range_start = initial;
                            } else {
                                do {
                                    if (initial == 0 || value == 0)
                                        do {
                                            error(0, 0, (gettext("fields and positions are numbered from 1")));
                                            usage(1);
                                        } while (0);
                                    if (n_rp >= n_rp_allocated) {
                                        (rp) = x2nrealloc(rp, &n_rp_allocated, sizeof *(rp));
                                    }
                                    rp[n_rp].lo = (initial);
                                    rp[n_rp].hi = (value);
                                    ++n_rp;
                                } while (0);
                            }
                            field_found = 1;
                        }
                    } else {
                        do {
                            if (initial == 0 || value == 0)
                                do {
                                    error(0, 0, (gettext("fields and positions are numbered from 1")));
                                    usage(1);
                                } while (0);
                            if (n_rp >= n_rp_allocated) {
                                (rp) = x2nrealloc(rp, &n_rp_allocated, sizeof *(rp));
                            }
                            rp[n_rp].lo = (initial);
                            rp[n_rp].hi = (value);
                            ++n_rp;
                        } while (0);
                        field_found = 1;
                    }
                    value = 0;
                }
            } else {
                do {
                    if (value == 0 || value == 0)
                        do {
                            error(0, 0, (gettext("fields and positions are numbered from 1")));
                            usage(1);
                        } while (0);
                    if (n_rp >= n_rp_allocated) {
                        (rp) = x2nrealloc(rp, &n_rp_allocated, sizeof *(rp));
                    }
                    rp[n_rp].lo = (value);
                    rp[n_rp].hi = (value);
                    ++n_rp;
                } while (0);
                value = 0;
                field_found = 1;
            }
            if (*fieldstr == '\x00') {
                break;
            }
            fieldstr++;
            lhs_specified = 0;
            rhs_specified = 0;
        } else if (((unsigned int)(*fieldstr) - '0' <= 9)) {
            static const char *num_start;
            if (!in_digits || !num_start)
                num_start = fieldstr;
            in_digits = 1;
            if (dash_found)
                rhs_specified = 1;
            else
                lhs_specified = 1;
            if (!((void)(&(value) == (size_t *)((void *)0)) , (((size_t)-1 / 10 < (value) || (size_t)((value) * 10 + (*fieldstr - '0')) < (value)) ? 0 : (((value) = (value) * 10 + (*fieldstr - '0')) , 1)))) {
                size_t len = strspn(num_start, "0123456789");
                char *bad_num = xstrndup(num_start, len);
                if (operating_mode == byte_mode)
                    error(0, 0, gettext("byte offset %s is too large"), quote(bad_num));
                else
                    error(0, 0, gettext("field number %s is too large"), quote(bad_num));
                free(bad_num);
                exit(1);
            }
            fieldstr++;
        } else
            do {
                error(0, 0, (gettext("invalid byte or field list")));
                usage(1);
            } while (0);
    }


BasicTester, a patch instance with id 139:
Spawn 1 instances, now Total 180
Counter: 181
Batcher Size:50
Preprocess the following candidate with BasicTester:
Priority 7465
At location src/cut.c:363
--Src File: src/cut.c
Fragment 0:
initial = (i);
while (1)
    {
        if (*fieldstr == '-') {
            in_digits = 0;
            if (dash_found)
                do {
                    error(0, 0, (gettext("invalid byte or field list")));
                    usage(1);
                } while (0);
            dash_found = 1;
            fieldstr++;
            initial = (lhs_specified ? value : 1);
            value = 0;
        } else if (*fieldstr == ',' || ((*__ctype_b_loc())[(int)((to_uchar(*fieldstr)))] & (unsigned short)_ISblank) || *fieldstr == '\x00') {
            in_digits = 0;
            if (dash_found) {
                dash_found = 0;
                if (!lhs_specified && !rhs_specified)
                    do {
                        error(0, 0, (gettext("invalid range with no endpoint: -")));
                        usage(1);
                    } while (0);
                if (!rhs_specified) {
                    eol_range_start = initial;
                    field_found = 1;
                } else {
                    if (value < initial)
                        do {
                            error(0, 0, (gettext("invalid decreasing range")));
                            usage(1);
                        } while (0);
                    if (eol_range_start != 0) {
                        if (initial < eol_range_start) {
                            if (eol_range_start <= value) {
                                eol_range_start = initial;
                            } else {
                                do {
                                    if (initial == 0 || value == 0)
                                        do {
                                            error(0, 0, (gettext("fields and positions are numbered from 1")));
                                            usage(1);
                                        } while (0);
                                    if (n_rp >= n_rp_allocated) {
                                        (rp) = x2nrealloc(rp, &n_rp_allocated, sizeof *(rp));
                                    }
                                    rp[n_rp].lo = (initial);
                                    rp[n_rp].hi = (value);
                                    ++n_rp;
                                } while (0);
                            }
                            field_found = 1;
                        }
                    } else {
                        do {
                            if (initial == 0 || value == 0)
                                do {
                                    error(0, 0, (gettext("fields and positions are numbered from 1")));
                                    usage(1);
                                } while (0);
                            if (n_rp >= n_rp_allocated) {
                                (rp) = x2nrealloc(rp, &n_rp_allocated, sizeof *(rp));
                            }
                            rp[n_rp].lo = (initial);
                            rp[n_rp].hi = (value);
                            ++n_rp;
                        } while (0);
                        field_found = 1;
                    }
                    value = 0;
                }
            } else {
                do {
                    if (value == 0 || value == 0)
                        do {
                            error(0, 0, (gettext("fields and positions are numbered from 1")));
                            usage(1);
                        } while (0);
                    if (n_rp >= n_rp_allocated) {
                        (rp) = x2nrealloc(rp, &n_rp_allocated, sizeof *(rp));
                    }
                    rp[n_rp].lo = (value);
                    rp[n_rp].hi = (value);
                    ++n_rp;
                } while (0);
                value = 0;
                field_found = 1;
            }
            if (*fieldstr == '\x00') {
                break;
            }
            fieldstr++;
            lhs_specified = 0;
            rhs_specified = 0;
        } else if (((unsigned int)(*fieldstr) - '0' <= 9)) {
            static const char *num_start;
            if (!in_digits || !num_start)
                num_start = fieldstr;
            in_digits = 1;
            if (dash_found)
                rhs_specified = 1;
            else
                lhs_specified = 1;
            if (!((void)(&(value) == (size_t *)((void *)0)) , (((size_t)-1 / 10 < (value) || (size_t)((value) * 10 + (*fieldstr - '0')) < (value)) ? 0 : (((value) = (value) * 10 + (*fieldstr - '0')) , 1)))) {
                size_t len = strspn(num_start, "0123456789");
                char *bad_num = xstrndup(num_start, len);
                if (operating_mode == byte_mode)
                    error(0, 0, gettext("byte offset %s is too large"), quote(bad_num));
                else
                    error(0, 0, gettext("field number %s is too large"), quote(bad_num));
                free(bad_num);
                exit(1);
            }
            fieldstr++;
        } else
            do {
                error(0, 0, (gettext("invalid byte or field list")));
                usage(1);
            } while (0);
    }


BasicTester, a patch instance with id 140:
Spawn 1 instances, now Total 181
Counter: 182
Batcher Size:51
Preprocess the following candidate with BasicTester:
Priority 7465
At location src/cut.c:363
--Src File: src/cut.c
Fragment 0:
initial = (10);
while (1)
    {
        if (*fieldstr == '-') {
            in_digits = 0;
            if (dash_found)
                do {
                    error(0, 0, (gettext("invalid byte or field list")));
                    usage(1);
                } while (0);
            dash_found = 1;
            fieldstr++;
            initial = (lhs_specified ? value : 1);
            value = 0;
        } else if (*fieldstr == ',' || ((*__ctype_b_loc())[(int)((to_uchar(*fieldstr)))] & (unsigned short)_ISblank) || *fieldstr == '\x00') {
            in_digits = 0;
            if (dash_found) {
                dash_found = 0;
                if (!lhs_specified && !rhs_specified)
                    do {
                        error(0, 0, (gettext("invalid range with no endpoint: -")));
                        usage(1);
                    } while (0);
                if (!rhs_specified) {
                    eol_range_start = initial;
                    field_found = 1;
                } else {
                    if (value < initial)
                        do {
                            error(0, 0, (gettext("invalid decreasing range")));
                            usage(1);
                        } while (0);
                    if (eol_range_start != 0) {
                        if (initial < eol_range_start) {
                            if (eol_range_start <= value) {
                                eol_range_start = initial;
                            } else {
                                do {
                                    if (initial == 0 || value == 0)
                                        do {
                                            error(0, 0, (gettext("fields and positions are numbered from 1")));
                                            usage(1);
                                        } while (0);
                                    if (n_rp >= n_rp_allocated) {
                                        (rp) = x2nrealloc(rp, &n_rp_allocated, sizeof *(rp));
                                    }
                                    rp[n_rp].lo = (initial);
                                    rp[n_rp].hi = (value);
                                    ++n_rp;
                                } while (0);
                            }
                            field_found = 1;
                        }
                    } else {
                        do {
                            if (initial == 0 || value == 0)
                                do {
                                    error(0, 0, (gettext("fields and positions are numbered from 1")));
                                    usage(1);
                                } while (0);
                            if (n_rp >= n_rp_allocated) {
                                (rp) = x2nrealloc(rp, &n_rp_allocated, sizeof *(rp));
                            }
                            rp[n_rp].lo = (initial);
                            rp[n_rp].hi = (value);
                            ++n_rp;
                        } while (0);
                        field_found = 1;
                    }
                    value = 0;
                }
            } else {
                do {
                    if (value == 0 || value == 0)
                        do {
                            error(0, 0, (gettext("fields and positions are numbered from 1")));
                            usage(1);
                        } while (0);
                    if (n_rp >= n_rp_allocated) {
                        (rp) = x2nrealloc(rp, &n_rp_allocated, sizeof *(rp));
                    }
                    rp[n_rp].lo = (value);
                    rp[n_rp].hi = (value);
                    ++n_rp;
                } while (0);
                value = 0;
                field_found = 1;
            }
            if (*fieldstr == '\x00') {
                break;
            }
            fieldstr++;
            lhs_specified = 0;
            rhs_specified = 0;
        } else if (((unsigned int)(*fieldstr) - '0' <= 9)) {
            static const char *num_start;
            if (!in_digits || !num_start)
                num_start = fieldstr;
            in_digits = 1;
            if (dash_found)
                rhs_specified = 1;
            else
                lhs_specified = 1;
            if (!((void)(&(value) == (size_t *)((void *)0)) , (((size_t)-1 / 10 < (value) || (size_t)((value) * 10 + (*fieldstr - '0')) < (value)) ? 0 : (((value) = (value) * 10 + (*fieldstr - '0')) , 1)))) {
                size_t len = strspn(num_start, "0123456789");
                char *bad_num = xstrndup(num_start, len);
                if (operating_mode == byte_mode)
                    error(0, 0, gettext("byte offset %s is too large"), quote(bad_num));
                else
                    error(0, 0, gettext("field number %s is too large"), quote(bad_num));
                free(bad_num);
                exit(1);
            }
            fieldstr++;
        } else
            do {
                error(0, 0, (gettext("invalid byte or field list")));
                usage(1);
            } while (0);
    }


BasicTester, a patch instance with id 141:
Spawn 1 instances, now Total 182
Counter: 183
Batcher Size:52
Preprocess the following candidate with BasicTester:
Priority 7465
At location src/cut.c:363
--Src File: src/cut.c
Fragment 0:
initial = (8);
while (1)
    {
        if (*fieldstr == '-') {
            in_digits = 0;
            if (dash_found)
                do {
                    error(0, 0, (gettext("invalid byte or field list")));
                    usage(1);
                } while (0);
            dash_found = 1;
            fieldstr++;
            initial = (lhs_specified ? value : 1);
            value = 0;
        } else if (*fieldstr == ',' || ((*__ctype_b_loc())[(int)((to_uchar(*fieldstr)))] & (unsigned short)_ISblank) || *fieldstr == '\x00') {
            in_digits = 0;
            if (dash_found) {
                dash_found = 0;
                if (!lhs_specified && !rhs_specified)
                    do {
                        error(0, 0, (gettext("invalid range with no endpoint: -")));
                        usage(1);
                    } while (0);
                if (!rhs_specified) {
                    eol_range_start = initial;
                    field_found = 1;
                } else {
                    if (value < initial)
                        do {
                            error(0, 0, (gettext("invalid decreasing range")));
                            usage(1);
                        } while (0);
                    if (eol_range_start != 0) {
                        if (initial < eol_range_start) {
                            if (eol_range_start <= value) {
                                eol_range_start = initial;
                            } else {
                                do {
                                    if (initial == 0 || value == 0)
                                        do {
                                            error(0, 0, (gettext("fields and positions are numbered from 1")));
                                            usage(1);
                                        } while (0);
                                    if (n_rp >= n_rp_allocated) {
                                        (rp) = x2nrealloc(rp, &n_rp_allocated, sizeof *(rp));
                                    }
                                    rp[n_rp].lo = (initial);
                                    rp[n_rp].hi = (value);
                                    ++n_rp;
                                } while (0);
                            }
                            field_found = 1;
                        }
                    } else {
                        do {
                            if (initial == 0 || value == 0)
                                do {
                                    error(0, 0, (gettext("fields and positions are numbered from 1")));
                                    usage(1);
                                } while (0);
                            if (n_rp >= n_rp_allocated) {
                                (rp) = x2nrealloc(rp, &n_rp_allocated, sizeof *(rp));
                            }
                            rp[n_rp].lo = (initial);
                            rp[n_rp].hi = (value);
                            ++n_rp;
                        } while (0);
                        field_found = 1;
                    }
                    value = 0;
                }
            } else {
                do {
                    if (value == 0 || value == 0)
                        do {
                            error(0, 0, (gettext("fields and positions are numbered from 1")));
                            usage(1);
                        } while (0);
                    if (n_rp >= n_rp_allocated) {
                        (rp) = x2nrealloc(rp, &n_rp_allocated, sizeof *(rp));
                    }
                    rp[n_rp].lo = (value);
                    rp[n_rp].hi = (value);
                    ++n_rp;
                } while (0);
                value = 0;
                field_found = 1;
            }
            if (*fieldstr == '\x00') {
                break;
            }
            fieldstr++;
            lhs_specified = 0;
            rhs_specified = 0;
        } else if (((unsigned int)(*fieldstr) - '0' <= 9)) {
            static const char *num_start;
            if (!in_digits || !num_start)
                num_start = fieldstr;
            in_digits = 1;
            if (dash_found)
                rhs_specified = 1;
            else
                lhs_specified = 1;
            if (!((void)(&(value) == (size_t *)((void *)0)) , (((size_t)-1 / 10 < (value) || (size_t)((value) * 10 + (*fieldstr - '0')) < (value)) ? 0 : (((value) = (value) * 10 + (*fieldstr - '0')) , 1)))) {
                size_t len = strspn(num_start, "0123456789");
                char *bad_num = xstrndup(num_start, len);
                if (operating_mode == byte_mode)
                    error(0, 0, gettext("byte offset %s is too large"), quote(bad_num));
                else
                    error(0, 0, gettext("field number %s is too large"), quote(bad_num));
                free(bad_num);
                exit(1);
            }
            fieldstr++;
        } else
            do {
                error(0, 0, (gettext("invalid byte or field list")));
                usage(1);
            } while (0);
    }


BasicTester, a patch instance with id 142:
Spawn 1 instances, now Total 183
a batched test job starts!
Building:src at:
/home/ubuntu/spr-fast/tests/corebench/coreutils/coreutils-case-7380cf79-2e636af1/tempworkdir/srcMerged code building succ, going to invoke tester!
BasicTester, Testing instance id 133:
Running test command:
/home/ubuntu/spr-fast/tools/coreutils-test.py /home/ubuntu/spr-fast/tests/corebench/coreutils/coreutils-case-7380cf79-2e636af1/tempworkdir/src /home/ubuntu/spr-fast/tests/corebench/coreutils/coreutils-case-7380cf79-2e636af1/tempworkdir/tests /home/ubuntu/spr-fast/tests/corebench/coreutils/coreutils-case-7380cf79-2e636af1/tempworkdir 0  > __res
BasicTester, Testing instance id 134:
Running test command:
/home/ubuntu/spr-fast/tools/coreutils-test.py /home/ubuntu/spr-fast/tests/corebench/coreutils/coreutils-case-7380cf79-2e636af1/tempworkdir/src /home/ubuntu/spr-fast/tests/corebench/coreutils/coreutils-case-7380cf79-2e636af1/tempworkdir/tests /home/ubuntu/spr-fast/tests/corebench/coreutils/coreutils-case-7380cf79-2e636af1/tempworkdir 0  > __res
BasicTester, Testing instance id 135:
Running test command:
/home/ubuntu/spr-fast/tools/coreutils-test.py /home/ubuntu/spr-fast/tests/corebench/coreutils/coreutils-case-7380cf79-2e636af1/tempworkdir/src /home/ubuntu/spr-fast/tests/corebench/coreutils/coreutils-case-7380cf79-2e636af1/tempworkdir/tests /home/ubuntu/spr-fast/tests/corebench/coreutils/coreutils-case-7380cf79-2e636af1/tempworkdir 0  > __res
BasicTester, Testing instance id 136:
Running test command:
/home/ubuntu/spr-fast/tools/coreutils-test.py /home/ubuntu/spr-fast/tests/corebench/coreutils/coreutils-case-7380cf79-2e636af1/tempworkdir/src /home/ubuntu/spr-fast/tests/corebench/coreutils/coreutils-case-7380cf79-2e636af1/tempworkdir/tests /home/ubuntu/spr-fast/tests/corebench/coreutils/coreutils-case-7380cf79-2e636af1/tempworkdir 0  > __res
BasicTester, Testing instance id 137:
Running test command:
/home/ubuntu/spr-fast/tools/coreutils-test.py /home/ubuntu/spr-fast/tests/corebench/coreutils/coreutils-case-7380cf79-2e636af1/tempworkdir/src /home/ubuntu/spr-fast/tests/corebench/coreutils/coreutils-case-7380cf79-2e636af1/tempworkdir/tests /home/ubuntu/spr-fast/tests/corebench/coreutils/coreutils-case-7380cf79-2e636af1/tempworkdir 0  > __res
BasicTester, Testing instance id 138:
Running test command:
/home/ubuntu/spr-fast/tools/coreutils-test.py /home/ubuntu/spr-fast/tests/corebench/coreutils/coreutils-case-7380cf79-2e636af1/tempworkdir/src /home/ubuntu/spr-fast/tests/corebench/coreutils/coreutils-case-7380cf79-2e636af1/tempworkdir/tests /home/ubuntu/spr-fast/tests/corebench/coreutils/coreutils-case-7380cf79-2e636af1/tempworkdir 0  > __res
BasicTester, Testing instance id 139:
Running test command:
/home/ubuntu/spr-fast/tools/coreutils-test.py /home/ubuntu/spr-fast/tests/corebench/coreutils/coreutils-case-7380cf79-2e636af1/tempworkdir/src /home/ubuntu/spr-fast/tests/corebench/coreutils/coreutils-case-7380cf79-2e636af1/tempworkdir/tests /home/ubuntu/spr-fast/tests/corebench/coreutils/coreutils-case-7380cf79-2e636af1/tempworkdir 0  > __res
BasicTester, Testing instance id 140:
Running test command:
/home/ubuntu/spr-fast/tools/coreutils-test.py /home/ubuntu/spr-fast/tests/corebench/coreutils/coreutils-case-7380cf79-2e636af1/tempworkdir/src /home/ubuntu/spr-fast/tests/corebench/coreutils/coreutils-case-7380cf79-2e636af1/tempworkdir/tests /home/ubuntu/spr-fast/tests/corebench/coreutils/coreutils-case-7380cf79-2e636af1/tempworkdir 0  > __res
BasicTester, Testing instance id 141:
Running test command:
/home/ubuntu/spr-fast/tools/coreutils-test.py /home/ubuntu/spr-fast/tests/corebench/coreutils/coreutils-case-7380cf79-2e636af1/tempworkdir/src /home/ubuntu/spr-fast/tests/corebench/coreutils/coreutils-case-7380cf79-2e636af1/tempworkdir/tests /home/ubuntu/spr-fast/tests/corebench/coreutils/coreutils-case-7380cf79-2e636af1/tempworkdir 0  > __res
BasicTester, Testing instance id 142:
Running test command:
/home/ubuntu/spr-fast/tools/coreutils-test.py /home/ubuntu/spr-fast/tests/corebench/coreutils/coreutils-case-7380cf79-2e636af1/tempworkdir/src /home/ubuntu/spr-fast/tests/corebench/coreutils/coreutils-case-7380cf79-2e636af1/tempworkdir/tests /home/ubuntu/spr-fast/tests/corebench/coreutils/coreutils-case-7380cf79-2e636af1/tempworkdir 0  > __res
Counter: 184
Batcher Size:43
Preprocess the following candidate with BasicTester:
Priority 7465
At location src/cut.c:363
--Src File: src/cut.c
Fragment 0:
in_digits = (rhs_specified);
while (1)
    {
        if (*fieldstr == '-') {
            in_digits = 0;
            if (dash_found)
                do {
                    error(0, 0, (gettext("invalid byte or field list")));
                    usage(1);
                } while (0);
            dash_found = 1;
            fieldstr++;
            initial = (lhs_specified ? value : 1);
            value = 0;
        } else if (*fieldstr == ',' || ((*__ctype_b_loc())[(int)((to_uchar(*fieldstr)))] & (unsigned short)_ISblank) || *fieldstr == '\x00') {
            in_digits = 0;
            if (dash_found) {
                dash_found = 0;
                if (!lhs_specified && !rhs_specified)
                    do {
                        error(0, 0, (gettext("invalid range with no endpoint: -")));
                        usage(1);
                    } while (0);
                if (!rhs_specified) {
                    eol_range_start = initial;
                    field_found = 1;
                } else {
                    if (value < initial)
                        do {
                            error(0, 0, (gettext("invalid decreasing range")));
                            usage(1);
                        } while (0);
                    if (eol_range_start != 0) {
                        if (initial < eol_range_start) {
                            if (eol_range_start <= value) {
                                eol_range_start = initial;
                            } else {
                                do {
                                    if (initial == 0 || value == 0)
                                        do {
                                            error(0, 0, (gettext("fields and positions are numbered from 1")));
                                            usage(1);
                                        } while (0);
                                    if (n_rp >= n_rp_allocated) {
                                        (rp) = x2nrealloc(rp, &n_rp_allocated, sizeof *(rp));
                                    }
                                    rp[n_rp].lo = (initial);
                                    rp[n_rp].hi = (value);
                                    ++n_rp;
                                } while (0);
                            }
                            field_found = 1;
                        }
                    } else {
                        do {
                            if (initial == 0 || value == 0)
                                do {
                                    error(0, 0, (gettext("fields and positions are numbered from 1")));
                                    usage(1);
                                } while (0);
                            if (n_rp >= n_rp_allocated) {
                                (rp) = x2nrealloc(rp, &n_rp_allocated, sizeof *(rp));
                            }
                            rp[n_rp].lo = (initial);
                            rp[n_rp].hi = (value);
                            ++n_rp;
                        } while (0);
                        field_found = 1;
                    }
                    value = 0;
                }
            } else {
                do {
                    if (value == 0 || value == 0)
                        do {
                            error(0, 0, (gettext("fields and positions are numbered from 1")));
                            usage(1);
                        } while (0);
                    if (n_rp >= n_rp_allocated) {
                        (rp) = x2nrealloc(rp, &n_rp_allocated, sizeof *(rp));
                    }
                    rp[n_rp].lo = (value);
                    rp[n_rp].hi = (value);
                    ++n_rp;
                } while (0);
                value = 0;
                field_found = 1;
            }
            if (*fieldstr == '\x00') {
                break;
            }
            fieldstr++;
            lhs_specified = 0;
            rhs_specified = 0;
        } else if (((unsigned int)(*fieldstr) - '0' <= 9)) {
            static const char *num_start;
            if (!in_digits || !num_start)
                num_start = fieldstr;
            in_digits = 1;
            if (dash_found)
                rhs_specified = 1;
            else
                lhs_specified = 1;
            if (!((void)(&(value) == (size_t *)((void *)0)) , (((size_t)-1 / 10 < (value) || (size_t)((value) * 10 + (*fieldstr - '0')) < (value)) ? 0 : (((value) = (value) * 10 + (*fieldstr - '0')) , 1)))) {
                size_t len = strspn(num_start, "0123456789");
                char *bad_num = xstrndup(num_start, len);
                if (operating_mode == byte_mode)
                    error(0, 0, gettext("byte offset %s is too large"), quote(bad_num));
                else
                    error(0, 0, gettext("field number %s is too large"), quote(bad_num));
                free(bad_num);
                exit(1);
            }
            fieldstr++;
        } else
            do {
                error(0, 0, (gettext("invalid byte or field list")));
                usage(1);
            } while (0);
    }


BasicTester, a patch instance with id 143:
Spawn 1 instances, now Total 184
Counter: 185
Batcher Size:44
Preprocess the following candidate with BasicTester:
Priority 7465
At location src/cut.c:363
--Src File: src/cut.c
Fragment 0:
in_digits = 1;
while (1)
    {
        if (*fieldstr == '-') {
            in_digits = 0;
            if (dash_found)
                do {
                    error(0, 0, (gettext("invalid byte or field list")));
                    usage(1);
                } while (0);
            dash_found = 1;
            fieldstr++;
            initial = (lhs_specified ? value : 1);
            value = 0;
        } else if (*fieldstr == ',' || ((*__ctype_b_loc())[(int)((to_uchar(*fieldstr)))] & (unsigned short)_ISblank) || *fieldstr == '\x00') {
            in_digits = 0;
            if (dash_found) {
                dash_found = 0;
                if (!lhs_specified && !rhs_specified)
                    do {
                        error(0, 0, (gettext("invalid range with no endpoint: -")));
                        usage(1);
                    } while (0);
                if (!rhs_specified) {
                    eol_range_start = initial;
                    field_found = 1;
                } else {
                    if (value < initial)
                        do {
                            error(0, 0, (gettext("invalid decreasing range")));
                            usage(1);
                        } while (0);
                    if (eol_range_start != 0) {
                        if (initial < eol_range_start) {
                            if (eol_range_start <= value) {
                                eol_range_start = initial;
                            } else {
                                do {
                                    if (initial == 0 || value == 0)
                                        do {
                                            error(0, 0, (gettext("fields and positions are numbered from 1")));
                                            usage(1);
                                        } while (0);
                                    if (n_rp >= n_rp_allocated) {
                                        (rp) = x2nrealloc(rp, &n_rp_allocated, sizeof *(rp));
                                    }
                                    rp[n_rp].lo = (initial);
                                    rp[n_rp].hi = (value);
                                    ++n_rp;
                                } while (0);
                            }
                            field_found = 1;
                        }
                    } else {
                        do {
                            if (initial == 0 || value == 0)
                                do {
                                    error(0, 0, (gettext("fields and positions are numbered from 1")));
                                    usage(1);
                                } while (0);
                            if (n_rp >= n_rp_allocated) {
                                (rp) = x2nrealloc(rp, &n_rp_allocated, sizeof *(rp));
                            }
                            rp[n_rp].lo = (initial);
                            rp[n_rp].hi = (value);
                            ++n_rp;
                        } while (0);
                        field_found = 1;
                    }
                    value = 0;
                }
            } else {
                do {
                    if (value == 0 || value == 0)
                        do {
                            error(0, 0, (gettext("fields and positions are numbered from 1")));
                            usage(1);
                        } while (0);
                    if (n_rp >= n_rp_allocated) {
                        (rp) = x2nrealloc(rp, &n_rp_allocated, sizeof *(rp));
                    }
                    rp[n_rp].lo = (value);
                    rp[n_rp].hi = (value);
                    ++n_rp;
                } while (0);
                value = 0;
                field_found = 1;
            }
            if (*fieldstr == '\x00') {
                break;
            }
            fieldstr++;
            lhs_specified = 0;
            rhs_specified = 0;
        } else if (((unsigned int)(*fieldstr) - '0' <= 9)) {
            static const char *num_start;
            if (!in_digits || !num_start)
                num_start = fieldstr;
            in_digits = 1;
            if (dash_found)
                rhs_specified = 1;
            else
                lhs_specified = 1;
            if (!((void)(&(value) == (size_t *)((void *)0)) , (((size_t)-1 / 10 < (value) || (size_t)((value) * 10 + (*fieldstr - '0')) < (value)) ? 0 : (((value) = (value) * 10 + (*fieldstr - '0')) , 1)))) {
                size_t len = strspn(num_start, "0123456789");
                char *bad_num = xstrndup(num_start, len);
                if (operating_mode == byte_mode)
                    error(0, 0, gettext("byte offset %s is too large"), quote(bad_num));
                else
                    error(0, 0, gettext("field number %s is too large"), quote(bad_num));
                free(bad_num);
                exit(1);
            }
            fieldstr++;
        } else
            do {
                error(0, 0, (gettext("invalid byte or field list")));
                usage(1);
            } while (0);
    }


BasicTester, a patch instance with id 144:
Spawn 1 instances, now Total 185
Counter: 186
Batcher Size:45
Preprocess the following candidate with BasicTester:
Priority 7465
At location src/cut.c:363
--Src File: src/cut.c
Fragment 0:
initial = (0);
while (1)
    {
        if (*fieldstr == '-') {
            in_digits = 0;
            if (dash_found)
                do {
                    error(0, 0, (gettext("invalid byte or field list")));
                    usage(1);
                } while (0);
            dash_found = 1;
            fieldstr++;
            initial = (lhs_specified ? value : 1);
            value = 0;
        } else if (*fieldstr == ',' || ((*__ctype_b_loc())[(int)((to_uchar(*fieldstr)))] & (unsigned short)_ISblank) || *fieldstr == '\x00') {
            in_digits = 0;
            if (dash_found) {
                dash_found = 0;
                if (!lhs_specified && !rhs_specified)
                    do {
                        error(0, 0, (gettext("invalid range with no endpoint: -")));
                        usage(1);
                    } while (0);
                if (!rhs_specified) {
                    eol_range_start = initial;
                    field_found = 1;
                } else {
                    if (value < initial)
                        do {
                            error(0, 0, (gettext("invalid decreasing range")));
                            usage(1);
                        } while (0);
                    if (eol_range_start != 0) {
                        if (initial < eol_range_start) {
                            if (eol_range_start <= value) {
                                eol_range_start = initial;
                            } else {
                                do {
                                    if (initial == 0 || value == 0)
                                        do {
                                            error(0, 0, (gettext("fields and positions are numbered from 1")));
                                            usage(1);
                                        } while (0);
                                    if (n_rp >= n_rp_allocated) {
                                        (rp) = x2nrealloc(rp, &n_rp_allocated, sizeof *(rp));
                                    }
                                    rp[n_rp].lo = (initial);
                                    rp[n_rp].hi = (value);
                                    ++n_rp;
                                } while (0);
                            }
                            field_found = 1;
                        }
                    } else {
                        do {
                            if (initial == 0 || value == 0)
                                do {
                                    error(0, 0, (gettext("fields and positions are numbered from 1")));
                                    usage(1);
                                } while (0);
                            if (n_rp >= n_rp_allocated) {
                                (rp) = x2nrealloc(rp, &n_rp_allocated, sizeof *(rp));
                            }
                            rp[n_rp].lo = (initial);
                            rp[n_rp].hi = (value);
                            ++n_rp;
                        } while (0);
                        field_found = 1;
                    }
                    value = 0;
                }
            } else {
                do {
                    if (value == 0 || value == 0)
                        do {
                            error(0, 0, (gettext("fields and positions are numbered from 1")));
                            usage(1);
                        } while (0);
                    if (n_rp >= n_rp_allocated) {
                        (rp) = x2nrealloc(rp, &n_rp_allocated, sizeof *(rp));
                    }
                    rp[n_rp].lo = (value);
                    rp[n_rp].hi = (value);
                    ++n_rp;
                } while (0);
                value = 0;
                field_found = 1;
            }
            if (*fieldstr == '\x00') {
                break;
            }
            fieldstr++;
            lhs_specified = 0;
            rhs_specified = 0;
        } else if (((unsigned int)(*fieldstr) - '0' <= 9)) {
            static const char *num_start;
            if (!in_digits || !num_start)
                num_start = fieldstr;
            in_digits = 1;
            if (dash_found)
                rhs_specified = 1;
            else
                lhs_specified = 1;
            if (!((void)(&(value) == (size_t *)((void *)0)) , (((size_t)-1 / 10 < (value) || (size_t)((value) * 10 + (*fieldstr - '0')) < (value)) ? 0 : (((value) = (value) * 10 + (*fieldstr - '0')) , 1)))) {
                size_t len = strspn(num_start, "0123456789");
                char *bad_num = xstrndup(num_start, len);
                if (operating_mode == byte_mode)
                    error(0, 0, gettext("byte offset %s is too large"), quote(bad_num));
                else
                    error(0, 0, gettext("field number %s is too large"), quote(bad_num));
                free(bad_num);
                exit(1);
            }
            fieldstr++;
        } else
            do {
                error(0, 0, (gettext("invalid byte or field list")));
                usage(1);
            } while (0);
    }


BasicTester, a patch instance with id 145:
Spawn 1 instances, now Total 186
Counter: 187
Batcher Size:46
Preprocess the following candidate with BasicTester:
Priority 7465
At location src/cut.c:363
--Src File: src/cut.c
Fragment 0:
initial = (1);
while (1)
    {
        if (*fieldstr == '-') {
            in_digits = 0;
            if (dash_found)
                do {
                    error(0, 0, (gettext("invalid byte or field list")));
                    usage(1);
                } while (0);
            dash_found = 1;
            fieldstr++;
            initial = (lhs_specified ? value : 1);
            value = 0;
        } else if (*fieldstr == ',' || ((*__ctype_b_loc())[(int)((to_uchar(*fieldstr)))] & (unsigned short)_ISblank) || *fieldstr == '\x00') {
            in_digits = 0;
            if (dash_found) {
                dash_found = 0;
                if (!lhs_specified && !rhs_specified)
                    do {
                        error(0, 0, (gettext("invalid range with no endpoint: -")));
                        usage(1);
                    } while (0);
                if (!rhs_specified) {
                    eol_range_start = initial;
                    field_found = 1;
                } else {
                    if (value < initial)
                        do {
                            error(0, 0, (gettext("invalid decreasing range")));
                            usage(1);
                        } while (0);
                    if (eol_range_start != 0) {
                        if (initial < eol_range_start) {
                            if (eol_range_start <= value) {
                                eol_range_start = initial;
                            } else {
                                do {
                                    if (initial == 0 || value == 0)
                                        do {
                                            error(0, 0, (gettext("fields and positions are numbered from 1")));
                                            usage(1);
                                        } while (0);
                                    if (n_rp >= n_rp_allocated) {
                                        (rp) = x2nrealloc(rp, &n_rp_allocated, sizeof *(rp));
                                    }
                                    rp[n_rp].lo = (initial);
                                    rp[n_rp].hi = (value);
                                    ++n_rp;
                                } while (0);
                            }
                            field_found = 1;
                        }
                    } else {
                        do {
                            if (initial == 0 || value == 0)
                                do {
                                    error(0, 0, (gettext("fields and positions are numbered from 1")));
                                    usage(1);
                                } while (0);
                            if (n_rp >= n_rp_allocated) {
                                (rp) = x2nrealloc(rp, &n_rp_allocated, sizeof *(rp));
                            }
                            rp[n_rp].lo = (initial);
                            rp[n_rp].hi = (value);
                            ++n_rp;
                        } while (0);
                        field_found = 1;
                    }
                    value = 0;
                }
            } else {
                do {
                    if (value == 0 || value == 0)
                        do {
                            error(0, 0, (gettext("fields and positions are numbered from 1")));
                            usage(1);
                        } while (0);
                    if (n_rp >= n_rp_allocated) {
                        (rp) = x2nrealloc(rp, &n_rp_allocated, sizeof *(rp));
                    }
                    rp[n_rp].lo = (value);
                    rp[n_rp].hi = (value);
                    ++n_rp;
                } while (0);
                value = 0;
                field_found = 1;
            }
            if (*fieldstr == '\x00') {
                break;
            }
            fieldstr++;
            lhs_specified = 0;
            rhs_specified = 0;
        } else if (((unsigned int)(*fieldstr) - '0' <= 9)) {
            static const char *num_start;
            if (!in_digits || !num_start)
                num_start = fieldstr;
            in_digits = 1;
            if (dash_found)
                rhs_specified = 1;
            else
                lhs_specified = 1;
            if (!((void)(&(value) == (size_t *)((void *)0)) , (((size_t)-1 / 10 < (value) || (size_t)((value) * 10 + (*fieldstr - '0')) < (value)) ? 0 : (((value) = (value) * 10 + (*fieldstr - '0')) , 1)))) {
                size_t len = strspn(num_start, "0123456789");
                char *bad_num = xstrndup(num_start, len);
                if (operating_mode == byte_mode)
                    error(0, 0, gettext("byte offset %s is too large"), quote(bad_num));
                else
                    error(0, 0, gettext("field number %s is too large"), quote(bad_num));
                free(bad_num);
                exit(1);
            }
            fieldstr++;
        } else
            do {
                error(0, 0, (gettext("invalid byte or field list")));
                usage(1);
            } while (0);
    }


BasicTester, a patch instance with id 146:
Spawn 1 instances, now Total 187
Counter: 188
Batcher Size:47
Preprocess the following candidate with BasicTester:
Priority 7465
At location src/cut.c:363
--Src File: src/cut.c
Fragment 0:
initial = (-1);
while (1)
    {
        if (*fieldstr == '-') {
            in_digits = 0;
            if (dash_found)
                do {
                    error(0, 0, (gettext("invalid byte or field list")));
                    usage(1);
                } while (0);
            dash_found = 1;
            fieldstr++;
            initial = (lhs_specified ? value : 1);
            value = 0;
        } else if (*fieldstr == ',' || ((*__ctype_b_loc())[(int)((to_uchar(*fieldstr)))] & (unsigned short)_ISblank) || *fieldstr == '\x00') {
            in_digits = 0;
            if (dash_found) {
                dash_found = 0;
                if (!lhs_specified && !rhs_specified)
                    do {
                        error(0, 0, (gettext("invalid range with no endpoint: -")));
                        usage(1);
                    } while (0);
                if (!rhs_specified) {
                    eol_range_start = initial;
                    field_found = 1;
                } else {
                    if (value < initial)
                        do {
                            error(0, 0, (gettext("invalid decreasing range")));
                            usage(1);
                        } while (0);
                    if (eol_range_start != 0) {
                        if (initial < eol_range_start) {
                            if (eol_range_start <= value) {
                                eol_range_start = initial;
                            } else {
                                do {
                                    if (initial == 0 || value == 0)
                                        do {
                                            error(0, 0, (gettext("fields and positions are numbered from 1")));
                                            usage(1);
                                        } while (0);
                                    if (n_rp >= n_rp_allocated) {
                                        (rp) = x2nrealloc(rp, &n_rp_allocated, sizeof *(rp));
                                    }
                                    rp[n_rp].lo = (initial);
                                    rp[n_rp].hi = (value);
                                    ++n_rp;
                                } while (0);
                            }
                            field_found = 1;
                        }
                    } else {
                        do {
                            if (initial == 0 || value == 0)
                                do {
                                    error(0, 0, (gettext("fields and positions are numbered from 1")));
                                    usage(1);
                                } while (0);
                            if (n_rp >= n_rp_allocated) {
                                (rp) = x2nrealloc(rp, &n_rp_allocated, sizeof *(rp));
                            }
                            rp[n_rp].lo = (initial);
                            rp[n_rp].hi = (value);
                            ++n_rp;
                        } while (0);
                        field_found = 1;
                    }
                    value = 0;
                }
            } else {
                do {
                    if (value == 0 || value == 0)
                        do {
                            error(0, 0, (gettext("fields and positions are numbered from 1")));
                            usage(1);
                        } while (0);
                    if (n_rp >= n_rp_allocated) {
                        (rp) = x2nrealloc(rp, &n_rp_allocated, sizeof *(rp));
                    }
                    rp[n_rp].lo = (value);
                    rp[n_rp].hi = (value);
                    ++n_rp;
                } while (0);
                value = 0;
                field_found = 1;
            }
            if (*fieldstr == '\x00') {
                break;
            }
            fieldstr++;
            lhs_specified = 0;
            rhs_specified = 0;
        } else if (((unsigned int)(*fieldstr) - '0' <= 9)) {
            static const char *num_start;
            if (!in_digits || !num_start)
                num_start = fieldstr;
            in_digits = 1;
            if (dash_found)
                rhs_specified = 1;
            else
                lhs_specified = 1;
            if (!((void)(&(value) == (size_t *)((void *)0)) , (((size_t)-1 / 10 < (value) || (size_t)((value) * 10 + (*fieldstr - '0')) < (value)) ? 0 : (((value) = (value) * 10 + (*fieldstr - '0')) , 1)))) {
                size_t len = strspn(num_start, "0123456789");
                char *bad_num = xstrndup(num_start, len);
                if (operating_mode == byte_mode)
                    error(0, 0, gettext("byte offset %s is too large"), quote(bad_num));
                else
                    error(0, 0, gettext("field number %s is too large"), quote(bad_num));
                free(bad_num);
                exit(1);
            }
            fieldstr++;
        } else
            do {
                error(0, 0, (gettext("invalid byte or field list")));
                usage(1);
            } while (0);
    }


BasicTester, a patch instance with id 147:
Spawn 1 instances, now Total 188
Counter: 189
Batcher Size:48
Preprocess the following candidate with BasicTester:
Priority 7465
At location src/cut.c:363
--Src File: src/cut.c
Fragment 0:
in_digits = 0;
while (1)
    {
        if (*fieldstr == '-') {
            in_digits = 0;
            if (dash_found)
                do {
                    error(0, 0, (gettext("invalid byte or field list")));
                    usage(1);
                } while (0);
            dash_found = 1;
            fieldstr++;
            initial = (lhs_specified ? value : 1);
            value = 0;
        } else if (*fieldstr == ',' || ((*__ctype_b_loc())[(int)((to_uchar(*fieldstr)))] & (unsigned short)_ISblank) || *fieldstr == '\x00') {
            in_digits = 0;
            if (dash_found) {
                dash_found = 0;
                if (!lhs_specified && !rhs_specified)
                    do {
                        error(0, 0, (gettext("invalid range with no endpoint: -")));
                        usage(1);
                    } while (0);
                if (!rhs_specified) {
                    eol_range_start = initial;
                    field_found = 1;
                } else {
                    if (value < initial)
                        do {
                            error(0, 0, (gettext("invalid decreasing range")));
                            usage(1);
                        } while (0);
                    if (eol_range_start != 0) {
                        if (initial < eol_range_start) {
                            if (eol_range_start <= value) {
                                eol_range_start = initial;
                            } else {
                                do {
                                    if (initial == 0 || value == 0)
                                        do {
                                            error(0, 0, (gettext("fields and positions are numbered from 1")));
                                            usage(1);
                                        } while (0);
                                    if (n_rp >= n_rp_allocated) {
                                        (rp) = x2nrealloc(rp, &n_rp_allocated, sizeof *(rp));
                                    }
                                    rp[n_rp].lo = (initial);
                                    rp[n_rp].hi = (value);
                                    ++n_rp;
                                } while (0);
                            }
                            field_found = 1;
                        }
                    } else {
                        do {
                            if (initial == 0 || value == 0)
                                do {
                                    error(0, 0, (gettext("fields and positions are numbered from 1")));
                                    usage(1);
                                } while (0);
                            if (n_rp >= n_rp_allocated) {
                                (rp) = x2nrealloc(rp, &n_rp_allocated, sizeof *(rp));
                            }
                            rp[n_rp].lo = (initial);
                            rp[n_rp].hi = (value);
                            ++n_rp;
                        } while (0);
                        field_found = 1;
                    }
                    value = 0;
                }
            } else {
                do {
                    if (value == 0 || value == 0)
                        do {
                            error(0, 0, (gettext("fields and positions are numbered from 1")));
                            usage(1);
                        } while (0);
                    if (n_rp >= n_rp_allocated) {
                        (rp) = x2nrealloc(rp, &n_rp_allocated, sizeof *(rp));
                    }
                    rp[n_rp].lo = (value);
                    rp[n_rp].hi = (value);
                    ++n_rp;
                } while (0);
                value = 0;
                field_found = 1;
            }
            if (*fieldstr == '\x00') {
                break;
            }
            fieldstr++;
            lhs_specified = 0;
            rhs_specified = 0;
        } else if (((unsigned int)(*fieldstr) - '0' <= 9)) {
            static const char *num_start;
            if (!in_digits || !num_start)
                num_start = fieldstr;
            in_digits = 1;
            if (dash_found)
                rhs_specified = 1;
            else
                lhs_specified = 1;
            if (!((void)(&(value) == (size_t *)((void *)0)) , (((size_t)-1 / 10 < (value) || (size_t)((value) * 10 + (*fieldstr - '0')) < (value)) ? 0 : (((value) = (value) * 10 + (*fieldstr - '0')) , 1)))) {
                size_t len = strspn(num_start, "0123456789");
                char *bad_num = xstrndup(num_start, len);
                if (operating_mode == byte_mode)
                    error(0, 0, gettext("byte offset %s is too large"), quote(bad_num));
                else
                    error(0, 0, gettext("field number %s is too large"), quote(bad_num));
                free(bad_num);
                exit(1);
            }
            fieldstr++;
        } else
            do {
                error(0, 0, (gettext("invalid byte or field list")));
                usage(1);
            } while (0);
    }


BasicTester, a patch instance with id 148:
Spawn 1 instances, now Total 189
Counter: 190
Batcher Size:49
Preprocess the following candidate with BasicTester:
Priority 7465
At location src/cut.c:363
--Src File: src/cut.c
Fragment 0:
have_read_stdin = 0;
while (1)
    {
        if (*fieldstr == '-') {
            in_digits = 0;
            if (dash_found)
                do {
                    error(0, 0, (gettext("invalid byte or field list")));
                    usage(1);
                } while (0);
            dash_found = 1;
            fieldstr++;
            initial = (lhs_specified ? value : 1);
            value = 0;
        } else if (*fieldstr == ',' || ((*__ctype_b_loc())[(int)((to_uchar(*fieldstr)))] & (unsigned short)_ISblank) || *fieldstr == '\x00') {
            in_digits = 0;
            if (dash_found) {
                dash_found = 0;
                if (!lhs_specified && !rhs_specified)
                    do {
                        error(0, 0, (gettext("invalid range with no endpoint: -")));
                        usage(1);
                    } while (0);
                if (!rhs_specified) {
                    eol_range_start = initial;
                    field_found = 1;
                } else {
                    if (value < initial)
                        do {
                            error(0, 0, (gettext("invalid decreasing range")));
                            usage(1);
                        } while (0);
                    if (eol_range_start != 0) {
                        if (initial < eol_range_start) {
                            if (eol_range_start <= value) {
                                eol_range_start = initial;
                            } else {
                                do {
                                    if (initial == 0 || value == 0)
                                        do {
                                            error(0, 0, (gettext("fields and positions are numbered from 1")));
                                            usage(1);
                                        } while (0);
                                    if (n_rp >= n_rp_allocated) {
                                        (rp) = x2nrealloc(rp, &n_rp_allocated, sizeof *(rp));
                                    }
                                    rp[n_rp].lo = (initial);
                                    rp[n_rp].hi = (value);
                                    ++n_rp;
                                } while (0);
                            }
                            field_found = 1;
                        }
                    } else {
                        do {
                            if (initial == 0 || value == 0)
                                do {
                                    error(0, 0, (gettext("fields and positions are numbered from 1")));
                                    usage(1);
                                } while (0);
                            if (n_rp >= n_rp_allocated) {
                                (rp) = x2nrealloc(rp, &n_rp_allocated, sizeof *(rp));
                            }
                            rp[n_rp].lo = (initial);
                            rp[n_rp].hi = (value);
                            ++n_rp;
                        } while (0);
                        field_found = 1;
                    }
                    value = 0;
                }
            } else {
                do {
                    if (value == 0 || value == 0)
                        do {
                            error(0, 0, (gettext("fields and positions are numbered from 1")));
                            usage(1);
                        } while (0);
                    if (n_rp >= n_rp_allocated) {
                        (rp) = x2nrealloc(rp, &n_rp_allocated, sizeof *(rp));
                    }
                    rp[n_rp].lo = (value);
                    rp[n_rp].hi = (value);
                    ++n_rp;
                } while (0);
                value = 0;
                field_found = 1;
            }
            if (*fieldstr == '\x00') {
                break;
            }
            fieldstr++;
            lhs_specified = 0;
            rhs_specified = 0;
        } else if (((unsigned int)(*fieldstr) - '0' <= 9)) {
            static const char *num_start;
            if (!in_digits || !num_start)
                num_start = fieldstr;
            in_digits = 1;
            if (dash_found)
                rhs_specified = 1;
            else
                lhs_specified = 1;
            if (!((void)(&(value) == (size_t *)((void *)0)) , (((size_t)-1 / 10 < (value) || (size_t)((value) * 10 + (*fieldstr - '0')) < (value)) ? 0 : (((value) = (value) * 10 + (*fieldstr - '0')) , 1)))) {
                size_t len = strspn(num_start, "0123456789");
                char *bad_num = xstrndup(num_start, len);
                if (operating_mode == byte_mode)
                    error(0, 0, gettext("byte offset %s is too large"), quote(bad_num));
                else
                    error(0, 0, gettext("field number %s is too large"), quote(bad_num));
                free(bad_num);
                exit(1);
            }
            fieldstr++;
        } else
            do {
                error(0, 0, (gettext("invalid byte or field list")));
                usage(1);
            } while (0);
    }


BasicTester, a patch instance with id 149:
Spawn 1 instances, now Total 190
Counter: 191
Batcher Size:50
Preprocess the following candidate with BasicTester:
Priority 7465
At location src/cut.c:363
--Src File: src/cut.c
Fragment 0:
if (output_delimiter_specified) {
}
while (1)
    {
        if (*fieldstr == '-') {
            in_digits = 0;
            if (dash_found)
                do {
                    error(0, 0, (gettext("invalid byte or field list")));
                    usage(1);
                } while (0);
            dash_found = 1;
            fieldstr++;
            initial = (lhs_specified ? value : 1);
            value = 0;
        } else if (*fieldstr == ',' || ((*__ctype_b_loc())[(int)((to_uchar(*fieldstr)))] & (unsigned short)_ISblank) || *fieldstr == '\x00') {
            in_digits = 0;
            if (dash_found) {
                dash_found = 0;
                if (!lhs_specified && !rhs_specified)
                    do {
                        error(0, 0, (gettext("invalid range with no endpoint: -")));
                        usage(1);
                    } while (0);
                if (!rhs_specified) {
                    eol_range_start = initial;
                    field_found = 1;
                } else {
                    if (value < initial)
                        do {
                            error(0, 0, (gettext("invalid decreasing range")));
                            usage(1);
                        } while (0);
                    if (eol_range_start != 0) {
                        if (initial < eol_range_start) {
                            if (eol_range_start <= value) {
                                eol_range_start = initial;
                            } else {
                                do {
                                    if (initial == 0 || value == 0)
                                        do {
                                            error(0, 0, (gettext("fields and positions are numbered from 1")));
                                            usage(1);
                                        } while (0);
                                    if (n_rp >= n_rp_allocated) {
                                        (rp) = x2nrealloc(rp, &n_rp_allocated, sizeof *(rp));
                                    }
                                    rp[n_rp].lo = (initial);
                                    rp[n_rp].hi = (value);
                                    ++n_rp;
                                } while (0);
                            }
                            field_found = 1;
                        }
                    } else {
                        do {
                            if (initial == 0 || value == 0)
                                do {
                                    error(0, 0, (gettext("fields and positions are numbered from 1")));
                                    usage(1);
                                } while (0);
                            if (n_rp >= n_rp_allocated) {
                                (rp) = x2nrealloc(rp, &n_rp_allocated, sizeof *(rp));
                            }
                            rp[n_rp].lo = (initial);
                            rp[n_rp].hi = (value);
                            ++n_rp;
                        } while (0);
                        field_found = 1;
                    }
                    value = 0;
                }
            } else {
                do {
                    if (value == 0 || value == 0)
                        do {
                            error(0, 0, (gettext("fields and positions are numbered from 1")));
                            usage(1);
                        } while (0);
                    if (n_rp >= n_rp_allocated) {
                        (rp) = x2nrealloc(rp, &n_rp_allocated, sizeof *(rp));
                    }
                    rp[n_rp].lo = (value);
                    rp[n_rp].hi = (value);
                    ++n_rp;
                } while (0);
                value = 0;
                field_found = 1;
            }
            if (*fieldstr == '\x00') {
                break;
            }
            fieldstr++;
            lhs_specified = 0;
            rhs_specified = 0;
        } else if (((unsigned int)(*fieldstr) - '0' <= 9)) {
            static const char *num_start;
            if (!in_digits || !num_start)
                num_start = fieldstr;
            in_digits = 1;
            if (dash_found)
                rhs_specified = 1;
            else
                lhs_specified = 1;
            if (!((void)(&(value) == (size_t *)((void *)0)) , (((size_t)-1 / 10 < (value) || (size_t)((value) * 10 + (*fieldstr - '0')) < (value)) ? 0 : (((value) = (value) * 10 + (*fieldstr - '0')) , 1)))) {
                size_t len = strspn(num_start, "0123456789");
                char *bad_num = xstrndup(num_start, len);
                if (operating_mode == byte_mode)
                    error(0, 0, gettext("byte offset %s is too large"), quote(bad_num));
                else
                    error(0, 0, gettext("field number %s is too large"), quote(bad_num));
                free(bad_num);
                exit(1);
            }
            fieldstr++;
        } else
            do {
                error(0, 0, (gettext("invalid byte or field list")));
                usage(1);
            } while (0);
    }


BasicTester, a patch instance with id 150:
Spawn 1 instances, now Total 191
Counter: 192
Batcher Size:51
Preprocess the following candidate with BasicTester:
Priority 7465
At location src/cut.c:363
--Src File: src/cut.c
Fragment 0:
in_digits = (dash_found);
while (1)
    {
        if (*fieldstr == '-') {
            in_digits = 0;
            if (dash_found)
                do {
                    error(0, 0, (gettext("invalid byte or field list")));
                    usage(1);
                } while (0);
            dash_found = 1;
            fieldstr++;
            initial = (lhs_specified ? value : 1);
            value = 0;
        } else if (*fieldstr == ',' || ((*__ctype_b_loc())[(int)((to_uchar(*fieldstr)))] & (unsigned short)_ISblank) || *fieldstr == '\x00') {
            in_digits = 0;
            if (dash_found) {
                dash_found = 0;
                if (!lhs_specified && !rhs_specified)
                    do {
                        error(0, 0, (gettext("invalid range with no endpoint: -")));
                        usage(1);
                    } while (0);
                if (!rhs_specified) {
                    eol_range_start = initial;
                    field_found = 1;
                } else {
                    if (value < initial)
                        do {
                            error(0, 0, (gettext("invalid decreasing range")));
                            usage(1);
                        } while (0);
                    if (eol_range_start != 0) {
                        if (initial < eol_range_start) {
                            if (eol_range_start <= value) {
                                eol_range_start = initial;
                            } else {
                                do {
                                    if (initial == 0 || value == 0)
                                        do {
                                            error(0, 0, (gettext("fields and positions are numbered from 1")));
                                            usage(1);
                                        } while (0);
                                    if (n_rp >= n_rp_allocated) {
                                        (rp) = x2nrealloc(rp, &n_rp_allocated, sizeof *(rp));
                                    }
                                    rp[n_rp].lo = (initial);
                                    rp[n_rp].hi = (value);
                                    ++n_rp;
                                } while (0);
                            }
                            field_found = 1;
                        }
                    } else {
                        do {
                            if (initial == 0 || value == 0)
                                do {
                                    error(0, 0, (gettext("fields and positions are numbered from 1")));
                                    usage(1);
                                } while (0);
                            if (n_rp >= n_rp_allocated) {
                                (rp) = x2nrealloc(rp, &n_rp_allocated, sizeof *(rp));
                            }
                            rp[n_rp].lo = (initial);
                            rp[n_rp].hi = (value);
                            ++n_rp;
                        } while (0);
                        field_found = 1;
                    }
                    value = 0;
                }
            } else {
                do {
                    if (value == 0 || value == 0)
                        do {
                            error(0, 0, (gettext("fields and positions are numbered from 1")));
                            usage(1);
                        } while (0);
                    if (n_rp >= n_rp_allocated) {
                        (rp) = x2nrealloc(rp, &n_rp_allocated, sizeof *(rp));
                    }
                    rp[n_rp].lo = (value);
                    rp[n_rp].hi = (value);
                    ++n_rp;
                } while (0);
                value = 0;
                field_found = 1;
            }
            if (*fieldstr == '\x00') {
                break;
            }
            fieldstr++;
            lhs_specified = 0;
            rhs_specified = 0;
        } else if (((unsigned int)(*fieldstr) - '0' <= 9)) {
            static const char *num_start;
            if (!in_digits || !num_start)
                num_start = fieldstr;
            in_digits = 1;
            if (dash_found)
                rhs_specified = 1;
            else
                lhs_specified = 1;
            if (!((void)(&(value) == (size_t *)((void *)0)) , (((size_t)-1 / 10 < (value) || (size_t)((value) * 10 + (*fieldstr - '0')) < (value)) ? 0 : (((value) = (value) * 10 + (*fieldstr - '0')) , 1)))) {
                size_t len = strspn(num_start, "0123456789");
                char *bad_num = xstrndup(num_start, len);
                if (operating_mode == byte_mode)
                    error(0, 0, gettext("byte offset %s is too large"), quote(bad_num));
                else
                    error(0, 0, gettext("field number %s is too large"), quote(bad_num));
                free(bad_num);
                exit(1);
            }
            fieldstr++;
        } else
            do {
                error(0, 0, (gettext("invalid byte or field list")));
                usage(1);
            } while (0);
    }


BasicTester, a patch instance with id 151:
Spawn 1 instances, now Total 192
Counter: 193
Batcher Size:52
Preprocess the following candidate with BasicTester:
Priority 7465
At location src/cut.c:363
--Src File: src/cut.c
Fragment 0:
in_digits = (field_found);
while (1)
    {
        if (*fieldstr == '-') {
            in_digits = 0;
            if (dash_found)
                do {
                    error(0, 0, (gettext("invalid byte or field list")));
                    usage(1);
                } while (0);
            dash_found = 1;
            fieldstr++;
            initial = (lhs_specified ? value : 1);
            value = 0;
        } else if (*fieldstr == ',' || ((*__ctype_b_loc())[(int)((to_uchar(*fieldstr)))] & (unsigned short)_ISblank) || *fieldstr == '\x00') {
            in_digits = 0;
            if (dash_found) {
                dash_found = 0;
                if (!lhs_specified && !rhs_specified)
                    do {
                        error(0, 0, (gettext("invalid range with no endpoint: -")));
                        usage(1);
                    } while (0);
                if (!rhs_specified) {
                    eol_range_start = initial;
                    field_found = 1;
                } else {
                    if (value < initial)
                        do {
                            error(0, 0, (gettext("invalid decreasing range")));
                            usage(1);
                        } while (0);
                    if (eol_range_start != 0) {
                        if (initial < eol_range_start) {
                            if (eol_range_start <= value) {
                                eol_range_start = initial;
                            } else {
                                do {
                                    if (initial == 0 || value == 0)
                                        do {
                                            error(0, 0, (gettext("fields and positions are numbered from 1")));
                                            usage(1);
                                        } while (0);
                                    if (n_rp >= n_rp_allocated) {
                                        (rp) = x2nrealloc(rp, &n_rp_allocated, sizeof *(rp));
                                    }
                                    rp[n_rp].lo = (initial);
                                    rp[n_rp].hi = (value);
                                    ++n_rp;
                                } while (0);
                            }
                            field_found = 1;
                        }
                    } else {
                        do {
                            if (initial == 0 || value == 0)
                                do {
                                    error(0, 0, (gettext("fields and positions are numbered from 1")));
                                    usage(1);
                                } while (0);
                            if (n_rp >= n_rp_allocated) {
                                (rp) = x2nrealloc(rp, &n_rp_allocated, sizeof *(rp));
                            }
                            rp[n_rp].lo = (initial);
                            rp[n_rp].hi = (value);
                            ++n_rp;
                        } while (0);
                        field_found = 1;
                    }
                    value = 0;
                }
            } else {
                do {
                    if (value == 0 || value == 0)
                        do {
                            error(0, 0, (gettext("fields and positions are numbered from 1")));
                            usage(1);
                        } while (0);
                    if (n_rp >= n_rp_allocated) {
                        (rp) = x2nrealloc(rp, &n_rp_allocated, sizeof *(rp));
                    }
                    rp[n_rp].lo = (value);
                    rp[n_rp].hi = (value);
                    ++n_rp;
                } while (0);
                value = 0;
                field_found = 1;
            }
            if (*fieldstr == '\x00') {
                break;
            }
            fieldstr++;
            lhs_specified = 0;
            rhs_specified = 0;
        } else if (((unsigned int)(*fieldstr) - '0' <= 9)) {
            static const char *num_start;
            if (!in_digits || !num_start)
                num_start = fieldstr;
            in_digits = 1;
            if (dash_found)
                rhs_specified = 1;
            else
                lhs_specified = 1;
            if (!((void)(&(value) == (size_t *)((void *)0)) , (((size_t)-1 / 10 < (value) || (size_t)((value) * 10 + (*fieldstr - '0')) < (value)) ? 0 : (((value) = (value) * 10 + (*fieldstr - '0')) , 1)))) {
                size_t len = strspn(num_start, "0123456789");
                char *bad_num = xstrndup(num_start, len);
                if (operating_mode == byte_mode)
                    error(0, 0, gettext("byte offset %s is too large"), quote(bad_num));
                else
                    error(0, 0, gettext("field number %s is too large"), quote(bad_num));
                free(bad_num);
                exit(1);
            }
            fieldstr++;
        } else
            do {
                error(0, 0, (gettext("invalid byte or field list")));
                usage(1);
            } while (0);
    }


BasicTester, a patch instance with id 152:
Spawn 1 instances, now Total 193
a batched test job starts!
Building:src at:
/home/ubuntu/spr-fast/tests/corebench/coreutils/coreutils-case-7380cf79-2e636af1/tempworkdir/srcMerged code building succ, going to invoke tester!
BasicTester, Testing instance id 143:
Running test command:
/home/ubuntu/spr-fast/tools/coreutils-test.py /home/ubuntu/spr-fast/tests/corebench/coreutils/coreutils-case-7380cf79-2e636af1/tempworkdir/src /home/ubuntu/spr-fast/tests/corebench/coreutils/coreutils-case-7380cf79-2e636af1/tempworkdir/tests /home/ubuntu/spr-fast/tests/corebench/coreutils/coreutils-case-7380cf79-2e636af1/tempworkdir 0  > __res
BasicTester, Testing instance id 144:
Running test command:
/home/ubuntu/spr-fast/tools/coreutils-test.py /home/ubuntu/spr-fast/tests/corebench/coreutils/coreutils-case-7380cf79-2e636af1/tempworkdir/src /home/ubuntu/spr-fast/tests/corebench/coreutils/coreutils-case-7380cf79-2e636af1/tempworkdir/tests /home/ubuntu/spr-fast/tests/corebench/coreutils/coreutils-case-7380cf79-2e636af1/tempworkdir 0  > __res
BasicTester, Testing instance id 145:
Running test command:
/home/ubuntu/spr-fast/tools/coreutils-test.py /home/ubuntu/spr-fast/tests/corebench/coreutils/coreutils-case-7380cf79-2e636af1/tempworkdir/src /home/ubuntu/spr-fast/tests/corebench/coreutils/coreutils-case-7380cf79-2e636af1/tempworkdir/tests /home/ubuntu/spr-fast/tests/corebench/coreutils/coreutils-case-7380cf79-2e636af1/tempworkdir 0  > __res
BasicTester, Testing instance id 146:
Running test command:
/home/ubuntu/spr-fast/tools/coreutils-test.py /home/ubuntu/spr-fast/tests/corebench/coreutils/coreutils-case-7380cf79-2e636af1/tempworkdir/src /home/ubuntu/spr-fast/tests/corebench/coreutils/coreutils-case-7380cf79-2e636af1/tempworkdir/tests /home/ubuntu/spr-fast/tests/corebench/coreutils/coreutils-case-7380cf79-2e636af1/tempworkdir 0  > __res
BasicTester, Testing instance id 147:
Running test command:
/home/ubuntu/spr-fast/tools/coreutils-test.py /home/ubuntu/spr-fast/tests/corebench/coreutils/coreutils-case-7380cf79-2e636af1/tempworkdir/src /home/ubuntu/spr-fast/tests/corebench/coreutils/coreutils-case-7380cf79-2e636af1/tempworkdir/tests /home/ubuntu/spr-fast/tests/corebench/coreutils/coreutils-case-7380cf79-2e636af1/tempworkdir 0  > __res
BasicTester, Testing instance id 148:
Running test command:
/home/ubuntu/spr-fast/tools/coreutils-test.py /home/ubuntu/spr-fast/tests/corebench/coreutils/coreutils-case-7380cf79-2e636af1/tempworkdir/src /home/ubuntu/spr-fast/tests/corebench/coreutils/coreutils-case-7380cf79-2e636af1/tempworkdir/tests /home/ubuntu/spr-fast/tests/corebench/coreutils/coreutils-case-7380cf79-2e636af1/tempworkdir 0  > __res
BasicTester, Testing instance id 149:
Running test command:
/home/ubuntu/spr-fast/tools/coreutils-test.py /home/ubuntu/spr-fast/tests/corebench/coreutils/coreutils-case-7380cf79-2e636af1/tempworkdir/src /home/ubuntu/spr-fast/tests/corebench/coreutils/coreutils-case-7380cf79-2e636af1/tempworkdir/tests /home/ubuntu/spr-fast/tests/corebench/coreutils/coreutils-case-7380cf79-2e636af1/tempworkdir 0  > __res
BasicTester, Testing instance id 150:
Running test command:
/home/ubuntu/spr-fast/tools/coreutils-test.py /home/ubuntu/spr-fast/tests/corebench/coreutils/coreutils-case-7380cf79-2e636af1/tempworkdir/src /home/ubuntu/spr-fast/tests/corebench/coreutils/coreutils-case-7380cf79-2e636af1/tempworkdir/tests /home/ubuntu/spr-fast/tests/corebench/coreutils/coreutils-case-7380cf79-2e636af1/tempworkdir 0  > __res
BasicTester, Testing instance id 151:
Running test command:
/home/ubuntu/spr-fast/tools/coreutils-test.py /home/ubuntu/spr-fast/tests/corebench/coreutils/coreutils-case-7380cf79-2e636af1/tempworkdir/src /home/ubuntu/spr-fast/tests/corebench/coreutils/coreutils-case-7380cf79-2e636af1/tempworkdir/tests /home/ubuntu/spr-fast/tests/corebench/coreutils/coreutils-case-7380cf79-2e636af1/tempworkdir 0  > __res
BasicTester, Testing instance id 152:
Running test command:
/home/ubuntu/spr-fast/tools/coreutils-test.py /home/ubuntu/spr-fast/tests/corebench/coreutils/coreutils-case-7380cf79-2e636af1/tempworkdir/src /home/ubuntu/spr-fast/tests/corebench/coreutils/coreutils-case-7380cf79-2e636af1/tempworkdir/tests /home/ubuntu/spr-fast/tests/corebench/coreutils/coreutils-case-7380cf79-2e636af1/tempworkdir 0  > __res
Counter: 194
Batcher Size:43
Preprocess the following candidate with BasicTester:
Priority 7465
At location src/cut.c:363
--Src File: src/cut.c
Fragment 0:
if (rp[i].hi > max_range_endpoint)
    max_range_endpoint = rp[i].hi;
while (1)
    {
        if (*fieldstr == '-') {
            in_digits = 0;
            if (dash_found)
                do {
                    error(0, 0, (gettext("invalid byte or field list")));
                    usage(1);
                } while (0);
            dash_found = 1;
            fieldstr++;
            initial = (lhs_specified ? value : 1);
            value = 0;
        } else if (*fieldstr == ',' || ((*__ctype_b_loc())[(int)((to_uchar(*fieldstr)))] & (unsigned short)_ISblank) || *fieldstr == '\x00') {
            in_digits = 0;
            if (dash_found) {
                dash_found = 0;
                if (!lhs_specified && !rhs_specified)
                    do {
                        error(0, 0, (gettext("invalid range with no endpoint: -")));
                        usage(1);
                    } while (0);
                if (!rhs_specified) {
                    eol_range_start = initial;
                    field_found = 1;
                } else {
                    if (value < initial)
                        do {
                            error(0, 0, (gettext("invalid decreasing range")));
                            usage(1);
                        } while (0);
                    if (eol_range_start != 0) {
                        if (initial < eol_range_start) {
                            if (eol_range_start <= value) {
                                eol_range_start = initial;
                            } else {
                                do {
                                    if (initial == 0 || value == 0)
                                        do {
                                            error(0, 0, (gettext("fields and positions are numbered from 1")));
                                            usage(1);
                                        } while (0);
                                    if (n_rp >= n_rp_allocated) {
                                        (rp) = x2nrealloc(rp, &n_rp_allocated, sizeof *(rp));
                                    }
                                    rp[n_rp].lo = (initial);
                                    rp[n_rp].hi = (value);
                                    ++n_rp;
                                } while (0);
                            }
                            field_found = 1;
                        }
                    } else {
                        do {
                            if (initial == 0 || value == 0)
                                do {
                                    error(0, 0, (gettext("fields and positions are numbered from 1")));
                                    usage(1);
                                } while (0);
                            if (n_rp >= n_rp_allocated) {
                                (rp) = x2nrealloc(rp, &n_rp_allocated, sizeof *(rp));
                            }
                            rp[n_rp].lo = (initial);
                            rp[n_rp].hi = (value);
                            ++n_rp;
                        } while (0);
                        field_found = 1;
                    }
                    value = 0;
                }
            } else {
                do {
                    if (value == 0 || value == 0)
                        do {
                            error(0, 0, (gettext("fields and positions are numbered from 1")));
                            usage(1);
                        } while (0);
                    if (n_rp >= n_rp_allocated) {
                        (rp) = x2nrealloc(rp, &n_rp_allocated, sizeof *(rp));
                    }
                    rp[n_rp].lo = (value);
                    rp[n_rp].hi = (value);
                    ++n_rp;
                } while (0);
                value = 0;
                field_found = 1;
            }
            if (*fieldstr == '\x00') {
                break;
            }
            fieldstr++;
            lhs_specified = 0;
            rhs_specified = 0;
        } else if (((unsigned int)(*fieldstr) - '0' <= 9)) {
            static const char *num_start;
            if (!in_digits || !num_start)
                num_start = fieldstr;
            in_digits = 1;
            if (dash_found)
                rhs_specified = 1;
            else
                lhs_specified = 1;
            if (!((void)(&(value) == (size_t *)((void *)0)) , (((size_t)-1 / 10 < (value) || (size_t)((value) * 10 + (*fieldstr - '0')) < (value)) ? 0 : (((value) = (value) * 10 + (*fieldstr - '0')) , 1)))) {
                size_t len = strspn(num_start, "0123456789");
                char *bad_num = xstrndup(num_start, len);
                if (operating_mode == byte_mode)
                    error(0, 0, gettext("byte offset %s is too large"), quote(bad_num));
                else
                    error(0, 0, gettext("field number %s is too large"), quote(bad_num));
                free(bad_num);
                exit(1);
            }
            fieldstr++;
        } else
            do {
                error(0, 0, (gettext("invalid byte or field list")));
                usage(1);
            } while (0);
    }


BasicTester, a patch instance with id 153:
Spawn 1 instances, now Total 194
Counter: 195
Batcher Size:44
Preprocess the following candidate with BasicTester:
Priority 7465
At location src/cut.c:363
--Src File: src/cut.c
Fragment 0:
have_read_stdin = 1;
while (1)
    {
        if (*fieldstr == '-') {
            in_digits = 0;
            if (dash_found)
                do {
                    error(0, 0, (gettext("invalid byte or field list")));
                    usage(1);
                } while (0);
            dash_found = 1;
            fieldstr++;
            initial = (lhs_specified ? value : 1);
            value = 0;
        } else if (*fieldstr == ',' || ((*__ctype_b_loc())[(int)((to_uchar(*fieldstr)))] & (unsigned short)_ISblank) || *fieldstr == '\x00') {
            in_digits = 0;
            if (dash_found) {
                dash_found = 0;
                if (!lhs_specified && !rhs_specified)
                    do {
                        error(0, 0, (gettext("invalid range with no endpoint: -")));
                        usage(1);
                    } while (0);
                if (!rhs_specified) {
                    eol_range_start = initial;
                    field_found = 1;
                } else {
                    if (value < initial)
                        do {
                            error(0, 0, (gettext("invalid decreasing range")));
                            usage(1);
                        } while (0);
                    if (eol_range_start != 0) {
                        if (initial < eol_range_start) {
                            if (eol_range_start <= value) {
                                eol_range_start = initial;
                            } else {
                                do {
                                    if (initial == 0 || value == 0)
                                        do {
                                            error(0, 0, (gettext("fields and positions are numbered from 1")));
                                            usage(1);
                                        } while (0);
                                    if (n_rp >= n_rp_allocated) {
                                        (rp) = x2nrealloc(rp, &n_rp_allocated, sizeof *(rp));
                                    }
                                    rp[n_rp].lo = (initial);
                                    rp[n_rp].hi = (value);
                                    ++n_rp;
                                } while (0);
                            }
                            field_found = 1;
                        }
                    } else {
                        do {
                            if (initial == 0 || value == 0)
                                do {
                                    error(0, 0, (gettext("fields and positions are numbered from 1")));
                                    usage(1);
                                } while (0);
                            if (n_rp >= n_rp_allocated) {
                                (rp) = x2nrealloc(rp, &n_rp_allocated, sizeof *(rp));
                            }
                            rp[n_rp].lo = (initial);
                            rp[n_rp].hi = (value);
                            ++n_rp;
                        } while (0);
                        field_found = 1;
                    }
                    value = 0;
                }
            } else {
                do {
                    if (value == 0 || value == 0)
                        do {
                            error(0, 0, (gettext("fields and positions are numbered from 1")));
                            usage(1);
                        } while (0);
                    if (n_rp >= n_rp_allocated) {
                        (rp) = x2nrealloc(rp, &n_rp_allocated, sizeof *(rp));
                    }
                    rp[n_rp].lo = (value);
                    rp[n_rp].hi = (value);
                    ++n_rp;
                } while (0);
                value = 0;
                field_found = 1;
            }
            if (*fieldstr == '\x00') {
                break;
            }
            fieldstr++;
            lhs_specified = 0;
            rhs_specified = 0;
        } else if (((unsigned int)(*fieldstr) - '0' <= 9)) {
            static const char *num_start;
            if (!in_digits || !num_start)
                num_start = fieldstr;
            in_digits = 1;
            if (dash_found)
                rhs_specified = 1;
            else
                lhs_specified = 1;
            if (!((void)(&(value) == (size_t *)((void *)0)) , (((size_t)-1 / 10 < (value) || (size_t)((value) * 10 + (*fieldstr - '0')) < (value)) ? 0 : (((value) = (value) * 10 + (*fieldstr - '0')) , 1)))) {
                size_t len = strspn(num_start, "0123456789");
                char *bad_num = xstrndup(num_start, len);
                if (operating_mode == byte_mode)
                    error(0, 0, gettext("byte offset %s is too large"), quote(bad_num));
                else
                    error(0, 0, gettext("field number %s is too large"), quote(bad_num));
                free(bad_num);
                exit(1);
            }
            fieldstr++;
        } else
            do {
                error(0, 0, (gettext("invalid byte or field list")));
                usage(1);
            } while (0);
    }


BasicTester, a patch instance with id 154:
Spawn 1 instances, now Total 195
Counter: 196
Batcher Size:45
Preprocess the following candidate with BasicTester:
Priority 7465
At location src/cut.c:363
--Src File: src/cut.c
Fragment 0:
if (dash_found)
    rhs_specified = 1;
else
    lhs_specified = 1;
while (1)
    {
        if (*fieldstr == '-') {
            in_digits = 0;
            if (dash_found)
                do {
                    error(0, 0, (gettext("invalid byte or field list")));
                    usage(1);
                } while (0);
            dash_found = 1;
            fieldstr++;
            initial = (lhs_specified ? value : 1);
            value = 0;
        } else if (*fieldstr == ',' || ((*__ctype_b_loc())[(int)((to_uchar(*fieldstr)))] & (unsigned short)_ISblank) || *fieldstr == '\x00') {
            in_digits = 0;
            if (dash_found) {
                dash_found = 0;
                if (!lhs_specified && !rhs_specified)
                    do {
                        error(0, 0, (gettext("invalid range with no endpoint: -")));
                        usage(1);
                    } while (0);
                if (!rhs_specified) {
                    eol_range_start = initial;
                    field_found = 1;
                } else {
                    if (value < initial)
                        do {
                            error(0, 0, (gettext("invalid decreasing range")));
                            usage(1);
                        } while (0);
                    if (eol_range_start != 0) {
                        if (initial < eol_range_start) {
                            if (eol_range_start <= value) {
                                eol_range_start = initial;
                            } else {
                                do {
                                    if (initial == 0 || value == 0)
                                        do {
                                            error(0, 0, (gettext("fields and positions are numbered from 1")));
                                            usage(1);
                                        } while (0);
                                    if (n_rp >= n_rp_allocated) {
                                        (rp) = x2nrealloc(rp, &n_rp_allocated, sizeof *(rp));
                                    }
                                    rp[n_rp].lo = (initial);
                                    rp[n_rp].hi = (value);
                                    ++n_rp;
                                } while (0);
                            }
                            field_found = 1;
                        }
                    } else {
                        do {
                            if (initial == 0 || value == 0)
                                do {
                                    error(0, 0, (gettext("fields and positions are numbered from 1")));
                                    usage(1);
                                } while (0);
                            if (n_rp >= n_rp_allocated) {
                                (rp) = x2nrealloc(rp, &n_rp_allocated, sizeof *(rp));
                            }
                            rp[n_rp].lo = (initial);
                            rp[n_rp].hi = (value);
                            ++n_rp;
                        } while (0);
                        field_found = 1;
                    }
                    value = 0;
                }
            } else {
                do {
                    if (value == 0 || value == 0)
                        do {
                            error(0, 0, (gettext("fields and positions are numbered from 1")));
                            usage(1);
                        } while (0);
                    if (n_rp >= n_rp_allocated) {
                        (rp) = x2nrealloc(rp, &n_rp_allocated, sizeof *(rp));
                    }
                    rp[n_rp].lo = (value);
                    rp[n_rp].hi = (value);
                    ++n_rp;
                } while (0);
                value = 0;
                field_found = 1;
            }
            if (*fieldstr == '\x00') {
                break;
            }
            fieldstr++;
            lhs_specified = 0;
            rhs_specified = 0;
        } else if (((unsigned int)(*fieldstr) - '0' <= 9)) {
            static const char *num_start;
            if (!in_digits || !num_start)
                num_start = fieldstr;
            in_digits = 1;
            if (dash_found)
                rhs_specified = 1;
            else
                lhs_specified = 1;
            if (!((void)(&(value) == (size_t *)((void *)0)) , (((size_t)-1 / 10 < (value) || (size_t)((value) * 10 + (*fieldstr - '0')) < (value)) ? 0 : (((value) = (value) * 10 + (*fieldstr - '0')) , 1)))) {
                size_t len = strspn(num_start, "0123456789");
                char *bad_num = xstrndup(num_start, len);
                if (operating_mode == byte_mode)
                    error(0, 0, gettext("byte offset %s is too large"), quote(bad_num));
                else
                    error(0, 0, gettext("field number %s is too large"), quote(bad_num));
                free(bad_num);
                exit(1);
            }
            fieldstr++;
        } else
            do {
                error(0, 0, (gettext("invalid byte or field list")));
                usage(1);
            } while (0);
    }


BasicTester, a patch instance with id 155:
Spawn 1 instances, now Total 196
Counter: 197
Batcher Size:46
Preprocess the following candidate with BasicTester:
Priority 7465
At location src/cut.c:363
--Src File: src/cut.c
Fragment 0:
if (output_delimiter_specified && !complement && eol_range_start && !is_printable_field(eol_range_start))
    mark_range_start(eol_range_start);
while (1)
    {
        if (*fieldstr == '-') {
            in_digits = 0;
            if (dash_found)
                do {
                    error(0, 0, (gettext("invalid byte or field list")));
                    usage(1);
                } while (0);
            dash_found = 1;
            fieldstr++;
            initial = (lhs_specified ? value : 1);
            value = 0;
        } else if (*fieldstr == ',' || ((*__ctype_b_loc())[(int)((to_uchar(*fieldstr)))] & (unsigned short)_ISblank) || *fieldstr == '\x00') {
            in_digits = 0;
            if (dash_found) {
                dash_found = 0;
                if (!lhs_specified && !rhs_specified)
                    do {
                        error(0, 0, (gettext("invalid range with no endpoint: -")));
                        usage(1);
                    } while (0);
                if (!rhs_specified) {
                    eol_range_start = initial;
                    field_found = 1;
                } else {
                    if (value < initial)
                        do {
                            error(0, 0, (gettext("invalid decreasing range")));
                            usage(1);
                        } while (0);
                    if (eol_range_start != 0) {
                        if (initial < eol_range_start) {
                            if (eol_range_start <= value) {
                                eol_range_start = initial;
                            } else {
                                do {
                                    if (initial == 0 || value == 0)
                                        do {
                                            error(0, 0, (gettext("fields and positions are numbered from 1")));
                                            usage(1);
                                        } while (0);
                                    if (n_rp >= n_rp_allocated) {
                                        (rp) = x2nrealloc(rp, &n_rp_allocated, sizeof *(rp));
                                    }
                                    rp[n_rp].lo = (initial);
                                    rp[n_rp].hi = (value);
                                    ++n_rp;
                                } while (0);
                            }
                            field_found = 1;
                        }
                    } else {
                        do {
                            if (initial == 0 || value == 0)
                                do {
                                    error(0, 0, (gettext("fields and positions are numbered from 1")));
                                    usage(1);
                                } while (0);
                            if (n_rp >= n_rp_allocated) {
                                (rp) = x2nrealloc(rp, &n_rp_allocated, sizeof *(rp));
                            }
                            rp[n_rp].lo = (initial);
                            rp[n_rp].hi = (value);
                            ++n_rp;
                        } while (0);
                        field_found = 1;
                    }
                    value = 0;
                }
            } else {
                do {
                    if (value == 0 || value == 0)
                        do {
                            error(0, 0, (gettext("fields and positions are numbered from 1")));
                            usage(1);
                        } while (0);
                    if (n_rp >= n_rp_allocated) {
                        (rp) = x2nrealloc(rp, &n_rp_allocated, sizeof *(rp));
                    }
                    rp[n_rp].lo = (value);
                    rp[n_rp].hi = (value);
                    ++n_rp;
                } while (0);
                value = 0;
                field_found = 1;
            }
            if (*fieldstr == '\x00') {
                break;
            }
            fieldstr++;
            lhs_specified = 0;
            rhs_specified = 0;
        } else if (((unsigned int)(*fieldstr) - '0' <= 9)) {
            static const char *num_start;
            if (!in_digits || !num_start)
                num_start = fieldstr;
            in_digits = 1;
            if (dash_found)
                rhs_specified = 1;
            else
                lhs_specified = 1;
            if (!((void)(&(value) == (size_t *)((void *)0)) , (((size_t)-1 / 10 < (value) || (size_t)((value) * 10 + (*fieldstr - '0')) < (value)) ? 0 : (((value) = (value) * 10 + (*fieldstr - '0')) , 1)))) {
                size_t len = strspn(num_start, "0123456789");
                char *bad_num = xstrndup(num_start, len);
                if (operating_mode == byte_mode)
                    error(0, 0, gettext("byte offset %s is too large"), quote(bad_num));
                else
                    error(0, 0, gettext("field number %s is too large"), quote(bad_num));
                free(bad_num);
                exit(1);
            }
            fieldstr++;
        } else
            do {
                error(0, 0, (gettext("invalid byte or field list")));
                usage(1);
            } while (0);
    }


BasicTester, a patch instance with id 156:
Spawn 1 instances, now Total 197
Counter: 198
Batcher Size:47
Preprocess the following candidate with BasicTester:
Priority 7465
At location src/cut.c:363
--Src File: src/cut.c
Fragment 0:
free((rp));
while (1)
    {
        if (*fieldstr == '-') {
            in_digits = 0;
            if (dash_found)
                do {
                    error(0, 0, (gettext("invalid byte or field list")));
                    usage(1);
                } while (0);
            dash_found = 1;
            fieldstr++;
            initial = (lhs_specified ? value : 1);
            value = 0;
        } else if (*fieldstr == ',' || ((*__ctype_b_loc())[(int)((to_uchar(*fieldstr)))] & (unsigned short)_ISblank) || *fieldstr == '\x00') {
            in_digits = 0;
            if (dash_found) {
                dash_found = 0;
                if (!lhs_specified && !rhs_specified)
                    do {
                        error(0, 0, (gettext("invalid range with no endpoint: -")));
                        usage(1);
                    } while (0);
                if (!rhs_specified) {
                    eol_range_start = initial;
                    field_found = 1;
                } else {
                    if (value < initial)
                        do {
                            error(0, 0, (gettext("invalid decreasing range")));
                            usage(1);
                        } while (0);
                    if (eol_range_start != 0) {
                        if (initial < eol_range_start) {
                            if (eol_range_start <= value) {
                                eol_range_start = initial;
                            } else {
                                do {
                                    if (initial == 0 || value == 0)
                                        do {
                                            error(0, 0, (gettext("fields and positions are numbered from 1")));
                                            usage(1);
                                        } while (0);
                                    if (n_rp >= n_rp_allocated) {
                                        (rp) = x2nrealloc(rp, &n_rp_allocated, sizeof *(rp));
                                    }
                                    rp[n_rp].lo = (initial);
                                    rp[n_rp].hi = (value);
                                    ++n_rp;
                                } while (0);
                            }
                            field_found = 1;
                        }
                    } else {
                        do {
                            if (initial == 0 || value == 0)
                                do {
                                    error(0, 0, (gettext("fields and positions are numbered from 1")));
                                    usage(1);
                                } while (0);
                            if (n_rp >= n_rp_allocated) {
                                (rp) = x2nrealloc(rp, &n_rp_allocated, sizeof *(rp));
                            }
                            rp[n_rp].lo = (initial);
                            rp[n_rp].hi = (value);
                            ++n_rp;
                        } while (0);
                        field_found = 1;
                    }
                    value = 0;
                }
            } else {
                do {
                    if (value == 0 || value == 0)
                        do {
                            error(0, 0, (gettext("fields and positions are numbered from 1")));
                            usage(1);
                        } while (0);
                    if (n_rp >= n_rp_allocated) {
                        (rp) = x2nrealloc(rp, &n_rp_allocated, sizeof *(rp));
                    }
                    rp[n_rp].lo = (value);
                    rp[n_rp].hi = (value);
                    ++n_rp;
                } while (0);
                value = 0;
                field_found = 1;
            }
            if (*fieldstr == '\x00') {
                break;
            }
            fieldstr++;
            lhs_specified = 0;
            rhs_specified = 0;
        } else if (((unsigned int)(*fieldstr) - '0' <= 9)) {
            static const char *num_start;
            if (!in_digits || !num_start)
                num_start = fieldstr;
            in_digits = 1;
            if (dash_found)
                rhs_specified = 1;
            else
                lhs_specified = 1;
            if (!((void)(&(value) == (size_t *)((void *)0)) , (((size_t)-1 / 10 < (value) || (size_t)((value) * 10 + (*fieldstr - '0')) < (value)) ? 0 : (((value) = (value) * 10 + (*fieldstr - '0')) , 1)))) {
                size_t len = strspn(num_start, "0123456789");
                char *bad_num = xstrndup(num_start, len);
                if (operating_mode == byte_mode)
                    error(0, 0, gettext("byte offset %s is too large"), quote(bad_num));
                else
                    error(0, 0, gettext("field number %s is too large"), quote(bad_num));
                free(bad_num);
                exit(1);
            }
            fieldstr++;
        } else
            do {
                error(0, 0, (gettext("invalid byte or field list")));
                usage(1);
            } while (0);
    }


BasicTester, a patch instance with id 157:
Spawn 1 instances, now Total 198
Counter: 199
Batcher Size:48
Preprocess the following candidate with BasicTester:
Priority 7465
At location src/cut.c:363
--Src File: src/cut.c
Fragment 0:
have_read_stdin = (field_found);
while (1)
    {
        if (*fieldstr == '-') {
            in_digits = 0;
            if (dash_found)
                do {
                    error(0, 0, (gettext("invalid byte or field list")));
                    usage(1);
                } while (0);
            dash_found = 1;
            fieldstr++;
            initial = (lhs_specified ? value : 1);
            value = 0;
        } else if (*fieldstr == ',' || ((*__ctype_b_loc())[(int)((to_uchar(*fieldstr)))] & (unsigned short)_ISblank) || *fieldstr == '\x00') {
            in_digits = 0;
            if (dash_found) {
                dash_found = 0;
                if (!lhs_specified && !rhs_specified)
                    do {
                        error(0, 0, (gettext("invalid range with no endpoint: -")));
                        usage(1);
                    } while (0);
                if (!rhs_specified) {
                    eol_range_start = initial;
                    field_found = 1;
                } else {
                    if (value < initial)
                        do {
                            error(0, 0, (gettext("invalid decreasing range")));
                            usage(1);
                        } while (0);
                    if (eol_range_start != 0) {
                        if (initial < eol_range_start) {
                            if (eol_range_start <= value) {
                                eol_range_start = initial;
                            } else {
                                do {
                                    if (initial == 0 || value == 0)
                                        do {
                                            error(0, 0, (gettext("fields and positions are numbered from 1")));
                                            usage(1);
                                        } while (0);
                                    if (n_rp >= n_rp_allocated) {
                                        (rp) = x2nrealloc(rp, &n_rp_allocated, sizeof *(rp));
                                    }
                                    rp[n_rp].lo = (initial);
                                    rp[n_rp].hi = (value);
                                    ++n_rp;
                                } while (0);
                            }
                            field_found = 1;
                        }
                    } else {
                        do {
                            if (initial == 0 || value == 0)
                                do {
                                    error(0, 0, (gettext("fields and positions are numbered from 1")));
                                    usage(1);
                                } while (0);
                            if (n_rp >= n_rp_allocated) {
                                (rp) = x2nrealloc(rp, &n_rp_allocated, sizeof *(rp));
                            }
                            rp[n_rp].lo = (initial);
                            rp[n_rp].hi = (value);
                            ++n_rp;
                        } while (0);
                        field_found = 1;
                    }
                    value = 0;
                }
            } else {
                do {
                    if (value == 0 || value == 0)
                        do {
                            error(0, 0, (gettext("fields and positions are numbered from 1")));
                            usage(1);
                        } while (0);
                    if (n_rp >= n_rp_allocated) {
                        (rp) = x2nrealloc(rp, &n_rp_allocated, sizeof *(rp));
                    }
                    rp[n_rp].lo = (value);
                    rp[n_rp].hi = (value);
                    ++n_rp;
                } while (0);
                value = 0;
                field_found = 1;
            }
            if (*fieldstr == '\x00') {
                break;
            }
            fieldstr++;
            lhs_specified = 0;
            rhs_specified = 0;
        } else if (((unsigned int)(*fieldstr) - '0' <= 9)) {
            static const char *num_start;
            if (!in_digits || !num_start)
                num_start = fieldstr;
            in_digits = 1;
            if (dash_found)
                rhs_specified = 1;
            else
                lhs_specified = 1;
            if (!((void)(&(value) == (size_t *)((void *)0)) , (((size_t)-1 / 10 < (value) || (size_t)((value) * 10 + (*fieldstr - '0')) < (value)) ? 0 : (((value) = (value) * 10 + (*fieldstr - '0')) , 1)))) {
                size_t len = strspn(num_start, "0123456789");
                char *bad_num = xstrndup(num_start, len);
                if (operating_mode == byte_mode)
                    error(0, 0, gettext("byte offset %s is too large"), quote(bad_num));
                else
                    error(0, 0, gettext("field number %s is too large"), quote(bad_num));
                free(bad_num);
                exit(1);
            }
            fieldstr++;
        } else
            do {
                error(0, 0, (gettext("invalid byte or field list")));
                usage(1);
            } while (0);
    }


BasicTester, a patch instance with id 158:
Spawn 1 instances, now Total 199
Counter: 200
Batcher Size:49
Preprocess the following candidate with BasicTester:
Priority 7465
At location src/cut.c:363
--Src File: src/cut.c
Fragment 0:
have_read_stdin = (lhs_specified);
while (1)
    {
        if (*fieldstr == '-') {
            in_digits = 0;
            if (dash_found)
                do {
                    error(0, 0, (gettext("invalid byte or field list")));
                    usage(1);
                } while (0);
            dash_found = 1;
            fieldstr++;
            initial = (lhs_specified ? value : 1);
            value = 0;
        } else if (*fieldstr == ',' || ((*__ctype_b_loc())[(int)((to_uchar(*fieldstr)))] & (unsigned short)_ISblank) || *fieldstr == '\x00') {
            in_digits = 0;
            if (dash_found) {
                dash_found = 0;
                if (!lhs_specified && !rhs_specified)
                    do {
                        error(0, 0, (gettext("invalid range with no endpoint: -")));
                        usage(1);
                    } while (0);
                if (!rhs_specified) {
                    eol_range_start = initial;
                    field_found = 1;
                } else {
                    if (value < initial)
                        do {
                            error(0, 0, (gettext("invalid decreasing range")));
                            usage(1);
                        } while (0);
                    if (eol_range_start != 0) {
                        if (initial < eol_range_start) {
                            if (eol_range_start <= value) {
                                eol_range_start = initial;
                            } else {
                                do {
                                    if (initial == 0 || value == 0)
                                        do {
                                            error(0, 0, (gettext("fields and positions are numbered from 1")));
                                            usage(1);
                                        } while (0);
                                    if (n_rp >= n_rp_allocated) {
                                        (rp) = x2nrealloc(rp, &n_rp_allocated, sizeof *(rp));
                                    }
                                    rp[n_rp].lo = (initial);
                                    rp[n_rp].hi = (value);
                                    ++n_rp;
                                } while (0);
                            }
                            field_found = 1;
                        }
                    } else {
                        do {
                            if (initial == 0 || value == 0)
                                do {
                                    error(0, 0, (gettext("fields and positions are numbered from 1")));
                                    usage(1);
                                } while (0);
                            if (n_rp >= n_rp_allocated) {
                                (rp) = x2nrealloc(rp, &n_rp_allocated, sizeof *(rp));
                            }
                            rp[n_rp].lo = (initial);
                            rp[n_rp].hi = (value);
                            ++n_rp;
                        } while (0);
                        field_found = 1;
                    }
                    value = 0;
                }
            } else {
                do {
                    if (value == 0 || value == 0)
                        do {
                            error(0, 0, (gettext("fields and positions are numbered from 1")));
                            usage(1);
                        } while (0);
                    if (n_rp >= n_rp_allocated) {
                        (rp) = x2nrealloc(rp, &n_rp_allocated, sizeof *(rp));
                    }
                    rp[n_rp].lo = (value);
                    rp[n_rp].hi = (value);
                    ++n_rp;
                } while (0);
                value = 0;
                field_found = 1;
            }
            if (*fieldstr == '\x00') {
                break;
            }
            fieldstr++;
            lhs_specified = 0;
            rhs_specified = 0;
        } else if (((unsigned int)(*fieldstr) - '0' <= 9)) {
            static const char *num_start;
            if (!in_digits || !num_start)
                num_start = fieldstr;
            in_digits = 1;
            if (dash_found)
                rhs_specified = 1;
            else
                lhs_specified = 1;
            if (!((void)(&(value) == (size_t *)((void *)0)) , (((size_t)-1 / 10 < (value) || (size_t)((value) * 10 + (*fieldstr - '0')) < (value)) ? 0 : (((value) = (value) * 10 + (*fieldstr - '0')) , 1)))) {
                size_t len = strspn(num_start, "0123456789");
                char *bad_num = xstrndup(num_start, len);
                if (operating_mode == byte_mode)
                    error(0, 0, gettext("byte offset %s is too large"), quote(bad_num));
                else
                    error(0, 0, gettext("field number %s is too large"), quote(bad_num));
                free(bad_num);
                exit(1);
            }
            fieldstr++;
        } else
            do {
                error(0, 0, (gettext("invalid byte or field list")));
                usage(1);
            } while (0);
    }


BasicTester, a patch instance with id 159:
Spawn 1 instances, now Total 200
Counter: 201
Batcher Size:50
Preprocess the following candidate with BasicTester:
Priority 7465
At location src/cut.c:363
--Src File: src/cut.c
Fragment 0:
have_read_stdin = (rhs_specified);
while (1)
    {
        if (*fieldstr == '-') {
            in_digits = 0;
            if (dash_found)
                do {
                    error(0, 0, (gettext("invalid byte or field list")));
                    usage(1);
                } while (0);
            dash_found = 1;
            fieldstr++;
            initial = (lhs_specified ? value : 1);
            value = 0;
        } else if (*fieldstr == ',' || ((*__ctype_b_loc())[(int)((to_uchar(*fieldstr)))] & (unsigned short)_ISblank) || *fieldstr == '\x00') {
            in_digits = 0;
            if (dash_found) {
                dash_found = 0;
                if (!lhs_specified && !rhs_specified)
                    do {
                        error(0, 0, (gettext("invalid range with no endpoint: -")));
                        usage(1);
                    } while (0);
                if (!rhs_specified) {
                    eol_range_start = initial;
                    field_found = 1;
                } else {
                    if (value < initial)
                        do {
                            error(0, 0, (gettext("invalid decreasing range")));
                            usage(1);
                        } while (0);
                    if (eol_range_start != 0) {
                        if (initial < eol_range_start) {
                            if (eol_range_start <= value) {
                                eol_range_start = initial;
                            } else {
                                do {
                                    if (initial == 0 || value == 0)
                                        do {
                                            error(0, 0, (gettext("fields and positions are numbered from 1")));
                                            usage(1);
                                        } while (0);
                                    if (n_rp >= n_rp_allocated) {
                                        (rp) = x2nrealloc(rp, &n_rp_allocated, sizeof *(rp));
                                    }
                                    rp[n_rp].lo = (initial);
                                    rp[n_rp].hi = (value);
                                    ++n_rp;
                                } while (0);
                            }
                            field_found = 1;
                        }
                    } else {
                        do {
                            if (initial == 0 || value == 0)
                                do {
                                    error(0, 0, (gettext("fields and positions are numbered from 1")));
                                    usage(1);
                                } while (0);
                            if (n_rp >= n_rp_allocated) {
                                (rp) = x2nrealloc(rp, &n_rp_allocated, sizeof *(rp));
                            }
                            rp[n_rp].lo = (initial);
                            rp[n_rp].hi = (value);
                            ++n_rp;
                        } while (0);
                        field_found = 1;
                    }
                    value = 0;
                }
            } else {
                do {
                    if (value == 0 || value == 0)
                        do {
                            error(0, 0, (gettext("fields and positions are numbered from 1")));
                            usage(1);
                        } while (0);
                    if (n_rp >= n_rp_allocated) {
                        (rp) = x2nrealloc(rp, &n_rp_allocated, sizeof *(rp));
                    }
                    rp[n_rp].lo = (value);
                    rp[n_rp].hi = (value);
                    ++n_rp;
                } while (0);
                value = 0;
                field_found = 1;
            }
            if (*fieldstr == '\x00') {
                break;
            }
            fieldstr++;
            lhs_specified = 0;
            rhs_specified = 0;
        } else if (((unsigned int)(*fieldstr) - '0' <= 9)) {
            static const char *num_start;
            if (!in_digits || !num_start)
                num_start = fieldstr;
            in_digits = 1;
            if (dash_found)
                rhs_specified = 1;
            else
                lhs_specified = 1;
            if (!((void)(&(value) == (size_t *)((void *)0)) , (((size_t)-1 / 10 < (value) || (size_t)((value) * 10 + (*fieldstr - '0')) < (value)) ? 0 : (((value) = (value) * 10 + (*fieldstr - '0')) , 1)))) {
                size_t len = strspn(num_start, "0123456789");
                char *bad_num = xstrndup(num_start, len);
                if (operating_mode == byte_mode)
                    error(0, 0, gettext("byte offset %s is too large"), quote(bad_num));
                else
                    error(0, 0, gettext("field number %s is too large"), quote(bad_num));
                free(bad_num);
                exit(1);
            }
            fieldstr++;
        } else
            do {
                error(0, 0, (gettext("invalid byte or field list")));
                usage(1);
            } while (0);
    }


BasicTester, a patch instance with id 160:
Spawn 1 instances, now Total 201
Counter: 202
Batcher Size:51
Preprocess the following candidate with BasicTester:
Priority 7465
At location src/cut.c:363
--Src File: src/cut.c
Fragment 0:
have_read_stdin = (in_digits);
while (1)
    {
        if (*fieldstr == '-') {
            in_digits = 0;
            if (dash_found)
                do {
                    error(0, 0, (gettext("invalid byte or field list")));
                    usage(1);
                } while (0);
            dash_found = 1;
            fieldstr++;
            initial = (lhs_specified ? value : 1);
            value = 0;
        } else if (*fieldstr == ',' || ((*__ctype_b_loc())[(int)((to_uchar(*fieldstr)))] & (unsigned short)_ISblank) || *fieldstr == '\x00') {
            in_digits = 0;
            if (dash_found) {
                dash_found = 0;
                if (!lhs_specified && !rhs_specified)
                    do {
                        error(0, 0, (gettext("invalid range with no endpoint: -")));
                        usage(1);
                    } while (0);
                if (!rhs_specified) {
                    eol_range_start = initial;
                    field_found = 1;
                } else {
                    if (value < initial)
                        do {
                            error(0, 0, (gettext("invalid decreasing range")));
                            usage(1);
                        } while (0);
                    if (eol_range_start != 0) {
                        if (initial < eol_range_start) {
                            if (eol_range_start <= value) {
                                eol_range_start = initial;
                            } else {
                                do {
                                    if (initial == 0 || value == 0)
                                        do {
                                            error(0, 0, (gettext("fields and positions are numbered from 1")));
                                            usage(1);
                                        } while (0);
                                    if (n_rp >= n_rp_allocated) {
                                        (rp) = x2nrealloc(rp, &n_rp_allocated, sizeof *(rp));
                                    }
                                    rp[n_rp].lo = (initial);
                                    rp[n_rp].hi = (value);
                                    ++n_rp;
                                } while (0);
                            }
                            field_found = 1;
                        }
                    } else {
                        do {
                            if (initial == 0 || value == 0)
                                do {
                                    error(0, 0, (gettext("fields and positions are numbered from 1")));
                                    usage(1);
                                } while (0);
                            if (n_rp >= n_rp_allocated) {
                                (rp) = x2nrealloc(rp, &n_rp_allocated, sizeof *(rp));
                            }
                            rp[n_rp].lo = (initial);
                            rp[n_rp].hi = (value);
                            ++n_rp;
                        } while (0);
                        field_found = 1;
                    }
                    value = 0;
                }
            } else {
                do {
                    if (value == 0 || value == 0)
                        do {
                            error(0, 0, (gettext("fields and positions are numbered from 1")));
                            usage(1);
                        } while (0);
                    if (n_rp >= n_rp_allocated) {
                        (rp) = x2nrealloc(rp, &n_rp_allocated, sizeof *(rp));
                    }
                    rp[n_rp].lo = (value);
                    rp[n_rp].hi = (value);
                    ++n_rp;
                } while (0);
                value = 0;
                field_found = 1;
            }
            if (*fieldstr == '\x00') {
                break;
            }
            fieldstr++;
            lhs_specified = 0;
            rhs_specified = 0;
        } else if (((unsigned int)(*fieldstr) - '0' <= 9)) {
            static const char *num_start;
            if (!in_digits || !num_start)
                num_start = fieldstr;
            in_digits = 1;
            if (dash_found)
                rhs_specified = 1;
            else
                lhs_specified = 1;
            if (!((void)(&(value) == (size_t *)((void *)0)) , (((size_t)-1 / 10 < (value) || (size_t)((value) * 10 + (*fieldstr - '0')) < (value)) ? 0 : (((value) = (value) * 10 + (*fieldstr - '0')) , 1)))) {
                size_t len = strspn(num_start, "0123456789");
                char *bad_num = xstrndup(num_start, len);
                if (operating_mode == byte_mode)
                    error(0, 0, gettext("byte offset %s is too large"), quote(bad_num));
                else
                    error(0, 0, gettext("field number %s is too large"), quote(bad_num));
                free(bad_num);
                exit(1);
            }
            fieldstr++;
        } else
            do {
                error(0, 0, (gettext("invalid byte or field list")));
                usage(1);
            } while (0);
    }


BasicTester, a patch instance with id 161:
Spawn 1 instances, now Total 202
Counter: 203
Batcher Size:52
Preprocess the following candidate with BasicTester:
Priority 7465
At location src/cut.c:363
--Src File: src/cut.c
Fragment 0:
free(field_1_buffer);
while (1)
    {
        if (*fieldstr == '-') {
            in_digits = 0;
            if (dash_found)
                do {
                    error(0, 0, (gettext("invalid byte or field list")));
                    usage(1);
                } while (0);
            dash_found = 1;
            fieldstr++;
            initial = (lhs_specified ? value : 1);
            value = 0;
        } else if (*fieldstr == ',' || ((*__ctype_b_loc())[(int)((to_uchar(*fieldstr)))] & (unsigned short)_ISblank) || *fieldstr == '\x00') {
            in_digits = 0;
            if (dash_found) {
                dash_found = 0;
                if (!lhs_specified && !rhs_specified)
                    do {
                        error(0, 0, (gettext("invalid range with no endpoint: -")));
                        usage(1);
                    } while (0);
                if (!rhs_specified) {
                    eol_range_start = initial;
                    field_found = 1;
                } else {
                    if (value < initial)
                        do {
                            error(0, 0, (gettext("invalid decreasing range")));
                            usage(1);
                        } while (0);
                    if (eol_range_start != 0) {
                        if (initial < eol_range_start) {
                            if (eol_range_start <= value) {
                                eol_range_start = initial;
                            } else {
                                do {
                                    if (initial == 0 || value == 0)
                                        do {
                                            error(0, 0, (gettext("fields and positions are numbered from 1")));
                                            usage(1);
                                        } while (0);
                                    if (n_rp >= n_rp_allocated) {
                                        (rp) = x2nrealloc(rp, &n_rp_allocated, sizeof *(rp));
                                    }
                                    rp[n_rp].lo = (initial);
                                    rp[n_rp].hi = (value);
                                    ++n_rp;
                                } while (0);
                            }
                            field_found = 1;
                        }
                    } else {
                        do {
                            if (initial == 0 || value == 0)
                                do {
                                    error(0, 0, (gettext("fields and positions are numbered from 1")));
                                    usage(1);
                                } while (0);
                            if (n_rp >= n_rp_allocated) {
                                (rp) = x2nrealloc(rp, &n_rp_allocated, sizeof *(rp));
                            }
                            rp[n_rp].lo = (initial);
                            rp[n_rp].hi = (value);
                            ++n_rp;
                        } while (0);
                        field_found = 1;
                    }
                    value = 0;
                }
            } else {
                do {
                    if (value == 0 || value == 0)
                        do {
                            error(0, 0, (gettext("fields and positions are numbered from 1")));
                            usage(1);
                        } while (0);
                    if (n_rp >= n_rp_allocated) {
                        (rp) = x2nrealloc(rp, &n_rp_allocated, sizeof *(rp));
                    }
                    rp[n_rp].lo = (value);
                    rp[n_rp].hi = (value);
                    ++n_rp;
                } while (0);
                value = 0;
                field_found = 1;
            }
            if (*fieldstr == '\x00') {
                break;
            }
            fieldstr++;
            lhs_specified = 0;
            rhs_specified = 0;
        } else if (((unsigned int)(*fieldstr) - '0' <= 9)) {
            static const char *num_start;
            if (!in_digits || !num_start)
                num_start = fieldstr;
            in_digits = 1;
            if (dash_found)
                rhs_specified = 1;
            else
                lhs_specified = 1;
            if (!((void)(&(value) == (size_t *)((void *)0)) , (((size_t)-1 / 10 < (value) || (size_t)((value) * 10 + (*fieldstr - '0')) < (value)) ? 0 : (((value) = (value) * 10 + (*fieldstr - '0')) , 1)))) {
                size_t len = strspn(num_start, "0123456789");
                char *bad_num = xstrndup(num_start, len);
                if (operating_mode == byte_mode)
                    error(0, 0, gettext("byte offset %s is too large"), quote(bad_num));
                else
                    error(0, 0, gettext("field number %s is too large"), quote(bad_num));
                free(bad_num);
                exit(1);
            }
            fieldstr++;
        } else
            do {
                error(0, 0, (gettext("invalid byte or field list")));
                usage(1);
            } while (0);
    }


BasicTester, a patch instance with id 162:
Spawn 1 instances, now Total 203
a batched test job starts!
Building:src at:
/home/ubuntu/spr-fast/tests/corebench/coreutils/coreutils-case-7380cf79-2e636af1/tempworkdir/srcMerged code building succ, going to invoke tester!
BasicTester, Testing instance id 153:
Running test command:
/home/ubuntu/spr-fast/tools/coreutils-test.py /home/ubuntu/spr-fast/tests/corebench/coreutils/coreutils-case-7380cf79-2e636af1/tempworkdir/src /home/ubuntu/spr-fast/tests/corebench/coreutils/coreutils-case-7380cf79-2e636af1/tempworkdir/tests /home/ubuntu/spr-fast/tests/corebench/coreutils/coreutils-case-7380cf79-2e636af1/tempworkdir 0  > __res
BasicTester, Testing instance id 154:
Running test command:
/home/ubuntu/spr-fast/tools/coreutils-test.py /home/ubuntu/spr-fast/tests/corebench/coreutils/coreutils-case-7380cf79-2e636af1/tempworkdir/src /home/ubuntu/spr-fast/tests/corebench/coreutils/coreutils-case-7380cf79-2e636af1/tempworkdir/tests /home/ubuntu/spr-fast/tests/corebench/coreutils/coreutils-case-7380cf79-2e636af1/tempworkdir 0  > __res
BasicTester, Testing instance id 155:
Running test command:
/home/ubuntu/spr-fast/tools/coreutils-test.py /home/ubuntu/spr-fast/tests/corebench/coreutils/coreutils-case-7380cf79-2e636af1/tempworkdir/src /home/ubuntu/spr-fast/tests/corebench/coreutils/coreutils-case-7380cf79-2e636af1/tempworkdir/tests /home/ubuntu/spr-fast/tests/corebench/coreutils/coreutils-case-7380cf79-2e636af1/tempworkdir 0  > __res
BasicTester, Testing instance id 156:
Running test command:
/home/ubuntu/spr-fast/tools/coreutils-test.py /home/ubuntu/spr-fast/tests/corebench/coreutils/coreutils-case-7380cf79-2e636af1/tempworkdir/src /home/ubuntu/spr-fast/tests/corebench/coreutils/coreutils-case-7380cf79-2e636af1/tempworkdir/tests /home/ubuntu/spr-fast/tests/corebench/coreutils/coreutils-case-7380cf79-2e636af1/tempworkdir 0  > __res
BasicTester, Testing instance id 157:
Running test command:
/home/ubuntu/spr-fast/tools/coreutils-test.py /home/ubuntu/spr-fast/tests/corebench/coreutils/coreutils-case-7380cf79-2e636af1/tempworkdir/src /home/ubuntu/spr-fast/tests/corebench/coreutils/coreutils-case-7380cf79-2e636af1/tempworkdir/tests /home/ubuntu/spr-fast/tests/corebench/coreutils/coreutils-case-7380cf79-2e636af1/tempworkdir 0  > __res
BasicTester, Testing instance id 158:
Running test command:
/home/ubuntu/spr-fast/tools/coreutils-test.py /home/ubuntu/spr-fast/tests/corebench/coreutils/coreutils-case-7380cf79-2e636af1/tempworkdir/src /home/ubuntu/spr-fast/tests/corebench/coreutils/coreutils-case-7380cf79-2e636af1/tempworkdir/tests /home/ubuntu/spr-fast/tests/corebench/coreutils/coreutils-case-7380cf79-2e636af1/tempworkdir 0  > __res
BasicTester, Testing instance id 159:
Running test command:
/home/ubuntu/spr-fast/tools/coreutils-test.py /home/ubuntu/spr-fast/tests/corebench/coreutils/coreutils-case-7380cf79-2e636af1/tempworkdir/src /home/ubuntu/spr-fast/tests/corebench/coreutils/coreutils-case-7380cf79-2e636af1/tempworkdir/tests /home/ubuntu/spr-fast/tests/corebench/coreutils/coreutils-case-7380cf79-2e636af1/tempworkdir 0  > __res
BasicTester, Testing instance id 160:
Running test command:
/home/ubuntu/spr-fast/tools/coreutils-test.py /home/ubuntu/spr-fast/tests/corebench/coreutils/coreutils-case-7380cf79-2e636af1/tempworkdir/src /home/ubuntu/spr-fast/tests/corebench/coreutils/coreutils-case-7380cf79-2e636af1/tempworkdir/tests /home/ubuntu/spr-fast/tests/corebench/coreutils/coreutils-case-7380cf79-2e636af1/tempworkdir 0  > __res
BasicTester, Testing instance id 161:
Running test command:
/home/ubuntu/spr-fast/tools/coreutils-test.py /home/ubuntu/spr-fast/tests/corebench/coreutils/coreutils-case-7380cf79-2e636af1/tempworkdir/src /home/ubuntu/spr-fast/tests/corebench/coreutils/coreutils-case-7380cf79-2e636af1/tempworkdir/tests /home/ubuntu/spr-fast/tests/corebench/coreutils/coreutils-case-7380cf79-2e636af1/tempworkdir 0  > __res
BasicTester, Testing instance id 162:
Running test command:
/home/ubuntu/spr-fast/tools/coreutils-test.py /home/ubuntu/spr-fast/tests/corebench/coreutils/coreutils-case-7380cf79-2e636af1/tempworkdir/src /home/ubuntu/spr-fast/tests/corebench/coreutils/coreutils-case-7380cf79-2e636af1/tempworkdir/tests /home/ubuntu/spr-fast/tests/corebench/coreutils/coreutils-case-7380cf79-2e636af1/tempworkdir 0  > __res
Counter: 204
Batcher Size:43
Preprocess the following candidate with BasicTester:
Priority 7465
At location src/cut.c:363
--Src File: src/cut.c
Fragment 0:
free(rp);
while (1)
    {
        if (*fieldstr == '-') {
            in_digits = 0;
            if (dash_found)
                do {
                    error(0, 0, (gettext("invalid byte or field list")));
                    usage(1);
                } while (0);
            dash_found = 1;
            fieldstr++;
            initial = (lhs_specified ? value : 1);
            value = 0;
        } else if (*fieldstr == ',' || ((*__ctype_b_loc())[(int)((to_uchar(*fieldstr)))] & (unsigned short)_ISblank) || *fieldstr == '\x00') {
            in_digits = 0;
            if (dash_found) {
                dash_found = 0;
                if (!lhs_specified && !rhs_specified)
                    do {
                        error(0, 0, (gettext("invalid range with no endpoint: -")));
                        usage(1);
                    } while (0);
                if (!rhs_specified) {
                    eol_range_start = initial;
                    field_found = 1;
                } else {
                    if (value < initial)
                        do {
                            error(0, 0, (gettext("invalid decreasing range")));
                            usage(1);
                        } while (0);
                    if (eol_range_start != 0) {
                        if (initial < eol_range_start) {
                            if (eol_range_start <= value) {
                                eol_range_start = initial;
                            } else {
                                do {
                                    if (initial == 0 || value == 0)
                                        do {
                                            error(0, 0, (gettext("fields and positions are numbered from 1")));
                                            usage(1);
                                        } while (0);
                                    if (n_rp >= n_rp_allocated) {
                                        (rp) = x2nrealloc(rp, &n_rp_allocated, sizeof *(rp));
                                    }
                                    rp[n_rp].lo = (initial);
                                    rp[n_rp].hi = (value);
                                    ++n_rp;
                                } while (0);
                            }
                            field_found = 1;
                        }
                    } else {
                        do {
                            if (initial == 0 || value == 0)
                                do {
                                    error(0, 0, (gettext("fields and positions are numbered from 1")));
                                    usage(1);
                                } while (0);
                            if (n_rp >= n_rp_allocated) {
                                (rp) = x2nrealloc(rp, &n_rp_allocated, sizeof *(rp));
                            }
                            rp[n_rp].lo = (initial);
                            rp[n_rp].hi = (value);
                            ++n_rp;
                        } while (0);
                        field_found = 1;
                    }
                    value = 0;
                }
            } else {
                do {
                    if (value == 0 || value == 0)
                        do {
                            error(0, 0, (gettext("fields and positions are numbered from 1")));
                            usage(1);
                        } while (0);
                    if (n_rp >= n_rp_allocated) {
                        (rp) = x2nrealloc(rp, &n_rp_allocated, sizeof *(rp));
                    }
                    rp[n_rp].lo = (value);
                    rp[n_rp].hi = (value);
                    ++n_rp;
                } while (0);
                value = 0;
                field_found = 1;
            }
            if (*fieldstr == '\x00') {
                break;
            }
            fieldstr++;
            lhs_specified = 0;
            rhs_specified = 0;
        } else if (((unsigned int)(*fieldstr) - '0' <= 9)) {
            static const char *num_start;
            if (!in_digits || !num_start)
                num_start = fieldstr;
            in_digits = 1;
            if (dash_found)
                rhs_specified = 1;
            else
                lhs_specified = 1;
            if (!((void)(&(value) == (size_t *)((void *)0)) , (((size_t)-1 / 10 < (value) || (size_t)((value) * 10 + (*fieldstr - '0')) < (value)) ? 0 : (((value) = (value) * 10 + (*fieldstr - '0')) , 1)))) {
                size_t len = strspn(num_start, "0123456789");
                char *bad_num = xstrndup(num_start, len);
                if (operating_mode == byte_mode)
                    error(0, 0, gettext("byte offset %s is too large"), quote(bad_num));
                else
                    error(0, 0, gettext("field number %s is too large"), quote(bad_num));
                free(bad_num);
                exit(1);
            }
            fieldstr++;
        } else
            do {
                error(0, 0, (gettext("invalid byte or field list")));
                usage(1);
            } while (0);
    }


BasicTester, a patch instance with id 163:
Spawn 1 instances, now Total 204
Counter: 205
Batcher Size:44
Preprocess the following candidate with BasicTester:
Priority 7465
At location src/cut.c:363
--Src File: src/cut.c
Fragment 0:
have_read_stdin = (dash_found);
while (1)
    {
        if (*fieldstr == '-') {
            in_digits = 0;
            if (dash_found)
                do {
                    error(0, 0, (gettext("invalid byte or field list")));
                    usage(1);
                } while (0);
            dash_found = 1;
            fieldstr++;
            initial = (lhs_specified ? value : 1);
            value = 0;
        } else if (*fieldstr == ',' || ((*__ctype_b_loc())[(int)((to_uchar(*fieldstr)))] & (unsigned short)_ISblank) || *fieldstr == '\x00') {
            in_digits = 0;
            if (dash_found) {
                dash_found = 0;
                if (!lhs_specified && !rhs_specified)
                    do {
                        error(0, 0, (gettext("invalid range with no endpoint: -")));
                        usage(1);
                    } while (0);
                if (!rhs_specified) {
                    eol_range_start = initial;
                    field_found = 1;
                } else {
                    if (value < initial)
                        do {
                            error(0, 0, (gettext("invalid decreasing range")));
                            usage(1);
                        } while (0);
                    if (eol_range_start != 0) {
                        if (initial < eol_range_start) {
                            if (eol_range_start <= value) {
                                eol_range_start = initial;
                            } else {
                                do {
                                    if (initial == 0 || value == 0)
                                        do {
                                            error(0, 0, (gettext("fields and positions are numbered from 1")));
                                            usage(1);
                                        } while (0);
                                    if (n_rp >= n_rp_allocated) {
                                        (rp) = x2nrealloc(rp, &n_rp_allocated, sizeof *(rp));
                                    }
                                    rp[n_rp].lo = (initial);
                                    rp[n_rp].hi = (value);
                                    ++n_rp;
                                } while (0);
                            }
                            field_found = 1;
                        }
                    } else {
                        do {
                            if (initial == 0 || value == 0)
                                do {
                                    error(0, 0, (gettext("fields and positions are numbered from 1")));
                                    usage(1);
                                } while (0);
                            if (n_rp >= n_rp_allocated) {
                                (rp) = x2nrealloc(rp, &n_rp_allocated, sizeof *(rp));
                            }
                            rp[n_rp].lo = (initial);
                            rp[n_rp].hi = (value);
                            ++n_rp;
                        } while (0);
                        field_found = 1;
                    }
                    value = 0;
                }
            } else {
                do {
                    if (value == 0 || value == 0)
                        do {
                            error(0, 0, (gettext("fields and positions are numbered from 1")));
                            usage(1);
                        } while (0);
                    if (n_rp >= n_rp_allocated) {
                        (rp) = x2nrealloc(rp, &n_rp_allocated, sizeof *(rp));
                    }
                    rp[n_rp].lo = (value);
                    rp[n_rp].hi = (value);
                    ++n_rp;
                } while (0);
                value = 0;
                field_found = 1;
            }
            if (*fieldstr == '\x00') {
                break;
            }
            fieldstr++;
            lhs_specified = 0;
            rhs_specified = 0;
        } else if (((unsigned int)(*fieldstr) - '0' <= 9)) {
            static const char *num_start;
            if (!in_digits || !num_start)
                num_start = fieldstr;
            in_digits = 1;
            if (dash_found)
                rhs_specified = 1;
            else
                lhs_specified = 1;
            if (!((void)(&(value) == (size_t *)((void *)0)) , (((size_t)-1 / 10 < (value) || (size_t)((value) * 10 + (*fieldstr - '0')) < (value)) ? 0 : (((value) = (value) * 10 + (*fieldstr - '0')) , 1)))) {
                size_t len = strspn(num_start, "0123456789");
                char *bad_num = xstrndup(num_start, len);
                if (operating_mode == byte_mode)
                    error(0, 0, gettext("byte offset %s is too large"), quote(bad_num));
                else
                    error(0, 0, gettext("field number %s is too large"), quote(bad_num));
                free(bad_num);
                exit(1);
            }
            fieldstr++;
        } else
            do {
                error(0, 0, (gettext("invalid byte or field list")));
                usage(1);
            } while (0);
    }


BasicTester, a patch instance with id 164:
Spawn 1 instances, now Total 205
Counter: 206
Batcher Size:45
Preprocess the following candidate with BasicTester:
Priority 7465
At location src/cut.c:363
--Src File: src/cut.c
Fragment 0:
eol_range_start = (n_rp);
while (1)
    {
        if (*fieldstr == '-') {
            in_digits = 0;
            if (dash_found)
                do {
                    error(0, 0, (gettext("invalid byte or field list")));
                    usage(1);
                } while (0);
            dash_found = 1;
            fieldstr++;
            initial = (lhs_specified ? value : 1);
            value = 0;
        } else if (*fieldstr == ',' || ((*__ctype_b_loc())[(int)((to_uchar(*fieldstr)))] & (unsigned short)_ISblank) || *fieldstr == '\x00') {
            in_digits = 0;
            if (dash_found) {
                dash_found = 0;
                if (!lhs_specified && !rhs_specified)
                    do {
                        error(0, 0, (gettext("invalid range with no endpoint: -")));
                        usage(1);
                    } while (0);
                if (!rhs_specified) {
                    eol_range_start = initial;
                    field_found = 1;
                } else {
                    if (value < initial)
                        do {
                            error(0, 0, (gettext("invalid decreasing range")));
                            usage(1);
                        } while (0);
                    if (eol_range_start != 0) {
                        if (initial < eol_range_start) {
                            if (eol_range_start <= value) {
                                eol_range_start = initial;
                            } else {
                                do {
                                    if (initial == 0 || value == 0)
                                        do {
                                            error(0, 0, (gettext("fields and positions are numbered from 1")));
                                            usage(1);
                                        } while (0);
                                    if (n_rp >= n_rp_allocated) {
                                        (rp) = x2nrealloc(rp, &n_rp_allocated, sizeof *(rp));
                                    }
                                    rp[n_rp].lo = (initial);
                                    rp[n_rp].hi = (value);
                                    ++n_rp;
                                } while (0);
                            }
                            field_found = 1;
                        }
                    } else {
                        do {
                            if (initial == 0 || value == 0)
                                do {
                                    error(0, 0, (gettext("fields and positions are numbered from 1")));
                                    usage(1);
                                } while (0);
                            if (n_rp >= n_rp_allocated) {
                                (rp) = x2nrealloc(rp, &n_rp_allocated, sizeof *(rp));
                            }
                            rp[n_rp].lo = (initial);
                            rp[n_rp].hi = (value);
                            ++n_rp;
                        } while (0);
                        field_found = 1;
                    }
                    value = 0;
                }
            } else {
                do {
                    if (value == 0 || value == 0)
                        do {
                            error(0, 0, (gettext("fields and positions are numbered from 1")));
                            usage(1);
                        } while (0);
                    if (n_rp >= n_rp_allocated) {
                        (rp) = x2nrealloc(rp, &n_rp_allocated, sizeof *(rp));
                    }
                    rp[n_rp].lo = (value);
                    rp[n_rp].hi = (value);
                    ++n_rp;
                } while (0);
                value = 0;
                field_found = 1;
            }
            if (*fieldstr == '\x00') {
                break;
            }
            fieldstr++;
            lhs_specified = 0;
            rhs_specified = 0;
        } else if (((unsigned int)(*fieldstr) - '0' <= 9)) {
            static const char *num_start;
            if (!in_digits || !num_start)
                num_start = fieldstr;
            in_digits = 1;
            if (dash_found)
                rhs_specified = 1;
            else
                lhs_specified = 1;
            if (!((void)(&(value) == (size_t *)((void *)0)) , (((size_t)-1 / 10 < (value) || (size_t)((value) * 10 + (*fieldstr - '0')) < (value)) ? 0 : (((value) = (value) * 10 + (*fieldstr - '0')) , 1)))) {
                size_t len = strspn(num_start, "0123456789");
                char *bad_num = xstrndup(num_start, len);
                if (operating_mode == byte_mode)
                    error(0, 0, gettext("byte offset %s is too large"), quote(bad_num));
                else
                    error(0, 0, gettext("field number %s is too large"), quote(bad_num));
                free(bad_num);
                exit(1);
            }
            fieldstr++;
        } else
            do {
                error(0, 0, (gettext("invalid byte or field list")));
                usage(1);
            } while (0);
    }


BasicTester, a patch instance with id 165:
Spawn 1 instances, now Total 206
Counter: 207
Batcher Size:46
Preprocess the following candidate with BasicTester:
Priority 7465
At location src/cut.c:363
--Src File: src/cut.c
Fragment 0:
field_1_buffer = ((void *)0);
while (1)
    {
        if (*fieldstr == '-') {
            in_digits = 0;
            if (dash_found)
                do {
                    error(0, 0, (gettext("invalid byte or field list")));
                    usage(1);
                } while (0);
            dash_found = 1;
            fieldstr++;
            initial = (lhs_specified ? value : 1);
            value = 0;
        } else if (*fieldstr == ',' || ((*__ctype_b_loc())[(int)((to_uchar(*fieldstr)))] & (unsigned short)_ISblank) || *fieldstr == '\x00') {
            in_digits = 0;
            if (dash_found) {
                dash_found = 0;
                if (!lhs_specified && !rhs_specified)
                    do {
                        error(0, 0, (gettext("invalid range with no endpoint: -")));
                        usage(1);
                    } while (0);
                if (!rhs_specified) {
                    eol_range_start = initial;
                    field_found = 1;
                } else {
                    if (value < initial)
                        do {
                            error(0, 0, (gettext("invalid decreasing range")));
                            usage(1);
                        } while (0);
                    if (eol_range_start != 0) {
                        if (initial < eol_range_start) {
                            if (eol_range_start <= value) {
                                eol_range_start = initial;
                            } else {
                                do {
                                    if (initial == 0 || value == 0)
                                        do {
                                            error(0, 0, (gettext("fields and positions are numbered from 1")));
                                            usage(1);
                                        } while (0);
                                    if (n_rp >= n_rp_allocated) {
                                        (rp) = x2nrealloc(rp, &n_rp_allocated, sizeof *(rp));
                                    }
                                    rp[n_rp].lo = (initial);
                                    rp[n_rp].hi = (value);
                                    ++n_rp;
                                } while (0);
                            }
                            field_found = 1;
                        }
                    } else {
                        do {
                            if (initial == 0 || value == 0)
                                do {
                                    error(0, 0, (gettext("fields and positions are numbered from 1")));
                                    usage(1);
                                } while (0);
                            if (n_rp >= n_rp_allocated) {
                                (rp) = x2nrealloc(rp, &n_rp_allocated, sizeof *(rp));
                            }
                            rp[n_rp].lo = (initial);
                            rp[n_rp].hi = (value);
                            ++n_rp;
                        } while (0);
                        field_found = 1;
                    }
                    value = 0;
                }
            } else {
                do {
                    if (value == 0 || value == 0)
                        do {
                            error(0, 0, (gettext("fields and positions are numbered from 1")));
                            usage(1);
                        } while (0);
                    if (n_rp >= n_rp_allocated) {
                        (rp) = x2nrealloc(rp, &n_rp_allocated, sizeof *(rp));
                    }
                    rp[n_rp].lo = (value);
                    rp[n_rp].hi = (value);
                    ++n_rp;
                } while (0);
                value = 0;
                field_found = 1;
            }
            if (*fieldstr == '\x00') {
                break;
            }
            fieldstr++;
            lhs_specified = 0;
            rhs_specified = 0;
        } else if (((unsigned int)(*fieldstr) - '0' <= 9)) {
            static const char *num_start;
            if (!in_digits || !num_start)
                num_start = fieldstr;
            in_digits = 1;
            if (dash_found)
                rhs_specified = 1;
            else
                lhs_specified = 1;
            if (!((void)(&(value) == (size_t *)((void *)0)) , (((size_t)-1 / 10 < (value) || (size_t)((value) * 10 + (*fieldstr - '0')) < (value)) ? 0 : (((value) = (value) * 10 + (*fieldstr - '0')) , 1)))) {
                size_t len = strspn(num_start, "0123456789");
                char *bad_num = xstrndup(num_start, len);
                if (operating_mode == byte_mode)
                    error(0, 0, gettext("byte offset %s is too large"), quote(bad_num));
                else
                    error(0, 0, gettext("field number %s is too large"), quote(bad_num));
                free(bad_num);
                exit(1);
            }
            fieldstr++;
        } else
            do {
                error(0, 0, (gettext("invalid byte or field list")));
                usage(1);
            } while (0);
    }


BasicTester, a patch instance with id 166:
Spawn 1 instances, now Total 207
Counter: 208
Batcher Size:47
Preprocess the following candidate with BasicTester:
Priority 7465
At location src/cut.c:363
--Src File: src/cut.c
Fragment 0:
field_found = (lhs_specified);
while (1)
    {
        if (*fieldstr == '-') {
            in_digits = 0;
            if (dash_found)
                do {
                    error(0, 0, (gettext("invalid byte or field list")));
                    usage(1);
                } while (0);
            dash_found = 1;
            fieldstr++;
            initial = (lhs_specified ? value : 1);
            value = 0;
        } else if (*fieldstr == ',' || ((*__ctype_b_loc())[(int)((to_uchar(*fieldstr)))] & (unsigned short)_ISblank) || *fieldstr == '\x00') {
            in_digits = 0;
            if (dash_found) {
                dash_found = 0;
                if (!lhs_specified && !rhs_specified)
                    do {
                        error(0, 0, (gettext("invalid range with no endpoint: -")));
                        usage(1);
                    } while (0);
                if (!rhs_specified) {
                    eol_range_start = initial;
                    field_found = 1;
                } else {
                    if (value < initial)
                        do {
                            error(0, 0, (gettext("invalid decreasing range")));
                            usage(1);
                        } while (0);
                    if (eol_range_start != 0) {
                        if (initial < eol_range_start) {
                            if (eol_range_start <= value) {
                                eol_range_start = initial;
                            } else {
                                do {
                                    if (initial == 0 || value == 0)
                                        do {
                                            error(0, 0, (gettext("fields and positions are numbered from 1")));
                                            usage(1);
                                        } while (0);
                                    if (n_rp >= n_rp_allocated) {
                                        (rp) = x2nrealloc(rp, &n_rp_allocated, sizeof *(rp));
                                    }
                                    rp[n_rp].lo = (initial);
                                    rp[n_rp].hi = (value);
                                    ++n_rp;
                                } while (0);
                            }
                            field_found = 1;
                        }
                    } else {
                        do {
                            if (initial == 0 || value == 0)
                                do {
                                    error(0, 0, (gettext("fields and positions are numbered from 1")));
                                    usage(1);
                                } while (0);
                            if (n_rp >= n_rp_allocated) {
                                (rp) = x2nrealloc(rp, &n_rp_allocated, sizeof *(rp));
                            }
                            rp[n_rp].lo = (initial);
                            rp[n_rp].hi = (value);
                            ++n_rp;
                        } while (0);
                        field_found = 1;
                    }
                    value = 0;
                }
            } else {
                do {
                    if (value == 0 || value == 0)
                        do {
                            error(0, 0, (gettext("fields and positions are numbered from 1")));
                            usage(1);
                        } while (0);
                    if (n_rp >= n_rp_allocated) {
                        (rp) = x2nrealloc(rp, &n_rp_allocated, sizeof *(rp));
                    }
                    rp[n_rp].lo = (value);
                    rp[n_rp].hi = (value);
                    ++n_rp;
                } while (0);
                value = 0;
                field_found = 1;
            }
            if (*fieldstr == '\x00') {
                break;
            }
            fieldstr++;
            lhs_specified = 0;
            rhs_specified = 0;
        } else if (((unsigned int)(*fieldstr) - '0' <= 9)) {
            static const char *num_start;
            if (!in_digits || !num_start)
                num_start = fieldstr;
            in_digits = 1;
            if (dash_found)
                rhs_specified = 1;
            else
                lhs_specified = 1;
            if (!((void)(&(value) == (size_t *)((void *)0)) , (((size_t)-1 / 10 < (value) || (size_t)((value) * 10 + (*fieldstr - '0')) < (value)) ? 0 : (((value) = (value) * 10 + (*fieldstr - '0')) , 1)))) {
                size_t len = strspn(num_start, "0123456789");
                char *bad_num = xstrndup(num_start, len);
                if (operating_mode == byte_mode)
                    error(0, 0, gettext("byte offset %s is too large"), quote(bad_num));
                else
                    error(0, 0, gettext("field number %s is too large"), quote(bad_num));
                free(bad_num);
                exit(1);
            }
            fieldstr++;
        } else
            do {
                error(0, 0, (gettext("invalid byte or field list")));
                usage(1);
            } while (0);
    }


BasicTester, a patch instance with id 167:
Spawn 1 instances, now Total 208
Counter: 209
Batcher Size:48
Preprocess the following candidate with BasicTester:
Priority 7465
At location src/cut.c:363
--Src File: src/cut.c
Fragment 0:
field_found = 1;
while (1)
    {
        if (*fieldstr == '-') {
            in_digits = 0;
            if (dash_found)
                do {
                    error(0, 0, (gettext("invalid byte or field list")));
                    usage(1);
                } while (0);
            dash_found = 1;
            fieldstr++;
            initial = (lhs_specified ? value : 1);
            value = 0;
        } else if (*fieldstr == ',' || ((*__ctype_b_loc())[(int)((to_uchar(*fieldstr)))] & (unsigned short)_ISblank) || *fieldstr == '\x00') {
            in_digits = 0;
            if (dash_found) {
                dash_found = 0;
                if (!lhs_specified && !rhs_specified)
                    do {
                        error(0, 0, (gettext("invalid range with no endpoint: -")));
                        usage(1);
                    } while (0);
                if (!rhs_specified) {
                    eol_range_start = initial;
                    field_found = 1;
                } else {
                    if (value < initial)
                        do {
                            error(0, 0, (gettext("invalid decreasing range")));
                            usage(1);
                        } while (0);
                    if (eol_range_start != 0) {
                        if (initial < eol_range_start) {
                            if (eol_range_start <= value) {
                                eol_range_start = initial;
                            } else {
                                do {
                                    if (initial == 0 || value == 0)
                                        do {
                                            error(0, 0, (gettext("fields and positions are numbered from 1")));
                                            usage(1);
                                        } while (0);
                                    if (n_rp >= n_rp_allocated) {
                                        (rp) = x2nrealloc(rp, &n_rp_allocated, sizeof *(rp));
                                    }
                                    rp[n_rp].lo = (initial);
                                    rp[n_rp].hi = (value);
                                    ++n_rp;
                                } while (0);
                            }
                            field_found = 1;
                        }
                    } else {
                        do {
                            if (initial == 0 || value == 0)
                                do {
                                    error(0, 0, (gettext("fields and positions are numbered from 1")));
                                    usage(1);
                                } while (0);
                            if (n_rp >= n_rp_allocated) {
                                (rp) = x2nrealloc(rp, &n_rp_allocated, sizeof *(rp));
                            }
                            rp[n_rp].lo = (initial);
                            rp[n_rp].hi = (value);
                            ++n_rp;
                        } while (0);
                        field_found = 1;
                    }
                    value = 0;
                }
            } else {
                do {
                    if (value == 0 || value == 0)
                        do {
                            error(0, 0, (gettext("fields and positions are numbered from 1")));
                            usage(1);
                        } while (0);
                    if (n_rp >= n_rp_allocated) {
                        (rp) = x2nrealloc(rp, &n_rp_allocated, sizeof *(rp));
                    }
                    rp[n_rp].lo = (value);
                    rp[n_rp].hi = (value);
                    ++n_rp;
                } while (0);
                value = 0;
                field_found = 1;
            }
            if (*fieldstr == '\x00') {
                break;
            }
            fieldstr++;
            lhs_specified = 0;
            rhs_specified = 0;
        } else if (((unsigned int)(*fieldstr) - '0' <= 9)) {
            static const char *num_start;
            if (!in_digits || !num_start)
                num_start = fieldstr;
            in_digits = 1;
            if (dash_found)
                rhs_specified = 1;
            else
                lhs_specified = 1;
            if (!((void)(&(value) == (size_t *)((void *)0)) , (((size_t)-1 / 10 < (value) || (size_t)((value) * 10 + (*fieldstr - '0')) < (value)) ? 0 : (((value) = (value) * 10 + (*fieldstr - '0')) , 1)))) {
                size_t len = strspn(num_start, "0123456789");
                char *bad_num = xstrndup(num_start, len);
                if (operating_mode == byte_mode)
                    error(0, 0, gettext("byte offset %s is too large"), quote(bad_num));
                else
                    error(0, 0, gettext("field number %s is too large"), quote(bad_num));
                free(bad_num);
                exit(1);
            }
            fieldstr++;
        } else
            do {
                error(0, 0, (gettext("invalid byte or field list")));
                usage(1);
            } while (0);
    }


BasicTester, a patch instance with id 168:
Spawn 1 instances, now Total 209
Counter: 210
Batcher Size:49
Preprocess the following candidate with BasicTester:
Priority 7465
At location src/cut.c:363
--Src File: src/cut.c
Fragment 0:
fieldstr++;
while (1)
    {
        if (*fieldstr == '-') {
            in_digits = 0;
            if (dash_found)
                do {
                    error(0, 0, (gettext("invalid byte or field list")));
                    usage(1);
                } while (0);
            dash_found = 1;
            fieldstr++;
            initial = (lhs_specified ? value : 1);
            value = 0;
        } else if (*fieldstr == ',' || ((*__ctype_b_loc())[(int)((to_uchar(*fieldstr)))] & (unsigned short)_ISblank) || *fieldstr == '\x00') {
            in_digits = 0;
            if (dash_found) {
                dash_found = 0;
                if (!lhs_specified && !rhs_specified)
                    do {
                        error(0, 0, (gettext("invalid range with no endpoint: -")));
                        usage(1);
                    } while (0);
                if (!rhs_specified) {
                    eol_range_start = initial;
                    field_found = 1;
                } else {
                    if (value < initial)
                        do {
                            error(0, 0, (gettext("invalid decreasing range")));
                            usage(1);
                        } while (0);
                    if (eol_range_start != 0) {
                        if (initial < eol_range_start) {
                            if (eol_range_start <= value) {
                                eol_range_start = initial;
                            } else {
                                do {
                                    if (initial == 0 || value == 0)
                                        do {
                                            error(0, 0, (gettext("fields and positions are numbered from 1")));
                                            usage(1);
                                        } while (0);
                                    if (n_rp >= n_rp_allocated) {
                                        (rp) = x2nrealloc(rp, &n_rp_allocated, sizeof *(rp));
                                    }
                                    rp[n_rp].lo = (initial);
                                    rp[n_rp].hi = (value);
                                    ++n_rp;
                                } while (0);
                            }
                            field_found = 1;
                        }
                    } else {
                        do {
                            if (initial == 0 || value == 0)
                                do {
                                    error(0, 0, (gettext("fields and positions are numbered from 1")));
                                    usage(1);
                                } while (0);
                            if (n_rp >= n_rp_allocated) {
                                (rp) = x2nrealloc(rp, &n_rp_allocated, sizeof *(rp));
                            }
                            rp[n_rp].lo = (initial);
                            rp[n_rp].hi = (value);
                            ++n_rp;
                        } while (0);
                        field_found = 1;
                    }
                    value = 0;
                }
            } else {
                do {
                    if (value == 0 || value == 0)
                        do {
                            error(0, 0, (gettext("fields and positions are numbered from 1")));
                            usage(1);
                        } while (0);
                    if (n_rp >= n_rp_allocated) {
                        (rp) = x2nrealloc(rp, &n_rp_allocated, sizeof *(rp));
                    }
                    rp[n_rp].lo = (value);
                    rp[n_rp].hi = (value);
                    ++n_rp;
                } while (0);
                value = 0;
                field_found = 1;
            }
            if (*fieldstr == '\x00') {
                break;
            }
            fieldstr++;
            lhs_specified = 0;
            rhs_specified = 0;
        } else if (((unsigned int)(*fieldstr) - '0' <= 9)) {
            static const char *num_start;
            if (!in_digits || !num_start)
                num_start = fieldstr;
            in_digits = 1;
            if (dash_found)
                rhs_specified = 1;
            else
                lhs_specified = 1;
            if (!((void)(&(value) == (size_t *)((void *)0)) , (((size_t)-1 / 10 < (value) || (size_t)((value) * 10 + (*fieldstr - '0')) < (value)) ? 0 : (((value) = (value) * 10 + (*fieldstr - '0')) , 1)))) {
                size_t len = strspn(num_start, "0123456789");
                char *bad_num = xstrndup(num_start, len);
                if (operating_mode == byte_mode)
                    error(0, 0, gettext("byte offset %s is too large"), quote(bad_num));
                else
                    error(0, 0, gettext("field number %s is too large"), quote(bad_num));
                free(bad_num);
                exit(1);
            }
            fieldstr++;
        } else
            do {
                error(0, 0, (gettext("invalid byte or field list")));
                usage(1);
            } while (0);
    }


BasicTester, a patch instance with id 169:
Spawn 1 instances, now Total 210
Counter: 211
Batcher Size:50
Preprocess the following candidate with BasicTester:
Priority 7465
At location src/cut.c:363
--Src File: src/cut.c
Fragment 0:
field_found = (rhs_specified);
while (1)
    {
        if (*fieldstr == '-') {
            in_digits = 0;
            if (dash_found)
                do {
                    error(0, 0, (gettext("invalid byte or field list")));
                    usage(1);
                } while (0);
            dash_found = 1;
            fieldstr++;
            initial = (lhs_specified ? value : 1);
            value = 0;
        } else if (*fieldstr == ',' || ((*__ctype_b_loc())[(int)((to_uchar(*fieldstr)))] & (unsigned short)_ISblank) || *fieldstr == '\x00') {
            in_digits = 0;
            if (dash_found) {
                dash_found = 0;
                if (!lhs_specified && !rhs_specified)
                    do {
                        error(0, 0, (gettext("invalid range with no endpoint: -")));
                        usage(1);
                    } while (0);
                if (!rhs_specified) {
                    eol_range_start = initial;
                    field_found = 1;
                } else {
                    if (value < initial)
                        do {
                            error(0, 0, (gettext("invalid decreasing range")));
                            usage(1);
                        } while (0);
                    if (eol_range_start != 0) {
                        if (initial < eol_range_start) {
                            if (eol_range_start <= value) {
                                eol_range_start = initial;
                            } else {
                                do {
                                    if (initial == 0 || value == 0)
                                        do {
                                            error(0, 0, (gettext("fields and positions are numbered from 1")));
                                            usage(1);
                                        } while (0);
                                    if (n_rp >= n_rp_allocated) {
                                        (rp) = x2nrealloc(rp, &n_rp_allocated, sizeof *(rp));
                                    }
                                    rp[n_rp].lo = (initial);
                                    rp[n_rp].hi = (value);
                                    ++n_rp;
                                } while (0);
                            }
                            field_found = 1;
                        }
                    } else {
                        do {
                            if (initial == 0 || value == 0)
                                do {
                                    error(0, 0, (gettext("fields and positions are numbered from 1")));
                                    usage(1);
                                } while (0);
                            if (n_rp >= n_rp_allocated) {
                                (rp) = x2nrealloc(rp, &n_rp_allocated, sizeof *(rp));
                            }
                            rp[n_rp].lo = (initial);
                            rp[n_rp].hi = (value);
                            ++n_rp;
                        } while (0);
                        field_found = 1;
                    }
                    value = 0;
                }
            } else {
                do {
                    if (value == 0 || value == 0)
                        do {
                            error(0, 0, (gettext("fields and positions are numbered from 1")));
                            usage(1);
                        } while (0);
                    if (n_rp >= n_rp_allocated) {
                        (rp) = x2nrealloc(rp, &n_rp_allocated, sizeof *(rp));
                    }
                    rp[n_rp].lo = (value);
                    rp[n_rp].hi = (value);
                    ++n_rp;
                } while (0);
                value = 0;
                field_found = 1;
            }
            if (*fieldstr == '\x00') {
                break;
            }
            fieldstr++;
            lhs_specified = 0;
            rhs_specified = 0;
        } else if (((unsigned int)(*fieldstr) - '0' <= 9)) {
            static const char *num_start;
            if (!in_digits || !num_start)
                num_start = fieldstr;
            in_digits = 1;
            if (dash_found)
                rhs_specified = 1;
            else
                lhs_specified = 1;
            if (!((void)(&(value) == (size_t *)((void *)0)) , (((size_t)-1 / 10 < (value) || (size_t)((value) * 10 + (*fieldstr - '0')) < (value)) ? 0 : (((value) = (value) * 10 + (*fieldstr - '0')) , 1)))) {
                size_t len = strspn(num_start, "0123456789");
                char *bad_num = xstrndup(num_start, len);
                if (operating_mode == byte_mode)
                    error(0, 0, gettext("byte offset %s is too large"), quote(bad_num));
                else
                    error(0, 0, gettext("field number %s is too large"), quote(bad_num));
                free(bad_num);
                exit(1);
            }
            fieldstr++;
        } else
            do {
                error(0, 0, (gettext("invalid byte or field list")));
                usage(1);
            } while (0);
    }


BasicTester, a patch instance with id 170:
Spawn 1 instances, now Total 211
Counter: 212
Batcher Size:51
Preprocess the following candidate with BasicTester:
Priority 7465
At location src/cut.c:363
--Src File: src/cut.c
Fragment 0:
field_found = (dash_found);
while (1)
    {
        if (*fieldstr == '-') {
            in_digits = 0;
            if (dash_found)
                do {
                    error(0, 0, (gettext("invalid byte or field list")));
                    usage(1);
                } while (0);
            dash_found = 1;
            fieldstr++;
            initial = (lhs_specified ? value : 1);
            value = 0;
        } else if (*fieldstr == ',' || ((*__ctype_b_loc())[(int)((to_uchar(*fieldstr)))] & (unsigned short)_ISblank) || *fieldstr == '\x00') {
            in_digits = 0;
            if (dash_found) {
                dash_found = 0;
                if (!lhs_specified && !rhs_specified)
                    do {
                        error(0, 0, (gettext("invalid range with no endpoint: -")));
                        usage(1);
                    } while (0);
                if (!rhs_specified) {
                    eol_range_start = initial;
                    field_found = 1;
                } else {
                    if (value < initial)
                        do {
                            error(0, 0, (gettext("invalid decreasing range")));
                            usage(1);
                        } while (0);
                    if (eol_range_start != 0) {
                        if (initial < eol_range_start) {
                            if (eol_range_start <= value) {
                                eol_range_start = initial;
                            } else {
                                do {
                                    if (initial == 0 || value == 0)
                                        do {
                                            error(0, 0, (gettext("fields and positions are numbered from 1")));
                                            usage(1);
                                        } while (0);
                                    if (n_rp >= n_rp_allocated) {
                                        (rp) = x2nrealloc(rp, &n_rp_allocated, sizeof *(rp));
                                    }
                                    rp[n_rp].lo = (initial);
                                    rp[n_rp].hi = (value);
                                    ++n_rp;
                                } while (0);
                            }
                            field_found = 1;
                        }
                    } else {
                        do {
                            if (initial == 0 || value == 0)
                                do {
                                    error(0, 0, (gettext("fields and positions are numbered from 1")));
                                    usage(1);
                                } while (0);
                            if (n_rp >= n_rp_allocated) {
                                (rp) = x2nrealloc(rp, &n_rp_allocated, sizeof *(rp));
                            }
                            rp[n_rp].lo = (initial);
                            rp[n_rp].hi = (value);
                            ++n_rp;
                        } while (0);
                        field_found = 1;
                    }
                    value = 0;
                }
            } else {
                do {
                    if (value == 0 || value == 0)
                        do {
                            error(0, 0, (gettext("fields and positions are numbered from 1")));
                            usage(1);
                        } while (0);
                    if (n_rp >= n_rp_allocated) {
                        (rp) = x2nrealloc(rp, &n_rp_allocated, sizeof *(rp));
                    }
                    rp[n_rp].lo = (value);
                    rp[n_rp].hi = (value);
                    ++n_rp;
                } while (0);
                value = 0;
                field_found = 1;
            }
            if (*fieldstr == '\x00') {
                break;
            }
            fieldstr++;
            lhs_specified = 0;
            rhs_specified = 0;
        } else if (((unsigned int)(*fieldstr) - '0' <= 9)) {
            static const char *num_start;
            if (!in_digits || !num_start)
                num_start = fieldstr;
            in_digits = 1;
            if (dash_found)
                rhs_specified = 1;
            else
                lhs_specified = 1;
            if (!((void)(&(value) == (size_t *)((void *)0)) , (((size_t)-1 / 10 < (value) || (size_t)((value) * 10 + (*fieldstr - '0')) < (value)) ? 0 : (((value) = (value) * 10 + (*fieldstr - '0')) , 1)))) {
                size_t len = strspn(num_start, "0123456789");
                char *bad_num = xstrndup(num_start, len);
                if (operating_mode == byte_mode)
                    error(0, 0, gettext("byte offset %s is too large"), quote(bad_num));
                else
                    error(0, 0, gettext("field number %s is too large"), quote(bad_num));
                free(bad_num);
                exit(1);
            }
            fieldstr++;
        } else
            do {
                error(0, 0, (gettext("invalid byte or field list")));
                usage(1);
            } while (0);
    }


BasicTester, a patch instance with id 171:
Spawn 1 instances, now Total 212
Counter: 213
Batcher Size:52
Preprocess the following candidate with BasicTester:
Priority 7465
At location src/cut.c:363
--Src File: src/cut.c
Fragment 0:
field_found = (field_found);
while (1)
    {
        if (*fieldstr == '-') {
            in_digits = 0;
            if (dash_found)
                do {
                    error(0, 0, (gettext("invalid byte or field list")));
                    usage(1);
                } while (0);
            dash_found = 1;
            fieldstr++;
            initial = (lhs_specified ? value : 1);
            value = 0;
        } else if (*fieldstr == ',' || ((*__ctype_b_loc())[(int)((to_uchar(*fieldstr)))] & (unsigned short)_ISblank) || *fieldstr == '\x00') {
            in_digits = 0;
            if (dash_found) {
                dash_found = 0;
                if (!lhs_specified && !rhs_specified)
                    do {
                        error(0, 0, (gettext("invalid range with no endpoint: -")));
                        usage(1);
                    } while (0);
                if (!rhs_specified) {
                    eol_range_start = initial;
                    field_found = 1;
                } else {
                    if (value < initial)
                        do {
                            error(0, 0, (gettext("invalid decreasing range")));
                            usage(1);
                        } while (0);
                    if (eol_range_start != 0) {
                        if (initial < eol_range_start) {
                            if (eol_range_start <= value) {
                                eol_range_start = initial;
                            } else {
                                do {
                                    if (initial == 0 || value == 0)
                                        do {
                                            error(0, 0, (gettext("fields and positions are numbered from 1")));
                                            usage(1);
                                        } while (0);
                                    if (n_rp >= n_rp_allocated) {
                                        (rp) = x2nrealloc(rp, &n_rp_allocated, sizeof *(rp));
                                    }
                                    rp[n_rp].lo = (initial);
                                    rp[n_rp].hi = (value);
                                    ++n_rp;
                                } while (0);
                            }
                            field_found = 1;
                        }
                    } else {
                        do {
                            if (initial == 0 || value == 0)
                                do {
                                    error(0, 0, (gettext("fields and positions are numbered from 1")));
                                    usage(1);
                                } while (0);
                            if (n_rp >= n_rp_allocated) {
                                (rp) = x2nrealloc(rp, &n_rp_allocated, sizeof *(rp));
                            }
                            rp[n_rp].lo = (initial);
                            rp[n_rp].hi = (value);
                            ++n_rp;
                        } while (0);
                        field_found = 1;
                    }
                    value = 0;
                }
            } else {
                do {
                    if (value == 0 || value == 0)
                        do {
                            error(0, 0, (gettext("fields and positions are numbered from 1")));
                            usage(1);
                        } while (0);
                    if (n_rp >= n_rp_allocated) {
                        (rp) = x2nrealloc(rp, &n_rp_allocated, sizeof *(rp));
                    }
                    rp[n_rp].lo = (value);
                    rp[n_rp].hi = (value);
                    ++n_rp;
                } while (0);
                value = 0;
                field_found = 1;
            }
            if (*fieldstr == '\x00') {
                break;
            }
            fieldstr++;
            lhs_specified = 0;
            rhs_specified = 0;
        } else if (((unsigned int)(*fieldstr) - '0' <= 9)) {
            static const char *num_start;
            if (!in_digits || !num_start)
                num_start = fieldstr;
            in_digits = 1;
            if (dash_found)
                rhs_specified = 1;
            else
                lhs_specified = 1;
            if (!((void)(&(value) == (size_t *)((void *)0)) , (((size_t)-1 / 10 < (value) || (size_t)((value) * 10 + (*fieldstr - '0')) < (value)) ? 0 : (((value) = (value) * 10 + (*fieldstr - '0')) , 1)))) {
                size_t len = strspn(num_start, "0123456789");
                char *bad_num = xstrndup(num_start, len);
                if (operating_mode == byte_mode)
                    error(0, 0, gettext("byte offset %s is too large"), quote(bad_num));
                else
                    error(0, 0, gettext("field number %s is too large"), quote(bad_num));
                free(bad_num);
                exit(1);
            }
            fieldstr++;
        } else
            do {
                error(0, 0, (gettext("invalid byte or field list")));
                usage(1);
            } while (0);
    }


BasicTester, a patch instance with id 172:
Spawn 1 instances, now Total 213
a batched test job starts!
Building:src at:
/home/ubuntu/spr-fast/tests/corebench/coreutils/coreutils-case-7380cf79-2e636af1/tempworkdir/srcMerged code building succ, going to invoke tester!
BasicTester, Testing instance id 163:
Running test command:
/home/ubuntu/spr-fast/tools/coreutils-test.py /home/ubuntu/spr-fast/tests/corebench/coreutils/coreutils-case-7380cf79-2e636af1/tempworkdir/src /home/ubuntu/spr-fast/tests/corebench/coreutils/coreutils-case-7380cf79-2e636af1/tempworkdir/tests /home/ubuntu/spr-fast/tests/corebench/coreutils/coreutils-case-7380cf79-2e636af1/tempworkdir 0  > __res
BasicTester, Testing instance id 164:
Running test command:
/home/ubuntu/spr-fast/tools/coreutils-test.py /home/ubuntu/spr-fast/tests/corebench/coreutils/coreutils-case-7380cf79-2e636af1/tempworkdir/src /home/ubuntu/spr-fast/tests/corebench/coreutils/coreutils-case-7380cf79-2e636af1/tempworkdir/tests /home/ubuntu/spr-fast/tests/corebench/coreutils/coreutils-case-7380cf79-2e636af1/tempworkdir 0  > __res
BasicTester, Testing instance id 165:
Running test command:
/home/ubuntu/spr-fast/tools/coreutils-test.py /home/ubuntu/spr-fast/tests/corebench/coreutils/coreutils-case-7380cf79-2e636af1/tempworkdir/src /home/ubuntu/spr-fast/tests/corebench/coreutils/coreutils-case-7380cf79-2e636af1/tempworkdir/tests /home/ubuntu/spr-fast/tests/corebench/coreutils/coreutils-case-7380cf79-2e636af1/tempworkdir 0  > __res
BasicTester, Testing instance id 166:
Running test command:
/home/ubuntu/spr-fast/tools/coreutils-test.py /home/ubuntu/spr-fast/tests/corebench/coreutils/coreutils-case-7380cf79-2e636af1/tempworkdir/src /home/ubuntu/spr-fast/tests/corebench/coreutils/coreutils-case-7380cf79-2e636af1/tempworkdir/tests /home/ubuntu/spr-fast/tests/corebench/coreutils/coreutils-case-7380cf79-2e636af1/tempworkdir 0  > __res
BasicTester, Testing instance id 167:
Running test command:
/home/ubuntu/spr-fast/tools/coreutils-test.py /home/ubuntu/spr-fast/tests/corebench/coreutils/coreutils-case-7380cf79-2e636af1/tempworkdir/src /home/ubuntu/spr-fast/tests/corebench/coreutils/coreutils-case-7380cf79-2e636af1/tempworkdir/tests /home/ubuntu/spr-fast/tests/corebench/coreutils/coreutils-case-7380cf79-2e636af1/tempworkdir 0  > __res
BasicTester, Testing instance id 168:
Running test command:
/home/ubuntu/spr-fast/tools/coreutils-test.py /home/ubuntu/spr-fast/tests/corebench/coreutils/coreutils-case-7380cf79-2e636af1/tempworkdir/src /home/ubuntu/spr-fast/tests/corebench/coreutils/coreutils-case-7380cf79-2e636af1/tempworkdir/tests /home/ubuntu/spr-fast/tests/corebench/coreutils/coreutils-case-7380cf79-2e636af1/tempworkdir 0  > __res
BasicTester, Testing instance id 169:
Running test command:
/home/ubuntu/spr-fast/tools/coreutils-test.py /home/ubuntu/spr-fast/tests/corebench/coreutils/coreutils-case-7380cf79-2e636af1/tempworkdir/src /home/ubuntu/spr-fast/tests/corebench/coreutils/coreutils-case-7380cf79-2e636af1/tempworkdir/tests /home/ubuntu/spr-fast/tests/corebench/coreutils/coreutils-case-7380cf79-2e636af1/tempworkdir 0  > __res
BasicTester, Testing instance id 170:
Running test command:
/home/ubuntu/spr-fast/tools/coreutils-test.py /home/ubuntu/spr-fast/tests/corebench/coreutils/coreutils-case-7380cf79-2e636af1/tempworkdir/src /home/ubuntu/spr-fast/tests/corebench/coreutils/coreutils-case-7380cf79-2e636af1/tempworkdir/tests /home/ubuntu/spr-fast/tests/corebench/coreutils/coreutils-case-7380cf79-2e636af1/tempworkdir 0  > __res
BasicTester, Testing instance id 171:
Running test command:
/home/ubuntu/spr-fast/tools/coreutils-test.py /home/ubuntu/spr-fast/tests/corebench/coreutils/coreutils-case-7380cf79-2e636af1/tempworkdir/src /home/ubuntu/spr-fast/tests/corebench/coreutils/coreutils-case-7380cf79-2e636af1/tempworkdir/tests /home/ubuntu/spr-fast/tests/corebench/coreutils/coreutils-case-7380cf79-2e636af1/tempworkdir 0  > __res
BasicTester, Testing instance id 172:
Running test command:
/home/ubuntu/spr-fast/tools/coreutils-test.py /home/ubuntu/spr-fast/tests/corebench/coreutils/coreutils-case-7380cf79-2e636af1/tempworkdir/src /home/ubuntu/spr-fast/tests/corebench/coreutils/coreutils-case-7380cf79-2e636af1/tempworkdir/tests /home/ubuntu/spr-fast/tests/corebench/coreutils/coreutils-case-7380cf79-2e636af1/tempworkdir 0  > __res
Counter: 214
Batcher Size:43
Preprocess the following candidate with BasicTester:
Priority 7465
At location src/cut.c:363
--Src File: src/cut.c
Fragment 0:
field_found = (in_digits);
while (1)
    {
        if (*fieldstr == '-') {
            in_digits = 0;
            if (dash_found)
                do {
                    error(0, 0, (gettext("invalid byte or field list")));
                    usage(1);
                } while (0);
            dash_found = 1;
            fieldstr++;
            initial = (lhs_specified ? value : 1);
            value = 0;
        } else if (*fieldstr == ',' || ((*__ctype_b_loc())[(int)((to_uchar(*fieldstr)))] & (unsigned short)_ISblank) || *fieldstr == '\x00') {
            in_digits = 0;
            if (dash_found) {
                dash_found = 0;
                if (!lhs_specified && !rhs_specified)
                    do {
                        error(0, 0, (gettext("invalid range with no endpoint: -")));
                        usage(1);
                    } while (0);
                if (!rhs_specified) {
                    eol_range_start = initial;
                    field_found = 1;
                } else {
                    if (value < initial)
                        do {
                            error(0, 0, (gettext("invalid decreasing range")));
                            usage(1);
                        } while (0);
                    if (eol_range_start != 0) {
                        if (initial < eol_range_start) {
                            if (eol_range_start <= value) {
                                eol_range_start = initial;
                            } else {
                                do {
                                    if (initial == 0 || value == 0)
                                        do {
                                            error(0, 0, (gettext("fields and positions are numbered from 1")));
                                            usage(1);
                                        } while (0);
                                    if (n_rp >= n_rp_allocated) {
                                        (rp) = x2nrealloc(rp, &n_rp_allocated, sizeof *(rp));
                                    }
                                    rp[n_rp].lo = (initial);
                                    rp[n_rp].hi = (value);
                                    ++n_rp;
                                } while (0);
                            }
                            field_found = 1;
                        }
                    } else {
                        do {
                            if (initial == 0 || value == 0)
                                do {
                                    error(0, 0, (gettext("fields and positions are numbered from 1")));
                                    usage(1);
                                } while (0);
                            if (n_rp >= n_rp_allocated) {
                                (rp) = x2nrealloc(rp, &n_rp_allocated, sizeof *(rp));
                            }
                            rp[n_rp].lo = (initial);
                            rp[n_rp].hi = (value);
                            ++n_rp;
                        } while (0);
                        field_found = 1;
                    }
                    value = 0;
                }
            } else {
                do {
                    if (value == 0 || value == 0)
                        do {
                            error(0, 0, (gettext("fields and positions are numbered from 1")));
                            usage(1);
                        } while (0);
                    if (n_rp >= n_rp_allocated) {
                        (rp) = x2nrealloc(rp, &n_rp_allocated, sizeof *(rp));
                    }
                    rp[n_rp].lo = (value);
                    rp[n_rp].hi = (value);
                    ++n_rp;
                } while (0);
                value = 0;
                field_found = 1;
            }
            if (*fieldstr == '\x00') {
                break;
            }
            fieldstr++;
            lhs_specified = 0;
            rhs_specified = 0;
        } else if (((unsigned int)(*fieldstr) - '0' <= 9)) {
            static const char *num_start;
            if (!in_digits || !num_start)
                num_start = fieldstr;
            in_digits = 1;
            if (dash_found)
                rhs_specified = 1;
            else
                lhs_specified = 1;
            if (!((void)(&(value) == (size_t *)((void *)0)) , (((size_t)-1 / 10 < (value) || (size_t)((value) * 10 + (*fieldstr - '0')) < (value)) ? 0 : (((value) = (value) * 10 + (*fieldstr - '0')) , 1)))) {
                size_t len = strspn(num_start, "0123456789");
                char *bad_num = xstrndup(num_start, len);
                if (operating_mode == byte_mode)
                    error(0, 0, gettext("byte offset %s is too large"), quote(bad_num));
                else
                    error(0, 0, gettext("field number %s is too large"), quote(bad_num));
                free(bad_num);
                exit(1);
            }
            fieldstr++;
        } else
            do {
                error(0, 0, (gettext("invalid byte or field list")));
                usage(1);
            } while (0);
    }


BasicTester, a patch instance with id 173:
Spawn 1 instances, now Total 214
Counter: 215
Batcher Size:44
Preprocess the following candidate with BasicTester:
Priority 7465
At location src/cut.c:363
--Src File: src/cut.c
Fragment 0:
eol_range_start = (n_rp_allocated);
while (1)
    {
        if (*fieldstr == '-') {
            in_digits = 0;
            if (dash_found)
                do {
                    error(0, 0, (gettext("invalid byte or field list")));
                    usage(1);
                } while (0);
            dash_found = 1;
            fieldstr++;
            initial = (lhs_specified ? value : 1);
            value = 0;
        } else if (*fieldstr == ',' || ((*__ctype_b_loc())[(int)((to_uchar(*fieldstr)))] & (unsigned short)_ISblank) || *fieldstr == '\x00') {
            in_digits = 0;
            if (dash_found) {
                dash_found = 0;
                if (!lhs_specified && !rhs_specified)
                    do {
                        error(0, 0, (gettext("invalid range with no endpoint: -")));
                        usage(1);
                    } while (0);
                if (!rhs_specified) {
                    eol_range_start = initial;
                    field_found = 1;
                } else {
                    if (value < initial)
                        do {
                            error(0, 0, (gettext("invalid decreasing range")));
                            usage(1);
                        } while (0);
                    if (eol_range_start != 0) {
                        if (initial < eol_range_start) {
                            if (eol_range_start <= value) {
                                eol_range_start = initial;
                            } else {
                                do {
                                    if (initial == 0 || value == 0)
                                        do {
                                            error(0, 0, (gettext("fields and positions are numbered from 1")));
                                            usage(1);
                                        } while (0);
                                    if (n_rp >= n_rp_allocated) {
                                        (rp) = x2nrealloc(rp, &n_rp_allocated, sizeof *(rp));
                                    }
                                    rp[n_rp].lo = (initial);
                                    rp[n_rp].hi = (value);
                                    ++n_rp;
                                } while (0);
                            }
                            field_found = 1;
                        }
                    } else {
                        do {
                            if (initial == 0 || value == 0)
                                do {
                                    error(0, 0, (gettext("fields and positions are numbered from 1")));
                                    usage(1);
                                } while (0);
                            if (n_rp >= n_rp_allocated) {
                                (rp) = x2nrealloc(rp, &n_rp_allocated, sizeof *(rp));
                            }
                            rp[n_rp].lo = (initial);
                            rp[n_rp].hi = (value);
                            ++n_rp;
                        } while (0);
                        field_found = 1;
                    }
                    value = 0;
                }
            } else {
                do {
                    if (value == 0 || value == 0)
                        do {
                            error(0, 0, (gettext("fields and positions are numbered from 1")));
                            usage(1);
                        } while (0);
                    if (n_rp >= n_rp_allocated) {
                        (rp) = x2nrealloc(rp, &n_rp_allocated, sizeof *(rp));
                    }
                    rp[n_rp].lo = (value);
                    rp[n_rp].hi = (value);
                    ++n_rp;
                } while (0);
                value = 0;
                field_found = 1;
            }
            if (*fieldstr == '\x00') {
                break;
            }
            fieldstr++;
            lhs_specified = 0;
            rhs_specified = 0;
        } else if (((unsigned int)(*fieldstr) - '0' <= 9)) {
            static const char *num_start;
            if (!in_digits || !num_start)
                num_start = fieldstr;
            in_digits = 1;
            if (dash_found)
                rhs_specified = 1;
            else
                lhs_specified = 1;
            if (!((void)(&(value) == (size_t *)((void *)0)) , (((size_t)-1 / 10 < (value) || (size_t)((value) * 10 + (*fieldstr - '0')) < (value)) ? 0 : (((value) = (value) * 10 + (*fieldstr - '0')) , 1)))) {
                size_t len = strspn(num_start, "0123456789");
                char *bad_num = xstrndup(num_start, len);
                if (operating_mode == byte_mode)
                    error(0, 0, gettext("byte offset %s is too large"), quote(bad_num));
                else
                    error(0, 0, gettext("field number %s is too large"), quote(bad_num));
                free(bad_num);
                exit(1);
            }
            fieldstr++;
        } else
            do {
                error(0, 0, (gettext("invalid byte or field list")));
                usage(1);
            } while (0);
    }


BasicTester, a patch instance with id 174:
Spawn 1 instances, now Total 215
Counter: 216
Batcher Size:45
Preprocess the following candidate with BasicTester:
Priority 7465
At location src/cut.c:363
--Src File: src/cut.c
Fragment 0:
error(0, (*__errno_location()), "%s", (fieldstr));
while (1)
    {
        if (*fieldstr == '-') {
            in_digits = 0;
            if (dash_found)
                do {
                    error(0, 0, (gettext("invalid byte or field list")));
                    usage(1);
                } while (0);
            dash_found = 1;
            fieldstr++;
            initial = (lhs_specified ? value : 1);
            value = 0;
        } else if (*fieldstr == ',' || ((*__ctype_b_loc())[(int)((to_uchar(*fieldstr)))] & (unsigned short)_ISblank) || *fieldstr == '\x00') {
            in_digits = 0;
            if (dash_found) {
                dash_found = 0;
                if (!lhs_specified && !rhs_specified)
                    do {
                        error(0, 0, (gettext("invalid range with no endpoint: -")));
                        usage(1);
                    } while (0);
                if (!rhs_specified) {
                    eol_range_start = initial;
                    field_found = 1;
                } else {
                    if (value < initial)
                        do {
                            error(0, 0, (gettext("invalid decreasing range")));
                            usage(1);
                        } while (0);
                    if (eol_range_start != 0) {
                        if (initial < eol_range_start) {
                            if (eol_range_start <= value) {
                                eol_range_start = initial;
                            } else {
                                do {
                                    if (initial == 0 || value == 0)
                                        do {
                                            error(0, 0, (gettext("fields and positions are numbered from 1")));
                                            usage(1);
                                        } while (0);
                                    if (n_rp >= n_rp_allocated) {
                                        (rp) = x2nrealloc(rp, &n_rp_allocated, sizeof *(rp));
                                    }
                                    rp[n_rp].lo = (initial);
                                    rp[n_rp].hi = (value);
                                    ++n_rp;
                                } while (0);
                            }
                            field_found = 1;
                        }
                    } else {
                        do {
                            if (initial == 0 || value == 0)
                                do {
                                    error(0, 0, (gettext("fields and positions are numbered from 1")));
                                    usage(1);
                                } while (0);
                            if (n_rp >= n_rp_allocated) {
                                (rp) = x2nrealloc(rp, &n_rp_allocated, sizeof *(rp));
                            }
                            rp[n_rp].lo = (initial);
                            rp[n_rp].hi = (value);
                            ++n_rp;
                        } while (0);
                        field_found = 1;
                    }
                    value = 0;
                }
            } else {
                do {
                    if (value == 0 || value == 0)
                        do {
                            error(0, 0, (gettext("fields and positions are numbered from 1")));
                            usage(1);
                        } while (0);
                    if (n_rp >= n_rp_allocated) {
                        (rp) = x2nrealloc(rp, &n_rp_allocated, sizeof *(rp));
                    }
                    rp[n_rp].lo = (value);
                    rp[n_rp].hi = (value);
                    ++n_rp;
                } while (0);
                value = 0;
                field_found = 1;
            }
            if (*fieldstr == '\x00') {
                break;
            }
            fieldstr++;
            lhs_specified = 0;
            rhs_specified = 0;
        } else if (((unsigned int)(*fieldstr) - '0' <= 9)) {
            static const char *num_start;
            if (!in_digits || !num_start)
                num_start = fieldstr;
            in_digits = 1;
            if (dash_found)
                rhs_specified = 1;
            else
                lhs_specified = 1;
            if (!((void)(&(value) == (size_t *)((void *)0)) , (((size_t)-1 / 10 < (value) || (size_t)((value) * 10 + (*fieldstr - '0')) < (value)) ? 0 : (((value) = (value) * 10 + (*fieldstr - '0')) , 1)))) {
                size_t len = strspn(num_start, "0123456789");
                char *bad_num = xstrndup(num_start, len);
                if (operating_mode == byte_mode)
                    error(0, 0, gettext("byte offset %s is too large"), quote(bad_num));
                else
                    error(0, 0, gettext("field number %s is too large"), quote(bad_num));
                free(bad_num);
                exit(1);
            }
            fieldstr++;
        } else
            do {
                error(0, 0, (gettext("invalid byte or field list")));
                usage(1);
            } while (0);
    }


BasicTester, a patch instance with id 175:
Spawn 1 instances, now Total 216
Counter: 217
Batcher Size:46
Preprocess the following candidate with BasicTester:
Priority 7465
At location src/cut.c:363
--Src File: src/cut.c
Fragment 0:
exit(0);
while (1)
    {
        if (*fieldstr == '-') {
            in_digits = 0;
            if (dash_found)
                do {
                    error(0, 0, (gettext("invalid byte or field list")));
                    usage(1);
                } while (0);
            dash_found = 1;
            fieldstr++;
            initial = (lhs_specified ? value : 1);
            value = 0;
        } else if (*fieldstr == ',' || ((*__ctype_b_loc())[(int)((to_uchar(*fieldstr)))] & (unsigned short)_ISblank) || *fieldstr == '\x00') {
            in_digits = 0;
            if (dash_found) {
                dash_found = 0;
                if (!lhs_specified && !rhs_specified)
                    do {
                        error(0, 0, (gettext("invalid range with no endpoint: -")));
                        usage(1);
                    } while (0);
                if (!rhs_specified) {
                    eol_range_start = initial;
                    field_found = 1;
                } else {
                    if (value < initial)
                        do {
                            error(0, 0, (gettext("invalid decreasing range")));
                            usage(1);
                        } while (0);
                    if (eol_range_start != 0) {
                        if (initial < eol_range_start) {
                            if (eol_range_start <= value) {
                                eol_range_start = initial;
                            } else {
                                do {
                                    if (initial == 0 || value == 0)
                                        do {
                                            error(0, 0, (gettext("fields and positions are numbered from 1")));
                                            usage(1);
                                        } while (0);
                                    if (n_rp >= n_rp_allocated) {
                                        (rp) = x2nrealloc(rp, &n_rp_allocated, sizeof *(rp));
                                    }
                                    rp[n_rp].lo = (initial);
                                    rp[n_rp].hi = (value);
                                    ++n_rp;
                                } while (0);
                            }
                            field_found = 1;
                        }
                    } else {
                        do {
                            if (initial == 0 || value == 0)
                                do {
                                    error(0, 0, (gettext("fields and positions are numbered from 1")));
                                    usage(1);
                                } while (0);
                            if (n_rp >= n_rp_allocated) {
                                (rp) = x2nrealloc(rp, &n_rp_allocated, sizeof *(rp));
                            }
                            rp[n_rp].lo = (initial);
                            rp[n_rp].hi = (value);
                            ++n_rp;
                        } while (0);
                        field_found = 1;
                    }
                    value = 0;
                }
            } else {
                do {
                    if (value == 0 || value == 0)
                        do {
                            error(0, 0, (gettext("fields and positions are numbered from 1")));
                            usage(1);
                        } while (0);
                    if (n_rp >= n_rp_allocated) {
                        (rp) = x2nrealloc(rp, &n_rp_allocated, sizeof *(rp));
                    }
                    rp[n_rp].lo = (value);
                    rp[n_rp].hi = (value);
                    ++n_rp;
                } while (0);
                value = 0;
                field_found = 1;
            }
            if (*fieldstr == '\x00') {
                break;
            }
            fieldstr++;
            lhs_specified = 0;
            rhs_specified = 0;
        } else if (((unsigned int)(*fieldstr) - '0' <= 9)) {
            static const char *num_start;
            if (!in_digits || !num_start)
                num_start = fieldstr;
            in_digits = 1;
            if (dash_found)
                rhs_specified = 1;
            else
                lhs_specified = 1;
            if (!((void)(&(value) == (size_t *)((void *)0)) , (((size_t)-1 / 10 < (value) || (size_t)((value) * 10 + (*fieldstr - '0')) < (value)) ? 0 : (((value) = (value) * 10 + (*fieldstr - '0')) , 1)))) {
                size_t len = strspn(num_start, "0123456789");
                char *bad_num = xstrndup(num_start, len);
                if (operating_mode == byte_mode)
                    error(0, 0, gettext("byte offset %s is too large"), quote(bad_num));
                else
                    error(0, 0, gettext("field number %s is too large"), quote(bad_num));
                free(bad_num);
                exit(1);
            }
            fieldstr++;
        } else
            do {
                error(0, 0, (gettext("invalid byte or field list")));
                usage(1);
            } while (0);
    }


BasicTester, a patch instance with id 176:
Spawn 1 instances, now Total 217
Counter: 218
Batcher Size:47
Preprocess the following candidate with BasicTester:
Priority 7465
At location src/cut.c:363
--Src File: src/cut.c
Fragment 0:
exit(1);
while (1)
    {
        if (*fieldstr == '-') {
            in_digits = 0;
            if (dash_found)
                do {
                    error(0, 0, (gettext("invalid byte or field list")));
                    usage(1);
                } while (0);
            dash_found = 1;
            fieldstr++;
            initial = (lhs_specified ? value : 1);
            value = 0;
        } else if (*fieldstr == ',' || ((*__ctype_b_loc())[(int)((to_uchar(*fieldstr)))] & (unsigned short)_ISblank) || *fieldstr == '\x00') {
            in_digits = 0;
            if (dash_found) {
                dash_found = 0;
                if (!lhs_specified && !rhs_specified)
                    do {
                        error(0, 0, (gettext("invalid range with no endpoint: -")));
                        usage(1);
                    } while (0);
                if (!rhs_specified) {
                    eol_range_start = initial;
                    field_found = 1;
                } else {
                    if (value < initial)
                        do {
                            error(0, 0, (gettext("invalid decreasing range")));
                            usage(1);
                        } while (0);
                    if (eol_range_start != 0) {
                        if (initial < eol_range_start) {
                            if (eol_range_start <= value) {
                                eol_range_start = initial;
                            } else {
                                do {
                                    if (initial == 0 || value == 0)
                                        do {
                                            error(0, 0, (gettext("fields and positions are numbered from 1")));
                                            usage(1);
                                        } while (0);
                                    if (n_rp >= n_rp_allocated) {
                                        (rp) = x2nrealloc(rp, &n_rp_allocated, sizeof *(rp));
                                    }
                                    rp[n_rp].lo = (initial);
                                    rp[n_rp].hi = (value);
                                    ++n_rp;
                                } while (0);
                            }
                            field_found = 1;
                        }
                    } else {
                        do {
                            if (initial == 0 || value == 0)
                                do {
                                    error(0, 0, (gettext("fields and positions are numbered from 1")));
                                    usage(1);
                                } while (0);
                            if (n_rp >= n_rp_allocated) {
                                (rp) = x2nrealloc(rp, &n_rp_allocated, sizeof *(rp));
                            }
                            rp[n_rp].lo = (initial);
                            rp[n_rp].hi = (value);
                            ++n_rp;
                        } while (0);
                        field_found = 1;
                    }
                    value = 0;
                }
            } else {
                do {
                    if (value == 0 || value == 0)
                        do {
                            error(0, 0, (gettext("fields and positions are numbered from 1")));
                            usage(1);
                        } while (0);
                    if (n_rp >= n_rp_allocated) {
                        (rp) = x2nrealloc(rp, &n_rp_allocated, sizeof *(rp));
                    }
                    rp[n_rp].lo = (value);
                    rp[n_rp].hi = (value);
                    ++n_rp;
                } while (0);
                value = 0;
                field_found = 1;
            }
            if (*fieldstr == '\x00') {
                break;
            }
            fieldstr++;
            lhs_specified = 0;
            rhs_specified = 0;
        } else if (((unsigned int)(*fieldstr) - '0' <= 9)) {
            static const char *num_start;
            if (!in_digits || !num_start)
                num_start = fieldstr;
            in_digits = 1;
            if (dash_found)
                rhs_specified = 1;
            else
                lhs_specified = 1;
            if (!((void)(&(value) == (size_t *)((void *)0)) , (((size_t)-1 / 10 < (value) || (size_t)((value) * 10 + (*fieldstr - '0')) < (value)) ? 0 : (((value) = (value) * 10 + (*fieldstr - '0')) , 1)))) {
                size_t len = strspn(num_start, "0123456789");
                char *bad_num = xstrndup(num_start, len);
                if (operating_mode == byte_mode)
                    error(0, 0, gettext("byte offset %s is too large"), quote(bad_num));
                else
                    error(0, 0, gettext("field number %s is too large"), quote(bad_num));
                free(bad_num);
                exit(1);
            }
            fieldstr++;
        } else
            do {
                error(0, 0, (gettext("invalid byte or field list")));
                usage(1);
            } while (0);
    }


BasicTester, a patch instance with id 177:
Spawn 1 instances, now Total 218
Counter: 219
Batcher Size:48
Preprocess the following candidate with BasicTester:
Priority 7465
At location src/cut.c:363
--Src File: src/cut.c
Fragment 0:
error(0, (*__errno_location()), "-");
while (1)
    {
        if (*fieldstr == '-') {
            in_digits = 0;
            if (dash_found)
                do {
                    error(0, 0, (gettext("invalid byte or field list")));
                    usage(1);
                } while (0);
            dash_found = 1;
            fieldstr++;
            initial = (lhs_specified ? value : 1);
            value = 0;
        } else if (*fieldstr == ',' || ((*__ctype_b_loc())[(int)((to_uchar(*fieldstr)))] & (unsigned short)_ISblank) || *fieldstr == '\x00') {
            in_digits = 0;
            if (dash_found) {
                dash_found = 0;
                if (!lhs_specified && !rhs_specified)
                    do {
                        error(0, 0, (gettext("invalid range with no endpoint: -")));
                        usage(1);
                    } while (0);
                if (!rhs_specified) {
                    eol_range_start = initial;
                    field_found = 1;
                } else {
                    if (value < initial)
                        do {
                            error(0, 0, (gettext("invalid decreasing range")));
                            usage(1);
                        } while (0);
                    if (eol_range_start != 0) {
                        if (initial < eol_range_start) {
                            if (eol_range_start <= value) {
                                eol_range_start = initial;
                            } else {
                                do {
                                    if (initial == 0 || value == 0)
                                        do {
                                            error(0, 0, (gettext("fields and positions are numbered from 1")));
                                            usage(1);
                                        } while (0);
                                    if (n_rp >= n_rp_allocated) {
                                        (rp) = x2nrealloc(rp, &n_rp_allocated, sizeof *(rp));
                                    }
                                    rp[n_rp].lo = (initial);
                                    rp[n_rp].hi = (value);
                                    ++n_rp;
                                } while (0);
                            }
                            field_found = 1;
                        }
                    } else {
                        do {
                            if (initial == 0 || value == 0)
                                do {
                                    error(0, 0, (gettext("fields and positions are numbered from 1")));
                                    usage(1);
                                } while (0);
                            if (n_rp >= n_rp_allocated) {
                                (rp) = x2nrealloc(rp, &n_rp_allocated, sizeof *(rp));
                            }
                            rp[n_rp].lo = (initial);
                            rp[n_rp].hi = (value);
                            ++n_rp;
                        } while (0);
                        field_found = 1;
                    }
                    value = 0;
                }
            } else {
                do {
                    if (value == 0 || value == 0)
                        do {
                            error(0, 0, (gettext("fields and positions are numbered from 1")));
                            usage(1);
                        } while (0);
                    if (n_rp >= n_rp_allocated) {
                        (rp) = x2nrealloc(rp, &n_rp_allocated, sizeof *(rp));
                    }
                    rp[n_rp].lo = (value);
                    rp[n_rp].hi = (value);
                    ++n_rp;
                } while (0);
                value = 0;
                field_found = 1;
            }
            if (*fieldstr == '\x00') {
                break;
            }
            fieldstr++;
            lhs_specified = 0;
            rhs_specified = 0;
        } else if (((unsigned int)(*fieldstr) - '0' <= 9)) {
            static const char *num_start;
            if (!in_digits || !num_start)
                num_start = fieldstr;
            in_digits = 1;
            if (dash_found)
                rhs_specified = 1;
            else
                lhs_specified = 1;
            if (!((void)(&(value) == (size_t *)((void *)0)) , (((size_t)-1 / 10 < (value) || (size_t)((value) * 10 + (*fieldstr - '0')) < (value)) ? 0 : (((value) = (value) * 10 + (*fieldstr - '0')) , 1)))) {
                size_t len = strspn(num_start, "0123456789");
                char *bad_num = xstrndup(num_start, len);
                if (operating_mode == byte_mode)
                    error(0, 0, gettext("byte offset %s is too large"), quote(bad_num));
                else
                    error(0, 0, gettext("field number %s is too large"), quote(bad_num));
                free(bad_num);
                exit(1);
            }
            fieldstr++;
        } else
            do {
                error(0, 0, (gettext("invalid byte or field list")));
                usage(1);
            } while (0);
    }


BasicTester, a patch instance with id 178:
Spawn 1 instances, now Total 219
Counter: 220
Batcher Size:49
Preprocess the following candidate with BasicTester:
Priority 7465
At location src/cut.c:363
--Src File: src/cut.c
Fragment 0:
eol_range_start = (value);
while (1)
    {
        if (*fieldstr == '-') {
            in_digits = 0;
            if (dash_found)
                do {
                    error(0, 0, (gettext("invalid byte or field list")));
                    usage(1);
                } while (0);
            dash_found = 1;
            fieldstr++;
            initial = (lhs_specified ? value : 1);
            value = 0;
        } else if (*fieldstr == ',' || ((*__ctype_b_loc())[(int)((to_uchar(*fieldstr)))] & (unsigned short)_ISblank) || *fieldstr == '\x00') {
            in_digits = 0;
            if (dash_found) {
                dash_found = 0;
                if (!lhs_specified && !rhs_specified)
                    do {
                        error(0, 0, (gettext("invalid range with no endpoint: -")));
                        usage(1);
                    } while (0);
                if (!rhs_specified) {
                    eol_range_start = initial;
                    field_found = 1;
                } else {
                    if (value < initial)
                        do {
                            error(0, 0, (gettext("invalid decreasing range")));
                            usage(1);
                        } while (0);
                    if (eol_range_start != 0) {
                        if (initial < eol_range_start) {
                            if (eol_range_start <= value) {
                                eol_range_start = initial;
                            } else {
                                do {
                                    if (initial == 0 || value == 0)
                                        do {
                                            error(0, 0, (gettext("fields and positions are numbered from 1")));
                                            usage(1);
                                        } while (0);
                                    if (n_rp >= n_rp_allocated) {
                                        (rp) = x2nrealloc(rp, &n_rp_allocated, sizeof *(rp));
                                    }
                                    rp[n_rp].lo = (initial);
                                    rp[n_rp].hi = (value);
                                    ++n_rp;
                                } while (0);
                            }
                            field_found = 1;
                        }
                    } else {
                        do {
                            if (initial == 0 || value == 0)
                                do {
                                    error(0, 0, (gettext("fields and positions are numbered from 1")));
                                    usage(1);
                                } while (0);
                            if (n_rp >= n_rp_allocated) {
                                (rp) = x2nrealloc(rp, &n_rp_allocated, sizeof *(rp));
                            }
                            rp[n_rp].lo = (initial);
                            rp[n_rp].hi = (value);
                            ++n_rp;
                        } while (0);
                        field_found = 1;
                    }
                    value = 0;
                }
            } else {
                do {
                    if (value == 0 || value == 0)
                        do {
                            error(0, 0, (gettext("fields and positions are numbered from 1")));
                            usage(1);
                        } while (0);
                    if (n_rp >= n_rp_allocated) {
                        (rp) = x2nrealloc(rp, &n_rp_allocated, sizeof *(rp));
                    }
                    rp[n_rp].lo = (value);
                    rp[n_rp].hi = (value);
                    ++n_rp;
                } while (0);
                value = 0;
                field_found = 1;
            }
            if (*fieldstr == '\x00') {
                break;
            }
            fieldstr++;
            lhs_specified = 0;
            rhs_specified = 0;
        } else if (((unsigned int)(*fieldstr) - '0' <= 9)) {
            static const char *num_start;
            if (!in_digits || !num_start)
                num_start = fieldstr;
            in_digits = 1;
            if (dash_found)
                rhs_specified = 1;
            else
                lhs_specified = 1;
            if (!((void)(&(value) == (size_t *)((void *)0)) , (((size_t)-1 / 10 < (value) || (size_t)((value) * 10 + (*fieldstr - '0')) < (value)) ? 0 : (((value) = (value) * 10 + (*fieldstr - '0')) , 1)))) {
                size_t len = strspn(num_start, "0123456789");
                char *bad_num = xstrndup(num_start, len);
                if (operating_mode == byte_mode)
                    error(0, 0, gettext("byte offset %s is too large"), quote(bad_num));
                else
                    error(0, 0, gettext("field number %s is too large"), quote(bad_num));
                free(bad_num);
                exit(1);
            }
            fieldstr++;
        } else
            do {
                error(0, 0, (gettext("invalid byte or field list")));
                usage(1);
            } while (0);
    }


BasicTester, a patch instance with id 179:
Spawn 1 instances, now Total 220
Counter: 221
Batcher Size:50
Preprocess the following candidate with BasicTester:
Priority 7465
At location src/cut.c:363
--Src File: src/cut.c
Fragment 0:
eol_range_start = initial;
while (1)
    {
        if (*fieldstr == '-') {
            in_digits = 0;
            if (dash_found)
                do {
                    error(0, 0, (gettext("invalid byte or field list")));
                    usage(1);
                } while (0);
            dash_found = 1;
            fieldstr++;
            initial = (lhs_specified ? value : 1);
            value = 0;
        } else if (*fieldstr == ',' || ((*__ctype_b_loc())[(int)((to_uchar(*fieldstr)))] & (unsigned short)_ISblank) || *fieldstr == '\x00') {
            in_digits = 0;
            if (dash_found) {
                dash_found = 0;
                if (!lhs_specified && !rhs_specified)
                    do {
                        error(0, 0, (gettext("invalid range with no endpoint: -")));
                        usage(1);
                    } while (0);
                if (!rhs_specified) {
                    eol_range_start = initial;
                    field_found = 1;
                } else {
                    if (value < initial)
                        do {
                            error(0, 0, (gettext("invalid decreasing range")));
                            usage(1);
                        } while (0);
                    if (eol_range_start != 0) {
                        if (initial < eol_range_start) {
                            if (eol_range_start <= value) {
                                eol_range_start = initial;
                            } else {
                                do {
                                    if (initial == 0 || value == 0)
                                        do {
                                            error(0, 0, (gettext("fields and positions are numbered from 1")));
                                            usage(1);
                                        } while (0);
                                    if (n_rp >= n_rp_allocated) {
                                        (rp) = x2nrealloc(rp, &n_rp_allocated, sizeof *(rp));
                                    }
                                    rp[n_rp].lo = (initial);
                                    rp[n_rp].hi = (value);
                                    ++n_rp;
                                } while (0);
                            }
                            field_found = 1;
                        }
                    } else {
                        do {
                            if (initial == 0 || value == 0)
                                do {
                                    error(0, 0, (gettext("fields and positions are numbered from 1")));
                                    usage(1);
                                } while (0);
                            if (n_rp >= n_rp_allocated) {
                                (rp) = x2nrealloc(rp, &n_rp_allocated, sizeof *(rp));
                            }
                            rp[n_rp].lo = (initial);
                            rp[n_rp].hi = (value);
                            ++n_rp;
                        } while (0);
                        field_found = 1;
                    }
                    value = 0;
                }
            } else {
                do {
                    if (value == 0 || value == 0)
                        do {
                            error(0, 0, (gettext("fields and positions are numbered from 1")));
                            usage(1);
                        } while (0);
                    if (n_rp >= n_rp_allocated) {
                        (rp) = x2nrealloc(rp, &n_rp_allocated, sizeof *(rp));
                    }
                    rp[n_rp].lo = (value);
                    rp[n_rp].hi = (value);
                    ++n_rp;
                } while (0);
                value = 0;
                field_found = 1;
            }
            if (*fieldstr == '\x00') {
                break;
            }
            fieldstr++;
            lhs_specified = 0;
            rhs_specified = 0;
        } else if (((unsigned int)(*fieldstr) - '0' <= 9)) {
            static const char *num_start;
            if (!in_digits || !num_start)
                num_start = fieldstr;
            in_digits = 1;
            if (dash_found)
                rhs_specified = 1;
            else
                lhs_specified = 1;
            if (!((void)(&(value) == (size_t *)((void *)0)) , (((size_t)-1 / 10 < (value) || (size_t)((value) * 10 + (*fieldstr - '0')) < (value)) ? 0 : (((value) = (value) * 10 + (*fieldstr - '0')) , 1)))) {
                size_t len = strspn(num_start, "0123456789");
                char *bad_num = xstrndup(num_start, len);
                if (operating_mode == byte_mode)
                    error(0, 0, gettext("byte offset %s is too large"), quote(bad_num));
                else
                    error(0, 0, gettext("field number %s is too large"), quote(bad_num));
                free(bad_num);
                exit(1);
            }
            fieldstr++;
        } else
            do {
                error(0, 0, (gettext("invalid byte or field list")));
                usage(1);
            } while (0);
    }


BasicTester, a patch instance with id 180:
Spawn 1 instances, now Total 221
Counter: 222
Batcher Size:51
Preprocess the following candidate with BasicTester:
Priority 7465
At location src/cut.c:363
--Src File: src/cut.c
Fragment 0:
delim = '\x00';
while (1)
    {
        if (*fieldstr == '-') {
            in_digits = 0;
            if (dash_found)
                do {
                    error(0, 0, (gettext("invalid byte or field list")));
                    usage(1);
                } while (0);
            dash_found = 1;
            fieldstr++;
            initial = (lhs_specified ? value : 1);
            value = 0;
        } else if (*fieldstr == ',' || ((*__ctype_b_loc())[(int)((to_uchar(*fieldstr)))] & (unsigned short)_ISblank) || *fieldstr == '\x00') {
            in_digits = 0;
            if (dash_found) {
                dash_found = 0;
                if (!lhs_specified && !rhs_specified)
                    do {
                        error(0, 0, (gettext("invalid range with no endpoint: -")));
                        usage(1);
                    } while (0);
                if (!rhs_specified) {
                    eol_range_start = initial;
                    field_found = 1;
                } else {
                    if (value < initial)
                        do {
                            error(0, 0, (gettext("invalid decreasing range")));
                            usage(1);
                        } while (0);
                    if (eol_range_start != 0) {
                        if (initial < eol_range_start) {
                            if (eol_range_start <= value) {
                                eol_range_start = initial;
                            } else {
                                do {
                                    if (initial == 0 || value == 0)
                                        do {
                                            error(0, 0, (gettext("fields and positions are numbered from 1")));
                                            usage(1);
                                        } while (0);
                                    if (n_rp >= n_rp_allocated) {
                                        (rp) = x2nrealloc(rp, &n_rp_allocated, sizeof *(rp));
                                    }
                                    rp[n_rp].lo = (initial);
                                    rp[n_rp].hi = (value);
                                    ++n_rp;
                                } while (0);
                            }
                            field_found = 1;
                        }
                    } else {
                        do {
                            if (initial == 0 || value == 0)
                                do {
                                    error(0, 0, (gettext("fields and positions are numbered from 1")));
                                    usage(1);
                                } while (0);
                            if (n_rp >= n_rp_allocated) {
                                (rp) = x2nrealloc(rp, &n_rp_allocated, sizeof *(rp));
                            }
                            rp[n_rp].lo = (initial);
                            rp[n_rp].hi = (value);
                            ++n_rp;
                        } while (0);
                        field_found = 1;
                    }
                    value = 0;
                }
            } else {
                do {
                    if (value == 0 || value == 0)
                        do {
                            error(0, 0, (gettext("fields and positions are numbered from 1")));
                            usage(1);
                        } while (0);
                    if (n_rp >= n_rp_allocated) {
                        (rp) = x2nrealloc(rp, &n_rp_allocated, sizeof *(rp));
                    }
                    rp[n_rp].lo = (value);
                    rp[n_rp].hi = (value);
                    ++n_rp;
                } while (0);
                value = 0;
                field_found = 1;
            }
            if (*fieldstr == '\x00') {
                break;
            }
            fieldstr++;
            lhs_specified = 0;
            rhs_specified = 0;
        } else if (((unsigned int)(*fieldstr) - '0' <= 9)) {
            static const char *num_start;
            if (!in_digits || !num_start)
                num_start = fieldstr;
            in_digits = 1;
            if (dash_found)
                rhs_specified = 1;
            else
                lhs_specified = 1;
            if (!((void)(&(value) == (size_t *)((void *)0)) , (((size_t)-1 / 10 < (value) || (size_t)((value) * 10 + (*fieldstr - '0')) < (value)) ? 0 : (((value) = (value) * 10 + (*fieldstr - '0')) , 1)))) {
                size_t len = strspn(num_start, "0123456789");
                char *bad_num = xstrndup(num_start, len);
                if (operating_mode == byte_mode)
                    error(0, 0, gettext("byte offset %s is too large"), quote(bad_num));
                else
                    error(0, 0, gettext("field number %s is too large"), quote(bad_num));
                free(bad_num);
                exit(1);
            }
            fieldstr++;
        } else
            do {
                error(0, 0, (gettext("invalid byte or field list")));
                usage(1);
            } while (0);
    }


BasicTester, a patch instance with id 181:
Spawn 1 instances, now Total 222
Counter: 223
Batcher Size:52
Preprocess the following candidate with BasicTester:
Priority 7465
At location src/cut.c:363
--Src File: src/cut.c
Fragment 0:
eol_range_start = (-1);
while (1)
    {
        if (*fieldstr == '-') {
            in_digits = 0;
            if (dash_found)
                do {
                    error(0, 0, (gettext("invalid byte or field list")));
                    usage(1);
                } while (0);
            dash_found = 1;
            fieldstr++;
            initial = (lhs_specified ? value : 1);
            value = 0;
        } else if (*fieldstr == ',' || ((*__ctype_b_loc())[(int)((to_uchar(*fieldstr)))] & (unsigned short)_ISblank) || *fieldstr == '\x00') {
            in_digits = 0;
            if (dash_found) {
                dash_found = 0;
                if (!lhs_specified && !rhs_specified)
                    do {
                        error(0, 0, (gettext("invalid range with no endpoint: -")));
                        usage(1);
                    } while (0);
                if (!rhs_specified) {
                    eol_range_start = initial;
                    field_found = 1;
                } else {
                    if (value < initial)
                        do {
                            error(0, 0, (gettext("invalid decreasing range")));
                            usage(1);
                        } while (0);
                    if (eol_range_start != 0) {
                        if (initial < eol_range_start) {
                            if (eol_range_start <= value) {
                                eol_range_start = initial;
                            } else {
                                do {
                                    if (initial == 0 || value == 0)
                                        do {
                                            error(0, 0, (gettext("fields and positions are numbered from 1")));
                                            usage(1);
                                        } while (0);
                                    if (n_rp >= n_rp_allocated) {
                                        (rp) = x2nrealloc(rp, &n_rp_allocated, sizeof *(rp));
                                    }
                                    rp[n_rp].lo = (initial);
                                    rp[n_rp].hi = (value);
                                    ++n_rp;
                                } while (0);
                            }
                            field_found = 1;
                        }
                    } else {
                        do {
                            if (initial == 0 || value == 0)
                                do {
                                    error(0, 0, (gettext("fields and positions are numbered from 1")));
                                    usage(1);
                                } while (0);
                            if (n_rp >= n_rp_allocated) {
                                (rp) = x2nrealloc(rp, &n_rp_allocated, sizeof *(rp));
                            }
                            rp[n_rp].lo = (initial);
                            rp[n_rp].hi = (value);
                            ++n_rp;
                        } while (0);
                        field_found = 1;
                    }
                    value = 0;
                }
            } else {
                do {
                    if (value == 0 || value == 0)
                        do {
                            error(0, 0, (gettext("fields and positions are numbered from 1")));
                            usage(1);
                        } while (0);
                    if (n_rp >= n_rp_allocated) {
                        (rp) = x2nrealloc(rp, &n_rp_allocated, sizeof *(rp));
                    }
                    rp[n_rp].lo = (value);
                    rp[n_rp].hi = (value);
                    ++n_rp;
                } while (0);
                value = 0;
                field_found = 1;
            }
            if (*fieldstr == '\x00') {
                break;
            }
            fieldstr++;
            lhs_specified = 0;
            rhs_specified = 0;
        } else if (((unsigned int)(*fieldstr) - '0' <= 9)) {
            static const char *num_start;
            if (!in_digits || !num_start)
                num_start = fieldstr;
            in_digits = 1;
            if (dash_found)
                rhs_specified = 1;
            else
                lhs_specified = 1;
            if (!((void)(&(value) == (size_t *)((void *)0)) , (((size_t)-1 / 10 < (value) || (size_t)((value) * 10 + (*fieldstr - '0')) < (value)) ? 0 : (((value) = (value) * 10 + (*fieldstr - '0')) , 1)))) {
                size_t len = strspn(num_start, "0123456789");
                char *bad_num = xstrndup(num_start, len);
                if (operating_mode == byte_mode)
                    error(0, 0, gettext("byte offset %s is too large"), quote(bad_num));
                else
                    error(0, 0, gettext("field number %s is too large"), quote(bad_num));
                free(bad_num);
                exit(1);
            }
            fieldstr++;
        } else
            do {
                error(0, 0, (gettext("invalid byte or field list")));
                usage(1);
            } while (0);
    }


BasicTester, a patch instance with id 182:
Spawn 1 instances, now Total 223
a batched test job starts!
Building:src at:
/home/ubuntu/spr-fast/tests/corebench/coreutils/coreutils-case-7380cf79-2e636af1/tempworkdir/srcMerged code building succ, going to invoke tester!
BasicTester, Testing instance id 173:
Running test command:
/home/ubuntu/spr-fast/tools/coreutils-test.py /home/ubuntu/spr-fast/tests/corebench/coreutils/coreutils-case-7380cf79-2e636af1/tempworkdir/src /home/ubuntu/spr-fast/tests/corebench/coreutils/coreutils-case-7380cf79-2e636af1/tempworkdir/tests /home/ubuntu/spr-fast/tests/corebench/coreutils/coreutils-case-7380cf79-2e636af1/tempworkdir 0  > __res
BasicTester, Testing instance id 174:
Running test command:
/home/ubuntu/spr-fast/tools/coreutils-test.py /home/ubuntu/spr-fast/tests/corebench/coreutils/coreutils-case-7380cf79-2e636af1/tempworkdir/src /home/ubuntu/spr-fast/tests/corebench/coreutils/coreutils-case-7380cf79-2e636af1/tempworkdir/tests /home/ubuntu/spr-fast/tests/corebench/coreutils/coreutils-case-7380cf79-2e636af1/tempworkdir 0  > __res
BasicTester, Testing instance id 175:
Running test command:
/home/ubuntu/spr-fast/tools/coreutils-test.py /home/ubuntu/spr-fast/tests/corebench/coreutils/coreutils-case-7380cf79-2e636af1/tempworkdir/src /home/ubuntu/spr-fast/tests/corebench/coreutils/coreutils-case-7380cf79-2e636af1/tempworkdir/tests /home/ubuntu/spr-fast/tests/corebench/coreutils/coreutils-case-7380cf79-2e636af1/tempworkdir 0  > __res
BasicTester, Testing instance id 176:
Running test command:
/home/ubuntu/spr-fast/tools/coreutils-test.py /home/ubuntu/spr-fast/tests/corebench/coreutils/coreutils-case-7380cf79-2e636af1/tempworkdir/src /home/ubuntu/spr-fast/tests/corebench/coreutils/coreutils-case-7380cf79-2e636af1/tempworkdir/tests /home/ubuntu/spr-fast/tests/corebench/coreutils/coreutils-case-7380cf79-2e636af1/tempworkdir 0  > __res
Passed Negative Cases with BasicTester
Running test command:
/home/ubuntu/spr-fast/tools/coreutils-test.py /home/ubuntu/spr-fast/tests/corebench/coreutils/coreutils-case-7380cf79-2e636af1/tempworkdir/src /home/ubuntu/spr-fast/tests/corebench/coreutils/coreutils-case-7380cf79-2e636af1/tempworkdir/tests /home/ubuntu/spr-fast/tests/corebench/coreutils/coreutils-case-7380cf79-2e636af1/tempworkdir 19  > __res
Failed positive case 19
BasicTester, Testing instance id 177:
Running test command:
/home/ubuntu/spr-fast/tools/coreutils-test.py /home/ubuntu/spr-fast/tests/corebench/coreutils/coreutils-case-7380cf79-2e636af1/tempworkdir/src /home/ubuntu/spr-fast/tests/corebench/coreutils/coreutils-case-7380cf79-2e636af1/tempworkdir/tests /home/ubuntu/spr-fast/tests/corebench/coreutils/coreutils-case-7380cf79-2e636af1/tempworkdir 0  > __res
BasicTester, Testing instance id 178:
Running test command:
/home/ubuntu/spr-fast/tools/coreutils-test.py /home/ubuntu/spr-fast/tests/corebench/coreutils/coreutils-case-7380cf79-2e636af1/tempworkdir/src /home/ubuntu/spr-fast/tests/corebench/coreutils/coreutils-case-7380cf79-2e636af1/tempworkdir/tests /home/ubuntu/spr-fast/tests/corebench/coreutils/coreutils-case-7380cf79-2e636af1/tempworkdir 0  > __res
BasicTester, Testing instance id 179:
Running test command:
/home/ubuntu/spr-fast/tools/coreutils-test.py /home/ubuntu/spr-fast/tests/corebench/coreutils/coreutils-case-7380cf79-2e636af1/tempworkdir/src /home/ubuntu/spr-fast/tests/corebench/coreutils/coreutils-case-7380cf79-2e636af1/tempworkdir/tests /home/ubuntu/spr-fast/tests/corebench/coreutils/coreutils-case-7380cf79-2e636af1/tempworkdir 0  > __res
BasicTester, Testing instance id 180:
Running test command:
/home/ubuntu/spr-fast/tools/coreutils-test.py /home/ubuntu/spr-fast/tests/corebench/coreutils/coreutils-case-7380cf79-2e636af1/tempworkdir/src /home/ubuntu/spr-fast/tests/corebench/coreutils/coreutils-case-7380cf79-2e636af1/tempworkdir/tests /home/ubuntu/spr-fast/tests/corebench/coreutils/coreutils-case-7380cf79-2e636af1/tempworkdir 0  > __res
BasicTester, Testing instance id 181:
Running test command:
/home/ubuntu/spr-fast/tools/coreutils-test.py /home/ubuntu/spr-fast/tests/corebench/coreutils/coreutils-case-7380cf79-2e636af1/tempworkdir/src /home/ubuntu/spr-fast/tests/corebench/coreutils/coreutils-case-7380cf79-2e636af1/tempworkdir/tests /home/ubuntu/spr-fast/tests/corebench/coreutils/coreutils-case-7380cf79-2e636af1/tempworkdir 0  > __res
BasicTester, Testing instance id 182:
Running test command:
/home/ubuntu/spr-fast/tools/coreutils-test.py /home/ubuntu/spr-fast/tests/corebench/coreutils/coreutils-case-7380cf79-2e636af1/tempworkdir/src /home/ubuntu/spr-fast/tests/corebench/coreutils/coreutils-case-7380cf79-2e636af1/tempworkdir/tests /home/ubuntu/spr-fast/tests/corebench/coreutils/coreutils-case-7380cf79-2e636af1/tempworkdir 0  > __res
Counter: 224
Batcher Size:43
Preprocess the following candidate with BasicTester:
Priority 7465
At location src/cut.c:363
--Src File: src/cut.c
Fragment 0:
eol_range_start = (initial);
while (1)
    {
        if (*fieldstr == '-') {
            in_digits = 0;
            if (dash_found)
                do {
                    error(0, 0, (gettext("invalid byte or field list")));
                    usage(1);
                } while (0);
            dash_found = 1;
            fieldstr++;
            initial = (lhs_specified ? value : 1);
            value = 0;
        } else if (*fieldstr == ',' || ((*__ctype_b_loc())[(int)((to_uchar(*fieldstr)))] & (unsigned short)_ISblank) || *fieldstr == '\x00') {
            in_digits = 0;
            if (dash_found) {
                dash_found = 0;
                if (!lhs_specified && !rhs_specified)
                    do {
                        error(0, 0, (gettext("invalid range with no endpoint: -")));
                        usage(1);
                    } while (0);
                if (!rhs_specified) {
                    eol_range_start = initial;
                    field_found = 1;
                } else {
                    if (value < initial)
                        do {
                            error(0, 0, (gettext("invalid decreasing range")));
                            usage(1);
                        } while (0);
                    if (eol_range_start != 0) {
                        if (initial < eol_range_start) {
                            if (eol_range_start <= value) {
                                eol_range_start = initial;
                            } else {
                                do {
                                    if (initial == 0 || value == 0)
                                        do {
                                            error(0, 0, (gettext("fields and positions are numbered from 1")));
                                            usage(1);
                                        } while (0);
                                    if (n_rp >= n_rp_allocated) {
                                        (rp) = x2nrealloc(rp, &n_rp_allocated, sizeof *(rp));
                                    }
                                    rp[n_rp].lo = (initial);
                                    rp[n_rp].hi = (value);
                                    ++n_rp;
                                } while (0);
                            }
                            field_found = 1;
                        }
                    } else {
                        do {
                            if (initial == 0 || value == 0)
                                do {
                                    error(0, 0, (gettext("fields and positions are numbered from 1")));
                                    usage(1);
                                } while (0);
                            if (n_rp >= n_rp_allocated) {
                                (rp) = x2nrealloc(rp, &n_rp_allocated, sizeof *(rp));
                            }
                            rp[n_rp].lo = (initial);
                            rp[n_rp].hi = (value);
                            ++n_rp;
                        } while (0);
                        field_found = 1;
                    }
                    value = 0;
                }
            } else {
                do {
                    if (value == 0 || value == 0)
                        do {
                            error(0, 0, (gettext("fields and positions are numbered from 1")));
                            usage(1);
                        } while (0);
                    if (n_rp >= n_rp_allocated) {
                        (rp) = x2nrealloc(rp, &n_rp_allocated, sizeof *(rp));
                    }
                    rp[n_rp].lo = (value);
                    rp[n_rp].hi = (value);
                    ++n_rp;
                } while (0);
                value = 0;
                field_found = 1;
            }
            if (*fieldstr == '\x00') {
                break;
            }
            fieldstr++;
            lhs_specified = 0;
            rhs_specified = 0;
        } else if (((unsigned int)(*fieldstr) - '0' <= 9)) {
            static const char *num_start;
            if (!in_digits || !num_start)
                num_start = fieldstr;
            in_digits = 1;
            if (dash_found)
                rhs_specified = 1;
            else
                lhs_specified = 1;
            if (!((void)(&(value) == (size_t *)((void *)0)) , (((size_t)-1 / 10 < (value) || (size_t)((value) * 10 + (*fieldstr - '0')) < (value)) ? 0 : (((value) = (value) * 10 + (*fieldstr - '0')) , 1)))) {
                size_t len = strspn(num_start, "0123456789");
                char *bad_num = xstrndup(num_start, len);
                if (operating_mode == byte_mode)
                    error(0, 0, gettext("byte offset %s is too large"), quote(bad_num));
                else
                    error(0, 0, gettext("field number %s is too large"), quote(bad_num));
                free(bad_num);
                exit(1);
            }
            fieldstr++;
        } else
            do {
                error(0, 0, (gettext("invalid byte or field list")));
                usage(1);
            } while (0);
    }


BasicTester, a patch instance with id 183:
Spawn 1 instances, now Total 224
Counter: 225
Batcher Size:44
Preprocess the following candidate with BasicTester:
Priority 7465
At location src/cut.c:363
--Src File: src/cut.c
Fragment 0:
eol_range_start = (8);
while (1)
    {
        if (*fieldstr == '-') {
            in_digits = 0;
            if (dash_found)
                do {
                    error(0, 0, (gettext("invalid byte or field list")));
                    usage(1);
                } while (0);
            dash_found = 1;
            fieldstr++;
            initial = (lhs_specified ? value : 1);
            value = 0;
        } else if (*fieldstr == ',' || ((*__ctype_b_loc())[(int)((to_uchar(*fieldstr)))] & (unsigned short)_ISblank) || *fieldstr == '\x00') {
            in_digits = 0;
            if (dash_found) {
                dash_found = 0;
                if (!lhs_specified && !rhs_specified)
                    do {
                        error(0, 0, (gettext("invalid range with no endpoint: -")));
                        usage(1);
                    } while (0);
                if (!rhs_specified) {
                    eol_range_start = initial;
                    field_found = 1;
                } else {
                    if (value < initial)
                        do {
                            error(0, 0, (gettext("invalid decreasing range")));
                            usage(1);
                        } while (0);
                    if (eol_range_start != 0) {
                        if (initial < eol_range_start) {
                            if (eol_range_start <= value) {
                                eol_range_start = initial;
                            } else {
                                do {
                                    if (initial == 0 || value == 0)
                                        do {
                                            error(0, 0, (gettext("fields and positions are numbered from 1")));
                                            usage(1);
                                        } while (0);
                                    if (n_rp >= n_rp_allocated) {
                                        (rp) = x2nrealloc(rp, &n_rp_allocated, sizeof *(rp));
                                    }
                                    rp[n_rp].lo = (initial);
                                    rp[n_rp].hi = (value);
                                    ++n_rp;
                                } while (0);
                            }
                            field_found = 1;
                        }
                    } else {
                        do {
                            if (initial == 0 || value == 0)
                                do {
                                    error(0, 0, (gettext("fields and positions are numbered from 1")));
                                    usage(1);
                                } while (0);
                            if (n_rp >= n_rp_allocated) {
                                (rp) = x2nrealloc(rp, &n_rp_allocated, sizeof *(rp));
                            }
                            rp[n_rp].lo = (initial);
                            rp[n_rp].hi = (value);
                            ++n_rp;
                        } while (0);
                        field_found = 1;
                    }
                    value = 0;
                }
            } else {
                do {
                    if (value == 0 || value == 0)
                        do {
                            error(0, 0, (gettext("fields and positions are numbered from 1")));
                            usage(1);
                        } while (0);
                    if (n_rp >= n_rp_allocated) {
                        (rp) = x2nrealloc(rp, &n_rp_allocated, sizeof *(rp));
                    }
                    rp[n_rp].lo = (value);
                    rp[n_rp].hi = (value);
                    ++n_rp;
                } while (0);
                value = 0;
                field_found = 1;
            }
            if (*fieldstr == '\x00') {
                break;
            }
            fieldstr++;
            lhs_specified = 0;
            rhs_specified = 0;
        } else if (((unsigned int)(*fieldstr) - '0' <= 9)) {
            static const char *num_start;
            if (!in_digits || !num_start)
                num_start = fieldstr;
            in_digits = 1;
            if (dash_found)
                rhs_specified = 1;
            else
                lhs_specified = 1;
            if (!((void)(&(value) == (size_t *)((void *)0)) , (((size_t)-1 / 10 < (value) || (size_t)((value) * 10 + (*fieldstr - '0')) < (value)) ? 0 : (((value) = (value) * 10 + (*fieldstr - '0')) , 1)))) {
                size_t len = strspn(num_start, "0123456789");
                char *bad_num = xstrndup(num_start, len);
                if (operating_mode == byte_mode)
                    error(0, 0, gettext("byte offset %s is too large"), quote(bad_num));
                else
                    error(0, 0, gettext("field number %s is too large"), quote(bad_num));
                free(bad_num);
                exit(1);
            }
            fieldstr++;
        } else
            do {
                error(0, 0, (gettext("invalid byte or field list")));
                usage(1);
            } while (0);
    }


BasicTester, a patch instance with id 184:
Spawn 1 instances, now Total 225
Counter: 226
Batcher Size:45
Preprocess the following candidate with BasicTester:
Priority 7465
At location src/cut.c:363
--Src File: src/cut.c
Fragment 0:
eol_range_start = (i);
while (1)
    {
        if (*fieldstr == '-') {
            in_digits = 0;
            if (dash_found)
                do {
                    error(0, 0, (gettext("invalid byte or field list")));
                    usage(1);
                } while (0);
            dash_found = 1;
            fieldstr++;
            initial = (lhs_specified ? value : 1);
            value = 0;
        } else if (*fieldstr == ',' || ((*__ctype_b_loc())[(int)((to_uchar(*fieldstr)))] & (unsigned short)_ISblank) || *fieldstr == '\x00') {
            in_digits = 0;
            if (dash_found) {
                dash_found = 0;
                if (!lhs_specified && !rhs_specified)
                    do {
                        error(0, 0, (gettext("invalid range with no endpoint: -")));
                        usage(1);
                    } while (0);
                if (!rhs_specified) {
                    eol_range_start = initial;
                    field_found = 1;
                } else {
                    if (value < initial)
                        do {
                            error(0, 0, (gettext("invalid decreasing range")));
                            usage(1);
                        } while (0);
                    if (eol_range_start != 0) {
                        if (initial < eol_range_start) {
                            if (eol_range_start <= value) {
                                eol_range_start = initial;
                            } else {
                                do {
                                    if (initial == 0 || value == 0)
                                        do {
                                            error(0, 0, (gettext("fields and positions are numbered from 1")));
                                            usage(1);
                                        } while (0);
                                    if (n_rp >= n_rp_allocated) {
                                        (rp) = x2nrealloc(rp, &n_rp_allocated, sizeof *(rp));
                                    }
                                    rp[n_rp].lo = (initial);
                                    rp[n_rp].hi = (value);
                                    ++n_rp;
                                } while (0);
                            }
                            field_found = 1;
                        }
                    } else {
                        do {
                            if (initial == 0 || value == 0)
                                do {
                                    error(0, 0, (gettext("fields and positions are numbered from 1")));
                                    usage(1);
                                } while (0);
                            if (n_rp >= n_rp_allocated) {
                                (rp) = x2nrealloc(rp, &n_rp_allocated, sizeof *(rp));
                            }
                            rp[n_rp].lo = (initial);
                            rp[n_rp].hi = (value);
                            ++n_rp;
                        } while (0);
                        field_found = 1;
                    }
                    value = 0;
                }
            } else {
                do {
                    if (value == 0 || value == 0)
                        do {
                            error(0, 0, (gettext("fields and positions are numbered from 1")));
                            usage(1);
                        } while (0);
                    if (n_rp >= n_rp_allocated) {
                        (rp) = x2nrealloc(rp, &n_rp_allocated, sizeof *(rp));
                    }
                    rp[n_rp].lo = (value);
                    rp[n_rp].hi = (value);
                    ++n_rp;
                } while (0);
                value = 0;
                field_found = 1;
            }
            if (*fieldstr == '\x00') {
                break;
            }
            fieldstr++;
            lhs_specified = 0;
            rhs_specified = 0;
        } else if (((unsigned int)(*fieldstr) - '0' <= 9)) {
            static const char *num_start;
            if (!in_digits || !num_start)
                num_start = fieldstr;
            in_digits = 1;
            if (dash_found)
                rhs_specified = 1;
            else
                lhs_specified = 1;
            if (!((void)(&(value) == (size_t *)((void *)0)) , (((size_t)-1 / 10 < (value) || (size_t)((value) * 10 + (*fieldstr - '0')) < (value)) ? 0 : (((value) = (value) * 10 + (*fieldstr - '0')) , 1)))) {
                size_t len = strspn(num_start, "0123456789");
                char *bad_num = xstrndup(num_start, len);
                if (operating_mode == byte_mode)
                    error(0, 0, gettext("byte offset %s is too large"), quote(bad_num));
                else
                    error(0, 0, gettext("field number %s is too large"), quote(bad_num));
                free(bad_num);
                exit(1);
            }
            fieldstr++;
        } else
            do {
                error(0, 0, (gettext("invalid byte or field list")));
                usage(1);
            } while (0);
    }


BasicTester, a patch instance with id 185:
Spawn 1 instances, now Total 226
Counter: 227
Batcher Size:46
Preprocess the following candidate with BasicTester:
Priority 7465
At location src/cut.c:363
--Src File: src/cut.c
Fragment 0:
eol_range_start = (9);
while (1)
    {
        if (*fieldstr == '-') {
            in_digits = 0;
            if (dash_found)
                do {
                    error(0, 0, (gettext("invalid byte or field list")));
                    usage(1);
                } while (0);
            dash_found = 1;
            fieldstr++;
            initial = (lhs_specified ? value : 1);
            value = 0;
        } else if (*fieldstr == ',' || ((*__ctype_b_loc())[(int)((to_uchar(*fieldstr)))] & (unsigned short)_ISblank) || *fieldstr == '\x00') {
            in_digits = 0;
            if (dash_found) {
                dash_found = 0;
                if (!lhs_specified && !rhs_specified)
                    do {
                        error(0, 0, (gettext("invalid range with no endpoint: -")));
                        usage(1);
                    } while (0);
                if (!rhs_specified) {
                    eol_range_start = initial;
                    field_found = 1;
                } else {
                    if (value < initial)
                        do {
                            error(0, 0, (gettext("invalid decreasing range")));
                            usage(1);
                        } while (0);
                    if (eol_range_start != 0) {
                        if (initial < eol_range_start) {
                            if (eol_range_start <= value) {
                                eol_range_start = initial;
                            } else {
                                do {
                                    if (initial == 0 || value == 0)
                                        do {
                                            error(0, 0, (gettext("fields and positions are numbered from 1")));
                                            usage(1);
                                        } while (0);
                                    if (n_rp >= n_rp_allocated) {
                                        (rp) = x2nrealloc(rp, &n_rp_allocated, sizeof *(rp));
                                    }
                                    rp[n_rp].lo = (initial);
                                    rp[n_rp].hi = (value);
                                    ++n_rp;
                                } while (0);
                            }
                            field_found = 1;
                        }
                    } else {
                        do {
                            if (initial == 0 || value == 0)
                                do {
                                    error(0, 0, (gettext("fields and positions are numbered from 1")));
                                    usage(1);
                                } while (0);
                            if (n_rp >= n_rp_allocated) {
                                (rp) = x2nrealloc(rp, &n_rp_allocated, sizeof *(rp));
                            }
                            rp[n_rp].lo = (initial);
                            rp[n_rp].hi = (value);
                            ++n_rp;
                        } while (0);
                        field_found = 1;
                    }
                    value = 0;
                }
            } else {
                do {
                    if (value == 0 || value == 0)
                        do {
                            error(0, 0, (gettext("fields and positions are numbered from 1")));
                            usage(1);
                        } while (0);
                    if (n_rp >= n_rp_allocated) {
                        (rp) = x2nrealloc(rp, &n_rp_allocated, sizeof *(rp));
                    }
                    rp[n_rp].lo = (value);
                    rp[n_rp].hi = (value);
                    ++n_rp;
                } while (0);
                value = 0;
                field_found = 1;
            }
            if (*fieldstr == '\x00') {
                break;
            }
            fieldstr++;
            lhs_specified = 0;
            rhs_specified = 0;
        } else if (((unsigned int)(*fieldstr) - '0' <= 9)) {
            static const char *num_start;
            if (!in_digits || !num_start)
                num_start = fieldstr;
            in_digits = 1;
            if (dash_found)
                rhs_specified = 1;
            else
                lhs_specified = 1;
            if (!((void)(&(value) == (size_t *)((void *)0)) , (((size_t)-1 / 10 < (value) || (size_t)((value) * 10 + (*fieldstr - '0')) < (value)) ? 0 : (((value) = (value) * 10 + (*fieldstr - '0')) , 1)))) {
                size_t len = strspn(num_start, "0123456789");
                char *bad_num = xstrndup(num_start, len);
                if (operating_mode == byte_mode)
                    error(0, 0, gettext("byte offset %s is too large"), quote(bad_num));
                else
                    error(0, 0, gettext("field number %s is too large"), quote(bad_num));
                free(bad_num);
                exit(1);
            }
            fieldstr++;
        } else
            do {
                error(0, 0, (gettext("invalid byte or field list")));
                usage(1);
            } while (0);
    }


BasicTester, a patch instance with id 186:
Spawn 1 instances, now Total 227
Counter: 228
Batcher Size:47
Preprocess the following candidate with BasicTester:
Priority 7465
At location src/cut.c:363
--Src File: src/cut.c
Fragment 0:
eol_range_start = (0);
while (1)
    {
        if (*fieldstr == '-') {
            in_digits = 0;
            if (dash_found)
                do {
                    error(0, 0, (gettext("invalid byte or field list")));
                    usage(1);
                } while (0);
            dash_found = 1;
            fieldstr++;
            initial = (lhs_specified ? value : 1);
            value = 0;
        } else if (*fieldstr == ',' || ((*__ctype_b_loc())[(int)((to_uchar(*fieldstr)))] & (unsigned short)_ISblank) || *fieldstr == '\x00') {
            in_digits = 0;
            if (dash_found) {
                dash_found = 0;
                if (!lhs_specified && !rhs_specified)
                    do {
                        error(0, 0, (gettext("invalid range with no endpoint: -")));
                        usage(1);
                    } while (0);
                if (!rhs_specified) {
                    eol_range_start = initial;
                    field_found = 1;
                } else {
                    if (value < initial)
                        do {
                            error(0, 0, (gettext("invalid decreasing range")));
                            usage(1);
                        } while (0);
                    if (eol_range_start != 0) {
                        if (initial < eol_range_start) {
                            if (eol_range_start <= value) {
                                eol_range_start = initial;
                            } else {
                                do {
                                    if (initial == 0 || value == 0)
                                        do {
                                            error(0, 0, (gettext("fields and positions are numbered from 1")));
                                            usage(1);
                                        } while (0);
                                    if (n_rp >= n_rp_allocated) {
                                        (rp) = x2nrealloc(rp, &n_rp_allocated, sizeof *(rp));
                                    }
                                    rp[n_rp].lo = (initial);
                                    rp[n_rp].hi = (value);
                                    ++n_rp;
                                } while (0);
                            }
                            field_found = 1;
                        }
                    } else {
                        do {
                            if (initial == 0 || value == 0)
                                do {
                                    error(0, 0, (gettext("fields and positions are numbered from 1")));
                                    usage(1);
                                } while (0);
                            if (n_rp >= n_rp_allocated) {
                                (rp) = x2nrealloc(rp, &n_rp_allocated, sizeof *(rp));
                            }
                            rp[n_rp].lo = (initial);
                            rp[n_rp].hi = (value);
                            ++n_rp;
                        } while (0);
                        field_found = 1;
                    }
                    value = 0;
                }
            } else {
                do {
                    if (value == 0 || value == 0)
                        do {
                            error(0, 0, (gettext("fields and positions are numbered from 1")));
                            usage(1);
                        } while (0);
                    if (n_rp >= n_rp_allocated) {
                        (rp) = x2nrealloc(rp, &n_rp_allocated, sizeof *(rp));
                    }
                    rp[n_rp].lo = (value);
                    rp[n_rp].hi = (value);
                    ++n_rp;
                } while (0);
                value = 0;
                field_found = 1;
            }
            if (*fieldstr == '\x00') {
                break;
            }
            fieldstr++;
            lhs_specified = 0;
            rhs_specified = 0;
        } else if (((unsigned int)(*fieldstr) - '0' <= 9)) {
            static const char *num_start;
            if (!in_digits || !num_start)
                num_start = fieldstr;
            in_digits = 1;
            if (dash_found)
                rhs_specified = 1;
            else
                lhs_specified = 1;
            if (!((void)(&(value) == (size_t *)((void *)0)) , (((size_t)-1 / 10 < (value) || (size_t)((value) * 10 + (*fieldstr - '0')) < (value)) ? 0 : (((value) = (value) * 10 + (*fieldstr - '0')) , 1)))) {
                size_t len = strspn(num_start, "0123456789");
                char *bad_num = xstrndup(num_start, len);
                if (operating_mode == byte_mode)
                    error(0, 0, gettext("byte offset %s is too large"), quote(bad_num));
                else
                    error(0, 0, gettext("field number %s is too large"), quote(bad_num));
                free(bad_num);
                exit(1);
            }
            fieldstr++;
        } else
            do {
                error(0, 0, (gettext("invalid byte or field list")));
                usage(1);
            } while (0);
    }


BasicTester, a patch instance with id 187:
Spawn 1 instances, now Total 228
Counter: 229
Batcher Size:48
Preprocess the following candidate with BasicTester:
Priority 7465
At location src/cut.c:363
--Src File: src/cut.c
Fragment 0:
eol_range_start = (1);
while (1)
    {
        if (*fieldstr == '-') {
            in_digits = 0;
            if (dash_found)
                do {
                    error(0, 0, (gettext("invalid byte or field list")));
                    usage(1);
                } while (0);
            dash_found = 1;
            fieldstr++;
            initial = (lhs_specified ? value : 1);
            value = 0;
        } else if (*fieldstr == ',' || ((*__ctype_b_loc())[(int)((to_uchar(*fieldstr)))] & (unsigned short)_ISblank) || *fieldstr == '\x00') {
            in_digits = 0;
            if (dash_found) {
                dash_found = 0;
                if (!lhs_specified && !rhs_specified)
                    do {
                        error(0, 0, (gettext("invalid range with no endpoint: -")));
                        usage(1);
                    } while (0);
                if (!rhs_specified) {
                    eol_range_start = initial;
                    field_found = 1;
                } else {
                    if (value < initial)
                        do {
                            error(0, 0, (gettext("invalid decreasing range")));
                            usage(1);
                        } while (0);
                    if (eol_range_start != 0) {
                        if (initial < eol_range_start) {
                            if (eol_range_start <= value) {
                                eol_range_start = initial;
                            } else {
                                do {
                                    if (initial == 0 || value == 0)
                                        do {
                                            error(0, 0, (gettext("fields and positions are numbered from 1")));
                                            usage(1);
                                        } while (0);
                                    if (n_rp >= n_rp_allocated) {
                                        (rp) = x2nrealloc(rp, &n_rp_allocated, sizeof *(rp));
                                    }
                                    rp[n_rp].lo = (initial);
                                    rp[n_rp].hi = (value);
                                    ++n_rp;
                                } while (0);
                            }
                            field_found = 1;
                        }
                    } else {
                        do {
                            if (initial == 0 || value == 0)
                                do {
                                    error(0, 0, (gettext("fields and positions are numbered from 1")));
                                    usage(1);
                                } while (0);
                            if (n_rp >= n_rp_allocated) {
                                (rp) = x2nrealloc(rp, &n_rp_allocated, sizeof *(rp));
                            }
                            rp[n_rp].lo = (initial);
                            rp[n_rp].hi = (value);
                            ++n_rp;
                        } while (0);
                        field_found = 1;
                    }
                    value = 0;
                }
            } else {
                do {
                    if (value == 0 || value == 0)
                        do {
                            error(0, 0, (gettext("fields and positions are numbered from 1")));
                            usage(1);
                        } while (0);
                    if (n_rp >= n_rp_allocated) {
                        (rp) = x2nrealloc(rp, &n_rp_allocated, sizeof *(rp));
                    }
                    rp[n_rp].lo = (value);
                    rp[n_rp].hi = (value);
                    ++n_rp;
                } while (0);
                value = 0;
                field_found = 1;
            }
            if (*fieldstr == '\x00') {
                break;
            }
            fieldstr++;
            lhs_specified = 0;
            rhs_specified = 0;
        } else if (((unsigned int)(*fieldstr) - '0' <= 9)) {
            static const char *num_start;
            if (!in_digits || !num_start)
                num_start = fieldstr;
            in_digits = 1;
            if (dash_found)
                rhs_specified = 1;
            else
                lhs_specified = 1;
            if (!((void)(&(value) == (size_t *)((void *)0)) , (((size_t)-1 / 10 < (value) || (size_t)((value) * 10 + (*fieldstr - '0')) < (value)) ? 0 : (((value) = (value) * 10 + (*fieldstr - '0')) , 1)))) {
                size_t len = strspn(num_start, "0123456789");
                char *bad_num = xstrndup(num_start, len);
                if (operating_mode == byte_mode)
                    error(0, 0, gettext("byte offset %s is too large"), quote(bad_num));
                else
                    error(0, 0, gettext("field number %s is too large"), quote(bad_num));
                free(bad_num);
                exit(1);
            }
            fieldstr++;
        } else
            do {
                error(0, 0, (gettext("invalid byte or field list")));
                usage(1);
            } while (0);
    }


BasicTester, a patch instance with id 188:
Spawn 1 instances, now Total 229
Counter: 230
Batcher Size:49
Preprocess the following candidate with BasicTester:
Priority 7465
At location src/cut.c:363
--Src File: src/cut.c
Fragment 0:
eol_range_start = (10);
while (1)
    {
        if (*fieldstr == '-') {
            in_digits = 0;
            if (dash_found)
                do {
                    error(0, 0, (gettext("invalid byte or field list")));
                    usage(1);
                } while (0);
            dash_found = 1;
            fieldstr++;
            initial = (lhs_specified ? value : 1);
            value = 0;
        } else if (*fieldstr == ',' || ((*__ctype_b_loc())[(int)((to_uchar(*fieldstr)))] & (unsigned short)_ISblank) || *fieldstr == '\x00') {
            in_digits = 0;
            if (dash_found) {
                dash_found = 0;
                if (!lhs_specified && !rhs_specified)
                    do {
                        error(0, 0, (gettext("invalid range with no endpoint: -")));
                        usage(1);
                    } while (0);
                if (!rhs_specified) {
                    eol_range_start = initial;
                    field_found = 1;
                } else {
                    if (value < initial)
                        do {
                            error(0, 0, (gettext("invalid decreasing range")));
                            usage(1);
                        } while (0);
                    if (eol_range_start != 0) {
                        if (initial < eol_range_start) {
                            if (eol_range_start <= value) {
                                eol_range_start = initial;
                            } else {
                                do {
                                    if (initial == 0 || value == 0)
                                        do {
                                            error(0, 0, (gettext("fields and positions are numbered from 1")));
                                            usage(1);
                                        } while (0);
                                    if (n_rp >= n_rp_allocated) {
                                        (rp) = x2nrealloc(rp, &n_rp_allocated, sizeof *(rp));
                                    }
                                    rp[n_rp].lo = (initial);
                                    rp[n_rp].hi = (value);
                                    ++n_rp;
                                } while (0);
                            }
                            field_found = 1;
                        }
                    } else {
                        do {
                            if (initial == 0 || value == 0)
                                do {
                                    error(0, 0, (gettext("fields and positions are numbered from 1")));
                                    usage(1);
                                } while (0);
                            if (n_rp >= n_rp_allocated) {
                                (rp) = x2nrealloc(rp, &n_rp_allocated, sizeof *(rp));
                            }
                            rp[n_rp].lo = (initial);
                            rp[n_rp].hi = (value);
                            ++n_rp;
                        } while (0);
                        field_found = 1;
                    }
                    value = 0;
                }
            } else {
                do {
                    if (value == 0 || value == 0)
                        do {
                            error(0, 0, (gettext("fields and positions are numbered from 1")));
                            usage(1);
                        } while (0);
                    if (n_rp >= n_rp_allocated) {
                        (rp) = x2nrealloc(rp, &n_rp_allocated, sizeof *(rp));
                    }
                    rp[n_rp].lo = (value);
                    rp[n_rp].hi = (value);
                    ++n_rp;
                } while (0);
                value = 0;
                field_found = 1;
            }
            if (*fieldstr == '\x00') {
                break;
            }
            fieldstr++;
            lhs_specified = 0;
            rhs_specified = 0;
        } else if (((unsigned int)(*fieldstr) - '0' <= 9)) {
            static const char *num_start;
            if (!in_digits || !num_start)
                num_start = fieldstr;
            in_digits = 1;
            if (dash_found)
                rhs_specified = 1;
            else
                lhs_specified = 1;
            if (!((void)(&(value) == (size_t *)((void *)0)) , (((size_t)-1 / 10 < (value) || (size_t)((value) * 10 + (*fieldstr - '0')) < (value)) ? 0 : (((value) = (value) * 10 + (*fieldstr - '0')) , 1)))) {
                size_t len = strspn(num_start, "0123456789");
                char *bad_num = xstrndup(num_start, len);
                if (operating_mode == byte_mode)
                    error(0, 0, gettext("byte offset %s is too large"), quote(bad_num));
                else
                    error(0, 0, gettext("field number %s is too large"), quote(bad_num));
                free(bad_num);
                exit(1);
            }
            fieldstr++;
        } else
            do {
                error(0, 0, (gettext("invalid byte or field list")));
                usage(1);
            } while (0);
    }


BasicTester, a patch instance with id 189:
Spawn 1 instances, now Total 230
Counter: 231
Batcher Size:50
Preprocess the following candidate with BasicTester:
Priority 7465
At location src/cut.c:363
--Src File: src/cut.c
Fragment 0:
delim = (-1);
while (1)
    {
        if (*fieldstr == '-') {
            in_digits = 0;
            if (dash_found)
                do {
                    error(0, 0, (gettext("invalid byte or field list")));
                    usage(1);
                } while (0);
            dash_found = 1;
            fieldstr++;
            initial = (lhs_specified ? value : 1);
            value = 0;
        } else if (*fieldstr == ',' || ((*__ctype_b_loc())[(int)((to_uchar(*fieldstr)))] & (unsigned short)_ISblank) || *fieldstr == '\x00') {
            in_digits = 0;
            if (dash_found) {
                dash_found = 0;
                if (!lhs_specified && !rhs_specified)
                    do {
                        error(0, 0, (gettext("invalid range with no endpoint: -")));
                        usage(1);
                    } while (0);
                if (!rhs_specified) {
                    eol_range_start = initial;
                    field_found = 1;
                } else {
                    if (value < initial)
                        do {
                            error(0, 0, (gettext("invalid decreasing range")));
                            usage(1);
                        } while (0);
                    if (eol_range_start != 0) {
                        if (initial < eol_range_start) {
                            if (eol_range_start <= value) {
                                eol_range_start = initial;
                            } else {
                                do {
                                    if (initial == 0 || value == 0)
                                        do {
                                            error(0, 0, (gettext("fields and positions are numbered from 1")));
                                            usage(1);
                                        } while (0);
                                    if (n_rp >= n_rp_allocated) {
                                        (rp) = x2nrealloc(rp, &n_rp_allocated, sizeof *(rp));
                                    }
                                    rp[n_rp].lo = (initial);
                                    rp[n_rp].hi = (value);
                                    ++n_rp;
                                } while (0);
                            }
                            field_found = 1;
                        }
                    } else {
                        do {
                            if (initial == 0 || value == 0)
                                do {
                                    error(0, 0, (gettext("fields and positions are numbered from 1")));
                                    usage(1);
                                } while (0);
                            if (n_rp >= n_rp_allocated) {
                                (rp) = x2nrealloc(rp, &n_rp_allocated, sizeof *(rp));
                            }
                            rp[n_rp].lo = (initial);
                            rp[n_rp].hi = (value);
                            ++n_rp;
                        } while (0);
                        field_found = 1;
                    }
                    value = 0;
                }
            } else {
                do {
                    if (value == 0 || value == 0)
                        do {
                            error(0, 0, (gettext("fields and positions are numbered from 1")));
                            usage(1);
                        } while (0);
                    if (n_rp >= n_rp_allocated) {
                        (rp) = x2nrealloc(rp, &n_rp_allocated, sizeof *(rp));
                    }
                    rp[n_rp].lo = (value);
                    rp[n_rp].hi = (value);
                    ++n_rp;
                } while (0);
                value = 0;
                field_found = 1;
            }
            if (*fieldstr == '\x00') {
                break;
            }
            fieldstr++;
            lhs_specified = 0;
            rhs_specified = 0;
        } else if (((unsigned int)(*fieldstr) - '0' <= 9)) {
            static const char *num_start;
            if (!in_digits || !num_start)
                num_start = fieldstr;
            in_digits = 1;
            if (dash_found)
                rhs_specified = 1;
            else
                lhs_specified = 1;
            if (!((void)(&(value) == (size_t *)((void *)0)) , (((size_t)-1 / 10 < (value) || (size_t)((value) * 10 + (*fieldstr - '0')) < (value)) ? 0 : (((value) = (value) * 10 + (*fieldstr - '0')) , 1)))) {
                size_t len = strspn(num_start, "0123456789");
                char *bad_num = xstrndup(num_start, len);
                if (operating_mode == byte_mode)
                    error(0, 0, gettext("byte offset %s is too large"), quote(bad_num));
                else
                    error(0, 0, gettext("field number %s is too large"), quote(bad_num));
                free(bad_num);
                exit(1);
            }
            fieldstr++;
        } else
            do {
                error(0, 0, (gettext("invalid byte or field list")));
                usage(1);
            } while (0);
    }


BasicTester, a patch instance with id 190:
Spawn 1 instances, now Total 231
Counter: 232
Batcher Size:51
Preprocess the following candidate with BasicTester:
Priority 7465
At location src/cut.c:363
--Src File: src/cut.c
Fragment 0:
delim = (10);
while (1)
    {
        if (*fieldstr == '-') {
            in_digits = 0;
            if (dash_found)
                do {
                    error(0, 0, (gettext("invalid byte or field list")));
                    usage(1);
                } while (0);
            dash_found = 1;
            fieldstr++;
            initial = (lhs_specified ? value : 1);
            value = 0;
        } else if (*fieldstr == ',' || ((*__ctype_b_loc())[(int)((to_uchar(*fieldstr)))] & (unsigned short)_ISblank) || *fieldstr == '\x00') {
            in_digits = 0;
            if (dash_found) {
                dash_found = 0;
                if (!lhs_specified && !rhs_specified)
                    do {
                        error(0, 0, (gettext("invalid range with no endpoint: -")));
                        usage(1);
                    } while (0);
                if (!rhs_specified) {
                    eol_range_start = initial;
                    field_found = 1;
                } else {
                    if (value < initial)
                        do {
                            error(0, 0, (gettext("invalid decreasing range")));
                            usage(1);
                        } while (0);
                    if (eol_range_start != 0) {
                        if (initial < eol_range_start) {
                            if (eol_range_start <= value) {
                                eol_range_start = initial;
                            } else {
                                do {
                                    if (initial == 0 || value == 0)
                                        do {
                                            error(0, 0, (gettext("fields and positions are numbered from 1")));
                                            usage(1);
                                        } while (0);
                                    if (n_rp >= n_rp_allocated) {
                                        (rp) = x2nrealloc(rp, &n_rp_allocated, sizeof *(rp));
                                    }
                                    rp[n_rp].lo = (initial);
                                    rp[n_rp].hi = (value);
                                    ++n_rp;
                                } while (0);
                            }
                            field_found = 1;
                        }
                    } else {
                        do {
                            if (initial == 0 || value == 0)
                                do {
                                    error(0, 0, (gettext("fields and positions are numbered from 1")));
                                    usage(1);
                                } while (0);
                            if (n_rp >= n_rp_allocated) {
                                (rp) = x2nrealloc(rp, &n_rp_allocated, sizeof *(rp));
                            }
                            rp[n_rp].lo = (initial);
                            rp[n_rp].hi = (value);
                            ++n_rp;
                        } while (0);
                        field_found = 1;
                    }
                    value = 0;
                }
            } else {
                do {
                    if (value == 0 || value == 0)
                        do {
                            error(0, 0, (gettext("fields and positions are numbered from 1")));
                            usage(1);
                        } while (0);
                    if (n_rp >= n_rp_allocated) {
                        (rp) = x2nrealloc(rp, &n_rp_allocated, sizeof *(rp));
                    }
                    rp[n_rp].lo = (value);
                    rp[n_rp].hi = (value);
                    ++n_rp;
                } while (0);
                value = 0;
                field_found = 1;
            }
            if (*fieldstr == '\x00') {
                break;
            }
            fieldstr++;
            lhs_specified = 0;
            rhs_specified = 0;
        } else if (((unsigned int)(*fieldstr) - '0' <= 9)) {
            static const char *num_start;
            if (!in_digits || !num_start)
                num_start = fieldstr;
            in_digits = 1;
            if (dash_found)
                rhs_specified = 1;
            else
                lhs_specified = 1;
            if (!((void)(&(value) == (size_t *)((void *)0)) , (((size_t)-1 / 10 < (value) || (size_t)((value) * 10 + (*fieldstr - '0')) < (value)) ? 0 : (((value) = (value) * 10 + (*fieldstr - '0')) , 1)))) {
                size_t len = strspn(num_start, "0123456789");
                char *bad_num = xstrndup(num_start, len);
                if (operating_mode == byte_mode)
                    error(0, 0, gettext("byte offset %s is too large"), quote(bad_num));
                else
                    error(0, 0, gettext("field number %s is too large"), quote(bad_num));
                free(bad_num);
                exit(1);
            }
            fieldstr++;
        } else
            do {
                error(0, 0, (gettext("invalid byte or field list")));
                usage(1);
            } while (0);
    }


BasicTester, a patch instance with id 191:
Spawn 1 instances, now Total 232
Counter: 233
Batcher Size:52
Preprocess the following candidate with BasicTester:
Priority 7465
At location src/cut.c:363
--Src File: src/cut.c
Fragment 0:
delim = (9);
while (1)
    {
        if (*fieldstr == '-') {
            in_digits = 0;
            if (dash_found)
                do {
                    error(0, 0, (gettext("invalid byte or field list")));
                    usage(1);
                } while (0);
            dash_found = 1;
            fieldstr++;
            initial = (lhs_specified ? value : 1);
            value = 0;
        } else if (*fieldstr == ',' || ((*__ctype_b_loc())[(int)((to_uchar(*fieldstr)))] & (unsigned short)_ISblank) || *fieldstr == '\x00') {
            in_digits = 0;
            if (dash_found) {
                dash_found = 0;
                if (!lhs_specified && !rhs_specified)
                    do {
                        error(0, 0, (gettext("invalid range with no endpoint: -")));
                        usage(1);
                    } while (0);
                if (!rhs_specified) {
                    eol_range_start = initial;
                    field_found = 1;
                } else {
                    if (value < initial)
                        do {
                            error(0, 0, (gettext("invalid decreasing range")));
                            usage(1);
                        } while (0);
                    if (eol_range_start != 0) {
                        if (initial < eol_range_start) {
                            if (eol_range_start <= value) {
                                eol_range_start = initial;
                            } else {
                                do {
                                    if (initial == 0 || value == 0)
                                        do {
                                            error(0, 0, (gettext("fields and positions are numbered from 1")));
                                            usage(1);
                                        } while (0);
                                    if (n_rp >= n_rp_allocated) {
                                        (rp) = x2nrealloc(rp, &n_rp_allocated, sizeof *(rp));
                                    }
                                    rp[n_rp].lo = (initial);
                                    rp[n_rp].hi = (value);
                                    ++n_rp;
                                } while (0);
                            }
                            field_found = 1;
                        }
                    } else {
                        do {
                            if (initial == 0 || value == 0)
                                do {
                                    error(0, 0, (gettext("fields and positions are numbered from 1")));
                                    usage(1);
                                } while (0);
                            if (n_rp >= n_rp_allocated) {
                                (rp) = x2nrealloc(rp, &n_rp_allocated, sizeof *(rp));
                            }
                            rp[n_rp].lo = (initial);
                            rp[n_rp].hi = (value);
                            ++n_rp;
                        } while (0);
                        field_found = 1;
                    }
                    value = 0;
                }
            } else {
                do {
                    if (value == 0 || value == 0)
                        do {
                            error(0, 0, (gettext("fields and positions are numbered from 1")));
                            usage(1);
                        } while (0);
                    if (n_rp >= n_rp_allocated) {
                        (rp) = x2nrealloc(rp, &n_rp_allocated, sizeof *(rp));
                    }
                    rp[n_rp].lo = (value);
                    rp[n_rp].hi = (value);
                    ++n_rp;
                } while (0);
                value = 0;
                field_found = 1;
            }
            if (*fieldstr == '\x00') {
                break;
            }
            fieldstr++;
            lhs_specified = 0;
            rhs_specified = 0;
        } else if (((unsigned int)(*fieldstr) - '0' <= 9)) {
            static const char *num_start;
            if (!in_digits || !num_start)
                num_start = fieldstr;
            in_digits = 1;
            if (dash_found)
                rhs_specified = 1;
            else
                lhs_specified = 1;
            if (!((void)(&(value) == (size_t *)((void *)0)) , (((size_t)-1 / 10 < (value) || (size_t)((value) * 10 + (*fieldstr - '0')) < (value)) ? 0 : (((value) = (value) * 10 + (*fieldstr - '0')) , 1)))) {
                size_t len = strspn(num_start, "0123456789");
                char *bad_num = xstrndup(num_start, len);
                if (operating_mode == byte_mode)
                    error(0, 0, gettext("byte offset %s is too large"), quote(bad_num));
                else
                    error(0, 0, gettext("field number %s is too large"), quote(bad_num));
                free(bad_num);
                exit(1);
            }
            fieldstr++;
        } else
            do {
                error(0, 0, (gettext("invalid byte or field list")));
                usage(1);
            } while (0);
    }


BasicTester, a patch instance with id 192:
Spawn 1 instances, now Total 233
a batched test job starts!
Building:src at:
/home/ubuntu/spr-fast/tests/corebench/coreutils/coreutils-case-7380cf79-2e636af1/tempworkdir/srcMerged code building succ, going to invoke tester!
BasicTester, Testing instance id 183:
Running test command:
/home/ubuntu/spr-fast/tools/coreutils-test.py /home/ubuntu/spr-fast/tests/corebench/coreutils/coreutils-case-7380cf79-2e636af1/tempworkdir/src /home/ubuntu/spr-fast/tests/corebench/coreutils/coreutils-case-7380cf79-2e636af1/tempworkdir/tests /home/ubuntu/spr-fast/tests/corebench/coreutils/coreutils-case-7380cf79-2e636af1/tempworkdir 0  > __res
BasicTester, Testing instance id 184:
Running test command:
/home/ubuntu/spr-fast/tools/coreutils-test.py /home/ubuntu/spr-fast/tests/corebench/coreutils/coreutils-case-7380cf79-2e636af1/tempworkdir/src /home/ubuntu/spr-fast/tests/corebench/coreutils/coreutils-case-7380cf79-2e636af1/tempworkdir/tests /home/ubuntu/spr-fast/tests/corebench/coreutils/coreutils-case-7380cf79-2e636af1/tempworkdir 0  > __res
BasicTester, Testing instance id 185:
Running test command:
/home/ubuntu/spr-fast/tools/coreutils-test.py /home/ubuntu/spr-fast/tests/corebench/coreutils/coreutils-case-7380cf79-2e636af1/tempworkdir/src /home/ubuntu/spr-fast/tests/corebench/coreutils/coreutils-case-7380cf79-2e636af1/tempworkdir/tests /home/ubuntu/spr-fast/tests/corebench/coreutils/coreutils-case-7380cf79-2e636af1/tempworkdir 0  > __res
BasicTester, Testing instance id 186:
Running test command:
/home/ubuntu/spr-fast/tools/coreutils-test.py /home/ubuntu/spr-fast/tests/corebench/coreutils/coreutils-case-7380cf79-2e636af1/tempworkdir/src /home/ubuntu/spr-fast/tests/corebench/coreutils/coreutils-case-7380cf79-2e636af1/tempworkdir/tests /home/ubuntu/spr-fast/tests/corebench/coreutils/coreutils-case-7380cf79-2e636af1/tempworkdir 0  > __res
BasicTester, Testing instance id 187:
Running test command:
/home/ubuntu/spr-fast/tools/coreutils-test.py /home/ubuntu/spr-fast/tests/corebench/coreutils/coreutils-case-7380cf79-2e636af1/tempworkdir/src /home/ubuntu/spr-fast/tests/corebench/coreutils/coreutils-case-7380cf79-2e636af1/tempworkdir/tests /home/ubuntu/spr-fast/tests/corebench/coreutils/coreutils-case-7380cf79-2e636af1/tempworkdir 0  > __res
BasicTester, Testing instance id 188:
Running test command:
/home/ubuntu/spr-fast/tools/coreutils-test.py /home/ubuntu/spr-fast/tests/corebench/coreutils/coreutils-case-7380cf79-2e636af1/tempworkdir/src /home/ubuntu/spr-fast/tests/corebench/coreutils/coreutils-case-7380cf79-2e636af1/tempworkdir/tests /home/ubuntu/spr-fast/tests/corebench/coreutils/coreutils-case-7380cf79-2e636af1/tempworkdir 0  > __res
BasicTester, Testing instance id 189:
Running test command:
/home/ubuntu/spr-fast/tools/coreutils-test.py /home/ubuntu/spr-fast/tests/corebench/coreutils/coreutils-case-7380cf79-2e636af1/tempworkdir/src /home/ubuntu/spr-fast/tests/corebench/coreutils/coreutils-case-7380cf79-2e636af1/tempworkdir/tests /home/ubuntu/spr-fast/tests/corebench/coreutils/coreutils-case-7380cf79-2e636af1/tempworkdir 0  > __res
BasicTester, Testing instance id 190:
Running test command:
/home/ubuntu/spr-fast/tools/coreutils-test.py /home/ubuntu/spr-fast/tests/corebench/coreutils/coreutils-case-7380cf79-2e636af1/tempworkdir/src /home/ubuntu/spr-fast/tests/corebench/coreutils/coreutils-case-7380cf79-2e636af1/tempworkdir/tests /home/ubuntu/spr-fast/tests/corebench/coreutils/coreutils-case-7380cf79-2e636af1/tempworkdir 0  > __res
BasicTester, Testing instance id 191:
Running test command:
/home/ubuntu/spr-fast/tools/coreutils-test.py /home/ubuntu/spr-fast/tests/corebench/coreutils/coreutils-case-7380cf79-2e636af1/tempworkdir/src /home/ubuntu/spr-fast/tests/corebench/coreutils/coreutils-case-7380cf79-2e636af1/tempworkdir/tests /home/ubuntu/spr-fast/tests/corebench/coreutils/coreutils-case-7380cf79-2e636af1/tempworkdir 0  > __res
BasicTester, Testing instance id 192:
Running test command:
/home/ubuntu/spr-fast/tools/coreutils-test.py /home/ubuntu/spr-fast/tests/corebench/coreutils/coreutils-case-7380cf79-2e636af1/tempworkdir/src /home/ubuntu/spr-fast/tests/corebench/coreutils/coreutils-case-7380cf79-2e636af1/tempworkdir/tests /home/ubuntu/spr-fast/tests/corebench/coreutils/coreutils-case-7380cf79-2e636af1/tempworkdir 0  > __res
Counter: 234
Batcher Size:43
Preprocess the following candidate with BasicTester:
Priority 7465
At location src/cut.c:363
--Src File: src/cut.c
Fragment 0:
emit_ancillary_info();
while (1)
    {
        if (*fieldstr == '-') {
            in_digits = 0;
            if (dash_found)
                do {
                    error(0, 0, (gettext("invalid byte or field list")));
                    usage(1);
                } while (0);
            dash_found = 1;
            fieldstr++;
            initial = (lhs_specified ? value : 1);
            value = 0;
        } else if (*fieldstr == ',' || ((*__ctype_b_loc())[(int)((to_uchar(*fieldstr)))] & (unsigned short)_ISblank) || *fieldstr == '\x00') {
            in_digits = 0;
            if (dash_found) {
                dash_found = 0;
                if (!lhs_specified && !rhs_specified)
                    do {
                        error(0, 0, (gettext("invalid range with no endpoint: -")));
                        usage(1);
                    } while (0);
                if (!rhs_specified) {
                    eol_range_start = initial;
                    field_found = 1;
                } else {
                    if (value < initial)
                        do {
                            error(0, 0, (gettext("invalid decreasing range")));
                            usage(1);
                        } while (0);
                    if (eol_range_start != 0) {
                        if (initial < eol_range_start) {
                            if (eol_range_start <= value) {
                                eol_range_start = initial;
                            } else {
                                do {
                                    if (initial == 0 || value == 0)
                                        do {
                                            error(0, 0, (gettext("fields and positions are numbered from 1")));
                                            usage(1);
                                        } while (0);
                                    if (n_rp >= n_rp_allocated) {
                                        (rp) = x2nrealloc(rp, &n_rp_allocated, sizeof *(rp));
                                    }
                                    rp[n_rp].lo = (initial);
                                    rp[n_rp].hi = (value);
                                    ++n_rp;
                                } while (0);
                            }
                            field_found = 1;
                        }
                    } else {
                        do {
                            if (initial == 0 || value == 0)
                                do {
                                    error(0, 0, (gettext("fields and positions are numbered from 1")));
                                    usage(1);
                                } while (0);
                            if (n_rp >= n_rp_allocated) {
                                (rp) = x2nrealloc(rp, &n_rp_allocated, sizeof *(rp));
                            }
                            rp[n_rp].lo = (initial);
                            rp[n_rp].hi = (value);
                            ++n_rp;
                        } while (0);
                        field_found = 1;
                    }
                    value = 0;
                }
            } else {
                do {
                    if (value == 0 || value == 0)
                        do {
                            error(0, 0, (gettext("fields and positions are numbered from 1")));
                            usage(1);
                        } while (0);
                    if (n_rp >= n_rp_allocated) {
                        (rp) = x2nrealloc(rp, &n_rp_allocated, sizeof *(rp));
                    }
                    rp[n_rp].lo = (value);
                    rp[n_rp].hi = (value);
                    ++n_rp;
                } while (0);
                value = 0;
                field_found = 1;
            }
            if (*fieldstr == '\x00') {
                break;
            }
            fieldstr++;
            lhs_specified = 0;
            rhs_specified = 0;
        } else if (((unsigned int)(*fieldstr) - '0' <= 9)) {
            static const char *num_start;
            if (!in_digits || !num_start)
                num_start = fieldstr;
            in_digits = 1;
            if (dash_found)
                rhs_specified = 1;
            else
                lhs_specified = 1;
            if (!((void)(&(value) == (size_t *)((void *)0)) , (((size_t)-1 / 10 < (value) || (size_t)((value) * 10 + (*fieldstr - '0')) < (value)) ? 0 : (((value) = (value) * 10 + (*fieldstr - '0')) , 1)))) {
                size_t len = strspn(num_start, "0123456789");
                char *bad_num = xstrndup(num_start, len);
                if (operating_mode == byte_mode)
                    error(0, 0, gettext("byte offset %s is too large"), quote(bad_num));
                else
                    error(0, 0, gettext("field number %s is too large"), quote(bad_num));
                free(bad_num);
                exit(1);
            }
            fieldstr++;
        } else
            do {
                error(0, 0, (gettext("invalid byte or field list")));
                usage(1);
            } while (0);
    }


BasicTester, a patch instance with id 193:
Spawn 1 instances, now Total 234
Counter: 235
Batcher Size:44
Preprocess the following candidate with BasicTester:
Priority 7465
At location src/cut.c:363
--Src File: src/cut.c
Fragment 0:
delim = (8);
while (1)
    {
        if (*fieldstr == '-') {
            in_digits = 0;
            if (dash_found)
                do {
                    error(0, 0, (gettext("invalid byte or field list")));
                    usage(1);
                } while (0);
            dash_found = 1;
            fieldstr++;
            initial = (lhs_specified ? value : 1);
            value = 0;
        } else if (*fieldstr == ',' || ((*__ctype_b_loc())[(int)((to_uchar(*fieldstr)))] & (unsigned short)_ISblank) || *fieldstr == '\x00') {
            in_digits = 0;
            if (dash_found) {
                dash_found = 0;
                if (!lhs_specified && !rhs_specified)
                    do {
                        error(0, 0, (gettext("invalid range with no endpoint: -")));
                        usage(1);
                    } while (0);
                if (!rhs_specified) {
                    eol_range_start = initial;
                    field_found = 1;
                } else {
                    if (value < initial)
                        do {
                            error(0, 0, (gettext("invalid decreasing range")));
                            usage(1);
                        } while (0);
                    if (eol_range_start != 0) {
                        if (initial < eol_range_start) {
                            if (eol_range_start <= value) {
                                eol_range_start = initial;
                            } else {
                                do {
                                    if (initial == 0 || value == 0)
                                        do {
                                            error(0, 0, (gettext("fields and positions are numbered from 1")));
                                            usage(1);
                                        } while (0);
                                    if (n_rp >= n_rp_allocated) {
                                        (rp) = x2nrealloc(rp, &n_rp_allocated, sizeof *(rp));
                                    }
                                    rp[n_rp].lo = (initial);
                                    rp[n_rp].hi = (value);
                                    ++n_rp;
                                } while (0);
                            }
                            field_found = 1;
                        }
                    } else {
                        do {
                            if (initial == 0 || value == 0)
                                do {
                                    error(0, 0, (gettext("fields and positions are numbered from 1")));
                                    usage(1);
                                } while (0);
                            if (n_rp >= n_rp_allocated) {
                                (rp) = x2nrealloc(rp, &n_rp_allocated, sizeof *(rp));
                            }
                            rp[n_rp].lo = (initial);
                            rp[n_rp].hi = (value);
                            ++n_rp;
                        } while (0);
                        field_found = 1;
                    }
                    value = 0;
                }
            } else {
                do {
                    if (value == 0 || value == 0)
                        do {
                            error(0, 0, (gettext("fields and positions are numbered from 1")));
                            usage(1);
                        } while (0);
                    if (n_rp >= n_rp_allocated) {
                        (rp) = x2nrealloc(rp, &n_rp_allocated, sizeof *(rp));
                    }
                    rp[n_rp].lo = (value);
                    rp[n_rp].hi = (value);
                    ++n_rp;
                } while (0);
                value = 0;
                field_found = 1;
            }
            if (*fieldstr == '\x00') {
                break;
            }
            fieldstr++;
            lhs_specified = 0;
            rhs_specified = 0;
        } else if (((unsigned int)(*fieldstr) - '0' <= 9)) {
            static const char *num_start;
            if (!in_digits || !num_start)
                num_start = fieldstr;
            in_digits = 1;
            if (dash_found)
                rhs_specified = 1;
            else
                lhs_specified = 1;
            if (!((void)(&(value) == (size_t *)((void *)0)) , (((size_t)-1 / 10 < (value) || (size_t)((value) * 10 + (*fieldstr - '0')) < (value)) ? 0 : (((value) = (value) * 10 + (*fieldstr - '0')) , 1)))) {
                size_t len = strspn(num_start, "0123456789");
                char *bad_num = xstrndup(num_start, len);
                if (operating_mode == byte_mode)
                    error(0, 0, gettext("byte offset %s is too large"), quote(bad_num));
                else
                    error(0, 0, gettext("field number %s is too large"), quote(bad_num));
                free(bad_num);
                exit(1);
            }
            fieldstr++;
        } else
            do {
                error(0, 0, (gettext("invalid byte or field list")));
                usage(1);
            } while (0);
    }


BasicTester, a patch instance with id 194:
Spawn 1 instances, now Total 235
Counter: 236
Batcher Size:45
Preprocess the following candidate with BasicTester:
Priority 7465
At location src/cut.c:363
--Src File: src/cut.c
Fragment 0:
delim = (0);
while (1)
    {
        if (*fieldstr == '-') {
            in_digits = 0;
            if (dash_found)
                do {
                    error(0, 0, (gettext("invalid byte or field list")));
                    usage(1);
                } while (0);
            dash_found = 1;
            fieldstr++;
            initial = (lhs_specified ? value : 1);
            value = 0;
        } else if (*fieldstr == ',' || ((*__ctype_b_loc())[(int)((to_uchar(*fieldstr)))] & (unsigned short)_ISblank) || *fieldstr == '\x00') {
            in_digits = 0;
            if (dash_found) {
                dash_found = 0;
                if (!lhs_specified && !rhs_specified)
                    do {
                        error(0, 0, (gettext("invalid range with no endpoint: -")));
                        usage(1);
                    } while (0);
                if (!rhs_specified) {
                    eol_range_start = initial;
                    field_found = 1;
                } else {
                    if (value < initial)
                        do {
                            error(0, 0, (gettext("invalid decreasing range")));
                            usage(1);
                        } while (0);
                    if (eol_range_start != 0) {
                        if (initial < eol_range_start) {
                            if (eol_range_start <= value) {
                                eol_range_start = initial;
                            } else {
                                do {
                                    if (initial == 0 || value == 0)
                                        do {
                                            error(0, 0, (gettext("fields and positions are numbered from 1")));
                                            usage(1);
                                        } while (0);
                                    if (n_rp >= n_rp_allocated) {
                                        (rp) = x2nrealloc(rp, &n_rp_allocated, sizeof *(rp));
                                    }
                                    rp[n_rp].lo = (initial);
                                    rp[n_rp].hi = (value);
                                    ++n_rp;
                                } while (0);
                            }
                            field_found = 1;
                        }
                    } else {
                        do {
                            if (initial == 0 || value == 0)
                                do {
                                    error(0, 0, (gettext("fields and positions are numbered from 1")));
                                    usage(1);
                                } while (0);
                            if (n_rp >= n_rp_allocated) {
                                (rp) = x2nrealloc(rp, &n_rp_allocated, sizeof *(rp));
                            }
                            rp[n_rp].lo = (initial);
                            rp[n_rp].hi = (value);
                            ++n_rp;
                        } while (0);
                        field_found = 1;
                    }
                    value = 0;
                }
            } else {
                do {
                    if (value == 0 || value == 0)
                        do {
                            error(0, 0, (gettext("fields and positions are numbered from 1")));
                            usage(1);
                        } while (0);
                    if (n_rp >= n_rp_allocated) {
                        (rp) = x2nrealloc(rp, &n_rp_allocated, sizeof *(rp));
                    }
                    rp[n_rp].lo = (value);
                    rp[n_rp].hi = (value);
                    ++n_rp;
                } while (0);
                value = 0;
                field_found = 1;
            }
            if (*fieldstr == '\x00') {
                break;
            }
            fieldstr++;
            lhs_specified = 0;
            rhs_specified = 0;
        } else if (((unsigned int)(*fieldstr) - '0' <= 9)) {
            static const char *num_start;
            if (!in_digits || !num_start)
                num_start = fieldstr;
            in_digits = 1;
            if (dash_found)
                rhs_specified = 1;
            else
                lhs_specified = 1;
            if (!((void)(&(value) == (size_t *)((void *)0)) , (((size_t)-1 / 10 < (value) || (size_t)((value) * 10 + (*fieldstr - '0')) < (value)) ? 0 : (((value) = (value) * 10 + (*fieldstr - '0')) , 1)))) {
                size_t len = strspn(num_start, "0123456789");
                char *bad_num = xstrndup(num_start, len);
                if (operating_mode == byte_mode)
                    error(0, 0, gettext("byte offset %s is too large"), quote(bad_num));
                else
                    error(0, 0, gettext("field number %s is too large"), quote(bad_num));
                free(bad_num);
                exit(1);
            }
            fieldstr++;
        } else
            do {
                error(0, 0, (gettext("invalid byte or field list")));
                usage(1);
            } while (0);
    }


BasicTester, a patch instance with id 195:
Spawn 1 instances, now Total 236
Counter: 237
Batcher Size:46
Preprocess the following candidate with BasicTester:
Priority 7465
At location src/cut.c:363
--Src File: src/cut.c
Fragment 0:
delim = (1);
while (1)
    {
        if (*fieldstr == '-') {
            in_digits = 0;
            if (dash_found)
                do {
                    error(0, 0, (gettext("invalid byte or field list")));
                    usage(1);
                } while (0);
            dash_found = 1;
            fieldstr++;
            initial = (lhs_specified ? value : 1);
            value = 0;
        } else if (*fieldstr == ',' || ((*__ctype_b_loc())[(int)((to_uchar(*fieldstr)))] & (unsigned short)_ISblank) || *fieldstr == '\x00') {
            in_digits = 0;
            if (dash_found) {
                dash_found = 0;
                if (!lhs_specified && !rhs_specified)
                    do {
                        error(0, 0, (gettext("invalid range with no endpoint: -")));
                        usage(1);
                    } while (0);
                if (!rhs_specified) {
                    eol_range_start = initial;
                    field_found = 1;
                } else {
                    if (value < initial)
                        do {
                            error(0, 0, (gettext("invalid decreasing range")));
                            usage(1);
                        } while (0);
                    if (eol_range_start != 0) {
                        if (initial < eol_range_start) {
                            if (eol_range_start <= value) {
                                eol_range_start = initial;
                            } else {
                                do {
                                    if (initial == 0 || value == 0)
                                        do {
                                            error(0, 0, (gettext("fields and positions are numbered from 1")));
                                            usage(1);
                                        } while (0);
                                    if (n_rp >= n_rp_allocated) {
                                        (rp) = x2nrealloc(rp, &n_rp_allocated, sizeof *(rp));
                                    }
                                    rp[n_rp].lo = (initial);
                                    rp[n_rp].hi = (value);
                                    ++n_rp;
                                } while (0);
                            }
                            field_found = 1;
                        }
                    } else {
                        do {
                            if (initial == 0 || value == 0)
                                do {
                                    error(0, 0, (gettext("fields and positions are numbered from 1")));
                                    usage(1);
                                } while (0);
                            if (n_rp >= n_rp_allocated) {
                                (rp) = x2nrealloc(rp, &n_rp_allocated, sizeof *(rp));
                            }
                            rp[n_rp].lo = (initial);
                            rp[n_rp].hi = (value);
                            ++n_rp;
                        } while (0);
                        field_found = 1;
                    }
                    value = 0;
                }
            } else {
                do {
                    if (value == 0 || value == 0)
                        do {
                            error(0, 0, (gettext("fields and positions are numbered from 1")));
                            usage(1);
                        } while (0);
                    if (n_rp >= n_rp_allocated) {
                        (rp) = x2nrealloc(rp, &n_rp_allocated, sizeof *(rp));
                    }
                    rp[n_rp].lo = (value);
                    rp[n_rp].hi = (value);
                    ++n_rp;
                } while (0);
                value = 0;
                field_found = 1;
            }
            if (*fieldstr == '\x00') {
                break;
            }
            fieldstr++;
            lhs_specified = 0;
            rhs_specified = 0;
        } else if (((unsigned int)(*fieldstr) - '0' <= 9)) {
            static const char *num_start;
            if (!in_digits || !num_start)
                num_start = fieldstr;
            in_digits = 1;
            if (dash_found)
                rhs_specified = 1;
            else
                lhs_specified = 1;
            if (!((void)(&(value) == (size_t *)((void *)0)) , (((size_t)-1 / 10 < (value) || (size_t)((value) * 10 + (*fieldstr - '0')) < (value)) ? 0 : (((value) = (value) * 10 + (*fieldstr - '0')) , 1)))) {
                size_t len = strspn(num_start, "0123456789");
                char *bad_num = xstrndup(num_start, len);
                if (operating_mode == byte_mode)
                    error(0, 0, gettext("byte offset %s is too large"), quote(bad_num));
                else
                    error(0, 0, gettext("field number %s is too large"), quote(bad_num));
                free(bad_num);
                exit(1);
            }
            fieldstr++;
        } else
            do {
                error(0, 0, (gettext("invalid byte or field list")));
                usage(1);
            } while (0);
    }


BasicTester, a patch instance with id 196:
Spawn 1 instances, now Total 237
Counter: 238
Batcher Size:47
Preprocess the following candidate with BasicTester:
Priority 7465
At location src/cut.c:363
--Src File: src/cut.c
Fragment 0:
(*__errno_location()) = (0);
while (1)
    {
        if (*fieldstr == '-') {
            in_digits = 0;
            if (dash_found)
                do {
                    error(0, 0, (gettext("invalid byte or field list")));
                    usage(1);
                } while (0);
            dash_found = 1;
            fieldstr++;
            initial = (lhs_specified ? value : 1);
            value = 0;
        } else if (*fieldstr == ',' || ((*__ctype_b_loc())[(int)((to_uchar(*fieldstr)))] & (unsigned short)_ISblank) || *fieldstr == '\x00') {
            in_digits = 0;
            if (dash_found) {
                dash_found = 0;
                if (!lhs_specified && !rhs_specified)
                    do {
                        error(0, 0, (gettext("invalid range with no endpoint: -")));
                        usage(1);
                    } while (0);
                if (!rhs_specified) {
                    eol_range_start = initial;
                    field_found = 1;
                } else {
                    if (value < initial)
                        do {
                            error(0, 0, (gettext("invalid decreasing range")));
                            usage(1);
                        } while (0);
                    if (eol_range_start != 0) {
                        if (initial < eol_range_start) {
                            if (eol_range_start <= value) {
                                eol_range_start = initial;
                            } else {
                                do {
                                    if (initial == 0 || value == 0)
                                        do {
                                            error(0, 0, (gettext("fields and positions are numbered from 1")));
                                            usage(1);
                                        } while (0);
                                    if (n_rp >= n_rp_allocated) {
                                        (rp) = x2nrealloc(rp, &n_rp_allocated, sizeof *(rp));
                                    }
                                    rp[n_rp].lo = (initial);
                                    rp[n_rp].hi = (value);
                                    ++n_rp;
                                } while (0);
                            }
                            field_found = 1;
                        }
                    } else {
                        do {
                            if (initial == 0 || value == 0)
                                do {
                                    error(0, 0, (gettext("fields and positions are numbered from 1")));
                                    usage(1);
                                } while (0);
                            if (n_rp >= n_rp_allocated) {
                                (rp) = x2nrealloc(rp, &n_rp_allocated, sizeof *(rp));
                            }
                            rp[n_rp].lo = (initial);
                            rp[n_rp].hi = (value);
                            ++n_rp;
                        } while (0);
                        field_found = 1;
                    }
                    value = 0;
                }
            } else {
                do {
                    if (value == 0 || value == 0)
                        do {
                            error(0, 0, (gettext("fields and positions are numbered from 1")));
                            usage(1);
                        } while (0);
                    if (n_rp >= n_rp_allocated) {
                        (rp) = x2nrealloc(rp, &n_rp_allocated, sizeof *(rp));
                    }
                    rp[n_rp].lo = (value);
                    rp[n_rp].hi = (value);
                    ++n_rp;
                } while (0);
                value = 0;
                field_found = 1;
            }
            if (*fieldstr == '\x00') {
                break;
            }
            fieldstr++;
            lhs_specified = 0;
            rhs_specified = 0;
        } else if (((unsigned int)(*fieldstr) - '0' <= 9)) {
            static const char *num_start;
            if (!in_digits || !num_start)
                num_start = fieldstr;
            in_digits = 1;
            if (dash_found)
                rhs_specified = 1;
            else
                lhs_specified = 1;
            if (!((void)(&(value) == (size_t *)((void *)0)) , (((size_t)-1 / 10 < (value) || (size_t)((value) * 10 + (*fieldstr - '0')) < (value)) ? 0 : (((value) = (value) * 10 + (*fieldstr - '0')) , 1)))) {
                size_t len = strspn(num_start, "0123456789");
                char *bad_num = xstrndup(num_start, len);
                if (operating_mode == byte_mode)
                    error(0, 0, gettext("byte offset %s is too large"), quote(bad_num));
                else
                    error(0, 0, gettext("field number %s is too large"), quote(bad_num));
                free(bad_num);
                exit(1);
            }
            fieldstr++;
        } else
            do {
                error(0, 0, (gettext("invalid byte or field list")));
                usage(1);
            } while (0);
    }


BasicTester, a patch instance with id 197:
Spawn 1 instances, now Total 238
Counter: 239
Batcher Size:48
Preprocess the following candidate with BasicTester:
Priority 7465
At location src/cut.c:363
--Src File: src/cut.c
Fragment 0:
dash_found = (dash_found);
while (1)
    {
        if (*fieldstr == '-') {
            in_digits = 0;
            if (dash_found)
                do {
                    error(0, 0, (gettext("invalid byte or field list")));
                    usage(1);
                } while (0);
            dash_found = 1;
            fieldstr++;
            initial = (lhs_specified ? value : 1);
            value = 0;
        } else if (*fieldstr == ',' || ((*__ctype_b_loc())[(int)((to_uchar(*fieldstr)))] & (unsigned short)_ISblank) || *fieldstr == '\x00') {
            in_digits = 0;
            if (dash_found) {
                dash_found = 0;
                if (!lhs_specified && !rhs_specified)
                    do {
                        error(0, 0, (gettext("invalid range with no endpoint: -")));
                        usage(1);
                    } while (0);
                if (!rhs_specified) {
                    eol_range_start = initial;
                    field_found = 1;
                } else {
                    if (value < initial)
                        do {
                            error(0, 0, (gettext("invalid decreasing range")));
                            usage(1);
                        } while (0);
                    if (eol_range_start != 0) {
                        if (initial < eol_range_start) {
                            if (eol_range_start <= value) {
                                eol_range_start = initial;
                            } else {
                                do {
                                    if (initial == 0 || value == 0)
                                        do {
                                            error(0, 0, (gettext("fields and positions are numbered from 1")));
                                            usage(1);
                                        } while (0);
                                    if (n_rp >= n_rp_allocated) {
                                        (rp) = x2nrealloc(rp, &n_rp_allocated, sizeof *(rp));
                                    }
                                    rp[n_rp].lo = (initial);
                                    rp[n_rp].hi = (value);
                                    ++n_rp;
                                } while (0);
                            }
                            field_found = 1;
                        }
                    } else {
                        do {
                            if (initial == 0 || value == 0)
                                do {
                                    error(0, 0, (gettext("fields and positions are numbered from 1")));
                                    usage(1);
                                } while (0);
                            if (n_rp >= n_rp_allocated) {
                                (rp) = x2nrealloc(rp, &n_rp_allocated, sizeof *(rp));
                            }
                            rp[n_rp].lo = (initial);
                            rp[n_rp].hi = (value);
                            ++n_rp;
                        } while (0);
                        field_found = 1;
                    }
                    value = 0;
                }
            } else {
                do {
                    if (value == 0 || value == 0)
                        do {
                            error(0, 0, (gettext("fields and positions are numbered from 1")));
                            usage(1);
                        } while (0);
                    if (n_rp >= n_rp_allocated) {
                        (rp) = x2nrealloc(rp, &n_rp_allocated, sizeof *(rp));
                    }
                    rp[n_rp].lo = (value);
                    rp[n_rp].hi = (value);
                    ++n_rp;
                } while (0);
                value = 0;
                field_found = 1;
            }
            if (*fieldstr == '\x00') {
                break;
            }
            fieldstr++;
            lhs_specified = 0;
            rhs_specified = 0;
        } else if (((unsigned int)(*fieldstr) - '0' <= 9)) {
            static const char *num_start;
            if (!in_digits || !num_start)
                num_start = fieldstr;
            in_digits = 1;
            if (dash_found)
                rhs_specified = 1;
            else
                lhs_specified = 1;
            if (!((void)(&(value) == (size_t *)((void *)0)) , (((size_t)-1 / 10 < (value) || (size_t)((value) * 10 + (*fieldstr - '0')) < (value)) ? 0 : (((value) = (value) * 10 + (*fieldstr - '0')) , 1)))) {
                size_t len = strspn(num_start, "0123456789");
                char *bad_num = xstrndup(num_start, len);
                if (operating_mode == byte_mode)
                    error(0, 0, gettext("byte offset %s is too large"), quote(bad_num));
                else
                    error(0, 0, gettext("field number %s is too large"), quote(bad_num));
                free(bad_num);
                exit(1);
            }
            fieldstr++;
        } else
            do {
                error(0, 0, (gettext("invalid byte or field list")));
                usage(1);
            } while (0);
    }


BasicTester, a patch instance with id 198:
Spawn 1 instances, now Total 239
Counter: 240
Batcher Size:49
Preprocess the following candidate with BasicTester:
Priority 7465
At location src/cut.c:363
--Src File: src/cut.c
Fragment 0:
dash_found = (rhs_specified);
while (1)
    {
        if (*fieldstr == '-') {
            in_digits = 0;
            if (dash_found)
                do {
                    error(0, 0, (gettext("invalid byte or field list")));
                    usage(1);
                } while (0);
            dash_found = 1;
            fieldstr++;
            initial = (lhs_specified ? value : 1);
            value = 0;
        } else if (*fieldstr == ',' || ((*__ctype_b_loc())[(int)((to_uchar(*fieldstr)))] & (unsigned short)_ISblank) || *fieldstr == '\x00') {
            in_digits = 0;
            if (dash_found) {
                dash_found = 0;
                if (!lhs_specified && !rhs_specified)
                    do {
                        error(0, 0, (gettext("invalid range with no endpoint: -")));
                        usage(1);
                    } while (0);
                if (!rhs_specified) {
                    eol_range_start = initial;
                    field_found = 1;
                } else {
                    if (value < initial)
                        do {
                            error(0, 0, (gettext("invalid decreasing range")));
                            usage(1);
                        } while (0);
                    if (eol_range_start != 0) {
                        if (initial < eol_range_start) {
                            if (eol_range_start <= value) {
                                eol_range_start = initial;
                            } else {
                                do {
                                    if (initial == 0 || value == 0)
                                        do {
                                            error(0, 0, (gettext("fields and positions are numbered from 1")));
                                            usage(1);
                                        } while (0);
                                    if (n_rp >= n_rp_allocated) {
                                        (rp) = x2nrealloc(rp, &n_rp_allocated, sizeof *(rp));
                                    }
                                    rp[n_rp].lo = (initial);
                                    rp[n_rp].hi = (value);
                                    ++n_rp;
                                } while (0);
                            }
                            field_found = 1;
                        }
                    } else {
                        do {
                            if (initial == 0 || value == 0)
                                do {
                                    error(0, 0, (gettext("fields and positions are numbered from 1")));
                                    usage(1);
                                } while (0);
                            if (n_rp >= n_rp_allocated) {
                                (rp) = x2nrealloc(rp, &n_rp_allocated, sizeof *(rp));
                            }
                            rp[n_rp].lo = (initial);
                            rp[n_rp].hi = (value);
                            ++n_rp;
                        } while (0);
                        field_found = 1;
                    }
                    value = 0;
                }
            } else {
                do {
                    if (value == 0 || value == 0)
                        do {
                            error(0, 0, (gettext("fields and positions are numbered from 1")));
                            usage(1);
                        } while (0);
                    if (n_rp >= n_rp_allocated) {
                        (rp) = x2nrealloc(rp, &n_rp_allocated, sizeof *(rp));
                    }
                    rp[n_rp].lo = (value);
                    rp[n_rp].hi = (value);
                    ++n_rp;
                } while (0);
                value = 0;
                field_found = 1;
            }
            if (*fieldstr == '\x00') {
                break;
            }
            fieldstr++;
            lhs_specified = 0;
            rhs_specified = 0;
        } else if (((unsigned int)(*fieldstr) - '0' <= 9)) {
            static const char *num_start;
            if (!in_digits || !num_start)
                num_start = fieldstr;
            in_digits = 1;
            if (dash_found)
                rhs_specified = 1;
            else
                lhs_specified = 1;
            if (!((void)(&(value) == (size_t *)((void *)0)) , (((size_t)-1 / 10 < (value) || (size_t)((value) * 10 + (*fieldstr - '0')) < (value)) ? 0 : (((value) = (value) * 10 + (*fieldstr - '0')) , 1)))) {
                size_t len = strspn(num_start, "0123456789");
                char *bad_num = xstrndup(num_start, len);
                if (operating_mode == byte_mode)
                    error(0, 0, gettext("byte offset %s is too large"), quote(bad_num));
                else
                    error(0, 0, gettext("field number %s is too large"), quote(bad_num));
                free(bad_num);
                exit(1);
            }
            fieldstr++;
        } else
            do {
                error(0, 0, (gettext("invalid byte or field list")));
                usage(1);
            } while (0);
    }


BasicTester, a patch instance with id 199:
Spawn 1 instances, now Total 240
Counter: 241
Batcher Size:50
Preprocess the following candidate with BasicTester:
Priority 7465
At location src/cut.c:363
--Src File: src/cut.c
Fragment 0:
dash_found = 1;
while (1)
    {
        if (*fieldstr == '-') {
            in_digits = 0;
            if (dash_found)
                do {
                    error(0, 0, (gettext("invalid byte or field list")));
                    usage(1);
                } while (0);
            dash_found = 1;
            fieldstr++;
            initial = (lhs_specified ? value : 1);
            value = 0;
        } else if (*fieldstr == ',' || ((*__ctype_b_loc())[(int)((to_uchar(*fieldstr)))] & (unsigned short)_ISblank) || *fieldstr == '\x00') {
            in_digits = 0;
            if (dash_found) {
                dash_found = 0;
                if (!lhs_specified && !rhs_specified)
                    do {
                        error(0, 0, (gettext("invalid range with no endpoint: -")));
                        usage(1);
                    } while (0);
                if (!rhs_specified) {
                    eol_range_start = initial;
                    field_found = 1;
                } else {
                    if (value < initial)
                        do {
                            error(0, 0, (gettext("invalid decreasing range")));
                            usage(1);
                        } while (0);
                    if (eol_range_start != 0) {
                        if (initial < eol_range_start) {
                            if (eol_range_start <= value) {
                                eol_range_start = initial;
                            } else {
                                do {
                                    if (initial == 0 || value == 0)
                                        do {
                                            error(0, 0, (gettext("fields and positions are numbered from 1")));
                                            usage(1);
                                        } while (0);
                                    if (n_rp >= n_rp_allocated) {
                                        (rp) = x2nrealloc(rp, &n_rp_allocated, sizeof *(rp));
                                    }
                                    rp[n_rp].lo = (initial);
                                    rp[n_rp].hi = (value);
                                    ++n_rp;
                                } while (0);
                            }
                            field_found = 1;
                        }
                    } else {
                        do {
                            if (initial == 0 || value == 0)
                                do {
                                    error(0, 0, (gettext("fields and positions are numbered from 1")));
                                    usage(1);
                                } while (0);
                            if (n_rp >= n_rp_allocated) {
                                (rp) = x2nrealloc(rp, &n_rp_allocated, sizeof *(rp));
                            }
                            rp[n_rp].lo = (initial);
                            rp[n_rp].hi = (value);
                            ++n_rp;
                        } while (0);
                        field_found = 1;
                    }
                    value = 0;
                }
            } else {
                do {
                    if (value == 0 || value == 0)
                        do {
                            error(0, 0, (gettext("fields and positions are numbered from 1")));
                            usage(1);
                        } while (0);
                    if (n_rp >= n_rp_allocated) {
                        (rp) = x2nrealloc(rp, &n_rp_allocated, sizeof *(rp));
                    }
                    rp[n_rp].lo = (value);
                    rp[n_rp].hi = (value);
                    ++n_rp;
                } while (0);
                value = 0;
                field_found = 1;
            }
            if (*fieldstr == '\x00') {
                break;
            }
            fieldstr++;
            lhs_specified = 0;
            rhs_specified = 0;
        } else if (((unsigned int)(*fieldstr) - '0' <= 9)) {
            static const char *num_start;
            if (!in_digits || !num_start)
                num_start = fieldstr;
            in_digits = 1;
            if (dash_found)
                rhs_specified = 1;
            else
                lhs_specified = 1;
            if (!((void)(&(value) == (size_t *)((void *)0)) , (((size_t)-1 / 10 < (value) || (size_t)((value) * 10 + (*fieldstr - '0')) < (value)) ? 0 : (((value) = (value) * 10 + (*fieldstr - '0')) , 1)))) {
                size_t len = strspn(num_start, "0123456789");
                char *bad_num = xstrndup(num_start, len);
                if (operating_mode == byte_mode)
                    error(0, 0, gettext("byte offset %s is too large"), quote(bad_num));
                else
                    error(0, 0, gettext("field number %s is too large"), quote(bad_num));
                free(bad_num);
                exit(1);
            }
            fieldstr++;
        } else
            do {
                error(0, 0, (gettext("invalid byte or field list")));
                usage(1);
            } while (0);
    }


BasicTester, a patch instance with id 200:
Spawn 1 instances, now Total 241
Counter: 242
Batcher Size:51
Preprocess the following candidate with BasicTester:
Priority 7465
At location src/cut.c:363
--Src File: src/cut.c
Fragment 0:
delim = '\t';
while (1)
    {
        if (*fieldstr == '-') {
            in_digits = 0;
            if (dash_found)
                do {
                    error(0, 0, (gettext("invalid byte or field list")));
                    usage(1);
                } while (0);
            dash_found = 1;
            fieldstr++;
            initial = (lhs_specified ? value : 1);
            value = 0;
        } else if (*fieldstr == ',' || ((*__ctype_b_loc())[(int)((to_uchar(*fieldstr)))] & (unsigned short)_ISblank) || *fieldstr == '\x00') {
            in_digits = 0;
            if (dash_found) {
                dash_found = 0;
                if (!lhs_specified && !rhs_specified)
                    do {
                        error(0, 0, (gettext("invalid range with no endpoint: -")));
                        usage(1);
                    } while (0);
                if (!rhs_specified) {
                    eol_range_start = initial;
                    field_found = 1;
                } else {
                    if (value < initial)
                        do {
                            error(0, 0, (gettext("invalid decreasing range")));
                            usage(1);
                        } while (0);
                    if (eol_range_start != 0) {
                        if (initial < eol_range_start) {
                            if (eol_range_start <= value) {
                                eol_range_start = initial;
                            } else {
                                do {
                                    if (initial == 0 || value == 0)
                                        do {
                                            error(0, 0, (gettext("fields and positions are numbered from 1")));
                                            usage(1);
                                        } while (0);
                                    if (n_rp >= n_rp_allocated) {
                                        (rp) = x2nrealloc(rp, &n_rp_allocated, sizeof *(rp));
                                    }
                                    rp[n_rp].lo = (initial);
                                    rp[n_rp].hi = (value);
                                    ++n_rp;
                                } while (0);
                            }
                            field_found = 1;
                        }
                    } else {
                        do {
                            if (initial == 0 || value == 0)
                                do {
                                    error(0, 0, (gettext("fields and positions are numbered from 1")));
                                    usage(1);
                                } while (0);
                            if (n_rp >= n_rp_allocated) {
                                (rp) = x2nrealloc(rp, &n_rp_allocated, sizeof *(rp));
                            }
                            rp[n_rp].lo = (initial);
                            rp[n_rp].hi = (value);
                            ++n_rp;
                        } while (0);
                        field_found = 1;
                    }
                    value = 0;
                }
            } else {
                do {
                    if (value == 0 || value == 0)
                        do {
                            error(0, 0, (gettext("fields and positions are numbered from 1")));
                            usage(1);
                        } while (0);
                    if (n_rp >= n_rp_allocated) {
                        (rp) = x2nrealloc(rp, &n_rp_allocated, sizeof *(rp));
                    }
                    rp[n_rp].lo = (value);
                    rp[n_rp].hi = (value);
                    ++n_rp;
                } while (0);
                value = 0;
                field_found = 1;
            }
            if (*fieldstr == '\x00') {
                break;
            }
            fieldstr++;
            lhs_specified = 0;
            rhs_specified = 0;
        } else if (((unsigned int)(*fieldstr) - '0' <= 9)) {
            static const char *num_start;
            if (!in_digits || !num_start)
                num_start = fieldstr;
            in_digits = 1;
            if (dash_found)
                rhs_specified = 1;
            else
                lhs_specified = 1;
            if (!((void)(&(value) == (size_t *)((void *)0)) , (((size_t)-1 / 10 < (value) || (size_t)((value) * 10 + (*fieldstr - '0')) < (value)) ? 0 : (((value) = (value) * 10 + (*fieldstr - '0')) , 1)))) {
                size_t len = strspn(num_start, "0123456789");
                char *bad_num = xstrndup(num_start, len);
                if (operating_mode == byte_mode)
                    error(0, 0, gettext("byte offset %s is too large"), quote(bad_num));
                else
                    error(0, 0, gettext("field number %s is too large"), quote(bad_num));
                free(bad_num);
                exit(1);
            }
            fieldstr++;
        } else
            do {
                error(0, 0, (gettext("invalid byte or field list")));
                usage(1);
            } while (0);
    }


BasicTester, a patch instance with id 201:
Spawn 1 instances, now Total 242
Counter: 243
Batcher Size:52
Preprocess the following candidate with BasicTester:
Priority 7465
At location src/cut.c:363
--Src File: src/cut.c
Fragment 0:
dash_found = 0;
while (1)
    {
        if (*fieldstr == '-') {
            in_digits = 0;
            if (dash_found)
                do {
                    error(0, 0, (gettext("invalid byte or field list")));
                    usage(1);
                } while (0);
            dash_found = 1;
            fieldstr++;
            initial = (lhs_specified ? value : 1);
            value = 0;
        } else if (*fieldstr == ',' || ((*__ctype_b_loc())[(int)((to_uchar(*fieldstr)))] & (unsigned short)_ISblank) || *fieldstr == '\x00') {
            in_digits = 0;
            if (dash_found) {
                dash_found = 0;
                if (!lhs_specified && !rhs_specified)
                    do {
                        error(0, 0, (gettext("invalid range with no endpoint: -")));
                        usage(1);
                    } while (0);
                if (!rhs_specified) {
                    eol_range_start = initial;
                    field_found = 1;
                } else {
                    if (value < initial)
                        do {
                            error(0, 0, (gettext("invalid decreasing range")));
                            usage(1);
                        } while (0);
                    if (eol_range_start != 0) {
                        if (initial < eol_range_start) {
                            if (eol_range_start <= value) {
                                eol_range_start = initial;
                            } else {
                                do {
                                    if (initial == 0 || value == 0)
                                        do {
                                            error(0, 0, (gettext("fields and positions are numbered from 1")));
                                            usage(1);
                                        } while (0);
                                    if (n_rp >= n_rp_allocated) {
                                        (rp) = x2nrealloc(rp, &n_rp_allocated, sizeof *(rp));
                                    }
                                    rp[n_rp].lo = (initial);
                                    rp[n_rp].hi = (value);
                                    ++n_rp;
                                } while (0);
                            }
                            field_found = 1;
                        }
                    } else {
                        do {
                            if (initial == 0 || value == 0)
                                do {
                                    error(0, 0, (gettext("fields and positions are numbered from 1")));
                                    usage(1);
                                } while (0);
                            if (n_rp >= n_rp_allocated) {
                                (rp) = x2nrealloc(rp, &n_rp_allocated, sizeof *(rp));
                            }
                            rp[n_rp].lo = (initial);
                            rp[n_rp].hi = (value);
                            ++n_rp;
                        } while (0);
                        field_found = 1;
                    }
                    value = 0;
                }
            } else {
                do {
                    if (value == 0 || value == 0)
                        do {
                            error(0, 0, (gettext("fields and positions are numbered from 1")));
                            usage(1);
                        } while (0);
                    if (n_rp >= n_rp_allocated) {
                        (rp) = x2nrealloc(rp, &n_rp_allocated, sizeof *(rp));
                    }
                    rp[n_rp].lo = (value);
                    rp[n_rp].hi = (value);
                    ++n_rp;
                } while (0);
                value = 0;
                field_found = 1;
            }
            if (*fieldstr == '\x00') {
                break;
            }
            fieldstr++;
            lhs_specified = 0;
            rhs_specified = 0;
        } else if (((unsigned int)(*fieldstr) - '0' <= 9)) {
            static const char *num_start;
            if (!in_digits || !num_start)
                num_start = fieldstr;
            in_digits = 1;
            if (dash_found)
                rhs_specified = 1;
            else
                lhs_specified = 1;
            if (!((void)(&(value) == (size_t *)((void *)0)) , (((size_t)-1 / 10 < (value) || (size_t)((value) * 10 + (*fieldstr - '0')) < (value)) ? 0 : (((value) = (value) * 10 + (*fieldstr - '0')) , 1)))) {
                size_t len = strspn(num_start, "0123456789");
                char *bad_num = xstrndup(num_start, len);
                if (operating_mode == byte_mode)
                    error(0, 0, gettext("byte offset %s is too large"), quote(bad_num));
                else
                    error(0, 0, gettext("field number %s is too large"), quote(bad_num));
                free(bad_num);
                exit(1);
            }
            fieldstr++;
        } else
            do {
                error(0, 0, (gettext("invalid byte or field list")));
                usage(1);
            } while (0);
    }


BasicTester, a patch instance with id 202:
Spawn 1 instances, now Total 243
a batched test job starts!
Building:src at:
/home/ubuntu/spr-fast/tests/corebench/coreutils/coreutils-case-7380cf79-2e636af1/tempworkdir/srcMerged code building succ, going to invoke tester!
BasicTester, Testing instance id 193:
Running test command:
/home/ubuntu/spr-fast/tools/coreutils-test.py /home/ubuntu/spr-fast/tests/corebench/coreutils/coreutils-case-7380cf79-2e636af1/tempworkdir/src /home/ubuntu/spr-fast/tests/corebench/coreutils/coreutils-case-7380cf79-2e636af1/tempworkdir/tests /home/ubuntu/spr-fast/tests/corebench/coreutils/coreutils-case-7380cf79-2e636af1/tempworkdir 0  > __res
BasicTester, Testing instance id 194:
Running test command:
/home/ubuntu/spr-fast/tools/coreutils-test.py /home/ubuntu/spr-fast/tests/corebench/coreutils/coreutils-case-7380cf79-2e636af1/tempworkdir/src /home/ubuntu/spr-fast/tests/corebench/coreutils/coreutils-case-7380cf79-2e636af1/tempworkdir/tests /home/ubuntu/spr-fast/tests/corebench/coreutils/coreutils-case-7380cf79-2e636af1/tempworkdir 0  > __res
BasicTester, Testing instance id 195:
Running test command:
/home/ubuntu/spr-fast/tools/coreutils-test.py /home/ubuntu/spr-fast/tests/corebench/coreutils/coreutils-case-7380cf79-2e636af1/tempworkdir/src /home/ubuntu/spr-fast/tests/corebench/coreutils/coreutils-case-7380cf79-2e636af1/tempworkdir/tests /home/ubuntu/spr-fast/tests/corebench/coreutils/coreutils-case-7380cf79-2e636af1/tempworkdir 0  > __res
BasicTester, Testing instance id 196:
Running test command:
/home/ubuntu/spr-fast/tools/coreutils-test.py /home/ubuntu/spr-fast/tests/corebench/coreutils/coreutils-case-7380cf79-2e636af1/tempworkdir/src /home/ubuntu/spr-fast/tests/corebench/coreutils/coreutils-case-7380cf79-2e636af1/tempworkdir/tests /home/ubuntu/spr-fast/tests/corebench/coreutils/coreutils-case-7380cf79-2e636af1/tempworkdir 0  > __res
BasicTester, Testing instance id 197:
Running test command:
/home/ubuntu/spr-fast/tools/coreutils-test.py /home/ubuntu/spr-fast/tests/corebench/coreutils/coreutils-case-7380cf79-2e636af1/tempworkdir/src /home/ubuntu/spr-fast/tests/corebench/coreutils/coreutils-case-7380cf79-2e636af1/tempworkdir/tests /home/ubuntu/spr-fast/tests/corebench/coreutils/coreutils-case-7380cf79-2e636af1/tempworkdir 0  > __res
BasicTester, Testing instance id 198:
Running test command:
/home/ubuntu/spr-fast/tools/coreutils-test.py /home/ubuntu/spr-fast/tests/corebench/coreutils/coreutils-case-7380cf79-2e636af1/tempworkdir/src /home/ubuntu/spr-fast/tests/corebench/coreutils/coreutils-case-7380cf79-2e636af1/tempworkdir/tests /home/ubuntu/spr-fast/tests/corebench/coreutils/coreutils-case-7380cf79-2e636af1/tempworkdir 0  > __res
BasicTester, Testing instance id 199:
Running test command:
/home/ubuntu/spr-fast/tools/coreutils-test.py /home/ubuntu/spr-fast/tests/corebench/coreutils/coreutils-case-7380cf79-2e636af1/tempworkdir/src /home/ubuntu/spr-fast/tests/corebench/coreutils/coreutils-case-7380cf79-2e636af1/tempworkdir/tests /home/ubuntu/spr-fast/tests/corebench/coreutils/coreutils-case-7380cf79-2e636af1/tempworkdir 0  > __res
BasicTester, Testing instance id 200:
Running test command:
/home/ubuntu/spr-fast/tools/coreutils-test.py /home/ubuntu/spr-fast/tests/corebench/coreutils/coreutils-case-7380cf79-2e636af1/tempworkdir/src /home/ubuntu/spr-fast/tests/corebench/coreutils/coreutils-case-7380cf79-2e636af1/tempworkdir/tests /home/ubuntu/spr-fast/tests/corebench/coreutils/coreutils-case-7380cf79-2e636af1/tempworkdir 0  > __res
BasicTester, Testing instance id 201:
Running test command:
/home/ubuntu/spr-fast/tools/coreutils-test.py /home/ubuntu/spr-fast/tests/corebench/coreutils/coreutils-case-7380cf79-2e636af1/tempworkdir/src /home/ubuntu/spr-fast/tests/corebench/coreutils/coreutils-case-7380cf79-2e636af1/tempworkdir/tests /home/ubuntu/spr-fast/tests/corebench/coreutils/coreutils-case-7380cf79-2e636af1/tempworkdir 0  > __res
BasicTester, Testing instance id 202:
Running test command:
/home/ubuntu/spr-fast/tools/coreutils-test.py /home/ubuntu/spr-fast/tests/corebench/coreutils/coreutils-case-7380cf79-2e636af1/tempworkdir/src /home/ubuntu/spr-fast/tests/corebench/coreutils/coreutils-case-7380cf79-2e636af1/tempworkdir/tests /home/ubuntu/spr-fast/tests/corebench/coreutils/coreutils-case-7380cf79-2e636af1/tempworkdir 0  > __res
Counter: 244
Batcher Size:43
Preprocess the following candidate with BasicTester:
Priority 7465
At location src/cut.c:363
--Src File: src/cut.c
Fragment 0:
dash_found = (field_found);
while (1)
    {
        if (*fieldstr == '-') {
            in_digits = 0;
            if (dash_found)
                do {
                    error(0, 0, (gettext("invalid byte or field list")));
                    usage(1);
                } while (0);
            dash_found = 1;
            fieldstr++;
            initial = (lhs_specified ? value : 1);
            value = 0;
        } else if (*fieldstr == ',' || ((*__ctype_b_loc())[(int)((to_uchar(*fieldstr)))] & (unsigned short)_ISblank) || *fieldstr == '\x00') {
            in_digits = 0;
            if (dash_found) {
                dash_found = 0;
                if (!lhs_specified && !rhs_specified)
                    do {
                        error(0, 0, (gettext("invalid range with no endpoint: -")));
                        usage(1);
                    } while (0);
                if (!rhs_specified) {
                    eol_range_start = initial;
                    field_found = 1;
                } else {
                    if (value < initial)
                        do {
                            error(0, 0, (gettext("invalid decreasing range")));
                            usage(1);
                        } while (0);
                    if (eol_range_start != 0) {
                        if (initial < eol_range_start) {
                            if (eol_range_start <= value) {
                                eol_range_start = initial;
                            } else {
                                do {
                                    if (initial == 0 || value == 0)
                                        do {
                                            error(0, 0, (gettext("fields and positions are numbered from 1")));
                                            usage(1);
                                        } while (0);
                                    if (n_rp >= n_rp_allocated) {
                                        (rp) = x2nrealloc(rp, &n_rp_allocated, sizeof *(rp));
                                    }
                                    rp[n_rp].lo = (initial);
                                    rp[n_rp].hi = (value);
                                    ++n_rp;
                                } while (0);
                            }
                            field_found = 1;
                        }
                    } else {
                        do {
                            if (initial == 0 || value == 0)
                                do {
                                    error(0, 0, (gettext("fields and positions are numbered from 1")));
                                    usage(1);
                                } while (0);
                            if (n_rp >= n_rp_allocated) {
                                (rp) = x2nrealloc(rp, &n_rp_allocated, sizeof *(rp));
                            }
                            rp[n_rp].lo = (initial);
                            rp[n_rp].hi = (value);
                            ++n_rp;
                        } while (0);
                        field_found = 1;
                    }
                    value = 0;
                }
            } else {
                do {
                    if (value == 0 || value == 0)
                        do {
                            error(0, 0, (gettext("fields and positions are numbered from 1")));
                            usage(1);
                        } while (0);
                    if (n_rp >= n_rp_allocated) {
                        (rp) = x2nrealloc(rp, &n_rp_allocated, sizeof *(rp));
                    }
                    rp[n_rp].lo = (value);
                    rp[n_rp].hi = (value);
                    ++n_rp;
                } while (0);
                value = 0;
                field_found = 1;
            }
            if (*fieldstr == '\x00') {
                break;
            }
            fieldstr++;
            lhs_specified = 0;
            rhs_specified = 0;
        } else if (((unsigned int)(*fieldstr) - '0' <= 9)) {
            static const char *num_start;
            if (!in_digits || !num_start)
                num_start = fieldstr;
            in_digits = 1;
            if (dash_found)
                rhs_specified = 1;
            else
                lhs_specified = 1;
            if (!((void)(&(value) == (size_t *)((void *)0)) , (((size_t)-1 / 10 < (value) || (size_t)((value) * 10 + (*fieldstr - '0')) < (value)) ? 0 : (((value) = (value) * 10 + (*fieldstr - '0')) , 1)))) {
                size_t len = strspn(num_start, "0123456789");
                char *bad_num = xstrndup(num_start, len);
                if (operating_mode == byte_mode)
                    error(0, 0, gettext("byte offset %s is too large"), quote(bad_num));
                else
                    error(0, 0, gettext("field number %s is too large"), quote(bad_num));
                free(bad_num);
                exit(1);
            }
            fieldstr++;
        } else
            do {
                error(0, 0, (gettext("invalid byte or field list")));
                usage(1);
            } while (0);
    }


BasicTester, a patch instance with id 203:
Spawn 1 instances, now Total 244
Counter: 245
Batcher Size:44
Preprocess the following candidate with BasicTester:
Priority 7465
At location src/cut.c:363
--Src File: src/cut.c
Fragment 0:
dash_found = (in_digits);
while (1)
    {
        if (*fieldstr == '-') {
            in_digits = 0;
            if (dash_found)
                do {
                    error(0, 0, (gettext("invalid byte or field list")));
                    usage(1);
                } while (0);
            dash_found = 1;
            fieldstr++;
            initial = (lhs_specified ? value : 1);
            value = 0;
        } else if (*fieldstr == ',' || ((*__ctype_b_loc())[(int)((to_uchar(*fieldstr)))] & (unsigned short)_ISblank) || *fieldstr == '\x00') {
            in_digits = 0;
            if (dash_found) {
                dash_found = 0;
                if (!lhs_specified && !rhs_specified)
                    do {
                        error(0, 0, (gettext("invalid range with no endpoint: -")));
                        usage(1);
                    } while (0);
                if (!rhs_specified) {
                    eol_range_start = initial;
                    field_found = 1;
                } else {
                    if (value < initial)
                        do {
                            error(0, 0, (gettext("invalid decreasing range")));
                            usage(1);
                        } while (0);
                    if (eol_range_start != 0) {
                        if (initial < eol_range_start) {
                            if (eol_range_start <= value) {
                                eol_range_start = initial;
                            } else {
                                do {
                                    if (initial == 0 || value == 0)
                                        do {
                                            error(0, 0, (gettext("fields and positions are numbered from 1")));
                                            usage(1);
                                        } while (0);
                                    if (n_rp >= n_rp_allocated) {
                                        (rp) = x2nrealloc(rp, &n_rp_allocated, sizeof *(rp));
                                    }
                                    rp[n_rp].lo = (initial);
                                    rp[n_rp].hi = (value);
                                    ++n_rp;
                                } while (0);
                            }
                            field_found = 1;
                        }
                    } else {
                        do {
                            if (initial == 0 || value == 0)
                                do {
                                    error(0, 0, (gettext("fields and positions are numbered from 1")));
                                    usage(1);
                                } while (0);
                            if (n_rp >= n_rp_allocated) {
                                (rp) = x2nrealloc(rp, &n_rp_allocated, sizeof *(rp));
                            }
                            rp[n_rp].lo = (initial);
                            rp[n_rp].hi = (value);
                            ++n_rp;
                        } while (0);
                        field_found = 1;
                    }
                    value = 0;
                }
            } else {
                do {
                    if (value == 0 || value == 0)
                        do {
                            error(0, 0, (gettext("fields and positions are numbered from 1")));
                            usage(1);
                        } while (0);
                    if (n_rp >= n_rp_allocated) {
                        (rp) = x2nrealloc(rp, &n_rp_allocated, sizeof *(rp));
                    }
                    rp[n_rp].lo = (value);
                    rp[n_rp].hi = (value);
                    ++n_rp;
                } while (0);
                value = 0;
                field_found = 1;
            }
            if (*fieldstr == '\x00') {
                break;
            }
            fieldstr++;
            lhs_specified = 0;
            rhs_specified = 0;
        } else if (((unsigned int)(*fieldstr) - '0' <= 9)) {
            static const char *num_start;
            if (!in_digits || !num_start)
                num_start = fieldstr;
            in_digits = 1;
            if (dash_found)
                rhs_specified = 1;
            else
                lhs_specified = 1;
            if (!((void)(&(value) == (size_t *)((void *)0)) , (((size_t)-1 / 10 < (value) || (size_t)((value) * 10 + (*fieldstr - '0')) < (value)) ? 0 : (((value) = (value) * 10 + (*fieldstr - '0')) , 1)))) {
                size_t len = strspn(num_start, "0123456789");
                char *bad_num = xstrndup(num_start, len);
                if (operating_mode == byte_mode)
                    error(0, 0, gettext("byte offset %s is too large"), quote(bad_num));
                else
                    error(0, 0, gettext("field number %s is too large"), quote(bad_num));
                free(bad_num);
                exit(1);
            }
            fieldstr++;
        } else
            do {
                error(0, 0, (gettext("invalid byte or field list")));
                usage(1);
            } while (0);
    }


BasicTester, a patch instance with id 204:
Spawn 1 instances, now Total 245
Counter: 246
Batcher Size:45
Preprocess the following candidate with BasicTester:
Priority 7465
At location src/cut.c:363
--Src File: src/cut.c
Fragment 0:
dash_found = (lhs_specified);
while (1)
    {
        if (*fieldstr == '-') {
            in_digits = 0;
            if (dash_found)
                do {
                    error(0, 0, (gettext("invalid byte or field list")));
                    usage(1);
                } while (0);
            dash_found = 1;
            fieldstr++;
            initial = (lhs_specified ? value : 1);
            value = 0;
        } else if (*fieldstr == ',' || ((*__ctype_b_loc())[(int)((to_uchar(*fieldstr)))] & (unsigned short)_ISblank) || *fieldstr == '\x00') {
            in_digits = 0;
            if (dash_found) {
                dash_found = 0;
                if (!lhs_specified && !rhs_specified)
                    do {
                        error(0, 0, (gettext("invalid range with no endpoint: -")));
                        usage(1);
                    } while (0);
                if (!rhs_specified) {
                    eol_range_start = initial;
                    field_found = 1;
                } else {
                    if (value < initial)
                        do {
                            error(0, 0, (gettext("invalid decreasing range")));
                            usage(1);
                        } while (0);
                    if (eol_range_start != 0) {
                        if (initial < eol_range_start) {
                            if (eol_range_start <= value) {
                                eol_range_start = initial;
                            } else {
                                do {
                                    if (initial == 0 || value == 0)
                                        do {
                                            error(0, 0, (gettext("fields and positions are numbered from 1")));
                                            usage(1);
                                        } while (0);
                                    if (n_rp >= n_rp_allocated) {
                                        (rp) = x2nrealloc(rp, &n_rp_allocated, sizeof *(rp));
                                    }
                                    rp[n_rp].lo = (initial);
                                    rp[n_rp].hi = (value);
                                    ++n_rp;
                                } while (0);
                            }
                            field_found = 1;
                        }
                    } else {
                        do {
                            if (initial == 0 || value == 0)
                                do {
                                    error(0, 0, (gettext("fields and positions are numbered from 1")));
                                    usage(1);
                                } while (0);
                            if (n_rp >= n_rp_allocated) {
                                (rp) = x2nrealloc(rp, &n_rp_allocated, sizeof *(rp));
                            }
                            rp[n_rp].lo = (initial);
                            rp[n_rp].hi = (value);
                            ++n_rp;
                        } while (0);
                        field_found = 1;
                    }
                    value = 0;
                }
            } else {
                do {
                    if (value == 0 || value == 0)
                        do {
                            error(0, 0, (gettext("fields and positions are numbered from 1")));
                            usage(1);
                        } while (0);
                    if (n_rp >= n_rp_allocated) {
                        (rp) = x2nrealloc(rp, &n_rp_allocated, sizeof *(rp));
                    }
                    rp[n_rp].lo = (value);
                    rp[n_rp].hi = (value);
                    ++n_rp;
                } while (0);
                value = 0;
                field_found = 1;
            }
            if (*fieldstr == '\x00') {
                break;
            }
            fieldstr++;
            lhs_specified = 0;
            rhs_specified = 0;
        } else if (((unsigned int)(*fieldstr) - '0' <= 9)) {
            static const char *num_start;
            if (!in_digits || !num_start)
                num_start = fieldstr;
            in_digits = 1;
            if (dash_found)
                rhs_specified = 1;
            else
                lhs_specified = 1;
            if (!((void)(&(value) == (size_t *)((void *)0)) , (((size_t)-1 / 10 < (value) || (size_t)((value) * 10 + (*fieldstr - '0')) < (value)) ? 0 : (((value) = (value) * 10 + (*fieldstr - '0')) , 1)))) {
                size_t len = strspn(num_start, "0123456789");
                char *bad_num = xstrndup(num_start, len);
                if (operating_mode == byte_mode)
                    error(0, 0, gettext("byte offset %s is too large"), quote(bad_num));
                else
                    error(0, 0, gettext("field number %s is too large"), quote(bad_num));
                free(bad_num);
                exit(1);
            }
            fieldstr++;
        } else
            do {
                error(0, 0, (gettext("invalid byte or field list")));
                usage(1);
            } while (0);
    }


BasicTester, a patch instance with id 205:
Spawn 1 instances, now Total 246
Counter: 247
Batcher Size:46
Preprocess the following candidate with BasicTester:
Priority 7465
At location src/cut.c:363
--Src File: src/cut.c
Fragment 0:
(*__errno_location()) = (1);
while (1)
    {
        if (*fieldstr == '-') {
            in_digits = 0;
            if (dash_found)
                do {
                    error(0, 0, (gettext("invalid byte or field list")));
                    usage(1);
                } while (0);
            dash_found = 1;
            fieldstr++;
            initial = (lhs_specified ? value : 1);
            value = 0;
        } else if (*fieldstr == ',' || ((*__ctype_b_loc())[(int)((to_uchar(*fieldstr)))] & (unsigned short)_ISblank) || *fieldstr == '\x00') {
            in_digits = 0;
            if (dash_found) {
                dash_found = 0;
                if (!lhs_specified && !rhs_specified)
                    do {
                        error(0, 0, (gettext("invalid range with no endpoint: -")));
                        usage(1);
                    } while (0);
                if (!rhs_specified) {
                    eol_range_start = initial;
                    field_found = 1;
                } else {
                    if (value < initial)
                        do {
                            error(0, 0, (gettext("invalid decreasing range")));
                            usage(1);
                        } while (0);
                    if (eol_range_start != 0) {
                        if (initial < eol_range_start) {
                            if (eol_range_start <= value) {
                                eol_range_start = initial;
                            } else {
                                do {
                                    if (initial == 0 || value == 0)
                                        do {
                                            error(0, 0, (gettext("fields and positions are numbered from 1")));
                                            usage(1);
                                        } while (0);
                                    if (n_rp >= n_rp_allocated) {
                                        (rp) = x2nrealloc(rp, &n_rp_allocated, sizeof *(rp));
                                    }
                                    rp[n_rp].lo = (initial);
                                    rp[n_rp].hi = (value);
                                    ++n_rp;
                                } while (0);
                            }
                            field_found = 1;
                        }
                    } else {
                        do {
                            if (initial == 0 || value == 0)
                                do {
                                    error(0, 0, (gettext("fields and positions are numbered from 1")));
                                    usage(1);
                                } while (0);
                            if (n_rp >= n_rp_allocated) {
                                (rp) = x2nrealloc(rp, &n_rp_allocated, sizeof *(rp));
                            }
                            rp[n_rp].lo = (initial);
                            rp[n_rp].hi = (value);
                            ++n_rp;
                        } while (0);
                        field_found = 1;
                    }
                    value = 0;
                }
            } else {
                do {
                    if (value == 0 || value == 0)
                        do {
                            error(0, 0, (gettext("fields and positions are numbered from 1")));
                            usage(1);
                        } while (0);
                    if (n_rp >= n_rp_allocated) {
                        (rp) = x2nrealloc(rp, &n_rp_allocated, sizeof *(rp));
                    }
                    rp[n_rp].lo = (value);
                    rp[n_rp].hi = (value);
                    ++n_rp;
                } while (0);
                value = 0;
                field_found = 1;
            }
            if (*fieldstr == '\x00') {
                break;
            }
            fieldstr++;
            lhs_specified = 0;
            rhs_specified = 0;
        } else if (((unsigned int)(*fieldstr) - '0' <= 9)) {
            static const char *num_start;
            if (!in_digits || !num_start)
                num_start = fieldstr;
            in_digits = 1;
            if (dash_found)
                rhs_specified = 1;
            else
                lhs_specified = 1;
            if (!((void)(&(value) == (size_t *)((void *)0)) , (((size_t)-1 / 10 < (value) || (size_t)((value) * 10 + (*fieldstr - '0')) < (value)) ? 0 : (((value) = (value) * 10 + (*fieldstr - '0')) , 1)))) {
                size_t len = strspn(num_start, "0123456789");
                char *bad_num = xstrndup(num_start, len);
                if (operating_mode == byte_mode)
                    error(0, 0, gettext("byte offset %s is too large"), quote(bad_num));
                else
                    error(0, 0, gettext("field number %s is too large"), quote(bad_num));
                free(bad_num);
                exit(1);
            }
            fieldstr++;
        } else
            do {
                error(0, 0, (gettext("invalid byte or field list")));
                usage(1);
            } while (0);
    }


BasicTester, a patch instance with id 206:
Spawn 1 instances, now Total 247
Counter: 248
Batcher Size:47
Preprocess the following candidate with BasicTester:
Priority 7465
At location src/cut.c:363
--Src File: src/cut.c
Fragment 0:
(*__errno_location()) = (8);
while (1)
    {
        if (*fieldstr == '-') {
            in_digits = 0;
            if (dash_found)
                do {
                    error(0, 0, (gettext("invalid byte or field list")));
                    usage(1);
                } while (0);
            dash_found = 1;
            fieldstr++;
            initial = (lhs_specified ? value : 1);
            value = 0;
        } else if (*fieldstr == ',' || ((*__ctype_b_loc())[(int)((to_uchar(*fieldstr)))] & (unsigned short)_ISblank) || *fieldstr == '\x00') {
            in_digits = 0;
            if (dash_found) {
                dash_found = 0;
                if (!lhs_specified && !rhs_specified)
                    do {
                        error(0, 0, (gettext("invalid range with no endpoint: -")));
                        usage(1);
                    } while (0);
                if (!rhs_specified) {
                    eol_range_start = initial;
                    field_found = 1;
                } else {
                    if (value < initial)
                        do {
                            error(0, 0, (gettext("invalid decreasing range")));
                            usage(1);
                        } while (0);
                    if (eol_range_start != 0) {
                        if (initial < eol_range_start) {
                            if (eol_range_start <= value) {
                                eol_range_start = initial;
                            } else {
                                do {
                                    if (initial == 0 || value == 0)
                                        do {
                                            error(0, 0, (gettext("fields and positions are numbered from 1")));
                                            usage(1);
                                        } while (0);
                                    if (n_rp >= n_rp_allocated) {
                                        (rp) = x2nrealloc(rp, &n_rp_allocated, sizeof *(rp));
                                    }
                                    rp[n_rp].lo = (initial);
                                    rp[n_rp].hi = (value);
                                    ++n_rp;
                                } while (0);
                            }
                            field_found = 1;
                        }
                    } else {
                        do {
                            if (initial == 0 || value == 0)
                                do {
                                    error(0, 0, (gettext("fields and positions are numbered from 1")));
                                    usage(1);
                                } while (0);
                            if (n_rp >= n_rp_allocated) {
                                (rp) = x2nrealloc(rp, &n_rp_allocated, sizeof *(rp));
                            }
                            rp[n_rp].lo = (initial);
                            rp[n_rp].hi = (value);
                            ++n_rp;
                        } while (0);
                        field_found = 1;
                    }
                    value = 0;
                }
            } else {
                do {
                    if (value == 0 || value == 0)
                        do {
                            error(0, 0, (gettext("fields and positions are numbered from 1")));
                            usage(1);
                        } while (0);
                    if (n_rp >= n_rp_allocated) {
                        (rp) = x2nrealloc(rp, &n_rp_allocated, sizeof *(rp));
                    }
                    rp[n_rp].lo = (value);
                    rp[n_rp].hi = (value);
                    ++n_rp;
                } while (0);
                value = 0;
                field_found = 1;
            }
            if (*fieldstr == '\x00') {
                break;
            }
            fieldstr++;
            lhs_specified = 0;
            rhs_specified = 0;
        } else if (((unsigned int)(*fieldstr) - '0' <= 9)) {
            static const char *num_start;
            if (!in_digits || !num_start)
                num_start = fieldstr;
            in_digits = 1;
            if (dash_found)
                rhs_specified = 1;
            else
                lhs_specified = 1;
            if (!((void)(&(value) == (size_t *)((void *)0)) , (((size_t)-1 / 10 < (value) || (size_t)((value) * 10 + (*fieldstr - '0')) < (value)) ? 0 : (((value) = (value) * 10 + (*fieldstr - '0')) , 1)))) {
                size_t len = strspn(num_start, "0123456789");
                char *bad_num = xstrndup(num_start, len);
                if (operating_mode == byte_mode)
                    error(0, 0, gettext("byte offset %s is too large"), quote(bad_num));
                else
                    error(0, 0, gettext("field number %s is too large"), quote(bad_num));
                free(bad_num);
                exit(1);
            }
            fieldstr++;
        } else
            do {
                error(0, 0, (gettext("invalid byte or field list")));
                usage(1);
            } while (0);
    }


BasicTester, a patch instance with id 207:
Spawn 1 instances, now Total 248
Counter: 249
Batcher Size:48
Preprocess the following candidate with BasicTester:
Priority 7465
At location src/cut.c:363
--Src File: src/cut.c
Fragment 0:
(*__errno_location()) = 0;
while (1)
    {
        if (*fieldstr == '-') {
            in_digits = 0;
            if (dash_found)
                do {
                    error(0, 0, (gettext("invalid byte or field list")));
                    usage(1);
                } while (0);
            dash_found = 1;
            fieldstr++;
            initial = (lhs_specified ? value : 1);
            value = 0;
        } else if (*fieldstr == ',' || ((*__ctype_b_loc())[(int)((to_uchar(*fieldstr)))] & (unsigned short)_ISblank) || *fieldstr == '\x00') {
            in_digits = 0;
            if (dash_found) {
                dash_found = 0;
                if (!lhs_specified && !rhs_specified)
                    do {
                        error(0, 0, (gettext("invalid range with no endpoint: -")));
                        usage(1);
                    } while (0);
                if (!rhs_specified) {
                    eol_range_start = initial;
                    field_found = 1;
                } else {
                    if (value < initial)
                        do {
                            error(0, 0, (gettext("invalid decreasing range")));
                            usage(1);
                        } while (0);
                    if (eol_range_start != 0) {
                        if (initial < eol_range_start) {
                            if (eol_range_start <= value) {
                                eol_range_start = initial;
                            } else {
                                do {
                                    if (initial == 0 || value == 0)
                                        do {
                                            error(0, 0, (gettext("fields and positions are numbered from 1")));
                                            usage(1);
                                        } while (0);
                                    if (n_rp >= n_rp_allocated) {
                                        (rp) = x2nrealloc(rp, &n_rp_allocated, sizeof *(rp));
                                    }
                                    rp[n_rp].lo = (initial);
                                    rp[n_rp].hi = (value);
                                    ++n_rp;
                                } while (0);
                            }
                            field_found = 1;
                        }
                    } else {
                        do {
                            if (initial == 0 || value == 0)
                                do {
                                    error(0, 0, (gettext("fields and positions are numbered from 1")));
                                    usage(1);
                                } while (0);
                            if (n_rp >= n_rp_allocated) {
                                (rp) = x2nrealloc(rp, &n_rp_allocated, sizeof *(rp));
                            }
                            rp[n_rp].lo = (initial);
                            rp[n_rp].hi = (value);
                            ++n_rp;
                        } while (0);
                        field_found = 1;
                    }
                    value = 0;
                }
            } else {
                do {
                    if (value == 0 || value == 0)
                        do {
                            error(0, 0, (gettext("fields and positions are numbered from 1")));
                            usage(1);
                        } while (0);
                    if (n_rp >= n_rp_allocated) {
                        (rp) = x2nrealloc(rp, &n_rp_allocated, sizeof *(rp));
                    }
                    rp[n_rp].lo = (value);
                    rp[n_rp].hi = (value);
                    ++n_rp;
                } while (0);
                value = 0;
                field_found = 1;
            }
            if (*fieldstr == '\x00') {
                break;
            }
            fieldstr++;
            lhs_specified = 0;
            rhs_specified = 0;
        } else if (((unsigned int)(*fieldstr) - '0' <= 9)) {
            static const char *num_start;
            if (!in_digits || !num_start)
                num_start = fieldstr;
            in_digits = 1;
            if (dash_found)
                rhs_specified = 1;
            else
                lhs_specified = 1;
            if (!((void)(&(value) == (size_t *)((void *)0)) , (((size_t)-1 / 10 < (value) || (size_t)((value) * 10 + (*fieldstr - '0')) < (value)) ? 0 : (((value) = (value) * 10 + (*fieldstr - '0')) , 1)))) {
                size_t len = strspn(num_start, "0123456789");
                char *bad_num = xstrndup(num_start, len);
                if (operating_mode == byte_mode)
                    error(0, 0, gettext("byte offset %s is too large"), quote(bad_num));
                else
                    error(0, 0, gettext("field number %s is too large"), quote(bad_num));
                free(bad_num);
                exit(1);
            }
            fieldstr++;
        } else
            do {
                error(0, 0, (gettext("invalid byte or field list")));
                usage(1);
            } while (0);
    }


BasicTester, a patch instance with id 208:
Spawn 1 instances, now Total 249
Counter: 250
Batcher Size:49
Preprocess the following candidate with BasicTester:
Priority 7465
At location src/cut.c:363
--Src File: src/cut.c
Fragment 0:
(fieldstr)++;
while (1)
    {
        if (*fieldstr == '-') {
            in_digits = 0;
            if (dash_found)
                do {
                    error(0, 0, (gettext("invalid byte or field list")));
                    usage(1);
                } while (0);
            dash_found = 1;
            fieldstr++;
            initial = (lhs_specified ? value : 1);
            value = 0;
        } else if (*fieldstr == ',' || ((*__ctype_b_loc())[(int)((to_uchar(*fieldstr)))] & (unsigned short)_ISblank) || *fieldstr == '\x00') {
            in_digits = 0;
            if (dash_found) {
                dash_found = 0;
                if (!lhs_specified && !rhs_specified)
                    do {
                        error(0, 0, (gettext("invalid range with no endpoint: -")));
                        usage(1);
                    } while (0);
                if (!rhs_specified) {
                    eol_range_start = initial;
                    field_found = 1;
                } else {
                    if (value < initial)
                        do {
                            error(0, 0, (gettext("invalid decreasing range")));
                            usage(1);
                        } while (0);
                    if (eol_range_start != 0) {
                        if (initial < eol_range_start) {
                            if (eol_range_start <= value) {
                                eol_range_start = initial;
                            } else {
                                do {
                                    if (initial == 0 || value == 0)
                                        do {
                                            error(0, 0, (gettext("fields and positions are numbered from 1")));
                                            usage(1);
                                        } while (0);
                                    if (n_rp >= n_rp_allocated) {
                                        (rp) = x2nrealloc(rp, &n_rp_allocated, sizeof *(rp));
                                    }
                                    rp[n_rp].lo = (initial);
                                    rp[n_rp].hi = (value);
                                    ++n_rp;
                                } while (0);
                            }
                            field_found = 1;
                        }
                    } else {
                        do {
                            if (initial == 0 || value == 0)
                                do {
                                    error(0, 0, (gettext("fields and positions are numbered from 1")));
                                    usage(1);
                                } while (0);
                            if (n_rp >= n_rp_allocated) {
                                (rp) = x2nrealloc(rp, &n_rp_allocated, sizeof *(rp));
                            }
                            rp[n_rp].lo = (initial);
                            rp[n_rp].hi = (value);
                            ++n_rp;
                        } while (0);
                        field_found = 1;
                    }
                    value = 0;
                }
            } else {
                do {
                    if (value == 0 || value == 0)
                        do {
                            error(0, 0, (gettext("fields and positions are numbered from 1")));
                            usage(1);
                        } while (0);
                    if (n_rp >= n_rp_allocated) {
                        (rp) = x2nrealloc(rp, &n_rp_allocated, sizeof *(rp));
                    }
                    rp[n_rp].lo = (value);
                    rp[n_rp].hi = (value);
                    ++n_rp;
                } while (0);
                value = 0;
                field_found = 1;
            }
            if (*fieldstr == '\x00') {
                break;
            }
            fieldstr++;
            lhs_specified = 0;
            rhs_specified = 0;
        } else if (((unsigned int)(*fieldstr) - '0' <= 9)) {
            static const char *num_start;
            if (!in_digits || !num_start)
                num_start = fieldstr;
            in_digits = 1;
            if (dash_found)
                rhs_specified = 1;
            else
                lhs_specified = 1;
            if (!((void)(&(value) == (size_t *)((void *)0)) , (((size_t)-1 / 10 < (value) || (size_t)((value) * 10 + (*fieldstr - '0')) < (value)) ? 0 : (((value) = (value) * 10 + (*fieldstr - '0')) , 1)))) {
                size_t len = strspn(num_start, "0123456789");
                char *bad_num = xstrndup(num_start, len);
                if (operating_mode == byte_mode)
                    error(0, 0, gettext("byte offset %s is too large"), quote(bad_num));
                else
                    error(0, 0, gettext("field number %s is too large"), quote(bad_num));
                free(bad_num);
                exit(1);
            }
            fieldstr++;
        } else
            do {
                error(0, 0, (gettext("invalid byte or field list")));
                usage(1);
            } while (0);
    }


BasicTester, a patch instance with id 209:
Spawn 1 instances, now Total 250
Counter: 251
Batcher Size:50
Preprocess the following candidate with BasicTester:
Priority 7465
At location src/cut.c:363
--Src File: src/cut.c
Fragment 0:
(*__errno_location()) = (9);
while (1)
    {
        if (*fieldstr == '-') {
            in_digits = 0;
            if (dash_found)
                do {
                    error(0, 0, (gettext("invalid byte or field list")));
                    usage(1);
                } while (0);
            dash_found = 1;
            fieldstr++;
            initial = (lhs_specified ? value : 1);
            value = 0;
        } else if (*fieldstr == ',' || ((*__ctype_b_loc())[(int)((to_uchar(*fieldstr)))] & (unsigned short)_ISblank) || *fieldstr == '\x00') {
            in_digits = 0;
            if (dash_found) {
                dash_found = 0;
                if (!lhs_specified && !rhs_specified)
                    do {
                        error(0, 0, (gettext("invalid range with no endpoint: -")));
                        usage(1);
                    } while (0);
                if (!rhs_specified) {
                    eol_range_start = initial;
                    field_found = 1;
                } else {
                    if (value < initial)
                        do {
                            error(0, 0, (gettext("invalid decreasing range")));
                            usage(1);
                        } while (0);
                    if (eol_range_start != 0) {
                        if (initial < eol_range_start) {
                            if (eol_range_start <= value) {
                                eol_range_start = initial;
                            } else {
                                do {
                                    if (initial == 0 || value == 0)
                                        do {
                                            error(0, 0, (gettext("fields and positions are numbered from 1")));
                                            usage(1);
                                        } while (0);
                                    if (n_rp >= n_rp_allocated) {
                                        (rp) = x2nrealloc(rp, &n_rp_allocated, sizeof *(rp));
                                    }
                                    rp[n_rp].lo = (initial);
                                    rp[n_rp].hi = (value);
                                    ++n_rp;
                                } while (0);
                            }
                            field_found = 1;
                        }
                    } else {
                        do {
                            if (initial == 0 || value == 0)
                                do {
                                    error(0, 0, (gettext("fields and positions are numbered from 1")));
                                    usage(1);
                                } while (0);
                            if (n_rp >= n_rp_allocated) {
                                (rp) = x2nrealloc(rp, &n_rp_allocated, sizeof *(rp));
                            }
                            rp[n_rp].lo = (initial);
                            rp[n_rp].hi = (value);
                            ++n_rp;
                        } while (0);
                        field_found = 1;
                    }
                    value = 0;
                }
            } else {
                do {
                    if (value == 0 || value == 0)
                        do {
                            error(0, 0, (gettext("fields and positions are numbered from 1")));
                            usage(1);
                        } while (0);
                    if (n_rp >= n_rp_allocated) {
                        (rp) = x2nrealloc(rp, &n_rp_allocated, sizeof *(rp));
                    }
                    rp[n_rp].lo = (value);
                    rp[n_rp].hi = (value);
                    ++n_rp;
                } while (0);
                value = 0;
                field_found = 1;
            }
            if (*fieldstr == '\x00') {
                break;
            }
            fieldstr++;
            lhs_specified = 0;
            rhs_specified = 0;
        } else if (((unsigned int)(*fieldstr) - '0' <= 9)) {
            static const char *num_start;
            if (!in_digits || !num_start)
                num_start = fieldstr;
            in_digits = 1;
            if (dash_found)
                rhs_specified = 1;
            else
                lhs_specified = 1;
            if (!((void)(&(value) == (size_t *)((void *)0)) , (((size_t)-1 / 10 < (value) || (size_t)((value) * 10 + (*fieldstr - '0')) < (value)) ? 0 : (((value) = (value) * 10 + (*fieldstr - '0')) , 1)))) {
                size_t len = strspn(num_start, "0123456789");
                char *bad_num = xstrndup(num_start, len);
                if (operating_mode == byte_mode)
                    error(0, 0, gettext("byte offset %s is too large"), quote(bad_num));
                else
                    error(0, 0, gettext("field number %s is too large"), quote(bad_num));
                free(bad_num);
                exit(1);
            }
            fieldstr++;
        } else
            do {
                error(0, 0, (gettext("invalid byte or field list")));
                usage(1);
            } while (0);
    }


BasicTester, a patch instance with id 210:
Spawn 1 instances, now Total 251
Counter: 252
Batcher Size:51
Preprocess the following candidate with BasicTester:
Priority 7465
At location src/cut.c:363
--Src File: src/cut.c
Fragment 0:
(*__errno_location()) = (10);
while (1)
    {
        if (*fieldstr == '-') {
            in_digits = 0;
            if (dash_found)
                do {
                    error(0, 0, (gettext("invalid byte or field list")));
                    usage(1);
                } while (0);
            dash_found = 1;
            fieldstr++;
            initial = (lhs_specified ? value : 1);
            value = 0;
        } else if (*fieldstr == ',' || ((*__ctype_b_loc())[(int)((to_uchar(*fieldstr)))] & (unsigned short)_ISblank) || *fieldstr == '\x00') {
            in_digits = 0;
            if (dash_found) {
                dash_found = 0;
                if (!lhs_specified && !rhs_specified)
                    do {
                        error(0, 0, (gettext("invalid range with no endpoint: -")));
                        usage(1);
                    } while (0);
                if (!rhs_specified) {
                    eol_range_start = initial;
                    field_found = 1;
                } else {
                    if (value < initial)
                        do {
                            error(0, 0, (gettext("invalid decreasing range")));
                            usage(1);
                        } while (0);
                    if (eol_range_start != 0) {
                        if (initial < eol_range_start) {
                            if (eol_range_start <= value) {
                                eol_range_start = initial;
                            } else {
                                do {
                                    if (initial == 0 || value == 0)
                                        do {
                                            error(0, 0, (gettext("fields and positions are numbered from 1")));
                                            usage(1);
                                        } while (0);
                                    if (n_rp >= n_rp_allocated) {
                                        (rp) = x2nrealloc(rp, &n_rp_allocated, sizeof *(rp));
                                    }
                                    rp[n_rp].lo = (initial);
                                    rp[n_rp].hi = (value);
                                    ++n_rp;
                                } while (0);
                            }
                            field_found = 1;
                        }
                    } else {
                        do {
                            if (initial == 0 || value == 0)
                                do {
                                    error(0, 0, (gettext("fields and positions are numbered from 1")));
                                    usage(1);
                                } while (0);
                            if (n_rp >= n_rp_allocated) {
                                (rp) = x2nrealloc(rp, &n_rp_allocated, sizeof *(rp));
                            }
                            rp[n_rp].lo = (initial);
                            rp[n_rp].hi = (value);
                            ++n_rp;
                        } while (0);
                        field_found = 1;
                    }
                    value = 0;
                }
            } else {
                do {
                    if (value == 0 || value == 0)
                        do {
                            error(0, 0, (gettext("fields and positions are numbered from 1")));
                            usage(1);
                        } while (0);
                    if (n_rp >= n_rp_allocated) {
                        (rp) = x2nrealloc(rp, &n_rp_allocated, sizeof *(rp));
                    }
                    rp[n_rp].lo = (value);
                    rp[n_rp].hi = (value);
                    ++n_rp;
                } while (0);
                value = 0;
                field_found = 1;
            }
            if (*fieldstr == '\x00') {
                break;
            }
            fieldstr++;
            lhs_specified = 0;
            rhs_specified = 0;
        } else if (((unsigned int)(*fieldstr) - '0' <= 9)) {
            static const char *num_start;
            if (!in_digits || !num_start)
                num_start = fieldstr;
            in_digits = 1;
            if (dash_found)
                rhs_specified = 1;
            else
                lhs_specified = 1;
            if (!((void)(&(value) == (size_t *)((void *)0)) , (((size_t)-1 / 10 < (value) || (size_t)((value) * 10 + (*fieldstr - '0')) < (value)) ? 0 : (((value) = (value) * 10 + (*fieldstr - '0')) , 1)))) {
                size_t len = strspn(num_start, "0123456789");
                char *bad_num = xstrndup(num_start, len);
                if (operating_mode == byte_mode)
                    error(0, 0, gettext("byte offset %s is too large"), quote(bad_num));
                else
                    error(0, 0, gettext("field number %s is too large"), quote(bad_num));
                free(bad_num);
                exit(1);
            }
            fieldstr++;
        } else
            do {
                error(0, 0, (gettext("invalid byte or field list")));
                usage(1);
            } while (0);
    }


BasicTester, a patch instance with id 211:
Spawn 1 instances, now Total 252
Counter: 253
Batcher Size:52
Preprocess the following candidate with BasicTester:
Priority 7430
At location src/cut.c:363
--Src File: src/cut.c
Fragment 0:
(*__errno_location()) = (-1);
while (1)
    {
        if (*fieldstr == '-') {
            in_digits = 0;
            if (dash_found)
                do {
                    error(0, 0, (gettext("invalid byte or field list")));
                    usage(1);
                } while (0);
            dash_found = 1;
            fieldstr++;
            initial = (lhs_specified ? value : 1);
            value = 0;
        } else if (*fieldstr == ',' || ((*__ctype_b_loc())[(int)((to_uchar(*fieldstr)))] & (unsigned short)_ISblank) || *fieldstr == '\x00') {
            in_digits = 0;
            if (dash_found) {
                dash_found = 0;
                if (!lhs_specified && !rhs_specified)
                    do {
                        error(0, 0, (gettext("invalid range with no endpoint: -")));
                        usage(1);
                    } while (0);
                if (!rhs_specified) {
                    eol_range_start = initial;
                    field_found = 1;
                } else {
                    if (value < initial)
                        do {
                            error(0, 0, (gettext("invalid decreasing range")));
                            usage(1);
                        } while (0);
                    if (eol_range_start != 0) {
                        if (initial < eol_range_start) {
                            if (eol_range_start <= value) {
                                eol_range_start = initial;
                            } else {
                                do {
                                    if (initial == 0 || value == 0)
                                        do {
                                            error(0, 0, (gettext("fields and positions are numbered from 1")));
                                            usage(1);
                                        } while (0);
                                    if (n_rp >= n_rp_allocated) {
                                        (rp) = x2nrealloc(rp, &n_rp_allocated, sizeof *(rp));
                                    }
                                    rp[n_rp].lo = (initial);
                                    rp[n_rp].hi = (value);
                                    ++n_rp;
                                } while (0);
                            }
                            field_found = 1;
                        }
                    } else {
                        do {
                            if (initial == 0 || value == 0)
                                do {
                                    error(0, 0, (gettext("fields and positions are numbered from 1")));
                                    usage(1);
                                } while (0);
                            if (n_rp >= n_rp_allocated) {
                                (rp) = x2nrealloc(rp, &n_rp_allocated, sizeof *(rp));
                            }
                            rp[n_rp].lo = (initial);
                            rp[n_rp].hi = (value);
                            ++n_rp;
                        } while (0);
                        field_found = 1;
                    }
                    value = 0;
                }
            } else {
                do {
                    if (value == 0 || value == 0)
                        do {
                            error(0, 0, (gettext("fields and positions are numbered from 1")));
                            usage(1);
                        } while (0);
                    if (n_rp >= n_rp_allocated) {
                        (rp) = x2nrealloc(rp, &n_rp_allocated, sizeof *(rp));
                    }
                    rp[n_rp].lo = (value);
                    rp[n_rp].hi = (value);
                    ++n_rp;
                } while (0);
                value = 0;
                field_found = 1;
            }
            if (*fieldstr == '\x00') {
                break;
            }
            fieldstr++;
            lhs_specified = 0;
            rhs_specified = 0;
        } else if (((unsigned int)(*fieldstr) - '0' <= 9)) {
            static const char *num_start;
            if (!in_digits || !num_start)
                num_start = fieldstr;
            in_digits = 1;
            if (dash_found)
                rhs_specified = 1;
            else
                lhs_specified = 1;
            if (!((void)(&(value) == (size_t *)((void *)0)) , (((size_t)-1 / 10 < (value) || (size_t)((value) * 10 + (*fieldstr - '0')) < (value)) ? 0 : (((value) = (value) * 10 + (*fieldstr - '0')) , 1)))) {
                size_t len = strspn(num_start, "0123456789");
                char *bad_num = xstrndup(num_start, len);
                if (operating_mode == byte_mode)
                    error(0, 0, gettext("byte offset %s is too large"), quote(bad_num));
                else
                    error(0, 0, gettext("field number %s is too large"), quote(bad_num));
                free(bad_num);
                exit(1);
            }
            fieldstr++;
        } else
            do {
                error(0, 0, (gettext("invalid byte or field list")));
                usage(1);
            } while (0);
    }


BasicTester, a patch instance with id 212:
Spawn 1 instances, now Total 253
a batched test job starts!
Building:src at:
/home/ubuntu/spr-fast/tests/corebench/coreutils/coreutils-case-7380cf79-2e636af1/tempworkdir/srcMerged code building succ, going to invoke tester!
BasicTester, Testing instance id 203:
Running test command:
/home/ubuntu/spr-fast/tools/coreutils-test.py /home/ubuntu/spr-fast/tests/corebench/coreutils/coreutils-case-7380cf79-2e636af1/tempworkdir/src /home/ubuntu/spr-fast/tests/corebench/coreutils/coreutils-case-7380cf79-2e636af1/tempworkdir/tests /home/ubuntu/spr-fast/tests/corebench/coreutils/coreutils-case-7380cf79-2e636af1/tempworkdir 0  > __res
BasicTester, Testing instance id 204:
Running test command:
/home/ubuntu/spr-fast/tools/coreutils-test.py /home/ubuntu/spr-fast/tests/corebench/coreutils/coreutils-case-7380cf79-2e636af1/tempworkdir/src /home/ubuntu/spr-fast/tests/corebench/coreutils/coreutils-case-7380cf79-2e636af1/tempworkdir/tests /home/ubuntu/spr-fast/tests/corebench/coreutils/coreutils-case-7380cf79-2e636af1/tempworkdir 0  > __res
BasicTester, Testing instance id 205:
Running test command:
/home/ubuntu/spr-fast/tools/coreutils-test.py /home/ubuntu/spr-fast/tests/corebench/coreutils/coreutils-case-7380cf79-2e636af1/tempworkdir/src /home/ubuntu/spr-fast/tests/corebench/coreutils/coreutils-case-7380cf79-2e636af1/tempworkdir/tests /home/ubuntu/spr-fast/tests/corebench/coreutils/coreutils-case-7380cf79-2e636af1/tempworkdir 0  > __res
BasicTester, Testing instance id 206:
Running test command:
/home/ubuntu/spr-fast/tools/coreutils-test.py /home/ubuntu/spr-fast/tests/corebench/coreutils/coreutils-case-7380cf79-2e636af1/tempworkdir/src /home/ubuntu/spr-fast/tests/corebench/coreutils/coreutils-case-7380cf79-2e636af1/tempworkdir/tests /home/ubuntu/spr-fast/tests/corebench/coreutils/coreutils-case-7380cf79-2e636af1/tempworkdir 0  > __res
BasicTester, Testing instance id 207:
Running test command:
/home/ubuntu/spr-fast/tools/coreutils-test.py /home/ubuntu/spr-fast/tests/corebench/coreutils/coreutils-case-7380cf79-2e636af1/tempworkdir/src /home/ubuntu/spr-fast/tests/corebench/coreutils/coreutils-case-7380cf79-2e636af1/tempworkdir/tests /home/ubuntu/spr-fast/tests/corebench/coreutils/coreutils-case-7380cf79-2e636af1/tempworkdir 0  > __res
BasicTester, Testing instance id 208:
Running test command:
/home/ubuntu/spr-fast/tools/coreutils-test.py /home/ubuntu/spr-fast/tests/corebench/coreutils/coreutils-case-7380cf79-2e636af1/tempworkdir/src /home/ubuntu/spr-fast/tests/corebench/coreutils/coreutils-case-7380cf79-2e636af1/tempworkdir/tests /home/ubuntu/spr-fast/tests/corebench/coreutils/coreutils-case-7380cf79-2e636af1/tempworkdir 0  > __res
BasicTester, Testing instance id 209:
Running test command:
/home/ubuntu/spr-fast/tools/coreutils-test.py /home/ubuntu/spr-fast/tests/corebench/coreutils/coreutils-case-7380cf79-2e636af1/tempworkdir/src /home/ubuntu/spr-fast/tests/corebench/coreutils/coreutils-case-7380cf79-2e636af1/tempworkdir/tests /home/ubuntu/spr-fast/tests/corebench/coreutils/coreutils-case-7380cf79-2e636af1/tempworkdir 0  > __res
BasicTester, Testing instance id 210:
Running test command:
/home/ubuntu/spr-fast/tools/coreutils-test.py /home/ubuntu/spr-fast/tests/corebench/coreutils/coreutils-case-7380cf79-2e636af1/tempworkdir/src /home/ubuntu/spr-fast/tests/corebench/coreutils/coreutils-case-7380cf79-2e636af1/tempworkdir/tests /home/ubuntu/spr-fast/tests/corebench/coreutils/coreutils-case-7380cf79-2e636af1/tempworkdir 0  > __res
BasicTester, Testing instance id 211:
Running test command:
/home/ubuntu/spr-fast/tools/coreutils-test.py /home/ubuntu/spr-fast/tests/corebench/coreutils/coreutils-case-7380cf79-2e636af1/tempworkdir/src /home/ubuntu/spr-fast/tests/corebench/coreutils/coreutils-case-7380cf79-2e636af1/tempworkdir/tests /home/ubuntu/spr-fast/tests/corebench/coreutils/coreutils-case-7380cf79-2e636af1/tempworkdir 0  > __res
BasicTester, Testing instance id 212:
Running test command:
/home/ubuntu/spr-fast/tools/coreutils-test.py /home/ubuntu/spr-fast/tests/corebench/coreutils/coreutils-case-7380cf79-2e636af1/tempworkdir/src /home/ubuntu/spr-fast/tests/corebench/coreutils/coreutils-case-7380cf79-2e636af1/tempworkdir/tests /home/ubuntu/spr-fast/tests/corebench/coreutils/coreutils-case-7380cf79-2e636af1/tempworkdir 0  > __res
Counter: 254
Batcher Size:43
Preprocess the following candidate with CondTester:
Priority 5000
At location src/cut.c:269
--Src File: src/cut.c
Fragment 0:
if (!(__abst_hole(i, n, printable_field)))
    return (printable_field[n] >> (i % 8)) & 1;


CondTester, a patch instance with id 40:
Spawn 1 instances, now Total 254
Counter: 255
Batcher Size:44
Preprocess the following candidate with CondTester:
Priority 4998
At location src/cut.c:526
--Src File: src/cut.c
Fragment 0:
if (!(__abst_hole(output_delimiter_specified, complement, eol_range_start, rp, i, field_found, n_rp, max_range_endpoint, printable_field, fieldstr, operating_mode, value, lhs_specified, rhs_specified, dash_found, in_digits, n_rp_allocated, initial)))
    if (output_delimiter_specified && !complement && eol_range_start && !is_printable_field(eol_range_start))
        mark_range_start(eol_range_start);


CondTester, a patch instance with id 41:
Spawn 1 instances, now Total 255
Counter: 256
Batcher Size:45
Preprocess the following candidate with CondTester:
Priority 4998
At location src/cut.c:526
--Src File: src/cut.c
Fragment 0:
if (!(__abst_hole(output_delimiter_specified, complement, eol_range_start, rp, i, field_found, n_rp, max_range_endpoint, printable_field, fieldstr, operating_mode, value, lhs_specified, rhs_specified, dash_found, in_digits, n_rp_allocated, initial)) && (output_delimiter_specified && !complement && eol_range_start && !is_printable_field(eol_range_start)))
    mark_range_start(eol_range_start);


CondTester, a patch instance with id 42:
Spawn 1 instances, now Total 256
Counter: 257
Batcher Size:46
Preprocess the following candidate with CondTester:
Priority 4997
At location src/cut.c:510
--Src File: src/cut.c
Fragment 0:
if (!(__abst_hole(n_rp, i, rp, max_range_endpoint, printable_field, complement, output_delimiter_specified, eol_range_start, fieldstr, field_found, operating_mode, value, lhs_specified, rhs_specified, dash_found, in_digits, n_rp_allocated, initial)))
    for (i = 0; i < n_rp; i++) {
        size_t j;
        size_t rsi_candidate;
        rsi_candidate = complement ? rp[i].hi + 1 : rp[i].lo;
        if (output_delimiter_specified && !is_printable_field(rsi_candidate))
            mark_range_start(rsi_candidate);
        for (j = rp[i].lo; j <= rp[i].hi; j++) 
            mark_printable_field(j);
    }


CondTester, a patch instance with id 43:
Spawn 1 instances, now Total 257
Counter: 258
Batcher Size:47
Preprocess the following candidate with BasicTester:
Priority 4997
At location src/cut.c:510
--Src File: src/cut.c
Fragment 0:
memset(&rp[i], 0, sizeof (*(&rp[i])));
for (i = 0; i < n_rp; i++) {
    size_t j;
    size_t rsi_candidate;
    rsi_candidate = complement ? rp[i].hi + 1 : rp[i].lo;
    if (output_delimiter_specified && !is_printable_field(rsi_candidate))
        mark_range_start(rsi_candidate);
    for (j = rp[i].lo; j <= rp[i].hi; j++) 
        mark_printable_field(j);
}


BasicTester, a patch instance with id 213:
Spawn 1 instances, now Total 258
Counter: 259
Batcher Size:48
Preprocess the following candidate with BasicTester:
Priority 4996
At location src/cut.c:507
--Src File: src/cut.c
Fragment 0:
printf(rp, n_rp, sizeof (rp[0]), compare_ranges);


BasicTester, a patch instance with id 214:
Spawn 1 instances, now Total 259
Counter: 260
Batcher Size:49
Preprocess the following candidate with BasicTester:
Priority 4996
At location src/cut.c:507
--Src File: src/cut.c
Fragment 0:
fread(rp, n_rp, sizeof (rp[0]), compare_ranges);


BasicTester, a patch instance with id 215:
Spawn 1 instances, now Total 260
Counter: 261
Batcher Size:50
Preprocess the following candidate with BasicTester:
Priority 4996
At location src/cut.c:507
--Src File: src/cut.c
Fragment 0:
fread_unlocked(rp, n_rp, sizeof (rp[0]), compare_ranges);


BasicTester, a patch instance with id 216:
Spawn 1 instances, now Total 261
Counter: 262
Batcher Size:51
Preprocess the following candidate with CondTester:
Priority 4996
At location src/cut.c:507
--Src File: src/cut.c
Fragment 0:
if (!(__abst_hole(rp, n_rp, max_range_endpoint, printable_field, i, complement, output_delimiter_specified, fieldstr, eol_range_start, field_found, operating_mode, value, lhs_specified, rhs_specified, dash_found, in_digits, n_rp_allocated, initial)))
    qsort(rp, n_rp, sizeof (rp[0]), compare_ranges);


CondTester, a patch instance with id 44:
Spawn 1 instances, now Total 262
Counter: 263
Batcher Size:52
Preprocess the following candidate with BasicTester:
Priority 4996
At location src/cut.c:507
--Src File: src/cut.c
Fragment 0:
printf(rp, n_rp, sizeof (rp[0]), compare_ranges);


BasicTester, a patch instance with id 217:
Spawn 1 instances, now Total 263
Counter: 264
Batcher Size:53
Preprocess the following candidate with BasicTester:
Priority 4996
At location src/cut.c:507
--Src File: src/cut.c
Fragment 0:
scanf(rp, n_rp, sizeof (rp[0]), compare_ranges);


BasicTester, a patch instance with id 218:
Spawn 1 instances, now Total 264
Counter: 265
Batcher Size:54
Preprocess the following candidate with BasicTester:
Priority 4996
At location src/cut.c:507
--Src File: src/cut.c
Fragment 0:
scanf(rp, n_rp, sizeof (rp[0]), compare_ranges);


BasicTester, a patch instance with id 219:
Spawn 1 instances, now Total 265
Counter: 266
Batcher Size:55
Preprocess the following candidate with BasicTester:
Priority 4996
At location src/cut.c:507
--Src File: src/cut.c
Fragment 0:
scanf(rp, n_rp, sizeof (rp[0]), compare_ranges);


BasicTester, a patch instance with id 220:
Spawn 1 instances, now Total 266
Counter: 267
Batcher Size:56
Preprocess the following candidate with CondTester:
Priority 4994
At location src/cut.c:505
--Src File: src/cut.c
Fragment 0:
if (!(__abst_hole(max_range_endpoint, printable_field, rp, n_rp, i, complement, output_delimiter_specified, fieldstr, eol_range_start, operating_mode, field_found, value, lhs_specified, rhs_specified, dash_found, in_digits, n_rp_allocated, initial)))
    printable_field = xzalloc(max_range_endpoint / 8 + 1);


CondTester, a patch instance with id 45:
Spawn 1 instances, now Total 267
Counter: 268
Batcher Size:57
Preprocess the following candidate with CondTester:
Priority 4993
At location src/cut.c:495
--Src File: src/cut.c
Fragment 0:
if (!(__abst_hole(n_rp, i, max_range_endpoint, rp, fieldstr, printable_field, operating_mode, complement, output_delimiter_specified, value, lhs_specified, rhs_specified, dash_found, in_digits, eol_range_start, field_found, n_rp_allocated, initial)))
    for (i = 0; i < n_rp; i++) {
        if (rp[i].hi > max_range_endpoint)
            max_range_endpoint = rp[i].hi;
    }


CondTester, a patch instance with id 46:
Spawn 1 instances, now Total 268
Counter: 269
Batcher Size:58
Preprocess the following candidate with BasicTester:
Priority 4993
At location src/cut.c:495
--Src File: src/cut.c
Fragment 0:
memset(&rp[i], 0, sizeof (*(&rp[i])));
for (i = 0; i < n_rp; i++) {
    if (rp[i].hi > max_range_endpoint)
        max_range_endpoint = rp[i].hi;
}


BasicTester, a patch instance with id 221:
Spawn 1 instances, now Total 269
Counter: 270
Batcher Size:59
Preprocess the following candidate with CondTester:
Priority 4992
At location src/cut.c:494
--Src File: src/cut.c
Fragment 0:
if (!(__abst_hole(max_range_endpoint, n_rp, i, rp, fieldstr, printable_field, operating_mode, value, complement, output_delimiter_specified, lhs_specified, rhs_specified, dash_found, in_digits, eol_range_start, field_found, n_rp_allocated, initial)))
    max_range_endpoint = 0;


CondTester, a patch instance with id 47:
Spawn 1 instances, now Total 270
Counter: 271
Batcher Size:60
Preprocess the following candidate with BasicTester:
Priority 4991
At location src/cut.c:449
--Src File: src/cut.c
Fragment 0:
in_digits = 0;
break;


BasicTester, a patch instance with id 222:
Spawn 1 instances, now Total 271
Counter: 272
Batcher Size:61
Preprocess the following candidate with BasicTester:
Priority 4991
At location src/cut.c:449
--Src File: src/cut.c
Fragment 0:
qsort((rp), n_rp, sizeof (rp[0]), compare_ranges);
break;


BasicTester, a patch instance with id 223:
Spawn 1 instances, now Total 272
Counter: 273
Batcher Size:62
Preprocess the following candidate with BasicTester:
Priority 4991
At location src/cut.c:449
--Src File: src/cut.c
Fragment 0:
qsort(rp, n_rp, sizeof (rp[0]), compare_ranges);
break;


BasicTester, a patch instance with id 224:
Spawn 1 instances, now Total 273
Counter: 274
Batcher Size:63
Preprocess the following candidate with BasicTester:
Priority 4991
At location src/cut.c:449
--Src File: src/cut.c
Fragment 0:
value = (-1);
break;


BasicTester, a patch instance with id 225:
Spawn 1 instances, now Total 274
Counter: 275
Batcher Size:64
Preprocess the following candidate with BasicTester:
Priority 4991
At location src/cut.c:449
--Src File: src/cut.c
Fragment 0:
value = (n_rp);
break;


BasicTester, a patch instance with id 226:
Spawn 1 instances, now Total 275
Counter: 276
Batcher Size:65
Preprocess the following candidate with BasicTester:
Priority 4991
At location src/cut.c:449
--Src File: src/cut.c
Fragment 0:
xalloc_die();
break;


BasicTester, a patch instance with id 227:
Spawn 1 instances, now Total 276
Counter: 277
Batcher Size:66
Preprocess the following candidate with BasicTester:
Priority 4991
At location src/cut.c:449
--Src File: src/cut.c
Fragment 0:
value = (n_rp_allocated);
break;


BasicTester, a patch instance with id 228:
Spawn 1 instances, now Total 277
Counter: 278
Batcher Size:67
Preprocess the following candidate with BasicTester:
Priority 4991
At location src/cut.c:449
--Src File: src/cut.c
Fragment 0:
value = (value);
break;


BasicTester, a patch instance with id 229:
Spawn 1 instances, now Total 278
Counter: 279
Batcher Size:68
Preprocess the following candidate with BasicTester:
Priority 4991
At location src/cut.c:449
--Src File: src/cut.c
Fragment 0:
value = 0;
break;


BasicTester, a patch instance with id 230:
Spawn 1 instances, now Total 279
a batched test job starts!
Building:src at:
/home/ubuntu/spr-fast/tests/corebench/coreutils/coreutils-case-7380cf79-2e636af1/tempworkdir/srcMerged code building succ, going to invoke tester!
CondTester, Testing instance id 38:
Running test command:
/home/ubuntu/spr-fast/tools/coreutils-test.py /home/ubuntu/spr-fast/tests/corebench/coreutils/coreutils-case-7380cf79-2e636af1/tempworkdir/src /home/ubuntu/spr-fast/tests/corebench/coreutils/coreutils-case-7380cf79-2e636af1/tempworkdir/tests /home/ubuntu/spr-fast/tests/corebench/coreutils/coreutils-case-7380cf79-2e636af1/tempworkdir 0  > __res
Running test command:
/home/ubuntu/spr-fast/tools/coreutils-test.py /home/ubuntu/spr-fast/tests/corebench/coreutils/coreutils-case-7380cf79-2e636af1/tempworkdir/src /home/ubuntu/spr-fast/tests/corebench/coreutils/coreutils-case-7380cf79-2e636af1/tempworkdir/tests /home/ubuntu/spr-fast/tests/corebench/coreutils/coreutils-case-7380cf79-2e636af1/tempworkdir 0  > __res
Running test command:
/home/ubuntu/spr-fast/tools/coreutils-test.py /home/ubuntu/spr-fast/tests/corebench/coreutils/coreutils-case-7380cf79-2e636af1/tempworkdir/src /home/ubuntu/spr-fast/tests/corebench/coreutils/coreutils-case-7380cf79-2e636af1/tempworkdir/tests /home/ubuntu/spr-fast/tests/corebench/coreutils/coreutils-case-7380cf79-2e636af1/tempworkdir 0  > __res
BasicTester, Testing instance id 222:
Running test command:
/home/ubuntu/spr-fast/tools/coreutils-test.py /home/ubuntu/spr-fast/tests/corebench/coreutils/coreutils-case-7380cf79-2e636af1/tempworkdir/src /home/ubuntu/spr-fast/tests/corebench/coreutils/coreutils-case-7380cf79-2e636af1/tempworkdir/tests /home/ubuntu/spr-fast/tests/corebench/coreutils/coreutils-case-7380cf79-2e636af1/tempworkdir 0  > __res
BasicTester, Testing instance id 223:
Running test command:
/home/ubuntu/spr-fast/tools/coreutils-test.py /home/ubuntu/spr-fast/tests/corebench/coreutils/coreutils-case-7380cf79-2e636af1/tempworkdir/src /home/ubuntu/spr-fast/tests/corebench/coreutils/coreutils-case-7380cf79-2e636af1/tempworkdir/tests /home/ubuntu/spr-fast/tests/corebench/coreutils/coreutils-case-7380cf79-2e636af1/tempworkdir 0  > __res
BasicTester, Testing instance id 224:
Running test command:
/home/ubuntu/spr-fast/tools/coreutils-test.py /home/ubuntu/spr-fast/tests/corebench/coreutils/coreutils-case-7380cf79-2e636af1/tempworkdir/src /home/ubuntu/spr-fast/tests/corebench/coreutils/coreutils-case-7380cf79-2e636af1/tempworkdir/tests /home/ubuntu/spr-fast/tests/corebench/coreutils/coreutils-case-7380cf79-2e636af1/tempworkdir 0  > __res
BasicTester, Testing instance id 225:
Running test command:
/home/ubuntu/spr-fast/tools/coreutils-test.py /home/ubuntu/spr-fast/tests/corebench/coreutils/coreutils-case-7380cf79-2e636af1/tempworkdir/src /home/ubuntu/spr-fast/tests/corebench/coreutils/coreutils-case-7380cf79-2e636af1/tempworkdir/tests /home/ubuntu/spr-fast/tests/corebench/coreutils/coreutils-case-7380cf79-2e636af1/tempworkdir 0  > __res
BasicTester, Testing instance id 226:
Running test command:
/home/ubuntu/spr-fast/tools/coreutils-test.py /home/ubuntu/spr-fast/tests/corebench/coreutils/coreutils-case-7380cf79-2e636af1/tempworkdir/src /home/ubuntu/spr-fast/tests/corebench/coreutils/coreutils-case-7380cf79-2e636af1/tempworkdir/tests /home/ubuntu/spr-fast/tests/corebench/coreutils/coreutils-case-7380cf79-2e636af1/tempworkdir 0  > __res
BasicTester, Testing instance id 227:
Running test command:
/home/ubuntu/spr-fast/tools/coreutils-test.py /home/ubuntu/spr-fast/tests/corebench/coreutils/coreutils-case-7380cf79-2e636af1/tempworkdir/src /home/ubuntu/spr-fast/tests/corebench/coreutils/coreutils-case-7380cf79-2e636af1/tempworkdir/tests /home/ubuntu/spr-fast/tests/corebench/coreutils/coreutils-case-7380cf79-2e636af1/tempworkdir 0  > __res
BasicTester, Testing instance id 228:
Running test command:
/home/ubuntu/spr-fast/tools/coreutils-test.py /home/ubuntu/spr-fast/tests/corebench/coreutils/coreutils-case-7380cf79-2e636af1/tempworkdir/src /home/ubuntu/spr-fast/tests/corebench/coreutils/coreutils-case-7380cf79-2e636af1/tempworkdir/tests /home/ubuntu/spr-fast/tests/corebench/coreutils/coreutils-case-7380cf79-2e636af1/tempworkdir 0  > __res
BasicTester, Testing instance id 229:
Running test command:
/home/ubuntu/spr-fast/tools/coreutils-test.py /home/ubuntu/spr-fast/tests/corebench/coreutils/coreutils-case-7380cf79-2e636af1/tempworkdir/src /home/ubuntu/spr-fast/tests/corebench/coreutils/coreutils-case-7380cf79-2e636af1/tempworkdir/tests /home/ubuntu/spr-fast/tests/corebench/coreutils/coreutils-case-7380cf79-2e636af1/tempworkdir 0  > __res
BasicTester, Testing instance id 230:
Running test command:
/home/ubuntu/spr-fast/tools/coreutils-test.py /home/ubuntu/spr-fast/tests/corebench/coreutils/coreutils-case-7380cf79-2e636af1/tempworkdir/src /home/ubuntu/spr-fast/tests/corebench/coreutils/coreutils-case-7380cf79-2e636af1/tempworkdir/tests /home/ubuntu/spr-fast/tests/corebench/coreutils/coreutils-case-7380cf79-2e636af1/tempworkdir 0  > __res
Counter: 280
Batcher Size:59
Preprocess the following candidate with BasicTester:
Priority 4991
At location src/cut.c:449
--Src File: src/cut.c
Fragment 0:
value = (0);
break;


BasicTester, a patch instance with id 231:
Spawn 1 instances, now Total 280
Counter: 281
Batcher Size:60
Preprocess the following candidate with BasicTester:
Priority 4991
At location src/cut.c:449
--Src File: src/cut.c
Fragment 0:
value = (8);
break;


BasicTester, a patch instance with id 232:
Spawn 1 instances, now Total 281
Counter: 282
Batcher Size:61
Preprocess the following candidate with BasicTester:
Priority 4991
At location src/cut.c:449
--Src File: src/cut.c
Fragment 0:
value = (i);
break;


BasicTester, a patch instance with id 233:
Spawn 1 instances, now Total 282
Counter: 283
Batcher Size:62
Preprocess the following candidate with BasicTester:
Priority 4991
At location src/cut.c:449
--Src File: src/cut.c
Fragment 0:
value = (initial);
break;


BasicTester, a patch instance with id 234:
Spawn 1 instances, now Total 283
Counter: 284
Batcher Size:63
Preprocess the following candidate with BasicTester:
Priority 4991
At location src/cut.c:449
--Src File: src/cut.c
Fragment 0:
value = (9);
break;


BasicTester, a patch instance with id 235:
Spawn 1 instances, now Total 284
Counter: 285
Batcher Size:64
Preprocess the following candidate with BasicTester:
Priority 4991
At location src/cut.c:449
--Src File: src/cut.c
Fragment 0:
value = (1);
break;


BasicTester, a patch instance with id 236:
Spawn 1 instances, now Total 285
Counter: 286
Batcher Size:65
Preprocess the following candidate with BasicTester:
Priority 4991
At location src/cut.c:449
--Src File: src/cut.c
Fragment 0:
value = (10);
break;


BasicTester, a patch instance with id 237:
Spawn 1 instances, now Total 286
Counter: 287
Batcher Size:66
Preprocess the following candidate with BasicTester:
Priority 4991
At location src/cut.c:449
--Src File: src/cut.c
Fragment 0:
rhs_specified = (dash_found);
break;


BasicTester, a patch instance with id 238:
Spawn 1 instances, now Total 287
Counter: 288
Batcher Size:67
Preprocess the following candidate with BasicTester:
Priority 4991
At location src/cut.c:449
--Src File: src/cut.c
Fragment 0:
rhs_specified = 1;
break;


BasicTester, a patch instance with id 239:
Spawn 1 instances, now Total 288
Counter: 289
Batcher Size:68
Preprocess the following candidate with BasicTester:
Priority 4991
At location src/cut.c:449
--Src File: src/cut.c
Fragment 0:
suppress_non_delimited = (in_digits);
break;


BasicTester, a patch instance with id 240:
Spawn 1 instances, now Total 289
a batched test job starts!
Building:src at:
/home/ubuntu/spr-fast/tests/corebench/coreutils/coreutils-case-7380cf79-2e636af1/tempworkdir/srcMerged code building succ, going to invoke tester!
BasicTester, Testing instance id 231:
Running test command:
/home/ubuntu/spr-fast/tools/coreutils-test.py /home/ubuntu/spr-fast/tests/corebench/coreutils/coreutils-case-7380cf79-2e636af1/tempworkdir/src /home/ubuntu/spr-fast/tests/corebench/coreutils/coreutils-case-7380cf79-2e636af1/tempworkdir/tests /home/ubuntu/spr-fast/tests/corebench/coreutils/coreutils-case-7380cf79-2e636af1/tempworkdir 0  > __res
BasicTester, Testing instance id 232:
Running test command:
/home/ubuntu/spr-fast/tools/coreutils-test.py /home/ubuntu/spr-fast/tests/corebench/coreutils/coreutils-case-7380cf79-2e636af1/tempworkdir/src /home/ubuntu/spr-fast/tests/corebench/coreutils/coreutils-case-7380cf79-2e636af1/tempworkdir/tests /home/ubuntu/spr-fast/tests/corebench/coreutils/coreutils-case-7380cf79-2e636af1/tempworkdir 0  > __res
BasicTester, Testing instance id 233:
Running test command:
/home/ubuntu/spr-fast/tools/coreutils-test.py /home/ubuntu/spr-fast/tests/corebench/coreutils/coreutils-case-7380cf79-2e636af1/tempworkdir/src /home/ubuntu/spr-fast/tests/corebench/coreutils/coreutils-case-7380cf79-2e636af1/tempworkdir/tests /home/ubuntu/spr-fast/tests/corebench/coreutils/coreutils-case-7380cf79-2e636af1/tempworkdir 0  > __res
BasicTester, Testing instance id 234:
Running test command:
/home/ubuntu/spr-fast/tools/coreutils-test.py /home/ubuntu/spr-fast/tests/corebench/coreutils/coreutils-case-7380cf79-2e636af1/tempworkdir/src /home/ubuntu/spr-fast/tests/corebench/coreutils/coreutils-case-7380cf79-2e636af1/tempworkdir/tests /home/ubuntu/spr-fast/tests/corebench/coreutils/coreutils-case-7380cf79-2e636af1/tempworkdir 0  > __res
BasicTester, Testing instance id 235:
Running test command:
/home/ubuntu/spr-fast/tools/coreutils-test.py /home/ubuntu/spr-fast/tests/corebench/coreutils/coreutils-case-7380cf79-2e636af1/tempworkdir/src /home/ubuntu/spr-fast/tests/corebench/coreutils/coreutils-case-7380cf79-2e636af1/tempworkdir/tests /home/ubuntu/spr-fast/tests/corebench/coreutils/coreutils-case-7380cf79-2e636af1/tempworkdir 0  > __res
BasicTester, Testing instance id 236:
Running test command:
/home/ubuntu/spr-fast/tools/coreutils-test.py /home/ubuntu/spr-fast/tests/corebench/coreutils/coreutils-case-7380cf79-2e636af1/tempworkdir/src /home/ubuntu/spr-fast/tests/corebench/coreutils/coreutils-case-7380cf79-2e636af1/tempworkdir/tests /home/ubuntu/spr-fast/tests/corebench/coreutils/coreutils-case-7380cf79-2e636af1/tempworkdir 0  > __res
BasicTester, Testing instance id 237:
Running test command:
/home/ubuntu/spr-fast/tools/coreutils-test.py /home/ubuntu/spr-fast/tests/corebench/coreutils/coreutils-case-7380cf79-2e636af1/tempworkdir/src /home/ubuntu/spr-fast/tests/corebench/coreutils/coreutils-case-7380cf79-2e636af1/tempworkdir/tests /home/ubuntu/spr-fast/tests/corebench/coreutils/coreutils-case-7380cf79-2e636af1/tempworkdir 0  > __res
BasicTester, Testing instance id 238:
Running test command:
/home/ubuntu/spr-fast/tools/coreutils-test.py /home/ubuntu/spr-fast/tests/corebench/coreutils/coreutils-case-7380cf79-2e636af1/tempworkdir/src /home/ubuntu/spr-fast/tests/corebench/coreutils/coreutils-case-7380cf79-2e636af1/tempworkdir/tests /home/ubuntu/spr-fast/tests/corebench/coreutils/coreutils-case-7380cf79-2e636af1/tempworkdir 0  > __res
BasicTester, Testing instance id 239:
Running test command:
/home/ubuntu/spr-fast/tools/coreutils-test.py /home/ubuntu/spr-fast/tests/corebench/coreutils/coreutils-case-7380cf79-2e636af1/tempworkdir/src /home/ubuntu/spr-fast/tests/corebench/coreutils/coreutils-case-7380cf79-2e636af1/tempworkdir/tests /home/ubuntu/spr-fast/tests/corebench/coreutils/coreutils-case-7380cf79-2e636af1/tempworkdir 0  > __res
BasicTester, Testing instance id 240:
Running test command:
/home/ubuntu/spr-fast/tools/coreutils-test.py /home/ubuntu/spr-fast/tests/corebench/coreutils/coreutils-case-7380cf79-2e636af1/tempworkdir/src /home/ubuntu/spr-fast/tests/corebench/coreutils/coreutils-case-7380cf79-2e636af1/tempworkdir/tests /home/ubuntu/spr-fast/tests/corebench/coreutils/coreutils-case-7380cf79-2e636af1/tempworkdir 0  > __res
Counter: 290
Batcher Size:59
Preprocess the following candidate with BasicTester:
Priority 4991
At location src/cut.c:449
--Src File: src/cut.c
Fragment 0:
suppress_non_delimited = (rhs_specified);
break;


BasicTester, a patch instance with id 241:
Spawn 1 instances, now Total 290
Counter: 291
Batcher Size:60
Preprocess the following candidate with BasicTester:
Priority 4991
At location src/cut.c:449
--Src File: src/cut.c
Fragment 0:
suppress_non_delimited = 0;
break;


BasicTester, a patch instance with id 242:
Spawn 1 instances, now Total 291
Counter: 292
Batcher Size:61
Preprocess the following candidate with BasicTester:
Priority 4991
At location src/cut.c:449
--Src File: src/cut.c
Fragment 0:
suppress_non_delimited = (lhs_specified);
break;


BasicTester, a patch instance with id 243:
Spawn 1 instances, now Total 292
Counter: 293
Batcher Size:62
Preprocess the following candidate with BasicTester:
Priority 4991
At location src/cut.c:449
--Src File: src/cut.c
Fragment 0:
setlocale(6, "");
break;


BasicTester, a patch instance with id 244:
Spawn 1 instances, now Total 293
Counter: 294
Batcher Size:63
Preprocess the following candidate with BasicTester:
Priority 4991
At location src/cut.c:449
--Src File: src/cut.c
Fragment 0:
suppress_non_delimited = (dash_found);
break;


BasicTester, a patch instance with id 245:
Spawn 1 instances, now Total 294
Counter: 295
Batcher Size:64
Preprocess the following candidate with BasicTester:
Priority 4991
At location src/cut.c:449
--Src File: src/cut.c
Fragment 0:
suppress_non_delimited = (field_found);
break;


BasicTester, a patch instance with id 246:
Spawn 1 instances, now Total 295
Counter: 296
Batcher Size:65
Preprocess the following candidate with BasicTester:
Priority 4991
At location src/cut.c:449
--Src File: src/cut.c
Fragment 0:
rhs_specified = (field_found);
break;


BasicTester, a patch instance with id 247:
Spawn 1 instances, now Total 296
Counter: 297
Batcher Size:66
Preprocess the following candidate with BasicTester:
Priority 4991
At location src/cut.c:449
--Src File: src/cut.c
Fragment 0:
rhs_specified = (in_digits);
break;


BasicTester, a patch instance with id 248:
Spawn 1 instances, now Total 297
Counter: 298
Batcher Size:67
Preprocess the following candidate with BasicTester:
Priority 4991
At location src/cut.c:449
--Src File: src/cut.c
Fragment 0:
rhs_specified = (rhs_specified);
break;


BasicTester, a patch instance with id 249:
Spawn 1 instances, now Total 298
Counter: 299
Batcher Size:68
Preprocess the following candidate with BasicTester:
Priority 4991
At location src/cut.c:449
--Src File: src/cut.c
Fragment 0:
rhs_specified = 0;
break;


BasicTester, a patch instance with id 250:
Spawn 1 instances, now Total 299
a batched test job starts!
Building:src at:
/home/ubuntu/spr-fast/tests/corebench/coreutils/coreutils-case-7380cf79-2e636af1/tempworkdir/srcMerged code building succ, going to invoke tester!
BasicTester, Testing instance id 241:
Running test command:
/home/ubuntu/spr-fast/tools/coreutils-test.py /home/ubuntu/spr-fast/tests/corebench/coreutils/coreutils-case-7380cf79-2e636af1/tempworkdir/src /home/ubuntu/spr-fast/tests/corebench/coreutils/coreutils-case-7380cf79-2e636af1/tempworkdir/tests /home/ubuntu/spr-fast/tests/corebench/coreutils/coreutils-case-7380cf79-2e636af1/tempworkdir 0  > __res
BasicTester, Testing instance id 242:
Running test command:
/home/ubuntu/spr-fast/tools/coreutils-test.py /home/ubuntu/spr-fast/tests/corebench/coreutils/coreutils-case-7380cf79-2e636af1/tempworkdir/src /home/ubuntu/spr-fast/tests/corebench/coreutils/coreutils-case-7380cf79-2e636af1/tempworkdir/tests /home/ubuntu/spr-fast/tests/corebench/coreutils/coreutils-case-7380cf79-2e636af1/tempworkdir 0  > __res
BasicTester, Testing instance id 243:
Running test command:
/home/ubuntu/spr-fast/tools/coreutils-test.py /home/ubuntu/spr-fast/tests/corebench/coreutils/coreutils-case-7380cf79-2e636af1/tempworkdir/src /home/ubuntu/spr-fast/tests/corebench/coreutils/coreutils-case-7380cf79-2e636af1/tempworkdir/tests /home/ubuntu/spr-fast/tests/corebench/coreutils/coreutils-case-7380cf79-2e636af1/tempworkdir 0  > __res
BasicTester, Testing instance id 244:
Running test command:
/home/ubuntu/spr-fast/tools/coreutils-test.py /home/ubuntu/spr-fast/tests/corebench/coreutils/coreutils-case-7380cf79-2e636af1/tempworkdir/src /home/ubuntu/spr-fast/tests/corebench/coreutils/coreutils-case-7380cf79-2e636af1/tempworkdir/tests /home/ubuntu/spr-fast/tests/corebench/coreutils/coreutils-case-7380cf79-2e636af1/tempworkdir 0  > __res
BasicTester, Testing instance id 245:
Running test command:
/home/ubuntu/spr-fast/tools/coreutils-test.py /home/ubuntu/spr-fast/tests/corebench/coreutils/coreutils-case-7380cf79-2e636af1/tempworkdir/src /home/ubuntu/spr-fast/tests/corebench/coreutils/coreutils-case-7380cf79-2e636af1/tempworkdir/tests /home/ubuntu/spr-fast/tests/corebench/coreutils/coreutils-case-7380cf79-2e636af1/tempworkdir 0  > __res
BasicTester, Testing instance id 246:
Running test command:
/home/ubuntu/spr-fast/tools/coreutils-test.py /home/ubuntu/spr-fast/tests/corebench/coreutils/coreutils-case-7380cf79-2e636af1/tempworkdir/src /home/ubuntu/spr-fast/tests/corebench/coreutils/coreutils-case-7380cf79-2e636af1/tempworkdir/tests /home/ubuntu/spr-fast/tests/corebench/coreutils/coreutils-case-7380cf79-2e636af1/tempworkdir 0  > __res
BasicTester, Testing instance id 247:
Running test command:
/home/ubuntu/spr-fast/tools/coreutils-test.py /home/ubuntu/spr-fast/tests/corebench/coreutils/coreutils-case-7380cf79-2e636af1/tempworkdir/src /home/ubuntu/spr-fast/tests/corebench/coreutils/coreutils-case-7380cf79-2e636af1/tempworkdir/tests /home/ubuntu/spr-fast/tests/corebench/coreutils/coreutils-case-7380cf79-2e636af1/tempworkdir 0  > __res
BasicTester, Testing instance id 248:
Running test command:
/home/ubuntu/spr-fast/tools/coreutils-test.py /home/ubuntu/spr-fast/tests/corebench/coreutils/coreutils-case-7380cf79-2e636af1/tempworkdir/src /home/ubuntu/spr-fast/tests/corebench/coreutils/coreutils-case-7380cf79-2e636af1/tempworkdir/tests /home/ubuntu/spr-fast/tests/corebench/coreutils/coreutils-case-7380cf79-2e636af1/tempworkdir 0  > __res
BasicTester, Testing instance id 249:
Running test command:
/home/ubuntu/spr-fast/tools/coreutils-test.py /home/ubuntu/spr-fast/tests/corebench/coreutils/coreutils-case-7380cf79-2e636af1/tempworkdir/src /home/ubuntu/spr-fast/tests/corebench/coreutils/coreutils-case-7380cf79-2e636af1/tempworkdir/tests /home/ubuntu/spr-fast/tests/corebench/coreutils/coreutils-case-7380cf79-2e636af1/tempworkdir 0  > __res
BasicTester, Testing instance id 250:
Running test command:
/home/ubuntu/spr-fast/tools/coreutils-test.py /home/ubuntu/spr-fast/tests/corebench/coreutils/coreutils-case-7380cf79-2e636af1/tempworkdir/src /home/ubuntu/spr-fast/tests/corebench/coreutils/coreutils-case-7380cf79-2e636af1/tempworkdir/tests /home/ubuntu/spr-fast/tests/corebench/coreutils/coreutils-case-7380cf79-2e636af1/tempworkdir 0  > __res
Counter: 300
Batcher Size:59
Preprocess the following candidate with BasicTester:
Priority 4991
At location src/cut.c:449
--Src File: src/cut.c
Fragment 0:
rhs_specified = (lhs_specified);
break;


BasicTester, a patch instance with id 251:
Spawn 1 instances, now Total 300
Counter: 301
Batcher Size:60
Preprocess the following candidate with BasicTester:
Priority 4991
At location src/cut.c:449
--Src File: src/cut.c
Fragment 0:
in_digits = 1;
break;


BasicTester, a patch instance with id 252:
Spawn 1 instances, now Total 301
Counter: 302
Batcher Size:61
Preprocess the following candidate with BasicTester:
Priority 4991
At location src/cut.c:449
--Src File: src/cut.c
Fragment 0:
max_range_endpoint = (rp)[i].hi;
break;


BasicTester, a patch instance with id 253:
Spawn 1 instances, now Total 302
Counter: 303
Batcher Size:62
Preprocess the following candidate with BasicTester:
Priority 4991
At location src/cut.c:449
--Src File: src/cut.c
Fragment 0:
output_delimiter_length = (-1);
break;


BasicTester, a patch instance with id 254:
Spawn 1 instances, now Total 303
Counter: 304
Batcher Size:63
Preprocess the following candidate with BasicTester:
Priority 4991
At location src/cut.c:449
--Src File: src/cut.c
Fragment 0:
output_delimiter_length = (n_rp);
break;


BasicTester, a patch instance with id 255:
Spawn 1 instances, now Total 304
Counter: 305
Batcher Size:64
Preprocess the following candidate with BasicTester:
Priority 4991
At location src/cut.c:449
--Src File: src/cut.c
Fragment 0:
output_delimiter_length = 1;
break;


BasicTester, a patch instance with id 256:
Spawn 1 instances, now Total 305
Counter: 306
Batcher Size:65
Preprocess the following candidate with BasicTester:
Priority 4991
At location src/cut.c:449
--Src File: src/cut.c
Fragment 0:
printf(gettext("\nDisplay values are in units of the first available SIZE from --block-size,\nand the %s_BLOCK_SIZE, BLOCK_SIZE and BLOCKSIZE environment variables.\nOtherwise, units default to 1024 bytes (or 512 if POSIXLY_CORRECT is set).\n"), (fieldstr));
break;


BasicTester, a patch instance with id 257:
Spawn 1 instances, now Total 306
Counter: 307
Batcher Size:66
Preprocess the following candidate with BasicTester:
Priority 4991
At location src/cut.c:449
--Src File: src/cut.c
Fragment 0:
putchar('\n');
break;


BasicTester, a patch instance with id 258:
Spawn 1 instances, now Total 307
Counter: 308
Batcher Size:67
Preprocess the following candidate with BasicTester:
Priority 4991
At location src/cut.c:449
--Src File: src/cut.c
Fragment 0:
printable_field = xzalloc(max_range_endpoint / 8 + 1);
break;


BasicTester, a patch instance with id 259:
Spawn 1 instances, now Total 308
Counter: 309
Batcher Size:68
Preprocess the following candidate with BasicTester:
Priority 4991
At location src/cut.c:449
--Src File: src/cut.c
Fragment 0:
output_delimiter_length = (n_rp_allocated);
break;


BasicTester, a patch instance with id 260:
Spawn 1 instances, now Total 309
a batched test job starts!
Building:src at:
/home/ubuntu/spr-fast/tests/corebench/coreutils/coreutils-case-7380cf79-2e636af1/tempworkdir/srcMerged code building succ, going to invoke tester!
BasicTester, Testing instance id 251:
Running test command:
/home/ubuntu/spr-fast/tools/coreutils-test.py /home/ubuntu/spr-fast/tests/corebench/coreutils/coreutils-case-7380cf79-2e636af1/tempworkdir/src /home/ubuntu/spr-fast/tests/corebench/coreutils/coreutils-case-7380cf79-2e636af1/tempworkdir/tests /home/ubuntu/spr-fast/tests/corebench/coreutils/coreutils-case-7380cf79-2e636af1/tempworkdir 0  > __res
BasicTester, Testing instance id 252:
Running test command:
/home/ubuntu/spr-fast/tools/coreutils-test.py /home/ubuntu/spr-fast/tests/corebench/coreutils/coreutils-case-7380cf79-2e636af1/tempworkdir/src /home/ubuntu/spr-fast/tests/corebench/coreutils/coreutils-case-7380cf79-2e636af1/tempworkdir/tests /home/ubuntu/spr-fast/tests/corebench/coreutils/coreutils-case-7380cf79-2e636af1/tempworkdir 0  > __res
BasicTester, Testing instance id 253:
Running test command:
/home/ubuntu/spr-fast/tools/coreutils-test.py /home/ubuntu/spr-fast/tests/corebench/coreutils/coreutils-case-7380cf79-2e636af1/tempworkdir/src /home/ubuntu/spr-fast/tests/corebench/coreutils/coreutils-case-7380cf79-2e636af1/tempworkdir/tests /home/ubuntu/spr-fast/tests/corebench/coreutils/coreutils-case-7380cf79-2e636af1/tempworkdir 0  > __res
BasicTester, Testing instance id 254:
Running test command:
/home/ubuntu/spr-fast/tools/coreutils-test.py /home/ubuntu/spr-fast/tests/corebench/coreutils/coreutils-case-7380cf79-2e636af1/tempworkdir/src /home/ubuntu/spr-fast/tests/corebench/coreutils/coreutils-case-7380cf79-2e636af1/tempworkdir/tests /home/ubuntu/spr-fast/tests/corebench/coreutils/coreutils-case-7380cf79-2e636af1/tempworkdir 0  > __res
BasicTester, Testing instance id 255:
Running test command:
/home/ubuntu/spr-fast/tools/coreutils-test.py /home/ubuntu/spr-fast/tests/corebench/coreutils/coreutils-case-7380cf79-2e636af1/tempworkdir/src /home/ubuntu/spr-fast/tests/corebench/coreutils/coreutils-case-7380cf79-2e636af1/tempworkdir/tests /home/ubuntu/spr-fast/tests/corebench/coreutils/coreutils-case-7380cf79-2e636af1/tempworkdir 0  > __res
BasicTester, Testing instance id 256:
Running test command:
/home/ubuntu/spr-fast/tools/coreutils-test.py /home/ubuntu/spr-fast/tests/corebench/coreutils/coreutils-case-7380cf79-2e636af1/tempworkdir/src /home/ubuntu/spr-fast/tests/corebench/coreutils/coreutils-case-7380cf79-2e636af1/tempworkdir/tests /home/ubuntu/spr-fast/tests/corebench/coreutils/coreutils-case-7380cf79-2e636af1/tempworkdir 0  > __res
BasicTester, Testing instance id 257:
Running test command:
/home/ubuntu/spr-fast/tools/coreutils-test.py /home/ubuntu/spr-fast/tests/corebench/coreutils/coreutils-case-7380cf79-2e636af1/tempworkdir/src /home/ubuntu/spr-fast/tests/corebench/coreutils/coreutils-case-7380cf79-2e636af1/tempworkdir/tests /home/ubuntu/spr-fast/tests/corebench/coreutils/coreutils-case-7380cf79-2e636af1/tempworkdir 0  > __res
BasicTester, Testing instance id 258:
Running test command:
/home/ubuntu/spr-fast/tools/coreutils-test.py /home/ubuntu/spr-fast/tests/corebench/coreutils/coreutils-case-7380cf79-2e636af1/tempworkdir/src /home/ubuntu/spr-fast/tests/corebench/coreutils/coreutils-case-7380cf79-2e636af1/tempworkdir/tests /home/ubuntu/spr-fast/tests/corebench/coreutils/coreutils-case-7380cf79-2e636af1/tempworkdir 0  > __res
BasicTester, Testing instance id 259:
Running test command:
/home/ubuntu/spr-fast/tools/coreutils-test.py /home/ubuntu/spr-fast/tests/corebench/coreutils/coreutils-case-7380cf79-2e636af1/tempworkdir/src /home/ubuntu/spr-fast/tests/corebench/coreutils/coreutils-case-7380cf79-2e636af1/tempworkdir/tests /home/ubuntu/spr-fast/tests/corebench/coreutils/coreutils-case-7380cf79-2e636af1/tempworkdir 0  > __res
BasicTester, Testing instance id 260:
Running test command:
/home/ubuntu/spr-fast/tools/coreutils-test.py /home/ubuntu/spr-fast/tests/corebench/coreutils/coreutils-case-7380cf79-2e636af1/tempworkdir/src /home/ubuntu/spr-fast/tests/corebench/coreutils/coreutils-case-7380cf79-2e636af1/tempworkdir/tests /home/ubuntu/spr-fast/tests/corebench/coreutils/coreutils-case-7380cf79-2e636af1/tempworkdir 0  > __res
Counter: 310
Batcher Size:59
Preprocess the following candidate with BasicTester:
Priority 4991
At location src/cut.c:449
--Src File: src/cut.c
Fragment 0:
output_delimiter_length = (optarg[0] == '\x00' ? 1 : strlen(optarg));
break;


BasicTester, a patch instance with id 261:
Spawn 1 instances, now Total 310
Counter: 311
Batcher Size:60
Preprocess the following candidate with BasicTester:
Priority 4991
At location src/cut.c:449
--Src File: src/cut.c
Fragment 0:
output_delimiter_length = (value);
break;


BasicTester, a patch instance with id 262:
Spawn 1 instances, now Total 311
Counter: 312
Batcher Size:61
Preprocess the following candidate with BasicTester:
Priority 4991
At location src/cut.c:449
--Src File: src/cut.c
Fragment 0:
output_delimiter_length = (0);
break;


BasicTester, a patch instance with id 263:
Spawn 1 instances, now Total 312
Counter: 313
Batcher Size:62
Preprocess the following candidate with BasicTester:
Priority 4991
At location src/cut.c:449
--Src File: src/cut.c
Fragment 0:
output_delimiter_length = (8);
break;


BasicTester, a patch instance with id 264:
Spawn 1 instances, now Total 313
Counter: 314
Batcher Size:63
Preprocess the following candidate with BasicTester:
Priority 4991
At location src/cut.c:449
--Src File: src/cut.c
Fragment 0:
output_delimiter_length = (i);
break;


BasicTester, a patch instance with id 265:
Spawn 1 instances, now Total 314
Counter: 315
Batcher Size:64
Preprocess the following candidate with BasicTester:
Priority 4991
At location src/cut.c:449
--Src File: src/cut.c
Fragment 0:
output_delimiter_length = (initial);
break;


BasicTester, a patch instance with id 266:
Spawn 1 instances, now Total 315
Counter: 316
Batcher Size:65
Preprocess the following candidate with BasicTester:
Priority 4991
At location src/cut.c:449
--Src File: src/cut.c
Fragment 0:
output_delimiter_length = (9);
break;


BasicTester, a patch instance with id 267:
Spawn 1 instances, now Total 316
Counter: 317
Batcher Size:66
Preprocess the following candidate with BasicTester:
Priority 4991
At location src/cut.c:449
--Src File: src/cut.c
Fragment 0:
output_delimiter_length = (1);
break;


BasicTester, a patch instance with id 268:
Spawn 1 instances, now Total 317
Counter: 318
Batcher Size:67
Preprocess the following candidate with BasicTester:
Priority 4991
At location src/cut.c:449
--Src File: src/cut.c
Fragment 0:
output_delimiter_length = (10);
break;


BasicTester, a patch instance with id 269:
Spawn 1 instances, now Total 318
Counter: 319
Batcher Size:68
Preprocess the following candidate with BasicTester:
Priority 4991
At location src/cut.c:449
--Src File: src/cut.c
Fragment 0:
max_range_endpoint = (value);
break;


BasicTester, a patch instance with id 270:
Spawn 1 instances, now Total 319
a batched test job starts!
Building:src at:
/home/ubuntu/spr-fast/tests/corebench/coreutils/coreutils-case-7380cf79-2e636af1/tempworkdir/srcMerged code building succ, going to invoke tester!
BasicTester, Testing instance id 261:
Running test command:
/home/ubuntu/spr-fast/tools/coreutils-test.py /home/ubuntu/spr-fast/tests/corebench/coreutils/coreutils-case-7380cf79-2e636af1/tempworkdir/src /home/ubuntu/spr-fast/tests/corebench/coreutils/coreutils-case-7380cf79-2e636af1/tempworkdir/tests /home/ubuntu/spr-fast/tests/corebench/coreutils/coreutils-case-7380cf79-2e636af1/tempworkdir 0  > __res
BasicTester, Testing instance id 262:
Running test command:
/home/ubuntu/spr-fast/tools/coreutils-test.py /home/ubuntu/spr-fast/tests/corebench/coreutils/coreutils-case-7380cf79-2e636af1/tempworkdir/src /home/ubuntu/spr-fast/tests/corebench/coreutils/coreutils-case-7380cf79-2e636af1/tempworkdir/tests /home/ubuntu/spr-fast/tests/corebench/coreutils/coreutils-case-7380cf79-2e636af1/tempworkdir 0  > __res
BasicTester, Testing instance id 263:
Running test command:
/home/ubuntu/spr-fast/tools/coreutils-test.py /home/ubuntu/spr-fast/tests/corebench/coreutils/coreutils-case-7380cf79-2e636af1/tempworkdir/src /home/ubuntu/spr-fast/tests/corebench/coreutils/coreutils-case-7380cf79-2e636af1/tempworkdir/tests /home/ubuntu/spr-fast/tests/corebench/coreutils/coreutils-case-7380cf79-2e636af1/tempworkdir 0  > __res
BasicTester, Testing instance id 264:
Running test command:
/home/ubuntu/spr-fast/tools/coreutils-test.py /home/ubuntu/spr-fast/tests/corebench/coreutils/coreutils-case-7380cf79-2e636af1/tempworkdir/src /home/ubuntu/spr-fast/tests/corebench/coreutils/coreutils-case-7380cf79-2e636af1/tempworkdir/tests /home/ubuntu/spr-fast/tests/corebench/coreutils/coreutils-case-7380cf79-2e636af1/tempworkdir 0  > __res
BasicTester, Testing instance id 265:
Running test command:
/home/ubuntu/spr-fast/tools/coreutils-test.py /home/ubuntu/spr-fast/tests/corebench/coreutils/coreutils-case-7380cf79-2e636af1/tempworkdir/src /home/ubuntu/spr-fast/tests/corebench/coreutils/coreutils-case-7380cf79-2e636af1/tempworkdir/tests /home/ubuntu/spr-fast/tests/corebench/coreutils/coreutils-case-7380cf79-2e636af1/tempworkdir 0  > __res
BasicTester, Testing instance id 266:
Running test command:
/home/ubuntu/spr-fast/tools/coreutils-test.py /home/ubuntu/spr-fast/tests/corebench/coreutils/coreutils-case-7380cf79-2e636af1/tempworkdir/src /home/ubuntu/spr-fast/tests/corebench/coreutils/coreutils-case-7380cf79-2e636af1/tempworkdir/tests /home/ubuntu/spr-fast/tests/corebench/coreutils/coreutils-case-7380cf79-2e636af1/tempworkdir 0  > __res
BasicTester, Testing instance id 267:
Running test command:
/home/ubuntu/spr-fast/tools/coreutils-test.py /home/ubuntu/spr-fast/tests/corebench/coreutils/coreutils-case-7380cf79-2e636af1/tempworkdir/src /home/ubuntu/spr-fast/tests/corebench/coreutils/coreutils-case-7380cf79-2e636af1/tempworkdir/tests /home/ubuntu/spr-fast/tests/corebench/coreutils/coreutils-case-7380cf79-2e636af1/tempworkdir 0  > __res
BasicTester, Testing instance id 268:
Running test command:
/home/ubuntu/spr-fast/tools/coreutils-test.py /home/ubuntu/spr-fast/tests/corebench/coreutils/coreutils-case-7380cf79-2e636af1/tempworkdir/src /home/ubuntu/spr-fast/tests/corebench/coreutils/coreutils-case-7380cf79-2e636af1/tempworkdir/tests /home/ubuntu/spr-fast/tests/corebench/coreutils/coreutils-case-7380cf79-2e636af1/tempworkdir 0  > __res
BasicTester, Testing instance id 269:
Running test command:
/home/ubuntu/spr-fast/tools/coreutils-test.py /home/ubuntu/spr-fast/tests/corebench/coreutils/coreutils-case-7380cf79-2e636af1/tempworkdir/src /home/ubuntu/spr-fast/tests/corebench/coreutils/coreutils-case-7380cf79-2e636af1/tempworkdir/tests /home/ubuntu/spr-fast/tests/corebench/coreutils/coreutils-case-7380cf79-2e636af1/tempworkdir 0  > __res
BasicTester, Testing instance id 270:
Running test command:
/home/ubuntu/spr-fast/tools/coreutils-test.py /home/ubuntu/spr-fast/tests/corebench/coreutils/coreutils-case-7380cf79-2e636af1/tempworkdir/src /home/ubuntu/spr-fast/tests/corebench/coreutils/coreutils-case-7380cf79-2e636af1/tempworkdir/tests /home/ubuntu/spr-fast/tests/corebench/coreutils/coreutils-case-7380cf79-2e636af1/tempworkdir 0  > __res
Counter: 320
Batcher Size:59
Preprocess the following candidate with BasicTester:
Priority 4991
At location src/cut.c:449
--Src File: src/cut.c
Fragment 0:
operating_mode = (8);
break;


BasicTester, a patch instance with id 271:
Spawn 1 instances, now Total 320
Counter: 321
Batcher Size:60
Preprocess the following candidate with BasicTester:
Priority 4991
At location src/cut.c:449
--Src File: src/cut.c
Fragment 0:
operating_mode = (undefined_mode);
break;


BasicTester, a patch instance with id 272:
Spawn 1 instances, now Total 321
Counter: 322
Batcher Size:61
Preprocess the following candidate with BasicTester:
Priority 4991
At location src/cut.c:449
--Src File: src/cut.c
Fragment 0:
operating_mode = field_mode;
break;


BasicTester, a patch instance with id 273:
Spawn 1 instances, now Total 322
Counter: 323
Batcher Size:62
Preprocess the following candidate with BasicTester:
Priority 4991
At location src/cut.c:449
--Src File: src/cut.c
Fragment 0:
operating_mode = undefined_mode;
break;


BasicTester, a patch instance with id 274:
Spawn 1 instances, now Total 323
Counter: 324
Batcher Size:63
Preprocess the following candidate with BasicTester:
Priority 4991
At location src/cut.c:449
--Src File: src/cut.c
Fragment 0:
operating_mode = byte_mode;
break;


BasicTester, a patch instance with id 275:
Spawn 1 instances, now Total 324
Counter: 325
Batcher Size:64
Preprocess the following candidate with BasicTester:
Priority 4991
At location src/cut.c:449
--Src File: src/cut.c
Fragment 0:
operating_mode = (9);
break;


BasicTester, a patch instance with id 276:
Spawn 1 instances, now Total 325
Counter: 326
Batcher Size:65
Preprocess the following candidate with BasicTester:
Priority 4991
At location src/cut.c:449
--Src File: src/cut.c
Fragment 0:
operating_mode = (byte_mode);
break;


BasicTester, a patch instance with id 277:
Spawn 1 instances, now Total 326
Counter: 327
Batcher Size:66
Preprocess the following candidate with BasicTester:
Priority 4991
At location src/cut.c:449
--Src File: src/cut.c
Fragment 0:
operating_mode = (field_mode);
break;


BasicTester, a patch instance with id 278:
Spawn 1 instances, now Total 327
Counter: 328
Batcher Size:67
Preprocess the following candidate with BasicTester:
Priority 4991
At location src/cut.c:449
--Src File: src/cut.c
Fragment 0:
max_range_endpoint = 0;
break;


BasicTester, a patch instance with id 279:
Spawn 1 instances, now Total 328
Counter: 329
Batcher Size:68
Preprocess the following candidate with BasicTester:
Priority 4991
At location src/cut.c:449
--Src File: src/cut.c
Fragment 0:
operating_mode = (-1);
break;


BasicTester, a patch instance with id 280:
Spawn 1 instances, now Total 329
a batched test job starts!
Building:src at:
/home/ubuntu/spr-fast/tests/corebench/coreutils/coreutils-case-7380cf79-2e636af1/tempworkdir/srcMerged code building succ, going to invoke tester!
BasicTester, Testing instance id 271:
Running test command:
/home/ubuntu/spr-fast/tools/coreutils-test.py /home/ubuntu/spr-fast/tests/corebench/coreutils/coreutils-case-7380cf79-2e636af1/tempworkdir/src /home/ubuntu/spr-fast/tests/corebench/coreutils/coreutils-case-7380cf79-2e636af1/tempworkdir/tests /home/ubuntu/spr-fast/tests/corebench/coreutils/coreutils-case-7380cf79-2e636af1/tempworkdir 0  > __res
BasicTester, Testing instance id 272:
Running test command:
/home/ubuntu/spr-fast/tools/coreutils-test.py /home/ubuntu/spr-fast/tests/corebench/coreutils/coreutils-case-7380cf79-2e636af1/tempworkdir/src /home/ubuntu/spr-fast/tests/corebench/coreutils/coreutils-case-7380cf79-2e636af1/tempworkdir/tests /home/ubuntu/spr-fast/tests/corebench/coreutils/coreutils-case-7380cf79-2e636af1/tempworkdir 0  > __res
BasicTester, Testing instance id 273:
Running test command:
/home/ubuntu/spr-fast/tools/coreutils-test.py /home/ubuntu/spr-fast/tests/corebench/coreutils/coreutils-case-7380cf79-2e636af1/tempworkdir/src /home/ubuntu/spr-fast/tests/corebench/coreutils/coreutils-case-7380cf79-2e636af1/tempworkdir/tests /home/ubuntu/spr-fast/tests/corebench/coreutils/coreutils-case-7380cf79-2e636af1/tempworkdir 0  > __res
BasicTester, Testing instance id 274:
Running test command:
/home/ubuntu/spr-fast/tools/coreutils-test.py /home/ubuntu/spr-fast/tests/corebench/coreutils/coreutils-case-7380cf79-2e636af1/tempworkdir/src /home/ubuntu/spr-fast/tests/corebench/coreutils/coreutils-case-7380cf79-2e636af1/tempworkdir/tests /home/ubuntu/spr-fast/tests/corebench/coreutils/coreutils-case-7380cf79-2e636af1/tempworkdir 0  > __res
BasicTester, Testing instance id 275:
Running test command:
/home/ubuntu/spr-fast/tools/coreutils-test.py /home/ubuntu/spr-fast/tests/corebench/coreutils/coreutils-case-7380cf79-2e636af1/tempworkdir/src /home/ubuntu/spr-fast/tests/corebench/coreutils/coreutils-case-7380cf79-2e636af1/tempworkdir/tests /home/ubuntu/spr-fast/tests/corebench/coreutils/coreutils-case-7380cf79-2e636af1/tempworkdir 0  > __res
BasicTester, Testing instance id 276:
Running test command:
/home/ubuntu/spr-fast/tools/coreutils-test.py /home/ubuntu/spr-fast/tests/corebench/coreutils/coreutils-case-7380cf79-2e636af1/tempworkdir/src /home/ubuntu/spr-fast/tests/corebench/coreutils/coreutils-case-7380cf79-2e636af1/tempworkdir/tests /home/ubuntu/spr-fast/tests/corebench/coreutils/coreutils-case-7380cf79-2e636af1/tempworkdir 0  > __res
BasicTester, Testing instance id 277:
Running test command:
/home/ubuntu/spr-fast/tools/coreutils-test.py /home/ubuntu/spr-fast/tests/corebench/coreutils/coreutils-case-7380cf79-2e636af1/tempworkdir/src /home/ubuntu/spr-fast/tests/corebench/coreutils/coreutils-case-7380cf79-2e636af1/tempworkdir/tests /home/ubuntu/spr-fast/tests/corebench/coreutils/coreutils-case-7380cf79-2e636af1/tempworkdir 0  > __res
BasicTester, Testing instance id 278:
Running test command:
/home/ubuntu/spr-fast/tools/coreutils-test.py /home/ubuntu/spr-fast/tests/corebench/coreutils/coreutils-case-7380cf79-2e636af1/tempworkdir/src /home/ubuntu/spr-fast/tests/corebench/coreutils/coreutils-case-7380cf79-2e636af1/tempworkdir/tests /home/ubuntu/spr-fast/tests/corebench/coreutils/coreutils-case-7380cf79-2e636af1/tempworkdir 0  > __res
BasicTester, Testing instance id 279:
Running test command:
/home/ubuntu/spr-fast/tools/coreutils-test.py /home/ubuntu/spr-fast/tests/corebench/coreutils/coreutils-case-7380cf79-2e636af1/tempworkdir/src /home/ubuntu/spr-fast/tests/corebench/coreutils/coreutils-case-7380cf79-2e636af1/tempworkdir/tests /home/ubuntu/spr-fast/tests/corebench/coreutils/coreutils-case-7380cf79-2e636af1/tempworkdir 0  > __res
BasicTester, Testing instance id 280:
Running test command:
/home/ubuntu/spr-fast/tools/coreutils-test.py /home/ubuntu/spr-fast/tests/corebench/coreutils/coreutils-case-7380cf79-2e636af1/tempworkdir/src /home/ubuntu/spr-fast/tests/corebench/coreutils/coreutils-case-7380cf79-2e636af1/tempworkdir/tests /home/ubuntu/spr-fast/tests/corebench/coreutils/coreutils-case-7380cf79-2e636af1/tempworkdir 0  > __res
Counter: 330
Batcher Size:59
Preprocess the following candidate with BasicTester:
Priority 4991
At location src/cut.c:449
--Src File: src/cut.c
Fragment 0:
operating_mode = (1);
break;


BasicTester, a patch instance with id 281:
Spawn 1 instances, now Total 330
Counter: 331
Batcher Size:60
Preprocess the following candidate with BasicTester:
Priority 4991
At location src/cut.c:449
--Src File: src/cut.c
Fragment 0:
operating_mode = (10);
break;


BasicTester, a patch instance with id 282:
Spawn 1 instances, now Total 331
Counter: 332
Batcher Size:61
Preprocess the following candidate with BasicTester:
Priority 4991
At location src/cut.c:449
--Src File: src/cut.c
Fragment 0:
operating_mode = (0);
break;


BasicTester, a patch instance with id 283:
Spawn 1 instances, now Total 332
Counter: 333
Batcher Size:62
Preprocess the following candidate with BasicTester:
Priority 4991
At location src/cut.c:449
--Src File: src/cut.c
Fragment 0:
max_range_endpoint = rp[i].hi;
break;


BasicTester, a patch instance with id 284:
Spawn 1 instances, now Total 333
Counter: 334
Batcher Size:63
Preprocess the following candidate with BasicTester:
Priority 4991
At location src/cut.c:449
--Src File: src/cut.c
Fragment 0:
initial = (-1);
break;


BasicTester, a patch instance with id 285:
Spawn 1 instances, now Total 334
Counter: 335
Batcher Size:64
Preprocess the following candidate with BasicTester:
Priority 4991
At location src/cut.c:449
--Src File: src/cut.c
Fragment 0:
lhs_specified = (in_digits);
break;


BasicTester, a patch instance with id 286:
Spawn 1 instances, now Total 335
Counter: 336
Batcher Size:65
Preprocess the following candidate with BasicTester:
Priority 4991
At location src/cut.c:449
--Src File: src/cut.c
Fragment 0:
max_range_endpoint = (1);
break;


BasicTester, a patch instance with id 287:
Spawn 1 instances, now Total 336
Counter: 337
Batcher Size:66
Preprocess the following candidate with BasicTester:
Priority 4991
At location src/cut.c:449
--Src File: src/cut.c
Fragment 0:
max_range_endpoint = (i);
break;


BasicTester, a patch instance with id 288:
Spawn 1 instances, now Total 337
Counter: 338
Batcher Size:67
Preprocess the following candidate with BasicTester:
Priority 4991
At location src/cut.c:449
--Src File: src/cut.c
Fragment 0:
max_range_endpoint = (n_rp);
break;


BasicTester, a patch instance with id 289:
Spawn 1 instances, now Total 338
Counter: 339
Batcher Size:68
Preprocess the following candidate with BasicTester:
Priority 4991
At location src/cut.c:449
--Src File: src/cut.c
Fragment 0:
max_range_endpoint = (n_rp_allocated);
break;


BasicTester, a patch instance with id 290:
Spawn 1 instances, now Total 339
a batched test job starts!
Building:src at:
/home/ubuntu/spr-fast/tests/corebench/coreutils/coreutils-case-7380cf79-2e636af1/tempworkdir/srcMerged code building succ, going to invoke tester!
BasicTester, Testing instance id 281:
Running test command:
/home/ubuntu/spr-fast/tools/coreutils-test.py /home/ubuntu/spr-fast/tests/corebench/coreutils/coreutils-case-7380cf79-2e636af1/tempworkdir/src /home/ubuntu/spr-fast/tests/corebench/coreutils/coreutils-case-7380cf79-2e636af1/tempworkdir/tests /home/ubuntu/spr-fast/tests/corebench/coreutils/coreutils-case-7380cf79-2e636af1/tempworkdir 0  > __res
BasicTester, Testing instance id 282:
Running test command:
/home/ubuntu/spr-fast/tools/coreutils-test.py /home/ubuntu/spr-fast/tests/corebench/coreutils/coreutils-case-7380cf79-2e636af1/tempworkdir/src /home/ubuntu/spr-fast/tests/corebench/coreutils/coreutils-case-7380cf79-2e636af1/tempworkdir/tests /home/ubuntu/spr-fast/tests/corebench/coreutils/coreutils-case-7380cf79-2e636af1/tempworkdir 0  > __res
BasicTester, Testing instance id 283:
Running test command:
/home/ubuntu/spr-fast/tools/coreutils-test.py /home/ubuntu/spr-fast/tests/corebench/coreutils/coreutils-case-7380cf79-2e636af1/tempworkdir/src /home/ubuntu/spr-fast/tests/corebench/coreutils/coreutils-case-7380cf79-2e636af1/tempworkdir/tests /home/ubuntu/spr-fast/tests/corebench/coreutils/coreutils-case-7380cf79-2e636af1/tempworkdir 0  > __res
BasicTester, Testing instance id 284:
Running test command:
/home/ubuntu/spr-fast/tools/coreutils-test.py /home/ubuntu/spr-fast/tests/corebench/coreutils/coreutils-case-7380cf79-2e636af1/tempworkdir/src /home/ubuntu/spr-fast/tests/corebench/coreutils/coreutils-case-7380cf79-2e636af1/tempworkdir/tests /home/ubuntu/spr-fast/tests/corebench/coreutils/coreutils-case-7380cf79-2e636af1/tempworkdir 0  > __res
BasicTester, Testing instance id 285:
Running test command:
/home/ubuntu/spr-fast/tools/coreutils-test.py /home/ubuntu/spr-fast/tests/corebench/coreutils/coreutils-case-7380cf79-2e636af1/tempworkdir/src /home/ubuntu/spr-fast/tests/corebench/coreutils/coreutils-case-7380cf79-2e636af1/tempworkdir/tests /home/ubuntu/spr-fast/tests/corebench/coreutils/coreutils-case-7380cf79-2e636af1/tempworkdir 0  > __res
BasicTester, Testing instance id 286:
Running test command:
/home/ubuntu/spr-fast/tools/coreutils-test.py /home/ubuntu/spr-fast/tests/corebench/coreutils/coreutils-case-7380cf79-2e636af1/tempworkdir/src /home/ubuntu/spr-fast/tests/corebench/coreutils/coreutils-case-7380cf79-2e636af1/tempworkdir/tests /home/ubuntu/spr-fast/tests/corebench/coreutils/coreutils-case-7380cf79-2e636af1/tempworkdir 0  > __res
BasicTester, Testing instance id 287:
Running test command:
/home/ubuntu/spr-fast/tools/coreutils-test.py /home/ubuntu/spr-fast/tests/corebench/coreutils/coreutils-case-7380cf79-2e636af1/tempworkdir/src /home/ubuntu/spr-fast/tests/corebench/coreutils/coreutils-case-7380cf79-2e636af1/tempworkdir/tests /home/ubuntu/spr-fast/tests/corebench/coreutils/coreutils-case-7380cf79-2e636af1/tempworkdir 0  > __res
BasicTester, Testing instance id 288:
Running test command:
/home/ubuntu/spr-fast/tools/coreutils-test.py /home/ubuntu/spr-fast/tests/corebench/coreutils/coreutils-case-7380cf79-2e636af1/tempworkdir/src /home/ubuntu/spr-fast/tests/corebench/coreutils/coreutils-case-7380cf79-2e636af1/tempworkdir/tests /home/ubuntu/spr-fast/tests/corebench/coreutils/coreutils-case-7380cf79-2e636af1/tempworkdir 0  > __res
BasicTester, Testing instance id 289:
Running test command:
/home/ubuntu/spr-fast/tools/coreutils-test.py /home/ubuntu/spr-fast/tests/corebench/coreutils/coreutils-case-7380cf79-2e636af1/tempworkdir/src /home/ubuntu/spr-fast/tests/corebench/coreutils/coreutils-case-7380cf79-2e636af1/tempworkdir/tests /home/ubuntu/spr-fast/tests/corebench/coreutils/coreutils-case-7380cf79-2e636af1/tempworkdir 0  > __res
BasicTester, Testing instance id 290:
Running test command:
/home/ubuntu/spr-fast/tools/coreutils-test.py /home/ubuntu/spr-fast/tests/corebench/coreutils/coreutils-case-7380cf79-2e636af1/tempworkdir/src /home/ubuntu/spr-fast/tests/corebench/coreutils/coreutils-case-7380cf79-2e636af1/tempworkdir/tests /home/ubuntu/spr-fast/tests/corebench/coreutils/coreutils-case-7380cf79-2e636af1/tempworkdir 0  > __res
Counter: 340
Batcher Size:59
Preprocess the following candidate with BasicTester:
Priority 4991
At location src/cut.c:449
--Src File: src/cut.c
Fragment 0:
max_range_endpoint = (initial);
break;


BasicTester, a patch instance with id 291:
Spawn 1 instances, now Total 340
Counter: 341
Batcher Size:60
Preprocess the following candidate with BasicTester:
Priority 4991
At location src/cut.c:449
--Src File: src/cut.c
Fragment 0:
max_range_endpoint = (10);
break;


BasicTester, a patch instance with id 292:
Spawn 1 instances, now Total 341
Counter: 342
Batcher Size:61
Preprocess the following candidate with BasicTester:
Priority 4991
At location src/cut.c:449
--Src File: src/cut.c
Fragment 0:
max_range_endpoint = (8);
break;


BasicTester, a patch instance with id 293:
Spawn 1 instances, now Total 342
Counter: 343
Batcher Size:62
Preprocess the following candidate with BasicTester:
Priority 4991
At location src/cut.c:449
--Src File: src/cut.c
Fragment 0:
max_range_endpoint = (9);
break;


BasicTester, a patch instance with id 294:
Spawn 1 instances, now Total 343
Counter: 344
Batcher Size:63
Preprocess the following candidate with BasicTester:
Priority 4991
At location src/cut.c:449
--Src File: src/cut.c
Fragment 0:
lhs_specified = (lhs_specified);
break;


BasicTester, a patch instance with id 295:
Spawn 1 instances, now Total 344
Counter: 345
Batcher Size:64
Preprocess the following candidate with BasicTester:
Priority 4991
At location src/cut.c:449
--Src File: src/cut.c
Fragment 0:
lhs_specified = 1;
break;


BasicTester, a patch instance with id 296:
Spawn 1 instances, now Total 345
Counter: 346
Batcher Size:65
Preprocess the following candidate with BasicTester:
Priority 4991
At location src/cut.c:449
--Src File: src/cut.c
Fragment 0:
max_range_endpoint = (-1);
break;


BasicTester, a patch instance with id 297:
Spawn 1 instances, now Total 346
Counter: 347
Batcher Size:66
Preprocess the following candidate with BasicTester:
Priority 4991
At location src/cut.c:449
--Src File: src/cut.c
Fragment 0:
max_range_endpoint = (0);
break;


BasicTester, a patch instance with id 298:
Spawn 1 instances, now Total 347
Counter: 348
Batcher Size:67
Preprocess the following candidate with BasicTester:
Priority 4991
At location src/cut.c:449
--Src File: src/cut.c
Fragment 0:
mark_range_start(eol_range_start);
break;


BasicTester, a patch instance with id 299:
Spawn 1 instances, now Total 348
Counter: 349
Batcher Size:68
Preprocess the following candidate with BasicTester:
Priority 4991
At location src/cut.c:449
--Src File: src/cut.c
Fragment 0:
lhs_specified = (rhs_specified);
break;


BasicTester, a patch instance with id 300:
Spawn 1 instances, now Total 349
a batched test job starts!
Building:src at:
/home/ubuntu/spr-fast/tests/corebench/coreutils/coreutils-case-7380cf79-2e636af1/tempworkdir/srcMerged code building succ, going to invoke tester!
BasicTester, Testing instance id 291:
Running test command:
/home/ubuntu/spr-fast/tools/coreutils-test.py /home/ubuntu/spr-fast/tests/corebench/coreutils/coreutils-case-7380cf79-2e636af1/tempworkdir/src /home/ubuntu/spr-fast/tests/corebench/coreutils/coreutils-case-7380cf79-2e636af1/tempworkdir/tests /home/ubuntu/spr-fast/tests/corebench/coreutils/coreutils-case-7380cf79-2e636af1/tempworkdir 0  > __res
BasicTester, Testing instance id 292:
Running test command:
/home/ubuntu/spr-fast/tools/coreutils-test.py /home/ubuntu/spr-fast/tests/corebench/coreutils/coreutils-case-7380cf79-2e636af1/tempworkdir/src /home/ubuntu/spr-fast/tests/corebench/coreutils/coreutils-case-7380cf79-2e636af1/tempworkdir/tests /home/ubuntu/spr-fast/tests/corebench/coreutils/coreutils-case-7380cf79-2e636af1/tempworkdir 0  > __res
BasicTester, Testing instance id 293:
Running test command:
/home/ubuntu/spr-fast/tools/coreutils-test.py /home/ubuntu/spr-fast/tests/corebench/coreutils/coreutils-case-7380cf79-2e636af1/tempworkdir/src /home/ubuntu/spr-fast/tests/corebench/coreutils/coreutils-case-7380cf79-2e636af1/tempworkdir/tests /home/ubuntu/spr-fast/tests/corebench/coreutils/coreutils-case-7380cf79-2e636af1/tempworkdir 0  > __res
BasicTester, Testing instance id 294:
Running test command:
/home/ubuntu/spr-fast/tools/coreutils-test.py /home/ubuntu/spr-fast/tests/corebench/coreutils/coreutils-case-7380cf79-2e636af1/tempworkdir/src /home/ubuntu/spr-fast/tests/corebench/coreutils/coreutils-case-7380cf79-2e636af1/tempworkdir/tests /home/ubuntu/spr-fast/tests/corebench/coreutils/coreutils-case-7380cf79-2e636af1/tempworkdir 0  > __res
BasicTester, Testing instance id 295:
Running test command:
/home/ubuntu/spr-fast/tools/coreutils-test.py /home/ubuntu/spr-fast/tests/corebench/coreutils/coreutils-case-7380cf79-2e636af1/tempworkdir/src /home/ubuntu/spr-fast/tests/corebench/coreutils/coreutils-case-7380cf79-2e636af1/tempworkdir/tests /home/ubuntu/spr-fast/tests/corebench/coreutils/coreutils-case-7380cf79-2e636af1/tempworkdir 0  > __res
BasicTester, Testing instance id 296:
Running test command:
/home/ubuntu/spr-fast/tools/coreutils-test.py /home/ubuntu/spr-fast/tests/corebench/coreutils/coreutils-case-7380cf79-2e636af1/tempworkdir/src /home/ubuntu/spr-fast/tests/corebench/coreutils/coreutils-case-7380cf79-2e636af1/tempworkdir/tests /home/ubuntu/spr-fast/tests/corebench/coreutils/coreutils-case-7380cf79-2e636af1/tempworkdir 0  > __res
BasicTester, Testing instance id 297:
Running test command:
/home/ubuntu/spr-fast/tools/coreutils-test.py /home/ubuntu/spr-fast/tests/corebench/coreutils/coreutils-case-7380cf79-2e636af1/tempworkdir/src /home/ubuntu/spr-fast/tests/corebench/coreutils/coreutils-case-7380cf79-2e636af1/tempworkdir/tests /home/ubuntu/spr-fast/tests/corebench/coreutils/coreutils-case-7380cf79-2e636af1/tempworkdir 0  > __res
BasicTester, Testing instance id 298:
Running test command:
/home/ubuntu/spr-fast/tools/coreutils-test.py /home/ubuntu/spr-fast/tests/corebench/coreutils/coreutils-case-7380cf79-2e636af1/tempworkdir/src /home/ubuntu/spr-fast/tests/corebench/coreutils/coreutils-case-7380cf79-2e636af1/tempworkdir/tests /home/ubuntu/spr-fast/tests/corebench/coreutils/coreutils-case-7380cf79-2e636af1/tempworkdir 0  > __res
BasicTester, Testing instance id 299:
Running test command:
/home/ubuntu/spr-fast/tools/coreutils-test.py /home/ubuntu/spr-fast/tests/corebench/coreutils/coreutils-case-7380cf79-2e636af1/tempworkdir/src /home/ubuntu/spr-fast/tests/corebench/coreutils/coreutils-case-7380cf79-2e636af1/tempworkdir/tests /home/ubuntu/spr-fast/tests/corebench/coreutils/coreutils-case-7380cf79-2e636af1/tempworkdir 0  > __res
BasicTester, Testing instance id 300:
Running test command:
/home/ubuntu/spr-fast/tools/coreutils-test.py /home/ubuntu/spr-fast/tests/corebench/coreutils/coreutils-case-7380cf79-2e636af1/tempworkdir/src /home/ubuntu/spr-fast/tests/corebench/coreutils/coreutils-case-7380cf79-2e636af1/tempworkdir/tests /home/ubuntu/spr-fast/tests/corebench/coreutils/coreutils-case-7380cf79-2e636af1/tempworkdir 0  > __res
Counter: 350
Batcher Size:59
Preprocess the following candidate with BasicTester:
Priority 4991
At location src/cut.c:449
--Src File: src/cut.c
Fragment 0:
lhs_specified = 0;
break;


BasicTester, a patch instance with id 301:
Spawn 1 instances, now Total 350
Counter: 351
Batcher Size:60
Preprocess the following candidate with BasicTester:
Priority 4991
At location src/cut.c:449
--Src File: src/cut.c
Fragment 0:
initial = (0);
break;


BasicTester, a patch instance with id 302:
Spawn 1 instances, now Total 351
Counter: 352
Batcher Size:61
Preprocess the following candidate with BasicTester:
Priority 4991
At location src/cut.c:449
--Src File: src/cut.c
Fragment 0:
initial = (i);
break;


BasicTester, a patch instance with id 303:
Spawn 1 instances, now Total 352
Counter: 353
Batcher Size:62
Preprocess the following candidate with BasicTester:
Priority 4991
At location src/cut.c:449
--Src File: src/cut.c
Fragment 0:
initial = (n_rp_allocated);
break;


BasicTester, a patch instance with id 304:
Spawn 1 instances, now Total 353
Counter: 354
Batcher Size:63
Preprocess the following candidate with BasicTester:
Priority 4991
At location src/cut.c:449
--Src File: src/cut.c
Fragment 0:
lhs_specified = (dash_found);
break;


BasicTester, a patch instance with id 305:
Spawn 1 instances, now Total 354
Counter: 355
Batcher Size:64
Preprocess the following candidate with BasicTester:
Priority 4991
At location src/cut.c:449
--Src File: src/cut.c
Fragment 0:
lhs_specified = (field_found);
break;


BasicTester, a patch instance with id 306:
Spawn 1 instances, now Total 355
Counter: 356
Batcher Size:65
Preprocess the following candidate with BasicTester:
Priority 4991
At location src/cut.c:449
--Src File: src/cut.c
Fragment 0:
initial = (value);
break;


BasicTester, a patch instance with id 307:
Spawn 1 instances, now Total 356
Counter: 357
Batcher Size:66
Preprocess the following candidate with BasicTester:
Priority 4991
At location src/cut.c:449
--Src File: src/cut.c
Fragment 0:
initial = (initial);
break;


BasicTester, a patch instance with id 308:
Spawn 1 instances, now Total 357
Counter: 358
Batcher Size:67
Preprocess the following candidate with BasicTester:
Priority 4991
At location src/cut.c:449
--Src File: src/cut.c
Fragment 0:
initial = (lhs_specified ? value : 1);
break;


BasicTester, a patch instance with id 309:
Spawn 1 instances, now Total 358
Counter: 359
Batcher Size:68
Preprocess the following candidate with BasicTester:
Priority 4991
At location src/cut.c:449
--Src File: src/cut.c
Fragment 0:
initial = (n_rp);
break;


BasicTester, a patch instance with id 310:
Spawn 1 instances, now Total 359
a batched test job starts!
Building:src at:
/home/ubuntu/spr-fast/tests/corebench/coreutils/coreutils-case-7380cf79-2e636af1/tempworkdir/srcMerged code building succ, going to invoke tester!
BasicTester, Testing instance id 301:
Running test command:
/home/ubuntu/spr-fast/tools/coreutils-test.py /home/ubuntu/spr-fast/tests/corebench/coreutils/coreutils-case-7380cf79-2e636af1/tempworkdir/src /home/ubuntu/spr-fast/tests/corebench/coreutils/coreutils-case-7380cf79-2e636af1/tempworkdir/tests /home/ubuntu/spr-fast/tests/corebench/coreutils/coreutils-case-7380cf79-2e636af1/tempworkdir 0  > __res
BasicTester, Testing instance id 302:
Running test command:
/home/ubuntu/spr-fast/tools/coreutils-test.py /home/ubuntu/spr-fast/tests/corebench/coreutils/coreutils-case-7380cf79-2e636af1/tempworkdir/src /home/ubuntu/spr-fast/tests/corebench/coreutils/coreutils-case-7380cf79-2e636af1/tempworkdir/tests /home/ubuntu/spr-fast/tests/corebench/coreutils/coreutils-case-7380cf79-2e636af1/tempworkdir 0  > __res
BasicTester, Testing instance id 303:
Running test command:
/home/ubuntu/spr-fast/tools/coreutils-test.py /home/ubuntu/spr-fast/tests/corebench/coreutils/coreutils-case-7380cf79-2e636af1/tempworkdir/src /home/ubuntu/spr-fast/tests/corebench/coreutils/coreutils-case-7380cf79-2e636af1/tempworkdir/tests /home/ubuntu/spr-fast/tests/corebench/coreutils/coreutils-case-7380cf79-2e636af1/tempworkdir 0  > __res
BasicTester, Testing instance id 304:
Running test command:
/home/ubuntu/spr-fast/tools/coreutils-test.py /home/ubuntu/spr-fast/tests/corebench/coreutils/coreutils-case-7380cf79-2e636af1/tempworkdir/src /home/ubuntu/spr-fast/tests/corebench/coreutils/coreutils-case-7380cf79-2e636af1/tempworkdir/tests /home/ubuntu/spr-fast/tests/corebench/coreutils/coreutils-case-7380cf79-2e636af1/tempworkdir 0  > __res
BasicTester, Testing instance id 305:
Running test command:
/home/ubuntu/spr-fast/tools/coreutils-test.py /home/ubuntu/spr-fast/tests/corebench/coreutils/coreutils-case-7380cf79-2e636af1/tempworkdir/src /home/ubuntu/spr-fast/tests/corebench/coreutils/coreutils-case-7380cf79-2e636af1/tempworkdir/tests /home/ubuntu/spr-fast/tests/corebench/coreutils/coreutils-case-7380cf79-2e636af1/tempworkdir 0  > __res
BasicTester, Testing instance id 306:
Running test command:
/home/ubuntu/spr-fast/tools/coreutils-test.py /home/ubuntu/spr-fast/tests/corebench/coreutils/coreutils-case-7380cf79-2e636af1/tempworkdir/src /home/ubuntu/spr-fast/tests/corebench/coreutils/coreutils-case-7380cf79-2e636af1/tempworkdir/tests /home/ubuntu/spr-fast/tests/corebench/coreutils/coreutils-case-7380cf79-2e636af1/tempworkdir 0  > __res
BasicTester, Testing instance id 307:
Running test command:
/home/ubuntu/spr-fast/tools/coreutils-test.py /home/ubuntu/spr-fast/tests/corebench/coreutils/coreutils-case-7380cf79-2e636af1/tempworkdir/src /home/ubuntu/spr-fast/tests/corebench/coreutils/coreutils-case-7380cf79-2e636af1/tempworkdir/tests /home/ubuntu/spr-fast/tests/corebench/coreutils/coreutils-case-7380cf79-2e636af1/tempworkdir 0  > __res
BasicTester, Testing instance id 308:
Running test command:
/home/ubuntu/spr-fast/tools/coreutils-test.py /home/ubuntu/spr-fast/tests/corebench/coreutils/coreutils-case-7380cf79-2e636af1/tempworkdir/src /home/ubuntu/spr-fast/tests/corebench/coreutils/coreutils-case-7380cf79-2e636af1/tempworkdir/tests /home/ubuntu/spr-fast/tests/corebench/coreutils/coreutils-case-7380cf79-2e636af1/tempworkdir 0  > __res
BasicTester, Testing instance id 309:
Running test command:
/home/ubuntu/spr-fast/tools/coreutils-test.py /home/ubuntu/spr-fast/tests/corebench/coreutils/coreutils-case-7380cf79-2e636af1/tempworkdir/src /home/ubuntu/spr-fast/tests/corebench/coreutils/coreutils-case-7380cf79-2e636af1/tempworkdir/tests /home/ubuntu/spr-fast/tests/corebench/coreutils/coreutils-case-7380cf79-2e636af1/tempworkdir 0  > __res
BasicTester, Testing instance id 310:
Running test command:
/home/ubuntu/spr-fast/tools/coreutils-test.py /home/ubuntu/spr-fast/tests/corebench/coreutils/coreutils-case-7380cf79-2e636af1/tempworkdir/src /home/ubuntu/spr-fast/tests/corebench/coreutils/coreutils-case-7380cf79-2e636af1/tempworkdir/tests /home/ubuntu/spr-fast/tests/corebench/coreutils/coreutils-case-7380cf79-2e636af1/tempworkdir 0  > __res
Counter: 360
Batcher Size:59
Preprocess the following candidate with BasicTester:
Priority 4991
At location src/cut.c:449
--Src File: src/cut.c
Fragment 0:
initial = (1);
break;


BasicTester, a patch instance with id 311:
Spawn 1 instances, now Total 360
Counter: 361
Batcher Size:60
Preprocess the following candidate with BasicTester:
Priority 4991
At location src/cut.c:449
--Src File: src/cut.c
Fragment 0:
initial = (10);
break;


BasicTester, a patch instance with id 312:
Spawn 1 instances, now Total 361
Counter: 362
Batcher Size:61
Preprocess the following candidate with BasicTester:
Priority 4991
At location src/cut.c:449
--Src File: src/cut.c
Fragment 0:
initial = (8);
break;


BasicTester, a patch instance with id 313:
Spawn 1 instances, now Total 362
Counter: 363
Batcher Size:62
Preprocess the following candidate with BasicTester:
Priority 4991
At location src/cut.c:449
--Src File: src/cut.c
Fragment 0:
initial = (9);
break;


BasicTester, a patch instance with id 314:
Spawn 1 instances, now Total 363
Counter: 364
Batcher Size:63
Preprocess the following candidate with CondTester:
Priority 4991
At location src/cut.c:449
--Src File: src/cut.c
Fragment 0:
if (!(__abst_hole(fieldstr, lhs_specified, rhs_specified, field_found, value, rp, n_rp, n_rp_allocated, in_digits, initial, dash_found, operating_mode, eol_range_start, max_range_endpoint, i, printable_field, complement, output_delimiter_specified)))
    break;


CondTester, a patch instance with id 48:
Spawn 1 instances, now Total 364
Counter: 365
Batcher Size:64
Preprocess the following candidate with BasicTester:
Priority 4991
At location src/cut.c:449
--Src File: src/cut.c
Fragment 0:
(*__errno_location()) = (10);
break;


BasicTester, a patch instance with id 315:
Spawn 1 instances, now Total 365
Counter: 366
Batcher Size:65
Preprocess the following candidate with BasicTester:
Priority 4991
At location src/cut.c:449
--Src File: src/cut.c
Fragment 0:
eol_range_start = initial;
break;


BasicTester, a patch instance with id 316:
Spawn 1 instances, now Total 366
Counter: 367
Batcher Size:66
Preprocess the following candidate with BasicTester:
Priority 4991
At location src/cut.c:449
--Src File: src/cut.c
Fragment 0:
have_read_stdin = (dash_found);
break;


BasicTester, a patch instance with id 317:
Spawn 1 instances, now Total 367
Counter: 368
Batcher Size:67
Preprocess the following candidate with BasicTester:
Priority 4991
At location src/cut.c:449
--Src File: src/cut.c
Fragment 0:
if (output_delimiter_specified && !complement && eol_range_start && !is_printable_field(eol_range_start))
    mark_range_start(eol_range_start);
break;


BasicTester, a patch instance with id 318:
Spawn 1 instances, now Total 368
Counter: 369
Batcher Size:68
Preprocess the following candidate with BasicTester:
Priority 4991
At location src/cut.c:449
--Src File: src/cut.c
Fragment 0:
in_digits = (field_found);
break;


BasicTester, a patch instance with id 319:
Spawn 1 instances, now Total 369
a batched test job starts!
Building:src at:
/home/ubuntu/spr-fast/tests/corebench/coreutils/coreutils-case-7380cf79-2e636af1/tempworkdir/srcMerged code building succ, going to invoke tester!
BasicTester, Testing instance id 311:
Running test command:
/home/ubuntu/spr-fast/tools/coreutils-test.py /home/ubuntu/spr-fast/tests/corebench/coreutils/coreutils-case-7380cf79-2e636af1/tempworkdir/src /home/ubuntu/spr-fast/tests/corebench/coreutils/coreutils-case-7380cf79-2e636af1/tempworkdir/tests /home/ubuntu/spr-fast/tests/corebench/coreutils/coreutils-case-7380cf79-2e636af1/tempworkdir 0  > __res
BasicTester, Testing instance id 312:
Running test command:
/home/ubuntu/spr-fast/tools/coreutils-test.py /home/ubuntu/spr-fast/tests/corebench/coreutils/coreutils-case-7380cf79-2e636af1/tempworkdir/src /home/ubuntu/spr-fast/tests/corebench/coreutils/coreutils-case-7380cf79-2e636af1/tempworkdir/tests /home/ubuntu/spr-fast/tests/corebench/coreutils/coreutils-case-7380cf79-2e636af1/tempworkdir 0  > __res
BasicTester, Testing instance id 313:
Running test command:
/home/ubuntu/spr-fast/tools/coreutils-test.py /home/ubuntu/spr-fast/tests/corebench/coreutils/coreutils-case-7380cf79-2e636af1/tempworkdir/src /home/ubuntu/spr-fast/tests/corebench/coreutils/coreutils-case-7380cf79-2e636af1/tempworkdir/tests /home/ubuntu/spr-fast/tests/corebench/coreutils/coreutils-case-7380cf79-2e636af1/tempworkdir 0  > __res
BasicTester, Testing instance id 314:
Running test command:
/home/ubuntu/spr-fast/tools/coreutils-test.py /home/ubuntu/spr-fast/tests/corebench/coreutils/coreutils-case-7380cf79-2e636af1/tempworkdir/src /home/ubuntu/spr-fast/tests/corebench/coreutils/coreutils-case-7380cf79-2e636af1/tempworkdir/tests /home/ubuntu/spr-fast/tests/corebench/coreutils/coreutils-case-7380cf79-2e636af1/tempworkdir 0  > __res
CondTester, Testing instance id 48:
Running test command:
/home/ubuntu/spr-fast/tools/coreutils-test.py /home/ubuntu/spr-fast/tests/corebench/coreutils/coreutils-case-7380cf79-2e636af1/tempworkdir/src /home/ubuntu/spr-fast/tests/corebench/coreutils/coreutils-case-7380cf79-2e636af1/tempworkdir/tests /home/ubuntu/spr-fast/tests/corebench/coreutils/coreutils-case-7380cf79-2e636af1/tempworkdir 0  > __res
Running test command:
/home/ubuntu/spr-fast/tools/coreutils-test.py /home/ubuntu/spr-fast/tests/corebench/coreutils/coreutils-case-7380cf79-2e636af1/tempworkdir/src /home/ubuntu/spr-fast/tests/corebench/coreutils/coreutils-case-7380cf79-2e636af1/tempworkdir/tests /home/ubuntu/spr-fast/tests/corebench/coreutils/coreutils-case-7380cf79-2e636af1/tempworkdir 0  > __res
Running test command:
/home/ubuntu/spr-fast/tools/coreutils-test.py /home/ubuntu/spr-fast/tests/corebench/coreutils/coreutils-case-7380cf79-2e636af1/tempworkdir/src /home/ubuntu/spr-fast/tests/corebench/coreutils/coreutils-case-7380cf79-2e636af1/tempworkdir/tests /home/ubuntu/spr-fast/tests/corebench/coreutils/coreutils-case-7380cf79-2e636af1/tempworkdir 0  > __res
BasicTester, Testing instance id 315:
Running test command:
/home/ubuntu/spr-fast/tools/coreutils-test.py /home/ubuntu/spr-fast/tests/corebench/coreutils/coreutils-case-7380cf79-2e636af1/tempworkdir/src /home/ubuntu/spr-fast/tests/corebench/coreutils/coreutils-case-7380cf79-2e636af1/tempworkdir/tests /home/ubuntu/spr-fast/tests/corebench/coreutils/coreutils-case-7380cf79-2e636af1/tempworkdir 0  > __res
BasicTester, Testing instance id 316:
Running test command:
/home/ubuntu/spr-fast/tools/coreutils-test.py /home/ubuntu/spr-fast/tests/corebench/coreutils/coreutils-case-7380cf79-2e636af1/tempworkdir/src /home/ubuntu/spr-fast/tests/corebench/coreutils/coreutils-case-7380cf79-2e636af1/tempworkdir/tests /home/ubuntu/spr-fast/tests/corebench/coreutils/coreutils-case-7380cf79-2e636af1/tempworkdir 0  > __res
BasicTester, Testing instance id 317:
Running test command:
/home/ubuntu/spr-fast/tools/coreutils-test.py /home/ubuntu/spr-fast/tests/corebench/coreutils/coreutils-case-7380cf79-2e636af1/tempworkdir/src /home/ubuntu/spr-fast/tests/corebench/coreutils/coreutils-case-7380cf79-2e636af1/tempworkdir/tests /home/ubuntu/spr-fast/tests/corebench/coreutils/coreutils-case-7380cf79-2e636af1/tempworkdir 0  > __res
BasicTester, Testing instance id 318:
Running test command:
/home/ubuntu/spr-fast/tools/coreutils-test.py /home/ubuntu/spr-fast/tests/corebench/coreutils/coreutils-case-7380cf79-2e636af1/tempworkdir/src /home/ubuntu/spr-fast/tests/corebench/coreutils/coreutils-case-7380cf79-2e636af1/tempworkdir/tests /home/ubuntu/spr-fast/tests/corebench/coreutils/coreutils-case-7380cf79-2e636af1/tempworkdir 0  > __res
BasicTester, Testing instance id 319:
Running test command:
/home/ubuntu/spr-fast/tools/coreutils-test.py /home/ubuntu/spr-fast/tests/corebench/coreutils/coreutils-case-7380cf79-2e636af1/tempworkdir/src /home/ubuntu/spr-fast/tests/corebench/coreutils/coreutils-case-7380cf79-2e636af1/tempworkdir/tests /home/ubuntu/spr-fast/tests/corebench/coreutils/coreutils-case-7380cf79-2e636af1/tempworkdir 0  > __res
Counter: 370
Batcher Size:59
Preprocess the following candidate with BasicTester:
Priority 4991
At location src/cut.c:449
--Src File: src/cut.c
Fragment 0:
in_digits = (lhs_specified);
break;


BasicTester, a patch instance with id 320:
Spawn 1 instances, now Total 370
Counter: 371
Batcher Size:60
Preprocess the following candidate with BasicTester:
Priority 4991
At location src/cut.c:449
--Src File: src/cut.c
Fragment 0:
in_digits = (rhs_specified);
break;


BasicTester, a patch instance with id 321:
Spawn 1 instances, now Total 371
Counter: 372
Batcher Size:61
Preprocess the following candidate with BasicTester:
Priority 4991
At location src/cut.c:449
--Src File: src/cut.c
Fragment 0:
in_digits = (in_digits);
break;


BasicTester, a patch instance with id 322:
Spawn 1 instances, now Total 372
Counter: 373
Batcher Size:62
Preprocess the following candidate with BasicTester:
Priority 4991
At location src/cut.c:449
--Src File: src/cut.c
Fragment 0:
if (output_delimiter_specified) {
}
break;


BasicTester, a patch instance with id 323:
Spawn 1 instances, now Total 373
Counter: 374
Batcher Size:63
Preprocess the following candidate with BasicTester:
Priority 4991
At location src/cut.c:449
--Src File: src/cut.c
Fragment 0:
if (rp[i].hi > max_range_endpoint)
    max_range_endpoint = rp[i].hi;
break;


BasicTester, a patch instance with id 324:
Spawn 1 instances, now Total 374
Counter: 375
Batcher Size:64
Preprocess the following candidate with BasicTester:
Priority 4991
At location src/cut.c:449
--Src File: src/cut.c
Fragment 0:
in_digits = (dash_found);
break;


BasicTester, a patch instance with id 325:
Spawn 1 instances, now Total 375
Counter: 376
Batcher Size:65
Preprocess the following candidate with BasicTester:
Priority 4991
At location src/cut.c:449
--Src File: src/cut.c
Fragment 0:
have_read_stdin = (field_found);
break;


BasicTester, a patch instance with id 326:
Spawn 1 instances, now Total 376
Counter: 377
Batcher Size:66
Preprocess the following candidate with BasicTester:
Priority 4991
At location src/cut.c:449
--Src File: src/cut.c
Fragment 0:
have_read_stdin = (rhs_specified);
break;


BasicTester, a patch instance with id 327:
Spawn 1 instances, now Total 377
Counter: 378
Batcher Size:67
Preprocess the following candidate with BasicTester:
Priority 4991
At location src/cut.c:449
--Src File: src/cut.c
Fragment 0:
have_read_stdin = 1;
break;


BasicTester, a patch instance with id 328:
Spawn 1 instances, now Total 378
Counter: 379
Batcher Size:68
Preprocess the following candidate with BasicTester:
Priority 4991
At location src/cut.c:449
--Src File: src/cut.c
Fragment 0:
if (dash_found)
    rhs_specified = 1;
else
    lhs_specified = 1;
break;


BasicTester, a patch instance with id 329:
Spawn 1 instances, now Total 379
a batched test job starts!
Building:src at:
/home/ubuntu/spr-fast/tests/corebench/coreutils/coreutils-case-7380cf79-2e636af1/tempworkdir/srcMerged code building succ, going to invoke tester!
BasicTester, Testing instance id 320:
Running test command:
/home/ubuntu/spr-fast/tools/coreutils-test.py /home/ubuntu/spr-fast/tests/corebench/coreutils/coreutils-case-7380cf79-2e636af1/tempworkdir/src /home/ubuntu/spr-fast/tests/corebench/coreutils/coreutils-case-7380cf79-2e636af1/tempworkdir/tests /home/ubuntu/spr-fast/tests/corebench/coreutils/coreutils-case-7380cf79-2e636af1/tempworkdir 0  > __res
BasicTester, Testing instance id 321:
Running test command:
/home/ubuntu/spr-fast/tools/coreutils-test.py /home/ubuntu/spr-fast/tests/corebench/coreutils/coreutils-case-7380cf79-2e636af1/tempworkdir/src /home/ubuntu/spr-fast/tests/corebench/coreutils/coreutils-case-7380cf79-2e636af1/tempworkdir/tests /home/ubuntu/spr-fast/tests/corebench/coreutils/coreutils-case-7380cf79-2e636af1/tempworkdir 0  > __res
BasicTester, Testing instance id 322:
Running test command:
/home/ubuntu/spr-fast/tools/coreutils-test.py /home/ubuntu/spr-fast/tests/corebench/coreutils/coreutils-case-7380cf79-2e636af1/tempworkdir/src /home/ubuntu/spr-fast/tests/corebench/coreutils/coreutils-case-7380cf79-2e636af1/tempworkdir/tests /home/ubuntu/spr-fast/tests/corebench/coreutils/coreutils-case-7380cf79-2e636af1/tempworkdir 0  > __res
BasicTester, Testing instance id 323:
Running test command:
/home/ubuntu/spr-fast/tools/coreutils-test.py /home/ubuntu/spr-fast/tests/corebench/coreutils/coreutils-case-7380cf79-2e636af1/tempworkdir/src /home/ubuntu/spr-fast/tests/corebench/coreutils/coreutils-case-7380cf79-2e636af1/tempworkdir/tests /home/ubuntu/spr-fast/tests/corebench/coreutils/coreutils-case-7380cf79-2e636af1/tempworkdir 0  > __res
BasicTester, Testing instance id 324:
Running test command:
/home/ubuntu/spr-fast/tools/coreutils-test.py /home/ubuntu/spr-fast/tests/corebench/coreutils/coreutils-case-7380cf79-2e636af1/tempworkdir/src /home/ubuntu/spr-fast/tests/corebench/coreutils/coreutils-case-7380cf79-2e636af1/tempworkdir/tests /home/ubuntu/spr-fast/tests/corebench/coreutils/coreutils-case-7380cf79-2e636af1/tempworkdir 0  > __res
BasicTester, Testing instance id 325:
Running test command:
/home/ubuntu/spr-fast/tools/coreutils-test.py /home/ubuntu/spr-fast/tests/corebench/coreutils/coreutils-case-7380cf79-2e636af1/tempworkdir/src /home/ubuntu/spr-fast/tests/corebench/coreutils/coreutils-case-7380cf79-2e636af1/tempworkdir/tests /home/ubuntu/spr-fast/tests/corebench/coreutils/coreutils-case-7380cf79-2e636af1/tempworkdir 0  > __res
BasicTester, Testing instance id 326:
Running test command:
/home/ubuntu/spr-fast/tools/coreutils-test.py /home/ubuntu/spr-fast/tests/corebench/coreutils/coreutils-case-7380cf79-2e636af1/tempworkdir/src /home/ubuntu/spr-fast/tests/corebench/coreutils/coreutils-case-7380cf79-2e636af1/tempworkdir/tests /home/ubuntu/spr-fast/tests/corebench/coreutils/coreutils-case-7380cf79-2e636af1/tempworkdir 0  > __res
BasicTester, Testing instance id 327:
Running test command:
/home/ubuntu/spr-fast/tools/coreutils-test.py /home/ubuntu/spr-fast/tests/corebench/coreutils/coreutils-case-7380cf79-2e636af1/tempworkdir/src /home/ubuntu/spr-fast/tests/corebench/coreutils/coreutils-case-7380cf79-2e636af1/tempworkdir/tests /home/ubuntu/spr-fast/tests/corebench/coreutils/coreutils-case-7380cf79-2e636af1/tempworkdir 0  > __res
BasicTester, Testing instance id 328:
Running test command:
/home/ubuntu/spr-fast/tools/coreutils-test.py /home/ubuntu/spr-fast/tests/corebench/coreutils/coreutils-case-7380cf79-2e636af1/tempworkdir/src /home/ubuntu/spr-fast/tests/corebench/coreutils/coreutils-case-7380cf79-2e636af1/tempworkdir/tests /home/ubuntu/spr-fast/tests/corebench/coreutils/coreutils-case-7380cf79-2e636af1/tempworkdir 0  > __res
BasicTester, Testing instance id 329:
Running test command:
/home/ubuntu/spr-fast/tools/coreutils-test.py /home/ubuntu/spr-fast/tests/corebench/coreutils/coreutils-case-7380cf79-2e636af1/tempworkdir/src /home/ubuntu/spr-fast/tests/corebench/coreutils/coreutils-case-7380cf79-2e636af1/tempworkdir/tests /home/ubuntu/spr-fast/tests/corebench/coreutils/coreutils-case-7380cf79-2e636af1/tempworkdir 0  > __res
Counter: 380
Batcher Size:59
Preprocess the following candidate with BasicTester:
Priority 4991
At location src/cut.c:449
--Src File: src/cut.c
Fragment 0:
have_read_stdin = 0;
break;


BasicTester, a patch instance with id 330:
Spawn 1 instances, now Total 380
Counter: 381
Batcher Size:60
Preprocess the following candidate with BasicTester:
Priority 4991
At location src/cut.c:449
--Src File: src/cut.c
Fragment 0:
have_read_stdin = (in_digits);
break;


BasicTester, a patch instance with id 331:
Spawn 1 instances, now Total 381
Counter: 382
Batcher Size:61
Preprocess the following candidate with BasicTester:
Priority 4991
At location src/cut.c:449
--Src File: src/cut.c
Fragment 0:
have_read_stdin = (lhs_specified);
break;


BasicTester, a patch instance with id 332:
Spawn 1 instances, now Total 382
Counter: 383
Batcher Size:62
Preprocess the following candidate with BasicTester:
Priority 4991
At location src/cut.c:449
--Src File: src/cut.c
Fragment 0:
error(0, (*__errno_location()), "%s", (fieldstr));
break;


BasicTester, a patch instance with id 333:
Spawn 1 instances, now Total 383
Counter: 384
Batcher Size:63
Preprocess the following candidate with BasicTester:
Priority 4991
At location src/cut.c:449
--Src File: src/cut.c
Fragment 0:
field_found = (in_digits);
break;


BasicTester, a patch instance with id 334:
Spawn 1 instances, now Total 384
Counter: 385
Batcher Size:64
Preprocess the following candidate with BasicTester:
Priority 4991
At location src/cut.c:449
--Src File: src/cut.c
Fragment 0:
fieldstr++;
break;


BasicTester, a patch instance with id 335:
Spawn 1 instances, now Total 385
Counter: 386
Batcher Size:65
Preprocess the following candidate with BasicTester:
Priority 4991
At location src/cut.c:449
--Src File: src/cut.c
Fragment 0:
free(field_1_buffer);
break;


BasicTester, a patch instance with id 336:
Spawn 1 instances, now Total 386
Counter: 387
Batcher Size:66
Preprocess the following candidate with BasicTester:
Priority 4991
At location src/cut.c:449
--Src File: src/cut.c
Fragment 0:
free(rp);
break;


BasicTester, a patch instance with id 337:
Spawn 1 instances, now Total 387
Counter: 388
Batcher Size:67
Preprocess the following candidate with BasicTester:
Priority 4991
At location src/cut.c:449
--Src File: src/cut.c
Fragment 0:
free((rp));
break;


BasicTester, a patch instance with id 338:
Spawn 1 instances, now Total 388
Counter: 389
Batcher Size:68
Preprocess the following candidate with BasicTester:
Priority 4991
At location src/cut.c:449
--Src File: src/cut.c
Fragment 0:
field_found = (lhs_specified);
break;


BasicTester, a patch instance with id 339:
Spawn 1 instances, now Total 389
a batched test job starts!
Building:src at:
/home/ubuntu/spr-fast/tests/corebench/coreutils/coreutils-case-7380cf79-2e636af1/tempworkdir/srcMerged code building succ, going to invoke tester!
BasicTester, Testing instance id 330:
Running test command:
/home/ubuntu/spr-fast/tools/coreutils-test.py /home/ubuntu/spr-fast/tests/corebench/coreutils/coreutils-case-7380cf79-2e636af1/tempworkdir/src /home/ubuntu/spr-fast/tests/corebench/coreutils/coreutils-case-7380cf79-2e636af1/tempworkdir/tests /home/ubuntu/spr-fast/tests/corebench/coreutils/coreutils-case-7380cf79-2e636af1/tempworkdir 0  > __res
BasicTester, Testing instance id 331:
Running test command:
/home/ubuntu/spr-fast/tools/coreutils-test.py /home/ubuntu/spr-fast/tests/corebench/coreutils/coreutils-case-7380cf79-2e636af1/tempworkdir/src /home/ubuntu/spr-fast/tests/corebench/coreutils/coreutils-case-7380cf79-2e636af1/tempworkdir/tests /home/ubuntu/spr-fast/tests/corebench/coreutils/coreutils-case-7380cf79-2e636af1/tempworkdir 0  > __res
BasicTester, Testing instance id 332:
Running test command:
/home/ubuntu/spr-fast/tools/coreutils-test.py /home/ubuntu/spr-fast/tests/corebench/coreutils/coreutils-case-7380cf79-2e636af1/tempworkdir/src /home/ubuntu/spr-fast/tests/corebench/coreutils/coreutils-case-7380cf79-2e636af1/tempworkdir/tests /home/ubuntu/spr-fast/tests/corebench/coreutils/coreutils-case-7380cf79-2e636af1/tempworkdir 0  > __res
BasicTester, Testing instance id 333:
Running test command:
/home/ubuntu/spr-fast/tools/coreutils-test.py /home/ubuntu/spr-fast/tests/corebench/coreutils/coreutils-case-7380cf79-2e636af1/tempworkdir/src /home/ubuntu/spr-fast/tests/corebench/coreutils/coreutils-case-7380cf79-2e636af1/tempworkdir/tests /home/ubuntu/spr-fast/tests/corebench/coreutils/coreutils-case-7380cf79-2e636af1/tempworkdir 0  > __res
BasicTester, Testing instance id 334:
Running test command:
/home/ubuntu/spr-fast/tools/coreutils-test.py /home/ubuntu/spr-fast/tests/corebench/coreutils/coreutils-case-7380cf79-2e636af1/tempworkdir/src /home/ubuntu/spr-fast/tests/corebench/coreutils/coreutils-case-7380cf79-2e636af1/tempworkdir/tests /home/ubuntu/spr-fast/tests/corebench/coreutils/coreutils-case-7380cf79-2e636af1/tempworkdir 0  > __res
BasicTester, Testing instance id 335:
Running test command:
/home/ubuntu/spr-fast/tools/coreutils-test.py /home/ubuntu/spr-fast/tests/corebench/coreutils/coreutils-case-7380cf79-2e636af1/tempworkdir/src /home/ubuntu/spr-fast/tests/corebench/coreutils/coreutils-case-7380cf79-2e636af1/tempworkdir/tests /home/ubuntu/spr-fast/tests/corebench/coreutils/coreutils-case-7380cf79-2e636af1/tempworkdir 0  > __res
BasicTester, Testing instance id 336:
Running test command:
/home/ubuntu/spr-fast/tools/coreutils-test.py /home/ubuntu/spr-fast/tests/corebench/coreutils/coreutils-case-7380cf79-2e636af1/tempworkdir/src /home/ubuntu/spr-fast/tests/corebench/coreutils/coreutils-case-7380cf79-2e636af1/tempworkdir/tests /home/ubuntu/spr-fast/tests/corebench/coreutils/coreutils-case-7380cf79-2e636af1/tempworkdir 0  > __res
BasicTester, Testing instance id 337:
Running test command:
/home/ubuntu/spr-fast/tools/coreutils-test.py /home/ubuntu/spr-fast/tests/corebench/coreutils/coreutils-case-7380cf79-2e636af1/tempworkdir/src /home/ubuntu/spr-fast/tests/corebench/coreutils/coreutils-case-7380cf79-2e636af1/tempworkdir/tests /home/ubuntu/spr-fast/tests/corebench/coreutils/coreutils-case-7380cf79-2e636af1/tempworkdir 0  > __res
BasicTester, Testing instance id 338:
Running test command:
/home/ubuntu/spr-fast/tools/coreutils-test.py /home/ubuntu/spr-fast/tests/corebench/coreutils/coreutils-case-7380cf79-2e636af1/tempworkdir/src /home/ubuntu/spr-fast/tests/corebench/coreutils/coreutils-case-7380cf79-2e636af1/tempworkdir/tests /home/ubuntu/spr-fast/tests/corebench/coreutils/coreutils-case-7380cf79-2e636af1/tempworkdir 0  > __res
BasicTester, Testing instance id 339:
Running test command:
/home/ubuntu/spr-fast/tools/coreutils-test.py /home/ubuntu/spr-fast/tests/corebench/coreutils/coreutils-case-7380cf79-2e636af1/tempworkdir/src /home/ubuntu/spr-fast/tests/corebench/coreutils/coreutils-case-7380cf79-2e636af1/tempworkdir/tests /home/ubuntu/spr-fast/tests/corebench/coreutils/coreutils-case-7380cf79-2e636af1/tempworkdir 0  > __res
Counter: 390
Batcher Size:59
Preprocess the following candidate with BasicTester:
Priority 4991
At location src/cut.c:449
--Src File: src/cut.c
Fragment 0:
field_found = (rhs_specified);
break;


BasicTester, a patch instance with id 340:
Spawn 1 instances, now Total 390
Counter: 391
Batcher Size:60
Preprocess the following candidate with BasicTester:
Priority 4991
At location src/cut.c:449
--Src File: src/cut.c
Fragment 0:
field_found = 1;
break;


BasicTester, a patch instance with id 341:
Spawn 1 instances, now Total 391
Counter: 392
Batcher Size:61
Preprocess the following candidate with BasicTester:
Priority 4991
At location src/cut.c:449
--Src File: src/cut.c
Fragment 0:
error(0, (*__errno_location()), "-");
break;


BasicTester, a patch instance with id 342:
Spawn 1 instances, now Total 392
Counter: 393
Batcher Size:62
Preprocess the following candidate with BasicTester:
Priority 4991
At location src/cut.c:449
--Src File: src/cut.c
Fragment 0:
exit(1);
break;


BasicTester, a patch instance with id 343:
Spawn 1 instances, now Total 393
Counter: 394
Batcher Size:63
Preprocess the following candidate with BasicTester:
Priority 4991
At location src/cut.c:449
--Src File: src/cut.c
Fragment 0:
field_found = (dash_found);
break;


BasicTester, a patch instance with id 344:
Spawn 1 instances, now Total 394
Counter: 395
Batcher Size:64
Preprocess the following candidate with BasicTester:
Priority 4991
At location src/cut.c:449
--Src File: src/cut.c
Fragment 0:
field_found = (field_found);
break;


BasicTester, a patch instance with id 345:
Spawn 1 instances, now Total 395
Counter: 396
Batcher Size:65
Preprocess the following candidate with BasicTester:
Priority 4991
At location src/cut.c:449
--Src File: src/cut.c
Fragment 0:
field_1_buffer = ((void *)0);
break;


BasicTester, a patch instance with id 346:
Spawn 1 instances, now Total 396
Counter: 397
Batcher Size:66
Preprocess the following candidate with BasicTester:
Priority 4991
At location src/cut.c:449
--Src File: src/cut.c
Fragment 0:
exit(0);
break;


BasicTester, a patch instance with id 347:
Spawn 1 instances, now Total 397
Counter: 398
Batcher Size:67
Preprocess the following candidate with BasicTester:
Priority 4991
At location src/cut.c:449
--Src File: src/cut.c
Fragment 0:
(*__errno_location()) = (8);
break;


BasicTester, a patch instance with id 348:
Spawn 1 instances, now Total 398
Counter: 399
Batcher Size:68
Preprocess the following candidate with BasicTester:
Priority 4991
At location src/cut.c:449
--Src File: src/cut.c
Fragment 0:
delim = (1);
break;


BasicTester, a patch instance with id 349:
Spawn 1 instances, now Total 399
a batched test job starts!
Building:src at:
/home/ubuntu/spr-fast/tests/corebench/coreutils/coreutils-case-7380cf79-2e636af1/tempworkdir/srcMerged code building succ, going to invoke tester!
BasicTester, Testing instance id 340:
Running test command:
/home/ubuntu/spr-fast/tools/coreutils-test.py /home/ubuntu/spr-fast/tests/corebench/coreutils/coreutils-case-7380cf79-2e636af1/tempworkdir/src /home/ubuntu/spr-fast/tests/corebench/coreutils/coreutils-case-7380cf79-2e636af1/tempworkdir/tests /home/ubuntu/spr-fast/tests/corebench/coreutils/coreutils-case-7380cf79-2e636af1/tempworkdir 0  > __res
BasicTester, Testing instance id 341:
Running test command:
/home/ubuntu/spr-fast/tools/coreutils-test.py /home/ubuntu/spr-fast/tests/corebench/coreutils/coreutils-case-7380cf79-2e636af1/tempworkdir/src /home/ubuntu/spr-fast/tests/corebench/coreutils/coreutils-case-7380cf79-2e636af1/tempworkdir/tests /home/ubuntu/spr-fast/tests/corebench/coreutils/coreutils-case-7380cf79-2e636af1/tempworkdir 0  > __res
BasicTester, Testing instance id 342:
Running test command:
/home/ubuntu/spr-fast/tools/coreutils-test.py /home/ubuntu/spr-fast/tests/corebench/coreutils/coreutils-case-7380cf79-2e636af1/tempworkdir/src /home/ubuntu/spr-fast/tests/corebench/coreutils/coreutils-case-7380cf79-2e636af1/tempworkdir/tests /home/ubuntu/spr-fast/tests/corebench/coreutils/coreutils-case-7380cf79-2e636af1/tempworkdir 0  > __res
BasicTester, Testing instance id 343:
Running test command:
/home/ubuntu/spr-fast/tools/coreutils-test.py /home/ubuntu/spr-fast/tests/corebench/coreutils/coreutils-case-7380cf79-2e636af1/tempworkdir/src /home/ubuntu/spr-fast/tests/corebench/coreutils/coreutils-case-7380cf79-2e636af1/tempworkdir/tests /home/ubuntu/spr-fast/tests/corebench/coreutils/coreutils-case-7380cf79-2e636af1/tempworkdir 0  > __res
BasicTester, Testing instance id 344:
Running test command:
/home/ubuntu/spr-fast/tools/coreutils-test.py /home/ubuntu/spr-fast/tests/corebench/coreutils/coreutils-case-7380cf79-2e636af1/tempworkdir/src /home/ubuntu/spr-fast/tests/corebench/coreutils/coreutils-case-7380cf79-2e636af1/tempworkdir/tests /home/ubuntu/spr-fast/tests/corebench/coreutils/coreutils-case-7380cf79-2e636af1/tempworkdir 0  > __res
BasicTester, Testing instance id 345:
Running test command:
/home/ubuntu/spr-fast/tools/coreutils-test.py /home/ubuntu/spr-fast/tests/corebench/coreutils/coreutils-case-7380cf79-2e636af1/tempworkdir/src /home/ubuntu/spr-fast/tests/corebench/coreutils/coreutils-case-7380cf79-2e636af1/tempworkdir/tests /home/ubuntu/spr-fast/tests/corebench/coreutils/coreutils-case-7380cf79-2e636af1/tempworkdir 0  > __res
BasicTester, Testing instance id 346:
Running test command:
/home/ubuntu/spr-fast/tools/coreutils-test.py /home/ubuntu/spr-fast/tests/corebench/coreutils/coreutils-case-7380cf79-2e636af1/tempworkdir/src /home/ubuntu/spr-fast/tests/corebench/coreutils/coreutils-case-7380cf79-2e636af1/tempworkdir/tests /home/ubuntu/spr-fast/tests/corebench/coreutils/coreutils-case-7380cf79-2e636af1/tempworkdir 0  > __res
BasicTester, Testing instance id 347:
Running test command:
/home/ubuntu/spr-fast/tools/coreutils-test.py /home/ubuntu/spr-fast/tests/corebench/coreutils/coreutils-case-7380cf79-2e636af1/tempworkdir/src /home/ubuntu/spr-fast/tests/corebench/coreutils/coreutils-case-7380cf79-2e636af1/tempworkdir/tests /home/ubuntu/spr-fast/tests/corebench/coreutils/coreutils-case-7380cf79-2e636af1/tempworkdir 0  > __res
Passed Negative Cases with BasicTester
Running test command:
/home/ubuntu/spr-fast/tools/coreutils-test.py /home/ubuntu/spr-fast/tests/corebench/coreutils/coreutils-case-7380cf79-2e636af1/tempworkdir/src /home/ubuntu/spr-fast/tests/corebench/coreutils/coreutils-case-7380cf79-2e636af1/tempworkdir/tests /home/ubuntu/spr-fast/tests/corebench/coreutils/coreutils-case-7380cf79-2e636af1/tempworkdir 19  > __res
Failed positive case 19
BasicTester, Testing instance id 348:
Running test command:
/home/ubuntu/spr-fast/tools/coreutils-test.py /home/ubuntu/spr-fast/tests/corebench/coreutils/coreutils-case-7380cf79-2e636af1/tempworkdir/src /home/ubuntu/spr-fast/tests/corebench/coreutils/coreutils-case-7380cf79-2e636af1/tempworkdir/tests /home/ubuntu/spr-fast/tests/corebench/coreutils/coreutils-case-7380cf79-2e636af1/tempworkdir 0  > __res
BasicTester, Testing instance id 349:
Running test command:
/home/ubuntu/spr-fast/tools/coreutils-test.py /home/ubuntu/spr-fast/tests/corebench/coreutils/coreutils-case-7380cf79-2e636af1/tempworkdir/src /home/ubuntu/spr-fast/tests/corebench/coreutils/coreutils-case-7380cf79-2e636af1/tempworkdir/tests /home/ubuntu/spr-fast/tests/corebench/coreutils/coreutils-case-7380cf79-2e636af1/tempworkdir 0  > __res
Counter: 400
Batcher Size:59
Preprocess the following candidate with BasicTester:
Priority 4991
At location src/cut.c:449
--Src File: src/cut.c
Fragment 0:
eol_range_start = (10);
break;


BasicTester, a patch instance with id 350:
Spawn 1 instances, now Total 400
Counter: 401
Batcher Size:60
Preprocess the following candidate with BasicTester:
Priority 4991
At location src/cut.c:449
--Src File: src/cut.c
Fragment 0:
eol_range_start = (initial);
break;


BasicTester, a patch instance with id 351:
Spawn 1 instances, now Total 401
Counter: 402
Batcher Size:61
Preprocess the following candidate with BasicTester:
Priority 4991
At location src/cut.c:449
--Src File: src/cut.c
Fragment 0:
eol_range_start = (n_rp_allocated);
break;


BasicTester, a patch instance with id 352:
Spawn 1 instances, now Total 402
Counter: 403
Batcher Size:62
Preprocess the following candidate with BasicTester:
Priority 4991
At location src/cut.c:449
--Src File: src/cut.c
Fragment 0:
eol_range_start = (value);
break;


BasicTester, a patch instance with id 353:
Spawn 1 instances, now Total 403
Counter: 404
Batcher Size:63
Preprocess the following candidate with BasicTester:
Priority 4991
At location src/cut.c:449
--Src File: src/cut.c
Fragment 0:
eol_range_start = (n_rp);
break;


BasicTester, a patch instance with id 354:
Spawn 1 instances, now Total 404
Counter: 405
Batcher Size:64
Preprocess the following candidate with BasicTester:
Priority 4991
At location src/cut.c:449
--Src File: src/cut.c
Fragment 0:
eol_range_start = (8);
break;


BasicTester, a patch instance with id 355:
Spawn 1 instances, now Total 405
Counter: 406
Batcher Size:65
Preprocess the following candidate with BasicTester:
Priority 4991
At location src/cut.c:449
--Src File: src/cut.c
Fragment 0:
eol_range_start = (9);
break;


BasicTester, a patch instance with id 356:
Spawn 1 instances, now Total 406
Counter: 407
Batcher Size:66
Preprocess the following candidate with BasicTester:
Priority 4991
At location src/cut.c:449
--Src File: src/cut.c
Fragment 0:
eol_range_start = (i);
break;


BasicTester, a patch instance with id 357:
Spawn 1 instances, now Total 407
Counter: 408
Batcher Size:67
Preprocess the following candidate with BasicTester:
Priority 4991
At location src/cut.c:449
--Src File: src/cut.c
Fragment 0:
delim = (10);
break;


BasicTester, a patch instance with id 358:
Spawn 1 instances, now Total 408
Counter: 409
Batcher Size:68
Preprocess the following candidate with BasicTester:
Priority 4991
At location src/cut.c:449
--Src File: src/cut.c
Fragment 0:
emit_ancillary_info();
break;


BasicTester, a patch instance with id 359:
Spawn 1 instances, now Total 409
a batched test job starts!
Building:src at:
/home/ubuntu/spr-fast/tests/corebench/coreutils/coreutils-case-7380cf79-2e636af1/tempworkdir/srcMerged code building succ, going to invoke tester!
BasicTester, Testing instance id 350:
Running test command:
/home/ubuntu/spr-fast/tools/coreutils-test.py /home/ubuntu/spr-fast/tests/corebench/coreutils/coreutils-case-7380cf79-2e636af1/tempworkdir/src /home/ubuntu/spr-fast/tests/corebench/coreutils/coreutils-case-7380cf79-2e636af1/tempworkdir/tests /home/ubuntu/spr-fast/tests/corebench/coreutils/coreutils-case-7380cf79-2e636af1/tempworkdir 0  > __res
Passed Negative Cases with BasicTester
Running test command:
/home/ubuntu/spr-fast/tools/coreutils-test.py /home/ubuntu/spr-fast/tests/corebench/coreutils/coreutils-case-7380cf79-2e636af1/tempworkdir/src /home/ubuntu/spr-fast/tests/corebench/coreutils/coreutils-case-7380cf79-2e636af1/tempworkdir/tests /home/ubuntu/spr-fast/tests/corebench/coreutils/coreutils-case-7380cf79-2e636af1/tempworkdir 19  > __res
Failed positive case 19
BasicTester, Testing instance id 351:
Running test command:
/home/ubuntu/spr-fast/tools/coreutils-test.py /home/ubuntu/spr-fast/tests/corebench/coreutils/coreutils-case-7380cf79-2e636af1/tempworkdir/src /home/ubuntu/spr-fast/tests/corebench/coreutils/coreutils-case-7380cf79-2e636af1/tempworkdir/tests /home/ubuntu/spr-fast/tests/corebench/coreutils/coreutils-case-7380cf79-2e636af1/tempworkdir 0  > __res
BasicTester, Testing instance id 352:
Running test command:
/home/ubuntu/spr-fast/tools/coreutils-test.py /home/ubuntu/spr-fast/tests/corebench/coreutils/coreutils-case-7380cf79-2e636af1/tempworkdir/src /home/ubuntu/spr-fast/tests/corebench/coreutils/coreutils-case-7380cf79-2e636af1/tempworkdir/tests /home/ubuntu/spr-fast/tests/corebench/coreutils/coreutils-case-7380cf79-2e636af1/tempworkdir 0  > __res
Passed Negative Cases with BasicTester
Running test command:
/home/ubuntu/spr-fast/tools/coreutils-test.py /home/ubuntu/spr-fast/tests/corebench/coreutils/coreutils-case-7380cf79-2e636af1/tempworkdir/src /home/ubuntu/spr-fast/tests/corebench/coreutils/coreutils-case-7380cf79-2e636af1/tempworkdir/tests /home/ubuntu/spr-fast/tests/corebench/coreutils/coreutils-case-7380cf79-2e636af1/tempworkdir 19  > __res
Failed positive case 19
BasicTester, Testing instance id 353:
Running test command:
/home/ubuntu/spr-fast/tools/coreutils-test.py /home/ubuntu/spr-fast/tests/corebench/coreutils/coreutils-case-7380cf79-2e636af1/tempworkdir/src /home/ubuntu/spr-fast/tests/corebench/coreutils/coreutils-case-7380cf79-2e636af1/tempworkdir/tests /home/ubuntu/spr-fast/tests/corebench/coreutils/coreutils-case-7380cf79-2e636af1/tempworkdir 0  > __res
Passed Negative Cases with BasicTester
Running test command:
/home/ubuntu/spr-fast/tools/coreutils-test.py /home/ubuntu/spr-fast/tests/corebench/coreutils/coreutils-case-7380cf79-2e636af1/tempworkdir/src /home/ubuntu/spr-fast/tests/corebench/coreutils/coreutils-case-7380cf79-2e636af1/tempworkdir/tests /home/ubuntu/spr-fast/tests/corebench/coreutils/coreutils-case-7380cf79-2e636af1/tempworkdir 19  > __res
Running test command:
/home/ubuntu/spr-fast/tools/coreutils-test.py /home/ubuntu/spr-fast/tests/corebench/coreutils/coreutils-case-7380cf79-2e636af1/tempworkdir/src /home/ubuntu/spr-fast/tests/corebench/coreutils/coreutils-case-7380cf79-2e636af1/tempworkdir/tests /home/ubuntu/spr-fast/tests/corebench/coreutils/coreutils-case-7380cf79-2e636af1/tempworkdir 3  > __res
Running test command:
/home/ubuntu/spr-fast/tools/coreutils-test.py /home/ubuntu/spr-fast/tests/corebench/coreutils/coreutils-case-7380cf79-2e636af1/tempworkdir/src /home/ubuntu/spr-fast/tests/corebench/coreutils/coreutils-case-7380cf79-2e636af1/tempworkdir/tests /home/ubuntu/spr-fast/tests/corebench/coreutils/coreutils-case-7380cf79-2e636af1/tempworkdir 4  > __res
Running test command:
/home/ubuntu/spr-fast/tools/coreutils-test.py /home/ubuntu/spr-fast/tests/corebench/coreutils/coreutils-case-7380cf79-2e636af1/tempworkdir/src /home/ubuntu/spr-fast/tests/corebench/coreutils/coreutils-case-7380cf79-2e636af1/tempworkdir/tests /home/ubuntu/spr-fast/tests/corebench/coreutils/coreutils-case-7380cf79-2e636af1/tempworkdir 7  > __res
Running test command:
/home/ubuntu/spr-fast/tools/coreutils-test.py /home/ubuntu/spr-fast/tests/corebench/coreutils/coreutils-case-7380cf79-2e636af1/tempworkdir/src /home/ubuntu/spr-fast/tests/corebench/coreutils/coreutils-case-7380cf79-2e636af1/tempworkdir/tests /home/ubuntu/spr-fast/tests/corebench/coreutils/coreutils-case-7380cf79-2e636af1/tempworkdir 8  > __res
Running test command:
/home/ubuntu/spr-fast/tools/coreutils-test.py /home/ubuntu/spr-fast/tests/corebench/coreutils/coreutils-case-7380cf79-2e636af1/tempworkdir/src /home/ubuntu/spr-fast/tests/corebench/coreutils/coreutils-case-7380cf79-2e636af1/tempworkdir/tests /home/ubuntu/spr-fast/tests/corebench/coreutils/coreutils-case-7380cf79-2e636af1/tempworkdir 10  > __res
Running test command:
/home/ubuntu/spr-fast/tools/coreutils-test.py /home/ubuntu/spr-fast/tests/corebench/coreutils/coreutils-case-7380cf79-2e636af1/tempworkdir/src /home/ubuntu/spr-fast/tests/corebench/coreutils/coreutils-case-7380cf79-2e636af1/tempworkdir/tests /home/ubuntu/spr-fast/tests/corebench/coreutils/coreutils-case-7380cf79-2e636af1/tempworkdir 14  > __res
Running test command:
/home/ubuntu/spr-fast/tools/coreutils-test.py /home/ubuntu/spr-fast/tests/corebench/coreutils/coreutils-case-7380cf79-2e636af1/tempworkdir/src /home/ubuntu/spr-fast/tests/corebench/coreutils/coreutils-case-7380cf79-2e636af1/tempworkdir/tests /home/ubuntu/spr-fast/tests/corebench/coreutils/coreutils-case-7380cf79-2e636af1/tempworkdir 16  > __res
Running test command:
/home/ubuntu/spr-fast/tools/coreutils-test.py /home/ubuntu/spr-fast/tests/corebench/coreutils/coreutils-case-7380cf79-2e636af1/tempworkdir/src /home/ubuntu/spr-fast/tests/corebench/coreutils/coreutils-case-7380cf79-2e636af1/tempworkdir/tests /home/ubuntu/spr-fast/tests/corebench/coreutils/coreutils-case-7380cf79-2e636af1/tempworkdir 18  > __res
Running test command:
/home/ubuntu/spr-fast/tools/coreutils-test.py /home/ubuntu/spr-fast/tests/corebench/coreutils/coreutils-case-7380cf79-2e636af1/tempworkdir/src /home/ubuntu/spr-fast/tests/corebench/coreutils/coreutils-case-7380cf79-2e636af1/tempworkdir/tests /home/ubuntu/spr-fast/tests/corebench/coreutils/coreutils-case-7380cf79-2e636af1/tempworkdir 20  > __res
Running test command:
/home/ubuntu/spr-fast/tools/coreutils-test.py /home/ubuntu/spr-fast/tests/corebench/coreutils/coreutils-case-7380cf79-2e636af1/tempworkdir/src /home/ubuntu/spr-fast/tests/corebench/coreutils/coreutils-case-7380cf79-2e636af1/tempworkdir/tests /home/ubuntu/spr-fast/tests/corebench/coreutils/coreutils-case-7380cf79-2e636af1/tempworkdir 21  > __res
Running test command:
/home/ubuntu/spr-fast/tools/coreutils-test.py /home/ubuntu/spr-fast/tests/corebench/coreutils/coreutils-case-7380cf79-2e636af1/tempworkdir/src /home/ubuntu/spr-fast/tests/corebench/coreutils/coreutils-case-7380cf79-2e636af1/tempworkdir/tests /home/ubuntu/spr-fast/tests/corebench/coreutils/coreutils-case-7380cf79-2e636af1/tempworkdir 22  > __res
Running test command:
/home/ubuntu/spr-fast/tools/coreutils-test.py /home/ubuntu/spr-fast/tests/corebench/coreutils/coreutils-case-7380cf79-2e636af1/tempworkdir/src /home/ubuntu/spr-fast/tests/corebench/coreutils/coreutils-case-7380cf79-2e636af1/tempworkdir/tests /home/ubuntu/spr-fast/tests/corebench/coreutils/coreutils-case-7380cf79-2e636af1/tempworkdir 24  > __res
Running test command:
/home/ubuntu/spr-fast/tools/coreutils-test.py /home/ubuntu/spr-fast/tests/corebench/coreutils/coreutils-case-7380cf79-2e636af1/tempworkdir/src /home/ubuntu/spr-fast/tests/corebench/coreutils/coreutils-case-7380cf79-2e636af1/tempworkdir/tests /home/ubuntu/spr-fast/tests/corebench/coreutils/coreutils-case-7380cf79-2e636af1/tempworkdir 25  > __res
Running test command:
/home/ubuntu/spr-fast/tools/coreutils-test.py /home/ubuntu/spr-fast/tests/corebench/coreutils/coreutils-case-7380cf79-2e636af1/tempworkdir/src /home/ubuntu/spr-fast/tests/corebench/coreutils/coreutils-case-7380cf79-2e636af1/tempworkdir/tests /home/ubuntu/spr-fast/tests/corebench/coreutils/coreutils-case-7380cf79-2e636af1/tempworkdir 26  > __res
Running test command:
/home/ubuntu/spr-fast/tools/coreutils-test.py /home/ubuntu/spr-fast/tests/corebench/coreutils/coreutils-case-7380cf79-2e636af1/tempworkdir/src /home/ubuntu/spr-fast/tests/corebench/coreutils/coreutils-case-7380cf79-2e636af1/tempworkdir/tests /home/ubuntu/spr-fast/tests/corebench/coreutils/coreutils-case-7380cf79-2e636af1/tempworkdir 27  > __res
Running test command:
/home/ubuntu/spr-fast/tools/coreutils-test.py /home/ubuntu/spr-fast/tests/corebench/coreutils/coreutils-case-7380cf79-2e636af1/tempworkdir/src /home/ubuntu/spr-fast/tests/corebench/coreutils/coreutils-case-7380cf79-2e636af1/tempworkdir/tests /home/ubuntu/spr-fast/tests/corebench/coreutils/coreutils-case-7380cf79-2e636af1/tempworkdir 32  > __res
Running test command:
/home/ubuntu/spr-fast/tools/coreutils-test.py /home/ubuntu/spr-fast/tests/corebench/coreutils/coreutils-case-7380cf79-2e636af1/tempworkdir/src /home/ubuntu/spr-fast/tests/corebench/coreutils/coreutils-case-7380cf79-2e636af1/tempworkdir/tests /home/ubuntu/spr-fast/tests/corebench/coreutils/coreutils-case-7380cf79-2e636af1/tempworkdir 34  > __res
Running test command:
/home/ubuntu/spr-fast/tools/coreutils-test.py /home/ubuntu/spr-fast/tests/corebench/coreutils/coreutils-case-7380cf79-2e636af1/tempworkdir/src /home/ubuntu/spr-fast/tests/corebench/coreutils/coreutils-case-7380cf79-2e636af1/tempworkdir/tests /home/ubuntu/spr-fast/tests/corebench/coreutils/coreutils-case-7380cf79-2e636af1/tempworkdir 38  > __res
Running test command:
/home/ubuntu/spr-fast/tools/coreutils-test.py /home/ubuntu/spr-fast/tests/corebench/coreutils/coreutils-case-7380cf79-2e636af1/tempworkdir/src /home/ubuntu/spr-fast/tests/corebench/coreutils/coreutils-case-7380cf79-2e636af1/tempworkdir/tests /home/ubuntu/spr-fast/tests/corebench/coreutils/coreutils-case-7380cf79-2e636af1/tempworkdir 40  > __res
Passed Positive Cases
Passed!
BasicTester, Testing instance id 354:
Running test command:
/home/ubuntu/spr-fast/tools/coreutils-test.py /home/ubuntu/spr-fast/tests/corebench/coreutils/coreutils-case-7380cf79-2e636af1/tempworkdir/src /home/ubuntu/spr-fast/tests/corebench/coreutils/coreutils-case-7380cf79-2e636af1/tempworkdir/tests /home/ubuntu/spr-fast/tests/corebench/coreutils/coreutils-case-7380cf79-2e636af1/tempworkdir 0  > __res
Passed Negative Cases with BasicTester
Running test command:
/home/ubuntu/spr-fast/tools/coreutils-test.py /home/ubuntu/spr-fast/tests/corebench/coreutils/coreutils-case-7380cf79-2e636af1/tempworkdir/src /home/ubuntu/spr-fast/tests/corebench/coreutils/coreutils-case-7380cf79-2e636af1/tempworkdir/tests /home/ubuntu/spr-fast/tests/corebench/coreutils/coreutils-case-7380cf79-2e636af1/tempworkdir 19  > __res
Failed positive case 19
BasicTester, Testing instance id 355:
Running test command:
/home/ubuntu/spr-fast/tools/coreutils-test.py /home/ubuntu/spr-fast/tests/corebench/coreutils/coreutils-case-7380cf79-2e636af1/tempworkdir/src /home/ubuntu/spr-fast/tests/corebench/coreutils/coreutils-case-7380cf79-2e636af1/tempworkdir/tests /home/ubuntu/spr-fast/tests/corebench/coreutils/coreutils-case-7380cf79-2e636af1/tempworkdir 0  > __res
Passed Negative Cases with BasicTester
Running test command:
/home/ubuntu/spr-fast/tools/coreutils-test.py /home/ubuntu/spr-fast/tests/corebench/coreutils/coreutils-case-7380cf79-2e636af1/tempworkdir/src /home/ubuntu/spr-fast/tests/corebench/coreutils/coreutils-case-7380cf79-2e636af1/tempworkdir/tests /home/ubuntu/spr-fast/tests/corebench/coreutils/coreutils-case-7380cf79-2e636af1/tempworkdir 19  > __res
Failed positive case 19
BasicTester, Testing instance id 356:
Running test command:
/home/ubuntu/spr-fast/tools/coreutils-test.py /home/ubuntu/spr-fast/tests/corebench/coreutils/coreutils-case-7380cf79-2e636af1/tempworkdir/src /home/ubuntu/spr-fast/tests/corebench/coreutils/coreutils-case-7380cf79-2e636af1/tempworkdir/tests /home/ubuntu/spr-fast/tests/corebench/coreutils/coreutils-case-7380cf79-2e636af1/tempworkdir 0  > __res
Passed Negative Cases with BasicTester
Running test command:
/home/ubuntu/spr-fast/tools/coreutils-test.py /home/ubuntu/spr-fast/tests/corebench/coreutils/coreutils-case-7380cf79-2e636af1/tempworkdir/src /home/ubuntu/spr-fast/tests/corebench/coreutils/coreutils-case-7380cf79-2e636af1/tempworkdir/tests /home/ubuntu/spr-fast/tests/corebench/coreutils/coreutils-case-7380cf79-2e636af1/tempworkdir 19  > __res
Failed positive case 19
BasicTester, Testing instance id 357:
Running test command:
/home/ubuntu/spr-fast/tools/coreutils-test.py /home/ubuntu/spr-fast/tests/corebench/coreutils/coreutils-case-7380cf79-2e636af1/tempworkdir/src /home/ubuntu/spr-fast/tests/corebench/coreutils/coreutils-case-7380cf79-2e636af1/tempworkdir/tests /home/ubuntu/spr-fast/tests/corebench/coreutils/coreutils-case-7380cf79-2e636af1/tempworkdir 0  > __res
Passed Negative Cases with BasicTester
Running test command:
/home/ubuntu/spr-fast/tools/coreutils-test.py /home/ubuntu/spr-fast/tests/corebench/coreutils/coreutils-case-7380cf79-2e636af1/tempworkdir/src /home/ubuntu/spr-fast/tests/corebench/coreutils/coreutils-case-7380cf79-2e636af1/tempworkdir/tests /home/ubuntu/spr-fast/tests/corebench/coreutils/coreutils-case-7380cf79-2e636af1/tempworkdir 19  > __res
Running test command:
/home/ubuntu/spr-fast/tools/coreutils-test.py /home/ubuntu/spr-fast/tests/corebench/coreutils/coreutils-case-7380cf79-2e636af1/tempworkdir/src /home/ubuntu/spr-fast/tests/corebench/coreutils/coreutils-case-7380cf79-2e636af1/tempworkdir/tests /home/ubuntu/spr-fast/tests/corebench/coreutils/coreutils-case-7380cf79-2e636af1/tempworkdir 3  > __res
Running test command:
/home/ubuntu/spr-fast/tools/coreutils-test.py /home/ubuntu/spr-fast/tests/corebench/coreutils/coreutils-case-7380cf79-2e636af1/tempworkdir/src /home/ubuntu/spr-fast/tests/corebench/coreutils/coreutils-case-7380cf79-2e636af1/tempworkdir/tests /home/ubuntu/spr-fast/tests/corebench/coreutils/coreutils-case-7380cf79-2e636af1/tempworkdir 4  > __res
Running test command:
/home/ubuntu/spr-fast/tools/coreutils-test.py /home/ubuntu/spr-fast/tests/corebench/coreutils/coreutils-case-7380cf79-2e636af1/tempworkdir/src /home/ubuntu/spr-fast/tests/corebench/coreutils/coreutils-case-7380cf79-2e636af1/tempworkdir/tests /home/ubuntu/spr-fast/tests/corebench/coreutils/coreutils-case-7380cf79-2e636af1/tempworkdir 7  > __res
Running test command:
/home/ubuntu/spr-fast/tools/coreutils-test.py /home/ubuntu/spr-fast/tests/corebench/coreutils/coreutils-case-7380cf79-2e636af1/tempworkdir/src /home/ubuntu/spr-fast/tests/corebench/coreutils/coreutils-case-7380cf79-2e636af1/tempworkdir/tests /home/ubuntu/spr-fast/tests/corebench/coreutils/coreutils-case-7380cf79-2e636af1/tempworkdir 8  > __res
Running test command:
/home/ubuntu/spr-fast/tools/coreutils-test.py /home/ubuntu/spr-fast/tests/corebench/coreutils/coreutils-case-7380cf79-2e636af1/tempworkdir/src /home/ubuntu/spr-fast/tests/corebench/coreutils/coreutils-case-7380cf79-2e636af1/tempworkdir/tests /home/ubuntu/spr-fast/tests/corebench/coreutils/coreutils-case-7380cf79-2e636af1/tempworkdir 10  > __res
Running test command:
/home/ubuntu/spr-fast/tools/coreutils-test.py /home/ubuntu/spr-fast/tests/corebench/coreutils/coreutils-case-7380cf79-2e636af1/tempworkdir/src /home/ubuntu/spr-fast/tests/corebench/coreutils/coreutils-case-7380cf79-2e636af1/tempworkdir/tests /home/ubuntu/spr-fast/tests/corebench/coreutils/coreutils-case-7380cf79-2e636af1/tempworkdir 14  > __res
Running test command:
/home/ubuntu/spr-fast/tools/coreutils-test.py /home/ubuntu/spr-fast/tests/corebench/coreutils/coreutils-case-7380cf79-2e636af1/tempworkdir/src /home/ubuntu/spr-fast/tests/corebench/coreutils/coreutils-case-7380cf79-2e636af1/tempworkdir/tests /home/ubuntu/spr-fast/tests/corebench/coreutils/coreutils-case-7380cf79-2e636af1/tempworkdir 16  > __res
Running test command:
/home/ubuntu/spr-fast/tools/coreutils-test.py /home/ubuntu/spr-fast/tests/corebench/coreutils/coreutils-case-7380cf79-2e636af1/tempworkdir/src /home/ubuntu/spr-fast/tests/corebench/coreutils/coreutils-case-7380cf79-2e636af1/tempworkdir/tests /home/ubuntu/spr-fast/tests/corebench/coreutils/coreutils-case-7380cf79-2e636af1/tempworkdir 18  > __res
Running test command:
/home/ubuntu/spr-fast/tools/coreutils-test.py /home/ubuntu/spr-fast/tests/corebench/coreutils/coreutils-case-7380cf79-2e636af1/tempworkdir/src /home/ubuntu/spr-fast/tests/corebench/coreutils/coreutils-case-7380cf79-2e636af1/tempworkdir/tests /home/ubuntu/spr-fast/tests/corebench/coreutils/coreutils-case-7380cf79-2e636af1/tempworkdir 20  > __res
Running test command:
/home/ubuntu/spr-fast/tools/coreutils-test.py /home/ubuntu/spr-fast/tests/corebench/coreutils/coreutils-case-7380cf79-2e636af1/tempworkdir/src /home/ubuntu/spr-fast/tests/corebench/coreutils/coreutils-case-7380cf79-2e636af1/tempworkdir/tests /home/ubuntu/spr-fast/tests/corebench/coreutils/coreutils-case-7380cf79-2e636af1/tempworkdir 21  > __res
Running test command:
/home/ubuntu/spr-fast/tools/coreutils-test.py /home/ubuntu/spr-fast/tests/corebench/coreutils/coreutils-case-7380cf79-2e636af1/tempworkdir/src /home/ubuntu/spr-fast/tests/corebench/coreutils/coreutils-case-7380cf79-2e636af1/tempworkdir/tests /home/ubuntu/spr-fast/tests/corebench/coreutils/coreutils-case-7380cf79-2e636af1/tempworkdir 22  > __res
Running test command:
/home/ubuntu/spr-fast/tools/coreutils-test.py /home/ubuntu/spr-fast/tests/corebench/coreutils/coreutils-case-7380cf79-2e636af1/tempworkdir/src /home/ubuntu/spr-fast/tests/corebench/coreutils/coreutils-case-7380cf79-2e636af1/tempworkdir/tests /home/ubuntu/spr-fast/tests/corebench/coreutils/coreutils-case-7380cf79-2e636af1/tempworkdir 24  > __res
Running test command:
/home/ubuntu/spr-fast/tools/coreutils-test.py /home/ubuntu/spr-fast/tests/corebench/coreutils/coreutils-case-7380cf79-2e636af1/tempworkdir/src /home/ubuntu/spr-fast/tests/corebench/coreutils/coreutils-case-7380cf79-2e636af1/tempworkdir/tests /home/ubuntu/spr-fast/tests/corebench/coreutils/coreutils-case-7380cf79-2e636af1/tempworkdir 25  > __res
Running test command:
/home/ubuntu/spr-fast/tools/coreutils-test.py /home/ubuntu/spr-fast/tests/corebench/coreutils/coreutils-case-7380cf79-2e636af1/tempworkdir/src /home/ubuntu/spr-fast/tests/corebench/coreutils/coreutils-case-7380cf79-2e636af1/tempworkdir/tests /home/ubuntu/spr-fast/tests/corebench/coreutils/coreutils-case-7380cf79-2e636af1/tempworkdir 26  > __res
Running test command:
/home/ubuntu/spr-fast/tools/coreutils-test.py /home/ubuntu/spr-fast/tests/corebench/coreutils/coreutils-case-7380cf79-2e636af1/tempworkdir/src /home/ubuntu/spr-fast/tests/corebench/coreutils/coreutils-case-7380cf79-2e636af1/tempworkdir/tests /home/ubuntu/spr-fast/tests/corebench/coreutils/coreutils-case-7380cf79-2e636af1/tempworkdir 27  > __res
Running test command:
/home/ubuntu/spr-fast/tools/coreutils-test.py /home/ubuntu/spr-fast/tests/corebench/coreutils/coreutils-case-7380cf79-2e636af1/tempworkdir/src /home/ubuntu/spr-fast/tests/corebench/coreutils/coreutils-case-7380cf79-2e636af1/tempworkdir/tests /home/ubuntu/spr-fast/tests/corebench/coreutils/coreutils-case-7380cf79-2e636af1/tempworkdir 32  > __res
Running test command:
/home/ubuntu/spr-fast/tools/coreutils-test.py /home/ubuntu/spr-fast/tests/corebench/coreutils/coreutils-case-7380cf79-2e636af1/tempworkdir/src /home/ubuntu/spr-fast/tests/corebench/coreutils/coreutils-case-7380cf79-2e636af1/tempworkdir/tests /home/ubuntu/spr-fast/tests/corebench/coreutils/coreutils-case-7380cf79-2e636af1/tempworkdir 34  > __res
Running test command:
/home/ubuntu/spr-fast/tools/coreutils-test.py /home/ubuntu/spr-fast/tests/corebench/coreutils/coreutils-case-7380cf79-2e636af1/tempworkdir/src /home/ubuntu/spr-fast/tests/corebench/coreutils/coreutils-case-7380cf79-2e636af1/tempworkdir/tests /home/ubuntu/spr-fast/tests/corebench/coreutils/coreutils-case-7380cf79-2e636af1/tempworkdir 38  > __res
Running test command:
/home/ubuntu/spr-fast/tools/coreutils-test.py /home/ubuntu/spr-fast/tests/corebench/coreutils/coreutils-case-7380cf79-2e636af1/tempworkdir/src /home/ubuntu/spr-fast/tests/corebench/coreutils/coreutils-case-7380cf79-2e636af1/tempworkdir/tests /home/ubuntu/spr-fast/tests/corebench/coreutils/coreutils-case-7380cf79-2e636af1/tempworkdir 40  > __res
Passed Positive Cases
Passed!
BasicTester, Testing instance id 358:
Running test command:
/home/ubuntu/spr-fast/tools/coreutils-test.py /home/ubuntu/spr-fast/tests/corebench/coreutils/coreutils-case-7380cf79-2e636af1/tempworkdir/src /home/ubuntu/spr-fast/tests/corebench/coreutils/coreutils-case-7380cf79-2e636af1/tempworkdir/tests /home/ubuntu/spr-fast/tests/corebench/coreutils/coreutils-case-7380cf79-2e636af1/tempworkdir 0  > __res
BasicTester, Testing instance id 359:
Running test command:
/home/ubuntu/spr-fast/tools/coreutils-test.py /home/ubuntu/spr-fast/tests/corebench/coreutils/coreutils-case-7380cf79-2e636af1/tempworkdir/src /home/ubuntu/spr-fast/tests/corebench/coreutils/coreutils-case-7380cf79-2e636af1/tempworkdir/tests /home/ubuntu/spr-fast/tests/corebench/coreutils/coreutils-case-7380cf79-2e636af1/tempworkdir 0  > __res
Update best score 4990647.000000
a batched test job starts!
Building:src at:
/home/ubuntu/spr-fast/tests/corebench/coreutils/coreutils-case-7380cf79-2e636af1/tempworkdir/srcMerged code building succ, going to invoke tester!
BasicTester, Testing instance id 50:
Running test command:
/home/ubuntu/spr-fast/tools/coreutils-test.py /home/ubuntu/spr-fast/tests/corebench/coreutils/coreutils-case-7380cf79-2e636af1/tempworkdir/src /home/ubuntu/spr-fast/tests/corebench/coreutils/coreutils-case-7380cf79-2e636af1/tempworkdir/tests /home/ubuntu/spr-fast/tests/corebench/coreutils/coreutils-case-7380cf79-2e636af1/tempworkdir 0  > __res
BasicTester, Testing instance id 51:
Running test command:
/home/ubuntu/spr-fast/tools/coreutils-test.py /home/ubuntu/spr-fast/tests/corebench/coreutils/coreutils-case-7380cf79-2e636af1/tempworkdir/src /home/ubuntu/spr-fast/tests/corebench/coreutils/coreutils-case-7380cf79-2e636af1/tempworkdir/tests /home/ubuntu/spr-fast/tests/corebench/coreutils/coreutils-case-7380cf79-2e636af1/tempworkdir 0  > __res
BasicTester, Testing instance id 52:
Running test command:
/home/ubuntu/spr-fast/tools/coreutils-test.py /home/ubuntu/spr-fast/tests/corebench/coreutils/coreutils-case-7380cf79-2e636af1/tempworkdir/src /home/ubuntu/spr-fast/tests/corebench/coreutils/coreutils-case-7380cf79-2e636af1/tempworkdir/tests /home/ubuntu/spr-fast/tests/corebench/coreutils/coreutils-case-7380cf79-2e636af1/tempworkdir 0  > __res
CondTester, Testing instance id 40:
Running test command:
/home/ubuntu/spr-fast/tools/coreutils-test.py /home/ubuntu/spr-fast/tests/corebench/coreutils/coreutils-case-7380cf79-2e636af1/tempworkdir/src /home/ubuntu/spr-fast/tests/corebench/coreutils/coreutils-case-7380cf79-2e636af1/tempworkdir/tests /home/ubuntu/spr-fast/tests/corebench/coreutils/coreutils-case-7380cf79-2e636af1/tempworkdir 0  > __res
Running test command:
/home/ubuntu/spr-fast/tools/coreutils-test.py /home/ubuntu/spr-fast/tests/corebench/coreutils/coreutils-case-7380cf79-2e636af1/tempworkdir/src /home/ubuntu/spr-fast/tests/corebench/coreutils/coreutils-case-7380cf79-2e636af1/tempworkdir/tests /home/ubuntu/spr-fast/tests/corebench/coreutils/coreutils-case-7380cf79-2e636af1/tempworkdir 0  > __res
Running test command:
/home/ubuntu/spr-fast/tools/coreutils-test.py /home/ubuntu/spr-fast/tests/corebench/coreutils/coreutils-case-7380cf79-2e636af1/tempworkdir/src /home/ubuntu/spr-fast/tests/corebench/coreutils/coreutils-case-7380cf79-2e636af1/tempworkdir/tests /home/ubuntu/spr-fast/tests/corebench/coreutils/coreutils-case-7380cf79-2e636af1/tempworkdir 0  > __res
Passed Negative Cases wiht CondTestder!
Running test command:
/home/ubuntu/spr-fast/tools/coreutils-test.py /home/ubuntu/spr-fast/tests/corebench/coreutils/coreutils-case-7380cf79-2e636af1/tempworkdir/src /home/ubuntu/spr-fast/tests/corebench/coreutils/coreutils-case-7380cf79-2e636af1/tempworkdir/tests /home/ubuntu/spr-fast/tests/corebench/coreutils/coreutils-case-7380cf79-2e636af1/tempworkdir 3  > __res
Running test command:
/home/ubuntu/spr-fast/tools/coreutils-test.py /home/ubuntu/spr-fast/tests/corebench/coreutils/coreutils-case-7380cf79-2e636af1/tempworkdir/src /home/ubuntu/spr-fast/tests/corebench/coreutils/coreutils-case-7380cf79-2e636af1/tempworkdir/tests /home/ubuntu/spr-fast/tests/corebench/coreutils/coreutils-case-7380cf79-2e636af1/tempworkdir 4  > __res
Running test command:
/home/ubuntu/spr-fast/tools/coreutils-test.py /home/ubuntu/spr-fast/tests/corebench/coreutils/coreutils-case-7380cf79-2e636af1/tempworkdir/src /home/ubuntu/spr-fast/tests/corebench/coreutils/coreutils-case-7380cf79-2e636af1/tempworkdir/tests /home/ubuntu/spr-fast/tests/corebench/coreutils/coreutils-case-7380cf79-2e636af1/tempworkdir 7  > __res
Running test command:
/home/ubuntu/spr-fast/tools/coreutils-test.py /home/ubuntu/spr-fast/tests/corebench/coreutils/coreutils-case-7380cf79-2e636af1/tempworkdir/src /home/ubuntu/spr-fast/tests/corebench/coreutils/coreutils-case-7380cf79-2e636af1/tempworkdir/tests /home/ubuntu/spr-fast/tests/corebench/coreutils/coreutils-case-7380cf79-2e636af1/tempworkdir 8  > __res
Running test command:
/home/ubuntu/spr-fast/tools/coreutils-test.py /home/ubuntu/spr-fast/tests/corebench/coreutils/coreutils-case-7380cf79-2e636af1/tempworkdir/src /home/ubuntu/spr-fast/tests/corebench/coreutils/coreutils-case-7380cf79-2e636af1/tempworkdir/tests /home/ubuntu/spr-fast/tests/corebench/coreutils/coreutils-case-7380cf79-2e636af1/tempworkdir 10  > __res
Running test command:
/home/ubuntu/spr-fast/tools/coreutils-test.py /home/ubuntu/spr-fast/tests/corebench/coreutils/coreutils-case-7380cf79-2e636af1/tempworkdir/src /home/ubuntu/spr-fast/tests/corebench/coreutils/coreutils-case-7380cf79-2e636af1/tempworkdir/tests /home/ubuntu/spr-fast/tests/corebench/coreutils/coreutils-case-7380cf79-2e636af1/tempworkdir 14  > __res
Running test command:
/home/ubuntu/spr-fast/tools/coreutils-test.py /home/ubuntu/spr-fast/tests/corebench/coreutils/coreutils-case-7380cf79-2e636af1/tempworkdir/src /home/ubuntu/spr-fast/tests/corebench/coreutils/coreutils-case-7380cf79-2e636af1/tempworkdir/tests /home/ubuntu/spr-fast/tests/corebench/coreutils/coreutils-case-7380cf79-2e636af1/tempworkdir 16  > __res
Running test command:
/home/ubuntu/spr-fast/tools/coreutils-test.py /home/ubuntu/spr-fast/tests/corebench/coreutils/coreutils-case-7380cf79-2e636af1/tempworkdir/src /home/ubuntu/spr-fast/tests/corebench/coreutils/coreutils-case-7380cf79-2e636af1/tempworkdir/tests /home/ubuntu/spr-fast/tests/corebench/coreutils/coreutils-case-7380cf79-2e636af1/tempworkdir 18  > __res
Running test command:
/home/ubuntu/spr-fast/tools/coreutils-test.py /home/ubuntu/spr-fast/tests/corebench/coreutils/coreutils-case-7380cf79-2e636af1/tempworkdir/src /home/ubuntu/spr-fast/tests/corebench/coreutils/coreutils-case-7380cf79-2e636af1/tempworkdir/tests /home/ubuntu/spr-fast/tests/corebench/coreutils/coreutils-case-7380cf79-2e636af1/tempworkdir 19  > __res
Running test command:
/home/ubuntu/spr-fast/tools/coreutils-test.py /home/ubuntu/spr-fast/tests/corebench/coreutils/coreutils-case-7380cf79-2e636af1/tempworkdir/src /home/ubuntu/spr-fast/tests/corebench/coreutils/coreutils-case-7380cf79-2e636af1/tempworkdir/tests /home/ubuntu/spr-fast/tests/corebench/coreutils/coreutils-case-7380cf79-2e636af1/tempworkdir 20  > __res
Running test command:
/home/ubuntu/spr-fast/tools/coreutils-test.py /home/ubuntu/spr-fast/tests/corebench/coreutils/coreutils-case-7380cf79-2e636af1/tempworkdir/src /home/ubuntu/spr-fast/tests/corebench/coreutils/coreutils-case-7380cf79-2e636af1/tempworkdir/tests /home/ubuntu/spr-fast/tests/corebench/coreutils/coreutils-case-7380cf79-2e636af1/tempworkdir 21  > __res
Running test command:
/home/ubuntu/spr-fast/tools/coreutils-test.py /home/ubuntu/spr-fast/tests/corebench/coreutils/coreutils-case-7380cf79-2e636af1/tempworkdir/src /home/ubuntu/spr-fast/tests/corebench/coreutils/coreutils-case-7380cf79-2e636af1/tempworkdir/tests /home/ubuntu/spr-fast/tests/corebench/coreutils/coreutils-case-7380cf79-2e636af1/tempworkdir 22  > __res
Running test command:
/home/ubuntu/spr-fast/tools/coreutils-test.py /home/ubuntu/spr-fast/tests/corebench/coreutils/coreutils-case-7380cf79-2e636af1/tempworkdir/src /home/ubuntu/spr-fast/tests/corebench/coreutils/coreutils-case-7380cf79-2e636af1/tempworkdir/tests /home/ubuntu/spr-fast/tests/corebench/coreutils/coreutils-case-7380cf79-2e636af1/tempworkdir 24  > __res
Running test command:
/home/ubuntu/spr-fast/tools/coreutils-test.py /home/ubuntu/spr-fast/tests/corebench/coreutils/coreutils-case-7380cf79-2e636af1/tempworkdir/src /home/ubuntu/spr-fast/tests/corebench/coreutils/coreutils-case-7380cf79-2e636af1/tempworkdir/tests /home/ubuntu/spr-fast/tests/corebench/coreutils/coreutils-case-7380cf79-2e636af1/tempworkdir 25  > __res
Running test command:
/home/ubuntu/spr-fast/tools/coreutils-test.py /home/ubuntu/spr-fast/tests/corebench/coreutils/coreutils-case-7380cf79-2e636af1/tempworkdir/src /home/ubuntu/spr-fast/tests/corebench/coreutils/coreutils-case-7380cf79-2e636af1/tempworkdir/tests /home/ubuntu/spr-fast/tests/corebench/coreutils/coreutils-case-7380cf79-2e636af1/tempworkdir 26  > __res
Running test command:
/home/ubuntu/spr-fast/tools/coreutils-test.py /home/ubuntu/spr-fast/tests/corebench/coreutils/coreutils-case-7380cf79-2e636af1/tempworkdir/src /home/ubuntu/spr-fast/tests/corebench/coreutils/coreutils-case-7380cf79-2e636af1/tempworkdir/tests /home/ubuntu/spr-fast/tests/corebench/coreutils/coreutils-case-7380cf79-2e636af1/tempworkdir 27  > __res
Running test command:
/home/ubuntu/spr-fast/tools/coreutils-test.py /home/ubuntu/spr-fast/tests/corebench/coreutils/coreutils-case-7380cf79-2e636af1/tempworkdir/src /home/ubuntu/spr-fast/tests/corebench/coreutils/coreutils-case-7380cf79-2e636af1/tempworkdir/tests /home/ubuntu/spr-fast/tests/corebench/coreutils/coreutils-case-7380cf79-2e636af1/tempworkdir 32  > __res
Running test command:
/home/ubuntu/spr-fast/tools/coreutils-test.py /home/ubuntu/spr-fast/tests/corebench/coreutils/coreutils-case-7380cf79-2e636af1/tempworkdir/src /home/ubuntu/spr-fast/tests/corebench/coreutils/coreutils-case-7380cf79-2e636af1/tempworkdir/tests /home/ubuntu/spr-fast/tests/corebench/coreutils/coreutils-case-7380cf79-2e636af1/tempworkdir 34  > __res
Running test command:
/home/ubuntu/spr-fast/tools/coreutils-test.py /home/ubuntu/spr-fast/tests/corebench/coreutils/coreutils-case-7380cf79-2e636af1/tempworkdir/src /home/ubuntu/spr-fast/tests/corebench/coreutils/coreutils-case-7380cf79-2e636af1/tempworkdir/tests /home/ubuntu/spr-fast/tests/corebench/coreutils/coreutils-case-7380cf79-2e636af1/tempworkdir 38  > __res
Running test command:
/home/ubuntu/spr-fast/tools/coreutils-test.py /home/ubuntu/spr-fast/tests/corebench/coreutils/coreutils-case-7380cf79-2e636af1/tempworkdir/src /home/ubuntu/spr-fast/tests/corebench/coreutils/coreutils-case-7380cf79-2e636af1/tempworkdir/tests /home/ubuntu/spr-fast/tests/corebench/coreutils/coreutils-case-7380cf79-2e636af1/tempworkdir 40  > __res
Passed Positive Cases
Running test command:
/home/ubuntu/spr-fast/tools/coreutils-test.py /home/ubuntu/spr-fast/tests/corebench/coreutils/coreutils-case-7380cf79-2e636af1/tempworkdir/src /home/ubuntu/spr-fast/tests/corebench/coreutils/coreutils-case-7380cf79-2e636af1/tempworkdir/tests /home/ubuntu/spr-fast/tests/corebench/coreutils/coreutils-case-7380cf79-2e636af1/tempworkdir 0  > __res
Running test command:
/home/ubuntu/spr-fast/tools/coreutils-test.py /home/ubuntu/spr-fast/tests/corebench/coreutils/coreutils-case-7380cf79-2e636af1/tempworkdir/src /home/ubuntu/spr-fast/tests/corebench/coreutils/coreutils-case-7380cf79-2e636af1/tempworkdir/tests /home/ubuntu/spr-fast/tests/corebench/coreutils/coreutils-case-7380cf79-2e636af1/tempworkdir 3  > __res
Running test command:
/home/ubuntu/spr-fast/tools/coreutils-test.py /home/ubuntu/spr-fast/tests/corebench/coreutils/coreutils-case-7380cf79-2e636af1/tempworkdir/src /home/ubuntu/spr-fast/tests/corebench/coreutils/coreutils-case-7380cf79-2e636af1/tempworkdir/tests /home/ubuntu/spr-fast/tests/corebench/coreutils/coreutils-case-7380cf79-2e636af1/tempworkdir 4  > __res
Running test command:
/home/ubuntu/spr-fast/tools/coreutils-test.py /home/ubuntu/spr-fast/tests/corebench/coreutils/coreutils-case-7380cf79-2e636af1/tempworkdir/src /home/ubuntu/spr-fast/tests/corebench/coreutils/coreutils-case-7380cf79-2e636af1/tempworkdir/tests /home/ubuntu/spr-fast/tests/corebench/coreutils/coreutils-case-7380cf79-2e636af1/tempworkdir 7  > __res
Running test command:
/home/ubuntu/spr-fast/tools/coreutils-test.py /home/ubuntu/spr-fast/tests/corebench/coreutils/coreutils-case-7380cf79-2e636af1/tempworkdir/src /home/ubuntu/spr-fast/tests/corebench/coreutils/coreutils-case-7380cf79-2e636af1/tempworkdir/tests /home/ubuntu/spr-fast/tests/corebench/coreutils/coreutils-case-7380cf79-2e636af1/tempworkdir 8  > __res
Running test command:
/home/ubuntu/spr-fast/tools/coreutils-test.py /home/ubuntu/spr-fast/tests/corebench/coreutils/coreutils-case-7380cf79-2e636af1/tempworkdir/src /home/ubuntu/spr-fast/tests/corebench/coreutils/coreutils-case-7380cf79-2e636af1/tempworkdir/tests /home/ubuntu/spr-fast/tests/corebench/coreutils/coreutils-case-7380cf79-2e636af1/tempworkdir 10  > __res
Running test command:
/home/ubuntu/spr-fast/tools/coreutils-test.py /home/ubuntu/spr-fast/tests/corebench/coreutils/coreutils-case-7380cf79-2e636af1/tempworkdir/src /home/ubuntu/spr-fast/tests/corebench/coreutils/coreutils-case-7380cf79-2e636af1/tempworkdir/tests /home/ubuntu/spr-fast/tests/corebench/coreutils/coreutils-case-7380cf79-2e636af1/tempworkdir 14  > __res
Running test command:
/home/ubuntu/spr-fast/tools/coreutils-test.py /home/ubuntu/spr-fast/tests/corebench/coreutils/coreutils-case-7380cf79-2e636af1/tempworkdir/src /home/ubuntu/spr-fast/tests/corebench/coreutils/coreutils-case-7380cf79-2e636af1/tempworkdir/tests /home/ubuntu/spr-fast/tests/corebench/coreutils/coreutils-case-7380cf79-2e636af1/tempworkdir 16  > __res
Running test command:
/home/ubuntu/spr-fast/tools/coreutils-test.py /home/ubuntu/spr-fast/tests/corebench/coreutils/coreutils-case-7380cf79-2e636af1/tempworkdir/src /home/ubuntu/spr-fast/tests/corebench/coreutils/coreutils-case-7380cf79-2e636af1/tempworkdir/tests /home/ubuntu/spr-fast/tests/corebench/coreutils/coreutils-case-7380cf79-2e636af1/tempworkdir 18  > __res
Running test command:
/home/ubuntu/spr-fast/tools/coreutils-test.py /home/ubuntu/spr-fast/tests/corebench/coreutils/coreutils-case-7380cf79-2e636af1/tempworkdir/src /home/ubuntu/spr-fast/tests/corebench/coreutils/coreutils-case-7380cf79-2e636af1/tempworkdir/tests /home/ubuntu/spr-fast/tests/corebench/coreutils/coreutils-case-7380cf79-2e636af1/tempworkdir 19  > __res
Running test command:
/home/ubuntu/spr-fast/tools/coreutils-test.py /home/ubuntu/spr-fast/tests/corebench/coreutils/coreutils-case-7380cf79-2e636af1/tempworkdir/src /home/ubuntu/spr-fast/tests/corebench/coreutils/coreutils-case-7380cf79-2e636af1/tempworkdir/tests /home/ubuntu/spr-fast/tests/corebench/coreutils/coreutils-case-7380cf79-2e636af1/tempworkdir 20  > __res
Running test command:
/home/ubuntu/spr-fast/tools/coreutils-test.py /home/ubuntu/spr-fast/tests/corebench/coreutils/coreutils-case-7380cf79-2e636af1/tempworkdir/src /home/ubuntu/spr-fast/tests/corebench/coreutils/coreutils-case-7380cf79-2e636af1/tempworkdir/tests /home/ubuntu/spr-fast/tests/corebench/coreutils/coreutils-case-7380cf79-2e636af1/tempworkdir 21  > __res
Running test command:
/home/ubuntu/spr-fast/tools/coreutils-test.py /home/ubuntu/spr-fast/tests/corebench/coreutils/coreutils-case-7380cf79-2e636af1/tempworkdir/src /home/ubuntu/spr-fast/tests/corebench/coreutils/coreutils-case-7380cf79-2e636af1/tempworkdir/tests /home/ubuntu/spr-fast/tests/corebench/coreutils/coreutils-case-7380cf79-2e636af1/tempworkdir 22  > __res
Running test command:
/home/ubuntu/spr-fast/tools/coreutils-test.py /home/ubuntu/spr-fast/tests/corebench/coreutils/coreutils-case-7380cf79-2e636af1/tempworkdir/src /home/ubuntu/spr-fast/tests/corebench/coreutils/coreutils-case-7380cf79-2e636af1/tempworkdir/tests /home/ubuntu/spr-fast/tests/corebench/coreutils/coreutils-case-7380cf79-2e636af1/tempworkdir 24  > __res
Running test command:
/home/ubuntu/spr-fast/tools/coreutils-test.py /home/ubuntu/spr-fast/tests/corebench/coreutils/coreutils-case-7380cf79-2e636af1/tempworkdir/src /home/ubuntu/spr-fast/tests/corebench/coreutils/coreutils-case-7380cf79-2e636af1/tempworkdir/tests /home/ubuntu/spr-fast/tests/corebench/coreutils/coreutils-case-7380cf79-2e636af1/tempworkdir 25  > __res
Running test command:
/home/ubuntu/spr-fast/tools/coreutils-test.py /home/ubuntu/spr-fast/tests/corebench/coreutils/coreutils-case-7380cf79-2e636af1/tempworkdir/src /home/ubuntu/spr-fast/tests/corebench/coreutils/coreutils-case-7380cf79-2e636af1/tempworkdir/tests /home/ubuntu/spr-fast/tests/corebench/coreutils/coreutils-case-7380cf79-2e636af1/tempworkdir 26  > __res
Running test command:
/home/ubuntu/spr-fast/tools/coreutils-test.py /home/ubuntu/spr-fast/tests/corebench/coreutils/coreutils-case-7380cf79-2e636af1/tempworkdir/src /home/ubuntu/spr-fast/tests/corebench/coreutils/coreutils-case-7380cf79-2e636af1/tempworkdir/tests /home/ubuntu/spr-fast/tests/corebench/coreutils/coreutils-case-7380cf79-2e636af1/tempworkdir 27  > __res
Running test command:
/home/ubuntu/spr-fast/tools/coreutils-test.py /home/ubuntu/spr-fast/tests/corebench/coreutils/coreutils-case-7380cf79-2e636af1/tempworkdir/src /home/ubuntu/spr-fast/tests/corebench/coreutils/coreutils-case-7380cf79-2e636af1/tempworkdir/tests /home/ubuntu/spr-fast/tests/corebench/coreutils/coreutils-case-7380cf79-2e636af1/tempworkdir 32  > __res
Running test command:
/home/ubuntu/spr-fast/tools/coreutils-test.py /home/ubuntu/spr-fast/tests/corebench/coreutils/coreutils-case-7380cf79-2e636af1/tempworkdir/src /home/ubuntu/spr-fast/tests/corebench/coreutils/coreutils-case-7380cf79-2e636af1/tempworkdir/tests /home/ubuntu/spr-fast/tests/corebench/coreutils/coreutils-case-7380cf79-2e636af1/tempworkdir 34  > __res
Running test command:
/home/ubuntu/spr-fast/tools/coreutils-test.py /home/ubuntu/spr-fast/tests/corebench/coreutils/coreutils-case-7380cf79-2e636af1/tempworkdir/src /home/ubuntu/spr-fast/tests/corebench/coreutils/coreutils-case-7380cf79-2e636af1/tempworkdir/tests /home/ubuntu/spr-fast/tests/corebench/coreutils/coreutils-case-7380cf79-2e636af1/tempworkdir 38  > __res
Running test command:
/home/ubuntu/spr-fast/tools/coreutils-test.py /home/ubuntu/spr-fast/tests/corebench/coreutils/coreutils-case-7380cf79-2e636af1/tempworkdir/src /home/ubuntu/spr-fast/tests/corebench/coreutils/coreutils-case-7380cf79-2e636af1/tempworkdir/tests /home/ubuntu/spr-fast/tests/corebench/coreutils/coreutils-case-7380cf79-2e636af1/tempworkdir 40  > __res
Passed!
CondTester, Postprocessing instance id 40:
Trying a synthesis expr 1
Skipping a synthesis:1
Skipping two clauses!(1) &&(0)
Postprocessing failed!
a batched test job starts!
Building:src at:
/home/ubuntu/spr-fast/tests/corebench/coreutils/coreutils-case-7380cf79-2e636af1/tempworkdir/srcMerged code building succ, going to invoke tester!
CondTester, Testing instance id 20:
Running test command:
/home/ubuntu/spr-fast/tools/coreutils-test.py /home/ubuntu/spr-fast/tests/corebench/coreutils/coreutils-case-7380cf79-2e636af1/tempworkdir/src /home/ubuntu/spr-fast/tests/corebench/coreutils/coreutils-case-7380cf79-2e636af1/tempworkdir/tests /home/ubuntu/spr-fast/tests/corebench/coreutils/coreutils-case-7380cf79-2e636af1/tempworkdir 0  > __res
Running test command:
/home/ubuntu/spr-fast/tools/coreutils-test.py /home/ubuntu/spr-fast/tests/corebench/coreutils/coreutils-case-7380cf79-2e636af1/tempworkdir/src /home/ubuntu/spr-fast/tests/corebench/coreutils/coreutils-case-7380cf79-2e636af1/tempworkdir/tests /home/ubuntu/spr-fast/tests/corebench/coreutils/coreutils-case-7380cf79-2e636af1/tempworkdir 0  > __res
Running test command:
/home/ubuntu/spr-fast/tools/coreutils-test.py /home/ubuntu/spr-fast/tests/corebench/coreutils/coreutils-case-7380cf79-2e636af1/tempworkdir/src /home/ubuntu/spr-fast/tests/corebench/coreutils/coreutils-case-7380cf79-2e636af1/tempworkdir/tests /home/ubuntu/spr-fast/tests/corebench/coreutils/coreutils-case-7380cf79-2e636af1/tempworkdir 0  > __res
CondTester, Testing instance id 21:
Running test command:
/home/ubuntu/spr-fast/tools/coreutils-test.py /home/ubuntu/spr-fast/tests/corebench/coreutils/coreutils-case-7380cf79-2e636af1/tempworkdir/src /home/ubuntu/spr-fast/tests/corebench/coreutils/coreutils-case-7380cf79-2e636af1/tempworkdir/tests /home/ubuntu/spr-fast/tests/corebench/coreutils/coreutils-case-7380cf79-2e636af1/tempworkdir 0  > __res
Running test command:
/home/ubuntu/spr-fast/tools/coreutils-test.py /home/ubuntu/spr-fast/tests/corebench/coreutils/coreutils-case-7380cf79-2e636af1/tempworkdir/src /home/ubuntu/spr-fast/tests/corebench/coreutils/coreutils-case-7380cf79-2e636af1/tempworkdir/tests /home/ubuntu/spr-fast/tests/corebench/coreutils/coreutils-case-7380cf79-2e636af1/tempworkdir 0  > __res
Running test command:
/home/ubuntu/spr-fast/tools/coreutils-test.py /home/ubuntu/spr-fast/tests/corebench/coreutils/coreutils-case-7380cf79-2e636af1/tempworkdir/src /home/ubuntu/spr-fast/tests/corebench/coreutils/coreutils-case-7380cf79-2e636af1/tempworkdir/tests /home/ubuntu/spr-fast/tests/corebench/coreutils/coreutils-case-7380cf79-2e636af1/tempworkdir 0  > __res
Running test command:
/home/ubuntu/spr-fast/tools/coreutils-test.py /home/ubuntu/spr-fast/tests/corebench/coreutils/coreutils-case-7380cf79-2e636af1/tempworkdir/src /home/ubuntu/spr-fast/tests/corebench/coreutils/coreutils-case-7380cf79-2e636af1/tempworkdir/tests /home/ubuntu/spr-fast/tests/corebench/coreutils/coreutils-case-7380cf79-2e636af1/tempworkdir 0  > __res
Running test command:
/home/ubuntu/spr-fast/tools/coreutils-test.py /home/ubuntu/spr-fast/tests/corebench/coreutils/coreutils-case-7380cf79-2e636af1/tempworkdir/src /home/ubuntu/spr-fast/tests/corebench/coreutils/coreutils-case-7380cf79-2e636af1/tempworkdir/tests /home/ubuntu/spr-fast/tests/corebench/coreutils/coreutils-case-7380cf79-2e636af1/tempworkdir 0  > __res
Running test command:
/home/ubuntu/spr-fast/tools/coreutils-test.py /home/ubuntu/spr-fast/tests/corebench/coreutils/coreutils-case-7380cf79-2e636af1/tempworkdir/src /home/ubuntu/spr-fast/tests/corebench/coreutils/coreutils-case-7380cf79-2e636af1/tempworkdir/tests /home/ubuntu/spr-fast/tests/corebench/coreutils/coreutils-case-7380cf79-2e636af1/tempworkdir 0  > __res
Running test command:
/home/ubuntu/spr-fast/tools/coreutils-test.py /home/ubuntu/spr-fast/tests/corebench/coreutils/coreutils-case-7380cf79-2e636af1/tempworkdir/src /home/ubuntu/spr-fast/tests/corebench/coreutils/coreutils-case-7380cf79-2e636af1/tempworkdir/tests /home/ubuntu/spr-fast/tests/corebench/coreutils/coreutils-case-7380cf79-2e636af1/tempworkdir 0  > __res
Running test command:
/home/ubuntu/spr-fast/tools/coreutils-test.py /home/ubuntu/spr-fast/tests/corebench/coreutils/coreutils-case-7380cf79-2e636af1/tempworkdir/src /home/ubuntu/spr-fast/tests/corebench/coreutils/coreutils-case-7380cf79-2e636af1/tempworkdir/tests /home/ubuntu/spr-fast/tests/corebench/coreutils/coreutils-case-7380cf79-2e636af1/tempworkdir 0  > __res
Running test command:
/home/ubuntu/spr-fast/tools/coreutils-test.py /home/ubuntu/spr-fast/tests/corebench/coreutils/coreutils-case-7380cf79-2e636af1/tempworkdir/src /home/ubuntu/spr-fast/tests/corebench/coreutils/coreutils-case-7380cf79-2e636af1/tempworkdir/tests /home/ubuntu/spr-fast/tests/corebench/coreutils/coreutils-case-7380cf79-2e636af1/tempworkdir 0  > __res
Running test command:
/home/ubuntu/spr-fast/tools/coreutils-test.py /home/ubuntu/spr-fast/tests/corebench/coreutils/coreutils-case-7380cf79-2e636af1/tempworkdir/src /home/ubuntu/spr-fast/tests/corebench/coreutils/coreutils-case-7380cf79-2e636af1/tempworkdir/tests /home/ubuntu/spr-fast/tests/corebench/coreutils/coreutils-case-7380cf79-2e636af1/tempworkdir 0  > __res
Running test command:
/home/ubuntu/spr-fast/tools/coreutils-test.py /home/ubuntu/spr-fast/tests/corebench/coreutils/coreutils-case-7380cf79-2e636af1/tempworkdir/src /home/ubuntu/spr-fast/tests/corebench/coreutils/coreutils-case-7380cf79-2e636af1/tempworkdir/tests /home/ubuntu/spr-fast/tests/corebench/coreutils/coreutils-case-7380cf79-2e636af1/tempworkdir 0  > __res
CondTester, Testing instance id 39:
Running test command:
/home/ubuntu/spr-fast/tools/coreutils-test.py /home/ubuntu/spr-fast/tests/corebench/coreutils/coreutils-case-7380cf79-2e636af1/tempworkdir/src /home/ubuntu/spr-fast/tests/corebench/coreutils/coreutils-case-7380cf79-2e636af1/tempworkdir/tests /home/ubuntu/spr-fast/tests/corebench/coreutils/coreutils-case-7380cf79-2e636af1/tempworkdir 0  > __res
Running test command:
/home/ubuntu/spr-fast/tools/coreutils-test.py /home/ubuntu/spr-fast/tests/corebench/coreutils/coreutils-case-7380cf79-2e636af1/tempworkdir/src /home/ubuntu/spr-fast/tests/corebench/coreutils/coreutils-case-7380cf79-2e636af1/tempworkdir/tests /home/ubuntu/spr-fast/tests/corebench/coreutils/coreutils-case-7380cf79-2e636af1/tempworkdir 0  > __res
Running test command:
/home/ubuntu/spr-fast/tools/coreutils-test.py /home/ubuntu/spr-fast/tests/corebench/coreutils/coreutils-case-7380cf79-2e636af1/tempworkdir/src /home/ubuntu/spr-fast/tests/corebench/coreutils/coreutils-case-7380cf79-2e636af1/tempworkdir/tests /home/ubuntu/spr-fast/tests/corebench/coreutils/coreutils-case-7380cf79-2e636af1/tempworkdir 0  > __res
Running test command:
/home/ubuntu/spr-fast/tools/coreutils-test.py /home/ubuntu/spr-fast/tests/corebench/coreutils/coreutils-case-7380cf79-2e636af1/tempworkdir/src /home/ubuntu/spr-fast/tests/corebench/coreutils/coreutils-case-7380cf79-2e636af1/tempworkdir/tests /home/ubuntu/spr-fast/tests/corebench/coreutils/coreutils-case-7380cf79-2e636af1/tempworkdir 0  > __res
Running test command:
/home/ubuntu/spr-fast/tools/coreutils-test.py /home/ubuntu/spr-fast/tests/corebench/coreutils/coreutils-case-7380cf79-2e636af1/tempworkdir/src /home/ubuntu/spr-fast/tests/corebench/coreutils/coreutils-case-7380cf79-2e636af1/tempworkdir/tests /home/ubuntu/spr-fast/tests/corebench/coreutils/coreutils-case-7380cf79-2e636af1/tempworkdir 0  > __res
Running test command:
/home/ubuntu/spr-fast/tools/coreutils-test.py /home/ubuntu/spr-fast/tests/corebench/coreutils/coreutils-case-7380cf79-2e636af1/tempworkdir/src /home/ubuntu/spr-fast/tests/corebench/coreutils/coreutils-case-7380cf79-2e636af1/tempworkdir/tests /home/ubuntu/spr-fast/tests/corebench/coreutils/coreutils-case-7380cf79-2e636af1/tempworkdir 0  > __res
Running test command:
/home/ubuntu/spr-fast/tools/coreutils-test.py /home/ubuntu/spr-fast/tests/corebench/coreutils/coreutils-case-7380cf79-2e636af1/tempworkdir/src /home/ubuntu/spr-fast/tests/corebench/coreutils/coreutils-case-7380cf79-2e636af1/tempworkdir/tests /home/ubuntu/spr-fast/tests/corebench/coreutils/coreutils-case-7380cf79-2e636af1/tempworkdir 0  > __res
Running test command:
/home/ubuntu/spr-fast/tools/coreutils-test.py /home/ubuntu/spr-fast/tests/corebench/coreutils/coreutils-case-7380cf79-2e636af1/tempworkdir/src /home/ubuntu/spr-fast/tests/corebench/coreutils/coreutils-case-7380cf79-2e636af1/tempworkdir/tests /home/ubuntu/spr-fast/tests/corebench/coreutils/coreutils-case-7380cf79-2e636af1/tempworkdir 0  > __res
Running test command:
/home/ubuntu/spr-fast/tools/coreutils-test.py /home/ubuntu/spr-fast/tests/corebench/coreutils/coreutils-case-7380cf79-2e636af1/tempworkdir/src /home/ubuntu/spr-fast/tests/corebench/coreutils/coreutils-case-7380cf79-2e636af1/tempworkdir/tests /home/ubuntu/spr-fast/tests/corebench/coreutils/coreutils-case-7380cf79-2e636af1/tempworkdir 0  > __res
Running test command:
/home/ubuntu/spr-fast/tools/coreutils-test.py /home/ubuntu/spr-fast/tests/corebench/coreutils/coreutils-case-7380cf79-2e636af1/tempworkdir/src /home/ubuntu/spr-fast/tests/corebench/coreutils/coreutils-case-7380cf79-2e636af1/tempworkdir/tests /home/ubuntu/spr-fast/tests/corebench/coreutils/coreutils-case-7380cf79-2e636af1/tempworkdir 0  > __res
Running test command:
/home/ubuntu/spr-fast/tools/coreutils-test.py /home/ubuntu/spr-fast/tests/corebench/coreutils/coreutils-case-7380cf79-2e636af1/tempworkdir/src /home/ubuntu/spr-fast/tests/corebench/coreutils/coreutils-case-7380cf79-2e636af1/tempworkdir/tests /home/ubuntu/spr-fast/tests/corebench/coreutils/coreutils-case-7380cf79-2e636af1/tempworkdir 0  > __res
a batched test job starts!
Building:src at:
/home/ubuntu/spr-fast/tests/corebench/coreutils/coreutils-case-7380cf79-2e636af1/tempworkdir/srcMerged code building succ, going to invoke tester!
CondTester, Testing instance id 0:
Running test command:
/home/ubuntu/spr-fast/tools/coreutils-test.py /home/ubuntu/spr-fast/tests/corebench/coreutils/coreutils-case-7380cf79-2e636af1/tempworkdir/src /home/ubuntu/spr-fast/tests/corebench/coreutils/coreutils-case-7380cf79-2e636af1/tempworkdir/tests /home/ubuntu/spr-fast/tests/corebench/coreutils/coreutils-case-7380cf79-2e636af1/tempworkdir 0  > __res
Running test command:
/home/ubuntu/spr-fast/tools/coreutils-test.py /home/ubuntu/spr-fast/tests/corebench/coreutils/coreutils-case-7380cf79-2e636af1/tempworkdir/src /home/ubuntu/spr-fast/tests/corebench/coreutils/coreutils-case-7380cf79-2e636af1/tempworkdir/tests /home/ubuntu/spr-fast/tests/corebench/coreutils/coreutils-case-7380cf79-2e636af1/tempworkdir 0  > __res
CondTester, Testing instance id 1:
Running test command:
/home/ubuntu/spr-fast/tools/coreutils-test.py /home/ubuntu/spr-fast/tests/corebench/coreutils/coreutils-case-7380cf79-2e636af1/tempworkdir/src /home/ubuntu/spr-fast/tests/corebench/coreutils/coreutils-case-7380cf79-2e636af1/tempworkdir/tests /home/ubuntu/spr-fast/tests/corebench/coreutils/coreutils-case-7380cf79-2e636af1/tempworkdir 0  > __res
Running test command:
/home/ubuntu/spr-fast/tools/coreutils-test.py /home/ubuntu/spr-fast/tests/corebench/coreutils/coreutils-case-7380cf79-2e636af1/tempworkdir/src /home/ubuntu/spr-fast/tests/corebench/coreutils/coreutils-case-7380cf79-2e636af1/tempworkdir/tests /home/ubuntu/spr-fast/tests/corebench/coreutils/coreutils-case-7380cf79-2e636af1/tempworkdir 0  > __res
Running test command:
/home/ubuntu/spr-fast/tools/coreutils-test.py /home/ubuntu/spr-fast/tests/corebench/coreutils/coreutils-case-7380cf79-2e636af1/tempworkdir/src /home/ubuntu/spr-fast/tests/corebench/coreutils/coreutils-case-7380cf79-2e636af1/tempworkdir/tests /home/ubuntu/spr-fast/tests/corebench/coreutils/coreutils-case-7380cf79-2e636af1/tempworkdir 0  > __res
a batched test job starts!
Building:src at:
/home/ubuntu/spr-fast/tests/corebench/coreutils/coreutils-case-7380cf79-2e636af1/tempworkdir/srcMerged code building succ, going to invoke tester!
CondTester, Testing instance id 18:
Running test command:
/home/ubuntu/spr-fast/tools/coreutils-test.py /home/ubuntu/spr-fast/tests/corebench/coreutils/coreutils-case-7380cf79-2e636af1/tempworkdir/src /home/ubuntu/spr-fast/tests/corebench/coreutils/coreutils-case-7380cf79-2e636af1/tempworkdir/tests /home/ubuntu/spr-fast/tests/corebench/coreutils/coreutils-case-7380cf79-2e636af1/tempworkdir 0  > __res
Running test command:
/home/ubuntu/spr-fast/tools/coreutils-test.py /home/ubuntu/spr-fast/tests/corebench/coreutils/coreutils-case-7380cf79-2e636af1/tempworkdir/src /home/ubuntu/spr-fast/tests/corebench/coreutils/coreutils-case-7380cf79-2e636af1/tempworkdir/tests /home/ubuntu/spr-fast/tests/corebench/coreutils/coreutils-case-7380cf79-2e636af1/tempworkdir 0  > __res
Running test command:
/home/ubuntu/spr-fast/tools/coreutils-test.py /home/ubuntu/spr-fast/tests/corebench/coreutils/coreutils-case-7380cf79-2e636af1/tempworkdir/src /home/ubuntu/spr-fast/tests/corebench/coreutils/coreutils-case-7380cf79-2e636af1/tempworkdir/tests /home/ubuntu/spr-fast/tests/corebench/coreutils/coreutils-case-7380cf79-2e636af1/tempworkdir 0  > __res
CondTester, Testing instance id 19:
Running test command:
/home/ubuntu/spr-fast/tools/coreutils-test.py /home/ubuntu/spr-fast/tests/corebench/coreutils/coreutils-case-7380cf79-2e636af1/tempworkdir/src /home/ubuntu/spr-fast/tests/corebench/coreutils/coreutils-case-7380cf79-2e636af1/tempworkdir/tests /home/ubuntu/spr-fast/tests/corebench/coreutils/coreutils-case-7380cf79-2e636af1/tempworkdir 0  > __res
Running test command:
/home/ubuntu/spr-fast/tools/coreutils-test.py /home/ubuntu/spr-fast/tests/corebench/coreutils/coreutils-case-7380cf79-2e636af1/tempworkdir/src /home/ubuntu/spr-fast/tests/corebench/coreutils/coreutils-case-7380cf79-2e636af1/tempworkdir/tests /home/ubuntu/spr-fast/tests/corebench/coreutils/coreutils-case-7380cf79-2e636af1/tempworkdir 0  > __res
Running test command:
/home/ubuntu/spr-fast/tools/coreutils-test.py /home/ubuntu/spr-fast/tests/corebench/coreutils/coreutils-case-7380cf79-2e636af1/tempworkdir/src /home/ubuntu/spr-fast/tests/corebench/coreutils/coreutils-case-7380cf79-2e636af1/tempworkdir/tests /home/ubuntu/spr-fast/tests/corebench/coreutils/coreutils-case-7380cf79-2e636af1/tempworkdir 0  > __res
Running test command:
/home/ubuntu/spr-fast/tools/coreutils-test.py /home/ubuntu/spr-fast/tests/corebench/coreutils/coreutils-case-7380cf79-2e636af1/tempworkdir/src /home/ubuntu/spr-fast/tests/corebench/coreutils/coreutils-case-7380cf79-2e636af1/tempworkdir/tests /home/ubuntu/spr-fast/tests/corebench/coreutils/coreutils-case-7380cf79-2e636af1/tempworkdir 0  > __res
Running test command:
/home/ubuntu/spr-fast/tools/coreutils-test.py /home/ubuntu/spr-fast/tests/corebench/coreutils/coreutils-case-7380cf79-2e636af1/tempworkdir/src /home/ubuntu/spr-fast/tests/corebench/coreutils/coreutils-case-7380cf79-2e636af1/tempworkdir/tests /home/ubuntu/spr-fast/tests/corebench/coreutils/coreutils-case-7380cf79-2e636af1/tempworkdir 0  > __res
Running test command:
/home/ubuntu/spr-fast/tools/coreutils-test.py /home/ubuntu/spr-fast/tests/corebench/coreutils/coreutils-case-7380cf79-2e636af1/tempworkdir/src /home/ubuntu/spr-fast/tests/corebench/coreutils/coreutils-case-7380cf79-2e636af1/tempworkdir/tests /home/ubuntu/spr-fast/tests/corebench/coreutils/coreutils-case-7380cf79-2e636af1/tempworkdir 0  > __res
Running test command:
/home/ubuntu/spr-fast/tools/coreutils-test.py /home/ubuntu/spr-fast/tests/corebench/coreutils/coreutils-case-7380cf79-2e636af1/tempworkdir/src /home/ubuntu/spr-fast/tests/corebench/coreutils/coreutils-case-7380cf79-2e636af1/tempworkdir/tests /home/ubuntu/spr-fast/tests/corebench/coreutils/coreutils-case-7380cf79-2e636af1/tempworkdir 0  > __res
Running test command:
/home/ubuntu/spr-fast/tools/coreutils-test.py /home/ubuntu/spr-fast/tests/corebench/coreutils/coreutils-case-7380cf79-2e636af1/tempworkdir/src /home/ubuntu/spr-fast/tests/corebench/coreutils/coreutils-case-7380cf79-2e636af1/tempworkdir/tests /home/ubuntu/spr-fast/tests/corebench/coreutils/coreutils-case-7380cf79-2e636af1/tempworkdir 0  > __res
Running test command:
/home/ubuntu/spr-fast/tools/coreutils-test.py /home/ubuntu/spr-fast/tests/corebench/coreutils/coreutils-case-7380cf79-2e636af1/tempworkdir/src /home/ubuntu/spr-fast/tests/corebench/coreutils/coreutils-case-7380cf79-2e636af1/tempworkdir/tests /home/ubuntu/spr-fast/tests/corebench/coreutils/coreutils-case-7380cf79-2e636af1/tempworkdir 0  > __res
Running test command:
/home/ubuntu/spr-fast/tools/coreutils-test.py /home/ubuntu/spr-fast/tests/corebench/coreutils/coreutils-case-7380cf79-2e636af1/tempworkdir/src /home/ubuntu/spr-fast/tests/corebench/coreutils/coreutils-case-7380cf79-2e636af1/tempworkdir/tests /home/ubuntu/spr-fast/tests/corebench/coreutils/coreutils-case-7380cf79-2e636af1/tempworkdir 0  > __res
Running test command:
/home/ubuntu/spr-fast/tools/coreutils-test.py /home/ubuntu/spr-fast/tests/corebench/coreutils/coreutils-case-7380cf79-2e636af1/tempworkdir/src /home/ubuntu/spr-fast/tests/corebench/coreutils/coreutils-case-7380cf79-2e636af1/tempworkdir/tests /home/ubuntu/spr-fast/tests/corebench/coreutils/coreutils-case-7380cf79-2e636af1/tempworkdir 0  > __res
a batched test job starts!
Building:src at:
/home/ubuntu/spr-fast/tests/corebench/coreutils/coreutils-case-7380cf79-2e636af1/tempworkdir/srcMerged code building succ, going to invoke tester!
CondTester, Testing instance id 4:
Running test command:
/home/ubuntu/spr-fast/tools/coreutils-test.py /home/ubuntu/spr-fast/tests/corebench/coreutils/coreutils-case-7380cf79-2e636af1/tempworkdir/src /home/ubuntu/spr-fast/tests/corebench/coreutils/coreutils-case-7380cf79-2e636af1/tempworkdir/tests /home/ubuntu/spr-fast/tests/corebench/coreutils/coreutils-case-7380cf79-2e636af1/tempworkdir 0  > __res
Running test command:
/home/ubuntu/spr-fast/tools/coreutils-test.py /home/ubuntu/spr-fast/tests/corebench/coreutils/coreutils-case-7380cf79-2e636af1/tempworkdir/src /home/ubuntu/spr-fast/tests/corebench/coreutils/coreutils-case-7380cf79-2e636af1/tempworkdir/tests /home/ubuntu/spr-fast/tests/corebench/coreutils/coreutils-case-7380cf79-2e636af1/tempworkdir 0  > __res
Running test command:
/home/ubuntu/spr-fast/tools/coreutils-test.py /home/ubuntu/spr-fast/tests/corebench/coreutils/coreutils-case-7380cf79-2e636af1/tempworkdir/src /home/ubuntu/spr-fast/tests/corebench/coreutils/coreutils-case-7380cf79-2e636af1/tempworkdir/tests /home/ubuntu/spr-fast/tests/corebench/coreutils/coreutils-case-7380cf79-2e636af1/tempworkdir 0  > __res
CondTester, Testing instance id 5:
Running test command:
/home/ubuntu/spr-fast/tools/coreutils-test.py /home/ubuntu/spr-fast/tests/corebench/coreutils/coreutils-case-7380cf79-2e636af1/tempworkdir/src /home/ubuntu/spr-fast/tests/corebench/coreutils/coreutils-case-7380cf79-2e636af1/tempworkdir/tests /home/ubuntu/spr-fast/tests/corebench/coreutils/coreutils-case-7380cf79-2e636af1/tempworkdir 0  > __res
Running test command:
/home/ubuntu/spr-fast/tools/coreutils-test.py /home/ubuntu/spr-fast/tests/corebench/coreutils/coreutils-case-7380cf79-2e636af1/tempworkdir/src /home/ubuntu/spr-fast/tests/corebench/coreutils/coreutils-case-7380cf79-2e636af1/tempworkdir/tests /home/ubuntu/spr-fast/tests/corebench/coreutils/coreutils-case-7380cf79-2e636af1/tempworkdir 0  > __res
a batched test job starts!
Building:src at:
/home/ubuntu/spr-fast/tests/corebench/coreutils/coreutils-case-7380cf79-2e636af1/tempworkdir/srcMerged code building succ, going to invoke tester!
CondTester, Testing instance id 6:
Running test command:
/home/ubuntu/spr-fast/tools/coreutils-test.py /home/ubuntu/spr-fast/tests/corebench/coreutils/coreutils-case-7380cf79-2e636af1/tempworkdir/src /home/ubuntu/spr-fast/tests/corebench/coreutils/coreutils-case-7380cf79-2e636af1/tempworkdir/tests /home/ubuntu/spr-fast/tests/corebench/coreutils/coreutils-case-7380cf79-2e636af1/tempworkdir 0  > __res
Running test command:
/home/ubuntu/spr-fast/tools/coreutils-test.py /home/ubuntu/spr-fast/tests/corebench/coreutils/coreutils-case-7380cf79-2e636af1/tempworkdir/src /home/ubuntu/spr-fast/tests/corebench/coreutils/coreutils-case-7380cf79-2e636af1/tempworkdir/tests /home/ubuntu/spr-fast/tests/corebench/coreutils/coreutils-case-7380cf79-2e636af1/tempworkdir 0  > __res
CondTester, Testing instance id 7:
Running test command:
/home/ubuntu/spr-fast/tools/coreutils-test.py /home/ubuntu/spr-fast/tests/corebench/coreutils/coreutils-case-7380cf79-2e636af1/tempworkdir/src /home/ubuntu/spr-fast/tests/corebench/coreutils/coreutils-case-7380cf79-2e636af1/tempworkdir/tests /home/ubuntu/spr-fast/tests/corebench/coreutils/coreutils-case-7380cf79-2e636af1/tempworkdir 0  > __res
Running test command:
/home/ubuntu/spr-fast/tools/coreutils-test.py /home/ubuntu/spr-fast/tests/corebench/coreutils/coreutils-case-7380cf79-2e636af1/tempworkdir/src /home/ubuntu/spr-fast/tests/corebench/coreutils/coreutils-case-7380cf79-2e636af1/tempworkdir/tests /home/ubuntu/spr-fast/tests/corebench/coreutils/coreutils-case-7380cf79-2e636af1/tempworkdir 0  > __res
Running test command:
/home/ubuntu/spr-fast/tools/coreutils-test.py /home/ubuntu/spr-fast/tests/corebench/coreutils/coreutils-case-7380cf79-2e636af1/tempworkdir/src /home/ubuntu/spr-fast/tests/corebench/coreutils/coreutils-case-7380cf79-2e636af1/tempworkdir/tests /home/ubuntu/spr-fast/tests/corebench/coreutils/coreutils-case-7380cf79-2e636af1/tempworkdir 0  > __res
CondTester, Testing instance id 8:
Running test command:
/home/ubuntu/spr-fast/tools/coreutils-test.py /home/ubuntu/spr-fast/tests/corebench/coreutils/coreutils-case-7380cf79-2e636af1/tempworkdir/src /home/ubuntu/spr-fast/tests/corebench/coreutils/coreutils-case-7380cf79-2e636af1/tempworkdir/tests /home/ubuntu/spr-fast/tests/corebench/coreutils/coreutils-case-7380cf79-2e636af1/tempworkdir 0  > __res
Running test command:
/home/ubuntu/spr-fast/tools/coreutils-test.py /home/ubuntu/spr-fast/tests/corebench/coreutils/coreutils-case-7380cf79-2e636af1/tempworkdir/src /home/ubuntu/spr-fast/tests/corebench/coreutils/coreutils-case-7380cf79-2e636af1/tempworkdir/tests /home/ubuntu/spr-fast/tests/corebench/coreutils/coreutils-case-7380cf79-2e636af1/tempworkdir 0  > __res
Running test command:
/home/ubuntu/spr-fast/tools/coreutils-test.py /home/ubuntu/spr-fast/tests/corebench/coreutils/coreutils-case-7380cf79-2e636af1/tempworkdir/src /home/ubuntu/spr-fast/tests/corebench/coreutils/coreutils-case-7380cf79-2e636af1/tempworkdir/tests /home/ubuntu/spr-fast/tests/corebench/coreutils/coreutils-case-7380cf79-2e636af1/tempworkdir 0  > __res
a batched test job starts!
Building:src at:
/home/ubuntu/spr-fast/tests/corebench/coreutils/coreutils-case-7380cf79-2e636af1/tempworkdir/srcMerged code building succ, going to invoke tester!
CondTester, Testing instance id 2:
Running test command:
/home/ubuntu/spr-fast/tools/coreutils-test.py /home/ubuntu/spr-fast/tests/corebench/coreutils/coreutils-case-7380cf79-2e636af1/tempworkdir/src /home/ubuntu/spr-fast/tests/corebench/coreutils/coreutils-case-7380cf79-2e636af1/tempworkdir/tests /home/ubuntu/spr-fast/tests/corebench/coreutils/coreutils-case-7380cf79-2e636af1/tempworkdir 0  > __res
Running test command:
/home/ubuntu/spr-fast/tools/coreutils-test.py /home/ubuntu/spr-fast/tests/corebench/coreutils/coreutils-case-7380cf79-2e636af1/tempworkdir/src /home/ubuntu/spr-fast/tests/corebench/coreutils/coreutils-case-7380cf79-2e636af1/tempworkdir/tests /home/ubuntu/spr-fast/tests/corebench/coreutils/coreutils-case-7380cf79-2e636af1/tempworkdir 0  > __res
Running test command:
/home/ubuntu/spr-fast/tools/coreutils-test.py /home/ubuntu/spr-fast/tests/corebench/coreutils/coreutils-case-7380cf79-2e636af1/tempworkdir/src /home/ubuntu/spr-fast/tests/corebench/coreutils/coreutils-case-7380cf79-2e636af1/tempworkdir/tests /home/ubuntu/spr-fast/tests/corebench/coreutils/coreutils-case-7380cf79-2e636af1/tempworkdir 0  > __res
CondTester, Testing instance id 3:
Running test command:
/home/ubuntu/spr-fast/tools/coreutils-test.py /home/ubuntu/spr-fast/tests/corebench/coreutils/coreutils-case-7380cf79-2e636af1/tempworkdir/src /home/ubuntu/spr-fast/tests/corebench/coreutils/coreutils-case-7380cf79-2e636af1/tempworkdir/tests /home/ubuntu/spr-fast/tests/corebench/coreutils/coreutils-case-7380cf79-2e636af1/tempworkdir 0  > __res
Running test command:
/home/ubuntu/spr-fast/tools/coreutils-test.py /home/ubuntu/spr-fast/tests/corebench/coreutils/coreutils-case-7380cf79-2e636af1/tempworkdir/src /home/ubuntu/spr-fast/tests/corebench/coreutils/coreutils-case-7380cf79-2e636af1/tempworkdir/tests /home/ubuntu/spr-fast/tests/corebench/coreutils/coreutils-case-7380cf79-2e636af1/tempworkdir 0  > __res
a batched test job starts!
Building:src at:
/home/ubuntu/spr-fast/tests/corebench/coreutils/coreutils-case-7380cf79-2e636af1/tempworkdir/srcMerged code building succ, going to invoke tester!
CondTester, Testing instance id 12:
Running test command:
/home/ubuntu/spr-fast/tools/coreutils-test.py /home/ubuntu/spr-fast/tests/corebench/coreutils/coreutils-case-7380cf79-2e636af1/tempworkdir/src /home/ubuntu/spr-fast/tests/corebench/coreutils/coreutils-case-7380cf79-2e636af1/tempworkdir/tests /home/ubuntu/spr-fast/tests/corebench/coreutils/coreutils-case-7380cf79-2e636af1/tempworkdir 0  > __res
Running test command:
/home/ubuntu/spr-fast/tools/coreutils-test.py /home/ubuntu/spr-fast/tests/corebench/coreutils/coreutils-case-7380cf79-2e636af1/tempworkdir/src /home/ubuntu/spr-fast/tests/corebench/coreutils/coreutils-case-7380cf79-2e636af1/tempworkdir/tests /home/ubuntu/spr-fast/tests/corebench/coreutils/coreutils-case-7380cf79-2e636af1/tempworkdir 0  > __res
Running test command:
/home/ubuntu/spr-fast/tools/coreutils-test.py /home/ubuntu/spr-fast/tests/corebench/coreutils/coreutils-case-7380cf79-2e636af1/tempworkdir/src /home/ubuntu/spr-fast/tests/corebench/coreutils/coreutils-case-7380cf79-2e636af1/tempworkdir/tests /home/ubuntu/spr-fast/tests/corebench/coreutils/coreutils-case-7380cf79-2e636af1/tempworkdir 0  > __res
CondTester, Testing instance id 23:
Running test command:
/home/ubuntu/spr-fast/tools/coreutils-test.py /home/ubuntu/spr-fast/tests/corebench/coreutils/coreutils-case-7380cf79-2e636af1/tempworkdir/src /home/ubuntu/spr-fast/tests/corebench/coreutils/coreutils-case-7380cf79-2e636af1/tempworkdir/tests /home/ubuntu/spr-fast/tests/corebench/coreutils/coreutils-case-7380cf79-2e636af1/tempworkdir 0  > __res
Running test command:
/home/ubuntu/spr-fast/tools/coreutils-test.py /home/ubuntu/spr-fast/tests/corebench/coreutils/coreutils-case-7380cf79-2e636af1/tempworkdir/src /home/ubuntu/spr-fast/tests/corebench/coreutils/coreutils-case-7380cf79-2e636af1/tempworkdir/tests /home/ubuntu/spr-fast/tests/corebench/coreutils/coreutils-case-7380cf79-2e636af1/tempworkdir 0  > __res
a batched test job starts!
Building:src at:
/home/ubuntu/spr-fast/tests/corebench/coreutils/coreutils-case-7380cf79-2e636af1/tempworkdir/srcMerged code building succ, going to invoke tester!
CondTester, Testing instance id 16:
Running test command:
/home/ubuntu/spr-fast/tools/coreutils-test.py /home/ubuntu/spr-fast/tests/corebench/coreutils/coreutils-case-7380cf79-2e636af1/tempworkdir/src /home/ubuntu/spr-fast/tests/corebench/coreutils/coreutils-case-7380cf79-2e636af1/tempworkdir/tests /home/ubuntu/spr-fast/tests/corebench/coreutils/coreutils-case-7380cf79-2e636af1/tempworkdir 0  > __res
Running test command:
/home/ubuntu/spr-fast/tools/coreutils-test.py /home/ubuntu/spr-fast/tests/corebench/coreutils/coreutils-case-7380cf79-2e636af1/tempworkdir/src /home/ubuntu/spr-fast/tests/corebench/coreutils/coreutils-case-7380cf79-2e636af1/tempworkdir/tests /home/ubuntu/spr-fast/tests/corebench/coreutils/coreutils-case-7380cf79-2e636af1/tempworkdir 0  > __res
Running test command:
/home/ubuntu/spr-fast/tools/coreutils-test.py /home/ubuntu/spr-fast/tests/corebench/coreutils/coreutils-case-7380cf79-2e636af1/tempworkdir/src /home/ubuntu/spr-fast/tests/corebench/coreutils/coreutils-case-7380cf79-2e636af1/tempworkdir/tests /home/ubuntu/spr-fast/tests/corebench/coreutils/coreutils-case-7380cf79-2e636af1/tempworkdir 0  > __res
Running test command:
/home/ubuntu/spr-fast/tools/coreutils-test.py /home/ubuntu/spr-fast/tests/corebench/coreutils/coreutils-case-7380cf79-2e636af1/tempworkdir/src /home/ubuntu/spr-fast/tests/corebench/coreutils/coreutils-case-7380cf79-2e636af1/tempworkdir/tests /home/ubuntu/spr-fast/tests/corebench/coreutils/coreutils-case-7380cf79-2e636af1/tempworkdir 0  > __res
Running test command:
/home/ubuntu/spr-fast/tools/coreutils-test.py /home/ubuntu/spr-fast/tests/corebench/coreutils/coreutils-case-7380cf79-2e636af1/tempworkdir/src /home/ubuntu/spr-fast/tests/corebench/coreutils/coreutils-case-7380cf79-2e636af1/tempworkdir/tests /home/ubuntu/spr-fast/tests/corebench/coreutils/coreutils-case-7380cf79-2e636af1/tempworkdir 0  > __res
Running test command:
/home/ubuntu/spr-fast/tools/coreutils-test.py /home/ubuntu/spr-fast/tests/corebench/coreutils/coreutils-case-7380cf79-2e636af1/tempworkdir/src /home/ubuntu/spr-fast/tests/corebench/coreutils/coreutils-case-7380cf79-2e636af1/tempworkdir/tests /home/ubuntu/spr-fast/tests/corebench/coreutils/coreutils-case-7380cf79-2e636af1/tempworkdir 0  > __res
Running test command:
/home/ubuntu/spr-fast/tools/coreutils-test.py /home/ubuntu/spr-fast/tests/corebench/coreutils/coreutils-case-7380cf79-2e636af1/tempworkdir/src /home/ubuntu/spr-fast/tests/corebench/coreutils/coreutils-case-7380cf79-2e636af1/tempworkdir/tests /home/ubuntu/spr-fast/tests/corebench/coreutils/coreutils-case-7380cf79-2e636af1/tempworkdir 0  > __res
Running test command:
/home/ubuntu/spr-fast/tools/coreutils-test.py /home/ubuntu/spr-fast/tests/corebench/coreutils/coreutils-case-7380cf79-2e636af1/tempworkdir/src /home/ubuntu/spr-fast/tests/corebench/coreutils/coreutils-case-7380cf79-2e636af1/tempworkdir/tests /home/ubuntu/spr-fast/tests/corebench/coreutils/coreutils-case-7380cf79-2e636af1/tempworkdir 0  > __res
Running test command:
/home/ubuntu/spr-fast/tools/coreutils-test.py /home/ubuntu/spr-fast/tests/corebench/coreutils/coreutils-case-7380cf79-2e636af1/tempworkdir/src /home/ubuntu/spr-fast/tests/corebench/coreutils/coreutils-case-7380cf79-2e636af1/tempworkdir/tests /home/ubuntu/spr-fast/tests/corebench/coreutils/coreutils-case-7380cf79-2e636af1/tempworkdir 0  > __res
Running test command:
/home/ubuntu/spr-fast/tools/coreutils-test.py /home/ubuntu/spr-fast/tests/corebench/coreutils/coreutils-case-7380cf79-2e636af1/tempworkdir/src /home/ubuntu/spr-fast/tests/corebench/coreutils/coreutils-case-7380cf79-2e636af1/tempworkdir/tests /home/ubuntu/spr-fast/tests/corebench/coreutils/coreutils-case-7380cf79-2e636af1/tempworkdir 0  > __res
Running test command:
/home/ubuntu/spr-fast/tools/coreutils-test.py /home/ubuntu/spr-fast/tests/corebench/coreutils/coreutils-case-7380cf79-2e636af1/tempworkdir/src /home/ubuntu/spr-fast/tests/corebench/coreutils/coreutils-case-7380cf79-2e636af1/tempworkdir/tests /home/ubuntu/spr-fast/tests/corebench/coreutils/coreutils-case-7380cf79-2e636af1/tempworkdir 0  > __res
CondTester, Testing instance id 17:
Running test command:
/home/ubuntu/spr-fast/tools/coreutils-test.py /home/ubuntu/spr-fast/tests/corebench/coreutils/coreutils-case-7380cf79-2e636af1/tempworkdir/src /home/ubuntu/spr-fast/tests/corebench/coreutils/coreutils-case-7380cf79-2e636af1/tempworkdir/tests /home/ubuntu/spr-fast/tests/corebench/coreutils/coreutils-case-7380cf79-2e636af1/tempworkdir 0  > __res
Running test command:
/home/ubuntu/spr-fast/tools/coreutils-test.py /home/ubuntu/spr-fast/tests/corebench/coreutils/coreutils-case-7380cf79-2e636af1/tempworkdir/src /home/ubuntu/spr-fast/tests/corebench/coreutils/coreutils-case-7380cf79-2e636af1/tempworkdir/tests /home/ubuntu/spr-fast/tests/corebench/coreutils/coreutils-case-7380cf79-2e636af1/tempworkdir 0  > __res
a batched test job starts!
Building:src at:
/home/ubuntu/spr-fast/tests/corebench/coreutils/coreutils-case-7380cf79-2e636af1/tempworkdir/srcMerged code building succ, going to invoke tester!
CondTester, Testing instance id 24:
Running test command:
/home/ubuntu/spr-fast/tools/coreutils-test.py /home/ubuntu/spr-fast/tests/corebench/coreutils/coreutils-case-7380cf79-2e636af1/tempworkdir/src /home/ubuntu/spr-fast/tests/corebench/coreutils/coreutils-case-7380cf79-2e636af1/tempworkdir/tests /home/ubuntu/spr-fast/tests/corebench/coreutils/coreutils-case-7380cf79-2e636af1/tempworkdir 0  > __res
Running test command:
/home/ubuntu/spr-fast/tools/coreutils-test.py /home/ubuntu/spr-fast/tests/corebench/coreutils/coreutils-case-7380cf79-2e636af1/tempworkdir/src /home/ubuntu/spr-fast/tests/corebench/coreutils/coreutils-case-7380cf79-2e636af1/tempworkdir/tests /home/ubuntu/spr-fast/tests/corebench/coreutils/coreutils-case-7380cf79-2e636af1/tempworkdir 0  > __res
Running test command:
/home/ubuntu/spr-fast/tools/coreutils-test.py /home/ubuntu/spr-fast/tests/corebench/coreutils/coreutils-case-7380cf79-2e636af1/tempworkdir/src /home/ubuntu/spr-fast/tests/corebench/coreutils/coreutils-case-7380cf79-2e636af1/tempworkdir/tests /home/ubuntu/spr-fast/tests/corebench/coreutils/coreutils-case-7380cf79-2e636af1/tempworkdir 0  > __res
Running test command:
/home/ubuntu/spr-fast/tools/coreutils-test.py /home/ubuntu/spr-fast/tests/corebench/coreutils/coreutils-case-7380cf79-2e636af1/tempworkdir/src /home/ubuntu/spr-fast/tests/corebench/coreutils/coreutils-case-7380cf79-2e636af1/tempworkdir/tests /home/ubuntu/spr-fast/tests/corebench/coreutils/coreutils-case-7380cf79-2e636af1/tempworkdir 0  > __res
Running test command:
/home/ubuntu/spr-fast/tools/coreutils-test.py /home/ubuntu/spr-fast/tests/corebench/coreutils/coreutils-case-7380cf79-2e636af1/tempworkdir/src /home/ubuntu/spr-fast/tests/corebench/coreutils/coreutils-case-7380cf79-2e636af1/tempworkdir/tests /home/ubuntu/spr-fast/tests/corebench/coreutils/coreutils-case-7380cf79-2e636af1/tempworkdir 0  > __res
Running test command:
/home/ubuntu/spr-fast/tools/coreutils-test.py /home/ubuntu/spr-fast/tests/corebench/coreutils/coreutils-case-7380cf79-2e636af1/tempworkdir/src /home/ubuntu/spr-fast/tests/corebench/coreutils/coreutils-case-7380cf79-2e636af1/tempworkdir/tests /home/ubuntu/spr-fast/tests/corebench/coreutils/coreutils-case-7380cf79-2e636af1/tempworkdir 0  > __res
Running test command:
/home/ubuntu/spr-fast/tools/coreutils-test.py /home/ubuntu/spr-fast/tests/corebench/coreutils/coreutils-case-7380cf79-2e636af1/tempworkdir/src /home/ubuntu/spr-fast/tests/corebench/coreutils/coreutils-case-7380cf79-2e636af1/tempworkdir/tests /home/ubuntu/spr-fast/tests/corebench/coreutils/coreutils-case-7380cf79-2e636af1/tempworkdir 0  > __res
Running test command:
/home/ubuntu/spr-fast/tools/coreutils-test.py /home/ubuntu/spr-fast/tests/corebench/coreutils/coreutils-case-7380cf79-2e636af1/tempworkdir/src /home/ubuntu/spr-fast/tests/corebench/coreutils/coreutils-case-7380cf79-2e636af1/tempworkdir/tests /home/ubuntu/spr-fast/tests/corebench/coreutils/coreutils-case-7380cf79-2e636af1/tempworkdir 0  > __res
Running test command:
/home/ubuntu/spr-fast/tools/coreutils-test.py /home/ubuntu/spr-fast/tests/corebench/coreutils/coreutils-case-7380cf79-2e636af1/tempworkdir/src /home/ubuntu/spr-fast/tests/corebench/coreutils/coreutils-case-7380cf79-2e636af1/tempworkdir/tests /home/ubuntu/spr-fast/tests/corebench/coreutils/coreutils-case-7380cf79-2e636af1/tempworkdir 0  > __res
Running test command:
/home/ubuntu/spr-fast/tools/coreutils-test.py /home/ubuntu/spr-fast/tests/corebench/coreutils/coreutils-case-7380cf79-2e636af1/tempworkdir/src /home/ubuntu/spr-fast/tests/corebench/coreutils/coreutils-case-7380cf79-2e636af1/tempworkdir/tests /home/ubuntu/spr-fast/tests/corebench/coreutils/coreutils-case-7380cf79-2e636af1/tempworkdir 0  > __res
Running test command:
/home/ubuntu/spr-fast/tools/coreutils-test.py /home/ubuntu/spr-fast/tests/corebench/coreutils/coreutils-case-7380cf79-2e636af1/tempworkdir/src /home/ubuntu/spr-fast/tests/corebench/coreutils/coreutils-case-7380cf79-2e636af1/tempworkdir/tests /home/ubuntu/spr-fast/tests/corebench/coreutils/coreutils-case-7380cf79-2e636af1/tempworkdir 0  > __res
CondTester, Testing instance id 25:
Running test command:
/home/ubuntu/spr-fast/tools/coreutils-test.py /home/ubuntu/spr-fast/tests/corebench/coreutils/coreutils-case-7380cf79-2e636af1/tempworkdir/src /home/ubuntu/spr-fast/tests/corebench/coreutils/coreutils-case-7380cf79-2e636af1/tempworkdir/tests /home/ubuntu/spr-fast/tests/corebench/coreutils/coreutils-case-7380cf79-2e636af1/tempworkdir 0  > __res
Running test command:
/home/ubuntu/spr-fast/tools/coreutils-test.py /home/ubuntu/spr-fast/tests/corebench/coreutils/coreutils-case-7380cf79-2e636af1/tempworkdir/src /home/ubuntu/spr-fast/tests/corebench/coreutils/coreutils-case-7380cf79-2e636af1/tempworkdir/tests /home/ubuntu/spr-fast/tests/corebench/coreutils/coreutils-case-7380cf79-2e636af1/tempworkdir 0  > __res
Running test command:
/home/ubuntu/spr-fast/tools/coreutils-test.py /home/ubuntu/spr-fast/tests/corebench/coreutils/coreutils-case-7380cf79-2e636af1/tempworkdir/src /home/ubuntu/spr-fast/tests/corebench/coreutils/coreutils-case-7380cf79-2e636af1/tempworkdir/tests /home/ubuntu/spr-fast/tests/corebench/coreutils/coreutils-case-7380cf79-2e636af1/tempworkdir 0  > __res
Running test command:
/home/ubuntu/spr-fast/tools/coreutils-test.py /home/ubuntu/spr-fast/tests/corebench/coreutils/coreutils-case-7380cf79-2e636af1/tempworkdir/src /home/ubuntu/spr-fast/tests/corebench/coreutils/coreutils-case-7380cf79-2e636af1/tempworkdir/tests /home/ubuntu/spr-fast/tests/corebench/coreutils/coreutils-case-7380cf79-2e636af1/tempworkdir 0  > __res
Running test command:
/home/ubuntu/spr-fast/tools/coreutils-test.py /home/ubuntu/spr-fast/tests/corebench/coreutils/coreutils-case-7380cf79-2e636af1/tempworkdir/src /home/ubuntu/spr-fast/tests/corebench/coreutils/coreutils-case-7380cf79-2e636af1/tempworkdir/tests /home/ubuntu/spr-fast/tests/corebench/coreutils/coreutils-case-7380cf79-2e636af1/tempworkdir 0  > __res
Running test command:
/home/ubuntu/spr-fast/tools/coreutils-test.py /home/ubuntu/spr-fast/tests/corebench/coreutils/coreutils-case-7380cf79-2e636af1/tempworkdir/src /home/ubuntu/spr-fast/tests/corebench/coreutils/coreutils-case-7380cf79-2e636af1/tempworkdir/tests /home/ubuntu/spr-fast/tests/corebench/coreutils/coreutils-case-7380cf79-2e636af1/tempworkdir 0  > __res
Running test command:
/home/ubuntu/spr-fast/tools/coreutils-test.py /home/ubuntu/spr-fast/tests/corebench/coreutils/coreutils-case-7380cf79-2e636af1/tempworkdir/src /home/ubuntu/spr-fast/tests/corebench/coreutils/coreutils-case-7380cf79-2e636af1/tempworkdir/tests /home/ubuntu/spr-fast/tests/corebench/coreutils/coreutils-case-7380cf79-2e636af1/tempworkdir 0  > __res
Running test command:
/home/ubuntu/spr-fast/tools/coreutils-test.py /home/ubuntu/spr-fast/tests/corebench/coreutils/coreutils-case-7380cf79-2e636af1/tempworkdir/src /home/ubuntu/spr-fast/tests/corebench/coreutils/coreutils-case-7380cf79-2e636af1/tempworkdir/tests /home/ubuntu/spr-fast/tests/corebench/coreutils/coreutils-case-7380cf79-2e636af1/tempworkdir 0  > __res
Running test command:
/home/ubuntu/spr-fast/tools/coreutils-test.py /home/ubuntu/spr-fast/tests/corebench/coreutils/coreutils-case-7380cf79-2e636af1/tempworkdir/src /home/ubuntu/spr-fast/tests/corebench/coreutils/coreutils-case-7380cf79-2e636af1/tempworkdir/tests /home/ubuntu/spr-fast/tests/corebench/coreutils/coreutils-case-7380cf79-2e636af1/tempworkdir 0  > __res
Running test command:
/home/ubuntu/spr-fast/tools/coreutils-test.py /home/ubuntu/spr-fast/tests/corebench/coreutils/coreutils-case-7380cf79-2e636af1/tempworkdir/src /home/ubuntu/spr-fast/tests/corebench/coreutils/coreutils-case-7380cf79-2e636af1/tempworkdir/tests /home/ubuntu/spr-fast/tests/corebench/coreutils/coreutils-case-7380cf79-2e636af1/tempworkdir 0  > __res
Running test command:
/home/ubuntu/spr-fast/tools/coreutils-test.py /home/ubuntu/spr-fast/tests/corebench/coreutils/coreutils-case-7380cf79-2e636af1/tempworkdir/src /home/ubuntu/spr-fast/tests/corebench/coreutils/coreutils-case-7380cf79-2e636af1/tempworkdir/tests /home/ubuntu/spr-fast/tests/corebench/coreutils/coreutils-case-7380cf79-2e636af1/tempworkdir 0  > __res
a batched test job starts!
Building:src at:
/home/ubuntu/spr-fast/tests/corebench/coreutils/coreutils-case-7380cf79-2e636af1/tempworkdir/srcMerged code building succ, going to invoke tester!
CondTester, Testing instance id 13:
Running test command:
/home/ubuntu/spr-fast/tools/coreutils-test.py /home/ubuntu/spr-fast/tests/corebench/coreutils/coreutils-case-7380cf79-2e636af1/tempworkdir/src /home/ubuntu/spr-fast/tests/corebench/coreutils/coreutils-case-7380cf79-2e636af1/tempworkdir/tests /home/ubuntu/spr-fast/tests/corebench/coreutils/coreutils-case-7380cf79-2e636af1/tempworkdir 0  > __res
Running test command:
/home/ubuntu/spr-fast/tools/coreutils-test.py /home/ubuntu/spr-fast/tests/corebench/coreutils/coreutils-case-7380cf79-2e636af1/tempworkdir/src /home/ubuntu/spr-fast/tests/corebench/coreutils/coreutils-case-7380cf79-2e636af1/tempworkdir/tests /home/ubuntu/spr-fast/tests/corebench/coreutils/coreutils-case-7380cf79-2e636af1/tempworkdir 0  > __res
CondTester, Testing instance id 22:
Running test command:
/home/ubuntu/spr-fast/tools/coreutils-test.py /home/ubuntu/spr-fast/tests/corebench/coreutils/coreutils-case-7380cf79-2e636af1/tempworkdir/src /home/ubuntu/spr-fast/tests/corebench/coreutils/coreutils-case-7380cf79-2e636af1/tempworkdir/tests /home/ubuntu/spr-fast/tests/corebench/coreutils/coreutils-case-7380cf79-2e636af1/tempworkdir 0  > __res
Running test command:
/home/ubuntu/spr-fast/tools/coreutils-test.py /home/ubuntu/spr-fast/tests/corebench/coreutils/coreutils-case-7380cf79-2e636af1/tempworkdir/src /home/ubuntu/spr-fast/tests/corebench/coreutils/coreutils-case-7380cf79-2e636af1/tempworkdir/tests /home/ubuntu/spr-fast/tests/corebench/coreutils/coreutils-case-7380cf79-2e636af1/tempworkdir 0  > __res
Running test command:
/home/ubuntu/spr-fast/tools/coreutils-test.py /home/ubuntu/spr-fast/tests/corebench/coreutils/coreutils-case-7380cf79-2e636af1/tempworkdir/src /home/ubuntu/spr-fast/tests/corebench/coreutils/coreutils-case-7380cf79-2e636af1/tempworkdir/tests /home/ubuntu/spr-fast/tests/corebench/coreutils/coreutils-case-7380cf79-2e636af1/tempworkdir 0  > __res
Running test command:
/home/ubuntu/spr-fast/tools/coreutils-test.py /home/ubuntu/spr-fast/tests/corebench/coreutils/coreutils-case-7380cf79-2e636af1/tempworkdir/src /home/ubuntu/spr-fast/tests/corebench/coreutils/coreutils-case-7380cf79-2e636af1/tempworkdir/tests /home/ubuntu/spr-fast/tests/corebench/coreutils/coreutils-case-7380cf79-2e636af1/tempworkdir 0  > __res
Running test command:
/home/ubuntu/spr-fast/tools/coreutils-test.py /home/ubuntu/spr-fast/tests/corebench/coreutils/coreutils-case-7380cf79-2e636af1/tempworkdir/src /home/ubuntu/spr-fast/tests/corebench/coreutils/coreutils-case-7380cf79-2e636af1/tempworkdir/tests /home/ubuntu/spr-fast/tests/corebench/coreutils/coreutils-case-7380cf79-2e636af1/tempworkdir 0  > __res
Running test command:
/home/ubuntu/spr-fast/tools/coreutils-test.py /home/ubuntu/spr-fast/tests/corebench/coreutils/coreutils-case-7380cf79-2e636af1/tempworkdir/src /home/ubuntu/spr-fast/tests/corebench/coreutils/coreutils-case-7380cf79-2e636af1/tempworkdir/tests /home/ubuntu/spr-fast/tests/corebench/coreutils/coreutils-case-7380cf79-2e636af1/tempworkdir 0  > __res
Running test command:
/home/ubuntu/spr-fast/tools/coreutils-test.py /home/ubuntu/spr-fast/tests/corebench/coreutils/coreutils-case-7380cf79-2e636af1/tempworkdir/src /home/ubuntu/spr-fast/tests/corebench/coreutils/coreutils-case-7380cf79-2e636af1/tempworkdir/tests /home/ubuntu/spr-fast/tests/corebench/coreutils/coreutils-case-7380cf79-2e636af1/tempworkdir 0  > __res
Running test command:
/home/ubuntu/spr-fast/tools/coreutils-test.py /home/ubuntu/spr-fast/tests/corebench/coreutils/coreutils-case-7380cf79-2e636af1/tempworkdir/src /home/ubuntu/spr-fast/tests/corebench/coreutils/coreutils-case-7380cf79-2e636af1/tempworkdir/tests /home/ubuntu/spr-fast/tests/corebench/coreutils/coreutils-case-7380cf79-2e636af1/tempworkdir 0  > __res
Running test command:
/home/ubuntu/spr-fast/tools/coreutils-test.py /home/ubuntu/spr-fast/tests/corebench/coreutils/coreutils-case-7380cf79-2e636af1/tempworkdir/src /home/ubuntu/spr-fast/tests/corebench/coreutils/coreutils-case-7380cf79-2e636af1/tempworkdir/tests /home/ubuntu/spr-fast/tests/corebench/coreutils/coreutils-case-7380cf79-2e636af1/tempworkdir 0  > __res
Running test command:
/home/ubuntu/spr-fast/tools/coreutils-test.py /home/ubuntu/spr-fast/tests/corebench/coreutils/coreutils-case-7380cf79-2e636af1/tempworkdir/src /home/ubuntu/spr-fast/tests/corebench/coreutils/coreutils-case-7380cf79-2e636af1/tempworkdir/tests /home/ubuntu/spr-fast/tests/corebench/coreutils/coreutils-case-7380cf79-2e636af1/tempworkdir 0  > __res
Running test command:
/home/ubuntu/spr-fast/tools/coreutils-test.py /home/ubuntu/spr-fast/tests/corebench/coreutils/coreutils-case-7380cf79-2e636af1/tempworkdir/src /home/ubuntu/spr-fast/tests/corebench/coreutils/coreutils-case-7380cf79-2e636af1/tempworkdir/tests /home/ubuntu/spr-fast/tests/corebench/coreutils/coreutils-case-7380cf79-2e636af1/tempworkdir 0  > __res
a batched test job starts!
Building:src at:
/home/ubuntu/spr-fast/tests/corebench/coreutils/coreutils-case-7380cf79-2e636af1/tempworkdir/srcMerged code building succ, going to invoke tester!
CondTester, Testing instance id 14:
Running test command:
/home/ubuntu/spr-fast/tools/coreutils-test.py /home/ubuntu/spr-fast/tests/corebench/coreutils/coreutils-case-7380cf79-2e636af1/tempworkdir/src /home/ubuntu/spr-fast/tests/corebench/coreutils/coreutils-case-7380cf79-2e636af1/tempworkdir/tests /home/ubuntu/spr-fast/tests/corebench/coreutils/coreutils-case-7380cf79-2e636af1/tempworkdir 0  > __res
Running test command:
/home/ubuntu/spr-fast/tools/coreutils-test.py /home/ubuntu/spr-fast/tests/corebench/coreutils/coreutils-case-7380cf79-2e636af1/tempworkdir/src /home/ubuntu/spr-fast/tests/corebench/coreutils/coreutils-case-7380cf79-2e636af1/tempworkdir/tests /home/ubuntu/spr-fast/tests/corebench/coreutils/coreutils-case-7380cf79-2e636af1/tempworkdir 0  > __res
CondTester, Testing instance id 15:
Running test command:
/home/ubuntu/spr-fast/tools/coreutils-test.py /home/ubuntu/spr-fast/tests/corebench/coreutils/coreutils-case-7380cf79-2e636af1/tempworkdir/src /home/ubuntu/spr-fast/tests/corebench/coreutils/coreutils-case-7380cf79-2e636af1/tempworkdir/tests /home/ubuntu/spr-fast/tests/corebench/coreutils/coreutils-case-7380cf79-2e636af1/tempworkdir 0  > __res
Running test command:
/home/ubuntu/spr-fast/tools/coreutils-test.py /home/ubuntu/spr-fast/tests/corebench/coreutils/coreutils-case-7380cf79-2e636af1/tempworkdir/src /home/ubuntu/spr-fast/tests/corebench/coreutils/coreutils-case-7380cf79-2e636af1/tempworkdir/tests /home/ubuntu/spr-fast/tests/corebench/coreutils/coreutils-case-7380cf79-2e636af1/tempworkdir 0  > __res
Running test command:
/home/ubuntu/spr-fast/tools/coreutils-test.py /home/ubuntu/spr-fast/tests/corebench/coreutils/coreutils-case-7380cf79-2e636af1/tempworkdir/src /home/ubuntu/spr-fast/tests/corebench/coreutils/coreutils-case-7380cf79-2e636af1/tempworkdir/tests /home/ubuntu/spr-fast/tests/corebench/coreutils/coreutils-case-7380cf79-2e636af1/tempworkdir 0  > __res
Running test command:
/home/ubuntu/spr-fast/tools/coreutils-test.py /home/ubuntu/spr-fast/tests/corebench/coreutils/coreutils-case-7380cf79-2e636af1/tempworkdir/src /home/ubuntu/spr-fast/tests/corebench/coreutils/coreutils-case-7380cf79-2e636af1/tempworkdir/tests /home/ubuntu/spr-fast/tests/corebench/coreutils/coreutils-case-7380cf79-2e636af1/tempworkdir 0  > __res
Running test command:
/home/ubuntu/spr-fast/tools/coreutils-test.py /home/ubuntu/spr-fast/tests/corebench/coreutils/coreutils-case-7380cf79-2e636af1/tempworkdir/src /home/ubuntu/spr-fast/tests/corebench/coreutils/coreutils-case-7380cf79-2e636af1/tempworkdir/tests /home/ubuntu/spr-fast/tests/corebench/coreutils/coreutils-case-7380cf79-2e636af1/tempworkdir 0  > __res
Running test command:
/home/ubuntu/spr-fast/tools/coreutils-test.py /home/ubuntu/spr-fast/tests/corebench/coreutils/coreutils-case-7380cf79-2e636af1/tempworkdir/src /home/ubuntu/spr-fast/tests/corebench/coreutils/coreutils-case-7380cf79-2e636af1/tempworkdir/tests /home/ubuntu/spr-fast/tests/corebench/coreutils/coreutils-case-7380cf79-2e636af1/tempworkdir 0  > __res
Running test command:
/home/ubuntu/spr-fast/tools/coreutils-test.py /home/ubuntu/spr-fast/tests/corebench/coreutils/coreutils-case-7380cf79-2e636af1/tempworkdir/src /home/ubuntu/spr-fast/tests/corebench/coreutils/coreutils-case-7380cf79-2e636af1/tempworkdir/tests /home/ubuntu/spr-fast/tests/corebench/coreutils/coreutils-case-7380cf79-2e636af1/tempworkdir 0  > __res
Running test command:
/home/ubuntu/spr-fast/tools/coreutils-test.py /home/ubuntu/spr-fast/tests/corebench/coreutils/coreutils-case-7380cf79-2e636af1/tempworkdir/src /home/ubuntu/spr-fast/tests/corebench/coreutils/coreutils-case-7380cf79-2e636af1/tempworkdir/tests /home/ubuntu/spr-fast/tests/corebench/coreutils/coreutils-case-7380cf79-2e636af1/tempworkdir 0  > __res
Running test command:
/home/ubuntu/spr-fast/tools/coreutils-test.py /home/ubuntu/spr-fast/tests/corebench/coreutils/coreutils-case-7380cf79-2e636af1/tempworkdir/src /home/ubuntu/spr-fast/tests/corebench/coreutils/coreutils-case-7380cf79-2e636af1/tempworkdir/tests /home/ubuntu/spr-fast/tests/corebench/coreutils/coreutils-case-7380cf79-2e636af1/tempworkdir 0  > __res
Running test command:
/home/ubuntu/spr-fast/tools/coreutils-test.py /home/ubuntu/spr-fast/tests/corebench/coreutils/coreutils-case-7380cf79-2e636af1/tempworkdir/src /home/ubuntu/spr-fast/tests/corebench/coreutils/coreutils-case-7380cf79-2e636af1/tempworkdir/tests /home/ubuntu/spr-fast/tests/corebench/coreutils/coreutils-case-7380cf79-2e636af1/tempworkdir 0  > __res
Running test command:
/home/ubuntu/spr-fast/tools/coreutils-test.py /home/ubuntu/spr-fast/tests/corebench/coreutils/coreutils-case-7380cf79-2e636af1/tempworkdir/src /home/ubuntu/spr-fast/tests/corebench/coreutils/coreutils-case-7380cf79-2e636af1/tempworkdir/tests /home/ubuntu/spr-fast/tests/corebench/coreutils/coreutils-case-7380cf79-2e636af1/tempworkdir 0  > __res
a batched test job starts!
Building:src at:
/home/ubuntu/spr-fast/tests/corebench/coreutils/coreutils-case-7380cf79-2e636af1/tempworkdir/srcMerged code building succ, going to invoke tester!
CondTester, Testing instance id 47:
Running test command:
/home/ubuntu/spr-fast/tools/coreutils-test.py /home/ubuntu/spr-fast/tests/corebench/coreutils/coreutils-case-7380cf79-2e636af1/tempworkdir/src /home/ubuntu/spr-fast/tests/corebench/coreutils/coreutils-case-7380cf79-2e636af1/tempworkdir/tests /home/ubuntu/spr-fast/tests/corebench/coreutils/coreutils-case-7380cf79-2e636af1/tempworkdir 0  > __res
Running test command:
/home/ubuntu/spr-fast/tools/coreutils-test.py /home/ubuntu/spr-fast/tests/corebench/coreutils/coreutils-case-7380cf79-2e636af1/tempworkdir/src /home/ubuntu/spr-fast/tests/corebench/coreutils/coreutils-case-7380cf79-2e636af1/tempworkdir/tests /home/ubuntu/spr-fast/tests/corebench/coreutils/coreutils-case-7380cf79-2e636af1/tempworkdir 0  > __res
Running test command:
/home/ubuntu/spr-fast/tools/coreutils-test.py /home/ubuntu/spr-fast/tests/corebench/coreutils/coreutils-case-7380cf79-2e636af1/tempworkdir/src /home/ubuntu/spr-fast/tests/corebench/coreutils/coreutils-case-7380cf79-2e636af1/tempworkdir/tests /home/ubuntu/spr-fast/tests/corebench/coreutils/coreutils-case-7380cf79-2e636af1/tempworkdir 0  > __res
a batched test job starts!
Building:src at:
/home/ubuntu/spr-fast/tests/corebench/coreutils/coreutils-case-7380cf79-2e636af1/tempworkdir/srcMerged code building succ, going to invoke tester!
CondTester, Testing instance id 46:
Running test command:
/home/ubuntu/spr-fast/tools/coreutils-test.py /home/ubuntu/spr-fast/tests/corebench/coreutils/coreutils-case-7380cf79-2e636af1/tempworkdir/src /home/ubuntu/spr-fast/tests/corebench/coreutils/coreutils-case-7380cf79-2e636af1/tempworkdir/tests /home/ubuntu/spr-fast/tests/corebench/coreutils/coreutils-case-7380cf79-2e636af1/tempworkdir 0  > __res
Running test command:
/home/ubuntu/spr-fast/tools/coreutils-test.py /home/ubuntu/spr-fast/tests/corebench/coreutils/coreutils-case-7380cf79-2e636af1/tempworkdir/src /home/ubuntu/spr-fast/tests/corebench/coreutils/coreutils-case-7380cf79-2e636af1/tempworkdir/tests /home/ubuntu/spr-fast/tests/corebench/coreutils/coreutils-case-7380cf79-2e636af1/tempworkdir 0  > __res
Running test command:
/home/ubuntu/spr-fast/tools/coreutils-test.py /home/ubuntu/spr-fast/tests/corebench/coreutils/coreutils-case-7380cf79-2e636af1/tempworkdir/src /home/ubuntu/spr-fast/tests/corebench/coreutils/coreutils-case-7380cf79-2e636af1/tempworkdir/tests /home/ubuntu/spr-fast/tests/corebench/coreutils/coreutils-case-7380cf79-2e636af1/tempworkdir 0  > __res
BasicTester, Testing instance id 221:
Running test command:
/home/ubuntu/spr-fast/tools/coreutils-test.py /home/ubuntu/spr-fast/tests/corebench/coreutils/coreutils-case-7380cf79-2e636af1/tempworkdir/src /home/ubuntu/spr-fast/tests/corebench/coreutils/coreutils-case-7380cf79-2e636af1/tempworkdir/tests /home/ubuntu/spr-fast/tests/corebench/coreutils/coreutils-case-7380cf79-2e636af1/tempworkdir 0  > __res
a batched test job starts!
Building:src at:
/home/ubuntu/spr-fast/tests/corebench/coreutils/coreutils-case-7380cf79-2e636af1/tempworkdir/srcMerged code building succ, going to invoke tester!
CondTester, Testing instance id 45:
Running test command:
/home/ubuntu/spr-fast/tools/coreutils-test.py /home/ubuntu/spr-fast/tests/corebench/coreutils/coreutils-case-7380cf79-2e636af1/tempworkdir/src /home/ubuntu/spr-fast/tests/corebench/coreutils/coreutils-case-7380cf79-2e636af1/tempworkdir/tests /home/ubuntu/spr-fast/tests/corebench/coreutils/coreutils-case-7380cf79-2e636af1/tempworkdir 0  > __res
Running test command:
/home/ubuntu/spr-fast/tools/coreutils-test.py /home/ubuntu/spr-fast/tests/corebench/coreutils/coreutils-case-7380cf79-2e636af1/tempworkdir/src /home/ubuntu/spr-fast/tests/corebench/coreutils/coreutils-case-7380cf79-2e636af1/tempworkdir/tests /home/ubuntu/spr-fast/tests/corebench/coreutils/coreutils-case-7380cf79-2e636af1/tempworkdir 0  > __res
Running test command:
/home/ubuntu/spr-fast/tools/coreutils-test.py /home/ubuntu/spr-fast/tests/corebench/coreutils/coreutils-case-7380cf79-2e636af1/tempworkdir/src /home/ubuntu/spr-fast/tests/corebench/coreutils/coreutils-case-7380cf79-2e636af1/tempworkdir/tests /home/ubuntu/spr-fast/tests/corebench/coreutils/coreutils-case-7380cf79-2e636af1/tempworkdir 0  > __res
a batched test job starts!
Building:src at:
/home/ubuntu/spr-fast/tests/corebench/coreutils/coreutils-case-7380cf79-2e636af1/tempworkdir/srcMerged code building succ, going to invoke tester!
BasicTester, Testing instance id 214:
Running test command:
/home/ubuntu/spr-fast/tools/coreutils-test.py /home/ubuntu/spr-fast/tests/corebench/coreutils/coreutils-case-7380cf79-2e636af1/tempworkdir/src /home/ubuntu/spr-fast/tests/corebench/coreutils/coreutils-case-7380cf79-2e636af1/tempworkdir/tests /home/ubuntu/spr-fast/tests/corebench/coreutils/coreutils-case-7380cf79-2e636af1/tempworkdir 0  > __res
BasicTester, Testing instance id 215:
Running test command:
/home/ubuntu/spr-fast/tools/coreutils-test.py /home/ubuntu/spr-fast/tests/corebench/coreutils/coreutils-case-7380cf79-2e636af1/tempworkdir/src /home/ubuntu/spr-fast/tests/corebench/coreutils/coreutils-case-7380cf79-2e636af1/tempworkdir/tests /home/ubuntu/spr-fast/tests/corebench/coreutils/coreutils-case-7380cf79-2e636af1/tempworkdir 0  > __res
BasicTester, Testing instance id 216:
Running test command:
/home/ubuntu/spr-fast/tools/coreutils-test.py /home/ubuntu/spr-fast/tests/corebench/coreutils/coreutils-case-7380cf79-2e636af1/tempworkdir/src /home/ubuntu/spr-fast/tests/corebench/coreutils/coreutils-case-7380cf79-2e636af1/tempworkdir/tests /home/ubuntu/spr-fast/tests/corebench/coreutils/coreutils-case-7380cf79-2e636af1/tempworkdir 0  > __res
CondTester, Testing instance id 44:
Running test command:
/home/ubuntu/spr-fast/tools/coreutils-test.py /home/ubuntu/spr-fast/tests/corebench/coreutils/coreutils-case-7380cf79-2e636af1/tempworkdir/src /home/ubuntu/spr-fast/tests/corebench/coreutils/coreutils-case-7380cf79-2e636af1/tempworkdir/tests /home/ubuntu/spr-fast/tests/corebench/coreutils/coreutils-case-7380cf79-2e636af1/tempworkdir 0  > __res
Running test command:
/home/ubuntu/spr-fast/tools/coreutils-test.py /home/ubuntu/spr-fast/tests/corebench/coreutils/coreutils-case-7380cf79-2e636af1/tempworkdir/src /home/ubuntu/spr-fast/tests/corebench/coreutils/coreutils-case-7380cf79-2e636af1/tempworkdir/tests /home/ubuntu/spr-fast/tests/corebench/coreutils/coreutils-case-7380cf79-2e636af1/tempworkdir 0  > __res
Running test command:
/home/ubuntu/spr-fast/tools/coreutils-test.py /home/ubuntu/spr-fast/tests/corebench/coreutils/coreutils-case-7380cf79-2e636af1/tempworkdir/src /home/ubuntu/spr-fast/tests/corebench/coreutils/coreutils-case-7380cf79-2e636af1/tempworkdir/tests /home/ubuntu/spr-fast/tests/corebench/coreutils/coreutils-case-7380cf79-2e636af1/tempworkdir 0  > __res
BasicTester, Testing instance id 217:
Running test command:
/home/ubuntu/spr-fast/tools/coreutils-test.py /home/ubuntu/spr-fast/tests/corebench/coreutils/coreutils-case-7380cf79-2e636af1/tempworkdir/src /home/ubuntu/spr-fast/tests/corebench/coreutils/coreutils-case-7380cf79-2e636af1/tempworkdir/tests /home/ubuntu/spr-fast/tests/corebench/coreutils/coreutils-case-7380cf79-2e636af1/tempworkdir 0  > __res
BasicTester, Testing instance id 218:
Running test command:
/home/ubuntu/spr-fast/tools/coreutils-test.py /home/ubuntu/spr-fast/tests/corebench/coreutils/coreutils-case-7380cf79-2e636af1/tempworkdir/src /home/ubuntu/spr-fast/tests/corebench/coreutils/coreutils-case-7380cf79-2e636af1/tempworkdir/tests /home/ubuntu/spr-fast/tests/corebench/coreutils/coreutils-case-7380cf79-2e636af1/tempworkdir 0  > __res
BasicTester, Testing instance id 219:
Running test command:
/home/ubuntu/spr-fast/tools/coreutils-test.py /home/ubuntu/spr-fast/tests/corebench/coreutils/coreutils-case-7380cf79-2e636af1/tempworkdir/src /home/ubuntu/spr-fast/tests/corebench/coreutils/coreutils-case-7380cf79-2e636af1/tempworkdir/tests /home/ubuntu/spr-fast/tests/corebench/coreutils/coreutils-case-7380cf79-2e636af1/tempworkdir 0  > __res
BasicTester, Testing instance id 220:
Running test command:
/home/ubuntu/spr-fast/tools/coreutils-test.py /home/ubuntu/spr-fast/tests/corebench/coreutils/coreutils-case-7380cf79-2e636af1/tempworkdir/src /home/ubuntu/spr-fast/tests/corebench/coreutils/coreutils-case-7380cf79-2e636af1/tempworkdir/tests /home/ubuntu/spr-fast/tests/corebench/coreutils/coreutils-case-7380cf79-2e636af1/tempworkdir 0  > __res
a batched test job starts!
Building:src at:
/home/ubuntu/spr-fast/tests/corebench/coreutils/coreutils-case-7380cf79-2e636af1/tempworkdir/srcMerged code building succ, going to invoke tester!
CondTester, Testing instance id 43:
Running test command:
/home/ubuntu/spr-fast/tools/coreutils-test.py /home/ubuntu/spr-fast/tests/corebench/coreutils/coreutils-case-7380cf79-2e636af1/tempworkdir/src /home/ubuntu/spr-fast/tests/corebench/coreutils/coreutils-case-7380cf79-2e636af1/tempworkdir/tests /home/ubuntu/spr-fast/tests/corebench/coreutils/coreutils-case-7380cf79-2e636af1/tempworkdir 0  > __res
Running test command:
/home/ubuntu/spr-fast/tools/coreutils-test.py /home/ubuntu/spr-fast/tests/corebench/coreutils/coreutils-case-7380cf79-2e636af1/tempworkdir/src /home/ubuntu/spr-fast/tests/corebench/coreutils/coreutils-case-7380cf79-2e636af1/tempworkdir/tests /home/ubuntu/spr-fast/tests/corebench/coreutils/coreutils-case-7380cf79-2e636af1/tempworkdir 0  > __res
Running test command:
/home/ubuntu/spr-fast/tools/coreutils-test.py /home/ubuntu/spr-fast/tests/corebench/coreutils/coreutils-case-7380cf79-2e636af1/tempworkdir/src /home/ubuntu/spr-fast/tests/corebench/coreutils/coreutils-case-7380cf79-2e636af1/tempworkdir/tests /home/ubuntu/spr-fast/tests/corebench/coreutils/coreutils-case-7380cf79-2e636af1/tempworkdir 0  > __res
BasicTester, Testing instance id 213:
Running test command:
/home/ubuntu/spr-fast/tools/coreutils-test.py /home/ubuntu/spr-fast/tests/corebench/coreutils/coreutils-case-7380cf79-2e636af1/tempworkdir/src /home/ubuntu/spr-fast/tests/corebench/coreutils/coreutils-case-7380cf79-2e636af1/tempworkdir/tests /home/ubuntu/spr-fast/tests/corebench/coreutils/coreutils-case-7380cf79-2e636af1/tempworkdir 0  > __res
a batched test job starts!
Building:src at:
/home/ubuntu/spr-fast/tests/corebench/coreutils/coreutils-case-7380cf79-2e636af1/tempworkdir/srcMerged code building succ, going to invoke tester!
CondTester, Testing instance id 9:
Running test command:
/home/ubuntu/spr-fast/tools/coreutils-test.py /home/ubuntu/spr-fast/tests/corebench/coreutils/coreutils-case-7380cf79-2e636af1/tempworkdir/src /home/ubuntu/spr-fast/tests/corebench/coreutils/coreutils-case-7380cf79-2e636af1/tempworkdir/tests /home/ubuntu/spr-fast/tests/corebench/coreutils/coreutils-case-7380cf79-2e636af1/tempworkdir 0  > __res
Running test command:
/home/ubuntu/spr-fast/tools/coreutils-test.py /home/ubuntu/spr-fast/tests/corebench/coreutils/coreutils-case-7380cf79-2e636af1/tempworkdir/src /home/ubuntu/spr-fast/tests/corebench/coreutils/coreutils-case-7380cf79-2e636af1/tempworkdir/tests /home/ubuntu/spr-fast/tests/corebench/coreutils/coreutils-case-7380cf79-2e636af1/tempworkdir 0  > __res
CondTester, Testing instance id 10:
Running test command:
/home/ubuntu/spr-fast/tools/coreutils-test.py /home/ubuntu/spr-fast/tests/corebench/coreutils/coreutils-case-7380cf79-2e636af1/tempworkdir/src /home/ubuntu/spr-fast/tests/corebench/coreutils/coreutils-case-7380cf79-2e636af1/tempworkdir/tests /home/ubuntu/spr-fast/tests/corebench/coreutils/coreutils-case-7380cf79-2e636af1/tempworkdir 0  > __res
Running test command:
/home/ubuntu/spr-fast/tools/coreutils-test.py /home/ubuntu/spr-fast/tests/corebench/coreutils/coreutils-case-7380cf79-2e636af1/tempworkdir/src /home/ubuntu/spr-fast/tests/corebench/coreutils/coreutils-case-7380cf79-2e636af1/tempworkdir/tests /home/ubuntu/spr-fast/tests/corebench/coreutils/coreutils-case-7380cf79-2e636af1/tempworkdir 0  > __res
CondTester, Testing instance id 11:
Running test command:
/home/ubuntu/spr-fast/tools/coreutils-test.py /home/ubuntu/spr-fast/tests/corebench/coreutils/coreutils-case-7380cf79-2e636af1/tempworkdir/src /home/ubuntu/spr-fast/tests/corebench/coreutils/coreutils-case-7380cf79-2e636af1/tempworkdir/tests /home/ubuntu/spr-fast/tests/corebench/coreutils/coreutils-case-7380cf79-2e636af1/tempworkdir 0  > __res
Running test command:
/home/ubuntu/spr-fast/tools/coreutils-test.py /home/ubuntu/spr-fast/tests/corebench/coreutils/coreutils-case-7380cf79-2e636af1/tempworkdir/src /home/ubuntu/spr-fast/tests/corebench/coreutils/coreutils-case-7380cf79-2e636af1/tempworkdir/tests /home/ubuntu/spr-fast/tests/corebench/coreutils/coreutils-case-7380cf79-2e636af1/tempworkdir 0  > __res
CondTester, Testing instance id 41:
Running test command:
/home/ubuntu/spr-fast/tools/coreutils-test.py /home/ubuntu/spr-fast/tests/corebench/coreutils/coreutils-case-7380cf79-2e636af1/tempworkdir/src /home/ubuntu/spr-fast/tests/corebench/coreutils/coreutils-case-7380cf79-2e636af1/tempworkdir/tests /home/ubuntu/spr-fast/tests/corebench/coreutils/coreutils-case-7380cf79-2e636af1/tempworkdir 0  > __res
Running test command:
/home/ubuntu/spr-fast/tools/coreutils-test.py /home/ubuntu/spr-fast/tests/corebench/coreutils/coreutils-case-7380cf79-2e636af1/tempworkdir/src /home/ubuntu/spr-fast/tests/corebench/coreutils/coreutils-case-7380cf79-2e636af1/tempworkdir/tests /home/ubuntu/spr-fast/tests/corebench/coreutils/coreutils-case-7380cf79-2e636af1/tempworkdir 0  > __res
Running test command:
/home/ubuntu/spr-fast/tools/coreutils-test.py /home/ubuntu/spr-fast/tests/corebench/coreutils/coreutils-case-7380cf79-2e636af1/tempworkdir/src /home/ubuntu/spr-fast/tests/corebench/coreutils/coreutils-case-7380cf79-2e636af1/tempworkdir/tests /home/ubuntu/spr-fast/tests/corebench/coreutils/coreutils-case-7380cf79-2e636af1/tempworkdir 0  > __res
Passed Negative Cases wiht CondTestder!
Running test command:
/home/ubuntu/spr-fast/tools/coreutils-test.py /home/ubuntu/spr-fast/tests/corebench/coreutils/coreutils-case-7380cf79-2e636af1/tempworkdir/src /home/ubuntu/spr-fast/tests/corebench/coreutils/coreutils-case-7380cf79-2e636af1/tempworkdir/tests /home/ubuntu/spr-fast/tests/corebench/coreutils/coreutils-case-7380cf79-2e636af1/tempworkdir 3  > __res
Running test command:
/home/ubuntu/spr-fast/tools/coreutils-test.py /home/ubuntu/spr-fast/tests/corebench/coreutils/coreutils-case-7380cf79-2e636af1/tempworkdir/src /home/ubuntu/spr-fast/tests/corebench/coreutils/coreutils-case-7380cf79-2e636af1/tempworkdir/tests /home/ubuntu/spr-fast/tests/corebench/coreutils/coreutils-case-7380cf79-2e636af1/tempworkdir 4  > __res
Running test command:
/home/ubuntu/spr-fast/tools/coreutils-test.py /home/ubuntu/spr-fast/tests/corebench/coreutils/coreutils-case-7380cf79-2e636af1/tempworkdir/src /home/ubuntu/spr-fast/tests/corebench/coreutils/coreutils-case-7380cf79-2e636af1/tempworkdir/tests /home/ubuntu/spr-fast/tests/corebench/coreutils/coreutils-case-7380cf79-2e636af1/tempworkdir 7  > __res
Running test command:
/home/ubuntu/spr-fast/tools/coreutils-test.py /home/ubuntu/spr-fast/tests/corebench/coreutils/coreutils-case-7380cf79-2e636af1/tempworkdir/src /home/ubuntu/spr-fast/tests/corebench/coreutils/coreutils-case-7380cf79-2e636af1/tempworkdir/tests /home/ubuntu/spr-fast/tests/corebench/coreutils/coreutils-case-7380cf79-2e636af1/tempworkdir 8  > __res
Running test command:
/home/ubuntu/spr-fast/tools/coreutils-test.py /home/ubuntu/spr-fast/tests/corebench/coreutils/coreutils-case-7380cf79-2e636af1/tempworkdir/src /home/ubuntu/spr-fast/tests/corebench/coreutils/coreutils-case-7380cf79-2e636af1/tempworkdir/tests /home/ubuntu/spr-fast/tests/corebench/coreutils/coreutils-case-7380cf79-2e636af1/tempworkdir 10  > __res
Running test command:
/home/ubuntu/spr-fast/tools/coreutils-test.py /home/ubuntu/spr-fast/tests/corebench/coreutils/coreutils-case-7380cf79-2e636af1/tempworkdir/src /home/ubuntu/spr-fast/tests/corebench/coreutils/coreutils-case-7380cf79-2e636af1/tempworkdir/tests /home/ubuntu/spr-fast/tests/corebench/coreutils/coreutils-case-7380cf79-2e636af1/tempworkdir 14  > __res
Running test command:
/home/ubuntu/spr-fast/tools/coreutils-test.py /home/ubuntu/spr-fast/tests/corebench/coreutils/coreutils-case-7380cf79-2e636af1/tempworkdir/src /home/ubuntu/spr-fast/tests/corebench/coreutils/coreutils-case-7380cf79-2e636af1/tempworkdir/tests /home/ubuntu/spr-fast/tests/corebench/coreutils/coreutils-case-7380cf79-2e636af1/tempworkdir 16  > __res
Running test command:
/home/ubuntu/spr-fast/tools/coreutils-test.py /home/ubuntu/spr-fast/tests/corebench/coreutils/coreutils-case-7380cf79-2e636af1/tempworkdir/src /home/ubuntu/spr-fast/tests/corebench/coreutils/coreutils-case-7380cf79-2e636af1/tempworkdir/tests /home/ubuntu/spr-fast/tests/corebench/coreutils/coreutils-case-7380cf79-2e636af1/tempworkdir 18  > __res
Running test command:
/home/ubuntu/spr-fast/tools/coreutils-test.py /home/ubuntu/spr-fast/tests/corebench/coreutils/coreutils-case-7380cf79-2e636af1/tempworkdir/src /home/ubuntu/spr-fast/tests/corebench/coreutils/coreutils-case-7380cf79-2e636af1/tempworkdir/tests /home/ubuntu/spr-fast/tests/corebench/coreutils/coreutils-case-7380cf79-2e636af1/tempworkdir 19  > __res
Running test command:
/home/ubuntu/spr-fast/tools/coreutils-test.py /home/ubuntu/spr-fast/tests/corebench/coreutils/coreutils-case-7380cf79-2e636af1/tempworkdir/src /home/ubuntu/spr-fast/tests/corebench/coreutils/coreutils-case-7380cf79-2e636af1/tempworkdir/tests /home/ubuntu/spr-fast/tests/corebench/coreutils/coreutils-case-7380cf79-2e636af1/tempworkdir 20  > __res
Running test command:
/home/ubuntu/spr-fast/tools/coreutils-test.py /home/ubuntu/spr-fast/tests/corebench/coreutils/coreutils-case-7380cf79-2e636af1/tempworkdir/src /home/ubuntu/spr-fast/tests/corebench/coreutils/coreutils-case-7380cf79-2e636af1/tempworkdir/tests /home/ubuntu/spr-fast/tests/corebench/coreutils/coreutils-case-7380cf79-2e636af1/tempworkdir 21  > __res
Running test command:
/home/ubuntu/spr-fast/tools/coreutils-test.py /home/ubuntu/spr-fast/tests/corebench/coreutils/coreutils-case-7380cf79-2e636af1/tempworkdir/src /home/ubuntu/spr-fast/tests/corebench/coreutils/coreutils-case-7380cf79-2e636af1/tempworkdir/tests /home/ubuntu/spr-fast/tests/corebench/coreutils/coreutils-case-7380cf79-2e636af1/tempworkdir 22  > __res
Running test command:
/home/ubuntu/spr-fast/tools/coreutils-test.py /home/ubuntu/spr-fast/tests/corebench/coreutils/coreutils-case-7380cf79-2e636af1/tempworkdir/src /home/ubuntu/spr-fast/tests/corebench/coreutils/coreutils-case-7380cf79-2e636af1/tempworkdir/tests /home/ubuntu/spr-fast/tests/corebench/coreutils/coreutils-case-7380cf79-2e636af1/tempworkdir 24  > __res
Running test command:
/home/ubuntu/spr-fast/tools/coreutils-test.py /home/ubuntu/spr-fast/tests/corebench/coreutils/coreutils-case-7380cf79-2e636af1/tempworkdir/src /home/ubuntu/spr-fast/tests/corebench/coreutils/coreutils-case-7380cf79-2e636af1/tempworkdir/tests /home/ubuntu/spr-fast/tests/corebench/coreutils/coreutils-case-7380cf79-2e636af1/tempworkdir 25  > __res
Running test command:
/home/ubuntu/spr-fast/tools/coreutils-test.py /home/ubuntu/spr-fast/tests/corebench/coreutils/coreutils-case-7380cf79-2e636af1/tempworkdir/src /home/ubuntu/spr-fast/tests/corebench/coreutils/coreutils-case-7380cf79-2e636af1/tempworkdir/tests /home/ubuntu/spr-fast/tests/corebench/coreutils/coreutils-case-7380cf79-2e636af1/tempworkdir 26  > __res
Running test command:
/home/ubuntu/spr-fast/tools/coreutils-test.py /home/ubuntu/spr-fast/tests/corebench/coreutils/coreutils-case-7380cf79-2e636af1/tempworkdir/src /home/ubuntu/spr-fast/tests/corebench/coreutils/coreutils-case-7380cf79-2e636af1/tempworkdir/tests /home/ubuntu/spr-fast/tests/corebench/coreutils/coreutils-case-7380cf79-2e636af1/tempworkdir 27  > __res
Running test command:
/home/ubuntu/spr-fast/tools/coreutils-test.py /home/ubuntu/spr-fast/tests/corebench/coreutils/coreutils-case-7380cf79-2e636af1/tempworkdir/src /home/ubuntu/spr-fast/tests/corebench/coreutils/coreutils-case-7380cf79-2e636af1/tempworkdir/tests /home/ubuntu/spr-fast/tests/corebench/coreutils/coreutils-case-7380cf79-2e636af1/tempworkdir 32  > __res
Running test command:
/home/ubuntu/spr-fast/tools/coreutils-test.py /home/ubuntu/spr-fast/tests/corebench/coreutils/coreutils-case-7380cf79-2e636af1/tempworkdir/src /home/ubuntu/spr-fast/tests/corebench/coreutils/coreutils-case-7380cf79-2e636af1/tempworkdir/tests /home/ubuntu/spr-fast/tests/corebench/coreutils/coreutils-case-7380cf79-2e636af1/tempworkdir 34  > __res
Running test command:
/home/ubuntu/spr-fast/tools/coreutils-test.py /home/ubuntu/spr-fast/tests/corebench/coreutils/coreutils-case-7380cf79-2e636af1/tempworkdir/src /home/ubuntu/spr-fast/tests/corebench/coreutils/coreutils-case-7380cf79-2e636af1/tempworkdir/tests /home/ubuntu/spr-fast/tests/corebench/coreutils/coreutils-case-7380cf79-2e636af1/tempworkdir 38  > __res
Running test command:
/home/ubuntu/spr-fast/tools/coreutils-test.py /home/ubuntu/spr-fast/tests/corebench/coreutils/coreutils-case-7380cf79-2e636af1/tempworkdir/src /home/ubuntu/spr-fast/tests/corebench/coreutils/coreutils-case-7380cf79-2e636af1/tempworkdir/tests /home/ubuntu/spr-fast/tests/corebench/coreutils/coreutils-case-7380cf79-2e636af1/tempworkdir 40  > __res
Passed Positive Cases
Running test command:
/home/ubuntu/spr-fast/tools/coreutils-test.py /home/ubuntu/spr-fast/tests/corebench/coreutils/coreutils-case-7380cf79-2e636af1/tempworkdir/src /home/ubuntu/spr-fast/tests/corebench/coreutils/coreutils-case-7380cf79-2e636af1/tempworkdir/tests /home/ubuntu/spr-fast/tests/corebench/coreutils/coreutils-case-7380cf79-2e636af1/tempworkdir 0  > __res
Running test command:
/home/ubuntu/spr-fast/tools/coreutils-test.py /home/ubuntu/spr-fast/tests/corebench/coreutils/coreutils-case-7380cf79-2e636af1/tempworkdir/src /home/ubuntu/spr-fast/tests/corebench/coreutils/coreutils-case-7380cf79-2e636af1/tempworkdir/tests /home/ubuntu/spr-fast/tests/corebench/coreutils/coreutils-case-7380cf79-2e636af1/tempworkdir 3  > __res
Running test command:
/home/ubuntu/spr-fast/tools/coreutils-test.py /home/ubuntu/spr-fast/tests/corebench/coreutils/coreutils-case-7380cf79-2e636af1/tempworkdir/src /home/ubuntu/spr-fast/tests/corebench/coreutils/coreutils-case-7380cf79-2e636af1/tempworkdir/tests /home/ubuntu/spr-fast/tests/corebench/coreutils/coreutils-case-7380cf79-2e636af1/tempworkdir 4  > __res
Running test command:
/home/ubuntu/spr-fast/tools/coreutils-test.py /home/ubuntu/spr-fast/tests/corebench/coreutils/coreutils-case-7380cf79-2e636af1/tempworkdir/src /home/ubuntu/spr-fast/tests/corebench/coreutils/coreutils-case-7380cf79-2e636af1/tempworkdir/tests /home/ubuntu/spr-fast/tests/corebench/coreutils/coreutils-case-7380cf79-2e636af1/tempworkdir 7  > __res
Running test command:
/home/ubuntu/spr-fast/tools/coreutils-test.py /home/ubuntu/spr-fast/tests/corebench/coreutils/coreutils-case-7380cf79-2e636af1/tempworkdir/src /home/ubuntu/spr-fast/tests/corebench/coreutils/coreutils-case-7380cf79-2e636af1/tempworkdir/tests /home/ubuntu/spr-fast/tests/corebench/coreutils/coreutils-case-7380cf79-2e636af1/tempworkdir 8  > __res
Running test command:
/home/ubuntu/spr-fast/tools/coreutils-test.py /home/ubuntu/spr-fast/tests/corebench/coreutils/coreutils-case-7380cf79-2e636af1/tempworkdir/src /home/ubuntu/spr-fast/tests/corebench/coreutils/coreutils-case-7380cf79-2e636af1/tempworkdir/tests /home/ubuntu/spr-fast/tests/corebench/coreutils/coreutils-case-7380cf79-2e636af1/tempworkdir 10  > __res
Running test command:
/home/ubuntu/spr-fast/tools/coreutils-test.py /home/ubuntu/spr-fast/tests/corebench/coreutils/coreutils-case-7380cf79-2e636af1/tempworkdir/src /home/ubuntu/spr-fast/tests/corebench/coreutils/coreutils-case-7380cf79-2e636af1/tempworkdir/tests /home/ubuntu/spr-fast/tests/corebench/coreutils/coreutils-case-7380cf79-2e636af1/tempworkdir 14  > __res
Running test command:
/home/ubuntu/spr-fast/tools/coreutils-test.py /home/ubuntu/spr-fast/tests/corebench/coreutils/coreutils-case-7380cf79-2e636af1/tempworkdir/src /home/ubuntu/spr-fast/tests/corebench/coreutils/coreutils-case-7380cf79-2e636af1/tempworkdir/tests /home/ubuntu/spr-fast/tests/corebench/coreutils/coreutils-case-7380cf79-2e636af1/tempworkdir 16  > __res
Running test command:
/home/ubuntu/spr-fast/tools/coreutils-test.py /home/ubuntu/spr-fast/tests/corebench/coreutils/coreutils-case-7380cf79-2e636af1/tempworkdir/src /home/ubuntu/spr-fast/tests/corebench/coreutils/coreutils-case-7380cf79-2e636af1/tempworkdir/tests /home/ubuntu/spr-fast/tests/corebench/coreutils/coreutils-case-7380cf79-2e636af1/tempworkdir 18  > __res
Running test command:
/home/ubuntu/spr-fast/tools/coreutils-test.py /home/ubuntu/spr-fast/tests/corebench/coreutils/coreutils-case-7380cf79-2e636af1/tempworkdir/src /home/ubuntu/spr-fast/tests/corebench/coreutils/coreutils-case-7380cf79-2e636af1/tempworkdir/tests /home/ubuntu/spr-fast/tests/corebench/coreutils/coreutils-case-7380cf79-2e636af1/tempworkdir 19  > __res
Running test command:
/home/ubuntu/spr-fast/tools/coreutils-test.py /home/ubuntu/spr-fast/tests/corebench/coreutils/coreutils-case-7380cf79-2e636af1/tempworkdir/src /home/ubuntu/spr-fast/tests/corebench/coreutils/coreutils-case-7380cf79-2e636af1/tempworkdir/tests /home/ubuntu/spr-fast/tests/corebench/coreutils/coreutils-case-7380cf79-2e636af1/tempworkdir 20  > __res
Running test command:
/home/ubuntu/spr-fast/tools/coreutils-test.py /home/ubuntu/spr-fast/tests/corebench/coreutils/coreutils-case-7380cf79-2e636af1/tempworkdir/src /home/ubuntu/spr-fast/tests/corebench/coreutils/coreutils-case-7380cf79-2e636af1/tempworkdir/tests /home/ubuntu/spr-fast/tests/corebench/coreutils/coreutils-case-7380cf79-2e636af1/tempworkdir 21  > __res
Running test command:
/home/ubuntu/spr-fast/tools/coreutils-test.py /home/ubuntu/spr-fast/tests/corebench/coreutils/coreutils-case-7380cf79-2e636af1/tempworkdir/src /home/ubuntu/spr-fast/tests/corebench/coreutils/coreutils-case-7380cf79-2e636af1/tempworkdir/tests /home/ubuntu/spr-fast/tests/corebench/coreutils/coreutils-case-7380cf79-2e636af1/tempworkdir 22  > __res
Running test command:
/home/ubuntu/spr-fast/tools/coreutils-test.py /home/ubuntu/spr-fast/tests/corebench/coreutils/coreutils-case-7380cf79-2e636af1/tempworkdir/src /home/ubuntu/spr-fast/tests/corebench/coreutils/coreutils-case-7380cf79-2e636af1/tempworkdir/tests /home/ubuntu/spr-fast/tests/corebench/coreutils/coreutils-case-7380cf79-2e636af1/tempworkdir 24  > __res
Running test command:
/home/ubuntu/spr-fast/tools/coreutils-test.py /home/ubuntu/spr-fast/tests/corebench/coreutils/coreutils-case-7380cf79-2e636af1/tempworkdir/src /home/ubuntu/spr-fast/tests/corebench/coreutils/coreutils-case-7380cf79-2e636af1/tempworkdir/tests /home/ubuntu/spr-fast/tests/corebench/coreutils/coreutils-case-7380cf79-2e636af1/tempworkdir 25  > __res
Running test command:
/home/ubuntu/spr-fast/tools/coreutils-test.py /home/ubuntu/spr-fast/tests/corebench/coreutils/coreutils-case-7380cf79-2e636af1/tempworkdir/src /home/ubuntu/spr-fast/tests/corebench/coreutils/coreutils-case-7380cf79-2e636af1/tempworkdir/tests /home/ubuntu/spr-fast/tests/corebench/coreutils/coreutils-case-7380cf79-2e636af1/tempworkdir 26  > __res
Running test command:
/home/ubuntu/spr-fast/tools/coreutils-test.py /home/ubuntu/spr-fast/tests/corebench/coreutils/coreutils-case-7380cf79-2e636af1/tempworkdir/src /home/ubuntu/spr-fast/tests/corebench/coreutils/coreutils-case-7380cf79-2e636af1/tempworkdir/tests /home/ubuntu/spr-fast/tests/corebench/coreutils/coreutils-case-7380cf79-2e636af1/tempworkdir 27  > __res
Running test command:
/home/ubuntu/spr-fast/tools/coreutils-test.py /home/ubuntu/spr-fast/tests/corebench/coreutils/coreutils-case-7380cf79-2e636af1/tempworkdir/src /home/ubuntu/spr-fast/tests/corebench/coreutils/coreutils-case-7380cf79-2e636af1/tempworkdir/tests /home/ubuntu/spr-fast/tests/corebench/coreutils/coreutils-case-7380cf79-2e636af1/tempworkdir 32  > __res
Running test command:
/home/ubuntu/spr-fast/tools/coreutils-test.py /home/ubuntu/spr-fast/tests/corebench/coreutils/coreutils-case-7380cf79-2e636af1/tempworkdir/src /home/ubuntu/spr-fast/tests/corebench/coreutils/coreutils-case-7380cf79-2e636af1/tempworkdir/tests /home/ubuntu/spr-fast/tests/corebench/coreutils/coreutils-case-7380cf79-2e636af1/tempworkdir 34  > __res
Running test command:
/home/ubuntu/spr-fast/tools/coreutils-test.py /home/ubuntu/spr-fast/tests/corebench/coreutils/coreutils-case-7380cf79-2e636af1/tempworkdir/src /home/ubuntu/spr-fast/tests/corebench/coreutils/coreutils-case-7380cf79-2e636af1/tempworkdir/tests /home/ubuntu/spr-fast/tests/corebench/coreutils/coreutils-case-7380cf79-2e636af1/tempworkdir 38  > __res
Running test command:
/home/ubuntu/spr-fast/tools/coreutils-test.py /home/ubuntu/spr-fast/tests/corebench/coreutils/coreutils-case-7380cf79-2e636af1/tempworkdir/src /home/ubuntu/spr-fast/tests/corebench/coreutils/coreutils-case-7380cf79-2e636af1/tempworkdir/tests /home/ubuntu/spr-fast/tests/corebench/coreutils/coreutils-case-7380cf79-2e636af1/tempworkdir 40  > __res
Passed!
CondTester, Testing instance id 42:
Running test command:
/home/ubuntu/spr-fast/tools/coreutils-test.py /home/ubuntu/spr-fast/tests/corebench/coreutils/coreutils-case-7380cf79-2e636af1/tempworkdir/src /home/ubuntu/spr-fast/tests/corebench/coreutils/coreutils-case-7380cf79-2e636af1/tempworkdir/tests /home/ubuntu/spr-fast/tests/corebench/coreutils/coreutils-case-7380cf79-2e636af1/tempworkdir 0  > __res
Running test command:
/home/ubuntu/spr-fast/tools/coreutils-test.py /home/ubuntu/spr-fast/tests/corebench/coreutils/coreutils-case-7380cf79-2e636af1/tempworkdir/src /home/ubuntu/spr-fast/tests/corebench/coreutils/coreutils-case-7380cf79-2e636af1/tempworkdir/tests /home/ubuntu/spr-fast/tests/corebench/coreutils/coreutils-case-7380cf79-2e636af1/tempworkdir 0  > __res
Running test command:
/home/ubuntu/spr-fast/tools/coreutils-test.py /home/ubuntu/spr-fast/tests/corebench/coreutils/coreutils-case-7380cf79-2e636af1/tempworkdir/src /home/ubuntu/spr-fast/tests/corebench/coreutils/coreutils-case-7380cf79-2e636af1/tempworkdir/tests /home/ubuntu/spr-fast/tests/corebench/coreutils/coreutils-case-7380cf79-2e636af1/tempworkdir 0  > __res
Passed Negative Cases wiht CondTestder!
Running test command:
/home/ubuntu/spr-fast/tools/coreutils-test.py /home/ubuntu/spr-fast/tests/corebench/coreutils/coreutils-case-7380cf79-2e636af1/tempworkdir/src /home/ubuntu/spr-fast/tests/corebench/coreutils/coreutils-case-7380cf79-2e636af1/tempworkdir/tests /home/ubuntu/spr-fast/tests/corebench/coreutils/coreutils-case-7380cf79-2e636af1/tempworkdir 3  > __res
Running test command:
/home/ubuntu/spr-fast/tools/coreutils-test.py /home/ubuntu/spr-fast/tests/corebench/coreutils/coreutils-case-7380cf79-2e636af1/tempworkdir/src /home/ubuntu/spr-fast/tests/corebench/coreutils/coreutils-case-7380cf79-2e636af1/tempworkdir/tests /home/ubuntu/spr-fast/tests/corebench/coreutils/coreutils-case-7380cf79-2e636af1/tempworkdir 4  > __res
Running test command:
/home/ubuntu/spr-fast/tools/coreutils-test.py /home/ubuntu/spr-fast/tests/corebench/coreutils/coreutils-case-7380cf79-2e636af1/tempworkdir/src /home/ubuntu/spr-fast/tests/corebench/coreutils/coreutils-case-7380cf79-2e636af1/tempworkdir/tests /home/ubuntu/spr-fast/tests/corebench/coreutils/coreutils-case-7380cf79-2e636af1/tempworkdir 7  > __res
Running test command:
/home/ubuntu/spr-fast/tools/coreutils-test.py /home/ubuntu/spr-fast/tests/corebench/coreutils/coreutils-case-7380cf79-2e636af1/tempworkdir/src /home/ubuntu/spr-fast/tests/corebench/coreutils/coreutils-case-7380cf79-2e636af1/tempworkdir/tests /home/ubuntu/spr-fast/tests/corebench/coreutils/coreutils-case-7380cf79-2e636af1/tempworkdir 8  > __res
Running test command:
/home/ubuntu/spr-fast/tools/coreutils-test.py /home/ubuntu/spr-fast/tests/corebench/coreutils/coreutils-case-7380cf79-2e636af1/tempworkdir/src /home/ubuntu/spr-fast/tests/corebench/coreutils/coreutils-case-7380cf79-2e636af1/tempworkdir/tests /home/ubuntu/spr-fast/tests/corebench/coreutils/coreutils-case-7380cf79-2e636af1/tempworkdir 10  > __res
Running test command:
/home/ubuntu/spr-fast/tools/coreutils-test.py /home/ubuntu/spr-fast/tests/corebench/coreutils/coreutils-case-7380cf79-2e636af1/tempworkdir/src /home/ubuntu/spr-fast/tests/corebench/coreutils/coreutils-case-7380cf79-2e636af1/tempworkdir/tests /home/ubuntu/spr-fast/tests/corebench/coreutils/coreutils-case-7380cf79-2e636af1/tempworkdir 14  > __res
Running test command:
/home/ubuntu/spr-fast/tools/coreutils-test.py /home/ubuntu/spr-fast/tests/corebench/coreutils/coreutils-case-7380cf79-2e636af1/tempworkdir/src /home/ubuntu/spr-fast/tests/corebench/coreutils/coreutils-case-7380cf79-2e636af1/tempworkdir/tests /home/ubuntu/spr-fast/tests/corebench/coreutils/coreutils-case-7380cf79-2e636af1/tempworkdir 16  > __res
Running test command:
/home/ubuntu/spr-fast/tools/coreutils-test.py /home/ubuntu/spr-fast/tests/corebench/coreutils/coreutils-case-7380cf79-2e636af1/tempworkdir/src /home/ubuntu/spr-fast/tests/corebench/coreutils/coreutils-case-7380cf79-2e636af1/tempworkdir/tests /home/ubuntu/spr-fast/tests/corebench/coreutils/coreutils-case-7380cf79-2e636af1/tempworkdir 18  > __res
Running test command:
/home/ubuntu/spr-fast/tools/coreutils-test.py /home/ubuntu/spr-fast/tests/corebench/coreutils/coreutils-case-7380cf79-2e636af1/tempworkdir/src /home/ubuntu/spr-fast/tests/corebench/coreutils/coreutils-case-7380cf79-2e636af1/tempworkdir/tests /home/ubuntu/spr-fast/tests/corebench/coreutils/coreutils-case-7380cf79-2e636af1/tempworkdir 19  > __res
Running test command:
/home/ubuntu/spr-fast/tools/coreutils-test.py /home/ubuntu/spr-fast/tests/corebench/coreutils/coreutils-case-7380cf79-2e636af1/tempworkdir/src /home/ubuntu/spr-fast/tests/corebench/coreutils/coreutils-case-7380cf79-2e636af1/tempworkdir/tests /home/ubuntu/spr-fast/tests/corebench/coreutils/coreutils-case-7380cf79-2e636af1/tempworkdir 20  > __res
Running test command:
/home/ubuntu/spr-fast/tools/coreutils-test.py /home/ubuntu/spr-fast/tests/corebench/coreutils/coreutils-case-7380cf79-2e636af1/tempworkdir/src /home/ubuntu/spr-fast/tests/corebench/coreutils/coreutils-case-7380cf79-2e636af1/tempworkdir/tests /home/ubuntu/spr-fast/tests/corebench/coreutils/coreutils-case-7380cf79-2e636af1/tempworkdir 21  > __res
Running test command:
/home/ubuntu/spr-fast/tools/coreutils-test.py /home/ubuntu/spr-fast/tests/corebench/coreutils/coreutils-case-7380cf79-2e636af1/tempworkdir/src /home/ubuntu/spr-fast/tests/corebench/coreutils/coreutils-case-7380cf79-2e636af1/tempworkdir/tests /home/ubuntu/spr-fast/tests/corebench/coreutils/coreutils-case-7380cf79-2e636af1/tempworkdir 22  > __res
Running test command:
/home/ubuntu/spr-fast/tools/coreutils-test.py /home/ubuntu/spr-fast/tests/corebench/coreutils/coreutils-case-7380cf79-2e636af1/tempworkdir/src /home/ubuntu/spr-fast/tests/corebench/coreutils/coreutils-case-7380cf79-2e636af1/tempworkdir/tests /home/ubuntu/spr-fast/tests/corebench/coreutils/coreutils-case-7380cf79-2e636af1/tempworkdir 24  > __res
Running test command:
/home/ubuntu/spr-fast/tools/coreutils-test.py /home/ubuntu/spr-fast/tests/corebench/coreutils/coreutils-case-7380cf79-2e636af1/tempworkdir/src /home/ubuntu/spr-fast/tests/corebench/coreutils/coreutils-case-7380cf79-2e636af1/tempworkdir/tests /home/ubuntu/spr-fast/tests/corebench/coreutils/coreutils-case-7380cf79-2e636af1/tempworkdir 25  > __res
Running test command:
/home/ubuntu/spr-fast/tools/coreutils-test.py /home/ubuntu/spr-fast/tests/corebench/coreutils/coreutils-case-7380cf79-2e636af1/tempworkdir/src /home/ubuntu/spr-fast/tests/corebench/coreutils/coreutils-case-7380cf79-2e636af1/tempworkdir/tests /home/ubuntu/spr-fast/tests/corebench/coreutils/coreutils-case-7380cf79-2e636af1/tempworkdir 26  > __res
Running test command:
/home/ubuntu/spr-fast/tools/coreutils-test.py /home/ubuntu/spr-fast/tests/corebench/coreutils/coreutils-case-7380cf79-2e636af1/tempworkdir/src /home/ubuntu/spr-fast/tests/corebench/coreutils/coreutils-case-7380cf79-2e636af1/tempworkdir/tests /home/ubuntu/spr-fast/tests/corebench/coreutils/coreutils-case-7380cf79-2e636af1/tempworkdir 27  > __res
Running test command:
/home/ubuntu/spr-fast/tools/coreutils-test.py /home/ubuntu/spr-fast/tests/corebench/coreutils/coreutils-case-7380cf79-2e636af1/tempworkdir/src /home/ubuntu/spr-fast/tests/corebench/coreutils/coreutils-case-7380cf79-2e636af1/tempworkdir/tests /home/ubuntu/spr-fast/tests/corebench/coreutils/coreutils-case-7380cf79-2e636af1/tempworkdir 32  > __res
Running test command:
/home/ubuntu/spr-fast/tools/coreutils-test.py /home/ubuntu/spr-fast/tests/corebench/coreutils/coreutils-case-7380cf79-2e636af1/tempworkdir/src /home/ubuntu/spr-fast/tests/corebench/coreutils/coreutils-case-7380cf79-2e636af1/tempworkdir/tests /home/ubuntu/spr-fast/tests/corebench/coreutils/coreutils-case-7380cf79-2e636af1/tempworkdir 34  > __res
Running test command:
/home/ubuntu/spr-fast/tools/coreutils-test.py /home/ubuntu/spr-fast/tests/corebench/coreutils/coreutils-case-7380cf79-2e636af1/tempworkdir/src /home/ubuntu/spr-fast/tests/corebench/coreutils/coreutils-case-7380cf79-2e636af1/tempworkdir/tests /home/ubuntu/spr-fast/tests/corebench/coreutils/coreutils-case-7380cf79-2e636af1/tempworkdir 38  > __res
Running test command:
/home/ubuntu/spr-fast/tools/coreutils-test.py /home/ubuntu/spr-fast/tests/corebench/coreutils/coreutils-case-7380cf79-2e636af1/tempworkdir/src /home/ubuntu/spr-fast/tests/corebench/coreutils/coreutils-case-7380cf79-2e636af1/tempworkdir/tests /home/ubuntu/spr-fast/tests/corebench/coreutils/coreutils-case-7380cf79-2e636af1/tempworkdir 40  > __res
Passed Positive Cases
Running test command:
/home/ubuntu/spr-fast/tools/coreutils-test.py /home/ubuntu/spr-fast/tests/corebench/coreutils/coreutils-case-7380cf79-2e636af1/tempworkdir/src /home/ubuntu/spr-fast/tests/corebench/coreutils/coreutils-case-7380cf79-2e636af1/tempworkdir/tests /home/ubuntu/spr-fast/tests/corebench/coreutils/coreutils-case-7380cf79-2e636af1/tempworkdir 0  > __res
Running test command:
/home/ubuntu/spr-fast/tools/coreutils-test.py /home/ubuntu/spr-fast/tests/corebench/coreutils/coreutils-case-7380cf79-2e636af1/tempworkdir/src /home/ubuntu/spr-fast/tests/corebench/coreutils/coreutils-case-7380cf79-2e636af1/tempworkdir/tests /home/ubuntu/spr-fast/tests/corebench/coreutils/coreutils-case-7380cf79-2e636af1/tempworkdir 3  > __res
Running test command:
/home/ubuntu/spr-fast/tools/coreutils-test.py /home/ubuntu/spr-fast/tests/corebench/coreutils/coreutils-case-7380cf79-2e636af1/tempworkdir/src /home/ubuntu/spr-fast/tests/corebench/coreutils/coreutils-case-7380cf79-2e636af1/tempworkdir/tests /home/ubuntu/spr-fast/tests/corebench/coreutils/coreutils-case-7380cf79-2e636af1/tempworkdir 4  > __res
Running test command:
/home/ubuntu/spr-fast/tools/coreutils-test.py /home/ubuntu/spr-fast/tests/corebench/coreutils/coreutils-case-7380cf79-2e636af1/tempworkdir/src /home/ubuntu/spr-fast/tests/corebench/coreutils/coreutils-case-7380cf79-2e636af1/tempworkdir/tests /home/ubuntu/spr-fast/tests/corebench/coreutils/coreutils-case-7380cf79-2e636af1/tempworkdir 7  > __res
Running test command:
/home/ubuntu/spr-fast/tools/coreutils-test.py /home/ubuntu/spr-fast/tests/corebench/coreutils/coreutils-case-7380cf79-2e636af1/tempworkdir/src /home/ubuntu/spr-fast/tests/corebench/coreutils/coreutils-case-7380cf79-2e636af1/tempworkdir/tests /home/ubuntu/spr-fast/tests/corebench/coreutils/coreutils-case-7380cf79-2e636af1/tempworkdir 8  > __res
Running test command:
/home/ubuntu/spr-fast/tools/coreutils-test.py /home/ubuntu/spr-fast/tests/corebench/coreutils/coreutils-case-7380cf79-2e636af1/tempworkdir/src /home/ubuntu/spr-fast/tests/corebench/coreutils/coreutils-case-7380cf79-2e636af1/tempworkdir/tests /home/ubuntu/spr-fast/tests/corebench/coreutils/coreutils-case-7380cf79-2e636af1/tempworkdir 10  > __res
Running test command:
/home/ubuntu/spr-fast/tools/coreutils-test.py /home/ubuntu/spr-fast/tests/corebench/coreutils/coreutils-case-7380cf79-2e636af1/tempworkdir/src /home/ubuntu/spr-fast/tests/corebench/coreutils/coreutils-case-7380cf79-2e636af1/tempworkdir/tests /home/ubuntu/spr-fast/tests/corebench/coreutils/coreutils-case-7380cf79-2e636af1/tempworkdir 14  > __res
Running test command:
/home/ubuntu/spr-fast/tools/coreutils-test.py /home/ubuntu/spr-fast/tests/corebench/coreutils/coreutils-case-7380cf79-2e636af1/tempworkdir/src /home/ubuntu/spr-fast/tests/corebench/coreutils/coreutils-case-7380cf79-2e636af1/tempworkdir/tests /home/ubuntu/spr-fast/tests/corebench/coreutils/coreutils-case-7380cf79-2e636af1/tempworkdir 16  > __res
Running test command:
/home/ubuntu/spr-fast/tools/coreutils-test.py /home/ubuntu/spr-fast/tests/corebench/coreutils/coreutils-case-7380cf79-2e636af1/tempworkdir/src /home/ubuntu/spr-fast/tests/corebench/coreutils/coreutils-case-7380cf79-2e636af1/tempworkdir/tests /home/ubuntu/spr-fast/tests/corebench/coreutils/coreutils-case-7380cf79-2e636af1/tempworkdir 18  > __res
Running test command:
/home/ubuntu/spr-fast/tools/coreutils-test.py /home/ubuntu/spr-fast/tests/corebench/coreutils/coreutils-case-7380cf79-2e636af1/tempworkdir/src /home/ubuntu/spr-fast/tests/corebench/coreutils/coreutils-case-7380cf79-2e636af1/tempworkdir/tests /home/ubuntu/spr-fast/tests/corebench/coreutils/coreutils-case-7380cf79-2e636af1/tempworkdir 19  > __res
Running test command:
/home/ubuntu/spr-fast/tools/coreutils-test.py /home/ubuntu/spr-fast/tests/corebench/coreutils/coreutils-case-7380cf79-2e636af1/tempworkdir/src /home/ubuntu/spr-fast/tests/corebench/coreutils/coreutils-case-7380cf79-2e636af1/tempworkdir/tests /home/ubuntu/spr-fast/tests/corebench/coreutils/coreutils-case-7380cf79-2e636af1/tempworkdir 20  > __res
Running test command:
/home/ubuntu/spr-fast/tools/coreutils-test.py /home/ubuntu/spr-fast/tests/corebench/coreutils/coreutils-case-7380cf79-2e636af1/tempworkdir/src /home/ubuntu/spr-fast/tests/corebench/coreutils/coreutils-case-7380cf79-2e636af1/tempworkdir/tests /home/ubuntu/spr-fast/tests/corebench/coreutils/coreutils-case-7380cf79-2e636af1/tempworkdir 21  > __res
Running test command:
/home/ubuntu/spr-fast/tools/coreutils-test.py /home/ubuntu/spr-fast/tests/corebench/coreutils/coreutils-case-7380cf79-2e636af1/tempworkdir/src /home/ubuntu/spr-fast/tests/corebench/coreutils/coreutils-case-7380cf79-2e636af1/tempworkdir/tests /home/ubuntu/spr-fast/tests/corebench/coreutils/coreutils-case-7380cf79-2e636af1/tempworkdir 22  > __res
Running test command:
/home/ubuntu/spr-fast/tools/coreutils-test.py /home/ubuntu/spr-fast/tests/corebench/coreutils/coreutils-case-7380cf79-2e636af1/tempworkdir/src /home/ubuntu/spr-fast/tests/corebench/coreutils/coreutils-case-7380cf79-2e636af1/tempworkdir/tests /home/ubuntu/spr-fast/tests/corebench/coreutils/coreutils-case-7380cf79-2e636af1/tempworkdir 24  > __res
Running test command:
/home/ubuntu/spr-fast/tools/coreutils-test.py /home/ubuntu/spr-fast/tests/corebench/coreutils/coreutils-case-7380cf79-2e636af1/tempworkdir/src /home/ubuntu/spr-fast/tests/corebench/coreutils/coreutils-case-7380cf79-2e636af1/tempworkdir/tests /home/ubuntu/spr-fast/tests/corebench/coreutils/coreutils-case-7380cf79-2e636af1/tempworkdir 25  > __res
Running test command:
/home/ubuntu/spr-fast/tools/coreutils-test.py /home/ubuntu/spr-fast/tests/corebench/coreutils/coreutils-case-7380cf79-2e636af1/tempworkdir/src /home/ubuntu/spr-fast/tests/corebench/coreutils/coreutils-case-7380cf79-2e636af1/tempworkdir/tests /home/ubuntu/spr-fast/tests/corebench/coreutils/coreutils-case-7380cf79-2e636af1/tempworkdir 26  > __res
Running test command:
/home/ubuntu/spr-fast/tools/coreutils-test.py /home/ubuntu/spr-fast/tests/corebench/coreutils/coreutils-case-7380cf79-2e636af1/tempworkdir/src /home/ubuntu/spr-fast/tests/corebench/coreutils/coreutils-case-7380cf79-2e636af1/tempworkdir/tests /home/ubuntu/spr-fast/tests/corebench/coreutils/coreutils-case-7380cf79-2e636af1/tempworkdir 27  > __res
Running test command:
/home/ubuntu/spr-fast/tools/coreutils-test.py /home/ubuntu/spr-fast/tests/corebench/coreutils/coreutils-case-7380cf79-2e636af1/tempworkdir/src /home/ubuntu/spr-fast/tests/corebench/coreutils/coreutils-case-7380cf79-2e636af1/tempworkdir/tests /home/ubuntu/spr-fast/tests/corebench/coreutils/coreutils-case-7380cf79-2e636af1/tempworkdir 32  > __res
Running test command:
/home/ubuntu/spr-fast/tools/coreutils-test.py /home/ubuntu/spr-fast/tests/corebench/coreutils/coreutils-case-7380cf79-2e636af1/tempworkdir/src /home/ubuntu/spr-fast/tests/corebench/coreutils/coreutils-case-7380cf79-2e636af1/tempworkdir/tests /home/ubuntu/spr-fast/tests/corebench/coreutils/coreutils-case-7380cf79-2e636af1/tempworkdir 34  > __res
Running test command:
/home/ubuntu/spr-fast/tools/coreutils-test.py /home/ubuntu/spr-fast/tests/corebench/coreutils/coreutils-case-7380cf79-2e636af1/tempworkdir/src /home/ubuntu/spr-fast/tests/corebench/coreutils/coreutils-case-7380cf79-2e636af1/tempworkdir/tests /home/ubuntu/spr-fast/tests/corebench/coreutils/coreutils-case-7380cf79-2e636af1/tempworkdir 38  > __res
Running test command:
/home/ubuntu/spr-fast/tools/coreutils-test.py /home/ubuntu/spr-fast/tests/corebench/coreutils/coreutils-case-7380cf79-2e636af1/tempworkdir/src /home/ubuntu/spr-fast/tests/corebench/coreutils/coreutils-case-7380cf79-2e636af1/tempworkdir/tests /home/ubuntu/spr-fast/tests/corebench/coreutils/coreutils-case-7380cf79-2e636af1/tempworkdir 40  > __res
Passed!
CondTester, Postprocessing instance id 41:
Trying a synthesis expr 1
Skipping a synthesis:1
Trying a synthesis expr complement == 0
Skipping an unintialized variable synthesis:complement
Trying a synthesis expr rp == 0
Building:src at:
/home/ubuntu/spr-fast/tests/corebench/coreutils/coreutils-case-7380cf79-2e636af1/tempworkdir/srcRunning test command:
/home/ubuntu/spr-fast/tools/coreutils-test.py /home/ubuntu/spr-fast/tests/corebench/coreutils/coreutils-case-7380cf79-2e636af1/tempworkdir/src /home/ubuntu/spr-fast/tests/corebench/coreutils/coreutils-case-7380cf79-2e636af1/tempworkdir/tests /home/ubuntu/spr-fast/tests/corebench/coreutils/coreutils-case-7380cf79-2e636af1/tempworkdir 0  > __res
Running test command:
/home/ubuntu/spr-fast/tools/coreutils-test.py /home/ubuntu/spr-fast/tests/corebench/coreutils/coreutils-case-7380cf79-2e636af1/tempworkdir/src /home/ubuntu/spr-fast/tests/corebench/coreutils/coreutils-case-7380cf79-2e636af1/tempworkdir/tests /home/ubuntu/spr-fast/tests/corebench/coreutils/coreutils-case-7380cf79-2e636af1/tempworkdir 3  > __res
Running test command:
/home/ubuntu/spr-fast/tools/coreutils-test.py /home/ubuntu/spr-fast/tests/corebench/coreutils/coreutils-case-7380cf79-2e636af1/tempworkdir/src /home/ubuntu/spr-fast/tests/corebench/coreutils/coreutils-case-7380cf79-2e636af1/tempworkdir/tests /home/ubuntu/spr-fast/tests/corebench/coreutils/coreutils-case-7380cf79-2e636af1/tempworkdir 4  > __res
Running test command:
/home/ubuntu/spr-fast/tools/coreutils-test.py /home/ubuntu/spr-fast/tests/corebench/coreutils/coreutils-case-7380cf79-2e636af1/tempworkdir/src /home/ubuntu/spr-fast/tests/corebench/coreutils/coreutils-case-7380cf79-2e636af1/tempworkdir/tests /home/ubuntu/spr-fast/tests/corebench/coreutils/coreutils-case-7380cf79-2e636af1/tempworkdir 7  > __res
Running test command:
/home/ubuntu/spr-fast/tools/coreutils-test.py /home/ubuntu/spr-fast/tests/corebench/coreutils/coreutils-case-7380cf79-2e636af1/tempworkdir/src /home/ubuntu/spr-fast/tests/corebench/coreutils/coreutils-case-7380cf79-2e636af1/tempworkdir/tests /home/ubuntu/spr-fast/tests/corebench/coreutils/coreutils-case-7380cf79-2e636af1/tempworkdir 8  > __res
Running test command:
/home/ubuntu/spr-fast/tools/coreutils-test.py /home/ubuntu/spr-fast/tests/corebench/coreutils/coreutils-case-7380cf79-2e636af1/tempworkdir/src /home/ubuntu/spr-fast/tests/corebench/coreutils/coreutils-case-7380cf79-2e636af1/tempworkdir/tests /home/ubuntu/spr-fast/tests/corebench/coreutils/coreutils-case-7380cf79-2e636af1/tempworkdir 10  > __res
Running test command:
/home/ubuntu/spr-fast/tools/coreutils-test.py /home/ubuntu/spr-fast/tests/corebench/coreutils/coreutils-case-7380cf79-2e636af1/tempworkdir/src /home/ubuntu/spr-fast/tests/corebench/coreutils/coreutils-case-7380cf79-2e636af1/tempworkdir/tests /home/ubuntu/spr-fast/tests/corebench/coreutils/coreutils-case-7380cf79-2e636af1/tempworkdir 14  > __res
Running test command:
/home/ubuntu/spr-fast/tools/coreutils-test.py /home/ubuntu/spr-fast/tests/corebench/coreutils/coreutils-case-7380cf79-2e636af1/tempworkdir/src /home/ubuntu/spr-fast/tests/corebench/coreutils/coreutils-case-7380cf79-2e636af1/tempworkdir/tests /home/ubuntu/spr-fast/tests/corebench/coreutils/coreutils-case-7380cf79-2e636af1/tempworkdir 16  > __res
Running test command:
/home/ubuntu/spr-fast/tools/coreutils-test.py /home/ubuntu/spr-fast/tests/corebench/coreutils/coreutils-case-7380cf79-2e636af1/tempworkdir/src /home/ubuntu/spr-fast/tests/corebench/coreutils/coreutils-case-7380cf79-2e636af1/tempworkdir/tests /home/ubuntu/spr-fast/tests/corebench/coreutils/coreutils-case-7380cf79-2e636af1/tempworkdir 18  > __res
Running test command:
/home/ubuntu/spr-fast/tools/coreutils-test.py /home/ubuntu/spr-fast/tests/corebench/coreutils/coreutils-case-7380cf79-2e636af1/tempworkdir/src /home/ubuntu/spr-fast/tests/corebench/coreutils/coreutils-case-7380cf79-2e636af1/tempworkdir/tests /home/ubuntu/spr-fast/tests/corebench/coreutils/coreutils-case-7380cf79-2e636af1/tempworkdir 19  > __res
Running test command:
/home/ubuntu/spr-fast/tools/coreutils-test.py /home/ubuntu/spr-fast/tests/corebench/coreutils/coreutils-case-7380cf79-2e636af1/tempworkdir/src /home/ubuntu/spr-fast/tests/corebench/coreutils/coreutils-case-7380cf79-2e636af1/tempworkdir/tests /home/ubuntu/spr-fast/tests/corebench/coreutils/coreutils-case-7380cf79-2e636af1/tempworkdir 20  > __res
Running test command:
/home/ubuntu/spr-fast/tools/coreutils-test.py /home/ubuntu/spr-fast/tests/corebench/coreutils/coreutils-case-7380cf79-2e636af1/tempworkdir/src /home/ubuntu/spr-fast/tests/corebench/coreutils/coreutils-case-7380cf79-2e636af1/tempworkdir/tests /home/ubuntu/spr-fast/tests/corebench/coreutils/coreutils-case-7380cf79-2e636af1/tempworkdir 21  > __res
Running test command:
/home/ubuntu/spr-fast/tools/coreutils-test.py /home/ubuntu/spr-fast/tests/corebench/coreutils/coreutils-case-7380cf79-2e636af1/tempworkdir/src /home/ubuntu/spr-fast/tests/corebench/coreutils/coreutils-case-7380cf79-2e636af1/tempworkdir/tests /home/ubuntu/spr-fast/tests/corebench/coreutils/coreutils-case-7380cf79-2e636af1/tempworkdir 22  > __res
Running test command:
/home/ubuntu/spr-fast/tools/coreutils-test.py /home/ubuntu/spr-fast/tests/corebench/coreutils/coreutils-case-7380cf79-2e636af1/tempworkdir/src /home/ubuntu/spr-fast/tests/corebench/coreutils/coreutils-case-7380cf79-2e636af1/tempworkdir/tests /home/ubuntu/spr-fast/tests/corebench/coreutils/coreutils-case-7380cf79-2e636af1/tempworkdir 24  > __res
Running test command:
/home/ubuntu/spr-fast/tools/coreutils-test.py /home/ubuntu/spr-fast/tests/corebench/coreutils/coreutils-case-7380cf79-2e636af1/tempworkdir/src /home/ubuntu/spr-fast/tests/corebench/coreutils/coreutils-case-7380cf79-2e636af1/tempworkdir/tests /home/ubuntu/spr-fast/tests/corebench/coreutils/coreutils-case-7380cf79-2e636af1/tempworkdir 25  > __res
Running test command:
/home/ubuntu/spr-fast/tools/coreutils-test.py /home/ubuntu/spr-fast/tests/corebench/coreutils/coreutils-case-7380cf79-2e636af1/tempworkdir/src /home/ubuntu/spr-fast/tests/corebench/coreutils/coreutils-case-7380cf79-2e636af1/tempworkdir/tests /home/ubuntu/spr-fast/tests/corebench/coreutils/coreutils-case-7380cf79-2e636af1/tempworkdir 26  > __res
Running test command:
/home/ubuntu/spr-fast/tools/coreutils-test.py /home/ubuntu/spr-fast/tests/corebench/coreutils/coreutils-case-7380cf79-2e636af1/tempworkdir/src /home/ubuntu/spr-fast/tests/corebench/coreutils/coreutils-case-7380cf79-2e636af1/tempworkdir/tests /home/ubuntu/spr-fast/tests/corebench/coreutils/coreutils-case-7380cf79-2e636af1/tempworkdir 27  > __res
Running test command:
/home/ubuntu/spr-fast/tools/coreutils-test.py /home/ubuntu/spr-fast/tests/corebench/coreutils/coreutils-case-7380cf79-2e636af1/tempworkdir/src /home/ubuntu/spr-fast/tests/corebench/coreutils/coreutils-case-7380cf79-2e636af1/tempworkdir/tests /home/ubuntu/spr-fast/tests/corebench/coreutils/coreutils-case-7380cf79-2e636af1/tempworkdir 32  > __res
Running test command:
/home/ubuntu/spr-fast/tools/coreutils-test.py /home/ubuntu/spr-fast/tests/corebench/coreutils/coreutils-case-7380cf79-2e636af1/tempworkdir/src /home/ubuntu/spr-fast/tests/corebench/coreutils/coreutils-case-7380cf79-2e636af1/tempworkdir/tests /home/ubuntu/spr-fast/tests/corebench/coreutils/coreutils-case-7380cf79-2e636af1/tempworkdir 34  > __res
Running test command:
/home/ubuntu/spr-fast/tools/coreutils-test.py /home/ubuntu/spr-fast/tests/corebench/coreutils/coreutils-case-7380cf79-2e636af1/tempworkdir/src /home/ubuntu/spr-fast/tests/corebench/coreutils/coreutils-case-7380cf79-2e636af1/tempworkdir/tests /home/ubuntu/spr-fast/tests/corebench/coreutils/coreutils-case-7380cf79-2e636af1/tempworkdir 38  > __res
Running test command:
/home/ubuntu/spr-fast/tools/coreutils-test.py /home/ubuntu/spr-fast/tests/corebench/coreutils/coreutils-case-7380cf79-2e636af1/tempworkdir/src /home/ubuntu/spr-fast/tests/corebench/coreutils/coreutils-case-7380cf79-2e636af1/tempworkdir/tests /home/ubuntu/spr-fast/tests/corebench/coreutils/coreutils-case-7380cf79-2e636af1/tempworkdir 40  > __res
Passed Positive Cases
Passed!
Passed with updated best score 4997959.000000
CondTester, Postprocessing instance id 42:
Postprocessing failed!
a batched test job starts!
Building:src at:
/home/ubuntu/spr-fast/tests/corebench/coreutils/coreutils-case-7380cf79-2e636af1/tempworkdir/srcMerged code building succ, going to invoke tester!
CondTester, Testing instance id 26:
Running test command:
/home/ubuntu/spr-fast/tools/coreutils-test.py /home/ubuntu/spr-fast/tests/corebench/coreutils/coreutils-case-7380cf79-2e636af1/tempworkdir/src /home/ubuntu/spr-fast/tests/corebench/coreutils/coreutils-case-7380cf79-2e636af1/tempworkdir/tests /home/ubuntu/spr-fast/tests/corebench/coreutils/coreutils-case-7380cf79-2e636af1/tempworkdir 0  > __res
Running test command:
/home/ubuntu/spr-fast/tools/coreutils-test.py /home/ubuntu/spr-fast/tests/corebench/coreutils/coreutils-case-7380cf79-2e636af1/tempworkdir/src /home/ubuntu/spr-fast/tests/corebench/coreutils/coreutils-case-7380cf79-2e636af1/tempworkdir/tests /home/ubuntu/spr-fast/tests/corebench/coreutils/coreutils-case-7380cf79-2e636af1/tempworkdir 0  > __res
CondTester, Testing instance id 27:
Running test command:
/home/ubuntu/spr-fast/tools/coreutils-test.py /home/ubuntu/spr-fast/tests/corebench/coreutils/coreutils-case-7380cf79-2e636af1/tempworkdir/src /home/ubuntu/spr-fast/tests/corebench/coreutils/coreutils-case-7380cf79-2e636af1/tempworkdir/tests /home/ubuntu/spr-fast/tests/corebench/coreutils/coreutils-case-7380cf79-2e636af1/tempworkdir 0  > __res
Running test command:
/home/ubuntu/spr-fast/tools/coreutils-test.py /home/ubuntu/spr-fast/tests/corebench/coreutils/coreutils-case-7380cf79-2e636af1/tempworkdir/src /home/ubuntu/spr-fast/tests/corebench/coreutils/coreutils-case-7380cf79-2e636af1/tempworkdir/tests /home/ubuntu/spr-fast/tests/corebench/coreutils/coreutils-case-7380cf79-2e636af1/tempworkdir 0  > __res
Running test command:
/home/ubuntu/spr-fast/tools/coreutils-test.py /home/ubuntu/spr-fast/tests/corebench/coreutils/coreutils-case-7380cf79-2e636af1/tempworkdir/src /home/ubuntu/spr-fast/tests/corebench/coreutils/coreutils-case-7380cf79-2e636af1/tempworkdir/tests /home/ubuntu/spr-fast/tests/corebench/coreutils/coreutils-case-7380cf79-2e636af1/tempworkdir 0  > __res
a batched test job starts!
Building:src at:
/home/ubuntu/spr-fast/tests/corebench/coreutils/coreutils-case-7380cf79-2e636af1/tempworkdir/srcMerged code building failed! Going to build saperately!
Building:src at:
/home/ubuntu/spr-fast/tests/corebench/coreutils/coreutils-case-7380cf79-2e636af1/tempworkdir/srcSingle building for Tester 0x35b62b0 id 32 failed as well!
Building:src at:
/home/ubuntu/spr-fast/tests/corebench/coreutils/coreutils-case-7380cf79-2e636af1/tempworkdir/srcSingle building for Tester 0x35b62b0 id 36 failed as well!
Building:src at:
/home/ubuntu/spr-fast/tests/corebench/coreutils/coreutils-case-7380cf79-2e636af1/tempworkdir/srcSingle building for Tester 0x35b62b0 id 37 failed as well!
a batched test job starts!
Building:src at:
/home/ubuntu/spr-fast/tests/corebench/coreutils/coreutils-case-7380cf79-2e636af1/tempworkdir/srcMerged code building failed! Going to build saperately!
Building:src at:
/home/ubuntu/spr-fast/tests/corebench/coreutils/coreutils-case-7380cf79-2e636af1/tempworkdir/srcSingle building for Tester 0x35b62b0 id 33 failed as well!
Building:src at:
/home/ubuntu/spr-fast/tests/corebench/coreutils/coreutils-case-7380cf79-2e636af1/tempworkdir/srcSingle building for Tester 0x35b62b0 id 34 failed as well!
Building:src at:
/home/ubuntu/spr-fast/tests/corebench/coreutils/coreutils-case-7380cf79-2e636af1/tempworkdir/srcSingle building for Tester 0x35b62b0 id 35 failed as well!
a batched test job starts!
Building:src at:
/home/ubuntu/spr-fast/tests/corebench/coreutils/coreutils-case-7380cf79-2e636af1/tempworkdir/srcMerged code building succ, going to invoke tester!
CondTester, Testing instance id 28:
Running test command:
/home/ubuntu/spr-fast/tools/coreutils-test.py /home/ubuntu/spr-fast/tests/corebench/coreutils/coreutils-case-7380cf79-2e636af1/tempworkdir/src /home/ubuntu/spr-fast/tests/corebench/coreutils/coreutils-case-7380cf79-2e636af1/tempworkdir/tests /home/ubuntu/spr-fast/tests/corebench/coreutils/coreutils-case-7380cf79-2e636af1/tempworkdir 0  > __res
Running test command:
/home/ubuntu/spr-fast/tools/coreutils-test.py /home/ubuntu/spr-fast/tests/corebench/coreutils/coreutils-case-7380cf79-2e636af1/tempworkdir/src /home/ubuntu/spr-fast/tests/corebench/coreutils/coreutils-case-7380cf79-2e636af1/tempworkdir/tests /home/ubuntu/spr-fast/tests/corebench/coreutils/coreutils-case-7380cf79-2e636af1/tempworkdir 0  > __res
Running test command:
/home/ubuntu/spr-fast/tools/coreutils-test.py /home/ubuntu/spr-fast/tests/corebench/coreutils/coreutils-case-7380cf79-2e636af1/tempworkdir/src /home/ubuntu/spr-fast/tests/corebench/coreutils/coreutils-case-7380cf79-2e636af1/tempworkdir/tests /home/ubuntu/spr-fast/tests/corebench/coreutils/coreutils-case-7380cf79-2e636af1/tempworkdir 0  > __res
CondTester, Testing instance id 29:
Running test command:
/home/ubuntu/spr-fast/tools/coreutils-test.py /home/ubuntu/spr-fast/tests/corebench/coreutils/coreutils-case-7380cf79-2e636af1/tempworkdir/src /home/ubuntu/spr-fast/tests/corebench/coreutils/coreutils-case-7380cf79-2e636af1/tempworkdir/tests /home/ubuntu/spr-fast/tests/corebench/coreutils/coreutils-case-7380cf79-2e636af1/tempworkdir 0  > __res
Running test command:
/home/ubuntu/spr-fast/tools/coreutils-test.py /home/ubuntu/spr-fast/tests/corebench/coreutils/coreutils-case-7380cf79-2e636af1/tempworkdir/src /home/ubuntu/spr-fast/tests/corebench/coreutils/coreutils-case-7380cf79-2e636af1/tempworkdir/tests /home/ubuntu/spr-fast/tests/corebench/coreutils/coreutils-case-7380cf79-2e636af1/tempworkdir 0  > __res
a batched test job starts!
Building:src at:
/home/ubuntu/spr-fast/tests/corebench/coreutils/coreutils-case-7380cf79-2e636af1/tempworkdir/srcMerged code building succ, going to invoke tester!
CondTester, Testing instance id 30:
Running test command:
/home/ubuntu/spr-fast/tools/coreutils-test.py /home/ubuntu/spr-fast/tests/corebench/coreutils/coreutils-case-7380cf79-2e636af1/tempworkdir/src /home/ubuntu/spr-fast/tests/corebench/coreutils/coreutils-case-7380cf79-2e636af1/tempworkdir/tests /home/ubuntu/spr-fast/tests/corebench/coreutils/coreutils-case-7380cf79-2e636af1/tempworkdir 0  > __res
Running test command:
/home/ubuntu/spr-fast/tools/coreutils-test.py /home/ubuntu/spr-fast/tests/corebench/coreutils/coreutils-case-7380cf79-2e636af1/tempworkdir/src /home/ubuntu/spr-fast/tests/corebench/coreutils/coreutils-case-7380cf79-2e636af1/tempworkdir/tests /home/ubuntu/spr-fast/tests/corebench/coreutils/coreutils-case-7380cf79-2e636af1/tempworkdir 0  > __res
CondTester, Testing instance id 31:
Running test command:
/home/ubuntu/spr-fast/tools/coreutils-test.py /home/ubuntu/spr-fast/tests/corebench/coreutils/coreutils-case-7380cf79-2e636af1/tempworkdir/src /home/ubuntu/spr-fast/tests/corebench/coreutils/coreutils-case-7380cf79-2e636af1/tempworkdir/tests /home/ubuntu/spr-fast/tests/corebench/coreutils/coreutils-case-7380cf79-2e636af1/tempworkdir 0  > __res
Running test command:
/home/ubuntu/spr-fast/tools/coreutils-test.py /home/ubuntu/spr-fast/tests/corebench/coreutils/coreutils-case-7380cf79-2e636af1/tempworkdir/src /home/ubuntu/spr-fast/tests/corebench/coreutils/coreutils-case-7380cf79-2e636af1/tempworkdir/tests /home/ubuntu/spr-fast/tests/corebench/coreutils/coreutils-case-7380cf79-2e636af1/tempworkdir 0  > __res
Total cnt of passed cond schemas: 3
Total cnt of cond schemas: 49
Counter: 410
Batcher Size:0
The found score 4997959.000000 is greater than current score 4991.000000!
Terminate current session!
Generated a patch at candidate schema no 255
Total cnt of passed cond schemas: 3
Total cnt of cond schemas: 49
Candidate count:0!!
Found a fix! Store to: coreutils-fix-7380cf79-2e636af1src_cut.c
Found a fix! Store to: coreutils-fix-7380cf79-2e636af1src_cut.c-1
Found a fix! Store to: coreutils-fix-7380cf79-2e636af1src_cut.c-2
Antipattern stats END: earlyret => 160
Antipattern stats END: errorexit => 14
Repair process ends successfully!
Total 9086 different repair candidate schema!!!!
Total number of compiles: 75
Total number of test eval: 736
