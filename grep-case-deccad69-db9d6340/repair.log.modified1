Initialize the program!
Verify Test Cases
Building:src at:
/home/ubuntu/spr-fast/tests/corebench/grep/grep-case-deccad69-db9d6340/tempworkdir2/srcRunning test command:
/home/ubuntu/spr-fast/tools/grep-test.py /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-deccad69-db9d6340/tempworkdir2/src /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-deccad69-db9d6340/tempworkdir2/tests /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-deccad69-db9d6340/tempworkdir2 0  > __res
Running test command:
/home/ubuntu/spr-fast/tools/grep-test.py /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-deccad69-db9d6340/tempworkdir2/src /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-deccad69-db9d6340/tempworkdir2/tests /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-deccad69-db9d6340/tempworkdir2 3 4 5 6 9 11 12 13 14 15 17 18 20 22 23 25  > __res
All passed!
Done Verification
Generating repair candidates!
Processing src/search.c
In dir /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-deccad69-db9d6340/tempworkdir2/src
Total 3127 different repair candidate templates!!!!
Total 3127 different repair candidate templates!!!!
Total 3924 different repair candidate!!!
Trying different candidates!
BasicTester pointer: 0x214bb60
CondTester pointer: 0x1942ea0
Counter: 1
Batcher Size:0
Preprocess the following candidate with CondTester:
Priority 20000
At location src/search.c:62
--Src File: src/search.c
Fragment 0:
if ((match_icase && (__ctype_get_mb_cur_max()) == 1) && !(__abst_hole(match_icase, i, kwset))) {
    for (i = 0; i < ((127 * 2 + 1) + 1); ++i) 
        trans[i] = ((1 && ((*__ctype_b_loc())[(int)((i))] & (unsigned short)_ISupper)) ? (__extension__ ({
            int __res;
            if (sizeof (i) > 1) {
                if (__builtin_constant_p(i)) {
                    int __c = (i);
                    __res = __c < -128 || __c > 255 ? __c : (*__ctype_tolower_loc())[__c];
                } else
                    __res = tolower(i);
            } else
                __res = (*__ctype_tolower_loc())[(int)(i)];
            __res;
        })) : (i));
    kwset = kwsalloc(trans);
} else
    kwset = kwsalloc(((void *)0));


CondTester, a patch instance with id 0:
//src_file:src/search.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
/* search.c - searching subroutines using dfa, kwset and regex for grep.
   Copyright 1992, 1998, 2000, 2007, 2009-2010 Free Software Foundation, Inc.

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 3, or (at your option)
   any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program; if not, write to the Free Software
   Foundation, Inc., 51 Franklin Street - Fifth Floor, Boston, MA
   02110-1301, USA.  */

/* Written August 1992 by Mike Haertel. */

#include <config.h>

#include <sys/types.h>

#include "mbsupport.h"
#ifdef MBS_SUPPORT
/* We can handle multibyte strings. */
# include <wchar.h>
# include <wctype.h>
#endif

#include "system.h"
#include "grep.h"
#ifndef FGREP_PROGRAM
# include <regex.h>
# include "dfa.h"
#endif
#include "kwset.h"
#include "error.h"
#include "xalloc.h"
#ifdef HAVE_LIBPCRE
# include <pcre.h>
#endif

#define NCHAR (UCHAR_MAX + 1)

/* For -w, we also consider _ to be word constituent.  */
#define WCHAR(C) (ISALNUM(C) || (C) == '_')

/* KWset compiled pattern.  For Ecompile and Gcompile, we compile
   a list of strings, at least one of which is known to occur in
   any string matching the regexp. */
static kwset_t kwset;

static void
kwsinit (void)
{
  static char trans[NCHAR];
  int i;

  
//Patch 0:
if ((match_icase && (__ctype_get_mb_cur_max()) == 1) && !(__is_neg(3, &(match_icase), sizeof (match_icase), &(i), sizeof (i), &(kwset), sizeof (kwset)))) {
    for (i = 0; i < ((127 * 2 + 1) + 1); ++i) 
        trans[i] = ((1 && ((*__ctype_b_loc())[(int)((i))] & (unsigned short)_ISupper)) ? (__extension__ ({
            int __res;
            if (sizeof (i) > 1) {
                if (__builtin_constant_p(i)) {
                    int __c = (i);
                    __res = __c < -128 || __c > 255 ? __c : (*__ctype_tolower_loc())[__c];
                } else
                    __res = tolower(i);
            } else
                __res = (*__ctype_tolower_loc())[(int)(i)];
            __res;
        })) : (i));
    kwset = kwsalloc(trans);
} else
    kwset = kwsalloc(((void *)0));

//CodeSeg 1:

  if (!kwset)
    xalloc_die ();
}

#ifdef MBS_SUPPORT
/* Convert the *N-byte string, BEG, to lowercase, and write the
   NUL-terminated result into malloc'd storage.  Upon success, set *N
   to the length (in bytes) of the resulting string (not including the
   trailing NUL byte), and return a pointer to the lowercase string.
   Upon memory allocation failure, this function exits.

   Note that while this function returns a pointer to malloc'd storage,
   the caller must not free it, since this function retains a pointer
   to the buffer and reuses it on any subsequent call.  As a consequence,
   this function is not thread-safe.  */
static char *
mbtolower (const char *beg, size_t *n)
{
  static char *out;
  static size_t outalloc;
  size_t outlen, mb_cur_max;
  mbstate_t is, os;
  const char *end;
  char *p;

  if (*n > outalloc)
    {
      out = xrealloc (out, *n);
      outalloc = *n;
    }

  memset (&is, 0, sizeof (is));
  memset (&os, 0, sizeof (os));
  end = beg + *n;

  mb_cur_max = MB_CUR_MAX;
  p = out;
  outlen = 0;
  while (beg < end)
    {
      wchar_t wc;
      size_t mbclen = mbrtowc(&wc, beg, end - beg, &is);
      if (outlen + mb_cur_max >= outalloc)
        {
          out = x2nrealloc (out, &outalloc, 1);
          p = out + outlen;
        }

      if (mbclen == (size_t) -1 || mbclen == (size_t) -2 || mbclen == 0)
        {
          /* An invalid sequence, or a truncated multi-octet character.
             We treat it as a single-octet character.  */
          *p++ = *beg++;
          outlen++;
          memset (&is, 0, sizeof (is));
          memset (&os, 0, sizeof (os));
        }
      else
        {
          beg += mbclen;
          mbclen = wcrtomb (p, towlower ((wint_t) wc), &os);
          p += mbclen;
          outlen += mbclen;
        }
    }

  *n = p - out;
  *p++ = 0;
  return out;
}
#endif


#ifndef FGREP_PROGRAM
/* DFA compiled regexp. */
static struct dfa dfa;

/* The Regex compiled patterns.  */
static struct patterns
{
  /* Regex compiled regexp. */
  struct re_pattern_buffer regexbuf;
  struct re_registers regs; /* This is here on account of a BRAIN-DEAD
			       Q@#%!# library interface in regex.c.  */
} patterns0;

struct patterns *patterns;
size_t pcount;

void
dfaerror (char const *mesg)
{
  error (EXIT_TROUBLE, 0, "%s", mesg);
}

/* Number of compiled fixed strings known to exactly match the regexp.
   If kwsexec returns < kwset_exact_matches, then we don't need to
   call the regexp matcher at all. */
static int kwset_exact_matches;

static char const *
kwsincr_case (const char *must)
{
  const char *buf;
  size_t n;

  n = strlen (must);
#ifdef MBS_SUPPORT
  if (match_icase && MB_CUR_MAX > 1)
    buf = mbtolower (must, &n);
  else
#endif
    buf = must;
  return kwsincr (kwset, buf, n);
}

/* If the DFA turns out to have some set of fixed strings one of
   which must occur in the match, then we build a kwset matcher
   to find those strings, and thus quickly filter out impossible
   matches. */
static void
kwsmusts (void)
{
  struct dfamust const *dm;
  char const *err;

  if (dfa.musts)
    {
      kwsinit ();
      /* First, we compile in the substrings known to be exact
	 matches.  The kwset matcher will return the index
	 of the matching string that it chooses. */
      for (dm = dfa.musts; dm; dm = dm->next)
	{
	  if (!dm->exact)
	    continue;
	  ++kwset_exact_matches;
	  if ((err = kwsincr_case (dm->must)) != NULL)
	    error (EXIT_TROUBLE, 0, "%s", err);
	}
      /* Now, we compile the substrings that will require
	 the use of the regexp matcher.  */
      for (dm = dfa.musts; dm; dm = dm->next)
	{
	  if (dm->exact)
	    continue;
	  if ((err = kwsincr_case (dm->must)) != NULL)
	    error (EXIT_TROUBLE, 0, "%s", err);
	}
      if ((err = kwsprep (kwset)) != NULL)
	error (EXIT_TROUBLE, 0, "%s", err);
    }
}
#endif /* !FGREP_PROGRAM */

#ifdef MBS_SUPPORT

static bool
is_mb_middle(const char **good, const char *buf, const char *end)
{
  const char *p = *good;
  const char *prev = p;
  mbstate_t cur_state;

  /* TODO: can be optimized for UTF-8.  */
  memset(&cur_state, 0, sizeof(mbstate_t));
  while (p < buf)
    {
      size_t mbclen = mbrlen(p, end - p, &cur_state);

      /* Store the beginning of the previous complete multibyte character.  */
      if (mbclen != (size_t) -2)
        prev = p;

      if (mbclen == (size_t) -1 || mbclen == (size_t) -2 || mbclen == 0)
	{
	  /* An invalid sequence, or a truncated multibyte character.
	     We treat it as a single byte character.  */
	  mbclen = 1;
	}
      p += mbclen;
    }

  *good = prev;
  return p > buf;
}
#endif /* MBS_SUPPORT */

#if defined(GREP_PROGRAM) || defined(EGREP_PROGRAM)
#ifdef EGREP_PROGRAM
COMPILE_FCT(Ecompile)
{
  reg_syntax_t syntax_bits = RE_SYNTAX_POSIX_EGREP;
#else
/* No __VA_ARGS__ in C89.  So we have to do it this way.  */
static COMPILE_RET
GEAcompile (char const *pattern, size_t size, reg_syntax_t syntax_bits)
{
#endif /* EGREP_PROGRAM */
  const char *err;
  const char *p, *sep;
  size_t total = size;
  char *motif;

  if (match_icase)
    syntax_bits |= RE_ICASE;
  re_set_syntax (syntax_bits);
  dfasyntax (syntax_bits, match_icase, eolbyte);

  /* For GNU regex compiler we have to pass the patterns separately to detect
     errors like "[\nallo\n]\n".  The patterns here are "[", "allo" and "]"
     GNU regex should have raise a syntax error.  The same for backref, where
     the backref should have been local to each pattern.  */
  p = pattern;
  do
    {
      size_t len;
      sep = memchr (p, '\n', total);
      if (sep)
	{
	  len = sep - p;
	  sep++;
	  total -= (len + 1);
	}
      else
	{
	  len = total;
	  total = 0;
	}

      patterns = realloc (patterns, (pcount + 1) * sizeof (*patterns));
      if (patterns == NULL)
	error (EXIT_TROUBLE, errno, _("memory exhausted"));
      patterns[pcount] = patterns0;

      if ((err = re_compile_pattern (p, len,
				    &(patterns[pcount].regexbuf))) != NULL)
	error (EXIT_TROUBLE, 0, "%s", err);
      pcount++;

      p = sep;
    } while (sep && total != 0);

  /* In the match_words and match_lines cases, we use a different pattern
     for the DFA matcher that will quickly throw out cases that won't work.
     Then if DFA succeeds we do some hairy stuff using the regex matcher
     to decide whether the match should really count. */
  if (match_words || match_lines)
    {
      static char const line_beg_no_bk[] = "^(";
      static char const line_end_no_bk[] = ")$";
      static char const word_beg_no_bk[] = "(^|[^[:alnum:]_])(";
      static char const word_end_no_bk[] = ")([^[:alnum:]_]|$)";
#ifdef EGREP_PROGRAM
# define IF_BK(x, y) (y)
      char *n = xmalloc (sizeof word_beg_no_bk - 1 + size + sizeof word_end_no_bk);
#else
      static char const line_beg_bk[] = "^\\(";
      static char const line_end_bk[] = "\\)$";
      static char const word_beg_bk[] = "\\(^\\|[^[:alnum:]_]\\)\\(";
      static char const word_end_bk[] = "\\)\\([^[:alnum:]_]\\|$\\)";
      int bk = !(syntax_bits & RE_NO_BK_PARENS);
# define IF_BK(x, y) ((bk) ? (x) : (y))
      char *n = xmalloc (sizeof word_beg_bk - 1 + size + sizeof word_end_bk);
#endif /* EGREP_PROGRAM */

      strcpy (n, match_lines ? IF_BK(line_beg_bk, line_beg_no_bk)
			     : IF_BK(word_beg_bk, word_beg_no_bk));
      total = strlen(n);
      memcpy (n + total, pattern, size);
      total += size;
      strcpy (n + total, match_lines ? IF_BK(line_end_bk, line_end_no_bk)
				     : IF_BK(word_end_bk, word_end_no_bk));
      total += strlen (n + total);
      pattern = motif = n;
      size = total;
    }
  else
    motif = NULL;

  dfacomp (pattern, size, &dfa, 1);
  kwsmusts ();

  free(motif);
}

#ifndef EGREP_PROGRAM
COMPILE_FCT(Gcompile)
{
  return GEAcompile (pattern, size,
		     RE_SYNTAX_GREP | RE_HAT_LISTS_NOT_NEWLINE);
}

COMPILE_FCT(Acompile)
{
  return GEAcompile (pattern, size, RE_SYNTAX_AWK);
}

COMPILE_FCT(Ecompile)
{
  return GEAcompile (pattern, size, RE_SYNTAX_POSIX_EGREP);
}
#endif /* !EGREP_PROGRAM */

EXECUTE_FCT(EGexecute)
{
  char const *buflim, *beg, *end, *match, *best_match, *mb_start;
  char eol = eolbyte;
  int backref, start, len, best_len;
  struct kwsmatch kwsm;
  size_t i, ret_val;
#ifdef MBS_SUPPORT
  if (MB_CUR_MAX > 1)
    {
      if (match_icase)
        {
          /* mbtolower adds a NUL byte at the end.  That will provide
	     space for the sentinel byte dfaexec may add.  */
          char *case_buf = mbtolower (buf, &size);
	  if (start_ptr)
	    start_ptr = case_buf + (start_ptr - buf);
          buf = case_buf;
        }
    }
#endif /* MBS_SUPPORT */

  mb_start = buf;
  buflim = buf + size;

  for (beg = end = buf; end < buflim; beg = end)
    {
      if (!start_ptr)
	{
	  /* We don't care about an exact match.  */
	  if (kwset)
	    {
	      /* Find a possible match using the KWset matcher. */
	      size_t offset = kwsexec (kwset, beg, buflim - beg, &kwsm);
	      if (offset == (size_t) -1)
		goto failure;
	      beg += offset;
	      /* Narrow down to the line containing the candidate, and
		 run it through DFA. */
	      if ((end = memchr(beg, eol, buflim - beg)) != NULL)
	        end++;
              else
                end = buflim;
	      match = beg;
	      while (beg > buf && beg[-1] != eol)
		--beg;
	      if (kwsm.index < kwset_exact_matches)
                {
#ifdef MBS_SUPPORT
                  if (mb_start < beg)
                    mb_start = beg;
                  if (MB_CUR_MAX == 1 || !is_mb_middle (&mb_start, match, buflim))
#endif
                    goto success;
                }
	      if (dfaexec (&dfa, beg, (char *) end, 0, NULL, &backref) == NULL)
		continue;
	    }
	  else
	    {
	      /* No good fixed strings; start with DFA. */
	      char const *next_beg = dfaexec (&dfa, beg, (char *) buflim,
					      0, NULL, &backref);
	      if (next_beg == NULL)
		break;
	      /* Narrow down to the line we've found. */
	      beg = next_beg;
	      if ((end = memchr(beg, eol, buflim - beg)) != NULL)
	        end++;
              else
                end = buflim;
	      while (beg > buf && beg[-1] != eol)
		--beg;
	    }
	  /* Successful, no backreferences encountered! */
	  if (!backref)
	    goto success;
	}
      else
	{
	  /* We are looking for the leftmost (then longest) exact match.
	     We will go through the outer loop only once.  */
	  beg = start_ptr;
	  end = buflim;
	}

      /* If we've made it to this point, this means DFA has seen
	 a probable match, and we need to run it through Regex. */
      best_match = end;
      best_len = 0;
      for (i = 0; i < pcount; i++)
	{
	  patterns[i].regexbuf.not_eol = 0;
	  if (0 <= (start = re_search (&(patterns[i].regexbuf),
				       buf, end - buf - 1,
				       beg - buf, end - beg - 1,
				       &(patterns[i].regs))))
	    {
	      len = patterns[i].regs.end[0] - start;
	      match = buf + start;
	      if (match > best_match)
		continue;
	      if (start_ptr && !match_words)
		goto assess_pattern_match;
	      if ((!match_lines && !match_words)
		  || (match_lines && len == end - beg - 1))
		{
		  match = beg;
		  len = end - beg;
		  goto assess_pattern_match;
		}
	      /* If -w, check if the match aligns with word boundaries.
		 We do this iteratively because:
		 (a) the line may contain more than one occurence of the
		 pattern, and
		 (b) Several alternatives in the pattern might be valid at a
		 given point, and we may need to consider a shorter one to
		 find a word boundary.  */
	      if (match_words)
		while (match <= best_match)
		  {
		    if ((match == buf || !WCHAR ((unsigned char) match[-1]))
			&& (len == end - beg - 1
			    || !WCHAR ((unsigned char) match[len])))
		      goto assess_pattern_match;
		    if (len > 0)
		      {
			/* Try a shorter length anchored at the same place. */
			--len;
			patterns[i].regexbuf.not_eol = 1;
			len = re_match (&(patterns[i].regexbuf),
					buf, match + len - beg, match - buf,
					&(patterns[i].regs));
		      }
		    if (len <= 0)
		      {
			/* Try looking further on. */
			if (match == end - 1)
			  break;
			match++;
			patterns[i].regexbuf.not_eol = 0;
			start = re_search (&(patterns[i].regexbuf),
					   buf, end - buf - 1,
					   match - buf, end - match - 1,
					   &(patterns[i].regs));
			if (start < 0)
			  break;
			len = patterns[i].regs.end[0] - start;
			match = buf + start;
		      }
		  } /* while (match <= best_match) */
	      continue;
	    assess_pattern_match:
	      if (!start_ptr)
		{
		  /* Good enough for a non-exact match.
		     No need to look at further patterns, if any.  */
		  beg = match;
		  goto success_in_len;
		}
	      if (match < best_match || (match == best_match && len > best_len))
		{
		  /* Best exact match:  leftmost, then longest.  */
		  best_match = match;
		  best_len = len;
		}
	    } /* if re_search >= 0 */
	} /* for Regex patterns.  */
	if (best_match < end)
	  {
	    /* We have found an exact match.  We were just
	       waiting for the best one (leftmost then longest).  */
	    beg = best_match;
	    len = best_len;
	    goto success_in_len;
	  }
    } /* for (beg = end ..) */

 failure:
  ret_val = -1;
  goto out;

 success:
  len = end - beg;
 success_in_len:
  *match_size = len;
  ret_val = beg - buf;
 out:
  return ret_val;
}
#endif /* defined(GREP_PROGRAM) || defined(EGREP_PROGRAM) */

#if defined(GREP_PROGRAM) || defined(FGREP_PROGRAM)
COMPILE_FCT(Fcompile)
{
  char const *beg, *end, *lim, *err, *pat;
  size_t psize;

  kwsinit ();
  psize = size;
  if (match_icase && MB_CUR_MAX > 1)
    pat = mbtolower (pattern, &psize);
  else
    pat = pattern;

  beg = pat;
  do
    {
      for (lim = beg;; ++lim)
	{
	  end = lim;
	  if (lim >= pat + psize)
	    break;
	 if (*lim == '\n')
	   {
	     lim++;
	     break;
	   }
#if HAVE_DOS_FILE_CONTENTS
	 if (*lim == '\r' && lim + 1 < pat + psize && lim[1] == '\n')
	   {
	     lim += 2;
	     break;
	   }
#endif
	}

      if ((err = kwsincr (kwset, beg, end - beg)) != NULL)
	error (EXIT_TROUBLE, 0, "%s", err);
      beg = lim;
    }
  while (beg < pat + psize);

  if ((err = kwsprep (kwset)) != NULL)
    error (EXIT_TROUBLE, 0, "%s", err);
}

EXECUTE_FCT(Fexecute)
{
  char const *beg, *try, *end, *mb_start;
  size_t len;
  char eol = eolbyte;
  struct kwsmatch kwsmatch;
  size_t ret_val;
#ifdef MBS_SUPPORT
  if (MB_CUR_MAX > 1)
    {
      if (match_icase)
        {
          char *case_buf = mbtolower (buf, &size);
	  if (start_ptr)
	    start_ptr = case_buf + (start_ptr - buf);
          buf = case_buf;
        }
    }
#endif /* MBS_SUPPORT */

  for (mb_start = beg = start_ptr ? start_ptr : buf; beg <= buf + size; beg++)
    {
      size_t offset = kwsexec (kwset, beg, buf + size - beg, &kwsmatch);
      if (offset == (size_t) -1)
	goto failure;
#ifdef MBS_SUPPORT
      if (MB_CUR_MAX > 1 && is_mb_middle (&mb_start, beg + offset, buf + size))
        {
          beg = mb_start - 1;
          continue; /* It is a part of multibyte character.  */
        }
#endif /* MBS_SUPPORT */
      beg += offset;
      len = kwsmatch.size[0];
      if (start_ptr && !match_words)
	goto success_in_beg_and_len;
      if (match_lines)
	{
	  if (beg > buf && beg[-1] != eol)
	    continue;
	  if (beg + len < buf + size && beg[len] != eol)
	    continue;
	  goto success;
	}
      else if (match_words)
	for (try = beg; len; )
	  {
	    if (try > buf && WCHAR((unsigned char) try[-1]))
	      break;
	    if (try + len < buf + size && WCHAR((unsigned char) try[len]))
	      {
		offset = kwsexec (kwset, beg, --len, &kwsmatch);
		if (offset == (size_t) -1)
		  break;
		try = beg + offset;
		len = kwsmatch.size[0];
	      }
	    else if (!start_ptr)
	      goto success;
	    else
	      goto success_in_beg_and_len;
	  } /* for (try) */
      else
	goto success;
    } /* for (beg in buf) */

 failure:
  ret_val = -1;
  goto out;

 success:
  if ((end = memchr (beg + len, eol, (buf + size) - (beg + len))) != NULL)
    end++;
  else
    end = buf + size;
  while (buf < beg && beg[-1] != eol)
    --beg;
  len = end - beg;
 success_in_beg_and_len:
  *match_size = len;
  ret_val = beg - buf;
 out:
  return ret_val;
}
#endif /* defined(GREP_PROGRAM) || defined(FGREP_PROGRAM) */

#ifdef GREP_PROGRAM
#if HAVE_LIBPCRE
/* Compiled internal form of a Perl regular expression.  */
static pcre *cre;

/* Additional information about the pattern.  */
static pcre_extra *extra;
#endif

COMPILE_FCT(Pcompile)
{
#if !HAVE_LIBPCRE
  error (EXIT_TROUBLE, 0, "%s",
	 _("support for the -P option is not compiled into "
	   "this --disable-perl-regexp binary"));
#else
  int e;
  char const *ep;
  char *re = xmalloc (4 * size + 7);
  int flags = PCRE_MULTILINE | (match_icase ? PCRE_CASELESS : 0);
  char const *patlim = pattern + size;
  char *n = re;
  char const *p;
  char const *pnul;

  /* FIXME: Remove these restrictions.  */
  if (memchr(pattern, '\n', size))
    error (EXIT_TROUBLE, 0, _("the -P option only supports a single pattern"));

  *n = '\0';
  if (match_lines)
    strcpy (n, "^(");
  if (match_words)
    strcpy (n, "\\b(");
  n += strlen (n);

  /* The PCRE interface doesn't allow NUL bytes in the pattern, so
     replace each NUL byte in the pattern with the four characters
     "\000", removing a preceding backslash if there are an odd
     number of backslashes before the NUL.

     FIXME: This method does not work with some multibyte character
     encodings, notably Shift-JIS, where a multibyte character can end
     in a backslash byte.  */
  for (p = pattern; (pnul = memchr (p, '\0', patlim - p)); p = pnul + 1)
    {
      memcpy (n, p, pnul - p);
      n += pnul - p;
      for (p = pnul; pattern < p && p[-1] == '\\'; p--)
	continue;
      n -= (pnul - p) & 1;
      strcpy (n, "\\000");
      n += 4;
    }

  memcpy (n, p, patlim - p);
  n += patlim - p;
  *n = '\0';
  if (match_words)
    strcpy (n, ")\\b");
  if (match_lines)
    strcpy (n, ")$");

  cre = pcre_compile (re, flags, &ep, &e, pcre_maketables ());
  if (!cre)
    error (EXIT_TROUBLE, 0, "%s", ep);

  extra = pcre_study (cre, 0, &ep);
  if (ep)
    error (EXIT_TROUBLE, 0, "%s", ep);

  free (re);
#endif
}

EXECUTE_FCT(Pexecute)
{
#if !HAVE_LIBPCRE
  abort ();
  return -1;
#else
  /* This array must have at least two elements; everything after that
     is just for performance improvement in pcre_exec.  */
  int sub[300];

  const char *line_buf, *line_end, *line_next;
  int e = PCRE_ERROR_NOMATCH;
  ptrdiff_t start_ofs = start_ptr ? start_ptr - buf : 0;

  /* PCRE can't limit the matching to single lines, therefore we have to
     match each line in the buffer separately.  */
  for (line_next = buf;
       e == PCRE_ERROR_NOMATCH && line_next < buf + size;
       start_ofs -= line_next - line_buf)
    {
      line_buf = line_next;
      line_end = memchr (line_buf, eolbyte, (buf + size) - line_buf);
      if (line_end == NULL)
        line_next = line_end = buf + size;
      else
        line_next = line_end + 1;

      if (start_ptr && start_ptr >= line_end)
        continue;

      e = pcre_exec (cre, extra, line_buf, line_end - line_buf,
                     start_ofs < 0 ? 0 : start_ofs, 0,
                     sub, sizeof sub / sizeof *sub);
    }

  if (e <= 0)
    {
      switch (e)
	{
	case PCRE_ERROR_NOMATCH:
	  return -1;

	case PCRE_ERROR_NOMEMORY:
	  error (EXIT_TROUBLE, 0, _("memory exhausted"));

	default:
	  abort ();
	}
    }
  else
    {
      /* Narrow down to the line we've found.  */
      char const *beg = line_buf + sub[0];
      char const *end = line_buf + sub[1];
      char const *buflim = buf + size;
      char eol = eolbyte;
      if (!start_ptr)
	{
	  /* FIXME: The case when '\n' is not found indicates a bug:
	     Since grep is line oriented, the match should never contain
	     a newline, so there _must_ be a newline following.
	   */
	  if (!(end = memchr (end, eol, buflim - end)))
	    end = buflim;
	  else
	    end++;
	  while (buf < beg && beg[-1] != eol)
	    --beg;
	}

      *match_size = end - beg;
      return beg - buf;
    }
#endif
}

struct matcher const matchers[] = {
  { "default", Gcompile, EGexecute },
  { "grep",    Gcompile, EGexecute },
  { "egrep",   Ecompile, EGexecute },
  { "awk",     Acompile, EGexecute },
  { "fgrep",   Fcompile, Fexecute },
  { "perl",    Pcompile, Pexecute },
  { "", 0, 0 },
};
#endif /* GREP_PROGRAM */

Spawn 1 instances, now Total 1
Counter: 2
Batcher Size:1
Preprocess the following candidate with CondTester:
Priority 20000
At location src/search.c:72
--Src File: src/search.c
Fragment 0:
if ((!kwset) && !(__abst_hole(kwset, i, match_icase)))
    xalloc_die();


CondTester, a patch instance with id 1:
//src_file:src/search.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
/* search.c - searching subroutines using dfa, kwset and regex for grep.
   Copyright 1992, 1998, 2000, 2007, 2009-2010 Free Software Foundation, Inc.

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 3, or (at your option)
   any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program; if not, write to the Free Software
   Foundation, Inc., 51 Franklin Street - Fifth Floor, Boston, MA
   02110-1301, USA.  */

/* Written August 1992 by Mike Haertel. */

#include <config.h>

#include <sys/types.h>

#include "mbsupport.h"
#ifdef MBS_SUPPORT
/* We can handle multibyte strings. */
# include <wchar.h>
# include <wctype.h>
#endif

#include "system.h"
#include "grep.h"
#ifndef FGREP_PROGRAM
# include <regex.h>
# include "dfa.h"
#endif
#include "kwset.h"
#include "error.h"
#include "xalloc.h"
#ifdef HAVE_LIBPCRE
# include <pcre.h>
#endif

#define NCHAR (UCHAR_MAX + 1)

/* For -w, we also consider _ to be word constituent.  */
#define WCHAR(C) (ISALNUM(C) || (C) == '_')

/* KWset compiled pattern.  For Ecompile and Gcompile, we compile
   a list of strings, at least one of which is known to occur in
   any string matching the regexp. */
static kwset_t kwset;

static void
kwsinit (void)
{
  static char trans[NCHAR];
  int i;

  if (match_icase && MB_CUR_MAX == 1)
    {
      for (i = 0; i < NCHAR; ++i)
        trans[i] = TOLOWER (i);

      kwset = kwsalloc (trans);
    }
  else
    kwset = kwsalloc (NULL);

  
//Patch 0:
if ((!kwset) && !(__is_neg(3, &(kwset), sizeof (kwset), &(i), sizeof (i), &(match_icase), sizeof (match_icase))))
    xalloc_die();

//CodeSeg 1:
}

#ifdef MBS_SUPPORT
/* Convert the *N-byte string, BEG, to lowercase, and write the
   NUL-terminated result into malloc'd storage.  Upon success, set *N
   to the length (in bytes) of the resulting string (not including the
   trailing NUL byte), and return a pointer to the lowercase string.
   Upon memory allocation failure, this function exits.

   Note that while this function returns a pointer to malloc'd storage,
   the caller must not free it, since this function retains a pointer
   to the buffer and reuses it on any subsequent call.  As a consequence,
   this function is not thread-safe.  */
static char *
mbtolower (const char *beg, size_t *n)
{
  static char *out;
  static size_t outalloc;
  size_t outlen, mb_cur_max;
  mbstate_t is, os;
  const char *end;
  char *p;

  if (*n > outalloc)
    {
      out = xrealloc (out, *n);
      outalloc = *n;
    }

  memset (&is, 0, sizeof (is));
  memset (&os, 0, sizeof (os));
  end = beg + *n;

  mb_cur_max = MB_CUR_MAX;
  p = out;
  outlen = 0;
  while (beg < end)
    {
      wchar_t wc;
      size_t mbclen = mbrtowc(&wc, beg, end - beg, &is);
      if (outlen + mb_cur_max >= outalloc)
        {
          out = x2nrealloc (out, &outalloc, 1);
          p = out + outlen;
        }

      if (mbclen == (size_t) -1 || mbclen == (size_t) -2 || mbclen == 0)
        {
          /* An invalid sequence, or a truncated multi-octet character.
             We treat it as a single-octet character.  */
          *p++ = *beg++;
          outlen++;
          memset (&is, 0, sizeof (is));
          memset (&os, 0, sizeof (os));
        }
      else
        {
          beg += mbclen;
          mbclen = wcrtomb (p, towlower ((wint_t) wc), &os);
          p += mbclen;
          outlen += mbclen;
        }
    }

  *n = p - out;
  *p++ = 0;
  return out;
}
#endif


#ifndef FGREP_PROGRAM
/* DFA compiled regexp. */
static struct dfa dfa;

/* The Regex compiled patterns.  */
static struct patterns
{
  /* Regex compiled regexp. */
  struct re_pattern_buffer regexbuf;
  struct re_registers regs; /* This is here on account of a BRAIN-DEAD
			       Q@#%!# library interface in regex.c.  */
} patterns0;

struct patterns *patterns;
size_t pcount;

void
dfaerror (char const *mesg)
{
  error (EXIT_TROUBLE, 0, "%s", mesg);
}

/* Number of compiled fixed strings known to exactly match the regexp.
   If kwsexec returns < kwset_exact_matches, then we don't need to
   call the regexp matcher at all. */
static int kwset_exact_matches;

static char const *
kwsincr_case (const char *must)
{
  const char *buf;
  size_t n;

  n = strlen (must);
#ifdef MBS_SUPPORT
  if (match_icase && MB_CUR_MAX > 1)
    buf = mbtolower (must, &n);
  else
#endif
    buf = must;
  return kwsincr (kwset, buf, n);
}

/* If the DFA turns out to have some set of fixed strings one of
   which must occur in the match, then we build a kwset matcher
   to find those strings, and thus quickly filter out impossible
   matches. */
static void
kwsmusts (void)
{
  struct dfamust const *dm;
  char const *err;

  if (dfa.musts)
    {
      kwsinit ();
      /* First, we compile in the substrings known to be exact
	 matches.  The kwset matcher will return the index
	 of the matching string that it chooses. */
      for (dm = dfa.musts; dm; dm = dm->next)
	{
	  if (!dm->exact)
	    continue;
	  ++kwset_exact_matches;
	  if ((err = kwsincr_case (dm->must)) != NULL)
	    error (EXIT_TROUBLE, 0, "%s", err);
	}
      /* Now, we compile the substrings that will require
	 the use of the regexp matcher.  */
      for (dm = dfa.musts; dm; dm = dm->next)
	{
	  if (dm->exact)
	    continue;
	  if ((err = kwsincr_case (dm->must)) != NULL)
	    error (EXIT_TROUBLE, 0, "%s", err);
	}
      if ((err = kwsprep (kwset)) != NULL)
	error (EXIT_TROUBLE, 0, "%s", err);
    }
}
#endif /* !FGREP_PROGRAM */

#ifdef MBS_SUPPORT

static bool
is_mb_middle(const char **good, const char *buf, const char *end)
{
  const char *p = *good;
  const char *prev = p;
  mbstate_t cur_state;

  /* TODO: can be optimized for UTF-8.  */
  memset(&cur_state, 0, sizeof(mbstate_t));
  while (p < buf)
    {
      size_t mbclen = mbrlen(p, end - p, &cur_state);

      /* Store the beginning of the previous complete multibyte character.  */
      if (mbclen != (size_t) -2)
        prev = p;

      if (mbclen == (size_t) -1 || mbclen == (size_t) -2 || mbclen == 0)
	{
	  /* An invalid sequence, or a truncated multibyte character.
	     We treat it as a single byte character.  */
	  mbclen = 1;
	}
      p += mbclen;
    }

  *good = prev;
  return p > buf;
}
#endif /* MBS_SUPPORT */

#if defined(GREP_PROGRAM) || defined(EGREP_PROGRAM)
#ifdef EGREP_PROGRAM
COMPILE_FCT(Ecompile)
{
  reg_syntax_t syntax_bits = RE_SYNTAX_POSIX_EGREP;
#else
/* No __VA_ARGS__ in C89.  So we have to do it this way.  */
static COMPILE_RET
GEAcompile (char const *pattern, size_t size, reg_syntax_t syntax_bits)
{
#endif /* EGREP_PROGRAM */
  const char *err;
  const char *p, *sep;
  size_t total = size;
  char *motif;

  if (match_icase)
    syntax_bits |= RE_ICASE;
  re_set_syntax (syntax_bits);
  dfasyntax (syntax_bits, match_icase, eolbyte);

  /* For GNU regex compiler we have to pass the patterns separately to detect
     errors like "[\nallo\n]\n".  The patterns here are "[", "allo" and "]"
     GNU regex should have raise a syntax error.  The same for backref, where
     the backref should have been local to each pattern.  */
  p = pattern;
  do
    {
      size_t len;
      sep = memchr (p, '\n', total);
      if (sep)
	{
	  len = sep - p;
	  sep++;
	  total -= (len + 1);
	}
      else
	{
	  len = total;
	  total = 0;
	}

      patterns = realloc (patterns, (pcount + 1) * sizeof (*patterns));
      if (patterns == NULL)
	error (EXIT_TROUBLE, errno, _("memory exhausted"));
      patterns[pcount] = patterns0;

      if ((err = re_compile_pattern (p, len,
				    &(patterns[pcount].regexbuf))) != NULL)
	error (EXIT_TROUBLE, 0, "%s", err);
      pcount++;

      p = sep;
    } while (sep && total != 0);

  /* In the match_words and match_lines cases, we use a different pattern
     for the DFA matcher that will quickly throw out cases that won't work.
     Then if DFA succeeds we do some hairy stuff using the regex matcher
     to decide whether the match should really count. */
  if (match_words || match_lines)
    {
      static char const line_beg_no_bk[] = "^(";
      static char const line_end_no_bk[] = ")$";
      static char const word_beg_no_bk[] = "(^|[^[:alnum:]_])(";
      static char const word_end_no_bk[] = ")([^[:alnum:]_]|$)";
#ifdef EGREP_PROGRAM
# define IF_BK(x, y) (y)
      char *n = xmalloc (sizeof word_beg_no_bk - 1 + size + sizeof word_end_no_bk);
#else
      static char const line_beg_bk[] = "^\\(";
      static char const line_end_bk[] = "\\)$";
      static char const word_beg_bk[] = "\\(^\\|[^[:alnum:]_]\\)\\(";
      static char const word_end_bk[] = "\\)\\([^[:alnum:]_]\\|$\\)";
      int bk = !(syntax_bits & RE_NO_BK_PARENS);
# define IF_BK(x, y) ((bk) ? (x) : (y))
      char *n = xmalloc (sizeof word_beg_bk - 1 + size + sizeof word_end_bk);
#endif /* EGREP_PROGRAM */

      strcpy (n, match_lines ? IF_BK(line_beg_bk, line_beg_no_bk)
			     : IF_BK(word_beg_bk, word_beg_no_bk));
      total = strlen(n);
      memcpy (n + total, pattern, size);
      total += size;
      strcpy (n + total, match_lines ? IF_BK(line_end_bk, line_end_no_bk)
				     : IF_BK(word_end_bk, word_end_no_bk));
      total += strlen (n + total);
      pattern = motif = n;
      size = total;
    }
  else
    motif = NULL;

  dfacomp (pattern, size, &dfa, 1);
  kwsmusts ();

  free(motif);
}

#ifndef EGREP_PROGRAM
COMPILE_FCT(Gcompile)
{
  return GEAcompile (pattern, size,
		     RE_SYNTAX_GREP | RE_HAT_LISTS_NOT_NEWLINE);
}

COMPILE_FCT(Acompile)
{
  return GEAcompile (pattern, size, RE_SYNTAX_AWK);
}

COMPILE_FCT(Ecompile)
{
  return GEAcompile (pattern, size, RE_SYNTAX_POSIX_EGREP);
}
#endif /* !EGREP_PROGRAM */

EXECUTE_FCT(EGexecute)
{
  char const *buflim, *beg, *end, *match, *best_match, *mb_start;
  char eol = eolbyte;
  int backref, start, len, best_len;
  struct kwsmatch kwsm;
  size_t i, ret_val;
#ifdef MBS_SUPPORT
  if (MB_CUR_MAX > 1)
    {
      if (match_icase)
        {
          /* mbtolower adds a NUL byte at the end.  That will provide
	     space for the sentinel byte dfaexec may add.  */
          char *case_buf = mbtolower (buf, &size);
	  if (start_ptr)
	    start_ptr = case_buf + (start_ptr - buf);
          buf = case_buf;
        }
    }
#endif /* MBS_SUPPORT */

  mb_start = buf;
  buflim = buf + size;

  for (beg = end = buf; end < buflim; beg = end)
    {
      if (!start_ptr)
	{
	  /* We don't care about an exact match.  */
	  if (kwset)
	    {
	      /* Find a possible match using the KWset matcher. */
	      size_t offset = kwsexec (kwset, beg, buflim - beg, &kwsm);
	      if (offset == (size_t) -1)
		goto failure;
	      beg += offset;
	      /* Narrow down to the line containing the candidate, and
		 run it through DFA. */
	      if ((end = memchr(beg, eol, buflim - beg)) != NULL)
	        end++;
              else
                end = buflim;
	      match = beg;
	      while (beg > buf && beg[-1] != eol)
		--beg;
	      if (kwsm.index < kwset_exact_matches)
                {
#ifdef MBS_SUPPORT
                  if (mb_start < beg)
                    mb_start = beg;
                  if (MB_CUR_MAX == 1 || !is_mb_middle (&mb_start, match, buflim))
#endif
                    goto success;
                }
	      if (dfaexec (&dfa, beg, (char *) end, 0, NULL, &backref) == NULL)
		continue;
	    }
	  else
	    {
	      /* No good fixed strings; start with DFA. */
	      char const *next_beg = dfaexec (&dfa, beg, (char *) buflim,
					      0, NULL, &backref);
	      if (next_beg == NULL)
		break;
	      /* Narrow down to the line we've found. */
	      beg = next_beg;
	      if ((end = memchr(beg, eol, buflim - beg)) != NULL)
	        end++;
              else
                end = buflim;
	      while (beg > buf && beg[-1] != eol)
		--beg;
	    }
	  /* Successful, no backreferences encountered! */
	  if (!backref)
	    goto success;
	}
      else
	{
	  /* We are looking for the leftmost (then longest) exact match.
	     We will go through the outer loop only once.  */
	  beg = start_ptr;
	  end = buflim;
	}

      /* If we've made it to this point, this means DFA has seen
	 a probable match, and we need to run it through Regex. */
      best_match = end;
      best_len = 0;
      for (i = 0; i < pcount; i++)
	{
	  patterns[i].regexbuf.not_eol = 0;
	  if (0 <= (start = re_search (&(patterns[i].regexbuf),
				       buf, end - buf - 1,
				       beg - buf, end - beg - 1,
				       &(patterns[i].regs))))
	    {
	      len = patterns[i].regs.end[0] - start;
	      match = buf + start;
	      if (match > best_match)
		continue;
	      if (start_ptr && !match_words)
		goto assess_pattern_match;
	      if ((!match_lines && !match_words)
		  || (match_lines && len == end - beg - 1))
		{
		  match = beg;
		  len = end - beg;
		  goto assess_pattern_match;
		}
	      /* If -w, check if the match aligns with word boundaries.
		 We do this iteratively because:
		 (a) the line may contain more than one occurence of the
		 pattern, and
		 (b) Several alternatives in the pattern might be valid at a
		 given point, and we may need to consider a shorter one to
		 find a word boundary.  */
	      if (match_words)
		while (match <= best_match)
		  {
		    if ((match == buf || !WCHAR ((unsigned char) match[-1]))
			&& (len == end - beg - 1
			    || !WCHAR ((unsigned char) match[len])))
		      goto assess_pattern_match;
		    if (len > 0)
		      {
			/* Try a shorter length anchored at the same place. */
			--len;
			patterns[i].regexbuf.not_eol = 1;
			len = re_match (&(patterns[i].regexbuf),
					buf, match + len - beg, match - buf,
					&(patterns[i].regs));
		      }
		    if (len <= 0)
		      {
			/* Try looking further on. */
			if (match == end - 1)
			  break;
			match++;
			patterns[i].regexbuf.not_eol = 0;
			start = re_search (&(patterns[i].regexbuf),
					   buf, end - buf - 1,
					   match - buf, end - match - 1,
					   &(patterns[i].regs));
			if (start < 0)
			  break;
			len = patterns[i].regs.end[0] - start;
			match = buf + start;
		      }
		  } /* while (match <= best_match) */
	      continue;
	    assess_pattern_match:
	      if (!start_ptr)
		{
		  /* Good enough for a non-exact match.
		     No need to look at further patterns, if any.  */
		  beg = match;
		  goto success_in_len;
		}
	      if (match < best_match || (match == best_match && len > best_len))
		{
		  /* Best exact match:  leftmost, then longest.  */
		  best_match = match;
		  best_len = len;
		}
	    } /* if re_search >= 0 */
	} /* for Regex patterns.  */
	if (best_match < end)
	  {
	    /* We have found an exact match.  We were just
	       waiting for the best one (leftmost then longest).  */
	    beg = best_match;
	    len = best_len;
	    goto success_in_len;
	  }
    } /* for (beg = end ..) */

 failure:
  ret_val = -1;
  goto out;

 success:
  len = end - beg;
 success_in_len:
  *match_size = len;
  ret_val = beg - buf;
 out:
  return ret_val;
}
#endif /* defined(GREP_PROGRAM) || defined(EGREP_PROGRAM) */

#if defined(GREP_PROGRAM) || defined(FGREP_PROGRAM)
COMPILE_FCT(Fcompile)
{
  char const *beg, *end, *lim, *err, *pat;
  size_t psize;

  kwsinit ();
  psize = size;
  if (match_icase && MB_CUR_MAX > 1)
    pat = mbtolower (pattern, &psize);
  else
    pat = pattern;

  beg = pat;
  do
    {
      for (lim = beg;; ++lim)
	{
	  end = lim;
	  if (lim >= pat + psize)
	    break;
	 if (*lim == '\n')
	   {
	     lim++;
	     break;
	   }
#if HAVE_DOS_FILE_CONTENTS
	 if (*lim == '\r' && lim + 1 < pat + psize && lim[1] == '\n')
	   {
	     lim += 2;
	     break;
	   }
#endif
	}

      if ((err = kwsincr (kwset, beg, end - beg)) != NULL)
	error (EXIT_TROUBLE, 0, "%s", err);
      beg = lim;
    }
  while (beg < pat + psize);

  if ((err = kwsprep (kwset)) != NULL)
    error (EXIT_TROUBLE, 0, "%s", err);
}

EXECUTE_FCT(Fexecute)
{
  char const *beg, *try, *end, *mb_start;
  size_t len;
  char eol = eolbyte;
  struct kwsmatch kwsmatch;
  size_t ret_val;
#ifdef MBS_SUPPORT
  if (MB_CUR_MAX > 1)
    {
      if (match_icase)
        {
          char *case_buf = mbtolower (buf, &size);
	  if (start_ptr)
	    start_ptr = case_buf + (start_ptr - buf);
          buf = case_buf;
        }
    }
#endif /* MBS_SUPPORT */

  for (mb_start = beg = start_ptr ? start_ptr : buf; beg <= buf + size; beg++)
    {
      size_t offset = kwsexec (kwset, beg, buf + size - beg, &kwsmatch);
      if (offset == (size_t) -1)
	goto failure;
#ifdef MBS_SUPPORT
      if (MB_CUR_MAX > 1 && is_mb_middle (&mb_start, beg + offset, buf + size))
        {
          beg = mb_start - 1;
          continue; /* It is a part of multibyte character.  */
        }
#endif /* MBS_SUPPORT */
      beg += offset;
      len = kwsmatch.size[0];
      if (start_ptr && !match_words)
	goto success_in_beg_and_len;
      if (match_lines)
	{
	  if (beg > buf && beg[-1] != eol)
	    continue;
	  if (beg + len < buf + size && beg[len] != eol)
	    continue;
	  goto success;
	}
      else if (match_words)
	for (try = beg; len; )
	  {
	    if (try > buf && WCHAR((unsigned char) try[-1]))
	      break;
	    if (try + len < buf + size && WCHAR((unsigned char) try[len]))
	      {
		offset = kwsexec (kwset, beg, --len, &kwsmatch);
		if (offset == (size_t) -1)
		  break;
		try = beg + offset;
		len = kwsmatch.size[0];
	      }
	    else if (!start_ptr)
	      goto success;
	    else
	      goto success_in_beg_and_len;
	  } /* for (try) */
      else
	goto success;
    } /* for (beg in buf) */

 failure:
  ret_val = -1;
  goto out;

 success:
  if ((end = memchr (beg + len, eol, (buf + size) - (beg + len))) != NULL)
    end++;
  else
    end = buf + size;
  while (buf < beg && beg[-1] != eol)
    --beg;
  len = end - beg;
 success_in_beg_and_len:
  *match_size = len;
  ret_val = beg - buf;
 out:
  return ret_val;
}
#endif /* defined(GREP_PROGRAM) || defined(FGREP_PROGRAM) */

#ifdef GREP_PROGRAM
#if HAVE_LIBPCRE
/* Compiled internal form of a Perl regular expression.  */
static pcre *cre;

/* Additional information about the pattern.  */
static pcre_extra *extra;
#endif

COMPILE_FCT(Pcompile)
{
#if !HAVE_LIBPCRE
  error (EXIT_TROUBLE, 0, "%s",
	 _("support for the -P option is not compiled into "
	   "this --disable-perl-regexp binary"));
#else
  int e;
  char const *ep;
  char *re = xmalloc (4 * size + 7);
  int flags = PCRE_MULTILINE | (match_icase ? PCRE_CASELESS : 0);
  char const *patlim = pattern + size;
  char *n = re;
  char const *p;
  char const *pnul;

  /* FIXME: Remove these restrictions.  */
  if (memchr(pattern, '\n', size))
    error (EXIT_TROUBLE, 0, _("the -P option only supports a single pattern"));

  *n = '\0';
  if (match_lines)
    strcpy (n, "^(");
  if (match_words)
    strcpy (n, "\\b(");
  n += strlen (n);

  /* The PCRE interface doesn't allow NUL bytes in the pattern, so
     replace each NUL byte in the pattern with the four characters
     "\000", removing a preceding backslash if there are an odd
     number of backslashes before the NUL.

     FIXME: This method does not work with some multibyte character
     encodings, notably Shift-JIS, where a multibyte character can end
     in a backslash byte.  */
  for (p = pattern; (pnul = memchr (p, '\0', patlim - p)); p = pnul + 1)
    {
      memcpy (n, p, pnul - p);
      n += pnul - p;
      for (p = pnul; pattern < p && p[-1] == '\\'; p--)
	continue;
      n -= (pnul - p) & 1;
      strcpy (n, "\\000");
      n += 4;
    }

  memcpy (n, p, patlim - p);
  n += patlim - p;
  *n = '\0';
  if (match_words)
    strcpy (n, ")\\b");
  if (match_lines)
    strcpy (n, ")$");

  cre = pcre_compile (re, flags, &ep, &e, pcre_maketables ());
  if (!cre)
    error (EXIT_TROUBLE, 0, "%s", ep);

  extra = pcre_study (cre, 0, &ep);
  if (ep)
    error (EXIT_TROUBLE, 0, "%s", ep);

  free (re);
#endif
}

EXECUTE_FCT(Pexecute)
{
#if !HAVE_LIBPCRE
  abort ();
  return -1;
#else
  /* This array must have at least two elements; everything after that
     is just for performance improvement in pcre_exec.  */
  int sub[300];

  const char *line_buf, *line_end, *line_next;
  int e = PCRE_ERROR_NOMATCH;
  ptrdiff_t start_ofs = start_ptr ? start_ptr - buf : 0;

  /* PCRE can't limit the matching to single lines, therefore we have to
     match each line in the buffer separately.  */
  for (line_next = buf;
       e == PCRE_ERROR_NOMATCH && line_next < buf + size;
       start_ofs -= line_next - line_buf)
    {
      line_buf = line_next;
      line_end = memchr (line_buf, eolbyte, (buf + size) - line_buf);
      if (line_end == NULL)
        line_next = line_end = buf + size;
      else
        line_next = line_end + 1;

      if (start_ptr && start_ptr >= line_end)
        continue;

      e = pcre_exec (cre, extra, line_buf, line_end - line_buf,
                     start_ofs < 0 ? 0 : start_ofs, 0,
                     sub, sizeof sub / sizeof *sub);
    }

  if (e <= 0)
    {
      switch (e)
	{
	case PCRE_ERROR_NOMATCH:
	  return -1;

	case PCRE_ERROR_NOMEMORY:
	  error (EXIT_TROUBLE, 0, _("memory exhausted"));

	default:
	  abort ();
	}
    }
  else
    {
      /* Narrow down to the line we've found.  */
      char const *beg = line_buf + sub[0];
      char const *end = line_buf + sub[1];
      char const *buflim = buf + size;
      char eol = eolbyte;
      if (!start_ptr)
	{
	  /* FIXME: The case when '\n' is not found indicates a bug:
	     Since grep is line oriented, the match should never contain
	     a newline, so there _must_ be a newline following.
	   */
	  if (!(end = memchr (end, eol, buflim - end)))
	    end = buflim;
	  else
	    end++;
	  while (buf < beg && beg[-1] != eol)
	    --beg;
	}

      *match_size = end - beg;
      return beg - buf;
    }
#endif
}

struct matcher const matchers[] = {
  { "default", Gcompile, EGexecute },
  { "grep",    Gcompile, EGexecute },
  { "egrep",   Ecompile, EGexecute },
  { "awk",     Acompile, EGexecute },
  { "fgrep",   Fcompile, Fexecute },
  { "perl",    Pcompile, Pexecute },
  { "", 0, 0 },
};
#endif /* GREP_PROGRAM */

Spawn 1 instances, now Total 2
Counter: 3
Batcher Size:2
Preprocess the following candidate with CondTester:
Priority 20000
At location src/search.c:72
--Src File: src/search.c
Fragment 0:
if ((!kwset) || (__abst_hole(kwset, i, match_icase)))
    xalloc_die();


CondTester, a patch instance with id 2:
//src_file:src/search.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
/* search.c - searching subroutines using dfa, kwset and regex for grep.
   Copyright 1992, 1998, 2000, 2007, 2009-2010 Free Software Foundation, Inc.

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 3, or (at your option)
   any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program; if not, write to the Free Software
   Foundation, Inc., 51 Franklin Street - Fifth Floor, Boston, MA
   02110-1301, USA.  */

/* Written August 1992 by Mike Haertel. */

#include <config.h>

#include <sys/types.h>

#include "mbsupport.h"
#ifdef MBS_SUPPORT
/* We can handle multibyte strings. */
# include <wchar.h>
# include <wctype.h>
#endif

#include "system.h"
#include "grep.h"
#ifndef FGREP_PROGRAM
# include <regex.h>
# include "dfa.h"
#endif
#include "kwset.h"
#include "error.h"
#include "xalloc.h"
#ifdef HAVE_LIBPCRE
# include <pcre.h>
#endif

#define NCHAR (UCHAR_MAX + 1)

/* For -w, we also consider _ to be word constituent.  */
#define WCHAR(C) (ISALNUM(C) || (C) == '_')

/* KWset compiled pattern.  For Ecompile and Gcompile, we compile
   a list of strings, at least one of which is known to occur in
   any string matching the regexp. */
static kwset_t kwset;

static void
kwsinit (void)
{
  static char trans[NCHAR];
  int i;

  if (match_icase && MB_CUR_MAX == 1)
    {
      for (i = 0; i < NCHAR; ++i)
        trans[i] = TOLOWER (i);

      kwset = kwsalloc (trans);
    }
  else
    kwset = kwsalloc (NULL);

  
//Patch 0:
if ((!kwset) || (__is_neg(3, &(kwset), sizeof (kwset), &(i), sizeof (i), &(match_icase), sizeof (match_icase))))
    xalloc_die();

//CodeSeg 1:
}

#ifdef MBS_SUPPORT
/* Convert the *N-byte string, BEG, to lowercase, and write the
   NUL-terminated result into malloc'd storage.  Upon success, set *N
   to the length (in bytes) of the resulting string (not including the
   trailing NUL byte), and return a pointer to the lowercase string.
   Upon memory allocation failure, this function exits.

   Note that while this function returns a pointer to malloc'd storage,
   the caller must not free it, since this function retains a pointer
   to the buffer and reuses it on any subsequent call.  As a consequence,
   this function is not thread-safe.  */
static char *
mbtolower (const char *beg, size_t *n)
{
  static char *out;
  static size_t outalloc;
  size_t outlen, mb_cur_max;
  mbstate_t is, os;
  const char *end;
  char *p;

  if (*n > outalloc)
    {
      out = xrealloc (out, *n);
      outalloc = *n;
    }

  memset (&is, 0, sizeof (is));
  memset (&os, 0, sizeof (os));
  end = beg + *n;

  mb_cur_max = MB_CUR_MAX;
  p = out;
  outlen = 0;
  while (beg < end)
    {
      wchar_t wc;
      size_t mbclen = mbrtowc(&wc, beg, end - beg, &is);
      if (outlen + mb_cur_max >= outalloc)
        {
          out = x2nrealloc (out, &outalloc, 1);
          p = out + outlen;
        }

      if (mbclen == (size_t) -1 || mbclen == (size_t) -2 || mbclen == 0)
        {
          /* An invalid sequence, or a truncated multi-octet character.
             We treat it as a single-octet character.  */
          *p++ = *beg++;
          outlen++;
          memset (&is, 0, sizeof (is));
          memset (&os, 0, sizeof (os));
        }
      else
        {
          beg += mbclen;
          mbclen = wcrtomb (p, towlower ((wint_t) wc), &os);
          p += mbclen;
          outlen += mbclen;
        }
    }

  *n = p - out;
  *p++ = 0;
  return out;
}
#endif


#ifndef FGREP_PROGRAM
/* DFA compiled regexp. */
static struct dfa dfa;

/* The Regex compiled patterns.  */
static struct patterns
{
  /* Regex compiled regexp. */
  struct re_pattern_buffer regexbuf;
  struct re_registers regs; /* This is here on account of a BRAIN-DEAD
			       Q@#%!# library interface in regex.c.  */
} patterns0;

struct patterns *patterns;
size_t pcount;

void
dfaerror (char const *mesg)
{
  error (EXIT_TROUBLE, 0, "%s", mesg);
}

/* Number of compiled fixed strings known to exactly match the regexp.
   If kwsexec returns < kwset_exact_matches, then we don't need to
   call the regexp matcher at all. */
static int kwset_exact_matches;

static char const *
kwsincr_case (const char *must)
{
  const char *buf;
  size_t n;

  n = strlen (must);
#ifdef MBS_SUPPORT
  if (match_icase && MB_CUR_MAX > 1)
    buf = mbtolower (must, &n);
  else
#endif
    buf = must;
  return kwsincr (kwset, buf, n);
}

/* If the DFA turns out to have some set of fixed strings one of
   which must occur in the match, then we build a kwset matcher
   to find those strings, and thus quickly filter out impossible
   matches. */
static void
kwsmusts (void)
{
  struct dfamust const *dm;
  char const *err;

  if (dfa.musts)
    {
      kwsinit ();
      /* First, we compile in the substrings known to be exact
	 matches.  The kwset matcher will return the index
	 of the matching string that it chooses. */
      for (dm = dfa.musts; dm; dm = dm->next)
	{
	  if (!dm->exact)
	    continue;
	  ++kwset_exact_matches;
	  if ((err = kwsincr_case (dm->must)) != NULL)
	    error (EXIT_TROUBLE, 0, "%s", err);
	}
      /* Now, we compile the substrings that will require
	 the use of the regexp matcher.  */
      for (dm = dfa.musts; dm; dm = dm->next)
	{
	  if (dm->exact)
	    continue;
	  if ((err = kwsincr_case (dm->must)) != NULL)
	    error (EXIT_TROUBLE, 0, "%s", err);
	}
      if ((err = kwsprep (kwset)) != NULL)
	error (EXIT_TROUBLE, 0, "%s", err);
    }
}
#endif /* !FGREP_PROGRAM */

#ifdef MBS_SUPPORT

static bool
is_mb_middle(const char **good, const char *buf, const char *end)
{
  const char *p = *good;
  const char *prev = p;
  mbstate_t cur_state;

  /* TODO: can be optimized for UTF-8.  */
  memset(&cur_state, 0, sizeof(mbstate_t));
  while (p < buf)
    {
      size_t mbclen = mbrlen(p, end - p, &cur_state);

      /* Store the beginning of the previous complete multibyte character.  */
      if (mbclen != (size_t) -2)
        prev = p;

      if (mbclen == (size_t) -1 || mbclen == (size_t) -2 || mbclen == 0)
	{
	  /* An invalid sequence, or a truncated multibyte character.
	     We treat it as a single byte character.  */
	  mbclen = 1;
	}
      p += mbclen;
    }

  *good = prev;
  return p > buf;
}
#endif /* MBS_SUPPORT */

#if defined(GREP_PROGRAM) || defined(EGREP_PROGRAM)
#ifdef EGREP_PROGRAM
COMPILE_FCT(Ecompile)
{
  reg_syntax_t syntax_bits = RE_SYNTAX_POSIX_EGREP;
#else
/* No __VA_ARGS__ in C89.  So we have to do it this way.  */
static COMPILE_RET
GEAcompile (char const *pattern, size_t size, reg_syntax_t syntax_bits)
{
#endif /* EGREP_PROGRAM */
  const char *err;
  const char *p, *sep;
  size_t total = size;
  char *motif;

  if (match_icase)
    syntax_bits |= RE_ICASE;
  re_set_syntax (syntax_bits);
  dfasyntax (syntax_bits, match_icase, eolbyte);

  /* For GNU regex compiler we have to pass the patterns separately to detect
     errors like "[\nallo\n]\n".  The patterns here are "[", "allo" and "]"
     GNU regex should have raise a syntax error.  The same for backref, where
     the backref should have been local to each pattern.  */
  p = pattern;
  do
    {
      size_t len;
      sep = memchr (p, '\n', total);
      if (sep)
	{
	  len = sep - p;
	  sep++;
	  total -= (len + 1);
	}
      else
	{
	  len = total;
	  total = 0;
	}

      patterns = realloc (patterns, (pcount + 1) * sizeof (*patterns));
      if (patterns == NULL)
	error (EXIT_TROUBLE, errno, _("memory exhausted"));
      patterns[pcount] = patterns0;

      if ((err = re_compile_pattern (p, len,
				    &(patterns[pcount].regexbuf))) != NULL)
	error (EXIT_TROUBLE, 0, "%s", err);
      pcount++;

      p = sep;
    } while (sep && total != 0);

  /* In the match_words and match_lines cases, we use a different pattern
     for the DFA matcher that will quickly throw out cases that won't work.
     Then if DFA succeeds we do some hairy stuff using the regex matcher
     to decide whether the match should really count. */
  if (match_words || match_lines)
    {
      static char const line_beg_no_bk[] = "^(";
      static char const line_end_no_bk[] = ")$";
      static char const word_beg_no_bk[] = "(^|[^[:alnum:]_])(";
      static char const word_end_no_bk[] = ")([^[:alnum:]_]|$)";
#ifdef EGREP_PROGRAM
# define IF_BK(x, y) (y)
      char *n = xmalloc (sizeof word_beg_no_bk - 1 + size + sizeof word_end_no_bk);
#else
      static char const line_beg_bk[] = "^\\(";
      static char const line_end_bk[] = "\\)$";
      static char const word_beg_bk[] = "\\(^\\|[^[:alnum:]_]\\)\\(";
      static char const word_end_bk[] = "\\)\\([^[:alnum:]_]\\|$\\)";
      int bk = !(syntax_bits & RE_NO_BK_PARENS);
# define IF_BK(x, y) ((bk) ? (x) : (y))
      char *n = xmalloc (sizeof word_beg_bk - 1 + size + sizeof word_end_bk);
#endif /* EGREP_PROGRAM */

      strcpy (n, match_lines ? IF_BK(line_beg_bk, line_beg_no_bk)
			     : IF_BK(word_beg_bk, word_beg_no_bk));
      total = strlen(n);
      memcpy (n + total, pattern, size);
      total += size;
      strcpy (n + total, match_lines ? IF_BK(line_end_bk, line_end_no_bk)
				     : IF_BK(word_end_bk, word_end_no_bk));
      total += strlen (n + total);
      pattern = motif = n;
      size = total;
    }
  else
    motif = NULL;

  dfacomp (pattern, size, &dfa, 1);
  kwsmusts ();

  free(motif);
}

#ifndef EGREP_PROGRAM
COMPILE_FCT(Gcompile)
{
  return GEAcompile (pattern, size,
		     RE_SYNTAX_GREP | RE_HAT_LISTS_NOT_NEWLINE);
}

COMPILE_FCT(Acompile)
{
  return GEAcompile (pattern, size, RE_SYNTAX_AWK);
}

COMPILE_FCT(Ecompile)
{
  return GEAcompile (pattern, size, RE_SYNTAX_POSIX_EGREP);
}
#endif /* !EGREP_PROGRAM */

EXECUTE_FCT(EGexecute)
{
  char const *buflim, *beg, *end, *match, *best_match, *mb_start;
  char eol = eolbyte;
  int backref, start, len, best_len;
  struct kwsmatch kwsm;
  size_t i, ret_val;
#ifdef MBS_SUPPORT
  if (MB_CUR_MAX > 1)
    {
      if (match_icase)
        {
          /* mbtolower adds a NUL byte at the end.  That will provide
	     space for the sentinel byte dfaexec may add.  */
          char *case_buf = mbtolower (buf, &size);
	  if (start_ptr)
	    start_ptr = case_buf + (start_ptr - buf);
          buf = case_buf;
        }
    }
#endif /* MBS_SUPPORT */

  mb_start = buf;
  buflim = buf + size;

  for (beg = end = buf; end < buflim; beg = end)
    {
      if (!start_ptr)
	{
	  /* We don't care about an exact match.  */
	  if (kwset)
	    {
	      /* Find a possible match using the KWset matcher. */
	      size_t offset = kwsexec (kwset, beg, buflim - beg, &kwsm);
	      if (offset == (size_t) -1)
		goto failure;
	      beg += offset;
	      /* Narrow down to the line containing the candidate, and
		 run it through DFA. */
	      if ((end = memchr(beg, eol, buflim - beg)) != NULL)
	        end++;
              else
                end = buflim;
	      match = beg;
	      while (beg > buf && beg[-1] != eol)
		--beg;
	      if (kwsm.index < kwset_exact_matches)
                {
#ifdef MBS_SUPPORT
                  if (mb_start < beg)
                    mb_start = beg;
                  if (MB_CUR_MAX == 1 || !is_mb_middle (&mb_start, match, buflim))
#endif
                    goto success;
                }
	      if (dfaexec (&dfa, beg, (char *) end, 0, NULL, &backref) == NULL)
		continue;
	    }
	  else
	    {
	      /* No good fixed strings; start with DFA. */
	      char const *next_beg = dfaexec (&dfa, beg, (char *) buflim,
					      0, NULL, &backref);
	      if (next_beg == NULL)
		break;
	      /* Narrow down to the line we've found. */
	      beg = next_beg;
	      if ((end = memchr(beg, eol, buflim - beg)) != NULL)
	        end++;
              else
                end = buflim;
	      while (beg > buf && beg[-1] != eol)
		--beg;
	    }
	  /* Successful, no backreferences encountered! */
	  if (!backref)
	    goto success;
	}
      else
	{
	  /* We are looking for the leftmost (then longest) exact match.
	     We will go through the outer loop only once.  */
	  beg = start_ptr;
	  end = buflim;
	}

      /* If we've made it to this point, this means DFA has seen
	 a probable match, and we need to run it through Regex. */
      best_match = end;
      best_len = 0;
      for (i = 0; i < pcount; i++)
	{
	  patterns[i].regexbuf.not_eol = 0;
	  if (0 <= (start = re_search (&(patterns[i].regexbuf),
				       buf, end - buf - 1,
				       beg - buf, end - beg - 1,
				       &(patterns[i].regs))))
	    {
	      len = patterns[i].regs.end[0] - start;
	      match = buf + start;
	      if (match > best_match)
		continue;
	      if (start_ptr && !match_words)
		goto assess_pattern_match;
	      if ((!match_lines && !match_words)
		  || (match_lines && len == end - beg - 1))
		{
		  match = beg;
		  len = end - beg;
		  goto assess_pattern_match;
		}
	      /* If -w, check if the match aligns with word boundaries.
		 We do this iteratively because:
		 (a) the line may contain more than one occurence of the
		 pattern, and
		 (b) Several alternatives in the pattern might be valid at a
		 given point, and we may need to consider a shorter one to
		 find a word boundary.  */
	      if (match_words)
		while (match <= best_match)
		  {
		    if ((match == buf || !WCHAR ((unsigned char) match[-1]))
			&& (len == end - beg - 1
			    || !WCHAR ((unsigned char) match[len])))
		      goto assess_pattern_match;
		    if (len > 0)
		      {
			/* Try a shorter length anchored at the same place. */
			--len;
			patterns[i].regexbuf.not_eol = 1;
			len = re_match (&(patterns[i].regexbuf),
					buf, match + len - beg, match - buf,
					&(patterns[i].regs));
		      }
		    if (len <= 0)
		      {
			/* Try looking further on. */
			if (match == end - 1)
			  break;
			match++;
			patterns[i].regexbuf.not_eol = 0;
			start = re_search (&(patterns[i].regexbuf),
					   buf, end - buf - 1,
					   match - buf, end - match - 1,
					   &(patterns[i].regs));
			if (start < 0)
			  break;
			len = patterns[i].regs.end[0] - start;
			match = buf + start;
		      }
		  } /* while (match <= best_match) */
	      continue;
	    assess_pattern_match:
	      if (!start_ptr)
		{
		  /* Good enough for a non-exact match.
		     No need to look at further patterns, if any.  */
		  beg = match;
		  goto success_in_len;
		}
	      if (match < best_match || (match == best_match && len > best_len))
		{
		  /* Best exact match:  leftmost, then longest.  */
		  best_match = match;
		  best_len = len;
		}
	    } /* if re_search >= 0 */
	} /* for Regex patterns.  */
	if (best_match < end)
	  {
	    /* We have found an exact match.  We were just
	       waiting for the best one (leftmost then longest).  */
	    beg = best_match;
	    len = best_len;
	    goto success_in_len;
	  }
    } /* for (beg = end ..) */

 failure:
  ret_val = -1;
  goto out;

 success:
  len = end - beg;
 success_in_len:
  *match_size = len;
  ret_val = beg - buf;
 out:
  return ret_val;
}
#endif /* defined(GREP_PROGRAM) || defined(EGREP_PROGRAM) */

#if defined(GREP_PROGRAM) || defined(FGREP_PROGRAM)
COMPILE_FCT(Fcompile)
{
  char const *beg, *end, *lim, *err, *pat;
  size_t psize;

  kwsinit ();
  psize = size;
  if (match_icase && MB_CUR_MAX > 1)
    pat = mbtolower (pattern, &psize);
  else
    pat = pattern;

  beg = pat;
  do
    {
      for (lim = beg;; ++lim)
	{
	  end = lim;
	  if (lim >= pat + psize)
	    break;
	 if (*lim == '\n')
	   {
	     lim++;
	     break;
	   }
#if HAVE_DOS_FILE_CONTENTS
	 if (*lim == '\r' && lim + 1 < pat + psize && lim[1] == '\n')
	   {
	     lim += 2;
	     break;
	   }
#endif
	}

      if ((err = kwsincr (kwset, beg, end - beg)) != NULL)
	error (EXIT_TROUBLE, 0, "%s", err);
      beg = lim;
    }
  while (beg < pat + psize);

  if ((err = kwsprep (kwset)) != NULL)
    error (EXIT_TROUBLE, 0, "%s", err);
}

EXECUTE_FCT(Fexecute)
{
  char const *beg, *try, *end, *mb_start;
  size_t len;
  char eol = eolbyte;
  struct kwsmatch kwsmatch;
  size_t ret_val;
#ifdef MBS_SUPPORT
  if (MB_CUR_MAX > 1)
    {
      if (match_icase)
        {
          char *case_buf = mbtolower (buf, &size);
	  if (start_ptr)
	    start_ptr = case_buf + (start_ptr - buf);
          buf = case_buf;
        }
    }
#endif /* MBS_SUPPORT */

  for (mb_start = beg = start_ptr ? start_ptr : buf; beg <= buf + size; beg++)
    {
      size_t offset = kwsexec (kwset, beg, buf + size - beg, &kwsmatch);
      if (offset == (size_t) -1)
	goto failure;
#ifdef MBS_SUPPORT
      if (MB_CUR_MAX > 1 && is_mb_middle (&mb_start, beg + offset, buf + size))
        {
          beg = mb_start - 1;
          continue; /* It is a part of multibyte character.  */
        }
#endif /* MBS_SUPPORT */
      beg += offset;
      len = kwsmatch.size[0];
      if (start_ptr && !match_words)
	goto success_in_beg_and_len;
      if (match_lines)
	{
	  if (beg > buf && beg[-1] != eol)
	    continue;
	  if (beg + len < buf + size && beg[len] != eol)
	    continue;
	  goto success;
	}
      else if (match_words)
	for (try = beg; len; )
	  {
	    if (try > buf && WCHAR((unsigned char) try[-1]))
	      break;
	    if (try + len < buf + size && WCHAR((unsigned char) try[len]))
	      {
		offset = kwsexec (kwset, beg, --len, &kwsmatch);
		if (offset == (size_t) -1)
		  break;
		try = beg + offset;
		len = kwsmatch.size[0];
	      }
	    else if (!start_ptr)
	      goto success;
	    else
	      goto success_in_beg_and_len;
	  } /* for (try) */
      else
	goto success;
    } /* for (beg in buf) */

 failure:
  ret_val = -1;
  goto out;

 success:
  if ((end = memchr (beg + len, eol, (buf + size) - (beg + len))) != NULL)
    end++;
  else
    end = buf + size;
  while (buf < beg && beg[-1] != eol)
    --beg;
  len = end - beg;
 success_in_beg_and_len:
  *match_size = len;
  ret_val = beg - buf;
 out:
  return ret_val;
}
#endif /* defined(GREP_PROGRAM) || defined(FGREP_PROGRAM) */

#ifdef GREP_PROGRAM
#if HAVE_LIBPCRE
/* Compiled internal form of a Perl regular expression.  */
static pcre *cre;

/* Additional information about the pattern.  */
static pcre_extra *extra;
#endif

COMPILE_FCT(Pcompile)
{
#if !HAVE_LIBPCRE
  error (EXIT_TROUBLE, 0, "%s",
	 _("support for the -P option is not compiled into "
	   "this --disable-perl-regexp binary"));
#else
  int e;
  char const *ep;
  char *re = xmalloc (4 * size + 7);
  int flags = PCRE_MULTILINE | (match_icase ? PCRE_CASELESS : 0);
  char const *patlim = pattern + size;
  char *n = re;
  char const *p;
  char const *pnul;

  /* FIXME: Remove these restrictions.  */
  if (memchr(pattern, '\n', size))
    error (EXIT_TROUBLE, 0, _("the -P option only supports a single pattern"));

  *n = '\0';
  if (match_lines)
    strcpy (n, "^(");
  if (match_words)
    strcpy (n, "\\b(");
  n += strlen (n);

  /* The PCRE interface doesn't allow NUL bytes in the pattern, so
     replace each NUL byte in the pattern with the four characters
     "\000", removing a preceding backslash if there are an odd
     number of backslashes before the NUL.

     FIXME: This method does not work with some multibyte character
     encodings, notably Shift-JIS, where a multibyte character can end
     in a backslash byte.  */
  for (p = pattern; (pnul = memchr (p, '\0', patlim - p)); p = pnul + 1)
    {
      memcpy (n, p, pnul - p);
      n += pnul - p;
      for (p = pnul; pattern < p && p[-1] == '\\'; p--)
	continue;
      n -= (pnul - p) & 1;
      strcpy (n, "\\000");
      n += 4;
    }

  memcpy (n, p, patlim - p);
  n += patlim - p;
  *n = '\0';
  if (match_words)
    strcpy (n, ")\\b");
  if (match_lines)
    strcpy (n, ")$");

  cre = pcre_compile (re, flags, &ep, &e, pcre_maketables ());
  if (!cre)
    error (EXIT_TROUBLE, 0, "%s", ep);

  extra = pcre_study (cre, 0, &ep);
  if (ep)
    error (EXIT_TROUBLE, 0, "%s", ep);

  free (re);
#endif
}

EXECUTE_FCT(Pexecute)
{
#if !HAVE_LIBPCRE
  abort ();
  return -1;
#else
  /* This array must have at least two elements; everything after that
     is just for performance improvement in pcre_exec.  */
  int sub[300];

  const char *line_buf, *line_end, *line_next;
  int e = PCRE_ERROR_NOMATCH;
  ptrdiff_t start_ofs = start_ptr ? start_ptr - buf : 0;

  /* PCRE can't limit the matching to single lines, therefore we have to
     match each line in the buffer separately.  */
  for (line_next = buf;
       e == PCRE_ERROR_NOMATCH && line_next < buf + size;
       start_ofs -= line_next - line_buf)
    {
      line_buf = line_next;
      line_end = memchr (line_buf, eolbyte, (buf + size) - line_buf);
      if (line_end == NULL)
        line_next = line_end = buf + size;
      else
        line_next = line_end + 1;

      if (start_ptr && start_ptr >= line_end)
        continue;

      e = pcre_exec (cre, extra, line_buf, line_end - line_buf,
                     start_ofs < 0 ? 0 : start_ofs, 0,
                     sub, sizeof sub / sizeof *sub);
    }

  if (e <= 0)
    {
      switch (e)
	{
	case PCRE_ERROR_NOMATCH:
	  return -1;

	case PCRE_ERROR_NOMEMORY:
	  error (EXIT_TROUBLE, 0, _("memory exhausted"));

	default:
	  abort ();
	}
    }
  else
    {
      /* Narrow down to the line we've found.  */
      char const *beg = line_buf + sub[0];
      char const *end = line_buf + sub[1];
      char const *buflim = buf + size;
      char eol = eolbyte;
      if (!start_ptr)
	{
	  /* FIXME: The case when '\n' is not found indicates a bug:
	     Since grep is line oriented, the match should never contain
	     a newline, so there _must_ be a newline following.
	   */
	  if (!(end = memchr (end, eol, buflim - end)))
	    end = buflim;
	  else
	    end++;
	  while (buf < beg && beg[-1] != eol)
	    --beg;
	}

      *match_size = end - beg;
      return beg - buf;
    }
#endif
}

struct matcher const matchers[] = {
  { "default", Gcompile, EGexecute },
  { "grep",    Gcompile, EGexecute },
  { "egrep",   Ecompile, EGexecute },
  { "awk",     Acompile, EGexecute },
  { "fgrep",   Fcompile, Fexecute },
  { "perl",    Pcompile, Pexecute },
  { "", 0, 0 },
};
#endif /* GREP_PROGRAM */

Spawn 1 instances, now Total 3
Counter: 4
Batcher Size:3
Preprocess the following candidate with CondTester:
Priority 20000
At location src/search.c:576
--Src File: src/search.c
Fragment 0:
if ((match_icase && (__ctype_get_mb_cur_max()) > 1) && !(__abst_hole(match_icase, pattern, size, pat, psize, beg, lim, end, err, kwset)))
    pat = mbtolower(pattern, &psize);
else
    pat = pattern;


CondTester, a patch instance with id 3:
//src_file:src/search.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
/* search.c - searching subroutines using dfa, kwset and regex for grep.
   Copyright 1992, 1998, 2000, 2007, 2009-2010 Free Software Foundation, Inc.

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 3, or (at your option)
   any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program; if not, write to the Free Software
   Foundation, Inc., 51 Franklin Street - Fifth Floor, Boston, MA
   02110-1301, USA.  */

/* Written August 1992 by Mike Haertel. */

#include <config.h>

#include <sys/types.h>

#include "mbsupport.h"
#ifdef MBS_SUPPORT
/* We can handle multibyte strings. */
# include <wchar.h>
# include <wctype.h>
#endif

#include "system.h"
#include "grep.h"
#ifndef FGREP_PROGRAM
# include <regex.h>
# include "dfa.h"
#endif
#include "kwset.h"
#include "error.h"
#include "xalloc.h"
#ifdef HAVE_LIBPCRE
# include <pcre.h>
#endif

#define NCHAR (UCHAR_MAX + 1)

/* For -w, we also consider _ to be word constituent.  */
#define WCHAR(C) (ISALNUM(C) || (C) == '_')

/* KWset compiled pattern.  For Ecompile and Gcompile, we compile
   a list of strings, at least one of which is known to occur in
   any string matching the regexp. */
static kwset_t kwset;

static void
kwsinit (void)
{
  static char trans[NCHAR];
  int i;

  if (match_icase && MB_CUR_MAX == 1)
    {
      for (i = 0; i < NCHAR; ++i)
        trans[i] = TOLOWER (i);

      kwset = kwsalloc (trans);
    }
  else
    kwset = kwsalloc (NULL);

  if (!kwset)
    xalloc_die ();
}

#ifdef MBS_SUPPORT
/* Convert the *N-byte string, BEG, to lowercase, and write the
   NUL-terminated result into malloc'd storage.  Upon success, set *N
   to the length (in bytes) of the resulting string (not including the
   trailing NUL byte), and return a pointer to the lowercase string.
   Upon memory allocation failure, this function exits.

   Note that while this function returns a pointer to malloc'd storage,
   the caller must not free it, since this function retains a pointer
   to the buffer and reuses it on any subsequent call.  As a consequence,
   this function is not thread-safe.  */
static char *
mbtolower (const char *beg, size_t *n)
{
  static char *out;
  static size_t outalloc;
  size_t outlen, mb_cur_max;
  mbstate_t is, os;
  const char *end;
  char *p;

  if (*n > outalloc)
    {
      out = xrealloc (out, *n);
      outalloc = *n;
    }

  memset (&is, 0, sizeof (is));
  memset (&os, 0, sizeof (os));
  end = beg + *n;

  mb_cur_max = MB_CUR_MAX;
  p = out;
  outlen = 0;
  while (beg < end)
    {
      wchar_t wc;
      size_t mbclen = mbrtowc(&wc, beg, end - beg, &is);
      if (outlen + mb_cur_max >= outalloc)
        {
          out = x2nrealloc (out, &outalloc, 1);
          p = out + outlen;
        }

      if (mbclen == (size_t) -1 || mbclen == (size_t) -2 || mbclen == 0)
        {
          /* An invalid sequence, or a truncated multi-octet character.
             We treat it as a single-octet character.  */
          *p++ = *beg++;
          outlen++;
          memset (&is, 0, sizeof (is));
          memset (&os, 0, sizeof (os));
        }
      else
        {
          beg += mbclen;
          mbclen = wcrtomb (p, towlower ((wint_t) wc), &os);
          p += mbclen;
          outlen += mbclen;
        }
    }

  *n = p - out;
  *p++ = 0;
  return out;
}
#endif


#ifndef FGREP_PROGRAM
/* DFA compiled regexp. */
static struct dfa dfa;

/* The Regex compiled patterns.  */
static struct patterns
{
  /* Regex compiled regexp. */
  struct re_pattern_buffer regexbuf;
  struct re_registers regs; /* This is here on account of a BRAIN-DEAD
			       Q@#%!# library interface in regex.c.  */
} patterns0;

struct patterns *patterns;
size_t pcount;

void
dfaerror (char const *mesg)
{
  error (EXIT_TROUBLE, 0, "%s", mesg);
}

/* Number of compiled fixed strings known to exactly match the regexp.
   If kwsexec returns < kwset_exact_matches, then we don't need to
   call the regexp matcher at all. */
static int kwset_exact_matches;

static char const *
kwsincr_case (const char *must)
{
  const char *buf;
  size_t n;

  n = strlen (must);
#ifdef MBS_SUPPORT
  if (match_icase && MB_CUR_MAX > 1)
    buf = mbtolower (must, &n);
  else
#endif
    buf = must;
  return kwsincr (kwset, buf, n);
}

/* If the DFA turns out to have some set of fixed strings one of
   which must occur in the match, then we build a kwset matcher
   to find those strings, and thus quickly filter out impossible
   matches. */
static void
kwsmusts (void)
{
  struct dfamust const *dm;
  char const *err;

  if (dfa.musts)
    {
      kwsinit ();
      /* First, we compile in the substrings known to be exact
	 matches.  The kwset matcher will return the index
	 of the matching string that it chooses. */
      for (dm = dfa.musts; dm; dm = dm->next)
	{
	  if (!dm->exact)
	    continue;
	  ++kwset_exact_matches;
	  if ((err = kwsincr_case (dm->must)) != NULL)
	    error (EXIT_TROUBLE, 0, "%s", err);
	}
      /* Now, we compile the substrings that will require
	 the use of the regexp matcher.  */
      for (dm = dfa.musts; dm; dm = dm->next)
	{
	  if (dm->exact)
	    continue;
	  if ((err = kwsincr_case (dm->must)) != NULL)
	    error (EXIT_TROUBLE, 0, "%s", err);
	}
      if ((err = kwsprep (kwset)) != NULL)
	error (EXIT_TROUBLE, 0, "%s", err);
    }
}
#endif /* !FGREP_PROGRAM */

#ifdef MBS_SUPPORT

static bool
is_mb_middle(const char **good, const char *buf, const char *end)
{
  const char *p = *good;
  const char *prev = p;
  mbstate_t cur_state;

  /* TODO: can be optimized for UTF-8.  */
  memset(&cur_state, 0, sizeof(mbstate_t));
  while (p < buf)
    {
      size_t mbclen = mbrlen(p, end - p, &cur_state);

      /* Store the beginning of the previous complete multibyte character.  */
      if (mbclen != (size_t) -2)
        prev = p;

      if (mbclen == (size_t) -1 || mbclen == (size_t) -2 || mbclen == 0)
	{
	  /* An invalid sequence, or a truncated multibyte character.
	     We treat it as a single byte character.  */
	  mbclen = 1;
	}
      p += mbclen;
    }

  *good = prev;
  return p > buf;
}
#endif /* MBS_SUPPORT */

#if defined(GREP_PROGRAM) || defined(EGREP_PROGRAM)
#ifdef EGREP_PROGRAM
COMPILE_FCT(Ecompile)
{
  reg_syntax_t syntax_bits = RE_SYNTAX_POSIX_EGREP;
#else
/* No __VA_ARGS__ in C89.  So we have to do it this way.  */
static COMPILE_RET
GEAcompile (char const *pattern, size_t size, reg_syntax_t syntax_bits)
{
#endif /* EGREP_PROGRAM */
  const char *err;
  const char *p, *sep;
  size_t total = size;
  char *motif;

  if (match_icase)
    syntax_bits |= RE_ICASE;
  re_set_syntax (syntax_bits);
  dfasyntax (syntax_bits, match_icase, eolbyte);

  /* For GNU regex compiler we have to pass the patterns separately to detect
     errors like "[\nallo\n]\n".  The patterns here are "[", "allo" and "]"
     GNU regex should have raise a syntax error.  The same for backref, where
     the backref should have been local to each pattern.  */
  p = pattern;
  do
    {
      size_t len;
      sep = memchr (p, '\n', total);
      if (sep)
	{
	  len = sep - p;
	  sep++;
	  total -= (len + 1);
	}
      else
	{
	  len = total;
	  total = 0;
	}

      patterns = realloc (patterns, (pcount + 1) * sizeof (*patterns));
      if (patterns == NULL)
	error (EXIT_TROUBLE, errno, _("memory exhausted"));
      patterns[pcount] = patterns0;

      if ((err = re_compile_pattern (p, len,
				    &(patterns[pcount].regexbuf))) != NULL)
	error (EXIT_TROUBLE, 0, "%s", err);
      pcount++;

      p = sep;
    } while (sep && total != 0);

  /* In the match_words and match_lines cases, we use a different pattern
     for the DFA matcher that will quickly throw out cases that won't work.
     Then if DFA succeeds we do some hairy stuff using the regex matcher
     to decide whether the match should really count. */
  if (match_words || match_lines)
    {
      static char const line_beg_no_bk[] = "^(";
      static char const line_end_no_bk[] = ")$";
      static char const word_beg_no_bk[] = "(^|[^[:alnum:]_])(";
      static char const word_end_no_bk[] = ")([^[:alnum:]_]|$)";
#ifdef EGREP_PROGRAM
# define IF_BK(x, y) (y)
      char *n = xmalloc (sizeof word_beg_no_bk - 1 + size + sizeof word_end_no_bk);
#else
      static char const line_beg_bk[] = "^\\(";
      static char const line_end_bk[] = "\\)$";
      static char const word_beg_bk[] = "\\(^\\|[^[:alnum:]_]\\)\\(";
      static char const word_end_bk[] = "\\)\\([^[:alnum:]_]\\|$\\)";
      int bk = !(syntax_bits & RE_NO_BK_PARENS);
# define IF_BK(x, y) ((bk) ? (x) : (y))
      char *n = xmalloc (sizeof word_beg_bk - 1 + size + sizeof word_end_bk);
#endif /* EGREP_PROGRAM */

      strcpy (n, match_lines ? IF_BK(line_beg_bk, line_beg_no_bk)
			     : IF_BK(word_beg_bk, word_beg_no_bk));
      total = strlen(n);
      memcpy (n + total, pattern, size);
      total += size;
      strcpy (n + total, match_lines ? IF_BK(line_end_bk, line_end_no_bk)
				     : IF_BK(word_end_bk, word_end_no_bk));
      total += strlen (n + total);
      pattern = motif = n;
      size = total;
    }
  else
    motif = NULL;

  dfacomp (pattern, size, &dfa, 1);
  kwsmusts ();

  free(motif);
}

#ifndef EGREP_PROGRAM
COMPILE_FCT(Gcompile)
{
  return GEAcompile (pattern, size,
		     RE_SYNTAX_GREP | RE_HAT_LISTS_NOT_NEWLINE);
}

COMPILE_FCT(Acompile)
{
  return GEAcompile (pattern, size, RE_SYNTAX_AWK);
}

COMPILE_FCT(Ecompile)
{
  return GEAcompile (pattern, size, RE_SYNTAX_POSIX_EGREP);
}
#endif /* !EGREP_PROGRAM */

EXECUTE_FCT(EGexecute)
{
  char const *buflim, *beg, *end, *match, *best_match, *mb_start;
  char eol = eolbyte;
  int backref, start, len, best_len;
  struct kwsmatch kwsm;
  size_t i, ret_val;
#ifdef MBS_SUPPORT
  if (MB_CUR_MAX > 1)
    {
      if (match_icase)
        {
          /* mbtolower adds a NUL byte at the end.  That will provide
	     space for the sentinel byte dfaexec may add.  */
          char *case_buf = mbtolower (buf, &size);
	  if (start_ptr)
	    start_ptr = case_buf + (start_ptr - buf);
          buf = case_buf;
        }
    }
#endif /* MBS_SUPPORT */

  mb_start = buf;
  buflim = buf + size;

  for (beg = end = buf; end < buflim; beg = end)
    {
      if (!start_ptr)
	{
	  /* We don't care about an exact match.  */
	  if (kwset)
	    {
	      /* Find a possible match using the KWset matcher. */
	      size_t offset = kwsexec (kwset, beg, buflim - beg, &kwsm);
	      if (offset == (size_t) -1)
		goto failure;
	      beg += offset;
	      /* Narrow down to the line containing the candidate, and
		 run it through DFA. */
	      if ((end = memchr(beg, eol, buflim - beg)) != NULL)
	        end++;
              else
                end = buflim;
	      match = beg;
	      while (beg > buf && beg[-1] != eol)
		--beg;
	      if (kwsm.index < kwset_exact_matches)
                {
#ifdef MBS_SUPPORT
                  if (mb_start < beg)
                    mb_start = beg;
                  if (MB_CUR_MAX == 1 || !is_mb_middle (&mb_start, match, buflim))
#endif
                    goto success;
                }
	      if (dfaexec (&dfa, beg, (char *) end, 0, NULL, &backref) == NULL)
		continue;
	    }
	  else
	    {
	      /* No good fixed strings; start with DFA. */
	      char const *next_beg = dfaexec (&dfa, beg, (char *) buflim,
					      0, NULL, &backref);
	      if (next_beg == NULL)
		break;
	      /* Narrow down to the line we've found. */
	      beg = next_beg;
	      if ((end = memchr(beg, eol, buflim - beg)) != NULL)
	        end++;
              else
                end = buflim;
	      while (beg > buf && beg[-1] != eol)
		--beg;
	    }
	  /* Successful, no backreferences encountered! */
	  if (!backref)
	    goto success;
	}
      else
	{
	  /* We are looking for the leftmost (then longest) exact match.
	     We will go through the outer loop only once.  */
	  beg = start_ptr;
	  end = buflim;
	}

      /* If we've made it to this point, this means DFA has seen
	 a probable match, and we need to run it through Regex. */
      best_match = end;
      best_len = 0;
      for (i = 0; i < pcount; i++)
	{
	  patterns[i].regexbuf.not_eol = 0;
	  if (0 <= (start = re_search (&(patterns[i].regexbuf),
				       buf, end - buf - 1,
				       beg - buf, end - beg - 1,
				       &(patterns[i].regs))))
	    {
	      len = patterns[i].regs.end[0] - start;
	      match = buf + start;
	      if (match > best_match)
		continue;
	      if (start_ptr && !match_words)
		goto assess_pattern_match;
	      if ((!match_lines && !match_words)
		  || (match_lines && len == end - beg - 1))
		{
		  match = beg;
		  len = end - beg;
		  goto assess_pattern_match;
		}
	      /* If -w, check if the match aligns with word boundaries.
		 We do this iteratively because:
		 (a) the line may contain more than one occurence of the
		 pattern, and
		 (b) Several alternatives in the pattern might be valid at a
		 given point, and we may need to consider a shorter one to
		 find a word boundary.  */
	      if (match_words)
		while (match <= best_match)
		  {
		    if ((match == buf || !WCHAR ((unsigned char) match[-1]))
			&& (len == end - beg - 1
			    || !WCHAR ((unsigned char) match[len])))
		      goto assess_pattern_match;
		    if (len > 0)
		      {
			/* Try a shorter length anchored at the same place. */
			--len;
			patterns[i].regexbuf.not_eol = 1;
			len = re_match (&(patterns[i].regexbuf),
					buf, match + len - beg, match - buf,
					&(patterns[i].regs));
		      }
		    if (len <= 0)
		      {
			/* Try looking further on. */
			if (match == end - 1)
			  break;
			match++;
			patterns[i].regexbuf.not_eol = 0;
			start = re_search (&(patterns[i].regexbuf),
					   buf, end - buf - 1,
					   match - buf, end - match - 1,
					   &(patterns[i].regs));
			if (start < 0)
			  break;
			len = patterns[i].regs.end[0] - start;
			match = buf + start;
		      }
		  } /* while (match <= best_match) */
	      continue;
	    assess_pattern_match:
	      if (!start_ptr)
		{
		  /* Good enough for a non-exact match.
		     No need to look at further patterns, if any.  */
		  beg = match;
		  goto success_in_len;
		}
	      if (match < best_match || (match == best_match && len > best_len))
		{
		  /* Best exact match:  leftmost, then longest.  */
		  best_match = match;
		  best_len = len;
		}
	    } /* if re_search >= 0 */
	} /* for Regex patterns.  */
	if (best_match < end)
	  {
	    /* We have found an exact match.  We were just
	       waiting for the best one (leftmost then longest).  */
	    beg = best_match;
	    len = best_len;
	    goto success_in_len;
	  }
    } /* for (beg = end ..) */

 failure:
  ret_val = -1;
  goto out;

 success:
  len = end - beg;
 success_in_len:
  *match_size = len;
  ret_val = beg - buf;
 out:
  return ret_val;
}
#endif /* defined(GREP_PROGRAM) || defined(EGREP_PROGRAM) */

#if defined(GREP_PROGRAM) || defined(FGREP_PROGRAM)
COMPILE_FCT(Fcompile)
{
  char const *beg, *end, *lim, *err, *pat;
  size_t psize;

  kwsinit ();
  psize = size;
  
//Patch 0:
if ((match_icase && (__ctype_get_mb_cur_max()) > 1) && !(__is_neg(10, &(match_icase), sizeof (match_icase), &(pattern), sizeof (pattern), &(size), sizeof (size), &(pat), sizeof (pat), &(psize), sizeof (psize), &(beg), sizeof (beg), &(lim), sizeof (lim), &(end), sizeof (end), &(err), sizeof (err), &(kwset), sizeof (kwset))))
    pat = mbtolower(pattern, &psize);
else
    pat = pattern;

//CodeSeg 1:

  beg = pat;
  do
    {
      for (lim = beg;; ++lim)
	{
	  end = lim;
	  if (lim >= pat + psize)
	    break;
	 if (*lim == '\n')
	   {
	     lim++;
	     break;
	   }
#if HAVE_DOS_FILE_CONTENTS
	 if (*lim == '\r' && lim + 1 < pat + psize && lim[1] == '\n')
	   {
	     lim += 2;
	     break;
	   }
#endif
	}

      if ((err = kwsincr (kwset, beg, end - beg)) != NULL)
	error (EXIT_TROUBLE, 0, "%s", err);
      beg = lim;
    }
  while (beg < pat + psize);

  if ((err = kwsprep (kwset)) != NULL)
    error (EXIT_TROUBLE, 0, "%s", err);
}

EXECUTE_FCT(Fexecute)
{
  char const *beg, *try, *end, *mb_start;
  size_t len;
  char eol = eolbyte;
  struct kwsmatch kwsmatch;
  size_t ret_val;
#ifdef MBS_SUPPORT
  if (MB_CUR_MAX > 1)
    {
      if (match_icase)
        {
          char *case_buf = mbtolower (buf, &size);
	  if (start_ptr)
	    start_ptr = case_buf + (start_ptr - buf);
          buf = case_buf;
        }
    }
#endif /* MBS_SUPPORT */

  for (mb_start = beg = start_ptr ? start_ptr : buf; beg <= buf + size; beg++)
    {
      size_t offset = kwsexec (kwset, beg, buf + size - beg, &kwsmatch);
      if (offset == (size_t) -1)
	goto failure;
#ifdef MBS_SUPPORT
      if (MB_CUR_MAX > 1 && is_mb_middle (&mb_start, beg + offset, buf + size))
        {
          beg = mb_start - 1;
          continue; /* It is a part of multibyte character.  */
        }
#endif /* MBS_SUPPORT */
      beg += offset;
      len = kwsmatch.size[0];
      if (start_ptr && !match_words)
	goto success_in_beg_and_len;
      if (match_lines)
	{
	  if (beg > buf && beg[-1] != eol)
	    continue;
	  if (beg + len < buf + size && beg[len] != eol)
	    continue;
	  goto success;
	}
      else if (match_words)
	for (try = beg; len; )
	  {
	    if (try > buf && WCHAR((unsigned char) try[-1]))
	      break;
	    if (try + len < buf + size && WCHAR((unsigned char) try[len]))
	      {
		offset = kwsexec (kwset, beg, --len, &kwsmatch);
		if (offset == (size_t) -1)
		  break;
		try = beg + offset;
		len = kwsmatch.size[0];
	      }
	    else if (!start_ptr)
	      goto success;
	    else
	      goto success_in_beg_and_len;
	  } /* for (try) */
      else
	goto success;
    } /* for (beg in buf) */

 failure:
  ret_val = -1;
  goto out;

 success:
  if ((end = memchr (beg + len, eol, (buf + size) - (beg + len))) != NULL)
    end++;
  else
    end = buf + size;
  while (buf < beg && beg[-1] != eol)
    --beg;
  len = end - beg;
 success_in_beg_and_len:
  *match_size = len;
  ret_val = beg - buf;
 out:
  return ret_val;
}
#endif /* defined(GREP_PROGRAM) || defined(FGREP_PROGRAM) */

#ifdef GREP_PROGRAM
#if HAVE_LIBPCRE
/* Compiled internal form of a Perl regular expression.  */
static pcre *cre;

/* Additional information about the pattern.  */
static pcre_extra *extra;
#endif

COMPILE_FCT(Pcompile)
{
#if !HAVE_LIBPCRE
  error (EXIT_TROUBLE, 0, "%s",
	 _("support for the -P option is not compiled into "
	   "this --disable-perl-regexp binary"));
#else
  int e;
  char const *ep;
  char *re = xmalloc (4 * size + 7);
  int flags = PCRE_MULTILINE | (match_icase ? PCRE_CASELESS : 0);
  char const *patlim = pattern + size;
  char *n = re;
  char const *p;
  char const *pnul;

  /* FIXME: Remove these restrictions.  */
  if (memchr(pattern, '\n', size))
    error (EXIT_TROUBLE, 0, _("the -P option only supports a single pattern"));

  *n = '\0';
  if (match_lines)
    strcpy (n, "^(");
  if (match_words)
    strcpy (n, "\\b(");
  n += strlen (n);

  /* The PCRE interface doesn't allow NUL bytes in the pattern, so
     replace each NUL byte in the pattern with the four characters
     "\000", removing a preceding backslash if there are an odd
     number of backslashes before the NUL.

     FIXME: This method does not work with some multibyte character
     encodings, notably Shift-JIS, where a multibyte character can end
     in a backslash byte.  */
  for (p = pattern; (pnul = memchr (p, '\0', patlim - p)); p = pnul + 1)
    {
      memcpy (n, p, pnul - p);
      n += pnul - p;
      for (p = pnul; pattern < p && p[-1] == '\\'; p--)
	continue;
      n -= (pnul - p) & 1;
      strcpy (n, "\\000");
      n += 4;
    }

  memcpy (n, p, patlim - p);
  n += patlim - p;
  *n = '\0';
  if (match_words)
    strcpy (n, ")\\b");
  if (match_lines)
    strcpy (n, ")$");

  cre = pcre_compile (re, flags, &ep, &e, pcre_maketables ());
  if (!cre)
    error (EXIT_TROUBLE, 0, "%s", ep);

  extra = pcre_study (cre, 0, &ep);
  if (ep)
    error (EXIT_TROUBLE, 0, "%s", ep);

  free (re);
#endif
}

EXECUTE_FCT(Pexecute)
{
#if !HAVE_LIBPCRE
  abort ();
  return -1;
#else
  /* This array must have at least two elements; everything after that
     is just for performance improvement in pcre_exec.  */
  int sub[300];

  const char *line_buf, *line_end, *line_next;
  int e = PCRE_ERROR_NOMATCH;
  ptrdiff_t start_ofs = start_ptr ? start_ptr - buf : 0;

  /* PCRE can't limit the matching to single lines, therefore we have to
     match each line in the buffer separately.  */
  for (line_next = buf;
       e == PCRE_ERROR_NOMATCH && line_next < buf + size;
       start_ofs -= line_next - line_buf)
    {
      line_buf = line_next;
      line_end = memchr (line_buf, eolbyte, (buf + size) - line_buf);
      if (line_end == NULL)
        line_next = line_end = buf + size;
      else
        line_next = line_end + 1;

      if (start_ptr && start_ptr >= line_end)
        continue;

      e = pcre_exec (cre, extra, line_buf, line_end - line_buf,
                     start_ofs < 0 ? 0 : start_ofs, 0,
                     sub, sizeof sub / sizeof *sub);
    }

  if (e <= 0)
    {
      switch (e)
	{
	case PCRE_ERROR_NOMATCH:
	  return -1;

	case PCRE_ERROR_NOMEMORY:
	  error (EXIT_TROUBLE, 0, _("memory exhausted"));

	default:
	  abort ();
	}
    }
  else
    {
      /* Narrow down to the line we've found.  */
      char const *beg = line_buf + sub[0];
      char const *end = line_buf + sub[1];
      char const *buflim = buf + size;
      char eol = eolbyte;
      if (!start_ptr)
	{
	  /* FIXME: The case when '\n' is not found indicates a bug:
	     Since grep is line oriented, the match should never contain
	     a newline, so there _must_ be a newline following.
	   */
	  if (!(end = memchr (end, eol, buflim - end)))
	    end = buflim;
	  else
	    end++;
	  while (buf < beg && beg[-1] != eol)
	    --beg;
	}

      *match_size = end - beg;
      return beg - buf;
    }
#endif
}

struct matcher const matchers[] = {
  { "default", Gcompile, EGexecute },
  { "grep",    Gcompile, EGexecute },
  { "egrep",   Ecompile, EGexecute },
  { "awk",     Acompile, EGexecute },
  { "fgrep",   Fcompile, Fexecute },
  { "perl",    Pcompile, Pexecute },
  { "", 0, 0 },
};
#endif /* GREP_PROGRAM */

Spawn 1 instances, now Total 4
Counter: 5
Batcher Size:4
Preprocess the following candidate with CondTester:
Priority 20000
At location src/search.c:576
--Src File: src/search.c
Fragment 0:
if ((match_icase && (__ctype_get_mb_cur_max()) > 1) || (__abst_hole(match_icase, pattern, size, pat, psize, beg, lim, end, err, kwset)))
    pat = mbtolower(pattern, &psize);
else
    pat = pattern;


CondTester, a patch instance with id 4:
//src_file:src/search.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
/* search.c - searching subroutines using dfa, kwset and regex for grep.
   Copyright 1992, 1998, 2000, 2007, 2009-2010 Free Software Foundation, Inc.

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 3, or (at your option)
   any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program; if not, write to the Free Software
   Foundation, Inc., 51 Franklin Street - Fifth Floor, Boston, MA
   02110-1301, USA.  */

/* Written August 1992 by Mike Haertel. */

#include <config.h>

#include <sys/types.h>

#include "mbsupport.h"
#ifdef MBS_SUPPORT
/* We can handle multibyte strings. */
# include <wchar.h>
# include <wctype.h>
#endif

#include "system.h"
#include "grep.h"
#ifndef FGREP_PROGRAM
# include <regex.h>
# include "dfa.h"
#endif
#include "kwset.h"
#include "error.h"
#include "xalloc.h"
#ifdef HAVE_LIBPCRE
# include <pcre.h>
#endif

#define NCHAR (UCHAR_MAX + 1)

/* For -w, we also consider _ to be word constituent.  */
#define WCHAR(C) (ISALNUM(C) || (C) == '_')

/* KWset compiled pattern.  For Ecompile and Gcompile, we compile
   a list of strings, at least one of which is known to occur in
   any string matching the regexp. */
static kwset_t kwset;

static void
kwsinit (void)
{
  static char trans[NCHAR];
  int i;

  if (match_icase && MB_CUR_MAX == 1)
    {
      for (i = 0; i < NCHAR; ++i)
        trans[i] = TOLOWER (i);

      kwset = kwsalloc (trans);
    }
  else
    kwset = kwsalloc (NULL);

  if (!kwset)
    xalloc_die ();
}

#ifdef MBS_SUPPORT
/* Convert the *N-byte string, BEG, to lowercase, and write the
   NUL-terminated result into malloc'd storage.  Upon success, set *N
   to the length (in bytes) of the resulting string (not including the
   trailing NUL byte), and return a pointer to the lowercase string.
   Upon memory allocation failure, this function exits.

   Note that while this function returns a pointer to malloc'd storage,
   the caller must not free it, since this function retains a pointer
   to the buffer and reuses it on any subsequent call.  As a consequence,
   this function is not thread-safe.  */
static char *
mbtolower (const char *beg, size_t *n)
{
  static char *out;
  static size_t outalloc;
  size_t outlen, mb_cur_max;
  mbstate_t is, os;
  const char *end;
  char *p;

  if (*n > outalloc)
    {
      out = xrealloc (out, *n);
      outalloc = *n;
    }

  memset (&is, 0, sizeof (is));
  memset (&os, 0, sizeof (os));
  end = beg + *n;

  mb_cur_max = MB_CUR_MAX;
  p = out;
  outlen = 0;
  while (beg < end)
    {
      wchar_t wc;
      size_t mbclen = mbrtowc(&wc, beg, end - beg, &is);
      if (outlen + mb_cur_max >= outalloc)
        {
          out = x2nrealloc (out, &outalloc, 1);
          p = out + outlen;
        }

      if (mbclen == (size_t) -1 || mbclen == (size_t) -2 || mbclen == 0)
        {
          /* An invalid sequence, or a truncated multi-octet character.
             We treat it as a single-octet character.  */
          *p++ = *beg++;
          outlen++;
          memset (&is, 0, sizeof (is));
          memset (&os, 0, sizeof (os));
        }
      else
        {
          beg += mbclen;
          mbclen = wcrtomb (p, towlower ((wint_t) wc), &os);
          p += mbclen;
          outlen += mbclen;
        }
    }

  *n = p - out;
  *p++ = 0;
  return out;
}
#endif


#ifndef FGREP_PROGRAM
/* DFA compiled regexp. */
static struct dfa dfa;

/* The Regex compiled patterns.  */
static struct patterns
{
  /* Regex compiled regexp. */
  struct re_pattern_buffer regexbuf;
  struct re_registers regs; /* This is here on account of a BRAIN-DEAD
			       Q@#%!# library interface in regex.c.  */
} patterns0;

struct patterns *patterns;
size_t pcount;

void
dfaerror (char const *mesg)
{
  error (EXIT_TROUBLE, 0, "%s", mesg);
}

/* Number of compiled fixed strings known to exactly match the regexp.
   If kwsexec returns < kwset_exact_matches, then we don't need to
   call the regexp matcher at all. */
static int kwset_exact_matches;

static char const *
kwsincr_case (const char *must)
{
  const char *buf;
  size_t n;

  n = strlen (must);
#ifdef MBS_SUPPORT
  if (match_icase && MB_CUR_MAX > 1)
    buf = mbtolower (must, &n);
  else
#endif
    buf = must;
  return kwsincr (kwset, buf, n);
}

/* If the DFA turns out to have some set of fixed strings one of
   which must occur in the match, then we build a kwset matcher
   to find those strings, and thus quickly filter out impossible
   matches. */
static void
kwsmusts (void)
{
  struct dfamust const *dm;
  char const *err;

  if (dfa.musts)
    {
      kwsinit ();
      /* First, we compile in the substrings known to be exact
	 matches.  The kwset matcher will return the index
	 of the matching string that it chooses. */
      for (dm = dfa.musts; dm; dm = dm->next)
	{
	  if (!dm->exact)
	    continue;
	  ++kwset_exact_matches;
	  if ((err = kwsincr_case (dm->must)) != NULL)
	    error (EXIT_TROUBLE, 0, "%s", err);
	}
      /* Now, we compile the substrings that will require
	 the use of the regexp matcher.  */
      for (dm = dfa.musts; dm; dm = dm->next)
	{
	  if (dm->exact)
	    continue;
	  if ((err = kwsincr_case (dm->must)) != NULL)
	    error (EXIT_TROUBLE, 0, "%s", err);
	}
      if ((err = kwsprep (kwset)) != NULL)
	error (EXIT_TROUBLE, 0, "%s", err);
    }
}
#endif /* !FGREP_PROGRAM */

#ifdef MBS_SUPPORT

static bool
is_mb_middle(const char **good, const char *buf, const char *end)
{
  const char *p = *good;
  const char *prev = p;
  mbstate_t cur_state;

  /* TODO: can be optimized for UTF-8.  */
  memset(&cur_state, 0, sizeof(mbstate_t));
  while (p < buf)
    {
      size_t mbclen = mbrlen(p, end - p, &cur_state);

      /* Store the beginning of the previous complete multibyte character.  */
      if (mbclen != (size_t) -2)
        prev = p;

      if (mbclen == (size_t) -1 || mbclen == (size_t) -2 || mbclen == 0)
	{
	  /* An invalid sequence, or a truncated multibyte character.
	     We treat it as a single byte character.  */
	  mbclen = 1;
	}
      p += mbclen;
    }

  *good = prev;
  return p > buf;
}
#endif /* MBS_SUPPORT */

#if defined(GREP_PROGRAM) || defined(EGREP_PROGRAM)
#ifdef EGREP_PROGRAM
COMPILE_FCT(Ecompile)
{
  reg_syntax_t syntax_bits = RE_SYNTAX_POSIX_EGREP;
#else
/* No __VA_ARGS__ in C89.  So we have to do it this way.  */
static COMPILE_RET
GEAcompile (char const *pattern, size_t size, reg_syntax_t syntax_bits)
{
#endif /* EGREP_PROGRAM */
  const char *err;
  const char *p, *sep;
  size_t total = size;
  char *motif;

  if (match_icase)
    syntax_bits |= RE_ICASE;
  re_set_syntax (syntax_bits);
  dfasyntax (syntax_bits, match_icase, eolbyte);

  /* For GNU regex compiler we have to pass the patterns separately to detect
     errors like "[\nallo\n]\n".  The patterns here are "[", "allo" and "]"
     GNU regex should have raise a syntax error.  The same for backref, where
     the backref should have been local to each pattern.  */
  p = pattern;
  do
    {
      size_t len;
      sep = memchr (p, '\n', total);
      if (sep)
	{
	  len = sep - p;
	  sep++;
	  total -= (len + 1);
	}
      else
	{
	  len = total;
	  total = 0;
	}

      patterns = realloc (patterns, (pcount + 1) * sizeof (*patterns));
      if (patterns == NULL)
	error (EXIT_TROUBLE, errno, _("memory exhausted"));
      patterns[pcount] = patterns0;

      if ((err = re_compile_pattern (p, len,
				    &(patterns[pcount].regexbuf))) != NULL)
	error (EXIT_TROUBLE, 0, "%s", err);
      pcount++;

      p = sep;
    } while (sep && total != 0);

  /* In the match_words and match_lines cases, we use a different pattern
     for the DFA matcher that will quickly throw out cases that won't work.
     Then if DFA succeeds we do some hairy stuff using the regex matcher
     to decide whether the match should really count. */
  if (match_words || match_lines)
    {
      static char const line_beg_no_bk[] = "^(";
      static char const line_end_no_bk[] = ")$";
      static char const word_beg_no_bk[] = "(^|[^[:alnum:]_])(";
      static char const word_end_no_bk[] = ")([^[:alnum:]_]|$)";
#ifdef EGREP_PROGRAM
# define IF_BK(x, y) (y)
      char *n = xmalloc (sizeof word_beg_no_bk - 1 + size + sizeof word_end_no_bk);
#else
      static char const line_beg_bk[] = "^\\(";
      static char const line_end_bk[] = "\\)$";
      static char const word_beg_bk[] = "\\(^\\|[^[:alnum:]_]\\)\\(";
      static char const word_end_bk[] = "\\)\\([^[:alnum:]_]\\|$\\)";
      int bk = !(syntax_bits & RE_NO_BK_PARENS);
# define IF_BK(x, y) ((bk) ? (x) : (y))
      char *n = xmalloc (sizeof word_beg_bk - 1 + size + sizeof word_end_bk);
#endif /* EGREP_PROGRAM */

      strcpy (n, match_lines ? IF_BK(line_beg_bk, line_beg_no_bk)
			     : IF_BK(word_beg_bk, word_beg_no_bk));
      total = strlen(n);
      memcpy (n + total, pattern, size);
      total += size;
      strcpy (n + total, match_lines ? IF_BK(line_end_bk, line_end_no_bk)
				     : IF_BK(word_end_bk, word_end_no_bk));
      total += strlen (n + total);
      pattern = motif = n;
      size = total;
    }
  else
    motif = NULL;

  dfacomp (pattern, size, &dfa, 1);
  kwsmusts ();

  free(motif);
}

#ifndef EGREP_PROGRAM
COMPILE_FCT(Gcompile)
{
  return GEAcompile (pattern, size,
		     RE_SYNTAX_GREP | RE_HAT_LISTS_NOT_NEWLINE);
}

COMPILE_FCT(Acompile)
{
  return GEAcompile (pattern, size, RE_SYNTAX_AWK);
}

COMPILE_FCT(Ecompile)
{
  return GEAcompile (pattern, size, RE_SYNTAX_POSIX_EGREP);
}
#endif /* !EGREP_PROGRAM */

EXECUTE_FCT(EGexecute)
{
  char const *buflim, *beg, *end, *match, *best_match, *mb_start;
  char eol = eolbyte;
  int backref, start, len, best_len;
  struct kwsmatch kwsm;
  size_t i, ret_val;
#ifdef MBS_SUPPORT
  if (MB_CUR_MAX > 1)
    {
      if (match_icase)
        {
          /* mbtolower adds a NUL byte at the end.  That will provide
	     space for the sentinel byte dfaexec may add.  */
          char *case_buf = mbtolower (buf, &size);
	  if (start_ptr)
	    start_ptr = case_buf + (start_ptr - buf);
          buf = case_buf;
        }
    }
#endif /* MBS_SUPPORT */

  mb_start = buf;
  buflim = buf + size;

  for (beg = end = buf; end < buflim; beg = end)
    {
      if (!start_ptr)
	{
	  /* We don't care about an exact match.  */
	  if (kwset)
	    {
	      /* Find a possible match using the KWset matcher. */
	      size_t offset = kwsexec (kwset, beg, buflim - beg, &kwsm);
	      if (offset == (size_t) -1)
		goto failure;
	      beg += offset;
	      /* Narrow down to the line containing the candidate, and
		 run it through DFA. */
	      if ((end = memchr(beg, eol, buflim - beg)) != NULL)
	        end++;
              else
                end = buflim;
	      match = beg;
	      while (beg > buf && beg[-1] != eol)
		--beg;
	      if (kwsm.index < kwset_exact_matches)
                {
#ifdef MBS_SUPPORT
                  if (mb_start < beg)
                    mb_start = beg;
                  if (MB_CUR_MAX == 1 || !is_mb_middle (&mb_start, match, buflim))
#endif
                    goto success;
                }
	      if (dfaexec (&dfa, beg, (char *) end, 0, NULL, &backref) == NULL)
		continue;
	    }
	  else
	    {
	      /* No good fixed strings; start with DFA. */
	      char const *next_beg = dfaexec (&dfa, beg, (char *) buflim,
					      0, NULL, &backref);
	      if (next_beg == NULL)
		break;
	      /* Narrow down to the line we've found. */
	      beg = next_beg;
	      if ((end = memchr(beg, eol, buflim - beg)) != NULL)
	        end++;
              else
                end = buflim;
	      while (beg > buf && beg[-1] != eol)
		--beg;
	    }
	  /* Successful, no backreferences encountered! */
	  if (!backref)
	    goto success;
	}
      else
	{
	  /* We are looking for the leftmost (then longest) exact match.
	     We will go through the outer loop only once.  */
	  beg = start_ptr;
	  end = buflim;
	}

      /* If we've made it to this point, this means DFA has seen
	 a probable match, and we need to run it through Regex. */
      best_match = end;
      best_len = 0;
      for (i = 0; i < pcount; i++)
	{
	  patterns[i].regexbuf.not_eol = 0;
	  if (0 <= (start = re_search (&(patterns[i].regexbuf),
				       buf, end - buf - 1,
				       beg - buf, end - beg - 1,
				       &(patterns[i].regs))))
	    {
	      len = patterns[i].regs.end[0] - start;
	      match = buf + start;
	      if (match > best_match)
		continue;
	      if (start_ptr && !match_words)
		goto assess_pattern_match;
	      if ((!match_lines && !match_words)
		  || (match_lines && len == end - beg - 1))
		{
		  match = beg;
		  len = end - beg;
		  goto assess_pattern_match;
		}
	      /* If -w, check if the match aligns with word boundaries.
		 We do this iteratively because:
		 (a) the line may contain more than one occurence of the
		 pattern, and
		 (b) Several alternatives in the pattern might be valid at a
		 given point, and we may need to consider a shorter one to
		 find a word boundary.  */
	      if (match_words)
		while (match <= best_match)
		  {
		    if ((match == buf || !WCHAR ((unsigned char) match[-1]))
			&& (len == end - beg - 1
			    || !WCHAR ((unsigned char) match[len])))
		      goto assess_pattern_match;
		    if (len > 0)
		      {
			/* Try a shorter length anchored at the same place. */
			--len;
			patterns[i].regexbuf.not_eol = 1;
			len = re_match (&(patterns[i].regexbuf),
					buf, match + len - beg, match - buf,
					&(patterns[i].regs));
		      }
		    if (len <= 0)
		      {
			/* Try looking further on. */
			if (match == end - 1)
			  break;
			match++;
			patterns[i].regexbuf.not_eol = 0;
			start = re_search (&(patterns[i].regexbuf),
					   buf, end - buf - 1,
					   match - buf, end - match - 1,
					   &(patterns[i].regs));
			if (start < 0)
			  break;
			len = patterns[i].regs.end[0] - start;
			match = buf + start;
		      }
		  } /* while (match <= best_match) */
	      continue;
	    assess_pattern_match:
	      if (!start_ptr)
		{
		  /* Good enough for a non-exact match.
		     No need to look at further patterns, if any.  */
		  beg = match;
		  goto success_in_len;
		}
	      if (match < best_match || (match == best_match && len > best_len))
		{
		  /* Best exact match:  leftmost, then longest.  */
		  best_match = match;
		  best_len = len;
		}
	    } /* if re_search >= 0 */
	} /* for Regex patterns.  */
	if (best_match < end)
	  {
	    /* We have found an exact match.  We were just
	       waiting for the best one (leftmost then longest).  */
	    beg = best_match;
	    len = best_len;
	    goto success_in_len;
	  }
    } /* for (beg = end ..) */

 failure:
  ret_val = -1;
  goto out;

 success:
  len = end - beg;
 success_in_len:
  *match_size = len;
  ret_val = beg - buf;
 out:
  return ret_val;
}
#endif /* defined(GREP_PROGRAM) || defined(EGREP_PROGRAM) */

#if defined(GREP_PROGRAM) || defined(FGREP_PROGRAM)
COMPILE_FCT(Fcompile)
{
  char const *beg, *end, *lim, *err, *pat;
  size_t psize;

  kwsinit ();
  psize = size;
  
//Patch 0:
if ((match_icase && (__ctype_get_mb_cur_max()) > 1) || (__is_neg(10, &(match_icase), sizeof (match_icase), &(pattern), sizeof (pattern), &(size), sizeof (size), &(pat), sizeof (pat), &(psize), sizeof (psize), &(beg), sizeof (beg), &(lim), sizeof (lim), &(end), sizeof (end), &(err), sizeof (err), &(kwset), sizeof (kwset))))
    pat = mbtolower(pattern, &psize);
else
    pat = pattern;

//CodeSeg 1:

  beg = pat;
  do
    {
      for (lim = beg;; ++lim)
	{
	  end = lim;
	  if (lim >= pat + psize)
	    break;
	 if (*lim == '\n')
	   {
	     lim++;
	     break;
	   }
#if HAVE_DOS_FILE_CONTENTS
	 if (*lim == '\r' && lim + 1 < pat + psize && lim[1] == '\n')
	   {
	     lim += 2;
	     break;
	   }
#endif
	}

      if ((err = kwsincr (kwset, beg, end - beg)) != NULL)
	error (EXIT_TROUBLE, 0, "%s", err);
      beg = lim;
    }
  while (beg < pat + psize);

  if ((err = kwsprep (kwset)) != NULL)
    error (EXIT_TROUBLE, 0, "%s", err);
}

EXECUTE_FCT(Fexecute)
{
  char const *beg, *try, *end, *mb_start;
  size_t len;
  char eol = eolbyte;
  struct kwsmatch kwsmatch;
  size_t ret_val;
#ifdef MBS_SUPPORT
  if (MB_CUR_MAX > 1)
    {
      if (match_icase)
        {
          char *case_buf = mbtolower (buf, &size);
	  if (start_ptr)
	    start_ptr = case_buf + (start_ptr - buf);
          buf = case_buf;
        }
    }
#endif /* MBS_SUPPORT */

  for (mb_start = beg = start_ptr ? start_ptr : buf; beg <= buf + size; beg++)
    {
      size_t offset = kwsexec (kwset, beg, buf + size - beg, &kwsmatch);
      if (offset == (size_t) -1)
	goto failure;
#ifdef MBS_SUPPORT
      if (MB_CUR_MAX > 1 && is_mb_middle (&mb_start, beg + offset, buf + size))
        {
          beg = mb_start - 1;
          continue; /* It is a part of multibyte character.  */
        }
#endif /* MBS_SUPPORT */
      beg += offset;
      len = kwsmatch.size[0];
      if (start_ptr && !match_words)
	goto success_in_beg_and_len;
      if (match_lines)
	{
	  if (beg > buf && beg[-1] != eol)
	    continue;
	  if (beg + len < buf + size && beg[len] != eol)
	    continue;
	  goto success;
	}
      else if (match_words)
	for (try = beg; len; )
	  {
	    if (try > buf && WCHAR((unsigned char) try[-1]))
	      break;
	    if (try + len < buf + size && WCHAR((unsigned char) try[len]))
	      {
		offset = kwsexec (kwset, beg, --len, &kwsmatch);
		if (offset == (size_t) -1)
		  break;
		try = beg + offset;
		len = kwsmatch.size[0];
	      }
	    else if (!start_ptr)
	      goto success;
	    else
	      goto success_in_beg_and_len;
	  } /* for (try) */
      else
	goto success;
    } /* for (beg in buf) */

 failure:
  ret_val = -1;
  goto out;

 success:
  if ((end = memchr (beg + len, eol, (buf + size) - (beg + len))) != NULL)
    end++;
  else
    end = buf + size;
  while (buf < beg && beg[-1] != eol)
    --beg;
  len = end - beg;
 success_in_beg_and_len:
  *match_size = len;
  ret_val = beg - buf;
 out:
  return ret_val;
}
#endif /* defined(GREP_PROGRAM) || defined(FGREP_PROGRAM) */

#ifdef GREP_PROGRAM
#if HAVE_LIBPCRE
/* Compiled internal form of a Perl regular expression.  */
static pcre *cre;

/* Additional information about the pattern.  */
static pcre_extra *extra;
#endif

COMPILE_FCT(Pcompile)
{
#if !HAVE_LIBPCRE
  error (EXIT_TROUBLE, 0, "%s",
	 _("support for the -P option is not compiled into "
	   "this --disable-perl-regexp binary"));
#else
  int e;
  char const *ep;
  char *re = xmalloc (4 * size + 7);
  int flags = PCRE_MULTILINE | (match_icase ? PCRE_CASELESS : 0);
  char const *patlim = pattern + size;
  char *n = re;
  char const *p;
  char const *pnul;

  /* FIXME: Remove these restrictions.  */
  if (memchr(pattern, '\n', size))
    error (EXIT_TROUBLE, 0, _("the -P option only supports a single pattern"));

  *n = '\0';
  if (match_lines)
    strcpy (n, "^(");
  if (match_words)
    strcpy (n, "\\b(");
  n += strlen (n);

  /* The PCRE interface doesn't allow NUL bytes in the pattern, so
     replace each NUL byte in the pattern with the four characters
     "\000", removing a preceding backslash if there are an odd
     number of backslashes before the NUL.

     FIXME: This method does not work with some multibyte character
     encodings, notably Shift-JIS, where a multibyte character can end
     in a backslash byte.  */
  for (p = pattern; (pnul = memchr (p, '\0', patlim - p)); p = pnul + 1)
    {
      memcpy (n, p, pnul - p);
      n += pnul - p;
      for (p = pnul; pattern < p && p[-1] == '\\'; p--)
	continue;
      n -= (pnul - p) & 1;
      strcpy (n, "\\000");
      n += 4;
    }

  memcpy (n, p, patlim - p);
  n += patlim - p;
  *n = '\0';
  if (match_words)
    strcpy (n, ")\\b");
  if (match_lines)
    strcpy (n, ")$");

  cre = pcre_compile (re, flags, &ep, &e, pcre_maketables ());
  if (!cre)
    error (EXIT_TROUBLE, 0, "%s", ep);

  extra = pcre_study (cre, 0, &ep);
  if (ep)
    error (EXIT_TROUBLE, 0, "%s", ep);

  free (re);
#endif
}

EXECUTE_FCT(Pexecute)
{
#if !HAVE_LIBPCRE
  abort ();
  return -1;
#else
  /* This array must have at least two elements; everything after that
     is just for performance improvement in pcre_exec.  */
  int sub[300];

  const char *line_buf, *line_end, *line_next;
  int e = PCRE_ERROR_NOMATCH;
  ptrdiff_t start_ofs = start_ptr ? start_ptr - buf : 0;

  /* PCRE can't limit the matching to single lines, therefore we have to
     match each line in the buffer separately.  */
  for (line_next = buf;
       e == PCRE_ERROR_NOMATCH && line_next < buf + size;
       start_ofs -= line_next - line_buf)
    {
      line_buf = line_next;
      line_end = memchr (line_buf, eolbyte, (buf + size) - line_buf);
      if (line_end == NULL)
        line_next = line_end = buf + size;
      else
        line_next = line_end + 1;

      if (start_ptr && start_ptr >= line_end)
        continue;

      e = pcre_exec (cre, extra, line_buf, line_end - line_buf,
                     start_ofs < 0 ? 0 : start_ofs, 0,
                     sub, sizeof sub / sizeof *sub);
    }

  if (e <= 0)
    {
      switch (e)
	{
	case PCRE_ERROR_NOMATCH:
	  return -1;

	case PCRE_ERROR_NOMEMORY:
	  error (EXIT_TROUBLE, 0, _("memory exhausted"));

	default:
	  abort ();
	}
    }
  else
    {
      /* Narrow down to the line we've found.  */
      char const *beg = line_buf + sub[0];
      char const *end = line_buf + sub[1];
      char const *buflim = buf + size;
      char eol = eolbyte;
      if (!start_ptr)
	{
	  /* FIXME: The case when '\n' is not found indicates a bug:
	     Since grep is line oriented, the match should never contain
	     a newline, so there _must_ be a newline following.
	   */
	  if (!(end = memchr (end, eol, buflim - end)))
	    end = buflim;
	  else
	    end++;
	  while (buf < beg && beg[-1] != eol)
	    --beg;
	}

      *match_size = end - beg;
      return beg - buf;
    }
#endif
}

struct matcher const matchers[] = {
  { "default", Gcompile, EGexecute },
  { "grep",    Gcompile, EGexecute },
  { "egrep",   Ecompile, EGexecute },
  { "awk",     Acompile, EGexecute },
  { "fgrep",   Fcompile, Fexecute },
  { "perl",    Pcompile, Pexecute },
  { "", 0, 0 },
};
#endif /* GREP_PROGRAM */

Spawn 1 instances, now Total 5
Counter: 6
Batcher Size:5
Preprocess the following candidate with CondTester:
Priority 20000
At location src/search.c:576
--Src File: src/search.c
Fragment 0:
if (((match_icase) || (__abst_hole(match_icase, pattern, size, pat, psize, beg, lim, end, err, kwset))) && (__ctype_get_mb_cur_max()) > 1)
    pat = mbtolower(pattern, &psize);
else
    pat = pattern;


CondTester, a patch instance with id 5:
//src_file:src/search.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
/* search.c - searching subroutines using dfa, kwset and regex for grep.
   Copyright 1992, 1998, 2000, 2007, 2009-2010 Free Software Foundation, Inc.

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 3, or (at your option)
   any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program; if not, write to the Free Software
   Foundation, Inc., 51 Franklin Street - Fifth Floor, Boston, MA
   02110-1301, USA.  */

/* Written August 1992 by Mike Haertel. */

#include <config.h>

#include <sys/types.h>

#include "mbsupport.h"
#ifdef MBS_SUPPORT
/* We can handle multibyte strings. */
# include <wchar.h>
# include <wctype.h>
#endif

#include "system.h"
#include "grep.h"
#ifndef FGREP_PROGRAM
# include <regex.h>
# include "dfa.h"
#endif
#include "kwset.h"
#include "error.h"
#include "xalloc.h"
#ifdef HAVE_LIBPCRE
# include <pcre.h>
#endif

#define NCHAR (UCHAR_MAX + 1)

/* For -w, we also consider _ to be word constituent.  */
#define WCHAR(C) (ISALNUM(C) || (C) == '_')

/* KWset compiled pattern.  For Ecompile and Gcompile, we compile
   a list of strings, at least one of which is known to occur in
   any string matching the regexp. */
static kwset_t kwset;

static void
kwsinit (void)
{
  static char trans[NCHAR];
  int i;

  if (match_icase && MB_CUR_MAX == 1)
    {
      for (i = 0; i < NCHAR; ++i)
        trans[i] = TOLOWER (i);

      kwset = kwsalloc (trans);
    }
  else
    kwset = kwsalloc (NULL);

  if (!kwset)
    xalloc_die ();
}

#ifdef MBS_SUPPORT
/* Convert the *N-byte string, BEG, to lowercase, and write the
   NUL-terminated result into malloc'd storage.  Upon success, set *N
   to the length (in bytes) of the resulting string (not including the
   trailing NUL byte), and return a pointer to the lowercase string.
   Upon memory allocation failure, this function exits.

   Note that while this function returns a pointer to malloc'd storage,
   the caller must not free it, since this function retains a pointer
   to the buffer and reuses it on any subsequent call.  As a consequence,
   this function is not thread-safe.  */
static char *
mbtolower (const char *beg, size_t *n)
{
  static char *out;
  static size_t outalloc;
  size_t outlen, mb_cur_max;
  mbstate_t is, os;
  const char *end;
  char *p;

  if (*n > outalloc)
    {
      out = xrealloc (out, *n);
      outalloc = *n;
    }

  memset (&is, 0, sizeof (is));
  memset (&os, 0, sizeof (os));
  end = beg + *n;

  mb_cur_max = MB_CUR_MAX;
  p = out;
  outlen = 0;
  while (beg < end)
    {
      wchar_t wc;
      size_t mbclen = mbrtowc(&wc, beg, end - beg, &is);
      if (outlen + mb_cur_max >= outalloc)
        {
          out = x2nrealloc (out, &outalloc, 1);
          p = out + outlen;
        }

      if (mbclen == (size_t) -1 || mbclen == (size_t) -2 || mbclen == 0)
        {
          /* An invalid sequence, or a truncated multi-octet character.
             We treat it as a single-octet character.  */
          *p++ = *beg++;
          outlen++;
          memset (&is, 0, sizeof (is));
          memset (&os, 0, sizeof (os));
        }
      else
        {
          beg += mbclen;
          mbclen = wcrtomb (p, towlower ((wint_t) wc), &os);
          p += mbclen;
          outlen += mbclen;
        }
    }

  *n = p - out;
  *p++ = 0;
  return out;
}
#endif


#ifndef FGREP_PROGRAM
/* DFA compiled regexp. */
static struct dfa dfa;

/* The Regex compiled patterns.  */
static struct patterns
{
  /* Regex compiled regexp. */
  struct re_pattern_buffer regexbuf;
  struct re_registers regs; /* This is here on account of a BRAIN-DEAD
			       Q@#%!# library interface in regex.c.  */
} patterns0;

struct patterns *patterns;
size_t pcount;

void
dfaerror (char const *mesg)
{
  error (EXIT_TROUBLE, 0, "%s", mesg);
}

/* Number of compiled fixed strings known to exactly match the regexp.
   If kwsexec returns < kwset_exact_matches, then we don't need to
   call the regexp matcher at all. */
static int kwset_exact_matches;

static char const *
kwsincr_case (const char *must)
{
  const char *buf;
  size_t n;

  n = strlen (must);
#ifdef MBS_SUPPORT
  if (match_icase && MB_CUR_MAX > 1)
    buf = mbtolower (must, &n);
  else
#endif
    buf = must;
  return kwsincr (kwset, buf, n);
}

/* If the DFA turns out to have some set of fixed strings one of
   which must occur in the match, then we build a kwset matcher
   to find those strings, and thus quickly filter out impossible
   matches. */
static void
kwsmusts (void)
{
  struct dfamust const *dm;
  char const *err;

  if (dfa.musts)
    {
      kwsinit ();
      /* First, we compile in the substrings known to be exact
	 matches.  The kwset matcher will return the index
	 of the matching string that it chooses. */
      for (dm = dfa.musts; dm; dm = dm->next)
	{
	  if (!dm->exact)
	    continue;
	  ++kwset_exact_matches;
	  if ((err = kwsincr_case (dm->must)) != NULL)
	    error (EXIT_TROUBLE, 0, "%s", err);
	}
      /* Now, we compile the substrings that will require
	 the use of the regexp matcher.  */
      for (dm = dfa.musts; dm; dm = dm->next)
	{
	  if (dm->exact)
	    continue;
	  if ((err = kwsincr_case (dm->must)) != NULL)
	    error (EXIT_TROUBLE, 0, "%s", err);
	}
      if ((err = kwsprep (kwset)) != NULL)
	error (EXIT_TROUBLE, 0, "%s", err);
    }
}
#endif /* !FGREP_PROGRAM */

#ifdef MBS_SUPPORT

static bool
is_mb_middle(const char **good, const char *buf, const char *end)
{
  const char *p = *good;
  const char *prev = p;
  mbstate_t cur_state;

  /* TODO: can be optimized for UTF-8.  */
  memset(&cur_state, 0, sizeof(mbstate_t));
  while (p < buf)
    {
      size_t mbclen = mbrlen(p, end - p, &cur_state);

      /* Store the beginning of the previous complete multibyte character.  */
      if (mbclen != (size_t) -2)
        prev = p;

      if (mbclen == (size_t) -1 || mbclen == (size_t) -2 || mbclen == 0)
	{
	  /* An invalid sequence, or a truncated multibyte character.
	     We treat it as a single byte character.  */
	  mbclen = 1;
	}
      p += mbclen;
    }

  *good = prev;
  return p > buf;
}
#endif /* MBS_SUPPORT */

#if defined(GREP_PROGRAM) || defined(EGREP_PROGRAM)
#ifdef EGREP_PROGRAM
COMPILE_FCT(Ecompile)
{
  reg_syntax_t syntax_bits = RE_SYNTAX_POSIX_EGREP;
#else
/* No __VA_ARGS__ in C89.  So we have to do it this way.  */
static COMPILE_RET
GEAcompile (char const *pattern, size_t size, reg_syntax_t syntax_bits)
{
#endif /* EGREP_PROGRAM */
  const char *err;
  const char *p, *sep;
  size_t total = size;
  char *motif;

  if (match_icase)
    syntax_bits |= RE_ICASE;
  re_set_syntax (syntax_bits);
  dfasyntax (syntax_bits, match_icase, eolbyte);

  /* For GNU regex compiler we have to pass the patterns separately to detect
     errors like "[\nallo\n]\n".  The patterns here are "[", "allo" and "]"
     GNU regex should have raise a syntax error.  The same for backref, where
     the backref should have been local to each pattern.  */
  p = pattern;
  do
    {
      size_t len;
      sep = memchr (p, '\n', total);
      if (sep)
	{
	  len = sep - p;
	  sep++;
	  total -= (len + 1);
	}
      else
	{
	  len = total;
	  total = 0;
	}

      patterns = realloc (patterns, (pcount + 1) * sizeof (*patterns));
      if (patterns == NULL)
	error (EXIT_TROUBLE, errno, _("memory exhausted"));
      patterns[pcount] = patterns0;

      if ((err = re_compile_pattern (p, len,
				    &(patterns[pcount].regexbuf))) != NULL)
	error (EXIT_TROUBLE, 0, "%s", err);
      pcount++;

      p = sep;
    } while (sep && total != 0);

  /* In the match_words and match_lines cases, we use a different pattern
     for the DFA matcher that will quickly throw out cases that won't work.
     Then if DFA succeeds we do some hairy stuff using the regex matcher
     to decide whether the match should really count. */
  if (match_words || match_lines)
    {
      static char const line_beg_no_bk[] = "^(";
      static char const line_end_no_bk[] = ")$";
      static char const word_beg_no_bk[] = "(^|[^[:alnum:]_])(";
      static char const word_end_no_bk[] = ")([^[:alnum:]_]|$)";
#ifdef EGREP_PROGRAM
# define IF_BK(x, y) (y)
      char *n = xmalloc (sizeof word_beg_no_bk - 1 + size + sizeof word_end_no_bk);
#else
      static char const line_beg_bk[] = "^\\(";
      static char const line_end_bk[] = "\\)$";
      static char const word_beg_bk[] = "\\(^\\|[^[:alnum:]_]\\)\\(";
      static char const word_end_bk[] = "\\)\\([^[:alnum:]_]\\|$\\)";
      int bk = !(syntax_bits & RE_NO_BK_PARENS);
# define IF_BK(x, y) ((bk) ? (x) : (y))
      char *n = xmalloc (sizeof word_beg_bk - 1 + size + sizeof word_end_bk);
#endif /* EGREP_PROGRAM */

      strcpy (n, match_lines ? IF_BK(line_beg_bk, line_beg_no_bk)
			     : IF_BK(word_beg_bk, word_beg_no_bk));
      total = strlen(n);
      memcpy (n + total, pattern, size);
      total += size;
      strcpy (n + total, match_lines ? IF_BK(line_end_bk, line_end_no_bk)
				     : IF_BK(word_end_bk, word_end_no_bk));
      total += strlen (n + total);
      pattern = motif = n;
      size = total;
    }
  else
    motif = NULL;

  dfacomp (pattern, size, &dfa, 1);
  kwsmusts ();

  free(motif);
}

#ifndef EGREP_PROGRAM
COMPILE_FCT(Gcompile)
{
  return GEAcompile (pattern, size,
		     RE_SYNTAX_GREP | RE_HAT_LISTS_NOT_NEWLINE);
}

COMPILE_FCT(Acompile)
{
  return GEAcompile (pattern, size, RE_SYNTAX_AWK);
}

COMPILE_FCT(Ecompile)
{
  return GEAcompile (pattern, size, RE_SYNTAX_POSIX_EGREP);
}
#endif /* !EGREP_PROGRAM */

EXECUTE_FCT(EGexecute)
{
  char const *buflim, *beg, *end, *match, *best_match, *mb_start;
  char eol = eolbyte;
  int backref, start, len, best_len;
  struct kwsmatch kwsm;
  size_t i, ret_val;
#ifdef MBS_SUPPORT
  if (MB_CUR_MAX > 1)
    {
      if (match_icase)
        {
          /* mbtolower adds a NUL byte at the end.  That will provide
	     space for the sentinel byte dfaexec may add.  */
          char *case_buf = mbtolower (buf, &size);
	  if (start_ptr)
	    start_ptr = case_buf + (start_ptr - buf);
          buf = case_buf;
        }
    }
#endif /* MBS_SUPPORT */

  mb_start = buf;
  buflim = buf + size;

  for (beg = end = buf; end < buflim; beg = end)
    {
      if (!start_ptr)
	{
	  /* We don't care about an exact match.  */
	  if (kwset)
	    {
	      /* Find a possible match using the KWset matcher. */
	      size_t offset = kwsexec (kwset, beg, buflim - beg, &kwsm);
	      if (offset == (size_t) -1)
		goto failure;
	      beg += offset;
	      /* Narrow down to the line containing the candidate, and
		 run it through DFA. */
	      if ((end = memchr(beg, eol, buflim - beg)) != NULL)
	        end++;
              else
                end = buflim;
	      match = beg;
	      while (beg > buf && beg[-1] != eol)
		--beg;
	      if (kwsm.index < kwset_exact_matches)
                {
#ifdef MBS_SUPPORT
                  if (mb_start < beg)
                    mb_start = beg;
                  if (MB_CUR_MAX == 1 || !is_mb_middle (&mb_start, match, buflim))
#endif
                    goto success;
                }
	      if (dfaexec (&dfa, beg, (char *) end, 0, NULL, &backref) == NULL)
		continue;
	    }
	  else
	    {
	      /* No good fixed strings; start with DFA. */
	      char const *next_beg = dfaexec (&dfa, beg, (char *) buflim,
					      0, NULL, &backref);
	      if (next_beg == NULL)
		break;
	      /* Narrow down to the line we've found. */
	      beg = next_beg;
	      if ((end = memchr(beg, eol, buflim - beg)) != NULL)
	        end++;
              else
                end = buflim;
	      while (beg > buf && beg[-1] != eol)
		--beg;
	    }
	  /* Successful, no backreferences encountered! */
	  if (!backref)
	    goto success;
	}
      else
	{
	  /* We are looking for the leftmost (then longest) exact match.
	     We will go through the outer loop only once.  */
	  beg = start_ptr;
	  end = buflim;
	}

      /* If we've made it to this point, this means DFA has seen
	 a probable match, and we need to run it through Regex. */
      best_match = end;
      best_len = 0;
      for (i = 0; i < pcount; i++)
	{
	  patterns[i].regexbuf.not_eol = 0;
	  if (0 <= (start = re_search (&(patterns[i].regexbuf),
				       buf, end - buf - 1,
				       beg - buf, end - beg - 1,
				       &(patterns[i].regs))))
	    {
	      len = patterns[i].regs.end[0] - start;
	      match = buf + start;
	      if (match > best_match)
		continue;
	      if (start_ptr && !match_words)
		goto assess_pattern_match;
	      if ((!match_lines && !match_words)
		  || (match_lines && len == end - beg - 1))
		{
		  match = beg;
		  len = end - beg;
		  goto assess_pattern_match;
		}
	      /* If -w, check if the match aligns with word boundaries.
		 We do this iteratively because:
		 (a) the line may contain more than one occurence of the
		 pattern, and
		 (b) Several alternatives in the pattern might be valid at a
		 given point, and we may need to consider a shorter one to
		 find a word boundary.  */
	      if (match_words)
		while (match <= best_match)
		  {
		    if ((match == buf || !WCHAR ((unsigned char) match[-1]))
			&& (len == end - beg - 1
			    || !WCHAR ((unsigned char) match[len])))
		      goto assess_pattern_match;
		    if (len > 0)
		      {
			/* Try a shorter length anchored at the same place. */
			--len;
			patterns[i].regexbuf.not_eol = 1;
			len = re_match (&(patterns[i].regexbuf),
					buf, match + len - beg, match - buf,
					&(patterns[i].regs));
		      }
		    if (len <= 0)
		      {
			/* Try looking further on. */
			if (match == end - 1)
			  break;
			match++;
			patterns[i].regexbuf.not_eol = 0;
			start = re_search (&(patterns[i].regexbuf),
					   buf, end - buf - 1,
					   match - buf, end - match - 1,
					   &(patterns[i].regs));
			if (start < 0)
			  break;
			len = patterns[i].regs.end[0] - start;
			match = buf + start;
		      }
		  } /* while (match <= best_match) */
	      continue;
	    assess_pattern_match:
	      if (!start_ptr)
		{
		  /* Good enough for a non-exact match.
		     No need to look at further patterns, if any.  */
		  beg = match;
		  goto success_in_len;
		}
	      if (match < best_match || (match == best_match && len > best_len))
		{
		  /* Best exact match:  leftmost, then longest.  */
		  best_match = match;
		  best_len = len;
		}
	    } /* if re_search >= 0 */
	} /* for Regex patterns.  */
	if (best_match < end)
	  {
	    /* We have found an exact match.  We were just
	       waiting for the best one (leftmost then longest).  */
	    beg = best_match;
	    len = best_len;
	    goto success_in_len;
	  }
    } /* for (beg = end ..) */

 failure:
  ret_val = -1;
  goto out;

 success:
  len = end - beg;
 success_in_len:
  *match_size = len;
  ret_val = beg - buf;
 out:
  return ret_val;
}
#endif /* defined(GREP_PROGRAM) || defined(EGREP_PROGRAM) */

#if defined(GREP_PROGRAM) || defined(FGREP_PROGRAM)
COMPILE_FCT(Fcompile)
{
  char const *beg, *end, *lim, *err, *pat;
  size_t psize;

  kwsinit ();
  psize = size;
  
//Patch 0:
if (((match_icase) || (__is_neg(10, &(match_icase), sizeof (match_icase), &(pattern), sizeof (pattern), &(size), sizeof (size), &(pat), sizeof (pat), &(psize), sizeof (psize), &(beg), sizeof (beg), &(lim), sizeof (lim), &(end), sizeof (end), &(err), sizeof (err), &(kwset), sizeof (kwset)))) && (__ctype_get_mb_cur_max()) > 1)
    pat = mbtolower(pattern, &psize);
else
    pat = pattern;

//CodeSeg 1:

  beg = pat;
  do
    {
      for (lim = beg;; ++lim)
	{
	  end = lim;
	  if (lim >= pat + psize)
	    break;
	 if (*lim == '\n')
	   {
	     lim++;
	     break;
	   }
#if HAVE_DOS_FILE_CONTENTS
	 if (*lim == '\r' && lim + 1 < pat + psize && lim[1] == '\n')
	   {
	     lim += 2;
	     break;
	   }
#endif
	}

      if ((err = kwsincr (kwset, beg, end - beg)) != NULL)
	error (EXIT_TROUBLE, 0, "%s", err);
      beg = lim;
    }
  while (beg < pat + psize);

  if ((err = kwsprep (kwset)) != NULL)
    error (EXIT_TROUBLE, 0, "%s", err);
}

EXECUTE_FCT(Fexecute)
{
  char const *beg, *try, *end, *mb_start;
  size_t len;
  char eol = eolbyte;
  struct kwsmatch kwsmatch;
  size_t ret_val;
#ifdef MBS_SUPPORT
  if (MB_CUR_MAX > 1)
    {
      if (match_icase)
        {
          char *case_buf = mbtolower (buf, &size);
	  if (start_ptr)
	    start_ptr = case_buf + (start_ptr - buf);
          buf = case_buf;
        }
    }
#endif /* MBS_SUPPORT */

  for (mb_start = beg = start_ptr ? start_ptr : buf; beg <= buf + size; beg++)
    {
      size_t offset = kwsexec (kwset, beg, buf + size - beg, &kwsmatch);
      if (offset == (size_t) -1)
	goto failure;
#ifdef MBS_SUPPORT
      if (MB_CUR_MAX > 1 && is_mb_middle (&mb_start, beg + offset, buf + size))
        {
          beg = mb_start - 1;
          continue; /* It is a part of multibyte character.  */
        }
#endif /* MBS_SUPPORT */
      beg += offset;
      len = kwsmatch.size[0];
      if (start_ptr && !match_words)
	goto success_in_beg_and_len;
      if (match_lines)
	{
	  if (beg > buf && beg[-1] != eol)
	    continue;
	  if (beg + len < buf + size && beg[len] != eol)
	    continue;
	  goto success;
	}
      else if (match_words)
	for (try = beg; len; )
	  {
	    if (try > buf && WCHAR((unsigned char) try[-1]))
	      break;
	    if (try + len < buf + size && WCHAR((unsigned char) try[len]))
	      {
		offset = kwsexec (kwset, beg, --len, &kwsmatch);
		if (offset == (size_t) -1)
		  break;
		try = beg + offset;
		len = kwsmatch.size[0];
	      }
	    else if (!start_ptr)
	      goto success;
	    else
	      goto success_in_beg_and_len;
	  } /* for (try) */
      else
	goto success;
    } /* for (beg in buf) */

 failure:
  ret_val = -1;
  goto out;

 success:
  if ((end = memchr (beg + len, eol, (buf + size) - (beg + len))) != NULL)
    end++;
  else
    end = buf + size;
  while (buf < beg && beg[-1] != eol)
    --beg;
  len = end - beg;
 success_in_beg_and_len:
  *match_size = len;
  ret_val = beg - buf;
 out:
  return ret_val;
}
#endif /* defined(GREP_PROGRAM) || defined(FGREP_PROGRAM) */

#ifdef GREP_PROGRAM
#if HAVE_LIBPCRE
/* Compiled internal form of a Perl regular expression.  */
static pcre *cre;

/* Additional information about the pattern.  */
static pcre_extra *extra;
#endif

COMPILE_FCT(Pcompile)
{
#if !HAVE_LIBPCRE
  error (EXIT_TROUBLE, 0, "%s",
	 _("support for the -P option is not compiled into "
	   "this --disable-perl-regexp binary"));
#else
  int e;
  char const *ep;
  char *re = xmalloc (4 * size + 7);
  int flags = PCRE_MULTILINE | (match_icase ? PCRE_CASELESS : 0);
  char const *patlim = pattern + size;
  char *n = re;
  char const *p;
  char const *pnul;

  /* FIXME: Remove these restrictions.  */
  if (memchr(pattern, '\n', size))
    error (EXIT_TROUBLE, 0, _("the -P option only supports a single pattern"));

  *n = '\0';
  if (match_lines)
    strcpy (n, "^(");
  if (match_words)
    strcpy (n, "\\b(");
  n += strlen (n);

  /* The PCRE interface doesn't allow NUL bytes in the pattern, so
     replace each NUL byte in the pattern with the four characters
     "\000", removing a preceding backslash if there are an odd
     number of backslashes before the NUL.

     FIXME: This method does not work with some multibyte character
     encodings, notably Shift-JIS, where a multibyte character can end
     in a backslash byte.  */
  for (p = pattern; (pnul = memchr (p, '\0', patlim - p)); p = pnul + 1)
    {
      memcpy (n, p, pnul - p);
      n += pnul - p;
      for (p = pnul; pattern < p && p[-1] == '\\'; p--)
	continue;
      n -= (pnul - p) & 1;
      strcpy (n, "\\000");
      n += 4;
    }

  memcpy (n, p, patlim - p);
  n += patlim - p;
  *n = '\0';
  if (match_words)
    strcpy (n, ")\\b");
  if (match_lines)
    strcpy (n, ")$");

  cre = pcre_compile (re, flags, &ep, &e, pcre_maketables ());
  if (!cre)
    error (EXIT_TROUBLE, 0, "%s", ep);

  extra = pcre_study (cre, 0, &ep);
  if (ep)
    error (EXIT_TROUBLE, 0, "%s", ep);

  free (re);
#endif
}

EXECUTE_FCT(Pexecute)
{
#if !HAVE_LIBPCRE
  abort ();
  return -1;
#else
  /* This array must have at least two elements; everything after that
     is just for performance improvement in pcre_exec.  */
  int sub[300];

  const char *line_buf, *line_end, *line_next;
  int e = PCRE_ERROR_NOMATCH;
  ptrdiff_t start_ofs = start_ptr ? start_ptr - buf : 0;

  /* PCRE can't limit the matching to single lines, therefore we have to
     match each line in the buffer separately.  */
  for (line_next = buf;
       e == PCRE_ERROR_NOMATCH && line_next < buf + size;
       start_ofs -= line_next - line_buf)
    {
      line_buf = line_next;
      line_end = memchr (line_buf, eolbyte, (buf + size) - line_buf);
      if (line_end == NULL)
        line_next = line_end = buf + size;
      else
        line_next = line_end + 1;

      if (start_ptr && start_ptr >= line_end)
        continue;

      e = pcre_exec (cre, extra, line_buf, line_end - line_buf,
                     start_ofs < 0 ? 0 : start_ofs, 0,
                     sub, sizeof sub / sizeof *sub);
    }

  if (e <= 0)
    {
      switch (e)
	{
	case PCRE_ERROR_NOMATCH:
	  return -1;

	case PCRE_ERROR_NOMEMORY:
	  error (EXIT_TROUBLE, 0, _("memory exhausted"));

	default:
	  abort ();
	}
    }
  else
    {
      /* Narrow down to the line we've found.  */
      char const *beg = line_buf + sub[0];
      char const *end = line_buf + sub[1];
      char const *buflim = buf + size;
      char eol = eolbyte;
      if (!start_ptr)
	{
	  /* FIXME: The case when '\n' is not found indicates a bug:
	     Since grep is line oriented, the match should never contain
	     a newline, so there _must_ be a newline following.
	   */
	  if (!(end = memchr (end, eol, buflim - end)))
	    end = buflim;
	  else
	    end++;
	  while (buf < beg && beg[-1] != eol)
	    --beg;
	}

      *match_size = end - beg;
      return beg - buf;
    }
#endif
}

struct matcher const matchers[] = {
  { "default", Gcompile, EGexecute },
  { "grep",    Gcompile, EGexecute },
  { "egrep",   Ecompile, EGexecute },
  { "awk",     Acompile, EGexecute },
  { "fgrep",   Fcompile, Fexecute },
  { "perl",    Pcompile, Pexecute },
  { "", 0, 0 },
};
#endif /* GREP_PROGRAM */

Spawn 1 instances, now Total 6
Counter: 7
Batcher Size:6
Preprocess the following candidate with CondTester:
Priority 20000
At location src/search.c:243
--Src File: src/search.c
Fragment 0:
if ((mbclen != (size_t)-2) && !(__abst_hole(mbclen, p, prev, end, buf, good)))
    prev = p;


CondTester, a patch instance with id 6:
//src_file:src/search.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
/* search.c - searching subroutines using dfa, kwset and regex for grep.
   Copyright 1992, 1998, 2000, 2007, 2009-2010 Free Software Foundation, Inc.

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 3, or (at your option)
   any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program; if not, write to the Free Software
   Foundation, Inc., 51 Franklin Street - Fifth Floor, Boston, MA
   02110-1301, USA.  */

/* Written August 1992 by Mike Haertel. */

#include <config.h>

#include <sys/types.h>

#include "mbsupport.h"
#ifdef MBS_SUPPORT
/* We can handle multibyte strings. */
# include <wchar.h>
# include <wctype.h>
#endif

#include "system.h"
#include "grep.h"
#ifndef FGREP_PROGRAM
# include <regex.h>
# include "dfa.h"
#endif
#include "kwset.h"
#include "error.h"
#include "xalloc.h"
#ifdef HAVE_LIBPCRE
# include <pcre.h>
#endif

#define NCHAR (UCHAR_MAX + 1)

/* For -w, we also consider _ to be word constituent.  */
#define WCHAR(C) (ISALNUM(C) || (C) == '_')

/* KWset compiled pattern.  For Ecompile and Gcompile, we compile
   a list of strings, at least one of which is known to occur in
   any string matching the regexp. */
static kwset_t kwset;

static void
kwsinit (void)
{
  static char trans[NCHAR];
  int i;

  if (match_icase && MB_CUR_MAX == 1)
    {
      for (i = 0; i < NCHAR; ++i)
        trans[i] = TOLOWER (i);

      kwset = kwsalloc (trans);
    }
  else
    kwset = kwsalloc (NULL);

  if (!kwset)
    xalloc_die ();
}

#ifdef MBS_SUPPORT
/* Convert the *N-byte string, BEG, to lowercase, and write the
   NUL-terminated result into malloc'd storage.  Upon success, set *N
   to the length (in bytes) of the resulting string (not including the
   trailing NUL byte), and return a pointer to the lowercase string.
   Upon memory allocation failure, this function exits.

   Note that while this function returns a pointer to malloc'd storage,
   the caller must not free it, since this function retains a pointer
   to the buffer and reuses it on any subsequent call.  As a consequence,
   this function is not thread-safe.  */
static char *
mbtolower (const char *beg, size_t *n)
{
  static char *out;
  static size_t outalloc;
  size_t outlen, mb_cur_max;
  mbstate_t is, os;
  const char *end;
  char *p;

  if (*n > outalloc)
    {
      out = xrealloc (out, *n);
      outalloc = *n;
    }

  memset (&is, 0, sizeof (is));
  memset (&os, 0, sizeof (os));
  end = beg + *n;

  mb_cur_max = MB_CUR_MAX;
  p = out;
  outlen = 0;
  while (beg < end)
    {
      wchar_t wc;
      size_t mbclen = mbrtowc(&wc, beg, end - beg, &is);
      if (outlen + mb_cur_max >= outalloc)
        {
          out = x2nrealloc (out, &outalloc, 1);
          p = out + outlen;
        }

      if (mbclen == (size_t) -1 || mbclen == (size_t) -2 || mbclen == 0)
        {
          /* An invalid sequence, or a truncated multi-octet character.
             We treat it as a single-octet character.  */
          *p++ = *beg++;
          outlen++;
          memset (&is, 0, sizeof (is));
          memset (&os, 0, sizeof (os));
        }
      else
        {
          beg += mbclen;
          mbclen = wcrtomb (p, towlower ((wint_t) wc), &os);
          p += mbclen;
          outlen += mbclen;
        }
    }

  *n = p - out;
  *p++ = 0;
  return out;
}
#endif


#ifndef FGREP_PROGRAM
/* DFA compiled regexp. */
static struct dfa dfa;

/* The Regex compiled patterns.  */
static struct patterns
{
  /* Regex compiled regexp. */
  struct re_pattern_buffer regexbuf;
  struct re_registers regs; /* This is here on account of a BRAIN-DEAD
			       Q@#%!# library interface in regex.c.  */
} patterns0;

struct patterns *patterns;
size_t pcount;

void
dfaerror (char const *mesg)
{
  error (EXIT_TROUBLE, 0, "%s", mesg);
}

/* Number of compiled fixed strings known to exactly match the regexp.
   If kwsexec returns < kwset_exact_matches, then we don't need to
   call the regexp matcher at all. */
static int kwset_exact_matches;

static char const *
kwsincr_case (const char *must)
{
  const char *buf;
  size_t n;

  n = strlen (must);
#ifdef MBS_SUPPORT
  if (match_icase && MB_CUR_MAX > 1)
    buf = mbtolower (must, &n);
  else
#endif
    buf = must;
  return kwsincr (kwset, buf, n);
}

/* If the DFA turns out to have some set of fixed strings one of
   which must occur in the match, then we build a kwset matcher
   to find those strings, and thus quickly filter out impossible
   matches. */
static void
kwsmusts (void)
{
  struct dfamust const *dm;
  char const *err;

  if (dfa.musts)
    {
      kwsinit ();
      /* First, we compile in the substrings known to be exact
	 matches.  The kwset matcher will return the index
	 of the matching string that it chooses. */
      for (dm = dfa.musts; dm; dm = dm->next)
	{
	  if (!dm->exact)
	    continue;
	  ++kwset_exact_matches;
	  if ((err = kwsincr_case (dm->must)) != NULL)
	    error (EXIT_TROUBLE, 0, "%s", err);
	}
      /* Now, we compile the substrings that will require
	 the use of the regexp matcher.  */
      for (dm = dfa.musts; dm; dm = dm->next)
	{
	  if (dm->exact)
	    continue;
	  if ((err = kwsincr_case (dm->must)) != NULL)
	    error (EXIT_TROUBLE, 0, "%s", err);
	}
      if ((err = kwsprep (kwset)) != NULL)
	error (EXIT_TROUBLE, 0, "%s", err);
    }
}
#endif /* !FGREP_PROGRAM */

#ifdef MBS_SUPPORT

static bool
is_mb_middle(const char **good, const char *buf, const char *end)
{
  const char *p = *good;
  const char *prev = p;
  mbstate_t cur_state;

  /* TODO: can be optimized for UTF-8.  */
  memset(&cur_state, 0, sizeof(mbstate_t));
  while (p < buf)
    {
      size_t mbclen = mbrlen(p, end - p, &cur_state);

      /* Store the beginning of the previous complete multibyte character.  */
      
//Patch 0:
if ((mbclen != (size_t)-2) && !(__is_neg(6, &(mbclen), sizeof (mbclen), &(p), sizeof (p), &(prev), sizeof (prev), &(end), sizeof (end), &(buf), sizeof (buf), &(good), sizeof (good))))
    prev = p;

//CodeSeg 1:

      if (mbclen == (size_t) -1 || mbclen == (size_t) -2 || mbclen == 0)
	{
	  /* An invalid sequence, or a truncated multibyte character.
	     We treat it as a single byte character.  */
	  mbclen = 1;
	}
      p += mbclen;
    }

  *good = prev;
  return p > buf;
}
#endif /* MBS_SUPPORT */

#if defined(GREP_PROGRAM) || defined(EGREP_PROGRAM)
#ifdef EGREP_PROGRAM
COMPILE_FCT(Ecompile)
{
  reg_syntax_t syntax_bits = RE_SYNTAX_POSIX_EGREP;
#else
/* No __VA_ARGS__ in C89.  So we have to do it this way.  */
static COMPILE_RET
GEAcompile (char const *pattern, size_t size, reg_syntax_t syntax_bits)
{
#endif /* EGREP_PROGRAM */
  const char *err;
  const char *p, *sep;
  size_t total = size;
  char *motif;

  if (match_icase)
    syntax_bits |= RE_ICASE;
  re_set_syntax (syntax_bits);
  dfasyntax (syntax_bits, match_icase, eolbyte);

  /* For GNU regex compiler we have to pass the patterns separately to detect
     errors like "[\nallo\n]\n".  The patterns here are "[", "allo" and "]"
     GNU regex should have raise a syntax error.  The same for backref, where
     the backref should have been local to each pattern.  */
  p = pattern;
  do
    {
      size_t len;
      sep = memchr (p, '\n', total);
      if (sep)
	{
	  len = sep - p;
	  sep++;
	  total -= (len + 1);
	}
      else
	{
	  len = total;
	  total = 0;
	}

      patterns = realloc (patterns, (pcount + 1) * sizeof (*patterns));
      if (patterns == NULL)
	error (EXIT_TROUBLE, errno, _("memory exhausted"));
      patterns[pcount] = patterns0;

      if ((err = re_compile_pattern (p, len,
				    &(patterns[pcount].regexbuf))) != NULL)
	error (EXIT_TROUBLE, 0, "%s", err);
      pcount++;

      p = sep;
    } while (sep && total != 0);

  /* In the match_words and match_lines cases, we use a different pattern
     for the DFA matcher that will quickly throw out cases that won't work.
     Then if DFA succeeds we do some hairy stuff using the regex matcher
     to decide whether the match should really count. */
  if (match_words || match_lines)
    {
      static char const line_beg_no_bk[] = "^(";
      static char const line_end_no_bk[] = ")$";
      static char const word_beg_no_bk[] = "(^|[^[:alnum:]_])(";
      static char const word_end_no_bk[] = ")([^[:alnum:]_]|$)";
#ifdef EGREP_PROGRAM
# define IF_BK(x, y) (y)
      char *n = xmalloc (sizeof word_beg_no_bk - 1 + size + sizeof word_end_no_bk);
#else
      static char const line_beg_bk[] = "^\\(";
      static char const line_end_bk[] = "\\)$";
      static char const word_beg_bk[] = "\\(^\\|[^[:alnum:]_]\\)\\(";
      static char const word_end_bk[] = "\\)\\([^[:alnum:]_]\\|$\\)";
      int bk = !(syntax_bits & RE_NO_BK_PARENS);
# define IF_BK(x, y) ((bk) ? (x) : (y))
      char *n = xmalloc (sizeof word_beg_bk - 1 + size + sizeof word_end_bk);
#endif /* EGREP_PROGRAM */

      strcpy (n, match_lines ? IF_BK(line_beg_bk, line_beg_no_bk)
			     : IF_BK(word_beg_bk, word_beg_no_bk));
      total = strlen(n);
      memcpy (n + total, pattern, size);
      total += size;
      strcpy (n + total, match_lines ? IF_BK(line_end_bk, line_end_no_bk)
				     : IF_BK(word_end_bk, word_end_no_bk));
      total += strlen (n + total);
      pattern = motif = n;
      size = total;
    }
  else
    motif = NULL;

  dfacomp (pattern, size, &dfa, 1);
  kwsmusts ();

  free(motif);
}

#ifndef EGREP_PROGRAM
COMPILE_FCT(Gcompile)
{
  return GEAcompile (pattern, size,
		     RE_SYNTAX_GREP | RE_HAT_LISTS_NOT_NEWLINE);
}

COMPILE_FCT(Acompile)
{
  return GEAcompile (pattern, size, RE_SYNTAX_AWK);
}

COMPILE_FCT(Ecompile)
{
  return GEAcompile (pattern, size, RE_SYNTAX_POSIX_EGREP);
}
#endif /* !EGREP_PROGRAM */

EXECUTE_FCT(EGexecute)
{
  char const *buflim, *beg, *end, *match, *best_match, *mb_start;
  char eol = eolbyte;
  int backref, start, len, best_len;
  struct kwsmatch kwsm;
  size_t i, ret_val;
#ifdef MBS_SUPPORT
  if (MB_CUR_MAX > 1)
    {
      if (match_icase)
        {
          /* mbtolower adds a NUL byte at the end.  That will provide
	     space for the sentinel byte dfaexec may add.  */
          char *case_buf = mbtolower (buf, &size);
	  if (start_ptr)
	    start_ptr = case_buf + (start_ptr - buf);
          buf = case_buf;
        }
    }
#endif /* MBS_SUPPORT */

  mb_start = buf;
  buflim = buf + size;

  for (beg = end = buf; end < buflim; beg = end)
    {
      if (!start_ptr)
	{
	  /* We don't care about an exact match.  */
	  if (kwset)
	    {
	      /* Find a possible match using the KWset matcher. */
	      size_t offset = kwsexec (kwset, beg, buflim - beg, &kwsm);
	      if (offset == (size_t) -1)
		goto failure;
	      beg += offset;
	      /* Narrow down to the line containing the candidate, and
		 run it through DFA. */
	      if ((end = memchr(beg, eol, buflim - beg)) != NULL)
	        end++;
              else
                end = buflim;
	      match = beg;
	      while (beg > buf && beg[-1] != eol)
		--beg;
	      if (kwsm.index < kwset_exact_matches)
                {
#ifdef MBS_SUPPORT
                  if (mb_start < beg)
                    mb_start = beg;
                  if (MB_CUR_MAX == 1 || !is_mb_middle (&mb_start, match, buflim))
#endif
                    goto success;
                }
	      if (dfaexec (&dfa, beg, (char *) end, 0, NULL, &backref) == NULL)
		continue;
	    }
	  else
	    {
	      /* No good fixed strings; start with DFA. */
	      char const *next_beg = dfaexec (&dfa, beg, (char *) buflim,
					      0, NULL, &backref);
	      if (next_beg == NULL)
		break;
	      /* Narrow down to the line we've found. */
	      beg = next_beg;
	      if ((end = memchr(beg, eol, buflim - beg)) != NULL)
	        end++;
              else
                end = buflim;
	      while (beg > buf && beg[-1] != eol)
		--beg;
	    }
	  /* Successful, no backreferences encountered! */
	  if (!backref)
	    goto success;
	}
      else
	{
	  /* We are looking for the leftmost (then longest) exact match.
	     We will go through the outer loop only once.  */
	  beg = start_ptr;
	  end = buflim;
	}

      /* If we've made it to this point, this means DFA has seen
	 a probable match, and we need to run it through Regex. */
      best_match = end;
      best_len = 0;
      for (i = 0; i < pcount; i++)
	{
	  patterns[i].regexbuf.not_eol = 0;
	  if (0 <= (start = re_search (&(patterns[i].regexbuf),
				       buf, end - buf - 1,
				       beg - buf, end - beg - 1,
				       &(patterns[i].regs))))
	    {
	      len = patterns[i].regs.end[0] - start;
	      match = buf + start;
	      if (match > best_match)
		continue;
	      if (start_ptr && !match_words)
		goto assess_pattern_match;
	      if ((!match_lines && !match_words)
		  || (match_lines && len == end - beg - 1))
		{
		  match = beg;
		  len = end - beg;
		  goto assess_pattern_match;
		}
	      /* If -w, check if the match aligns with word boundaries.
		 We do this iteratively because:
		 (a) the line may contain more than one occurence of the
		 pattern, and
		 (b) Several alternatives in the pattern might be valid at a
		 given point, and we may need to consider a shorter one to
		 find a word boundary.  */
	      if (match_words)
		while (match <= best_match)
		  {
		    if ((match == buf || !WCHAR ((unsigned char) match[-1]))
			&& (len == end - beg - 1
			    || !WCHAR ((unsigned char) match[len])))
		      goto assess_pattern_match;
		    if (len > 0)
		      {
			/* Try a shorter length anchored at the same place. */
			--len;
			patterns[i].regexbuf.not_eol = 1;
			len = re_match (&(patterns[i].regexbuf),
					buf, match + len - beg, match - buf,
					&(patterns[i].regs));
		      }
		    if (len <= 0)
		      {
			/* Try looking further on. */
			if (match == end - 1)
			  break;
			match++;
			patterns[i].regexbuf.not_eol = 0;
			start = re_search (&(patterns[i].regexbuf),
					   buf, end - buf - 1,
					   match - buf, end - match - 1,
					   &(patterns[i].regs));
			if (start < 0)
			  break;
			len = patterns[i].regs.end[0] - start;
			match = buf + start;
		      }
		  } /* while (match <= best_match) */
	      continue;
	    assess_pattern_match:
	      if (!start_ptr)
		{
		  /* Good enough for a non-exact match.
		     No need to look at further patterns, if any.  */
		  beg = match;
		  goto success_in_len;
		}
	      if (match < best_match || (match == best_match && len > best_len))
		{
		  /* Best exact match:  leftmost, then longest.  */
		  best_match = match;
		  best_len = len;
		}
	    } /* if re_search >= 0 */
	} /* for Regex patterns.  */
	if (best_match < end)
	  {
	    /* We have found an exact match.  We were just
	       waiting for the best one (leftmost then longest).  */
	    beg = best_match;
	    len = best_len;
	    goto success_in_len;
	  }
    } /* for (beg = end ..) */

 failure:
  ret_val = -1;
  goto out;

 success:
  len = end - beg;
 success_in_len:
  *match_size = len;
  ret_val = beg - buf;
 out:
  return ret_val;
}
#endif /* defined(GREP_PROGRAM) || defined(EGREP_PROGRAM) */

#if defined(GREP_PROGRAM) || defined(FGREP_PROGRAM)
COMPILE_FCT(Fcompile)
{
  char const *beg, *end, *lim, *err, *pat;
  size_t psize;

  kwsinit ();
  psize = size;
  if (match_icase && MB_CUR_MAX > 1)
    pat = mbtolower (pattern, &psize);
  else
    pat = pattern;

  beg = pat;
  do
    {
      for (lim = beg;; ++lim)
	{
	  end = lim;
	  if (lim >= pat + psize)
	    break;
	 if (*lim == '\n')
	   {
	     lim++;
	     break;
	   }
#if HAVE_DOS_FILE_CONTENTS
	 if (*lim == '\r' && lim + 1 < pat + psize && lim[1] == '\n')
	   {
	     lim += 2;
	     break;
	   }
#endif
	}

      if ((err = kwsincr (kwset, beg, end - beg)) != NULL)
	error (EXIT_TROUBLE, 0, "%s", err);
      beg = lim;
    }
  while (beg < pat + psize);

  if ((err = kwsprep (kwset)) != NULL)
    error (EXIT_TROUBLE, 0, "%s", err);
}

EXECUTE_FCT(Fexecute)
{
  char const *beg, *try, *end, *mb_start;
  size_t len;
  char eol = eolbyte;
  struct kwsmatch kwsmatch;
  size_t ret_val;
#ifdef MBS_SUPPORT
  if (MB_CUR_MAX > 1)
    {
      if (match_icase)
        {
          char *case_buf = mbtolower (buf, &size);
	  if (start_ptr)
	    start_ptr = case_buf + (start_ptr - buf);
          buf = case_buf;
        }
    }
#endif /* MBS_SUPPORT */

  for (mb_start = beg = start_ptr ? start_ptr : buf; beg <= buf + size; beg++)
    {
      size_t offset = kwsexec (kwset, beg, buf + size - beg, &kwsmatch);
      if (offset == (size_t) -1)
	goto failure;
#ifdef MBS_SUPPORT
      if (MB_CUR_MAX > 1 && is_mb_middle (&mb_start, beg + offset, buf + size))
        {
          beg = mb_start - 1;
          continue; /* It is a part of multibyte character.  */
        }
#endif /* MBS_SUPPORT */
      beg += offset;
      len = kwsmatch.size[0];
      if (start_ptr && !match_words)
	goto success_in_beg_and_len;
      if (match_lines)
	{
	  if (beg > buf && beg[-1] != eol)
	    continue;
	  if (beg + len < buf + size && beg[len] != eol)
	    continue;
	  goto success;
	}
      else if (match_words)
	for (try = beg; len; )
	  {
	    if (try > buf && WCHAR((unsigned char) try[-1]))
	      break;
	    if (try + len < buf + size && WCHAR((unsigned char) try[len]))
	      {
		offset = kwsexec (kwset, beg, --len, &kwsmatch);
		if (offset == (size_t) -1)
		  break;
		try = beg + offset;
		len = kwsmatch.size[0];
	      }
	    else if (!start_ptr)
	      goto success;
	    else
	      goto success_in_beg_and_len;
	  } /* for (try) */
      else
	goto success;
    } /* for (beg in buf) */

 failure:
  ret_val = -1;
  goto out;

 success:
  if ((end = memchr (beg + len, eol, (buf + size) - (beg + len))) != NULL)
    end++;
  else
    end = buf + size;
  while (buf < beg && beg[-1] != eol)
    --beg;
  len = end - beg;
 success_in_beg_and_len:
  *match_size = len;
  ret_val = beg - buf;
 out:
  return ret_val;
}
#endif /* defined(GREP_PROGRAM) || defined(FGREP_PROGRAM) */

#ifdef GREP_PROGRAM
#if HAVE_LIBPCRE
/* Compiled internal form of a Perl regular expression.  */
static pcre *cre;

/* Additional information about the pattern.  */
static pcre_extra *extra;
#endif

COMPILE_FCT(Pcompile)
{
#if !HAVE_LIBPCRE
  error (EXIT_TROUBLE, 0, "%s",
	 _("support for the -P option is not compiled into "
	   "this --disable-perl-regexp binary"));
#else
  int e;
  char const *ep;
  char *re = xmalloc (4 * size + 7);
  int flags = PCRE_MULTILINE | (match_icase ? PCRE_CASELESS : 0);
  char const *patlim = pattern + size;
  char *n = re;
  char const *p;
  char const *pnul;

  /* FIXME: Remove these restrictions.  */
  if (memchr(pattern, '\n', size))
    error (EXIT_TROUBLE, 0, _("the -P option only supports a single pattern"));

  *n = '\0';
  if (match_lines)
    strcpy (n, "^(");
  if (match_words)
    strcpy (n, "\\b(");
  n += strlen (n);

  /* The PCRE interface doesn't allow NUL bytes in the pattern, so
     replace each NUL byte in the pattern with the four characters
     "\000", removing a preceding backslash if there are an odd
     number of backslashes before the NUL.

     FIXME: This method does not work with some multibyte character
     encodings, notably Shift-JIS, where a multibyte character can end
     in a backslash byte.  */
  for (p = pattern; (pnul = memchr (p, '\0', patlim - p)); p = pnul + 1)
    {
      memcpy (n, p, pnul - p);
      n += pnul - p;
      for (p = pnul; pattern < p && p[-1] == '\\'; p--)
	continue;
      n -= (pnul - p) & 1;
      strcpy (n, "\\000");
      n += 4;
    }

  memcpy (n, p, patlim - p);
  n += patlim - p;
  *n = '\0';
  if (match_words)
    strcpy (n, ")\\b");
  if (match_lines)
    strcpy (n, ")$");

  cre = pcre_compile (re, flags, &ep, &e, pcre_maketables ());
  if (!cre)
    error (EXIT_TROUBLE, 0, "%s", ep);

  extra = pcre_study (cre, 0, &ep);
  if (ep)
    error (EXIT_TROUBLE, 0, "%s", ep);

  free (re);
#endif
}

EXECUTE_FCT(Pexecute)
{
#if !HAVE_LIBPCRE
  abort ();
  return -1;
#else
  /* This array must have at least two elements; everything after that
     is just for performance improvement in pcre_exec.  */
  int sub[300];

  const char *line_buf, *line_end, *line_next;
  int e = PCRE_ERROR_NOMATCH;
  ptrdiff_t start_ofs = start_ptr ? start_ptr - buf : 0;

  /* PCRE can't limit the matching to single lines, therefore we have to
     match each line in the buffer separately.  */
  for (line_next = buf;
       e == PCRE_ERROR_NOMATCH && line_next < buf + size;
       start_ofs -= line_next - line_buf)
    {
      line_buf = line_next;
      line_end = memchr (line_buf, eolbyte, (buf + size) - line_buf);
      if (line_end == NULL)
        line_next = line_end = buf + size;
      else
        line_next = line_end + 1;

      if (start_ptr && start_ptr >= line_end)
        continue;

      e = pcre_exec (cre, extra, line_buf, line_end - line_buf,
                     start_ofs < 0 ? 0 : start_ofs, 0,
                     sub, sizeof sub / sizeof *sub);
    }

  if (e <= 0)
    {
      switch (e)
	{
	case PCRE_ERROR_NOMATCH:
	  return -1;

	case PCRE_ERROR_NOMEMORY:
	  error (EXIT_TROUBLE, 0, _("memory exhausted"));

	default:
	  abort ();
	}
    }
  else
    {
      /* Narrow down to the line we've found.  */
      char const *beg = line_buf + sub[0];
      char const *end = line_buf + sub[1];
      char const *buflim = buf + size;
      char eol = eolbyte;
      if (!start_ptr)
	{
	  /* FIXME: The case when '\n' is not found indicates a bug:
	     Since grep is line oriented, the match should never contain
	     a newline, so there _must_ be a newline following.
	   */
	  if (!(end = memchr (end, eol, buflim - end)))
	    end = buflim;
	  else
	    end++;
	  while (buf < beg && beg[-1] != eol)
	    --beg;
	}

      *match_size = end - beg;
      return beg - buf;
    }
#endif
}

struct matcher const matchers[] = {
  { "default", Gcompile, EGexecute },
  { "grep",    Gcompile, EGexecute },
  { "egrep",   Ecompile, EGexecute },
  { "awk",     Acompile, EGexecute },
  { "fgrep",   Fcompile, Fexecute },
  { "perl",    Pcompile, Pexecute },
  { "", 0, 0 },
};
#endif /* GREP_PROGRAM */

Spawn 1 instances, now Total 7
Counter: 8
Batcher Size:7
Preprocess the following candidate with CondTester:
Priority 20000
At location src/search.c:243
--Src File: src/search.c
Fragment 0:
if ((mbclen != (size_t)-2) || (__abst_hole(mbclen, p, prev, end, buf, good)))
    prev = p;


CondTester, a patch instance with id 7:
//src_file:src/search.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
/* search.c - searching subroutines using dfa, kwset and regex for grep.
   Copyright 1992, 1998, 2000, 2007, 2009-2010 Free Software Foundation, Inc.

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 3, or (at your option)
   any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program; if not, write to the Free Software
   Foundation, Inc., 51 Franklin Street - Fifth Floor, Boston, MA
   02110-1301, USA.  */

/* Written August 1992 by Mike Haertel. */

#include <config.h>

#include <sys/types.h>

#include "mbsupport.h"
#ifdef MBS_SUPPORT
/* We can handle multibyte strings. */
# include <wchar.h>
# include <wctype.h>
#endif

#include "system.h"
#include "grep.h"
#ifndef FGREP_PROGRAM
# include <regex.h>
# include "dfa.h"
#endif
#include "kwset.h"
#include "error.h"
#include "xalloc.h"
#ifdef HAVE_LIBPCRE
# include <pcre.h>
#endif

#define NCHAR (UCHAR_MAX + 1)

/* For -w, we also consider _ to be word constituent.  */
#define WCHAR(C) (ISALNUM(C) || (C) == '_')

/* KWset compiled pattern.  For Ecompile and Gcompile, we compile
   a list of strings, at least one of which is known to occur in
   any string matching the regexp. */
static kwset_t kwset;

static void
kwsinit (void)
{
  static char trans[NCHAR];
  int i;

  if (match_icase && MB_CUR_MAX == 1)
    {
      for (i = 0; i < NCHAR; ++i)
        trans[i] = TOLOWER (i);

      kwset = kwsalloc (trans);
    }
  else
    kwset = kwsalloc (NULL);

  if (!kwset)
    xalloc_die ();
}

#ifdef MBS_SUPPORT
/* Convert the *N-byte string, BEG, to lowercase, and write the
   NUL-terminated result into malloc'd storage.  Upon success, set *N
   to the length (in bytes) of the resulting string (not including the
   trailing NUL byte), and return a pointer to the lowercase string.
   Upon memory allocation failure, this function exits.

   Note that while this function returns a pointer to malloc'd storage,
   the caller must not free it, since this function retains a pointer
   to the buffer and reuses it on any subsequent call.  As a consequence,
   this function is not thread-safe.  */
static char *
mbtolower (const char *beg, size_t *n)
{
  static char *out;
  static size_t outalloc;
  size_t outlen, mb_cur_max;
  mbstate_t is, os;
  const char *end;
  char *p;

  if (*n > outalloc)
    {
      out = xrealloc (out, *n);
      outalloc = *n;
    }

  memset (&is, 0, sizeof (is));
  memset (&os, 0, sizeof (os));
  end = beg + *n;

  mb_cur_max = MB_CUR_MAX;
  p = out;
  outlen = 0;
  while (beg < end)
    {
      wchar_t wc;
      size_t mbclen = mbrtowc(&wc, beg, end - beg, &is);
      if (outlen + mb_cur_max >= outalloc)
        {
          out = x2nrealloc (out, &outalloc, 1);
          p = out + outlen;
        }

      if (mbclen == (size_t) -1 || mbclen == (size_t) -2 || mbclen == 0)
        {
          /* An invalid sequence, or a truncated multi-octet character.
             We treat it as a single-octet character.  */
          *p++ = *beg++;
          outlen++;
          memset (&is, 0, sizeof (is));
          memset (&os, 0, sizeof (os));
        }
      else
        {
          beg += mbclen;
          mbclen = wcrtomb (p, towlower ((wint_t) wc), &os);
          p += mbclen;
          outlen += mbclen;
        }
    }

  *n = p - out;
  *p++ = 0;
  return out;
}
#endif


#ifndef FGREP_PROGRAM
/* DFA compiled regexp. */
static struct dfa dfa;

/* The Regex compiled patterns.  */
static struct patterns
{
  /* Regex compiled regexp. */
  struct re_pattern_buffer regexbuf;
  struct re_registers regs; /* This is here on account of a BRAIN-DEAD
			       Q@#%!# library interface in regex.c.  */
} patterns0;

struct patterns *patterns;
size_t pcount;

void
dfaerror (char const *mesg)
{
  error (EXIT_TROUBLE, 0, "%s", mesg);
}

/* Number of compiled fixed strings known to exactly match the regexp.
   If kwsexec returns < kwset_exact_matches, then we don't need to
   call the regexp matcher at all. */
static int kwset_exact_matches;

static char const *
kwsincr_case (const char *must)
{
  const char *buf;
  size_t n;

  n = strlen (must);
#ifdef MBS_SUPPORT
  if (match_icase && MB_CUR_MAX > 1)
    buf = mbtolower (must, &n);
  else
#endif
    buf = must;
  return kwsincr (kwset, buf, n);
}

/* If the DFA turns out to have some set of fixed strings one of
   which must occur in the match, then we build a kwset matcher
   to find those strings, and thus quickly filter out impossible
   matches. */
static void
kwsmusts (void)
{
  struct dfamust const *dm;
  char const *err;

  if (dfa.musts)
    {
      kwsinit ();
      /* First, we compile in the substrings known to be exact
	 matches.  The kwset matcher will return the index
	 of the matching string that it chooses. */
      for (dm = dfa.musts; dm; dm = dm->next)
	{
	  if (!dm->exact)
	    continue;
	  ++kwset_exact_matches;
	  if ((err = kwsincr_case (dm->must)) != NULL)
	    error (EXIT_TROUBLE, 0, "%s", err);
	}
      /* Now, we compile the substrings that will require
	 the use of the regexp matcher.  */
      for (dm = dfa.musts; dm; dm = dm->next)
	{
	  if (dm->exact)
	    continue;
	  if ((err = kwsincr_case (dm->must)) != NULL)
	    error (EXIT_TROUBLE, 0, "%s", err);
	}
      if ((err = kwsprep (kwset)) != NULL)
	error (EXIT_TROUBLE, 0, "%s", err);
    }
}
#endif /* !FGREP_PROGRAM */

#ifdef MBS_SUPPORT

static bool
is_mb_middle(const char **good, const char *buf, const char *end)
{
  const char *p = *good;
  const char *prev = p;
  mbstate_t cur_state;

  /* TODO: can be optimized for UTF-8.  */
  memset(&cur_state, 0, sizeof(mbstate_t));
  while (p < buf)
    {
      size_t mbclen = mbrlen(p, end - p, &cur_state);

      /* Store the beginning of the previous complete multibyte character.  */
      
//Patch 0:
if ((mbclen != (size_t)-2) || (__is_neg(6, &(mbclen), sizeof (mbclen), &(p), sizeof (p), &(prev), sizeof (prev), &(end), sizeof (end), &(buf), sizeof (buf), &(good), sizeof (good))))
    prev = p;

//CodeSeg 1:

      if (mbclen == (size_t) -1 || mbclen == (size_t) -2 || mbclen == 0)
	{
	  /* An invalid sequence, or a truncated multibyte character.
	     We treat it as a single byte character.  */
	  mbclen = 1;
	}
      p += mbclen;
    }

  *good = prev;
  return p > buf;
}
#endif /* MBS_SUPPORT */

#if defined(GREP_PROGRAM) || defined(EGREP_PROGRAM)
#ifdef EGREP_PROGRAM
COMPILE_FCT(Ecompile)
{
  reg_syntax_t syntax_bits = RE_SYNTAX_POSIX_EGREP;
#else
/* No __VA_ARGS__ in C89.  So we have to do it this way.  */
static COMPILE_RET
GEAcompile (char const *pattern, size_t size, reg_syntax_t syntax_bits)
{
#endif /* EGREP_PROGRAM */
  const char *err;
  const char *p, *sep;
  size_t total = size;
  char *motif;

  if (match_icase)
    syntax_bits |= RE_ICASE;
  re_set_syntax (syntax_bits);
  dfasyntax (syntax_bits, match_icase, eolbyte);

  /* For GNU regex compiler we have to pass the patterns separately to detect
     errors like "[\nallo\n]\n".  The patterns here are "[", "allo" and "]"
     GNU regex should have raise a syntax error.  The same for backref, where
     the backref should have been local to each pattern.  */
  p = pattern;
  do
    {
      size_t len;
      sep = memchr (p, '\n', total);
      if (sep)
	{
	  len = sep - p;
	  sep++;
	  total -= (len + 1);
	}
      else
	{
	  len = total;
	  total = 0;
	}

      patterns = realloc (patterns, (pcount + 1) * sizeof (*patterns));
      if (patterns == NULL)
	error (EXIT_TROUBLE, errno, _("memory exhausted"));
      patterns[pcount] = patterns0;

      if ((err = re_compile_pattern (p, len,
				    &(patterns[pcount].regexbuf))) != NULL)
	error (EXIT_TROUBLE, 0, "%s", err);
      pcount++;

      p = sep;
    } while (sep && total != 0);

  /* In the match_words and match_lines cases, we use a different pattern
     for the DFA matcher that will quickly throw out cases that won't work.
     Then if DFA succeeds we do some hairy stuff using the regex matcher
     to decide whether the match should really count. */
  if (match_words || match_lines)
    {
      static char const line_beg_no_bk[] = "^(";
      static char const line_end_no_bk[] = ")$";
      static char const word_beg_no_bk[] = "(^|[^[:alnum:]_])(";
      static char const word_end_no_bk[] = ")([^[:alnum:]_]|$)";
#ifdef EGREP_PROGRAM
# define IF_BK(x, y) (y)
      char *n = xmalloc (sizeof word_beg_no_bk - 1 + size + sizeof word_end_no_bk);
#else
      static char const line_beg_bk[] = "^\\(";
      static char const line_end_bk[] = "\\)$";
      static char const word_beg_bk[] = "\\(^\\|[^[:alnum:]_]\\)\\(";
      static char const word_end_bk[] = "\\)\\([^[:alnum:]_]\\|$\\)";
      int bk = !(syntax_bits & RE_NO_BK_PARENS);
# define IF_BK(x, y) ((bk) ? (x) : (y))
      char *n = xmalloc (sizeof word_beg_bk - 1 + size + sizeof word_end_bk);
#endif /* EGREP_PROGRAM */

      strcpy (n, match_lines ? IF_BK(line_beg_bk, line_beg_no_bk)
			     : IF_BK(word_beg_bk, word_beg_no_bk));
      total = strlen(n);
      memcpy (n + total, pattern, size);
      total += size;
      strcpy (n + total, match_lines ? IF_BK(line_end_bk, line_end_no_bk)
				     : IF_BK(word_end_bk, word_end_no_bk));
      total += strlen (n + total);
      pattern = motif = n;
      size = total;
    }
  else
    motif = NULL;

  dfacomp (pattern, size, &dfa, 1);
  kwsmusts ();

  free(motif);
}

#ifndef EGREP_PROGRAM
COMPILE_FCT(Gcompile)
{
  return GEAcompile (pattern, size,
		     RE_SYNTAX_GREP | RE_HAT_LISTS_NOT_NEWLINE);
}

COMPILE_FCT(Acompile)
{
  return GEAcompile (pattern, size, RE_SYNTAX_AWK);
}

COMPILE_FCT(Ecompile)
{
  return GEAcompile (pattern, size, RE_SYNTAX_POSIX_EGREP);
}
#endif /* !EGREP_PROGRAM */

EXECUTE_FCT(EGexecute)
{
  char const *buflim, *beg, *end, *match, *best_match, *mb_start;
  char eol = eolbyte;
  int backref, start, len, best_len;
  struct kwsmatch kwsm;
  size_t i, ret_val;
#ifdef MBS_SUPPORT
  if (MB_CUR_MAX > 1)
    {
      if (match_icase)
        {
          /* mbtolower adds a NUL byte at the end.  That will provide
	     space for the sentinel byte dfaexec may add.  */
          char *case_buf = mbtolower (buf, &size);
	  if (start_ptr)
	    start_ptr = case_buf + (start_ptr - buf);
          buf = case_buf;
        }
    }
#endif /* MBS_SUPPORT */

  mb_start = buf;
  buflim = buf + size;

  for (beg = end = buf; end < buflim; beg = end)
    {
      if (!start_ptr)
	{
	  /* We don't care about an exact match.  */
	  if (kwset)
	    {
	      /* Find a possible match using the KWset matcher. */
	      size_t offset = kwsexec (kwset, beg, buflim - beg, &kwsm);
	      if (offset == (size_t) -1)
		goto failure;
	      beg += offset;
	      /* Narrow down to the line containing the candidate, and
		 run it through DFA. */
	      if ((end = memchr(beg, eol, buflim - beg)) != NULL)
	        end++;
              else
                end = buflim;
	      match = beg;
	      while (beg > buf && beg[-1] != eol)
		--beg;
	      if (kwsm.index < kwset_exact_matches)
                {
#ifdef MBS_SUPPORT
                  if (mb_start < beg)
                    mb_start = beg;
                  if (MB_CUR_MAX == 1 || !is_mb_middle (&mb_start, match, buflim))
#endif
                    goto success;
                }
	      if (dfaexec (&dfa, beg, (char *) end, 0, NULL, &backref) == NULL)
		continue;
	    }
	  else
	    {
	      /* No good fixed strings; start with DFA. */
	      char const *next_beg = dfaexec (&dfa, beg, (char *) buflim,
					      0, NULL, &backref);
	      if (next_beg == NULL)
		break;
	      /* Narrow down to the line we've found. */
	      beg = next_beg;
	      if ((end = memchr(beg, eol, buflim - beg)) != NULL)
	        end++;
              else
                end = buflim;
	      while (beg > buf && beg[-1] != eol)
		--beg;
	    }
	  /* Successful, no backreferences encountered! */
	  if (!backref)
	    goto success;
	}
      else
	{
	  /* We are looking for the leftmost (then longest) exact match.
	     We will go through the outer loop only once.  */
	  beg = start_ptr;
	  end = buflim;
	}

      /* If we've made it to this point, this means DFA has seen
	 a probable match, and we need to run it through Regex. */
      best_match = end;
      best_len = 0;
      for (i = 0; i < pcount; i++)
	{
	  patterns[i].regexbuf.not_eol = 0;
	  if (0 <= (start = re_search (&(patterns[i].regexbuf),
				       buf, end - buf - 1,
				       beg - buf, end - beg - 1,
				       &(patterns[i].regs))))
	    {
	      len = patterns[i].regs.end[0] - start;
	      match = buf + start;
	      if (match > best_match)
		continue;
	      if (start_ptr && !match_words)
		goto assess_pattern_match;
	      if ((!match_lines && !match_words)
		  || (match_lines && len == end - beg - 1))
		{
		  match = beg;
		  len = end - beg;
		  goto assess_pattern_match;
		}
	      /* If -w, check if the match aligns with word boundaries.
		 We do this iteratively because:
		 (a) the line may contain more than one occurence of the
		 pattern, and
		 (b) Several alternatives in the pattern might be valid at a
		 given point, and we may need to consider a shorter one to
		 find a word boundary.  */
	      if (match_words)
		while (match <= best_match)
		  {
		    if ((match == buf || !WCHAR ((unsigned char) match[-1]))
			&& (len == end - beg - 1
			    || !WCHAR ((unsigned char) match[len])))
		      goto assess_pattern_match;
		    if (len > 0)
		      {
			/* Try a shorter length anchored at the same place. */
			--len;
			patterns[i].regexbuf.not_eol = 1;
			len = re_match (&(patterns[i].regexbuf),
					buf, match + len - beg, match - buf,
					&(patterns[i].regs));
		      }
		    if (len <= 0)
		      {
			/* Try looking further on. */
			if (match == end - 1)
			  break;
			match++;
			patterns[i].regexbuf.not_eol = 0;
			start = re_search (&(patterns[i].regexbuf),
					   buf, end - buf - 1,
					   match - buf, end - match - 1,
					   &(patterns[i].regs));
			if (start < 0)
			  break;
			len = patterns[i].regs.end[0] - start;
			match = buf + start;
		      }
		  } /* while (match <= best_match) */
	      continue;
	    assess_pattern_match:
	      if (!start_ptr)
		{
		  /* Good enough for a non-exact match.
		     No need to look at further patterns, if any.  */
		  beg = match;
		  goto success_in_len;
		}
	      if (match < best_match || (match == best_match && len > best_len))
		{
		  /* Best exact match:  leftmost, then longest.  */
		  best_match = match;
		  best_len = len;
		}
	    } /* if re_search >= 0 */
	} /* for Regex patterns.  */
	if (best_match < end)
	  {
	    /* We have found an exact match.  We were just
	       waiting for the best one (leftmost then longest).  */
	    beg = best_match;
	    len = best_len;
	    goto success_in_len;
	  }
    } /* for (beg = end ..) */

 failure:
  ret_val = -1;
  goto out;

 success:
  len = end - beg;
 success_in_len:
  *match_size = len;
  ret_val = beg - buf;
 out:
  return ret_val;
}
#endif /* defined(GREP_PROGRAM) || defined(EGREP_PROGRAM) */

#if defined(GREP_PROGRAM) || defined(FGREP_PROGRAM)
COMPILE_FCT(Fcompile)
{
  char const *beg, *end, *lim, *err, *pat;
  size_t psize;

  kwsinit ();
  psize = size;
  if (match_icase && MB_CUR_MAX > 1)
    pat = mbtolower (pattern, &psize);
  else
    pat = pattern;

  beg = pat;
  do
    {
      for (lim = beg;; ++lim)
	{
	  end = lim;
	  if (lim >= pat + psize)
	    break;
	 if (*lim == '\n')
	   {
	     lim++;
	     break;
	   }
#if HAVE_DOS_FILE_CONTENTS
	 if (*lim == '\r' && lim + 1 < pat + psize && lim[1] == '\n')
	   {
	     lim += 2;
	     break;
	   }
#endif
	}

      if ((err = kwsincr (kwset, beg, end - beg)) != NULL)
	error (EXIT_TROUBLE, 0, "%s", err);
      beg = lim;
    }
  while (beg < pat + psize);

  if ((err = kwsprep (kwset)) != NULL)
    error (EXIT_TROUBLE, 0, "%s", err);
}

EXECUTE_FCT(Fexecute)
{
  char const *beg, *try, *end, *mb_start;
  size_t len;
  char eol = eolbyte;
  struct kwsmatch kwsmatch;
  size_t ret_val;
#ifdef MBS_SUPPORT
  if (MB_CUR_MAX > 1)
    {
      if (match_icase)
        {
          char *case_buf = mbtolower (buf, &size);
	  if (start_ptr)
	    start_ptr = case_buf + (start_ptr - buf);
          buf = case_buf;
        }
    }
#endif /* MBS_SUPPORT */

  for (mb_start = beg = start_ptr ? start_ptr : buf; beg <= buf + size; beg++)
    {
      size_t offset = kwsexec (kwset, beg, buf + size - beg, &kwsmatch);
      if (offset == (size_t) -1)
	goto failure;
#ifdef MBS_SUPPORT
      if (MB_CUR_MAX > 1 && is_mb_middle (&mb_start, beg + offset, buf + size))
        {
          beg = mb_start - 1;
          continue; /* It is a part of multibyte character.  */
        }
#endif /* MBS_SUPPORT */
      beg += offset;
      len = kwsmatch.size[0];
      if (start_ptr && !match_words)
	goto success_in_beg_and_len;
      if (match_lines)
	{
	  if (beg > buf && beg[-1] != eol)
	    continue;
	  if (beg + len < buf + size && beg[len] != eol)
	    continue;
	  goto success;
	}
      else if (match_words)
	for (try = beg; len; )
	  {
	    if (try > buf && WCHAR((unsigned char) try[-1]))
	      break;
	    if (try + len < buf + size && WCHAR((unsigned char) try[len]))
	      {
		offset = kwsexec (kwset, beg, --len, &kwsmatch);
		if (offset == (size_t) -1)
		  break;
		try = beg + offset;
		len = kwsmatch.size[0];
	      }
	    else if (!start_ptr)
	      goto success;
	    else
	      goto success_in_beg_and_len;
	  } /* for (try) */
      else
	goto success;
    } /* for (beg in buf) */

 failure:
  ret_val = -1;
  goto out;

 success:
  if ((end = memchr (beg + len, eol, (buf + size) - (beg + len))) != NULL)
    end++;
  else
    end = buf + size;
  while (buf < beg && beg[-1] != eol)
    --beg;
  len = end - beg;
 success_in_beg_and_len:
  *match_size = len;
  ret_val = beg - buf;
 out:
  return ret_val;
}
#endif /* defined(GREP_PROGRAM) || defined(FGREP_PROGRAM) */

#ifdef GREP_PROGRAM
#if HAVE_LIBPCRE
/* Compiled internal form of a Perl regular expression.  */
static pcre *cre;

/* Additional information about the pattern.  */
static pcre_extra *extra;
#endif

COMPILE_FCT(Pcompile)
{
#if !HAVE_LIBPCRE
  error (EXIT_TROUBLE, 0, "%s",
	 _("support for the -P option is not compiled into "
	   "this --disable-perl-regexp binary"));
#else
  int e;
  char const *ep;
  char *re = xmalloc (4 * size + 7);
  int flags = PCRE_MULTILINE | (match_icase ? PCRE_CASELESS : 0);
  char const *patlim = pattern + size;
  char *n = re;
  char const *p;
  char const *pnul;

  /* FIXME: Remove these restrictions.  */
  if (memchr(pattern, '\n', size))
    error (EXIT_TROUBLE, 0, _("the -P option only supports a single pattern"));

  *n = '\0';
  if (match_lines)
    strcpy (n, "^(");
  if (match_words)
    strcpy (n, "\\b(");
  n += strlen (n);

  /* The PCRE interface doesn't allow NUL bytes in the pattern, so
     replace each NUL byte in the pattern with the four characters
     "\000", removing a preceding backslash if there are an odd
     number of backslashes before the NUL.

     FIXME: This method does not work with some multibyte character
     encodings, notably Shift-JIS, where a multibyte character can end
     in a backslash byte.  */
  for (p = pattern; (pnul = memchr (p, '\0', patlim - p)); p = pnul + 1)
    {
      memcpy (n, p, pnul - p);
      n += pnul - p;
      for (p = pnul; pattern < p && p[-1] == '\\'; p--)
	continue;
      n -= (pnul - p) & 1;
      strcpy (n, "\\000");
      n += 4;
    }

  memcpy (n, p, patlim - p);
  n += patlim - p;
  *n = '\0';
  if (match_words)
    strcpy (n, ")\\b");
  if (match_lines)
    strcpy (n, ")$");

  cre = pcre_compile (re, flags, &ep, &e, pcre_maketables ());
  if (!cre)
    error (EXIT_TROUBLE, 0, "%s", ep);

  extra = pcre_study (cre, 0, &ep);
  if (ep)
    error (EXIT_TROUBLE, 0, "%s", ep);

  free (re);
#endif
}

EXECUTE_FCT(Pexecute)
{
#if !HAVE_LIBPCRE
  abort ();
  return -1;
#else
  /* This array must have at least two elements; everything after that
     is just for performance improvement in pcre_exec.  */
  int sub[300];

  const char *line_buf, *line_end, *line_next;
  int e = PCRE_ERROR_NOMATCH;
  ptrdiff_t start_ofs = start_ptr ? start_ptr - buf : 0;

  /* PCRE can't limit the matching to single lines, therefore we have to
     match each line in the buffer separately.  */
  for (line_next = buf;
       e == PCRE_ERROR_NOMATCH && line_next < buf + size;
       start_ofs -= line_next - line_buf)
    {
      line_buf = line_next;
      line_end = memchr (line_buf, eolbyte, (buf + size) - line_buf);
      if (line_end == NULL)
        line_next = line_end = buf + size;
      else
        line_next = line_end + 1;

      if (start_ptr && start_ptr >= line_end)
        continue;

      e = pcre_exec (cre, extra, line_buf, line_end - line_buf,
                     start_ofs < 0 ? 0 : start_ofs, 0,
                     sub, sizeof sub / sizeof *sub);
    }

  if (e <= 0)
    {
      switch (e)
	{
	case PCRE_ERROR_NOMATCH:
	  return -1;

	case PCRE_ERROR_NOMEMORY:
	  error (EXIT_TROUBLE, 0, _("memory exhausted"));

	default:
	  abort ();
	}
    }
  else
    {
      /* Narrow down to the line we've found.  */
      char const *beg = line_buf + sub[0];
      char const *end = line_buf + sub[1];
      char const *buflim = buf + size;
      char eol = eolbyte;
      if (!start_ptr)
	{
	  /* FIXME: The case when '\n' is not found indicates a bug:
	     Since grep is line oriented, the match should never contain
	     a newline, so there _must_ be a newline following.
	   */
	  if (!(end = memchr (end, eol, buflim - end)))
	    end = buflim;
	  else
	    end++;
	  while (buf < beg && beg[-1] != eol)
	    --beg;
	}

      *match_size = end - beg;
      return beg - buf;
    }
#endif
}

struct matcher const matchers[] = {
  { "default", Gcompile, EGexecute },
  { "grep",    Gcompile, EGexecute },
  { "egrep",   Ecompile, EGexecute },
  { "awk",     Acompile, EGexecute },
  { "fgrep",   Fcompile, Fexecute },
  { "perl",    Pcompile, Pexecute },
  { "", 0, 0 },
};
#endif /* GREP_PROGRAM */

Spawn 1 instances, now Total 8
Counter: 9
Batcher Size:8
Preprocess the following candidate with CondTester:
Priority 20000
At location src/search.c:603
--Src File: src/search.c
Fragment 0:
if (((err = kwsincr(kwset, beg, end - beg)) != ((void *)0)) && !(__abst_hole(beg, end, err, kwset, lim, pat, psize, pattern, match_icase, size)))
    error(EXIT_TROUBLE, 0, "%s", err);


CondTester, a patch instance with id 8:
//src_file:src/search.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
/* search.c - searching subroutines using dfa, kwset and regex for grep.
   Copyright 1992, 1998, 2000, 2007, 2009-2010 Free Software Foundation, Inc.

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 3, or (at your option)
   any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program; if not, write to the Free Software
   Foundation, Inc., 51 Franklin Street - Fifth Floor, Boston, MA
   02110-1301, USA.  */

/* Written August 1992 by Mike Haertel. */

#include <config.h>

#include <sys/types.h>

#include "mbsupport.h"
#ifdef MBS_SUPPORT
/* We can handle multibyte strings. */
# include <wchar.h>
# include <wctype.h>
#endif

#include "system.h"
#include "grep.h"
#ifndef FGREP_PROGRAM
# include <regex.h>
# include "dfa.h"
#endif
#include "kwset.h"
#include "error.h"
#include "xalloc.h"
#ifdef HAVE_LIBPCRE
# include <pcre.h>
#endif

#define NCHAR (UCHAR_MAX + 1)

/* For -w, we also consider _ to be word constituent.  */
#define WCHAR(C) (ISALNUM(C) || (C) == '_')

/* KWset compiled pattern.  For Ecompile and Gcompile, we compile
   a list of strings, at least one of which is known to occur in
   any string matching the regexp. */
static kwset_t kwset;

static void
kwsinit (void)
{
  static char trans[NCHAR];
  int i;

  if (match_icase && MB_CUR_MAX == 1)
    {
      for (i = 0; i < NCHAR; ++i)
        trans[i] = TOLOWER (i);

      kwset = kwsalloc (trans);
    }
  else
    kwset = kwsalloc (NULL);

  if (!kwset)
    xalloc_die ();
}

#ifdef MBS_SUPPORT
/* Convert the *N-byte string, BEG, to lowercase, and write the
   NUL-terminated result into malloc'd storage.  Upon success, set *N
   to the length (in bytes) of the resulting string (not including the
   trailing NUL byte), and return a pointer to the lowercase string.
   Upon memory allocation failure, this function exits.

   Note that while this function returns a pointer to malloc'd storage,
   the caller must not free it, since this function retains a pointer
   to the buffer and reuses it on any subsequent call.  As a consequence,
   this function is not thread-safe.  */
static char *
mbtolower (const char *beg, size_t *n)
{
  static char *out;
  static size_t outalloc;
  size_t outlen, mb_cur_max;
  mbstate_t is, os;
  const char *end;
  char *p;

  if (*n > outalloc)
    {
      out = xrealloc (out, *n);
      outalloc = *n;
    }

  memset (&is, 0, sizeof (is));
  memset (&os, 0, sizeof (os));
  end = beg + *n;

  mb_cur_max = MB_CUR_MAX;
  p = out;
  outlen = 0;
  while (beg < end)
    {
      wchar_t wc;
      size_t mbclen = mbrtowc(&wc, beg, end - beg, &is);
      if (outlen + mb_cur_max >= outalloc)
        {
          out = x2nrealloc (out, &outalloc, 1);
          p = out + outlen;
        }

      if (mbclen == (size_t) -1 || mbclen == (size_t) -2 || mbclen == 0)
        {
          /* An invalid sequence, or a truncated multi-octet character.
             We treat it as a single-octet character.  */
          *p++ = *beg++;
          outlen++;
          memset (&is, 0, sizeof (is));
          memset (&os, 0, sizeof (os));
        }
      else
        {
          beg += mbclen;
          mbclen = wcrtomb (p, towlower ((wint_t) wc), &os);
          p += mbclen;
          outlen += mbclen;
        }
    }

  *n = p - out;
  *p++ = 0;
  return out;
}
#endif


#ifndef FGREP_PROGRAM
/* DFA compiled regexp. */
static struct dfa dfa;

/* The Regex compiled patterns.  */
static struct patterns
{
  /* Regex compiled regexp. */
  struct re_pattern_buffer regexbuf;
  struct re_registers regs; /* This is here on account of a BRAIN-DEAD
			       Q@#%!# library interface in regex.c.  */
} patterns0;

struct patterns *patterns;
size_t pcount;

void
dfaerror (char const *mesg)
{
  error (EXIT_TROUBLE, 0, "%s", mesg);
}

/* Number of compiled fixed strings known to exactly match the regexp.
   If kwsexec returns < kwset_exact_matches, then we don't need to
   call the regexp matcher at all. */
static int kwset_exact_matches;

static char const *
kwsincr_case (const char *must)
{
  const char *buf;
  size_t n;

  n = strlen (must);
#ifdef MBS_SUPPORT
  if (match_icase && MB_CUR_MAX > 1)
    buf = mbtolower (must, &n);
  else
#endif
    buf = must;
  return kwsincr (kwset, buf, n);
}

/* If the DFA turns out to have some set of fixed strings one of
   which must occur in the match, then we build a kwset matcher
   to find those strings, and thus quickly filter out impossible
   matches. */
static void
kwsmusts (void)
{
  struct dfamust const *dm;
  char const *err;

  if (dfa.musts)
    {
      kwsinit ();
      /* First, we compile in the substrings known to be exact
	 matches.  The kwset matcher will return the index
	 of the matching string that it chooses. */
      for (dm = dfa.musts; dm; dm = dm->next)
	{
	  if (!dm->exact)
	    continue;
	  ++kwset_exact_matches;
	  if ((err = kwsincr_case (dm->must)) != NULL)
	    error (EXIT_TROUBLE, 0, "%s", err);
	}
      /* Now, we compile the substrings that will require
	 the use of the regexp matcher.  */
      for (dm = dfa.musts; dm; dm = dm->next)
	{
	  if (dm->exact)
	    continue;
	  if ((err = kwsincr_case (dm->must)) != NULL)
	    error (EXIT_TROUBLE, 0, "%s", err);
	}
      if ((err = kwsprep (kwset)) != NULL)
	error (EXIT_TROUBLE, 0, "%s", err);
    }
}
#endif /* !FGREP_PROGRAM */

#ifdef MBS_SUPPORT

static bool
is_mb_middle(const char **good, const char *buf, const char *end)
{
  const char *p = *good;
  const char *prev = p;
  mbstate_t cur_state;

  /* TODO: can be optimized for UTF-8.  */
  memset(&cur_state, 0, sizeof(mbstate_t));
  while (p < buf)
    {
      size_t mbclen = mbrlen(p, end - p, &cur_state);

      /* Store the beginning of the previous complete multibyte character.  */
      if (mbclen != (size_t) -2)
        prev = p;

      if (mbclen == (size_t) -1 || mbclen == (size_t) -2 || mbclen == 0)
	{
	  /* An invalid sequence, or a truncated multibyte character.
	     We treat it as a single byte character.  */
	  mbclen = 1;
	}
      p += mbclen;
    }

  *good = prev;
  return p > buf;
}
#endif /* MBS_SUPPORT */

#if defined(GREP_PROGRAM) || defined(EGREP_PROGRAM)
#ifdef EGREP_PROGRAM
COMPILE_FCT(Ecompile)
{
  reg_syntax_t syntax_bits = RE_SYNTAX_POSIX_EGREP;
#else
/* No __VA_ARGS__ in C89.  So we have to do it this way.  */
static COMPILE_RET
GEAcompile (char const *pattern, size_t size, reg_syntax_t syntax_bits)
{
#endif /* EGREP_PROGRAM */
  const char *err;
  const char *p, *sep;
  size_t total = size;
  char *motif;

  if (match_icase)
    syntax_bits |= RE_ICASE;
  re_set_syntax (syntax_bits);
  dfasyntax (syntax_bits, match_icase, eolbyte);

  /* For GNU regex compiler we have to pass the patterns separately to detect
     errors like "[\nallo\n]\n".  The patterns here are "[", "allo" and "]"
     GNU regex should have raise a syntax error.  The same for backref, where
     the backref should have been local to each pattern.  */
  p = pattern;
  do
    {
      size_t len;
      sep = memchr (p, '\n', total);
      if (sep)
	{
	  len = sep - p;
	  sep++;
	  total -= (len + 1);
	}
      else
	{
	  len = total;
	  total = 0;
	}

      patterns = realloc (patterns, (pcount + 1) * sizeof (*patterns));
      if (patterns == NULL)
	error (EXIT_TROUBLE, errno, _("memory exhausted"));
      patterns[pcount] = patterns0;

      if ((err = re_compile_pattern (p, len,
				    &(patterns[pcount].regexbuf))) != NULL)
	error (EXIT_TROUBLE, 0, "%s", err);
      pcount++;

      p = sep;
    } while (sep && total != 0);

  /* In the match_words and match_lines cases, we use a different pattern
     for the DFA matcher that will quickly throw out cases that won't work.
     Then if DFA succeeds we do some hairy stuff using the regex matcher
     to decide whether the match should really count. */
  if (match_words || match_lines)
    {
      static char const line_beg_no_bk[] = "^(";
      static char const line_end_no_bk[] = ")$";
      static char const word_beg_no_bk[] = "(^|[^[:alnum:]_])(";
      static char const word_end_no_bk[] = ")([^[:alnum:]_]|$)";
#ifdef EGREP_PROGRAM
# define IF_BK(x, y) (y)
      char *n = xmalloc (sizeof word_beg_no_bk - 1 + size + sizeof word_end_no_bk);
#else
      static char const line_beg_bk[] = "^\\(";
      static char const line_end_bk[] = "\\)$";
      static char const word_beg_bk[] = "\\(^\\|[^[:alnum:]_]\\)\\(";
      static char const word_end_bk[] = "\\)\\([^[:alnum:]_]\\|$\\)";
      int bk = !(syntax_bits & RE_NO_BK_PARENS);
# define IF_BK(x, y) ((bk) ? (x) : (y))
      char *n = xmalloc (sizeof word_beg_bk - 1 + size + sizeof word_end_bk);
#endif /* EGREP_PROGRAM */

      strcpy (n, match_lines ? IF_BK(line_beg_bk, line_beg_no_bk)
			     : IF_BK(word_beg_bk, word_beg_no_bk));
      total = strlen(n);
      memcpy (n + total, pattern, size);
      total += size;
      strcpy (n + total, match_lines ? IF_BK(line_end_bk, line_end_no_bk)
				     : IF_BK(word_end_bk, word_end_no_bk));
      total += strlen (n + total);
      pattern = motif = n;
      size = total;
    }
  else
    motif = NULL;

  dfacomp (pattern, size, &dfa, 1);
  kwsmusts ();

  free(motif);
}

#ifndef EGREP_PROGRAM
COMPILE_FCT(Gcompile)
{
  return GEAcompile (pattern, size,
		     RE_SYNTAX_GREP | RE_HAT_LISTS_NOT_NEWLINE);
}

COMPILE_FCT(Acompile)
{
  return GEAcompile (pattern, size, RE_SYNTAX_AWK);
}

COMPILE_FCT(Ecompile)
{
  return GEAcompile (pattern, size, RE_SYNTAX_POSIX_EGREP);
}
#endif /* !EGREP_PROGRAM */

EXECUTE_FCT(EGexecute)
{
  char const *buflim, *beg, *end, *match, *best_match, *mb_start;
  char eol = eolbyte;
  int backref, start, len, best_len;
  struct kwsmatch kwsm;
  size_t i, ret_val;
#ifdef MBS_SUPPORT
  if (MB_CUR_MAX > 1)
    {
      if (match_icase)
        {
          /* mbtolower adds a NUL byte at the end.  That will provide
	     space for the sentinel byte dfaexec may add.  */
          char *case_buf = mbtolower (buf, &size);
	  if (start_ptr)
	    start_ptr = case_buf + (start_ptr - buf);
          buf = case_buf;
        }
    }
#endif /* MBS_SUPPORT */

  mb_start = buf;
  buflim = buf + size;

  for (beg = end = buf; end < buflim; beg = end)
    {
      if (!start_ptr)
	{
	  /* We don't care about an exact match.  */
	  if (kwset)
	    {
	      /* Find a possible match using the KWset matcher. */
	      size_t offset = kwsexec (kwset, beg, buflim - beg, &kwsm);
	      if (offset == (size_t) -1)
		goto failure;
	      beg += offset;
	      /* Narrow down to the line containing the candidate, and
		 run it through DFA. */
	      if ((end = memchr(beg, eol, buflim - beg)) != NULL)
	        end++;
              else
                end = buflim;
	      match = beg;
	      while (beg > buf && beg[-1] != eol)
		--beg;
	      if (kwsm.index < kwset_exact_matches)
                {
#ifdef MBS_SUPPORT
                  if (mb_start < beg)
                    mb_start = beg;
                  if (MB_CUR_MAX == 1 || !is_mb_middle (&mb_start, match, buflim))
#endif
                    goto success;
                }
	      if (dfaexec (&dfa, beg, (char *) end, 0, NULL, &backref) == NULL)
		continue;
	    }
	  else
	    {
	      /* No good fixed strings; start with DFA. */
	      char const *next_beg = dfaexec (&dfa, beg, (char *) buflim,
					      0, NULL, &backref);
	      if (next_beg == NULL)
		break;
	      /* Narrow down to the line we've found. */
	      beg = next_beg;
	      if ((end = memchr(beg, eol, buflim - beg)) != NULL)
	        end++;
              else
                end = buflim;
	      while (beg > buf && beg[-1] != eol)
		--beg;
	    }
	  /* Successful, no backreferences encountered! */
	  if (!backref)
	    goto success;
	}
      else
	{
	  /* We are looking for the leftmost (then longest) exact match.
	     We will go through the outer loop only once.  */
	  beg = start_ptr;
	  end = buflim;
	}

      /* If we've made it to this point, this means DFA has seen
	 a probable match, and we need to run it through Regex. */
      best_match = end;
      best_len = 0;
      for (i = 0; i < pcount; i++)
	{
	  patterns[i].regexbuf.not_eol = 0;
	  if (0 <= (start = re_search (&(patterns[i].regexbuf),
				       buf, end - buf - 1,
				       beg - buf, end - beg - 1,
				       &(patterns[i].regs))))
	    {
	      len = patterns[i].regs.end[0] - start;
	      match = buf + start;
	      if (match > best_match)
		continue;
	      if (start_ptr && !match_words)
		goto assess_pattern_match;
	      if ((!match_lines && !match_words)
		  || (match_lines && len == end - beg - 1))
		{
		  match = beg;
		  len = end - beg;
		  goto assess_pattern_match;
		}
	      /* If -w, check if the match aligns with word boundaries.
		 We do this iteratively because:
		 (a) the line may contain more than one occurence of the
		 pattern, and
		 (b) Several alternatives in the pattern might be valid at a
		 given point, and we may need to consider a shorter one to
		 find a word boundary.  */
	      if (match_words)
		while (match <= best_match)
		  {
		    if ((match == buf || !WCHAR ((unsigned char) match[-1]))
			&& (len == end - beg - 1
			    || !WCHAR ((unsigned char) match[len])))
		      goto assess_pattern_match;
		    if (len > 0)
		      {
			/* Try a shorter length anchored at the same place. */
			--len;
			patterns[i].regexbuf.not_eol = 1;
			len = re_match (&(patterns[i].regexbuf),
					buf, match + len - beg, match - buf,
					&(patterns[i].regs));
		      }
		    if (len <= 0)
		      {
			/* Try looking further on. */
			if (match == end - 1)
			  break;
			match++;
			patterns[i].regexbuf.not_eol = 0;
			start = re_search (&(patterns[i].regexbuf),
					   buf, end - buf - 1,
					   match - buf, end - match - 1,
					   &(patterns[i].regs));
			if (start < 0)
			  break;
			len = patterns[i].regs.end[0] - start;
			match = buf + start;
		      }
		  } /* while (match <= best_match) */
	      continue;
	    assess_pattern_match:
	      if (!start_ptr)
		{
		  /* Good enough for a non-exact match.
		     No need to look at further patterns, if any.  */
		  beg = match;
		  goto success_in_len;
		}
	      if (match < best_match || (match == best_match && len > best_len))
		{
		  /* Best exact match:  leftmost, then longest.  */
		  best_match = match;
		  best_len = len;
		}
	    } /* if re_search >= 0 */
	} /* for Regex patterns.  */
	if (best_match < end)
	  {
	    /* We have found an exact match.  We were just
	       waiting for the best one (leftmost then longest).  */
	    beg = best_match;
	    len = best_len;
	    goto success_in_len;
	  }
    } /* for (beg = end ..) */

 failure:
  ret_val = -1;
  goto out;

 success:
  len = end - beg;
 success_in_len:
  *match_size = len;
  ret_val = beg - buf;
 out:
  return ret_val;
}
#endif /* defined(GREP_PROGRAM) || defined(EGREP_PROGRAM) */

#if defined(GREP_PROGRAM) || defined(FGREP_PROGRAM)
COMPILE_FCT(Fcompile)
{
  char const *beg, *end, *lim, *err, *pat;
  size_t psize;

  kwsinit ();
  psize = size;
  if (match_icase && MB_CUR_MAX > 1)
    pat = mbtolower (pattern, &psize);
  else
    pat = pattern;

  beg = pat;
  do
    {
      for (lim = beg;; ++lim)
	{
	  end = lim;
	  if (lim >= pat + psize)
	    break;
	 if (*lim == '\n')
	   {
	     lim++;
	     break;
	   }
#if HAVE_DOS_FILE_CONTENTS
	 if (*lim == '\r' && lim + 1 < pat + psize && lim[1] == '\n')
	   {
	     lim += 2;
	     break;
	   }
#endif
	}

      
//Patch 0:
if (((err = kwsincr(kwset, beg, end - beg)) != ((void *)0)) && !(__is_neg(10, &(beg), sizeof (beg), &(end), sizeof (end), &(err), sizeof (err), &(kwset), sizeof (kwset), &(lim), sizeof (lim), &(pat), sizeof (pat), &(psize), sizeof (psize), &(pattern), sizeof (pattern), &(match_icase), sizeof (match_icase), &(size), sizeof (size))))
    error(EXIT_TROUBLE, 0, "%s", err);

//CodeSeg 1:
      beg = lim;
    }
  while (beg < pat + psize);

  if ((err = kwsprep (kwset)) != NULL)
    error (EXIT_TROUBLE, 0, "%s", err);
}

EXECUTE_FCT(Fexecute)
{
  char const *beg, *try, *end, *mb_start;
  size_t len;
  char eol = eolbyte;
  struct kwsmatch kwsmatch;
  size_t ret_val;
#ifdef MBS_SUPPORT
  if (MB_CUR_MAX > 1)
    {
      if (match_icase)
        {
          char *case_buf = mbtolower (buf, &size);
	  if (start_ptr)
	    start_ptr = case_buf + (start_ptr - buf);
          buf = case_buf;
        }
    }
#endif /* MBS_SUPPORT */

  for (mb_start = beg = start_ptr ? start_ptr : buf; beg <= buf + size; beg++)
    {
      size_t offset = kwsexec (kwset, beg, buf + size - beg, &kwsmatch);
      if (offset == (size_t) -1)
	goto failure;
#ifdef MBS_SUPPORT
      if (MB_CUR_MAX > 1 && is_mb_middle (&mb_start, beg + offset, buf + size))
        {
          beg = mb_start - 1;
          continue; /* It is a part of multibyte character.  */
        }
#endif /* MBS_SUPPORT */
      beg += offset;
      len = kwsmatch.size[0];
      if (start_ptr && !match_words)
	goto success_in_beg_and_len;
      if (match_lines)
	{
	  if (beg > buf && beg[-1] != eol)
	    continue;
	  if (beg + len < buf + size && beg[len] != eol)
	    continue;
	  goto success;
	}
      else if (match_words)
	for (try = beg; len; )
	  {
	    if (try > buf && WCHAR((unsigned char) try[-1]))
	      break;
	    if (try + len < buf + size && WCHAR((unsigned char) try[len]))
	      {
		offset = kwsexec (kwset, beg, --len, &kwsmatch);
		if (offset == (size_t) -1)
		  break;
		try = beg + offset;
		len = kwsmatch.size[0];
	      }
	    else if (!start_ptr)
	      goto success;
	    else
	      goto success_in_beg_and_len;
	  } /* for (try) */
      else
	goto success;
    } /* for (beg in buf) */

 failure:
  ret_val = -1;
  goto out;

 success:
  if ((end = memchr (beg + len, eol, (buf + size) - (beg + len))) != NULL)
    end++;
  else
    end = buf + size;
  while (buf < beg && beg[-1] != eol)
    --beg;
  len = end - beg;
 success_in_beg_and_len:
  *match_size = len;
  ret_val = beg - buf;
 out:
  return ret_val;
}
#endif /* defined(GREP_PROGRAM) || defined(FGREP_PROGRAM) */

#ifdef GREP_PROGRAM
#if HAVE_LIBPCRE
/* Compiled internal form of a Perl regular expression.  */
static pcre *cre;

/* Additional information about the pattern.  */
static pcre_extra *extra;
#endif

COMPILE_FCT(Pcompile)
{
#if !HAVE_LIBPCRE
  error (EXIT_TROUBLE, 0, "%s",
	 _("support for the -P option is not compiled into "
	   "this --disable-perl-regexp binary"));
#else
  int e;
  char const *ep;
  char *re = xmalloc (4 * size + 7);
  int flags = PCRE_MULTILINE | (match_icase ? PCRE_CASELESS : 0);
  char const *patlim = pattern + size;
  char *n = re;
  char const *p;
  char const *pnul;

  /* FIXME: Remove these restrictions.  */
  if (memchr(pattern, '\n', size))
    error (EXIT_TROUBLE, 0, _("the -P option only supports a single pattern"));

  *n = '\0';
  if (match_lines)
    strcpy (n, "^(");
  if (match_words)
    strcpy (n, "\\b(");
  n += strlen (n);

  /* The PCRE interface doesn't allow NUL bytes in the pattern, so
     replace each NUL byte in the pattern with the four characters
     "\000", removing a preceding backslash if there are an odd
     number of backslashes before the NUL.

     FIXME: This method does not work with some multibyte character
     encodings, notably Shift-JIS, where a multibyte character can end
     in a backslash byte.  */
  for (p = pattern; (pnul = memchr (p, '\0', patlim - p)); p = pnul + 1)
    {
      memcpy (n, p, pnul - p);
      n += pnul - p;
      for (p = pnul; pattern < p && p[-1] == '\\'; p--)
	continue;
      n -= (pnul - p) & 1;
      strcpy (n, "\\000");
      n += 4;
    }

  memcpy (n, p, patlim - p);
  n += patlim - p;
  *n = '\0';
  if (match_words)
    strcpy (n, ")\\b");
  if (match_lines)
    strcpy (n, ")$");

  cre = pcre_compile (re, flags, &ep, &e, pcre_maketables ());
  if (!cre)
    error (EXIT_TROUBLE, 0, "%s", ep);

  extra = pcre_study (cre, 0, &ep);
  if (ep)
    error (EXIT_TROUBLE, 0, "%s", ep);

  free (re);
#endif
}

EXECUTE_FCT(Pexecute)
{
#if !HAVE_LIBPCRE
  abort ();
  return -1;
#else
  /* This array must have at least two elements; everything after that
     is just for performance improvement in pcre_exec.  */
  int sub[300];

  const char *line_buf, *line_end, *line_next;
  int e = PCRE_ERROR_NOMATCH;
  ptrdiff_t start_ofs = start_ptr ? start_ptr - buf : 0;

  /* PCRE can't limit the matching to single lines, therefore we have to
     match each line in the buffer separately.  */
  for (line_next = buf;
       e == PCRE_ERROR_NOMATCH && line_next < buf + size;
       start_ofs -= line_next - line_buf)
    {
      line_buf = line_next;
      line_end = memchr (line_buf, eolbyte, (buf + size) - line_buf);
      if (line_end == NULL)
        line_next = line_end = buf + size;
      else
        line_next = line_end + 1;

      if (start_ptr && start_ptr >= line_end)
        continue;

      e = pcre_exec (cre, extra, line_buf, line_end - line_buf,
                     start_ofs < 0 ? 0 : start_ofs, 0,
                     sub, sizeof sub / sizeof *sub);
    }

  if (e <= 0)
    {
      switch (e)
	{
	case PCRE_ERROR_NOMATCH:
	  return -1;

	case PCRE_ERROR_NOMEMORY:
	  error (EXIT_TROUBLE, 0, _("memory exhausted"));

	default:
	  abort ();
	}
    }
  else
    {
      /* Narrow down to the line we've found.  */
      char const *beg = line_buf + sub[0];
      char const *end = line_buf + sub[1];
      char const *buflim = buf + size;
      char eol = eolbyte;
      if (!start_ptr)
	{
	  /* FIXME: The case when '\n' is not found indicates a bug:
	     Since grep is line oriented, the match should never contain
	     a newline, so there _must_ be a newline following.
	   */
	  if (!(end = memchr (end, eol, buflim - end)))
	    end = buflim;
	  else
	    end++;
	  while (buf < beg && beg[-1] != eol)
	    --beg;
	}

      *match_size = end - beg;
      return beg - buf;
    }
#endif
}

struct matcher const matchers[] = {
  { "default", Gcompile, EGexecute },
  { "grep",    Gcompile, EGexecute },
  { "egrep",   Ecompile, EGexecute },
  { "awk",     Acompile, EGexecute },
  { "fgrep",   Fcompile, Fexecute },
  { "perl",    Pcompile, Pexecute },
  { "", 0, 0 },
};
#endif /* GREP_PROGRAM */

Spawn 1 instances, now Total 9
Counter: 10
Batcher Size:9
Preprocess the following candidate with CondTester:
Priority 20000
At location src/search.c:609
--Src File: src/search.c
Fragment 0:
if (((err = kwsprep(kwset)) != ((void *)0)) && !(__abst_hole(err, kwset, beg, pat, psize, lim, end, pattern, match_icase, size)))
    error(EXIT_TROUBLE, 0, "%s", err);


CondTester, a patch instance with id 9:
//src_file:src/search.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
/* search.c - searching subroutines using dfa, kwset and regex for grep.
   Copyright 1992, 1998, 2000, 2007, 2009-2010 Free Software Foundation, Inc.

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 3, or (at your option)
   any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program; if not, write to the Free Software
   Foundation, Inc., 51 Franklin Street - Fifth Floor, Boston, MA
   02110-1301, USA.  */

/* Written August 1992 by Mike Haertel. */

#include <config.h>

#include <sys/types.h>

#include "mbsupport.h"
#ifdef MBS_SUPPORT
/* We can handle multibyte strings. */
# include <wchar.h>
# include <wctype.h>
#endif

#include "system.h"
#include "grep.h"
#ifndef FGREP_PROGRAM
# include <regex.h>
# include "dfa.h"
#endif
#include "kwset.h"
#include "error.h"
#include "xalloc.h"
#ifdef HAVE_LIBPCRE
# include <pcre.h>
#endif

#define NCHAR (UCHAR_MAX + 1)

/* For -w, we also consider _ to be word constituent.  */
#define WCHAR(C) (ISALNUM(C) || (C) == '_')

/* KWset compiled pattern.  For Ecompile and Gcompile, we compile
   a list of strings, at least one of which is known to occur in
   any string matching the regexp. */
static kwset_t kwset;

static void
kwsinit (void)
{
  static char trans[NCHAR];
  int i;

  if (match_icase && MB_CUR_MAX == 1)
    {
      for (i = 0; i < NCHAR; ++i)
        trans[i] = TOLOWER (i);

      kwset = kwsalloc (trans);
    }
  else
    kwset = kwsalloc (NULL);

  if (!kwset)
    xalloc_die ();
}

#ifdef MBS_SUPPORT
/* Convert the *N-byte string, BEG, to lowercase, and write the
   NUL-terminated result into malloc'd storage.  Upon success, set *N
   to the length (in bytes) of the resulting string (not including the
   trailing NUL byte), and return a pointer to the lowercase string.
   Upon memory allocation failure, this function exits.

   Note that while this function returns a pointer to malloc'd storage,
   the caller must not free it, since this function retains a pointer
   to the buffer and reuses it on any subsequent call.  As a consequence,
   this function is not thread-safe.  */
static char *
mbtolower (const char *beg, size_t *n)
{
  static char *out;
  static size_t outalloc;
  size_t outlen, mb_cur_max;
  mbstate_t is, os;
  const char *end;
  char *p;

  if (*n > outalloc)
    {
      out = xrealloc (out, *n);
      outalloc = *n;
    }

  memset (&is, 0, sizeof (is));
  memset (&os, 0, sizeof (os));
  end = beg + *n;

  mb_cur_max = MB_CUR_MAX;
  p = out;
  outlen = 0;
  while (beg < end)
    {
      wchar_t wc;
      size_t mbclen = mbrtowc(&wc, beg, end - beg, &is);
      if (outlen + mb_cur_max >= outalloc)
        {
          out = x2nrealloc (out, &outalloc, 1);
          p = out + outlen;
        }

      if (mbclen == (size_t) -1 || mbclen == (size_t) -2 || mbclen == 0)
        {
          /* An invalid sequence, or a truncated multi-octet character.
             We treat it as a single-octet character.  */
          *p++ = *beg++;
          outlen++;
          memset (&is, 0, sizeof (is));
          memset (&os, 0, sizeof (os));
        }
      else
        {
          beg += mbclen;
          mbclen = wcrtomb (p, towlower ((wint_t) wc), &os);
          p += mbclen;
          outlen += mbclen;
        }
    }

  *n = p - out;
  *p++ = 0;
  return out;
}
#endif


#ifndef FGREP_PROGRAM
/* DFA compiled regexp. */
static struct dfa dfa;

/* The Regex compiled patterns.  */
static struct patterns
{
  /* Regex compiled regexp. */
  struct re_pattern_buffer regexbuf;
  struct re_registers regs; /* This is here on account of a BRAIN-DEAD
			       Q@#%!# library interface in regex.c.  */
} patterns0;

struct patterns *patterns;
size_t pcount;

void
dfaerror (char const *mesg)
{
  error (EXIT_TROUBLE, 0, "%s", mesg);
}

/* Number of compiled fixed strings known to exactly match the regexp.
   If kwsexec returns < kwset_exact_matches, then we don't need to
   call the regexp matcher at all. */
static int kwset_exact_matches;

static char const *
kwsincr_case (const char *must)
{
  const char *buf;
  size_t n;

  n = strlen (must);
#ifdef MBS_SUPPORT
  if (match_icase && MB_CUR_MAX > 1)
    buf = mbtolower (must, &n);
  else
#endif
    buf = must;
  return kwsincr (kwset, buf, n);
}

/* If the DFA turns out to have some set of fixed strings one of
   which must occur in the match, then we build a kwset matcher
   to find those strings, and thus quickly filter out impossible
   matches. */
static void
kwsmusts (void)
{
  struct dfamust const *dm;
  char const *err;

  if (dfa.musts)
    {
      kwsinit ();
      /* First, we compile in the substrings known to be exact
	 matches.  The kwset matcher will return the index
	 of the matching string that it chooses. */
      for (dm = dfa.musts; dm; dm = dm->next)
	{
	  if (!dm->exact)
	    continue;
	  ++kwset_exact_matches;
	  if ((err = kwsincr_case (dm->must)) != NULL)
	    error (EXIT_TROUBLE, 0, "%s", err);
	}
      /* Now, we compile the substrings that will require
	 the use of the regexp matcher.  */
      for (dm = dfa.musts; dm; dm = dm->next)
	{
	  if (dm->exact)
	    continue;
	  if ((err = kwsincr_case (dm->must)) != NULL)
	    error (EXIT_TROUBLE, 0, "%s", err);
	}
      if ((err = kwsprep (kwset)) != NULL)
	error (EXIT_TROUBLE, 0, "%s", err);
    }
}
#endif /* !FGREP_PROGRAM */

#ifdef MBS_SUPPORT

static bool
is_mb_middle(const char **good, const char *buf, const char *end)
{
  const char *p = *good;
  const char *prev = p;
  mbstate_t cur_state;

  /* TODO: can be optimized for UTF-8.  */
  memset(&cur_state, 0, sizeof(mbstate_t));
  while (p < buf)
    {
      size_t mbclen = mbrlen(p, end - p, &cur_state);

      /* Store the beginning of the previous complete multibyte character.  */
      if (mbclen != (size_t) -2)
        prev = p;

      if (mbclen == (size_t) -1 || mbclen == (size_t) -2 || mbclen == 0)
	{
	  /* An invalid sequence, or a truncated multibyte character.
	     We treat it as a single byte character.  */
	  mbclen = 1;
	}
      p += mbclen;
    }

  *good = prev;
  return p > buf;
}
#endif /* MBS_SUPPORT */

#if defined(GREP_PROGRAM) || defined(EGREP_PROGRAM)
#ifdef EGREP_PROGRAM
COMPILE_FCT(Ecompile)
{
  reg_syntax_t syntax_bits = RE_SYNTAX_POSIX_EGREP;
#else
/* No __VA_ARGS__ in C89.  So we have to do it this way.  */
static COMPILE_RET
GEAcompile (char const *pattern, size_t size, reg_syntax_t syntax_bits)
{
#endif /* EGREP_PROGRAM */
  const char *err;
  const char *p, *sep;
  size_t total = size;
  char *motif;

  if (match_icase)
    syntax_bits |= RE_ICASE;
  re_set_syntax (syntax_bits);
  dfasyntax (syntax_bits, match_icase, eolbyte);

  /* For GNU regex compiler we have to pass the patterns separately to detect
     errors like "[\nallo\n]\n".  The patterns here are "[", "allo" and "]"
     GNU regex should have raise a syntax error.  The same for backref, where
     the backref should have been local to each pattern.  */
  p = pattern;
  do
    {
      size_t len;
      sep = memchr (p, '\n', total);
      if (sep)
	{
	  len = sep - p;
	  sep++;
	  total -= (len + 1);
	}
      else
	{
	  len = total;
	  total = 0;
	}

      patterns = realloc (patterns, (pcount + 1) * sizeof (*patterns));
      if (patterns == NULL)
	error (EXIT_TROUBLE, errno, _("memory exhausted"));
      patterns[pcount] = patterns0;

      if ((err = re_compile_pattern (p, len,
				    &(patterns[pcount].regexbuf))) != NULL)
	error (EXIT_TROUBLE, 0, "%s", err);
      pcount++;

      p = sep;
    } while (sep && total != 0);

  /* In the match_words and match_lines cases, we use a different pattern
     for the DFA matcher that will quickly throw out cases that won't work.
     Then if DFA succeeds we do some hairy stuff using the regex matcher
     to decide whether the match should really count. */
  if (match_words || match_lines)
    {
      static char const line_beg_no_bk[] = "^(";
      static char const line_end_no_bk[] = ")$";
      static char const word_beg_no_bk[] = "(^|[^[:alnum:]_])(";
      static char const word_end_no_bk[] = ")([^[:alnum:]_]|$)";
#ifdef EGREP_PROGRAM
# define IF_BK(x, y) (y)
      char *n = xmalloc (sizeof word_beg_no_bk - 1 + size + sizeof word_end_no_bk);
#else
      static char const line_beg_bk[] = "^\\(";
      static char const line_end_bk[] = "\\)$";
      static char const word_beg_bk[] = "\\(^\\|[^[:alnum:]_]\\)\\(";
      static char const word_end_bk[] = "\\)\\([^[:alnum:]_]\\|$\\)";
      int bk = !(syntax_bits & RE_NO_BK_PARENS);
# define IF_BK(x, y) ((bk) ? (x) : (y))
      char *n = xmalloc (sizeof word_beg_bk - 1 + size + sizeof word_end_bk);
#endif /* EGREP_PROGRAM */

      strcpy (n, match_lines ? IF_BK(line_beg_bk, line_beg_no_bk)
			     : IF_BK(word_beg_bk, word_beg_no_bk));
      total = strlen(n);
      memcpy (n + total, pattern, size);
      total += size;
      strcpy (n + total, match_lines ? IF_BK(line_end_bk, line_end_no_bk)
				     : IF_BK(word_end_bk, word_end_no_bk));
      total += strlen (n + total);
      pattern = motif = n;
      size = total;
    }
  else
    motif = NULL;

  dfacomp (pattern, size, &dfa, 1);
  kwsmusts ();

  free(motif);
}

#ifndef EGREP_PROGRAM
COMPILE_FCT(Gcompile)
{
  return GEAcompile (pattern, size,
		     RE_SYNTAX_GREP | RE_HAT_LISTS_NOT_NEWLINE);
}

COMPILE_FCT(Acompile)
{
  return GEAcompile (pattern, size, RE_SYNTAX_AWK);
}

COMPILE_FCT(Ecompile)
{
  return GEAcompile (pattern, size, RE_SYNTAX_POSIX_EGREP);
}
#endif /* !EGREP_PROGRAM */

EXECUTE_FCT(EGexecute)
{
  char const *buflim, *beg, *end, *match, *best_match, *mb_start;
  char eol = eolbyte;
  int backref, start, len, best_len;
  struct kwsmatch kwsm;
  size_t i, ret_val;
#ifdef MBS_SUPPORT
  if (MB_CUR_MAX > 1)
    {
      if (match_icase)
        {
          /* mbtolower adds a NUL byte at the end.  That will provide
	     space for the sentinel byte dfaexec may add.  */
          char *case_buf = mbtolower (buf, &size);
	  if (start_ptr)
	    start_ptr = case_buf + (start_ptr - buf);
          buf = case_buf;
        }
    }
#endif /* MBS_SUPPORT */

  mb_start = buf;
  buflim = buf + size;

  for (beg = end = buf; end < buflim; beg = end)
    {
      if (!start_ptr)
	{
	  /* We don't care about an exact match.  */
	  if (kwset)
	    {
	      /* Find a possible match using the KWset matcher. */
	      size_t offset = kwsexec (kwset, beg, buflim - beg, &kwsm);
	      if (offset == (size_t) -1)
		goto failure;
	      beg += offset;
	      /* Narrow down to the line containing the candidate, and
		 run it through DFA. */
	      if ((end = memchr(beg, eol, buflim - beg)) != NULL)
	        end++;
              else
                end = buflim;
	      match = beg;
	      while (beg > buf && beg[-1] != eol)
		--beg;
	      if (kwsm.index < kwset_exact_matches)
                {
#ifdef MBS_SUPPORT
                  if (mb_start < beg)
                    mb_start = beg;
                  if (MB_CUR_MAX == 1 || !is_mb_middle (&mb_start, match, buflim))
#endif
                    goto success;
                }
	      if (dfaexec (&dfa, beg, (char *) end, 0, NULL, &backref) == NULL)
		continue;
	    }
	  else
	    {
	      /* No good fixed strings; start with DFA. */
	      char const *next_beg = dfaexec (&dfa, beg, (char *) buflim,
					      0, NULL, &backref);
	      if (next_beg == NULL)
		break;
	      /* Narrow down to the line we've found. */
	      beg = next_beg;
	      if ((end = memchr(beg, eol, buflim - beg)) != NULL)
	        end++;
              else
                end = buflim;
	      while (beg > buf && beg[-1] != eol)
		--beg;
	    }
	  /* Successful, no backreferences encountered! */
	  if (!backref)
	    goto success;
	}
      else
	{
	  /* We are looking for the leftmost (then longest) exact match.
	     We will go through the outer loop only once.  */
	  beg = start_ptr;
	  end = buflim;
	}

      /* If we've made it to this point, this means DFA has seen
	 a probable match, and we need to run it through Regex. */
      best_match = end;
      best_len = 0;
      for (i = 0; i < pcount; i++)
	{
	  patterns[i].regexbuf.not_eol = 0;
	  if (0 <= (start = re_search (&(patterns[i].regexbuf),
				       buf, end - buf - 1,
				       beg - buf, end - beg - 1,
				       &(patterns[i].regs))))
	    {
	      len = patterns[i].regs.end[0] - start;
	      match = buf + start;
	      if (match > best_match)
		continue;
	      if (start_ptr && !match_words)
		goto assess_pattern_match;
	      if ((!match_lines && !match_words)
		  || (match_lines && len == end - beg - 1))
		{
		  match = beg;
		  len = end - beg;
		  goto assess_pattern_match;
		}
	      /* If -w, check if the match aligns with word boundaries.
		 We do this iteratively because:
		 (a) the line may contain more than one occurence of the
		 pattern, and
		 (b) Several alternatives in the pattern might be valid at a
		 given point, and we may need to consider a shorter one to
		 find a word boundary.  */
	      if (match_words)
		while (match <= best_match)
		  {
		    if ((match == buf || !WCHAR ((unsigned char) match[-1]))
			&& (len == end - beg - 1
			    || !WCHAR ((unsigned char) match[len])))
		      goto assess_pattern_match;
		    if (len > 0)
		      {
			/* Try a shorter length anchored at the same place. */
			--len;
			patterns[i].regexbuf.not_eol = 1;
			len = re_match (&(patterns[i].regexbuf),
					buf, match + len - beg, match - buf,
					&(patterns[i].regs));
		      }
		    if (len <= 0)
		      {
			/* Try looking further on. */
			if (match == end - 1)
			  break;
			match++;
			patterns[i].regexbuf.not_eol = 0;
			start = re_search (&(patterns[i].regexbuf),
					   buf, end - buf - 1,
					   match - buf, end - match - 1,
					   &(patterns[i].regs));
			if (start < 0)
			  break;
			len = patterns[i].regs.end[0] - start;
			match = buf + start;
		      }
		  } /* while (match <= best_match) */
	      continue;
	    assess_pattern_match:
	      if (!start_ptr)
		{
		  /* Good enough for a non-exact match.
		     No need to look at further patterns, if any.  */
		  beg = match;
		  goto success_in_len;
		}
	      if (match < best_match || (match == best_match && len > best_len))
		{
		  /* Best exact match:  leftmost, then longest.  */
		  best_match = match;
		  best_len = len;
		}
	    } /* if re_search >= 0 */
	} /* for Regex patterns.  */
	if (best_match < end)
	  {
	    /* We have found an exact match.  We were just
	       waiting for the best one (leftmost then longest).  */
	    beg = best_match;
	    len = best_len;
	    goto success_in_len;
	  }
    } /* for (beg = end ..) */

 failure:
  ret_val = -1;
  goto out;

 success:
  len = end - beg;
 success_in_len:
  *match_size = len;
  ret_val = beg - buf;
 out:
  return ret_val;
}
#endif /* defined(GREP_PROGRAM) || defined(EGREP_PROGRAM) */

#if defined(GREP_PROGRAM) || defined(FGREP_PROGRAM)
COMPILE_FCT(Fcompile)
{
  char const *beg, *end, *lim, *err, *pat;
  size_t psize;

  kwsinit ();
  psize = size;
  if (match_icase && MB_CUR_MAX > 1)
    pat = mbtolower (pattern, &psize);
  else
    pat = pattern;

  beg = pat;
  do
    {
      for (lim = beg;; ++lim)
	{
	  end = lim;
	  if (lim >= pat + psize)
	    break;
	 if (*lim == '\n')
	   {
	     lim++;
	     break;
	   }
#if HAVE_DOS_FILE_CONTENTS
	 if (*lim == '\r' && lim + 1 < pat + psize && lim[1] == '\n')
	   {
	     lim += 2;
	     break;
	   }
#endif
	}

      if ((err = kwsincr (kwset, beg, end - beg)) != NULL)
	error (EXIT_TROUBLE, 0, "%s", err);
      beg = lim;
    }
  while (beg < pat + psize);

  
//Patch 0:
if (((err = kwsprep(kwset)) != ((void *)0)) && !(__is_neg(10, &(err), sizeof (err), &(kwset), sizeof (kwset), &(beg), sizeof (beg), &(pat), sizeof (pat), &(psize), sizeof (psize), &(lim), sizeof (lim), &(end), sizeof (end), &(pattern), sizeof (pattern), &(match_icase), sizeof (match_icase), &(size), sizeof (size))))
    error(EXIT_TROUBLE, 0, "%s", err);

//CodeSeg 1:
}

EXECUTE_FCT(Fexecute)
{
  char const *beg, *try, *end, *mb_start;
  size_t len;
  char eol = eolbyte;
  struct kwsmatch kwsmatch;
  size_t ret_val;
#ifdef MBS_SUPPORT
  if (MB_CUR_MAX > 1)
    {
      if (match_icase)
        {
          char *case_buf = mbtolower (buf, &size);
	  if (start_ptr)
	    start_ptr = case_buf + (start_ptr - buf);
          buf = case_buf;
        }
    }
#endif /* MBS_SUPPORT */

  for (mb_start = beg = start_ptr ? start_ptr : buf; beg <= buf + size; beg++)
    {
      size_t offset = kwsexec (kwset, beg, buf + size - beg, &kwsmatch);
      if (offset == (size_t) -1)
	goto failure;
#ifdef MBS_SUPPORT
      if (MB_CUR_MAX > 1 && is_mb_middle (&mb_start, beg + offset, buf + size))
        {
          beg = mb_start - 1;
          continue; /* It is a part of multibyte character.  */
        }
#endif /* MBS_SUPPORT */
      beg += offset;
      len = kwsmatch.size[0];
      if (start_ptr && !match_words)
	goto success_in_beg_and_len;
      if (match_lines)
	{
	  if (beg > buf && beg[-1] != eol)
	    continue;
	  if (beg + len < buf + size && beg[len] != eol)
	    continue;
	  goto success;
	}
      else if (match_words)
	for (try = beg; len; )
	  {
	    if (try > buf && WCHAR((unsigned char) try[-1]))
	      break;
	    if (try + len < buf + size && WCHAR((unsigned char) try[len]))
	      {
		offset = kwsexec (kwset, beg, --len, &kwsmatch);
		if (offset == (size_t) -1)
		  break;
		try = beg + offset;
		len = kwsmatch.size[0];
	      }
	    else if (!start_ptr)
	      goto success;
	    else
	      goto success_in_beg_and_len;
	  } /* for (try) */
      else
	goto success;
    } /* for (beg in buf) */

 failure:
  ret_val = -1;
  goto out;

 success:
  if ((end = memchr (beg + len, eol, (buf + size) - (beg + len))) != NULL)
    end++;
  else
    end = buf + size;
  while (buf < beg && beg[-1] != eol)
    --beg;
  len = end - beg;
 success_in_beg_and_len:
  *match_size = len;
  ret_val = beg - buf;
 out:
  return ret_val;
}
#endif /* defined(GREP_PROGRAM) || defined(FGREP_PROGRAM) */

#ifdef GREP_PROGRAM
#if HAVE_LIBPCRE
/* Compiled internal form of a Perl regular expression.  */
static pcre *cre;

/* Additional information about the pattern.  */
static pcre_extra *extra;
#endif

COMPILE_FCT(Pcompile)
{
#if !HAVE_LIBPCRE
  error (EXIT_TROUBLE, 0, "%s",
	 _("support for the -P option is not compiled into "
	   "this --disable-perl-regexp binary"));
#else
  int e;
  char const *ep;
  char *re = xmalloc (4 * size + 7);
  int flags = PCRE_MULTILINE | (match_icase ? PCRE_CASELESS : 0);
  char const *patlim = pattern + size;
  char *n = re;
  char const *p;
  char const *pnul;

  /* FIXME: Remove these restrictions.  */
  if (memchr(pattern, '\n', size))
    error (EXIT_TROUBLE, 0, _("the -P option only supports a single pattern"));

  *n = '\0';
  if (match_lines)
    strcpy (n, "^(");
  if (match_words)
    strcpy (n, "\\b(");
  n += strlen (n);

  /* The PCRE interface doesn't allow NUL bytes in the pattern, so
     replace each NUL byte in the pattern with the four characters
     "\000", removing a preceding backslash if there are an odd
     number of backslashes before the NUL.

     FIXME: This method does not work with some multibyte character
     encodings, notably Shift-JIS, where a multibyte character can end
     in a backslash byte.  */
  for (p = pattern; (pnul = memchr (p, '\0', patlim - p)); p = pnul + 1)
    {
      memcpy (n, p, pnul - p);
      n += pnul - p;
      for (p = pnul; pattern < p && p[-1] == '\\'; p--)
	continue;
      n -= (pnul - p) & 1;
      strcpy (n, "\\000");
      n += 4;
    }

  memcpy (n, p, patlim - p);
  n += patlim - p;
  *n = '\0';
  if (match_words)
    strcpy (n, ")\\b");
  if (match_lines)
    strcpy (n, ")$");

  cre = pcre_compile (re, flags, &ep, &e, pcre_maketables ());
  if (!cre)
    error (EXIT_TROUBLE, 0, "%s", ep);

  extra = pcre_study (cre, 0, &ep);
  if (ep)
    error (EXIT_TROUBLE, 0, "%s", ep);

  free (re);
#endif
}

EXECUTE_FCT(Pexecute)
{
#if !HAVE_LIBPCRE
  abort ();
  return -1;
#else
  /* This array must have at least two elements; everything after that
     is just for performance improvement in pcre_exec.  */
  int sub[300];

  const char *line_buf, *line_end, *line_next;
  int e = PCRE_ERROR_NOMATCH;
  ptrdiff_t start_ofs = start_ptr ? start_ptr - buf : 0;

  /* PCRE can't limit the matching to single lines, therefore we have to
     match each line in the buffer separately.  */
  for (line_next = buf;
       e == PCRE_ERROR_NOMATCH && line_next < buf + size;
       start_ofs -= line_next - line_buf)
    {
      line_buf = line_next;
      line_end = memchr (line_buf, eolbyte, (buf + size) - line_buf);
      if (line_end == NULL)
        line_next = line_end = buf + size;
      else
        line_next = line_end + 1;

      if (start_ptr && start_ptr >= line_end)
        continue;

      e = pcre_exec (cre, extra, line_buf, line_end - line_buf,
                     start_ofs < 0 ? 0 : start_ofs, 0,
                     sub, sizeof sub / sizeof *sub);
    }

  if (e <= 0)
    {
      switch (e)
	{
	case PCRE_ERROR_NOMATCH:
	  return -1;

	case PCRE_ERROR_NOMEMORY:
	  error (EXIT_TROUBLE, 0, _("memory exhausted"));

	default:
	  abort ();
	}
    }
  else
    {
      /* Narrow down to the line we've found.  */
      char const *beg = line_buf + sub[0];
      char const *end = line_buf + sub[1];
      char const *buflim = buf + size;
      char eol = eolbyte;
      if (!start_ptr)
	{
	  /* FIXME: The case when '\n' is not found indicates a bug:
	     Since grep is line oriented, the match should never contain
	     a newline, so there _must_ be a newline following.
	   */
	  if (!(end = memchr (end, eol, buflim - end)))
	    end = buflim;
	  else
	    end++;
	  while (buf < beg && beg[-1] != eol)
	    --beg;
	}

      *match_size = end - beg;
      return beg - buf;
    }
#endif
}

struct matcher const matchers[] = {
  { "default", Gcompile, EGexecute },
  { "grep",    Gcompile, EGexecute },
  { "egrep",   Ecompile, EGexecute },
  { "awk",     Acompile, EGexecute },
  { "fgrep",   Fcompile, Fexecute },
  { "perl",    Pcompile, Pexecute },
  { "", 0, 0 },
};
#endif /* GREP_PROGRAM */

Spawn 1 instances, now Total 10
Counter: 11
Batcher Size:10
Preprocess the following candidate with CondTester:
Priority 20000
At location src/search.c:609
--Src File: src/search.c
Fragment 0:
if (((err = kwsprep(kwset)) != ((void *)0)) || (__abst_hole(err, kwset, beg, pat, psize, lim, end, pattern, match_icase, size)))
    error(EXIT_TROUBLE, 0, "%s", err);


CondTester, a patch instance with id 10:
//src_file:src/search.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
/* search.c - searching subroutines using dfa, kwset and regex for grep.
   Copyright 1992, 1998, 2000, 2007, 2009-2010 Free Software Foundation, Inc.

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 3, or (at your option)
   any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program; if not, write to the Free Software
   Foundation, Inc., 51 Franklin Street - Fifth Floor, Boston, MA
   02110-1301, USA.  */

/* Written August 1992 by Mike Haertel. */

#include <config.h>

#include <sys/types.h>

#include "mbsupport.h"
#ifdef MBS_SUPPORT
/* We can handle multibyte strings. */
# include <wchar.h>
# include <wctype.h>
#endif

#include "system.h"
#include "grep.h"
#ifndef FGREP_PROGRAM
# include <regex.h>
# include "dfa.h"
#endif
#include "kwset.h"
#include "error.h"
#include "xalloc.h"
#ifdef HAVE_LIBPCRE
# include <pcre.h>
#endif

#define NCHAR (UCHAR_MAX + 1)

/* For -w, we also consider _ to be word constituent.  */
#define WCHAR(C) (ISALNUM(C) || (C) == '_')

/* KWset compiled pattern.  For Ecompile and Gcompile, we compile
   a list of strings, at least one of which is known to occur in
   any string matching the regexp. */
static kwset_t kwset;

static void
kwsinit (void)
{
  static char trans[NCHAR];
  int i;

  if (match_icase && MB_CUR_MAX == 1)
    {
      for (i = 0; i < NCHAR; ++i)
        trans[i] = TOLOWER (i);

      kwset = kwsalloc (trans);
    }
  else
    kwset = kwsalloc (NULL);

  if (!kwset)
    xalloc_die ();
}

#ifdef MBS_SUPPORT
/* Convert the *N-byte string, BEG, to lowercase, and write the
   NUL-terminated result into malloc'd storage.  Upon success, set *N
   to the length (in bytes) of the resulting string (not including the
   trailing NUL byte), and return a pointer to the lowercase string.
   Upon memory allocation failure, this function exits.

   Note that while this function returns a pointer to malloc'd storage,
   the caller must not free it, since this function retains a pointer
   to the buffer and reuses it on any subsequent call.  As a consequence,
   this function is not thread-safe.  */
static char *
mbtolower (const char *beg, size_t *n)
{
  static char *out;
  static size_t outalloc;
  size_t outlen, mb_cur_max;
  mbstate_t is, os;
  const char *end;
  char *p;

  if (*n > outalloc)
    {
      out = xrealloc (out, *n);
      outalloc = *n;
    }

  memset (&is, 0, sizeof (is));
  memset (&os, 0, sizeof (os));
  end = beg + *n;

  mb_cur_max = MB_CUR_MAX;
  p = out;
  outlen = 0;
  while (beg < end)
    {
      wchar_t wc;
      size_t mbclen = mbrtowc(&wc, beg, end - beg, &is);
      if (outlen + mb_cur_max >= outalloc)
        {
          out = x2nrealloc (out, &outalloc, 1);
          p = out + outlen;
        }

      if (mbclen == (size_t) -1 || mbclen == (size_t) -2 || mbclen == 0)
        {
          /* An invalid sequence, or a truncated multi-octet character.
             We treat it as a single-octet character.  */
          *p++ = *beg++;
          outlen++;
          memset (&is, 0, sizeof (is));
          memset (&os, 0, sizeof (os));
        }
      else
        {
          beg += mbclen;
          mbclen = wcrtomb (p, towlower ((wint_t) wc), &os);
          p += mbclen;
          outlen += mbclen;
        }
    }

  *n = p - out;
  *p++ = 0;
  return out;
}
#endif


#ifndef FGREP_PROGRAM
/* DFA compiled regexp. */
static struct dfa dfa;

/* The Regex compiled patterns.  */
static struct patterns
{
  /* Regex compiled regexp. */
  struct re_pattern_buffer regexbuf;
  struct re_registers regs; /* This is here on account of a BRAIN-DEAD
			       Q@#%!# library interface in regex.c.  */
} patterns0;

struct patterns *patterns;
size_t pcount;

void
dfaerror (char const *mesg)
{
  error (EXIT_TROUBLE, 0, "%s", mesg);
}

/* Number of compiled fixed strings known to exactly match the regexp.
   If kwsexec returns < kwset_exact_matches, then we don't need to
   call the regexp matcher at all. */
static int kwset_exact_matches;

static char const *
kwsincr_case (const char *must)
{
  const char *buf;
  size_t n;

  n = strlen (must);
#ifdef MBS_SUPPORT
  if (match_icase && MB_CUR_MAX > 1)
    buf = mbtolower (must, &n);
  else
#endif
    buf = must;
  return kwsincr (kwset, buf, n);
}

/* If the DFA turns out to have some set of fixed strings one of
   which must occur in the match, then we build a kwset matcher
   to find those strings, and thus quickly filter out impossible
   matches. */
static void
kwsmusts (void)
{
  struct dfamust const *dm;
  char const *err;

  if (dfa.musts)
    {
      kwsinit ();
      /* First, we compile in the substrings known to be exact
	 matches.  The kwset matcher will return the index
	 of the matching string that it chooses. */
      for (dm = dfa.musts; dm; dm = dm->next)
	{
	  if (!dm->exact)
	    continue;
	  ++kwset_exact_matches;
	  if ((err = kwsincr_case (dm->must)) != NULL)
	    error (EXIT_TROUBLE, 0, "%s", err);
	}
      /* Now, we compile the substrings that will require
	 the use of the regexp matcher.  */
      for (dm = dfa.musts; dm; dm = dm->next)
	{
	  if (dm->exact)
	    continue;
	  if ((err = kwsincr_case (dm->must)) != NULL)
	    error (EXIT_TROUBLE, 0, "%s", err);
	}
      if ((err = kwsprep (kwset)) != NULL)
	error (EXIT_TROUBLE, 0, "%s", err);
    }
}
#endif /* !FGREP_PROGRAM */

#ifdef MBS_SUPPORT

static bool
is_mb_middle(const char **good, const char *buf, const char *end)
{
  const char *p = *good;
  const char *prev = p;
  mbstate_t cur_state;

  /* TODO: can be optimized for UTF-8.  */
  memset(&cur_state, 0, sizeof(mbstate_t));
  while (p < buf)
    {
      size_t mbclen = mbrlen(p, end - p, &cur_state);

      /* Store the beginning of the previous complete multibyte character.  */
      if (mbclen != (size_t) -2)
        prev = p;

      if (mbclen == (size_t) -1 || mbclen == (size_t) -2 || mbclen == 0)
	{
	  /* An invalid sequence, or a truncated multibyte character.
	     We treat it as a single byte character.  */
	  mbclen = 1;
	}
      p += mbclen;
    }

  *good = prev;
  return p > buf;
}
#endif /* MBS_SUPPORT */

#if defined(GREP_PROGRAM) || defined(EGREP_PROGRAM)
#ifdef EGREP_PROGRAM
COMPILE_FCT(Ecompile)
{
  reg_syntax_t syntax_bits = RE_SYNTAX_POSIX_EGREP;
#else
/* No __VA_ARGS__ in C89.  So we have to do it this way.  */
static COMPILE_RET
GEAcompile (char const *pattern, size_t size, reg_syntax_t syntax_bits)
{
#endif /* EGREP_PROGRAM */
  const char *err;
  const char *p, *sep;
  size_t total = size;
  char *motif;

  if (match_icase)
    syntax_bits |= RE_ICASE;
  re_set_syntax (syntax_bits);
  dfasyntax (syntax_bits, match_icase, eolbyte);

  /* For GNU regex compiler we have to pass the patterns separately to detect
     errors like "[\nallo\n]\n".  The patterns here are "[", "allo" and "]"
     GNU regex should have raise a syntax error.  The same for backref, where
     the backref should have been local to each pattern.  */
  p = pattern;
  do
    {
      size_t len;
      sep = memchr (p, '\n', total);
      if (sep)
	{
	  len = sep - p;
	  sep++;
	  total -= (len + 1);
	}
      else
	{
	  len = total;
	  total = 0;
	}

      patterns = realloc (patterns, (pcount + 1) * sizeof (*patterns));
      if (patterns == NULL)
	error (EXIT_TROUBLE, errno, _("memory exhausted"));
      patterns[pcount] = patterns0;

      if ((err = re_compile_pattern (p, len,
				    &(patterns[pcount].regexbuf))) != NULL)
	error (EXIT_TROUBLE, 0, "%s", err);
      pcount++;

      p = sep;
    } while (sep && total != 0);

  /* In the match_words and match_lines cases, we use a different pattern
     for the DFA matcher that will quickly throw out cases that won't work.
     Then if DFA succeeds we do some hairy stuff using the regex matcher
     to decide whether the match should really count. */
  if (match_words || match_lines)
    {
      static char const line_beg_no_bk[] = "^(";
      static char const line_end_no_bk[] = ")$";
      static char const word_beg_no_bk[] = "(^|[^[:alnum:]_])(";
      static char const word_end_no_bk[] = ")([^[:alnum:]_]|$)";
#ifdef EGREP_PROGRAM
# define IF_BK(x, y) (y)
      char *n = xmalloc (sizeof word_beg_no_bk - 1 + size + sizeof word_end_no_bk);
#else
      static char const line_beg_bk[] = "^\\(";
      static char const line_end_bk[] = "\\)$";
      static char const word_beg_bk[] = "\\(^\\|[^[:alnum:]_]\\)\\(";
      static char const word_end_bk[] = "\\)\\([^[:alnum:]_]\\|$\\)";
      int bk = !(syntax_bits & RE_NO_BK_PARENS);
# define IF_BK(x, y) ((bk) ? (x) : (y))
      char *n = xmalloc (sizeof word_beg_bk - 1 + size + sizeof word_end_bk);
#endif /* EGREP_PROGRAM */

      strcpy (n, match_lines ? IF_BK(line_beg_bk, line_beg_no_bk)
			     : IF_BK(word_beg_bk, word_beg_no_bk));
      total = strlen(n);
      memcpy (n + total, pattern, size);
      total += size;
      strcpy (n + total, match_lines ? IF_BK(line_end_bk, line_end_no_bk)
				     : IF_BK(word_end_bk, word_end_no_bk));
      total += strlen (n + total);
      pattern = motif = n;
      size = total;
    }
  else
    motif = NULL;

  dfacomp (pattern, size, &dfa, 1);
  kwsmusts ();

  free(motif);
}

#ifndef EGREP_PROGRAM
COMPILE_FCT(Gcompile)
{
  return GEAcompile (pattern, size,
		     RE_SYNTAX_GREP | RE_HAT_LISTS_NOT_NEWLINE);
}

COMPILE_FCT(Acompile)
{
  return GEAcompile (pattern, size, RE_SYNTAX_AWK);
}

COMPILE_FCT(Ecompile)
{
  return GEAcompile (pattern, size, RE_SYNTAX_POSIX_EGREP);
}
#endif /* !EGREP_PROGRAM */

EXECUTE_FCT(EGexecute)
{
  char const *buflim, *beg, *end, *match, *best_match, *mb_start;
  char eol = eolbyte;
  int backref, start, len, best_len;
  struct kwsmatch kwsm;
  size_t i, ret_val;
#ifdef MBS_SUPPORT
  if (MB_CUR_MAX > 1)
    {
      if (match_icase)
        {
          /* mbtolower adds a NUL byte at the end.  That will provide
	     space for the sentinel byte dfaexec may add.  */
          char *case_buf = mbtolower (buf, &size);
	  if (start_ptr)
	    start_ptr = case_buf + (start_ptr - buf);
          buf = case_buf;
        }
    }
#endif /* MBS_SUPPORT */

  mb_start = buf;
  buflim = buf + size;

  for (beg = end = buf; end < buflim; beg = end)
    {
      if (!start_ptr)
	{
	  /* We don't care about an exact match.  */
	  if (kwset)
	    {
	      /* Find a possible match using the KWset matcher. */
	      size_t offset = kwsexec (kwset, beg, buflim - beg, &kwsm);
	      if (offset == (size_t) -1)
		goto failure;
	      beg += offset;
	      /* Narrow down to the line containing the candidate, and
		 run it through DFA. */
	      if ((end = memchr(beg, eol, buflim - beg)) != NULL)
	        end++;
              else
                end = buflim;
	      match = beg;
	      while (beg > buf && beg[-1] != eol)
		--beg;
	      if (kwsm.index < kwset_exact_matches)
                {
#ifdef MBS_SUPPORT
                  if (mb_start < beg)
                    mb_start = beg;
                  if (MB_CUR_MAX == 1 || !is_mb_middle (&mb_start, match, buflim))
#endif
                    goto success;
                }
	      if (dfaexec (&dfa, beg, (char *) end, 0, NULL, &backref) == NULL)
		continue;
	    }
	  else
	    {
	      /* No good fixed strings; start with DFA. */
	      char const *next_beg = dfaexec (&dfa, beg, (char *) buflim,
					      0, NULL, &backref);
	      if (next_beg == NULL)
		break;
	      /* Narrow down to the line we've found. */
	      beg = next_beg;
	      if ((end = memchr(beg, eol, buflim - beg)) != NULL)
	        end++;
              else
                end = buflim;
	      while (beg > buf && beg[-1] != eol)
		--beg;
	    }
	  /* Successful, no backreferences encountered! */
	  if (!backref)
	    goto success;
	}
      else
	{
	  /* We are looking for the leftmost (then longest) exact match.
	     We will go through the outer loop only once.  */
	  beg = start_ptr;
	  end = buflim;
	}

      /* If we've made it to this point, this means DFA has seen
	 a probable match, and we need to run it through Regex. */
      best_match = end;
      best_len = 0;
      for (i = 0; i < pcount; i++)
	{
	  patterns[i].regexbuf.not_eol = 0;
	  if (0 <= (start = re_search (&(patterns[i].regexbuf),
				       buf, end - buf - 1,
				       beg - buf, end - beg - 1,
				       &(patterns[i].regs))))
	    {
	      len = patterns[i].regs.end[0] - start;
	      match = buf + start;
	      if (match > best_match)
		continue;
	      if (start_ptr && !match_words)
		goto assess_pattern_match;
	      if ((!match_lines && !match_words)
		  || (match_lines && len == end - beg - 1))
		{
		  match = beg;
		  len = end - beg;
		  goto assess_pattern_match;
		}
	      /* If -w, check if the match aligns with word boundaries.
		 We do this iteratively because:
		 (a) the line may contain more than one occurence of the
		 pattern, and
		 (b) Several alternatives in the pattern might be valid at a
		 given point, and we may need to consider a shorter one to
		 find a word boundary.  */
	      if (match_words)
		while (match <= best_match)
		  {
		    if ((match == buf || !WCHAR ((unsigned char) match[-1]))
			&& (len == end - beg - 1
			    || !WCHAR ((unsigned char) match[len])))
		      goto assess_pattern_match;
		    if (len > 0)
		      {
			/* Try a shorter length anchored at the same place. */
			--len;
			patterns[i].regexbuf.not_eol = 1;
			len = re_match (&(patterns[i].regexbuf),
					buf, match + len - beg, match - buf,
					&(patterns[i].regs));
		      }
		    if (len <= 0)
		      {
			/* Try looking further on. */
			if (match == end - 1)
			  break;
			match++;
			patterns[i].regexbuf.not_eol = 0;
			start = re_search (&(patterns[i].regexbuf),
					   buf, end - buf - 1,
					   match - buf, end - match - 1,
					   &(patterns[i].regs));
			if (start < 0)
			  break;
			len = patterns[i].regs.end[0] - start;
			match = buf + start;
		      }
		  } /* while (match <= best_match) */
	      continue;
	    assess_pattern_match:
	      if (!start_ptr)
		{
		  /* Good enough for a non-exact match.
		     No need to look at further patterns, if any.  */
		  beg = match;
		  goto success_in_len;
		}
	      if (match < best_match || (match == best_match && len > best_len))
		{
		  /* Best exact match:  leftmost, then longest.  */
		  best_match = match;
		  best_len = len;
		}
	    } /* if re_search >= 0 */
	} /* for Regex patterns.  */
	if (best_match < end)
	  {
	    /* We have found an exact match.  We were just
	       waiting for the best one (leftmost then longest).  */
	    beg = best_match;
	    len = best_len;
	    goto success_in_len;
	  }
    } /* for (beg = end ..) */

 failure:
  ret_val = -1;
  goto out;

 success:
  len = end - beg;
 success_in_len:
  *match_size = len;
  ret_val = beg - buf;
 out:
  return ret_val;
}
#endif /* defined(GREP_PROGRAM) || defined(EGREP_PROGRAM) */

#if defined(GREP_PROGRAM) || defined(FGREP_PROGRAM)
COMPILE_FCT(Fcompile)
{
  char const *beg, *end, *lim, *err, *pat;
  size_t psize;

  kwsinit ();
  psize = size;
  if (match_icase && MB_CUR_MAX > 1)
    pat = mbtolower (pattern, &psize);
  else
    pat = pattern;

  beg = pat;
  do
    {
      for (lim = beg;; ++lim)
	{
	  end = lim;
	  if (lim >= pat + psize)
	    break;
	 if (*lim == '\n')
	   {
	     lim++;
	     break;
	   }
#if HAVE_DOS_FILE_CONTENTS
	 if (*lim == '\r' && lim + 1 < pat + psize && lim[1] == '\n')
	   {
	     lim += 2;
	     break;
	   }
#endif
	}

      if ((err = kwsincr (kwset, beg, end - beg)) != NULL)
	error (EXIT_TROUBLE, 0, "%s", err);
      beg = lim;
    }
  while (beg < pat + psize);

  
//Patch 0:
if (((err = kwsprep(kwset)) != ((void *)0)) || (__is_neg(10, &(err), sizeof (err), &(kwset), sizeof (kwset), &(beg), sizeof (beg), &(pat), sizeof (pat), &(psize), sizeof (psize), &(lim), sizeof (lim), &(end), sizeof (end), &(pattern), sizeof (pattern), &(match_icase), sizeof (match_icase), &(size), sizeof (size))))
    error(EXIT_TROUBLE, 0, "%s", err);

//CodeSeg 1:
}

EXECUTE_FCT(Fexecute)
{
  char const *beg, *try, *end, *mb_start;
  size_t len;
  char eol = eolbyte;
  struct kwsmatch kwsmatch;
  size_t ret_val;
#ifdef MBS_SUPPORT
  if (MB_CUR_MAX > 1)
    {
      if (match_icase)
        {
          char *case_buf = mbtolower (buf, &size);
	  if (start_ptr)
	    start_ptr = case_buf + (start_ptr - buf);
          buf = case_buf;
        }
    }
#endif /* MBS_SUPPORT */

  for (mb_start = beg = start_ptr ? start_ptr : buf; beg <= buf + size; beg++)
    {
      size_t offset = kwsexec (kwset, beg, buf + size - beg, &kwsmatch);
      if (offset == (size_t) -1)
	goto failure;
#ifdef MBS_SUPPORT
      if (MB_CUR_MAX > 1 && is_mb_middle (&mb_start, beg + offset, buf + size))
        {
          beg = mb_start - 1;
          continue; /* It is a part of multibyte character.  */
        }
#endif /* MBS_SUPPORT */
      beg += offset;
      len = kwsmatch.size[0];
      if (start_ptr && !match_words)
	goto success_in_beg_and_len;
      if (match_lines)
	{
	  if (beg > buf && beg[-1] != eol)
	    continue;
	  if (beg + len < buf + size && beg[len] != eol)
	    continue;
	  goto success;
	}
      else if (match_words)
	for (try = beg; len; )
	  {
	    if (try > buf && WCHAR((unsigned char) try[-1]))
	      break;
	    if (try + len < buf + size && WCHAR((unsigned char) try[len]))
	      {
		offset = kwsexec (kwset, beg, --len, &kwsmatch);
		if (offset == (size_t) -1)
		  break;
		try = beg + offset;
		len = kwsmatch.size[0];
	      }
	    else if (!start_ptr)
	      goto success;
	    else
	      goto success_in_beg_and_len;
	  } /* for (try) */
      else
	goto success;
    } /* for (beg in buf) */

 failure:
  ret_val = -1;
  goto out;

 success:
  if ((end = memchr (beg + len, eol, (buf + size) - (beg + len))) != NULL)
    end++;
  else
    end = buf + size;
  while (buf < beg && beg[-1] != eol)
    --beg;
  len = end - beg;
 success_in_beg_and_len:
  *match_size = len;
  ret_val = beg - buf;
 out:
  return ret_val;
}
#endif /* defined(GREP_PROGRAM) || defined(FGREP_PROGRAM) */

#ifdef GREP_PROGRAM
#if HAVE_LIBPCRE
/* Compiled internal form of a Perl regular expression.  */
static pcre *cre;

/* Additional information about the pattern.  */
static pcre_extra *extra;
#endif

COMPILE_FCT(Pcompile)
{
#if !HAVE_LIBPCRE
  error (EXIT_TROUBLE, 0, "%s",
	 _("support for the -P option is not compiled into "
	   "this --disable-perl-regexp binary"));
#else
  int e;
  char const *ep;
  char *re = xmalloc (4 * size + 7);
  int flags = PCRE_MULTILINE | (match_icase ? PCRE_CASELESS : 0);
  char const *patlim = pattern + size;
  char *n = re;
  char const *p;
  char const *pnul;

  /* FIXME: Remove these restrictions.  */
  if (memchr(pattern, '\n', size))
    error (EXIT_TROUBLE, 0, _("the -P option only supports a single pattern"));

  *n = '\0';
  if (match_lines)
    strcpy (n, "^(");
  if (match_words)
    strcpy (n, "\\b(");
  n += strlen (n);

  /* The PCRE interface doesn't allow NUL bytes in the pattern, so
     replace each NUL byte in the pattern with the four characters
     "\000", removing a preceding backslash if there are an odd
     number of backslashes before the NUL.

     FIXME: This method does not work with some multibyte character
     encodings, notably Shift-JIS, where a multibyte character can end
     in a backslash byte.  */
  for (p = pattern; (pnul = memchr (p, '\0', patlim - p)); p = pnul + 1)
    {
      memcpy (n, p, pnul - p);
      n += pnul - p;
      for (p = pnul; pattern < p && p[-1] == '\\'; p--)
	continue;
      n -= (pnul - p) & 1;
      strcpy (n, "\\000");
      n += 4;
    }

  memcpy (n, p, patlim - p);
  n += patlim - p;
  *n = '\0';
  if (match_words)
    strcpy (n, ")\\b");
  if (match_lines)
    strcpy (n, ")$");

  cre = pcre_compile (re, flags, &ep, &e, pcre_maketables ());
  if (!cre)
    error (EXIT_TROUBLE, 0, "%s", ep);

  extra = pcre_study (cre, 0, &ep);
  if (ep)
    error (EXIT_TROUBLE, 0, "%s", ep);

  free (re);
#endif
}

EXECUTE_FCT(Pexecute)
{
#if !HAVE_LIBPCRE
  abort ();
  return -1;
#else
  /* This array must have at least two elements; everything after that
     is just for performance improvement in pcre_exec.  */
  int sub[300];

  const char *line_buf, *line_end, *line_next;
  int e = PCRE_ERROR_NOMATCH;
  ptrdiff_t start_ofs = start_ptr ? start_ptr - buf : 0;

  /* PCRE can't limit the matching to single lines, therefore we have to
     match each line in the buffer separately.  */
  for (line_next = buf;
       e == PCRE_ERROR_NOMATCH && line_next < buf + size;
       start_ofs -= line_next - line_buf)
    {
      line_buf = line_next;
      line_end = memchr (line_buf, eolbyte, (buf + size) - line_buf);
      if (line_end == NULL)
        line_next = line_end = buf + size;
      else
        line_next = line_end + 1;

      if (start_ptr && start_ptr >= line_end)
        continue;

      e = pcre_exec (cre, extra, line_buf, line_end - line_buf,
                     start_ofs < 0 ? 0 : start_ofs, 0,
                     sub, sizeof sub / sizeof *sub);
    }

  if (e <= 0)
    {
      switch (e)
	{
	case PCRE_ERROR_NOMATCH:
	  return -1;

	case PCRE_ERROR_NOMEMORY:
	  error (EXIT_TROUBLE, 0, _("memory exhausted"));

	default:
	  abort ();
	}
    }
  else
    {
      /* Narrow down to the line we've found.  */
      char const *beg = line_buf + sub[0];
      char const *end = line_buf + sub[1];
      char const *buflim = buf + size;
      char eol = eolbyte;
      if (!start_ptr)
	{
	  /* FIXME: The case when '\n' is not found indicates a bug:
	     Since grep is line oriented, the match should never contain
	     a newline, so there _must_ be a newline following.
	   */
	  if (!(end = memchr (end, eol, buflim - end)))
	    end = buflim;
	  else
	    end++;
	  while (buf < beg && beg[-1] != eol)
	    --beg;
	}

      *match_size = end - beg;
      return beg - buf;
    }
#endif
}

struct matcher const matchers[] = {
  { "default", Gcompile, EGexecute },
  { "grep",    Gcompile, EGexecute },
  { "egrep",   Ecompile, EGexecute },
  { "awk",     Acompile, EGexecute },
  { "fgrep",   Fcompile, Fexecute },
  { "perl",    Pcompile, Pexecute },
  { "", 0, 0 },
};
#endif /* GREP_PROGRAM */

Spawn 1 instances, now Total 11
Counter: 12
Batcher Size:11
Preprocess the following candidate with CondTester:
Priority 20000
At location src/search.c:603
--Src File: src/search.c
Fragment 0:
if (((err = kwsincr(kwset, beg, end - beg)) != ((void *)0)) || (__abst_hole(beg, end, err, kwset, lim, pat, psize, pattern, match_icase, size)))
    error(EXIT_TROUBLE, 0, "%s", err);


CondTester, a patch instance with id 11:
//src_file:src/search.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
/* search.c - searching subroutines using dfa, kwset and regex for grep.
   Copyright 1992, 1998, 2000, 2007, 2009-2010 Free Software Foundation, Inc.

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 3, or (at your option)
   any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program; if not, write to the Free Software
   Foundation, Inc., 51 Franklin Street - Fifth Floor, Boston, MA
   02110-1301, USA.  */

/* Written August 1992 by Mike Haertel. */

#include <config.h>

#include <sys/types.h>

#include "mbsupport.h"
#ifdef MBS_SUPPORT
/* We can handle multibyte strings. */
# include <wchar.h>
# include <wctype.h>
#endif

#include "system.h"
#include "grep.h"
#ifndef FGREP_PROGRAM
# include <regex.h>
# include "dfa.h"
#endif
#include "kwset.h"
#include "error.h"
#include "xalloc.h"
#ifdef HAVE_LIBPCRE
# include <pcre.h>
#endif

#define NCHAR (UCHAR_MAX + 1)

/* For -w, we also consider _ to be word constituent.  */
#define WCHAR(C) (ISALNUM(C) || (C) == '_')

/* KWset compiled pattern.  For Ecompile and Gcompile, we compile
   a list of strings, at least one of which is known to occur in
   any string matching the regexp. */
static kwset_t kwset;

static void
kwsinit (void)
{
  static char trans[NCHAR];
  int i;

  if (match_icase && MB_CUR_MAX == 1)
    {
      for (i = 0; i < NCHAR; ++i)
        trans[i] = TOLOWER (i);

      kwset = kwsalloc (trans);
    }
  else
    kwset = kwsalloc (NULL);

  if (!kwset)
    xalloc_die ();
}

#ifdef MBS_SUPPORT
/* Convert the *N-byte string, BEG, to lowercase, and write the
   NUL-terminated result into malloc'd storage.  Upon success, set *N
   to the length (in bytes) of the resulting string (not including the
   trailing NUL byte), and return a pointer to the lowercase string.
   Upon memory allocation failure, this function exits.

   Note that while this function returns a pointer to malloc'd storage,
   the caller must not free it, since this function retains a pointer
   to the buffer and reuses it on any subsequent call.  As a consequence,
   this function is not thread-safe.  */
static char *
mbtolower (const char *beg, size_t *n)
{
  static char *out;
  static size_t outalloc;
  size_t outlen, mb_cur_max;
  mbstate_t is, os;
  const char *end;
  char *p;

  if (*n > outalloc)
    {
      out = xrealloc (out, *n);
      outalloc = *n;
    }

  memset (&is, 0, sizeof (is));
  memset (&os, 0, sizeof (os));
  end = beg + *n;

  mb_cur_max = MB_CUR_MAX;
  p = out;
  outlen = 0;
  while (beg < end)
    {
      wchar_t wc;
      size_t mbclen = mbrtowc(&wc, beg, end - beg, &is);
      if (outlen + mb_cur_max >= outalloc)
        {
          out = x2nrealloc (out, &outalloc, 1);
          p = out + outlen;
        }

      if (mbclen == (size_t) -1 || mbclen == (size_t) -2 || mbclen == 0)
        {
          /* An invalid sequence, or a truncated multi-octet character.
             We treat it as a single-octet character.  */
          *p++ = *beg++;
          outlen++;
          memset (&is, 0, sizeof (is));
          memset (&os, 0, sizeof (os));
        }
      else
        {
          beg += mbclen;
          mbclen = wcrtomb (p, towlower ((wint_t) wc), &os);
          p += mbclen;
          outlen += mbclen;
        }
    }

  *n = p - out;
  *p++ = 0;
  return out;
}
#endif


#ifndef FGREP_PROGRAM
/* DFA compiled regexp. */
static struct dfa dfa;

/* The Regex compiled patterns.  */
static struct patterns
{
  /* Regex compiled regexp. */
  struct re_pattern_buffer regexbuf;
  struct re_registers regs; /* This is here on account of a BRAIN-DEAD
			       Q@#%!# library interface in regex.c.  */
} patterns0;

struct patterns *patterns;
size_t pcount;

void
dfaerror (char const *mesg)
{
  error (EXIT_TROUBLE, 0, "%s", mesg);
}

/* Number of compiled fixed strings known to exactly match the regexp.
   If kwsexec returns < kwset_exact_matches, then we don't need to
   call the regexp matcher at all. */
static int kwset_exact_matches;

static char const *
kwsincr_case (const char *must)
{
  const char *buf;
  size_t n;

  n = strlen (must);
#ifdef MBS_SUPPORT
  if (match_icase && MB_CUR_MAX > 1)
    buf = mbtolower (must, &n);
  else
#endif
    buf = must;
  return kwsincr (kwset, buf, n);
}

/* If the DFA turns out to have some set of fixed strings one of
   which must occur in the match, then we build a kwset matcher
   to find those strings, and thus quickly filter out impossible
   matches. */
static void
kwsmusts (void)
{
  struct dfamust const *dm;
  char const *err;

  if (dfa.musts)
    {
      kwsinit ();
      /* First, we compile in the substrings known to be exact
	 matches.  The kwset matcher will return the index
	 of the matching string that it chooses. */
      for (dm = dfa.musts; dm; dm = dm->next)
	{
	  if (!dm->exact)
	    continue;
	  ++kwset_exact_matches;
	  if ((err = kwsincr_case (dm->must)) != NULL)
	    error (EXIT_TROUBLE, 0, "%s", err);
	}
      /* Now, we compile the substrings that will require
	 the use of the regexp matcher.  */
      for (dm = dfa.musts; dm; dm = dm->next)
	{
	  if (dm->exact)
	    continue;
	  if ((err = kwsincr_case (dm->must)) != NULL)
	    error (EXIT_TROUBLE, 0, "%s", err);
	}
      if ((err = kwsprep (kwset)) != NULL)
	error (EXIT_TROUBLE, 0, "%s", err);
    }
}
#endif /* !FGREP_PROGRAM */

#ifdef MBS_SUPPORT

static bool
is_mb_middle(const char **good, const char *buf, const char *end)
{
  const char *p = *good;
  const char *prev = p;
  mbstate_t cur_state;

  /* TODO: can be optimized for UTF-8.  */
  memset(&cur_state, 0, sizeof(mbstate_t));
  while (p < buf)
    {
      size_t mbclen = mbrlen(p, end - p, &cur_state);

      /* Store the beginning of the previous complete multibyte character.  */
      if (mbclen != (size_t) -2)
        prev = p;

      if (mbclen == (size_t) -1 || mbclen == (size_t) -2 || mbclen == 0)
	{
	  /* An invalid sequence, or a truncated multibyte character.
	     We treat it as a single byte character.  */
	  mbclen = 1;
	}
      p += mbclen;
    }

  *good = prev;
  return p > buf;
}
#endif /* MBS_SUPPORT */

#if defined(GREP_PROGRAM) || defined(EGREP_PROGRAM)
#ifdef EGREP_PROGRAM
COMPILE_FCT(Ecompile)
{
  reg_syntax_t syntax_bits = RE_SYNTAX_POSIX_EGREP;
#else
/* No __VA_ARGS__ in C89.  So we have to do it this way.  */
static COMPILE_RET
GEAcompile (char const *pattern, size_t size, reg_syntax_t syntax_bits)
{
#endif /* EGREP_PROGRAM */
  const char *err;
  const char *p, *sep;
  size_t total = size;
  char *motif;

  if (match_icase)
    syntax_bits |= RE_ICASE;
  re_set_syntax (syntax_bits);
  dfasyntax (syntax_bits, match_icase, eolbyte);

  /* For GNU regex compiler we have to pass the patterns separately to detect
     errors like "[\nallo\n]\n".  The patterns here are "[", "allo" and "]"
     GNU regex should have raise a syntax error.  The same for backref, where
     the backref should have been local to each pattern.  */
  p = pattern;
  do
    {
      size_t len;
      sep = memchr (p, '\n', total);
      if (sep)
	{
	  len = sep - p;
	  sep++;
	  total -= (len + 1);
	}
      else
	{
	  len = total;
	  total = 0;
	}

      patterns = realloc (patterns, (pcount + 1) * sizeof (*patterns));
      if (patterns == NULL)
	error (EXIT_TROUBLE, errno, _("memory exhausted"));
      patterns[pcount] = patterns0;

      if ((err = re_compile_pattern (p, len,
				    &(patterns[pcount].regexbuf))) != NULL)
	error (EXIT_TROUBLE, 0, "%s", err);
      pcount++;

      p = sep;
    } while (sep && total != 0);

  /* In the match_words and match_lines cases, we use a different pattern
     for the DFA matcher that will quickly throw out cases that won't work.
     Then if DFA succeeds we do some hairy stuff using the regex matcher
     to decide whether the match should really count. */
  if (match_words || match_lines)
    {
      static char const line_beg_no_bk[] = "^(";
      static char const line_end_no_bk[] = ")$";
      static char const word_beg_no_bk[] = "(^|[^[:alnum:]_])(";
      static char const word_end_no_bk[] = ")([^[:alnum:]_]|$)";
#ifdef EGREP_PROGRAM
# define IF_BK(x, y) (y)
      char *n = xmalloc (sizeof word_beg_no_bk - 1 + size + sizeof word_end_no_bk);
#else
      static char const line_beg_bk[] = "^\\(";
      static char const line_end_bk[] = "\\)$";
      static char const word_beg_bk[] = "\\(^\\|[^[:alnum:]_]\\)\\(";
      static char const word_end_bk[] = "\\)\\([^[:alnum:]_]\\|$\\)";
      int bk = !(syntax_bits & RE_NO_BK_PARENS);
# define IF_BK(x, y) ((bk) ? (x) : (y))
      char *n = xmalloc (sizeof word_beg_bk - 1 + size + sizeof word_end_bk);
#endif /* EGREP_PROGRAM */

      strcpy (n, match_lines ? IF_BK(line_beg_bk, line_beg_no_bk)
			     : IF_BK(word_beg_bk, word_beg_no_bk));
      total = strlen(n);
      memcpy (n + total, pattern, size);
      total += size;
      strcpy (n + total, match_lines ? IF_BK(line_end_bk, line_end_no_bk)
				     : IF_BK(word_end_bk, word_end_no_bk));
      total += strlen (n + total);
      pattern = motif = n;
      size = total;
    }
  else
    motif = NULL;

  dfacomp (pattern, size, &dfa, 1);
  kwsmusts ();

  free(motif);
}

#ifndef EGREP_PROGRAM
COMPILE_FCT(Gcompile)
{
  return GEAcompile (pattern, size,
		     RE_SYNTAX_GREP | RE_HAT_LISTS_NOT_NEWLINE);
}

COMPILE_FCT(Acompile)
{
  return GEAcompile (pattern, size, RE_SYNTAX_AWK);
}

COMPILE_FCT(Ecompile)
{
  return GEAcompile (pattern, size, RE_SYNTAX_POSIX_EGREP);
}
#endif /* !EGREP_PROGRAM */

EXECUTE_FCT(EGexecute)
{
  char const *buflim, *beg, *end, *match, *best_match, *mb_start;
  char eol = eolbyte;
  int backref, start, len, best_len;
  struct kwsmatch kwsm;
  size_t i, ret_val;
#ifdef MBS_SUPPORT
  if (MB_CUR_MAX > 1)
    {
      if (match_icase)
        {
          /* mbtolower adds a NUL byte at the end.  That will provide
	     space for the sentinel byte dfaexec may add.  */
          char *case_buf = mbtolower (buf, &size);
	  if (start_ptr)
	    start_ptr = case_buf + (start_ptr - buf);
          buf = case_buf;
        }
    }
#endif /* MBS_SUPPORT */

  mb_start = buf;
  buflim = buf + size;

  for (beg = end = buf; end < buflim; beg = end)
    {
      if (!start_ptr)
	{
	  /* We don't care about an exact match.  */
	  if (kwset)
	    {
	      /* Find a possible match using the KWset matcher. */
	      size_t offset = kwsexec (kwset, beg, buflim - beg, &kwsm);
	      if (offset == (size_t) -1)
		goto failure;
	      beg += offset;
	      /* Narrow down to the line containing the candidate, and
		 run it through DFA. */
	      if ((end = memchr(beg, eol, buflim - beg)) != NULL)
	        end++;
              else
                end = buflim;
	      match = beg;
	      while (beg > buf && beg[-1] != eol)
		--beg;
	      if (kwsm.index < kwset_exact_matches)
                {
#ifdef MBS_SUPPORT
                  if (mb_start < beg)
                    mb_start = beg;
                  if (MB_CUR_MAX == 1 || !is_mb_middle (&mb_start, match, buflim))
#endif
                    goto success;
                }
	      if (dfaexec (&dfa, beg, (char *) end, 0, NULL, &backref) == NULL)
		continue;
	    }
	  else
	    {
	      /* No good fixed strings; start with DFA. */
	      char const *next_beg = dfaexec (&dfa, beg, (char *) buflim,
					      0, NULL, &backref);
	      if (next_beg == NULL)
		break;
	      /* Narrow down to the line we've found. */
	      beg = next_beg;
	      if ((end = memchr(beg, eol, buflim - beg)) != NULL)
	        end++;
              else
                end = buflim;
	      while (beg > buf && beg[-1] != eol)
		--beg;
	    }
	  /* Successful, no backreferences encountered! */
	  if (!backref)
	    goto success;
	}
      else
	{
	  /* We are looking for the leftmost (then longest) exact match.
	     We will go through the outer loop only once.  */
	  beg = start_ptr;
	  end = buflim;
	}

      /* If we've made it to this point, this means DFA has seen
	 a probable match, and we need to run it through Regex. */
      best_match = end;
      best_len = 0;
      for (i = 0; i < pcount; i++)
	{
	  patterns[i].regexbuf.not_eol = 0;
	  if (0 <= (start = re_search (&(patterns[i].regexbuf),
				       buf, end - buf - 1,
				       beg - buf, end - beg - 1,
				       &(patterns[i].regs))))
	    {
	      len = patterns[i].regs.end[0] - start;
	      match = buf + start;
	      if (match > best_match)
		continue;
	      if (start_ptr && !match_words)
		goto assess_pattern_match;
	      if ((!match_lines && !match_words)
		  || (match_lines && len == end - beg - 1))
		{
		  match = beg;
		  len = end - beg;
		  goto assess_pattern_match;
		}
	      /* If -w, check if the match aligns with word boundaries.
		 We do this iteratively because:
		 (a) the line may contain more than one occurence of the
		 pattern, and
		 (b) Several alternatives in the pattern might be valid at a
		 given point, and we may need to consider a shorter one to
		 find a word boundary.  */
	      if (match_words)
		while (match <= best_match)
		  {
		    if ((match == buf || !WCHAR ((unsigned char) match[-1]))
			&& (len == end - beg - 1
			    || !WCHAR ((unsigned char) match[len])))
		      goto assess_pattern_match;
		    if (len > 0)
		      {
			/* Try a shorter length anchored at the same place. */
			--len;
			patterns[i].regexbuf.not_eol = 1;
			len = re_match (&(patterns[i].regexbuf),
					buf, match + len - beg, match - buf,
					&(patterns[i].regs));
		      }
		    if (len <= 0)
		      {
			/* Try looking further on. */
			if (match == end - 1)
			  break;
			match++;
			patterns[i].regexbuf.not_eol = 0;
			start = re_search (&(patterns[i].regexbuf),
					   buf, end - buf - 1,
					   match - buf, end - match - 1,
					   &(patterns[i].regs));
			if (start < 0)
			  break;
			len = patterns[i].regs.end[0] - start;
			match = buf + start;
		      }
		  } /* while (match <= best_match) */
	      continue;
	    assess_pattern_match:
	      if (!start_ptr)
		{
		  /* Good enough for a non-exact match.
		     No need to look at further patterns, if any.  */
		  beg = match;
		  goto success_in_len;
		}
	      if (match < best_match || (match == best_match && len > best_len))
		{
		  /* Best exact match:  leftmost, then longest.  */
		  best_match = match;
		  best_len = len;
		}
	    } /* if re_search >= 0 */
	} /* for Regex patterns.  */
	if (best_match < end)
	  {
	    /* We have found an exact match.  We were just
	       waiting for the best one (leftmost then longest).  */
	    beg = best_match;
	    len = best_len;
	    goto success_in_len;
	  }
    } /* for (beg = end ..) */

 failure:
  ret_val = -1;
  goto out;

 success:
  len = end - beg;
 success_in_len:
  *match_size = len;
  ret_val = beg - buf;
 out:
  return ret_val;
}
#endif /* defined(GREP_PROGRAM) || defined(EGREP_PROGRAM) */

#if defined(GREP_PROGRAM) || defined(FGREP_PROGRAM)
COMPILE_FCT(Fcompile)
{
  char const *beg, *end, *lim, *err, *pat;
  size_t psize;

  kwsinit ();
  psize = size;
  if (match_icase && MB_CUR_MAX > 1)
    pat = mbtolower (pattern, &psize);
  else
    pat = pattern;

  beg = pat;
  do
    {
      for (lim = beg;; ++lim)
	{
	  end = lim;
	  if (lim >= pat + psize)
	    break;
	 if (*lim == '\n')
	   {
	     lim++;
	     break;
	   }
#if HAVE_DOS_FILE_CONTENTS
	 if (*lim == '\r' && lim + 1 < pat + psize && lim[1] == '\n')
	   {
	     lim += 2;
	     break;
	   }
#endif
	}

      
//Patch 0:
if (((err = kwsincr(kwset, beg, end - beg)) != ((void *)0)) || (__is_neg(10, &(beg), sizeof (beg), &(end), sizeof (end), &(err), sizeof (err), &(kwset), sizeof (kwset), &(lim), sizeof (lim), &(pat), sizeof (pat), &(psize), sizeof (psize), &(pattern), sizeof (pattern), &(match_icase), sizeof (match_icase), &(size), sizeof (size))))
    error(EXIT_TROUBLE, 0, "%s", err);

//CodeSeg 1:
      beg = lim;
    }
  while (beg < pat + psize);

  if ((err = kwsprep (kwset)) != NULL)
    error (EXIT_TROUBLE, 0, "%s", err);
}

EXECUTE_FCT(Fexecute)
{
  char const *beg, *try, *end, *mb_start;
  size_t len;
  char eol = eolbyte;
  struct kwsmatch kwsmatch;
  size_t ret_val;
#ifdef MBS_SUPPORT
  if (MB_CUR_MAX > 1)
    {
      if (match_icase)
        {
          char *case_buf = mbtolower (buf, &size);
	  if (start_ptr)
	    start_ptr = case_buf + (start_ptr - buf);
          buf = case_buf;
        }
    }
#endif /* MBS_SUPPORT */

  for (mb_start = beg = start_ptr ? start_ptr : buf; beg <= buf + size; beg++)
    {
      size_t offset = kwsexec (kwset, beg, buf + size - beg, &kwsmatch);
      if (offset == (size_t) -1)
	goto failure;
#ifdef MBS_SUPPORT
      if (MB_CUR_MAX > 1 && is_mb_middle (&mb_start, beg + offset, buf + size))
        {
          beg = mb_start - 1;
          continue; /* It is a part of multibyte character.  */
        }
#endif /* MBS_SUPPORT */
      beg += offset;
      len = kwsmatch.size[0];
      if (start_ptr && !match_words)
	goto success_in_beg_and_len;
      if (match_lines)
	{
	  if (beg > buf && beg[-1] != eol)
	    continue;
	  if (beg + len < buf + size && beg[len] != eol)
	    continue;
	  goto success;
	}
      else if (match_words)
	for (try = beg; len; )
	  {
	    if (try > buf && WCHAR((unsigned char) try[-1]))
	      break;
	    if (try + len < buf + size && WCHAR((unsigned char) try[len]))
	      {
		offset = kwsexec (kwset, beg, --len, &kwsmatch);
		if (offset == (size_t) -1)
		  break;
		try = beg + offset;
		len = kwsmatch.size[0];
	      }
	    else if (!start_ptr)
	      goto success;
	    else
	      goto success_in_beg_and_len;
	  } /* for (try) */
      else
	goto success;
    } /* for (beg in buf) */

 failure:
  ret_val = -1;
  goto out;

 success:
  if ((end = memchr (beg + len, eol, (buf + size) - (beg + len))) != NULL)
    end++;
  else
    end = buf + size;
  while (buf < beg && beg[-1] != eol)
    --beg;
  len = end - beg;
 success_in_beg_and_len:
  *match_size = len;
  ret_val = beg - buf;
 out:
  return ret_val;
}
#endif /* defined(GREP_PROGRAM) || defined(FGREP_PROGRAM) */

#ifdef GREP_PROGRAM
#if HAVE_LIBPCRE
/* Compiled internal form of a Perl regular expression.  */
static pcre *cre;

/* Additional information about the pattern.  */
static pcre_extra *extra;
#endif

COMPILE_FCT(Pcompile)
{
#if !HAVE_LIBPCRE
  error (EXIT_TROUBLE, 0, "%s",
	 _("support for the -P option is not compiled into "
	   "this --disable-perl-regexp binary"));
#else
  int e;
  char const *ep;
  char *re = xmalloc (4 * size + 7);
  int flags = PCRE_MULTILINE | (match_icase ? PCRE_CASELESS : 0);
  char const *patlim = pattern + size;
  char *n = re;
  char const *p;
  char const *pnul;

  /* FIXME: Remove these restrictions.  */
  if (memchr(pattern, '\n', size))
    error (EXIT_TROUBLE, 0, _("the -P option only supports a single pattern"));

  *n = '\0';
  if (match_lines)
    strcpy (n, "^(");
  if (match_words)
    strcpy (n, "\\b(");
  n += strlen (n);

  /* The PCRE interface doesn't allow NUL bytes in the pattern, so
     replace each NUL byte in the pattern with the four characters
     "\000", removing a preceding backslash if there are an odd
     number of backslashes before the NUL.

     FIXME: This method does not work with some multibyte character
     encodings, notably Shift-JIS, where a multibyte character can end
     in a backslash byte.  */
  for (p = pattern; (pnul = memchr (p, '\0', patlim - p)); p = pnul + 1)
    {
      memcpy (n, p, pnul - p);
      n += pnul - p;
      for (p = pnul; pattern < p && p[-1] == '\\'; p--)
	continue;
      n -= (pnul - p) & 1;
      strcpy (n, "\\000");
      n += 4;
    }

  memcpy (n, p, patlim - p);
  n += patlim - p;
  *n = '\0';
  if (match_words)
    strcpy (n, ")\\b");
  if (match_lines)
    strcpy (n, ")$");

  cre = pcre_compile (re, flags, &ep, &e, pcre_maketables ());
  if (!cre)
    error (EXIT_TROUBLE, 0, "%s", ep);

  extra = pcre_study (cre, 0, &ep);
  if (ep)
    error (EXIT_TROUBLE, 0, "%s", ep);

  free (re);
#endif
}

EXECUTE_FCT(Pexecute)
{
#if !HAVE_LIBPCRE
  abort ();
  return -1;
#else
  /* This array must have at least two elements; everything after that
     is just for performance improvement in pcre_exec.  */
  int sub[300];

  const char *line_buf, *line_end, *line_next;
  int e = PCRE_ERROR_NOMATCH;
  ptrdiff_t start_ofs = start_ptr ? start_ptr - buf : 0;

  /* PCRE can't limit the matching to single lines, therefore we have to
     match each line in the buffer separately.  */
  for (line_next = buf;
       e == PCRE_ERROR_NOMATCH && line_next < buf + size;
       start_ofs -= line_next - line_buf)
    {
      line_buf = line_next;
      line_end = memchr (line_buf, eolbyte, (buf + size) - line_buf);
      if (line_end == NULL)
        line_next = line_end = buf + size;
      else
        line_next = line_end + 1;

      if (start_ptr && start_ptr >= line_end)
        continue;

      e = pcre_exec (cre, extra, line_buf, line_end - line_buf,
                     start_ofs < 0 ? 0 : start_ofs, 0,
                     sub, sizeof sub / sizeof *sub);
    }

  if (e <= 0)
    {
      switch (e)
	{
	case PCRE_ERROR_NOMATCH:
	  return -1;

	case PCRE_ERROR_NOMEMORY:
	  error (EXIT_TROUBLE, 0, _("memory exhausted"));

	default:
	  abort ();
	}
    }
  else
    {
      /* Narrow down to the line we've found.  */
      char const *beg = line_buf + sub[0];
      char const *end = line_buf + sub[1];
      char const *buflim = buf + size;
      char eol = eolbyte;
      if (!start_ptr)
	{
	  /* FIXME: The case when '\n' is not found indicates a bug:
	     Since grep is line oriented, the match should never contain
	     a newline, so there _must_ be a newline following.
	   */
	  if (!(end = memchr (end, eol, buflim - end)))
	    end = buflim;
	  else
	    end++;
	  while (buf < beg && beg[-1] != eol)
	    --beg;
	}

      *match_size = end - beg;
      return beg - buf;
    }
#endif
}

struct matcher const matchers[] = {
  { "default", Gcompile, EGexecute },
  { "grep",    Gcompile, EGexecute },
  { "egrep",   Ecompile, EGexecute },
  { "awk",     Acompile, EGexecute },
  { "fgrep",   Fcompile, Fexecute },
  { "perl",    Pcompile, Pexecute },
  { "", 0, 0 },
};
#endif /* GREP_PROGRAM */

Spawn 1 instances, now Total 12
Counter: 13
Batcher Size:12
Preprocess the following candidate with CondTester:
Priority 20000
At location src/search.c:639
--Src File: src/search.c
Fragment 0:
if (((__ctype_get_mb_cur_max()) > 1 && is_mb_middle(&mb_start, beg + offset, buf + size)) && !(__abst_hole(buf, size, beg, mb_start, offset, kwset, start_ptr, len, match_words, match_lines, eol, match_icase, try, eolbyte, ret_val, end, match_size))) {
    beg = mb_start - 1;
    continue;
}


CondTester, a patch instance with id 12:
//src_file:src/search.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
/* search.c - searching subroutines using dfa, kwset and regex for grep.
   Copyright 1992, 1998, 2000, 2007, 2009-2010 Free Software Foundation, Inc.

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 3, or (at your option)
   any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program; if not, write to the Free Software
   Foundation, Inc., 51 Franklin Street - Fifth Floor, Boston, MA
   02110-1301, USA.  */

/* Written August 1992 by Mike Haertel. */

#include <config.h>

#include <sys/types.h>

#include "mbsupport.h"
#ifdef MBS_SUPPORT
/* We can handle multibyte strings. */
# include <wchar.h>
# include <wctype.h>
#endif

#include "system.h"
#include "grep.h"
#ifndef FGREP_PROGRAM
# include <regex.h>
# include "dfa.h"
#endif
#include "kwset.h"
#include "error.h"
#include "xalloc.h"
#ifdef HAVE_LIBPCRE
# include <pcre.h>
#endif

#define NCHAR (UCHAR_MAX + 1)

/* For -w, we also consider _ to be word constituent.  */
#define WCHAR(C) (ISALNUM(C) || (C) == '_')

/* KWset compiled pattern.  For Ecompile and Gcompile, we compile
   a list of strings, at least one of which is known to occur in
   any string matching the regexp. */
static kwset_t kwset;

static void
kwsinit (void)
{
  static char trans[NCHAR];
  int i;

  if (match_icase && MB_CUR_MAX == 1)
    {
      for (i = 0; i < NCHAR; ++i)
        trans[i] = TOLOWER (i);

      kwset = kwsalloc (trans);
    }
  else
    kwset = kwsalloc (NULL);

  if (!kwset)
    xalloc_die ();
}

#ifdef MBS_SUPPORT
/* Convert the *N-byte string, BEG, to lowercase, and write the
   NUL-terminated result into malloc'd storage.  Upon success, set *N
   to the length (in bytes) of the resulting string (not including the
   trailing NUL byte), and return a pointer to the lowercase string.
   Upon memory allocation failure, this function exits.

   Note that while this function returns a pointer to malloc'd storage,
   the caller must not free it, since this function retains a pointer
   to the buffer and reuses it on any subsequent call.  As a consequence,
   this function is not thread-safe.  */
static char *
mbtolower (const char *beg, size_t *n)
{
  static char *out;
  static size_t outalloc;
  size_t outlen, mb_cur_max;
  mbstate_t is, os;
  const char *end;
  char *p;

  if (*n > outalloc)
    {
      out = xrealloc (out, *n);
      outalloc = *n;
    }

  memset (&is, 0, sizeof (is));
  memset (&os, 0, sizeof (os));
  end = beg + *n;

  mb_cur_max = MB_CUR_MAX;
  p = out;
  outlen = 0;
  while (beg < end)
    {
      wchar_t wc;
      size_t mbclen = mbrtowc(&wc, beg, end - beg, &is);
      if (outlen + mb_cur_max >= outalloc)
        {
          out = x2nrealloc (out, &outalloc, 1);
          p = out + outlen;
        }

      if (mbclen == (size_t) -1 || mbclen == (size_t) -2 || mbclen == 0)
        {
          /* An invalid sequence, or a truncated multi-octet character.
             We treat it as a single-octet character.  */
          *p++ = *beg++;
          outlen++;
          memset (&is, 0, sizeof (is));
          memset (&os, 0, sizeof (os));
        }
      else
        {
          beg += mbclen;
          mbclen = wcrtomb (p, towlower ((wint_t) wc), &os);
          p += mbclen;
          outlen += mbclen;
        }
    }

  *n = p - out;
  *p++ = 0;
  return out;
}
#endif


#ifndef FGREP_PROGRAM
/* DFA compiled regexp. */
static struct dfa dfa;

/* The Regex compiled patterns.  */
static struct patterns
{
  /* Regex compiled regexp. */
  struct re_pattern_buffer regexbuf;
  struct re_registers regs; /* This is here on account of a BRAIN-DEAD
			       Q@#%!# library interface in regex.c.  */
} patterns0;

struct patterns *patterns;
size_t pcount;

void
dfaerror (char const *mesg)
{
  error (EXIT_TROUBLE, 0, "%s", mesg);
}

/* Number of compiled fixed strings known to exactly match the regexp.
   If kwsexec returns < kwset_exact_matches, then we don't need to
   call the regexp matcher at all. */
static int kwset_exact_matches;

static char const *
kwsincr_case (const char *must)
{
  const char *buf;
  size_t n;

  n = strlen (must);
#ifdef MBS_SUPPORT
  if (match_icase && MB_CUR_MAX > 1)
    buf = mbtolower (must, &n);
  else
#endif
    buf = must;
  return kwsincr (kwset, buf, n);
}

/* If the DFA turns out to have some set of fixed strings one of
   which must occur in the match, then we build a kwset matcher
   to find those strings, and thus quickly filter out impossible
   matches. */
static void
kwsmusts (void)
{
  struct dfamust const *dm;
  char const *err;

  if (dfa.musts)
    {
      kwsinit ();
      /* First, we compile in the substrings known to be exact
	 matches.  The kwset matcher will return the index
	 of the matching string that it chooses. */
      for (dm = dfa.musts; dm; dm = dm->next)
	{
	  if (!dm->exact)
	    continue;
	  ++kwset_exact_matches;
	  if ((err = kwsincr_case (dm->must)) != NULL)
	    error (EXIT_TROUBLE, 0, "%s", err);
	}
      /* Now, we compile the substrings that will require
	 the use of the regexp matcher.  */
      for (dm = dfa.musts; dm; dm = dm->next)
	{
	  if (dm->exact)
	    continue;
	  if ((err = kwsincr_case (dm->must)) != NULL)
	    error (EXIT_TROUBLE, 0, "%s", err);
	}
      if ((err = kwsprep (kwset)) != NULL)
	error (EXIT_TROUBLE, 0, "%s", err);
    }
}
#endif /* !FGREP_PROGRAM */

#ifdef MBS_SUPPORT

static bool
is_mb_middle(const char **good, const char *buf, const char *end)
{
  const char *p = *good;
  const char *prev = p;
  mbstate_t cur_state;

  /* TODO: can be optimized for UTF-8.  */
  memset(&cur_state, 0, sizeof(mbstate_t));
  while (p < buf)
    {
      size_t mbclen = mbrlen(p, end - p, &cur_state);

      /* Store the beginning of the previous complete multibyte character.  */
      if (mbclen != (size_t) -2)
        prev = p;

      if (mbclen == (size_t) -1 || mbclen == (size_t) -2 || mbclen == 0)
	{
	  /* An invalid sequence, or a truncated multibyte character.
	     We treat it as a single byte character.  */
	  mbclen = 1;
	}
      p += mbclen;
    }

  *good = prev;
  return p > buf;
}
#endif /* MBS_SUPPORT */

#if defined(GREP_PROGRAM) || defined(EGREP_PROGRAM)
#ifdef EGREP_PROGRAM
COMPILE_FCT(Ecompile)
{
  reg_syntax_t syntax_bits = RE_SYNTAX_POSIX_EGREP;
#else
/* No __VA_ARGS__ in C89.  So we have to do it this way.  */
static COMPILE_RET
GEAcompile (char const *pattern, size_t size, reg_syntax_t syntax_bits)
{
#endif /* EGREP_PROGRAM */
  const char *err;
  const char *p, *sep;
  size_t total = size;
  char *motif;

  if (match_icase)
    syntax_bits |= RE_ICASE;
  re_set_syntax (syntax_bits);
  dfasyntax (syntax_bits, match_icase, eolbyte);

  /* For GNU regex compiler we have to pass the patterns separately to detect
     errors like "[\nallo\n]\n".  The patterns here are "[", "allo" and "]"
     GNU regex should have raise a syntax error.  The same for backref, where
     the backref should have been local to each pattern.  */
  p = pattern;
  do
    {
      size_t len;
      sep = memchr (p, '\n', total);
      if (sep)
	{
	  len = sep - p;
	  sep++;
	  total -= (len + 1);
	}
      else
	{
	  len = total;
	  total = 0;
	}

      patterns = realloc (patterns, (pcount + 1) * sizeof (*patterns));
      if (patterns == NULL)
	error (EXIT_TROUBLE, errno, _("memory exhausted"));
      patterns[pcount] = patterns0;

      if ((err = re_compile_pattern (p, len,
				    &(patterns[pcount].regexbuf))) != NULL)
	error (EXIT_TROUBLE, 0, "%s", err);
      pcount++;

      p = sep;
    } while (sep && total != 0);

  /* In the match_words and match_lines cases, we use a different pattern
     for the DFA matcher that will quickly throw out cases that won't work.
     Then if DFA succeeds we do some hairy stuff using the regex matcher
     to decide whether the match should really count. */
  if (match_words || match_lines)
    {
      static char const line_beg_no_bk[] = "^(";
      static char const line_end_no_bk[] = ")$";
      static char const word_beg_no_bk[] = "(^|[^[:alnum:]_])(";
      static char const word_end_no_bk[] = ")([^[:alnum:]_]|$)";
#ifdef EGREP_PROGRAM
# define IF_BK(x, y) (y)
      char *n = xmalloc (sizeof word_beg_no_bk - 1 + size + sizeof word_end_no_bk);
#else
      static char const line_beg_bk[] = "^\\(";
      static char const line_end_bk[] = "\\)$";
      static char const word_beg_bk[] = "\\(^\\|[^[:alnum:]_]\\)\\(";
      static char const word_end_bk[] = "\\)\\([^[:alnum:]_]\\|$\\)";
      int bk = !(syntax_bits & RE_NO_BK_PARENS);
# define IF_BK(x, y) ((bk) ? (x) : (y))
      char *n = xmalloc (sizeof word_beg_bk - 1 + size + sizeof word_end_bk);
#endif /* EGREP_PROGRAM */

      strcpy (n, match_lines ? IF_BK(line_beg_bk, line_beg_no_bk)
			     : IF_BK(word_beg_bk, word_beg_no_bk));
      total = strlen(n);
      memcpy (n + total, pattern, size);
      total += size;
      strcpy (n + total, match_lines ? IF_BK(line_end_bk, line_end_no_bk)
				     : IF_BK(word_end_bk, word_end_no_bk));
      total += strlen (n + total);
      pattern = motif = n;
      size = total;
    }
  else
    motif = NULL;

  dfacomp (pattern, size, &dfa, 1);
  kwsmusts ();

  free(motif);
}

#ifndef EGREP_PROGRAM
COMPILE_FCT(Gcompile)
{
  return GEAcompile (pattern, size,
		     RE_SYNTAX_GREP | RE_HAT_LISTS_NOT_NEWLINE);
}

COMPILE_FCT(Acompile)
{
  return GEAcompile (pattern, size, RE_SYNTAX_AWK);
}

COMPILE_FCT(Ecompile)
{
  return GEAcompile (pattern, size, RE_SYNTAX_POSIX_EGREP);
}
#endif /* !EGREP_PROGRAM */

EXECUTE_FCT(EGexecute)
{
  char const *buflim, *beg, *end, *match, *best_match, *mb_start;
  char eol = eolbyte;
  int backref, start, len, best_len;
  struct kwsmatch kwsm;
  size_t i, ret_val;
#ifdef MBS_SUPPORT
  if (MB_CUR_MAX > 1)
    {
      if (match_icase)
        {
          /* mbtolower adds a NUL byte at the end.  That will provide
	     space for the sentinel byte dfaexec may add.  */
          char *case_buf = mbtolower (buf, &size);
	  if (start_ptr)
	    start_ptr = case_buf + (start_ptr - buf);
          buf = case_buf;
        }
    }
#endif /* MBS_SUPPORT */

  mb_start = buf;
  buflim = buf + size;

  for (beg = end = buf; end < buflim; beg = end)
    {
      if (!start_ptr)
	{
	  /* We don't care about an exact match.  */
	  if (kwset)
	    {
	      /* Find a possible match using the KWset matcher. */
	      size_t offset = kwsexec (kwset, beg, buflim - beg, &kwsm);
	      if (offset == (size_t) -1)
		goto failure;
	      beg += offset;
	      /* Narrow down to the line containing the candidate, and
		 run it through DFA. */
	      if ((end = memchr(beg, eol, buflim - beg)) != NULL)
	        end++;
              else
                end = buflim;
	      match = beg;
	      while (beg > buf && beg[-1] != eol)
		--beg;
	      if (kwsm.index < kwset_exact_matches)
                {
#ifdef MBS_SUPPORT
                  if (mb_start < beg)
                    mb_start = beg;
                  if (MB_CUR_MAX == 1 || !is_mb_middle (&mb_start, match, buflim))
#endif
                    goto success;
                }
	      if (dfaexec (&dfa, beg, (char *) end, 0, NULL, &backref) == NULL)
		continue;
	    }
	  else
	    {
	      /* No good fixed strings; start with DFA. */
	      char const *next_beg = dfaexec (&dfa, beg, (char *) buflim,
					      0, NULL, &backref);
	      if (next_beg == NULL)
		break;
	      /* Narrow down to the line we've found. */
	      beg = next_beg;
	      if ((end = memchr(beg, eol, buflim - beg)) != NULL)
	        end++;
              else
                end = buflim;
	      while (beg > buf && beg[-1] != eol)
		--beg;
	    }
	  /* Successful, no backreferences encountered! */
	  if (!backref)
	    goto success;
	}
      else
	{
	  /* We are looking for the leftmost (then longest) exact match.
	     We will go through the outer loop only once.  */
	  beg = start_ptr;
	  end = buflim;
	}

      /* If we've made it to this point, this means DFA has seen
	 a probable match, and we need to run it through Regex. */
      best_match = end;
      best_len = 0;
      for (i = 0; i < pcount; i++)
	{
	  patterns[i].regexbuf.not_eol = 0;
	  if (0 <= (start = re_search (&(patterns[i].regexbuf),
				       buf, end - buf - 1,
				       beg - buf, end - beg - 1,
				       &(patterns[i].regs))))
	    {
	      len = patterns[i].regs.end[0] - start;
	      match = buf + start;
	      if (match > best_match)
		continue;
	      if (start_ptr && !match_words)
		goto assess_pattern_match;
	      if ((!match_lines && !match_words)
		  || (match_lines && len == end - beg - 1))
		{
		  match = beg;
		  len = end - beg;
		  goto assess_pattern_match;
		}
	      /* If -w, check if the match aligns with word boundaries.
		 We do this iteratively because:
		 (a) the line may contain more than one occurence of the
		 pattern, and
		 (b) Several alternatives in the pattern might be valid at a
		 given point, and we may need to consider a shorter one to
		 find a word boundary.  */
	      if (match_words)
		while (match <= best_match)
		  {
		    if ((match == buf || !WCHAR ((unsigned char) match[-1]))
			&& (len == end - beg - 1
			    || !WCHAR ((unsigned char) match[len])))
		      goto assess_pattern_match;
		    if (len > 0)
		      {
			/* Try a shorter length anchored at the same place. */
			--len;
			patterns[i].regexbuf.not_eol = 1;
			len = re_match (&(patterns[i].regexbuf),
					buf, match + len - beg, match - buf,
					&(patterns[i].regs));
		      }
		    if (len <= 0)
		      {
			/* Try looking further on. */
			if (match == end - 1)
			  break;
			match++;
			patterns[i].regexbuf.not_eol = 0;
			start = re_search (&(patterns[i].regexbuf),
					   buf, end - buf - 1,
					   match - buf, end - match - 1,
					   &(patterns[i].regs));
			if (start < 0)
			  break;
			len = patterns[i].regs.end[0] - start;
			match = buf + start;
		      }
		  } /* while (match <= best_match) */
	      continue;
	    assess_pattern_match:
	      if (!start_ptr)
		{
		  /* Good enough for a non-exact match.
		     No need to look at further patterns, if any.  */
		  beg = match;
		  goto success_in_len;
		}
	      if (match < best_match || (match == best_match && len > best_len))
		{
		  /* Best exact match:  leftmost, then longest.  */
		  best_match = match;
		  best_len = len;
		}
	    } /* if re_search >= 0 */
	} /* for Regex patterns.  */
	if (best_match < end)
	  {
	    /* We have found an exact match.  We were just
	       waiting for the best one (leftmost then longest).  */
	    beg = best_match;
	    len = best_len;
	    goto success_in_len;
	  }
    } /* for (beg = end ..) */

 failure:
  ret_val = -1;
  goto out;

 success:
  len = end - beg;
 success_in_len:
  *match_size = len;
  ret_val = beg - buf;
 out:
  return ret_val;
}
#endif /* defined(GREP_PROGRAM) || defined(EGREP_PROGRAM) */

#if defined(GREP_PROGRAM) || defined(FGREP_PROGRAM)
COMPILE_FCT(Fcompile)
{
  char const *beg, *end, *lim, *err, *pat;
  size_t psize;

  kwsinit ();
  psize = size;
  if (match_icase && MB_CUR_MAX > 1)
    pat = mbtolower (pattern, &psize);
  else
    pat = pattern;

  beg = pat;
  do
    {
      for (lim = beg;; ++lim)
	{
	  end = lim;
	  if (lim >= pat + psize)
	    break;
	 if (*lim == '\n')
	   {
	     lim++;
	     break;
	   }
#if HAVE_DOS_FILE_CONTENTS
	 if (*lim == '\r' && lim + 1 < pat + psize && lim[1] == '\n')
	   {
	     lim += 2;
	     break;
	   }
#endif
	}

      if ((err = kwsincr (kwset, beg, end - beg)) != NULL)
	error (EXIT_TROUBLE, 0, "%s", err);
      beg = lim;
    }
  while (beg < pat + psize);

  if ((err = kwsprep (kwset)) != NULL)
    error (EXIT_TROUBLE, 0, "%s", err);
}

EXECUTE_FCT(Fexecute)
{
  char const *beg, *try, *end, *mb_start;
  size_t len;
  char eol = eolbyte;
  struct kwsmatch kwsmatch;
  size_t ret_val;
#ifdef MBS_SUPPORT
  if (MB_CUR_MAX > 1)
    {
      if (match_icase)
        {
          char *case_buf = mbtolower (buf, &size);
	  if (start_ptr)
	    start_ptr = case_buf + (start_ptr - buf);
          buf = case_buf;
        }
    }
#endif /* MBS_SUPPORT */

  for (mb_start = beg = start_ptr ? start_ptr : buf; beg <= buf + size; beg++)
    {
      size_t offset = kwsexec (kwset, beg, buf + size - beg, &kwsmatch);
      if (offset == (size_t) -1)
	goto failure;
#ifdef MBS_SUPPORT
      
//Patch 0:
if (((__ctype_get_mb_cur_max()) > 1 && is_mb_middle(&mb_start, beg + offset, buf + size)) && !(__is_neg(17, &(buf), sizeof (buf), &(size), sizeof (size), &(beg), sizeof (beg), &(mb_start), sizeof (mb_start), &(offset), sizeof (offset), &(kwset), sizeof (kwset), &(start_ptr), sizeof (start_ptr), &(len), sizeof (len), &(match_words), sizeof (match_words), &(match_lines), sizeof (match_lines), &(eol), sizeof (eol), &(match_icase), sizeof (match_icase), &(try), sizeof (try), &(eolbyte), sizeof (eolbyte), &(ret_val), sizeof (ret_val), &(end), sizeof (end), &(match_size), sizeof (match_size)))) {
    beg = mb_start - 1;
    continue;
}

//CodeSeg 1:
#endif /* MBS_SUPPORT */
      beg += offset;
      len = kwsmatch.size[0];
      if (start_ptr && !match_words)
	goto success_in_beg_and_len;
      if (match_lines)
	{
	  if (beg > buf && beg[-1] != eol)
	    continue;
	  if (beg + len < buf + size && beg[len] != eol)
	    continue;
	  goto success;
	}
      else if (match_words)
	for (try = beg; len; )
	  {
	    if (try > buf && WCHAR((unsigned char) try[-1]))
	      break;
	    if (try + len < buf + size && WCHAR((unsigned char) try[len]))
	      {
		offset = kwsexec (kwset, beg, --len, &kwsmatch);
		if (offset == (size_t) -1)
		  break;
		try = beg + offset;
		len = kwsmatch.size[0];
	      }
	    else if (!start_ptr)
	      goto success;
	    else
	      goto success_in_beg_and_len;
	  } /* for (try) */
      else
	goto success;
    } /* for (beg in buf) */

 failure:
  ret_val = -1;
  goto out;

 success:
  if ((end = memchr (beg + len, eol, (buf + size) - (beg + len))) != NULL)
    end++;
  else
    end = buf + size;
  while (buf < beg && beg[-1] != eol)
    --beg;
  len = end - beg;
 success_in_beg_and_len:
  *match_size = len;
  ret_val = beg - buf;
 out:
  return ret_val;
}
#endif /* defined(GREP_PROGRAM) || defined(FGREP_PROGRAM) */

#ifdef GREP_PROGRAM
#if HAVE_LIBPCRE
/* Compiled internal form of a Perl regular expression.  */
static pcre *cre;

/* Additional information about the pattern.  */
static pcre_extra *extra;
#endif

COMPILE_FCT(Pcompile)
{
#if !HAVE_LIBPCRE
  error (EXIT_TROUBLE, 0, "%s",
	 _("support for the -P option is not compiled into "
	   "this --disable-perl-regexp binary"));
#else
  int e;
  char const *ep;
  char *re = xmalloc (4 * size + 7);
  int flags = PCRE_MULTILINE | (match_icase ? PCRE_CASELESS : 0);
  char const *patlim = pattern + size;
  char *n = re;
  char const *p;
  char const *pnul;

  /* FIXME: Remove these restrictions.  */
  if (memchr(pattern, '\n', size))
    error (EXIT_TROUBLE, 0, _("the -P option only supports a single pattern"));

  *n = '\0';
  if (match_lines)
    strcpy (n, "^(");
  if (match_words)
    strcpy (n, "\\b(");
  n += strlen (n);

  /* The PCRE interface doesn't allow NUL bytes in the pattern, so
     replace each NUL byte in the pattern with the four characters
     "\000", removing a preceding backslash if there are an odd
     number of backslashes before the NUL.

     FIXME: This method does not work with some multibyte character
     encodings, notably Shift-JIS, where a multibyte character can end
     in a backslash byte.  */
  for (p = pattern; (pnul = memchr (p, '\0', patlim - p)); p = pnul + 1)
    {
      memcpy (n, p, pnul - p);
      n += pnul - p;
      for (p = pnul; pattern < p && p[-1] == '\\'; p--)
	continue;
      n -= (pnul - p) & 1;
      strcpy (n, "\\000");
      n += 4;
    }

  memcpy (n, p, patlim - p);
  n += patlim - p;
  *n = '\0';
  if (match_words)
    strcpy (n, ")\\b");
  if (match_lines)
    strcpy (n, ")$");

  cre = pcre_compile (re, flags, &ep, &e, pcre_maketables ());
  if (!cre)
    error (EXIT_TROUBLE, 0, "%s", ep);

  extra = pcre_study (cre, 0, &ep);
  if (ep)
    error (EXIT_TROUBLE, 0, "%s", ep);

  free (re);
#endif
}

EXECUTE_FCT(Pexecute)
{
#if !HAVE_LIBPCRE
  abort ();
  return -1;
#else
  /* This array must have at least two elements; everything after that
     is just for performance improvement in pcre_exec.  */
  int sub[300];

  const char *line_buf, *line_end, *line_next;
  int e = PCRE_ERROR_NOMATCH;
  ptrdiff_t start_ofs = start_ptr ? start_ptr - buf : 0;

  /* PCRE can't limit the matching to single lines, therefore we have to
     match each line in the buffer separately.  */
  for (line_next = buf;
       e == PCRE_ERROR_NOMATCH && line_next < buf + size;
       start_ofs -= line_next - line_buf)
    {
      line_buf = line_next;
      line_end = memchr (line_buf, eolbyte, (buf + size) - line_buf);
      if (line_end == NULL)
        line_next = line_end = buf + size;
      else
        line_next = line_end + 1;

      if (start_ptr && start_ptr >= line_end)
        continue;

      e = pcre_exec (cre, extra, line_buf, line_end - line_buf,
                     start_ofs < 0 ? 0 : start_ofs, 0,
                     sub, sizeof sub / sizeof *sub);
    }

  if (e <= 0)
    {
      switch (e)
	{
	case PCRE_ERROR_NOMATCH:
	  return -1;

	case PCRE_ERROR_NOMEMORY:
	  error (EXIT_TROUBLE, 0, _("memory exhausted"));

	default:
	  abort ();
	}
    }
  else
    {
      /* Narrow down to the line we've found.  */
      char const *beg = line_buf + sub[0];
      char const *end = line_buf + sub[1];
      char const *buflim = buf + size;
      char eol = eolbyte;
      if (!start_ptr)
	{
	  /* FIXME: The case when '\n' is not found indicates a bug:
	     Since grep is line oriented, the match should never contain
	     a newline, so there _must_ be a newline following.
	   */
	  if (!(end = memchr (end, eol, buflim - end)))
	    end = buflim;
	  else
	    end++;
	  while (buf < beg && beg[-1] != eol)
	    --beg;
	}

      *match_size = end - beg;
      return beg - buf;
    }
#endif
}

struct matcher const matchers[] = {
  { "default", Gcompile, EGexecute },
  { "grep",    Gcompile, EGexecute },
  { "egrep",   Ecompile, EGexecute },
  { "awk",     Acompile, EGexecute },
  { "fgrep",   Fcompile, Fexecute },
  { "perl",    Pcompile, Pexecute },
  { "", 0, 0 },
};
#endif /* GREP_PROGRAM */

Spawn 1 instances, now Total 13
Counter: 14
Batcher Size:13
Preprocess the following candidate with CondTester:
Priority 20000
At location src/search.c:639
--Src File: src/search.c
Fragment 0:
if (((__ctype_get_mb_cur_max()) > 1 && is_mb_middle(&mb_start, beg + offset, buf + size)) || (__abst_hole(buf, size, beg, mb_start, offset, kwset, start_ptr, len, match_words, match_lines, eol, match_icase, try, eolbyte, ret_val, end, match_size))) {
    beg = mb_start - 1;
    continue;
}


CondTester, a patch instance with id 13:
//src_file:src/search.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
/* search.c - searching subroutines using dfa, kwset and regex for grep.
   Copyright 1992, 1998, 2000, 2007, 2009-2010 Free Software Foundation, Inc.

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 3, or (at your option)
   any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program; if not, write to the Free Software
   Foundation, Inc., 51 Franklin Street - Fifth Floor, Boston, MA
   02110-1301, USA.  */

/* Written August 1992 by Mike Haertel. */

#include <config.h>

#include <sys/types.h>

#include "mbsupport.h"
#ifdef MBS_SUPPORT
/* We can handle multibyte strings. */
# include <wchar.h>
# include <wctype.h>
#endif

#include "system.h"
#include "grep.h"
#ifndef FGREP_PROGRAM
# include <regex.h>
# include "dfa.h"
#endif
#include "kwset.h"
#include "error.h"
#include "xalloc.h"
#ifdef HAVE_LIBPCRE
# include <pcre.h>
#endif

#define NCHAR (UCHAR_MAX + 1)

/* For -w, we also consider _ to be word constituent.  */
#define WCHAR(C) (ISALNUM(C) || (C) == '_')

/* KWset compiled pattern.  For Ecompile and Gcompile, we compile
   a list of strings, at least one of which is known to occur in
   any string matching the regexp. */
static kwset_t kwset;

static void
kwsinit (void)
{
  static char trans[NCHAR];
  int i;

  if (match_icase && MB_CUR_MAX == 1)
    {
      for (i = 0; i < NCHAR; ++i)
        trans[i] = TOLOWER (i);

      kwset = kwsalloc (trans);
    }
  else
    kwset = kwsalloc (NULL);

  if (!kwset)
    xalloc_die ();
}

#ifdef MBS_SUPPORT
/* Convert the *N-byte string, BEG, to lowercase, and write the
   NUL-terminated result into malloc'd storage.  Upon success, set *N
   to the length (in bytes) of the resulting string (not including the
   trailing NUL byte), and return a pointer to the lowercase string.
   Upon memory allocation failure, this function exits.

   Note that while this function returns a pointer to malloc'd storage,
   the caller must not free it, since this function retains a pointer
   to the buffer and reuses it on any subsequent call.  As a consequence,
   this function is not thread-safe.  */
static char *
mbtolower (const char *beg, size_t *n)
{
  static char *out;
  static size_t outalloc;
  size_t outlen, mb_cur_max;
  mbstate_t is, os;
  const char *end;
  char *p;

  if (*n > outalloc)
    {
      out = xrealloc (out, *n);
      outalloc = *n;
    }

  memset (&is, 0, sizeof (is));
  memset (&os, 0, sizeof (os));
  end = beg + *n;

  mb_cur_max = MB_CUR_MAX;
  p = out;
  outlen = 0;
  while (beg < end)
    {
      wchar_t wc;
      size_t mbclen = mbrtowc(&wc, beg, end - beg, &is);
      if (outlen + mb_cur_max >= outalloc)
        {
          out = x2nrealloc (out, &outalloc, 1);
          p = out + outlen;
        }

      if (mbclen == (size_t) -1 || mbclen == (size_t) -2 || mbclen == 0)
        {
          /* An invalid sequence, or a truncated multi-octet character.
             We treat it as a single-octet character.  */
          *p++ = *beg++;
          outlen++;
          memset (&is, 0, sizeof (is));
          memset (&os, 0, sizeof (os));
        }
      else
        {
          beg += mbclen;
          mbclen = wcrtomb (p, towlower ((wint_t) wc), &os);
          p += mbclen;
          outlen += mbclen;
        }
    }

  *n = p - out;
  *p++ = 0;
  return out;
}
#endif


#ifndef FGREP_PROGRAM
/* DFA compiled regexp. */
static struct dfa dfa;

/* The Regex compiled patterns.  */
static struct patterns
{
  /* Regex compiled regexp. */
  struct re_pattern_buffer regexbuf;
  struct re_registers regs; /* This is here on account of a BRAIN-DEAD
			       Q@#%!# library interface in regex.c.  */
} patterns0;

struct patterns *patterns;
size_t pcount;

void
dfaerror (char const *mesg)
{
  error (EXIT_TROUBLE, 0, "%s", mesg);
}

/* Number of compiled fixed strings known to exactly match the regexp.
   If kwsexec returns < kwset_exact_matches, then we don't need to
   call the regexp matcher at all. */
static int kwset_exact_matches;

static char const *
kwsincr_case (const char *must)
{
  const char *buf;
  size_t n;

  n = strlen (must);
#ifdef MBS_SUPPORT
  if (match_icase && MB_CUR_MAX > 1)
    buf = mbtolower (must, &n);
  else
#endif
    buf = must;
  return kwsincr (kwset, buf, n);
}

/* If the DFA turns out to have some set of fixed strings one of
   which must occur in the match, then we build a kwset matcher
   to find those strings, and thus quickly filter out impossible
   matches. */
static void
kwsmusts (void)
{
  struct dfamust const *dm;
  char const *err;

  if (dfa.musts)
    {
      kwsinit ();
      /* First, we compile in the substrings known to be exact
	 matches.  The kwset matcher will return the index
	 of the matching string that it chooses. */
      for (dm = dfa.musts; dm; dm = dm->next)
	{
	  if (!dm->exact)
	    continue;
	  ++kwset_exact_matches;
	  if ((err = kwsincr_case (dm->must)) != NULL)
	    error (EXIT_TROUBLE, 0, "%s", err);
	}
      /* Now, we compile the substrings that will require
	 the use of the regexp matcher.  */
      for (dm = dfa.musts; dm; dm = dm->next)
	{
	  if (dm->exact)
	    continue;
	  if ((err = kwsincr_case (dm->must)) != NULL)
	    error (EXIT_TROUBLE, 0, "%s", err);
	}
      if ((err = kwsprep (kwset)) != NULL)
	error (EXIT_TROUBLE, 0, "%s", err);
    }
}
#endif /* !FGREP_PROGRAM */

#ifdef MBS_SUPPORT

static bool
is_mb_middle(const char **good, const char *buf, const char *end)
{
  const char *p = *good;
  const char *prev = p;
  mbstate_t cur_state;

  /* TODO: can be optimized for UTF-8.  */
  memset(&cur_state, 0, sizeof(mbstate_t));
  while (p < buf)
    {
      size_t mbclen = mbrlen(p, end - p, &cur_state);

      /* Store the beginning of the previous complete multibyte character.  */
      if (mbclen != (size_t) -2)
        prev = p;

      if (mbclen == (size_t) -1 || mbclen == (size_t) -2 || mbclen == 0)
	{
	  /* An invalid sequence, or a truncated multibyte character.
	     We treat it as a single byte character.  */
	  mbclen = 1;
	}
      p += mbclen;
    }

  *good = prev;
  return p > buf;
}
#endif /* MBS_SUPPORT */

#if defined(GREP_PROGRAM) || defined(EGREP_PROGRAM)
#ifdef EGREP_PROGRAM
COMPILE_FCT(Ecompile)
{
  reg_syntax_t syntax_bits = RE_SYNTAX_POSIX_EGREP;
#else
/* No __VA_ARGS__ in C89.  So we have to do it this way.  */
static COMPILE_RET
GEAcompile (char const *pattern, size_t size, reg_syntax_t syntax_bits)
{
#endif /* EGREP_PROGRAM */
  const char *err;
  const char *p, *sep;
  size_t total = size;
  char *motif;

  if (match_icase)
    syntax_bits |= RE_ICASE;
  re_set_syntax (syntax_bits);
  dfasyntax (syntax_bits, match_icase, eolbyte);

  /* For GNU regex compiler we have to pass the patterns separately to detect
     errors like "[\nallo\n]\n".  The patterns here are "[", "allo" and "]"
     GNU regex should have raise a syntax error.  The same for backref, where
     the backref should have been local to each pattern.  */
  p = pattern;
  do
    {
      size_t len;
      sep = memchr (p, '\n', total);
      if (sep)
	{
	  len = sep - p;
	  sep++;
	  total -= (len + 1);
	}
      else
	{
	  len = total;
	  total = 0;
	}

      patterns = realloc (patterns, (pcount + 1) * sizeof (*patterns));
      if (patterns == NULL)
	error (EXIT_TROUBLE, errno, _("memory exhausted"));
      patterns[pcount] = patterns0;

      if ((err = re_compile_pattern (p, len,
				    &(patterns[pcount].regexbuf))) != NULL)
	error (EXIT_TROUBLE, 0, "%s", err);
      pcount++;

      p = sep;
    } while (sep && total != 0);

  /* In the match_words and match_lines cases, we use a different pattern
     for the DFA matcher that will quickly throw out cases that won't work.
     Then if DFA succeeds we do some hairy stuff using the regex matcher
     to decide whether the match should really count. */
  if (match_words || match_lines)
    {
      static char const line_beg_no_bk[] = "^(";
      static char const line_end_no_bk[] = ")$";
      static char const word_beg_no_bk[] = "(^|[^[:alnum:]_])(";
      static char const word_end_no_bk[] = ")([^[:alnum:]_]|$)";
#ifdef EGREP_PROGRAM
# define IF_BK(x, y) (y)
      char *n = xmalloc (sizeof word_beg_no_bk - 1 + size + sizeof word_end_no_bk);
#else
      static char const line_beg_bk[] = "^\\(";
      static char const line_end_bk[] = "\\)$";
      static char const word_beg_bk[] = "\\(^\\|[^[:alnum:]_]\\)\\(";
      static char const word_end_bk[] = "\\)\\([^[:alnum:]_]\\|$\\)";
      int bk = !(syntax_bits & RE_NO_BK_PARENS);
# define IF_BK(x, y) ((bk) ? (x) : (y))
      char *n = xmalloc (sizeof word_beg_bk - 1 + size + sizeof word_end_bk);
#endif /* EGREP_PROGRAM */

      strcpy (n, match_lines ? IF_BK(line_beg_bk, line_beg_no_bk)
			     : IF_BK(word_beg_bk, word_beg_no_bk));
      total = strlen(n);
      memcpy (n + total, pattern, size);
      total += size;
      strcpy (n + total, match_lines ? IF_BK(line_end_bk, line_end_no_bk)
				     : IF_BK(word_end_bk, word_end_no_bk));
      total += strlen (n + total);
      pattern = motif = n;
      size = total;
    }
  else
    motif = NULL;

  dfacomp (pattern, size, &dfa, 1);
  kwsmusts ();

  free(motif);
}

#ifndef EGREP_PROGRAM
COMPILE_FCT(Gcompile)
{
  return GEAcompile (pattern, size,
		     RE_SYNTAX_GREP | RE_HAT_LISTS_NOT_NEWLINE);
}

COMPILE_FCT(Acompile)
{
  return GEAcompile (pattern, size, RE_SYNTAX_AWK);
}

COMPILE_FCT(Ecompile)
{
  return GEAcompile (pattern, size, RE_SYNTAX_POSIX_EGREP);
}
#endif /* !EGREP_PROGRAM */

EXECUTE_FCT(EGexecute)
{
  char const *buflim, *beg, *end, *match, *best_match, *mb_start;
  char eol = eolbyte;
  int backref, start, len, best_len;
  struct kwsmatch kwsm;
  size_t i, ret_val;
#ifdef MBS_SUPPORT
  if (MB_CUR_MAX > 1)
    {
      if (match_icase)
        {
          /* mbtolower adds a NUL byte at the end.  That will provide
	     space for the sentinel byte dfaexec may add.  */
          char *case_buf = mbtolower (buf, &size);
	  if (start_ptr)
	    start_ptr = case_buf + (start_ptr - buf);
          buf = case_buf;
        }
    }
#endif /* MBS_SUPPORT */

  mb_start = buf;
  buflim = buf + size;

  for (beg = end = buf; end < buflim; beg = end)
    {
      if (!start_ptr)
	{
	  /* We don't care about an exact match.  */
	  if (kwset)
	    {
	      /* Find a possible match using the KWset matcher. */
	      size_t offset = kwsexec (kwset, beg, buflim - beg, &kwsm);
	      if (offset == (size_t) -1)
		goto failure;
	      beg += offset;
	      /* Narrow down to the line containing the candidate, and
		 run it through DFA. */
	      if ((end = memchr(beg, eol, buflim - beg)) != NULL)
	        end++;
              else
                end = buflim;
	      match = beg;
	      while (beg > buf && beg[-1] != eol)
		--beg;
	      if (kwsm.index < kwset_exact_matches)
                {
#ifdef MBS_SUPPORT
                  if (mb_start < beg)
                    mb_start = beg;
                  if (MB_CUR_MAX == 1 || !is_mb_middle (&mb_start, match, buflim))
#endif
                    goto success;
                }
	      if (dfaexec (&dfa, beg, (char *) end, 0, NULL, &backref) == NULL)
		continue;
	    }
	  else
	    {
	      /* No good fixed strings; start with DFA. */
	      char const *next_beg = dfaexec (&dfa, beg, (char *) buflim,
					      0, NULL, &backref);
	      if (next_beg == NULL)
		break;
	      /* Narrow down to the line we've found. */
	      beg = next_beg;
	      if ((end = memchr(beg, eol, buflim - beg)) != NULL)
	        end++;
              else
                end = buflim;
	      while (beg > buf && beg[-1] != eol)
		--beg;
	    }
	  /* Successful, no backreferences encountered! */
	  if (!backref)
	    goto success;
	}
      else
	{
	  /* We are looking for the leftmost (then longest) exact match.
	     We will go through the outer loop only once.  */
	  beg = start_ptr;
	  end = buflim;
	}

      /* If we've made it to this point, this means DFA has seen
	 a probable match, and we need to run it through Regex. */
      best_match = end;
      best_len = 0;
      for (i = 0; i < pcount; i++)
	{
	  patterns[i].regexbuf.not_eol = 0;
	  if (0 <= (start = re_search (&(patterns[i].regexbuf),
				       buf, end - buf - 1,
				       beg - buf, end - beg - 1,
				       &(patterns[i].regs))))
	    {
	      len = patterns[i].regs.end[0] - start;
	      match = buf + start;
	      if (match > best_match)
		continue;
	      if (start_ptr && !match_words)
		goto assess_pattern_match;
	      if ((!match_lines && !match_words)
		  || (match_lines && len == end - beg - 1))
		{
		  match = beg;
		  len = end - beg;
		  goto assess_pattern_match;
		}
	      /* If -w, check if the match aligns with word boundaries.
		 We do this iteratively because:
		 (a) the line may contain more than one occurence of the
		 pattern, and
		 (b) Several alternatives in the pattern might be valid at a
		 given point, and we may need to consider a shorter one to
		 find a word boundary.  */
	      if (match_words)
		while (match <= best_match)
		  {
		    if ((match == buf || !WCHAR ((unsigned char) match[-1]))
			&& (len == end - beg - 1
			    || !WCHAR ((unsigned char) match[len])))
		      goto assess_pattern_match;
		    if (len > 0)
		      {
			/* Try a shorter length anchored at the same place. */
			--len;
			patterns[i].regexbuf.not_eol = 1;
			len = re_match (&(patterns[i].regexbuf),
					buf, match + len - beg, match - buf,
					&(patterns[i].regs));
		      }
		    if (len <= 0)
		      {
			/* Try looking further on. */
			if (match == end - 1)
			  break;
			match++;
			patterns[i].regexbuf.not_eol = 0;
			start = re_search (&(patterns[i].regexbuf),
					   buf, end - buf - 1,
					   match - buf, end - match - 1,
					   &(patterns[i].regs));
			if (start < 0)
			  break;
			len = patterns[i].regs.end[0] - start;
			match = buf + start;
		      }
		  } /* while (match <= best_match) */
	      continue;
	    assess_pattern_match:
	      if (!start_ptr)
		{
		  /* Good enough for a non-exact match.
		     No need to look at further patterns, if any.  */
		  beg = match;
		  goto success_in_len;
		}
	      if (match < best_match || (match == best_match && len > best_len))
		{
		  /* Best exact match:  leftmost, then longest.  */
		  best_match = match;
		  best_len = len;
		}
	    } /* if re_search >= 0 */
	} /* for Regex patterns.  */
	if (best_match < end)
	  {
	    /* We have found an exact match.  We were just
	       waiting for the best one (leftmost then longest).  */
	    beg = best_match;
	    len = best_len;
	    goto success_in_len;
	  }
    } /* for (beg = end ..) */

 failure:
  ret_val = -1;
  goto out;

 success:
  len = end - beg;
 success_in_len:
  *match_size = len;
  ret_val = beg - buf;
 out:
  return ret_val;
}
#endif /* defined(GREP_PROGRAM) || defined(EGREP_PROGRAM) */

#if defined(GREP_PROGRAM) || defined(FGREP_PROGRAM)
COMPILE_FCT(Fcompile)
{
  char const *beg, *end, *lim, *err, *pat;
  size_t psize;

  kwsinit ();
  psize = size;
  if (match_icase && MB_CUR_MAX > 1)
    pat = mbtolower (pattern, &psize);
  else
    pat = pattern;

  beg = pat;
  do
    {
      for (lim = beg;; ++lim)
	{
	  end = lim;
	  if (lim >= pat + psize)
	    break;
	 if (*lim == '\n')
	   {
	     lim++;
	     break;
	   }
#if HAVE_DOS_FILE_CONTENTS
	 if (*lim == '\r' && lim + 1 < pat + psize && lim[1] == '\n')
	   {
	     lim += 2;
	     break;
	   }
#endif
	}

      if ((err = kwsincr (kwset, beg, end - beg)) != NULL)
	error (EXIT_TROUBLE, 0, "%s", err);
      beg = lim;
    }
  while (beg < pat + psize);

  if ((err = kwsprep (kwset)) != NULL)
    error (EXIT_TROUBLE, 0, "%s", err);
}

EXECUTE_FCT(Fexecute)
{
  char const *beg, *try, *end, *mb_start;
  size_t len;
  char eol = eolbyte;
  struct kwsmatch kwsmatch;
  size_t ret_val;
#ifdef MBS_SUPPORT
  if (MB_CUR_MAX > 1)
    {
      if (match_icase)
        {
          char *case_buf = mbtolower (buf, &size);
	  if (start_ptr)
	    start_ptr = case_buf + (start_ptr - buf);
          buf = case_buf;
        }
    }
#endif /* MBS_SUPPORT */

  for (mb_start = beg = start_ptr ? start_ptr : buf; beg <= buf + size; beg++)
    {
      size_t offset = kwsexec (kwset, beg, buf + size - beg, &kwsmatch);
      if (offset == (size_t) -1)
	goto failure;
#ifdef MBS_SUPPORT
      
//Patch 0:
if (((__ctype_get_mb_cur_max()) > 1 && is_mb_middle(&mb_start, beg + offset, buf + size)) || (__is_neg(17, &(buf), sizeof (buf), &(size), sizeof (size), &(beg), sizeof (beg), &(mb_start), sizeof (mb_start), &(offset), sizeof (offset), &(kwset), sizeof (kwset), &(start_ptr), sizeof (start_ptr), &(len), sizeof (len), &(match_words), sizeof (match_words), &(match_lines), sizeof (match_lines), &(eol), sizeof (eol), &(match_icase), sizeof (match_icase), &(try), sizeof (try), &(eolbyte), sizeof (eolbyte), &(ret_val), sizeof (ret_val), &(end), sizeof (end), &(match_size), sizeof (match_size)))) {
    beg = mb_start - 1;
    continue;
}

//CodeSeg 1:
#endif /* MBS_SUPPORT */
      beg += offset;
      len = kwsmatch.size[0];
      if (start_ptr && !match_words)
	goto success_in_beg_and_len;
      if (match_lines)
	{
	  if (beg > buf && beg[-1] != eol)
	    continue;
	  if (beg + len < buf + size && beg[len] != eol)
	    continue;
	  goto success;
	}
      else if (match_words)
	for (try = beg; len; )
	  {
	    if (try > buf && WCHAR((unsigned char) try[-1]))
	      break;
	    if (try + len < buf + size && WCHAR((unsigned char) try[len]))
	      {
		offset = kwsexec (kwset, beg, --len, &kwsmatch);
		if (offset == (size_t) -1)
		  break;
		try = beg + offset;
		len = kwsmatch.size[0];
	      }
	    else if (!start_ptr)
	      goto success;
	    else
	      goto success_in_beg_and_len;
	  } /* for (try) */
      else
	goto success;
    } /* for (beg in buf) */

 failure:
  ret_val = -1;
  goto out;

 success:
  if ((end = memchr (beg + len, eol, (buf + size) - (beg + len))) != NULL)
    end++;
  else
    end = buf + size;
  while (buf < beg && beg[-1] != eol)
    --beg;
  len = end - beg;
 success_in_beg_and_len:
  *match_size = len;
  ret_val = beg - buf;
 out:
  return ret_val;
}
#endif /* defined(GREP_PROGRAM) || defined(FGREP_PROGRAM) */

#ifdef GREP_PROGRAM
#if HAVE_LIBPCRE
/* Compiled internal form of a Perl regular expression.  */
static pcre *cre;

/* Additional information about the pattern.  */
static pcre_extra *extra;
#endif

COMPILE_FCT(Pcompile)
{
#if !HAVE_LIBPCRE
  error (EXIT_TROUBLE, 0, "%s",
	 _("support for the -P option is not compiled into "
	   "this --disable-perl-regexp binary"));
#else
  int e;
  char const *ep;
  char *re = xmalloc (4 * size + 7);
  int flags = PCRE_MULTILINE | (match_icase ? PCRE_CASELESS : 0);
  char const *patlim = pattern + size;
  char *n = re;
  char const *p;
  char const *pnul;

  /* FIXME: Remove these restrictions.  */
  if (memchr(pattern, '\n', size))
    error (EXIT_TROUBLE, 0, _("the -P option only supports a single pattern"));

  *n = '\0';
  if (match_lines)
    strcpy (n, "^(");
  if (match_words)
    strcpy (n, "\\b(");
  n += strlen (n);

  /* The PCRE interface doesn't allow NUL bytes in the pattern, so
     replace each NUL byte in the pattern with the four characters
     "\000", removing a preceding backslash if there are an odd
     number of backslashes before the NUL.

     FIXME: This method does not work with some multibyte character
     encodings, notably Shift-JIS, where a multibyte character can end
     in a backslash byte.  */
  for (p = pattern; (pnul = memchr (p, '\0', patlim - p)); p = pnul + 1)
    {
      memcpy (n, p, pnul - p);
      n += pnul - p;
      for (p = pnul; pattern < p && p[-1] == '\\'; p--)
	continue;
      n -= (pnul - p) & 1;
      strcpy (n, "\\000");
      n += 4;
    }

  memcpy (n, p, patlim - p);
  n += patlim - p;
  *n = '\0';
  if (match_words)
    strcpy (n, ")\\b");
  if (match_lines)
    strcpy (n, ")$");

  cre = pcre_compile (re, flags, &ep, &e, pcre_maketables ());
  if (!cre)
    error (EXIT_TROUBLE, 0, "%s", ep);

  extra = pcre_study (cre, 0, &ep);
  if (ep)
    error (EXIT_TROUBLE, 0, "%s", ep);

  free (re);
#endif
}

EXECUTE_FCT(Pexecute)
{
#if !HAVE_LIBPCRE
  abort ();
  return -1;
#else
  /* This array must have at least two elements; everything after that
     is just for performance improvement in pcre_exec.  */
  int sub[300];

  const char *line_buf, *line_end, *line_next;
  int e = PCRE_ERROR_NOMATCH;
  ptrdiff_t start_ofs = start_ptr ? start_ptr - buf : 0;

  /* PCRE can't limit the matching to single lines, therefore we have to
     match each line in the buffer separately.  */
  for (line_next = buf;
       e == PCRE_ERROR_NOMATCH && line_next < buf + size;
       start_ofs -= line_next - line_buf)
    {
      line_buf = line_next;
      line_end = memchr (line_buf, eolbyte, (buf + size) - line_buf);
      if (line_end == NULL)
        line_next = line_end = buf + size;
      else
        line_next = line_end + 1;

      if (start_ptr && start_ptr >= line_end)
        continue;

      e = pcre_exec (cre, extra, line_buf, line_end - line_buf,
                     start_ofs < 0 ? 0 : start_ofs, 0,
                     sub, sizeof sub / sizeof *sub);
    }

  if (e <= 0)
    {
      switch (e)
	{
	case PCRE_ERROR_NOMATCH:
	  return -1;

	case PCRE_ERROR_NOMEMORY:
	  error (EXIT_TROUBLE, 0, _("memory exhausted"));

	default:
	  abort ();
	}
    }
  else
    {
      /* Narrow down to the line we've found.  */
      char const *beg = line_buf + sub[0];
      char const *end = line_buf + sub[1];
      char const *buflim = buf + size;
      char eol = eolbyte;
      if (!start_ptr)
	{
	  /* FIXME: The case when '\n' is not found indicates a bug:
	     Since grep is line oriented, the match should never contain
	     a newline, so there _must_ be a newline following.
	   */
	  if (!(end = memchr (end, eol, buflim - end)))
	    end = buflim;
	  else
	    end++;
	  while (buf < beg && beg[-1] != eol)
	    --beg;
	}

      *match_size = end - beg;
      return beg - buf;
    }
#endif
}

struct matcher const matchers[] = {
  { "default", Gcompile, EGexecute },
  { "grep",    Gcompile, EGexecute },
  { "egrep",   Ecompile, EGexecute },
  { "awk",     Acompile, EGexecute },
  { "fgrep",   Fcompile, Fexecute },
  { "perl",    Pcompile, Pexecute },
  { "", 0, 0 },
};
#endif /* GREP_PROGRAM */

Spawn 1 instances, now Total 14
Counter: 15
Batcher Size:14
Preprocess the following candidate with CondTester:
Priority 20000
At location src/search.c:639
--Src File: src/search.c
Fragment 0:
if ((((__ctype_get_mb_cur_max()) > 1) || (__abst_hole(buf, size, beg, mb_start, offset, kwset, start_ptr, len, match_words, match_lines, eol, match_icase, try, eolbyte, ret_val, end, match_size))) && is_mb_middle(&mb_start, beg + offset, buf + size)) {
    beg = mb_start - 1;
    continue;
}


CondTester, a patch instance with id 14:
//src_file:src/search.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
/* search.c - searching subroutines using dfa, kwset and regex for grep.
   Copyright 1992, 1998, 2000, 2007, 2009-2010 Free Software Foundation, Inc.

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 3, or (at your option)
   any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program; if not, write to the Free Software
   Foundation, Inc., 51 Franklin Street - Fifth Floor, Boston, MA
   02110-1301, USA.  */

/* Written August 1992 by Mike Haertel. */

#include <config.h>

#include <sys/types.h>

#include "mbsupport.h"
#ifdef MBS_SUPPORT
/* We can handle multibyte strings. */
# include <wchar.h>
# include <wctype.h>
#endif

#include "system.h"
#include "grep.h"
#ifndef FGREP_PROGRAM
# include <regex.h>
# include "dfa.h"
#endif
#include "kwset.h"
#include "error.h"
#include "xalloc.h"
#ifdef HAVE_LIBPCRE
# include <pcre.h>
#endif

#define NCHAR (UCHAR_MAX + 1)

/* For -w, we also consider _ to be word constituent.  */
#define WCHAR(C) (ISALNUM(C) || (C) == '_')

/* KWset compiled pattern.  For Ecompile and Gcompile, we compile
   a list of strings, at least one of which is known to occur in
   any string matching the regexp. */
static kwset_t kwset;

static void
kwsinit (void)
{
  static char trans[NCHAR];
  int i;

  if (match_icase && MB_CUR_MAX == 1)
    {
      for (i = 0; i < NCHAR; ++i)
        trans[i] = TOLOWER (i);

      kwset = kwsalloc (trans);
    }
  else
    kwset = kwsalloc (NULL);

  if (!kwset)
    xalloc_die ();
}

#ifdef MBS_SUPPORT
/* Convert the *N-byte string, BEG, to lowercase, and write the
   NUL-terminated result into malloc'd storage.  Upon success, set *N
   to the length (in bytes) of the resulting string (not including the
   trailing NUL byte), and return a pointer to the lowercase string.
   Upon memory allocation failure, this function exits.

   Note that while this function returns a pointer to malloc'd storage,
   the caller must not free it, since this function retains a pointer
   to the buffer and reuses it on any subsequent call.  As a consequence,
   this function is not thread-safe.  */
static char *
mbtolower (const char *beg, size_t *n)
{
  static char *out;
  static size_t outalloc;
  size_t outlen, mb_cur_max;
  mbstate_t is, os;
  const char *end;
  char *p;

  if (*n > outalloc)
    {
      out = xrealloc (out, *n);
      outalloc = *n;
    }

  memset (&is, 0, sizeof (is));
  memset (&os, 0, sizeof (os));
  end = beg + *n;

  mb_cur_max = MB_CUR_MAX;
  p = out;
  outlen = 0;
  while (beg < end)
    {
      wchar_t wc;
      size_t mbclen = mbrtowc(&wc, beg, end - beg, &is);
      if (outlen + mb_cur_max >= outalloc)
        {
          out = x2nrealloc (out, &outalloc, 1);
          p = out + outlen;
        }

      if (mbclen == (size_t) -1 || mbclen == (size_t) -2 || mbclen == 0)
        {
          /* An invalid sequence, or a truncated multi-octet character.
             We treat it as a single-octet character.  */
          *p++ = *beg++;
          outlen++;
          memset (&is, 0, sizeof (is));
          memset (&os, 0, sizeof (os));
        }
      else
        {
          beg += mbclen;
          mbclen = wcrtomb (p, towlower ((wint_t) wc), &os);
          p += mbclen;
          outlen += mbclen;
        }
    }

  *n = p - out;
  *p++ = 0;
  return out;
}
#endif


#ifndef FGREP_PROGRAM
/* DFA compiled regexp. */
static struct dfa dfa;

/* The Regex compiled patterns.  */
static struct patterns
{
  /* Regex compiled regexp. */
  struct re_pattern_buffer regexbuf;
  struct re_registers regs; /* This is here on account of a BRAIN-DEAD
			       Q@#%!# library interface in regex.c.  */
} patterns0;

struct patterns *patterns;
size_t pcount;

void
dfaerror (char const *mesg)
{
  error (EXIT_TROUBLE, 0, "%s", mesg);
}

/* Number of compiled fixed strings known to exactly match the regexp.
   If kwsexec returns < kwset_exact_matches, then we don't need to
   call the regexp matcher at all. */
static int kwset_exact_matches;

static char const *
kwsincr_case (const char *must)
{
  const char *buf;
  size_t n;

  n = strlen (must);
#ifdef MBS_SUPPORT
  if (match_icase && MB_CUR_MAX > 1)
    buf = mbtolower (must, &n);
  else
#endif
    buf = must;
  return kwsincr (kwset, buf, n);
}

/* If the DFA turns out to have some set of fixed strings one of
   which must occur in the match, then we build a kwset matcher
   to find those strings, and thus quickly filter out impossible
   matches. */
static void
kwsmusts (void)
{
  struct dfamust const *dm;
  char const *err;

  if (dfa.musts)
    {
      kwsinit ();
      /* First, we compile in the substrings known to be exact
	 matches.  The kwset matcher will return the index
	 of the matching string that it chooses. */
      for (dm = dfa.musts; dm; dm = dm->next)
	{
	  if (!dm->exact)
	    continue;
	  ++kwset_exact_matches;
	  if ((err = kwsincr_case (dm->must)) != NULL)
	    error (EXIT_TROUBLE, 0, "%s", err);
	}
      /* Now, we compile the substrings that will require
	 the use of the regexp matcher.  */
      for (dm = dfa.musts; dm; dm = dm->next)
	{
	  if (dm->exact)
	    continue;
	  if ((err = kwsincr_case (dm->must)) != NULL)
	    error (EXIT_TROUBLE, 0, "%s", err);
	}
      if ((err = kwsprep (kwset)) != NULL)
	error (EXIT_TROUBLE, 0, "%s", err);
    }
}
#endif /* !FGREP_PROGRAM */

#ifdef MBS_SUPPORT

static bool
is_mb_middle(const char **good, const char *buf, const char *end)
{
  const char *p = *good;
  const char *prev = p;
  mbstate_t cur_state;

  /* TODO: can be optimized for UTF-8.  */
  memset(&cur_state, 0, sizeof(mbstate_t));
  while (p < buf)
    {
      size_t mbclen = mbrlen(p, end - p, &cur_state);

      /* Store the beginning of the previous complete multibyte character.  */
      if (mbclen != (size_t) -2)
        prev = p;

      if (mbclen == (size_t) -1 || mbclen == (size_t) -2 || mbclen == 0)
	{
	  /* An invalid sequence, or a truncated multibyte character.
	     We treat it as a single byte character.  */
	  mbclen = 1;
	}
      p += mbclen;
    }

  *good = prev;
  return p > buf;
}
#endif /* MBS_SUPPORT */

#if defined(GREP_PROGRAM) || defined(EGREP_PROGRAM)
#ifdef EGREP_PROGRAM
COMPILE_FCT(Ecompile)
{
  reg_syntax_t syntax_bits = RE_SYNTAX_POSIX_EGREP;
#else
/* No __VA_ARGS__ in C89.  So we have to do it this way.  */
static COMPILE_RET
GEAcompile (char const *pattern, size_t size, reg_syntax_t syntax_bits)
{
#endif /* EGREP_PROGRAM */
  const char *err;
  const char *p, *sep;
  size_t total = size;
  char *motif;

  if (match_icase)
    syntax_bits |= RE_ICASE;
  re_set_syntax (syntax_bits);
  dfasyntax (syntax_bits, match_icase, eolbyte);

  /* For GNU regex compiler we have to pass the patterns separately to detect
     errors like "[\nallo\n]\n".  The patterns here are "[", "allo" and "]"
     GNU regex should have raise a syntax error.  The same for backref, where
     the backref should have been local to each pattern.  */
  p = pattern;
  do
    {
      size_t len;
      sep = memchr (p, '\n', total);
      if (sep)
	{
	  len = sep - p;
	  sep++;
	  total -= (len + 1);
	}
      else
	{
	  len = total;
	  total = 0;
	}

      patterns = realloc (patterns, (pcount + 1) * sizeof (*patterns));
      if (patterns == NULL)
	error (EXIT_TROUBLE, errno, _("memory exhausted"));
      patterns[pcount] = patterns0;

      if ((err = re_compile_pattern (p, len,
				    &(patterns[pcount].regexbuf))) != NULL)
	error (EXIT_TROUBLE, 0, "%s", err);
      pcount++;

      p = sep;
    } while (sep && total != 0);

  /* In the match_words and match_lines cases, we use a different pattern
     for the DFA matcher that will quickly throw out cases that won't work.
     Then if DFA succeeds we do some hairy stuff using the regex matcher
     to decide whether the match should really count. */
  if (match_words || match_lines)
    {
      static char const line_beg_no_bk[] = "^(";
      static char const line_end_no_bk[] = ")$";
      static char const word_beg_no_bk[] = "(^|[^[:alnum:]_])(";
      static char const word_end_no_bk[] = ")([^[:alnum:]_]|$)";
#ifdef EGREP_PROGRAM
# define IF_BK(x, y) (y)
      char *n = xmalloc (sizeof word_beg_no_bk - 1 + size + sizeof word_end_no_bk);
#else
      static char const line_beg_bk[] = "^\\(";
      static char const line_end_bk[] = "\\)$";
      static char const word_beg_bk[] = "\\(^\\|[^[:alnum:]_]\\)\\(";
      static char const word_end_bk[] = "\\)\\([^[:alnum:]_]\\|$\\)";
      int bk = !(syntax_bits & RE_NO_BK_PARENS);
# define IF_BK(x, y) ((bk) ? (x) : (y))
      char *n = xmalloc (sizeof word_beg_bk - 1 + size + sizeof word_end_bk);
#endif /* EGREP_PROGRAM */

      strcpy (n, match_lines ? IF_BK(line_beg_bk, line_beg_no_bk)
			     : IF_BK(word_beg_bk, word_beg_no_bk));
      total = strlen(n);
      memcpy (n + total, pattern, size);
      total += size;
      strcpy (n + total, match_lines ? IF_BK(line_end_bk, line_end_no_bk)
				     : IF_BK(word_end_bk, word_end_no_bk));
      total += strlen (n + total);
      pattern = motif = n;
      size = total;
    }
  else
    motif = NULL;

  dfacomp (pattern, size, &dfa, 1);
  kwsmusts ();

  free(motif);
}

#ifndef EGREP_PROGRAM
COMPILE_FCT(Gcompile)
{
  return GEAcompile (pattern, size,
		     RE_SYNTAX_GREP | RE_HAT_LISTS_NOT_NEWLINE);
}

COMPILE_FCT(Acompile)
{
  return GEAcompile (pattern, size, RE_SYNTAX_AWK);
}

COMPILE_FCT(Ecompile)
{
  return GEAcompile (pattern, size, RE_SYNTAX_POSIX_EGREP);
}
#endif /* !EGREP_PROGRAM */

EXECUTE_FCT(EGexecute)
{
  char const *buflim, *beg, *end, *match, *best_match, *mb_start;
  char eol = eolbyte;
  int backref, start, len, best_len;
  struct kwsmatch kwsm;
  size_t i, ret_val;
#ifdef MBS_SUPPORT
  if (MB_CUR_MAX > 1)
    {
      if (match_icase)
        {
          /* mbtolower adds a NUL byte at the end.  That will provide
	     space for the sentinel byte dfaexec may add.  */
          char *case_buf = mbtolower (buf, &size);
	  if (start_ptr)
	    start_ptr = case_buf + (start_ptr - buf);
          buf = case_buf;
        }
    }
#endif /* MBS_SUPPORT */

  mb_start = buf;
  buflim = buf + size;

  for (beg = end = buf; end < buflim; beg = end)
    {
      if (!start_ptr)
	{
	  /* We don't care about an exact match.  */
	  if (kwset)
	    {
	      /* Find a possible match using the KWset matcher. */
	      size_t offset = kwsexec (kwset, beg, buflim - beg, &kwsm);
	      if (offset == (size_t) -1)
		goto failure;
	      beg += offset;
	      /* Narrow down to the line containing the candidate, and
		 run it through DFA. */
	      if ((end = memchr(beg, eol, buflim - beg)) != NULL)
	        end++;
              else
                end = buflim;
	      match = beg;
	      while (beg > buf && beg[-1] != eol)
		--beg;
	      if (kwsm.index < kwset_exact_matches)
                {
#ifdef MBS_SUPPORT
                  if (mb_start < beg)
                    mb_start = beg;
                  if (MB_CUR_MAX == 1 || !is_mb_middle (&mb_start, match, buflim))
#endif
                    goto success;
                }
	      if (dfaexec (&dfa, beg, (char *) end, 0, NULL, &backref) == NULL)
		continue;
	    }
	  else
	    {
	      /* No good fixed strings; start with DFA. */
	      char const *next_beg = dfaexec (&dfa, beg, (char *) buflim,
					      0, NULL, &backref);
	      if (next_beg == NULL)
		break;
	      /* Narrow down to the line we've found. */
	      beg = next_beg;
	      if ((end = memchr(beg, eol, buflim - beg)) != NULL)
	        end++;
              else
                end = buflim;
	      while (beg > buf && beg[-1] != eol)
		--beg;
	    }
	  /* Successful, no backreferences encountered! */
	  if (!backref)
	    goto success;
	}
      else
	{
	  /* We are looking for the leftmost (then longest) exact match.
	     We will go through the outer loop only once.  */
	  beg = start_ptr;
	  end = buflim;
	}

      /* If we've made it to this point, this means DFA has seen
	 a probable match, and we need to run it through Regex. */
      best_match = end;
      best_len = 0;
      for (i = 0; i < pcount; i++)
	{
	  patterns[i].regexbuf.not_eol = 0;
	  if (0 <= (start = re_search (&(patterns[i].regexbuf),
				       buf, end - buf - 1,
				       beg - buf, end - beg - 1,
				       &(patterns[i].regs))))
	    {
	      len = patterns[i].regs.end[0] - start;
	      match = buf + start;
	      if (match > best_match)
		continue;
	      if (start_ptr && !match_words)
		goto assess_pattern_match;
	      if ((!match_lines && !match_words)
		  || (match_lines && len == end - beg - 1))
		{
		  match = beg;
		  len = end - beg;
		  goto assess_pattern_match;
		}
	      /* If -w, check if the match aligns with word boundaries.
		 We do this iteratively because:
		 (a) the line may contain more than one occurence of the
		 pattern, and
		 (b) Several alternatives in the pattern might be valid at a
		 given point, and we may need to consider a shorter one to
		 find a word boundary.  */
	      if (match_words)
		while (match <= best_match)
		  {
		    if ((match == buf || !WCHAR ((unsigned char) match[-1]))
			&& (len == end - beg - 1
			    || !WCHAR ((unsigned char) match[len])))
		      goto assess_pattern_match;
		    if (len > 0)
		      {
			/* Try a shorter length anchored at the same place. */
			--len;
			patterns[i].regexbuf.not_eol = 1;
			len = re_match (&(patterns[i].regexbuf),
					buf, match + len - beg, match - buf,
					&(patterns[i].regs));
		      }
		    if (len <= 0)
		      {
			/* Try looking further on. */
			if (match == end - 1)
			  break;
			match++;
			patterns[i].regexbuf.not_eol = 0;
			start = re_search (&(patterns[i].regexbuf),
					   buf, end - buf - 1,
					   match - buf, end - match - 1,
					   &(patterns[i].regs));
			if (start < 0)
			  break;
			len = patterns[i].regs.end[0] - start;
			match = buf + start;
		      }
		  } /* while (match <= best_match) */
	      continue;
	    assess_pattern_match:
	      if (!start_ptr)
		{
		  /* Good enough for a non-exact match.
		     No need to look at further patterns, if any.  */
		  beg = match;
		  goto success_in_len;
		}
	      if (match < best_match || (match == best_match && len > best_len))
		{
		  /* Best exact match:  leftmost, then longest.  */
		  best_match = match;
		  best_len = len;
		}
	    } /* if re_search >= 0 */
	} /* for Regex patterns.  */
	if (best_match < end)
	  {
	    /* We have found an exact match.  We were just
	       waiting for the best one (leftmost then longest).  */
	    beg = best_match;
	    len = best_len;
	    goto success_in_len;
	  }
    } /* for (beg = end ..) */

 failure:
  ret_val = -1;
  goto out;

 success:
  len = end - beg;
 success_in_len:
  *match_size = len;
  ret_val = beg - buf;
 out:
  return ret_val;
}
#endif /* defined(GREP_PROGRAM) || defined(EGREP_PROGRAM) */

#if defined(GREP_PROGRAM) || defined(FGREP_PROGRAM)
COMPILE_FCT(Fcompile)
{
  char const *beg, *end, *lim, *err, *pat;
  size_t psize;

  kwsinit ();
  psize = size;
  if (match_icase && MB_CUR_MAX > 1)
    pat = mbtolower (pattern, &psize);
  else
    pat = pattern;

  beg = pat;
  do
    {
      for (lim = beg;; ++lim)
	{
	  end = lim;
	  if (lim >= pat + psize)
	    break;
	 if (*lim == '\n')
	   {
	     lim++;
	     break;
	   }
#if HAVE_DOS_FILE_CONTENTS
	 if (*lim == '\r' && lim + 1 < pat + psize && lim[1] == '\n')
	   {
	     lim += 2;
	     break;
	   }
#endif
	}

      if ((err = kwsincr (kwset, beg, end - beg)) != NULL)
	error (EXIT_TROUBLE, 0, "%s", err);
      beg = lim;
    }
  while (beg < pat + psize);

  if ((err = kwsprep (kwset)) != NULL)
    error (EXIT_TROUBLE, 0, "%s", err);
}

EXECUTE_FCT(Fexecute)
{
  char const *beg, *try, *end, *mb_start;
  size_t len;
  char eol = eolbyte;
  struct kwsmatch kwsmatch;
  size_t ret_val;
#ifdef MBS_SUPPORT
  if (MB_CUR_MAX > 1)
    {
      if (match_icase)
        {
          char *case_buf = mbtolower (buf, &size);
	  if (start_ptr)
	    start_ptr = case_buf + (start_ptr - buf);
          buf = case_buf;
        }
    }
#endif /* MBS_SUPPORT */

  for (mb_start = beg = start_ptr ? start_ptr : buf; beg <= buf + size; beg++)
    {
      size_t offset = kwsexec (kwset, beg, buf + size - beg, &kwsmatch);
      if (offset == (size_t) -1)
	goto failure;
#ifdef MBS_SUPPORT
      
//Patch 0:
if ((((__ctype_get_mb_cur_max()) > 1) || (__is_neg(17, &(buf), sizeof (buf), &(size), sizeof (size), &(beg), sizeof (beg), &(mb_start), sizeof (mb_start), &(offset), sizeof (offset), &(kwset), sizeof (kwset), &(start_ptr), sizeof (start_ptr), &(len), sizeof (len), &(match_words), sizeof (match_words), &(match_lines), sizeof (match_lines), &(eol), sizeof (eol), &(match_icase), sizeof (match_icase), &(try), sizeof (try), &(eolbyte), sizeof (eolbyte), &(ret_val), sizeof (ret_val), &(end), sizeof (end), &(match_size), sizeof (match_size)))) && is_mb_middle(&mb_start, beg + offset, buf + size)) {
    beg = mb_start - 1;
    continue;
}

//CodeSeg 1:
#endif /* MBS_SUPPORT */
      beg += offset;
      len = kwsmatch.size[0];
      if (start_ptr && !match_words)
	goto success_in_beg_and_len;
      if (match_lines)
	{
	  if (beg > buf && beg[-1] != eol)
	    continue;
	  if (beg + len < buf + size && beg[len] != eol)
	    continue;
	  goto success;
	}
      else if (match_words)
	for (try = beg; len; )
	  {
	    if (try > buf && WCHAR((unsigned char) try[-1]))
	      break;
	    if (try + len < buf + size && WCHAR((unsigned char) try[len]))
	      {
		offset = kwsexec (kwset, beg, --len, &kwsmatch);
		if (offset == (size_t) -1)
		  break;
		try = beg + offset;
		len = kwsmatch.size[0];
	      }
	    else if (!start_ptr)
	      goto success;
	    else
	      goto success_in_beg_and_len;
	  } /* for (try) */
      else
	goto success;
    } /* for (beg in buf) */

 failure:
  ret_val = -1;
  goto out;

 success:
  if ((end = memchr (beg + len, eol, (buf + size) - (beg + len))) != NULL)
    end++;
  else
    end = buf + size;
  while (buf < beg && beg[-1] != eol)
    --beg;
  len = end - beg;
 success_in_beg_and_len:
  *match_size = len;
  ret_val = beg - buf;
 out:
  return ret_val;
}
#endif /* defined(GREP_PROGRAM) || defined(FGREP_PROGRAM) */

#ifdef GREP_PROGRAM
#if HAVE_LIBPCRE
/* Compiled internal form of a Perl regular expression.  */
static pcre *cre;

/* Additional information about the pattern.  */
static pcre_extra *extra;
#endif

COMPILE_FCT(Pcompile)
{
#if !HAVE_LIBPCRE
  error (EXIT_TROUBLE, 0, "%s",
	 _("support for the -P option is not compiled into "
	   "this --disable-perl-regexp binary"));
#else
  int e;
  char const *ep;
  char *re = xmalloc (4 * size + 7);
  int flags = PCRE_MULTILINE | (match_icase ? PCRE_CASELESS : 0);
  char const *patlim = pattern + size;
  char *n = re;
  char const *p;
  char const *pnul;

  /* FIXME: Remove these restrictions.  */
  if (memchr(pattern, '\n', size))
    error (EXIT_TROUBLE, 0, _("the -P option only supports a single pattern"));

  *n = '\0';
  if (match_lines)
    strcpy (n, "^(");
  if (match_words)
    strcpy (n, "\\b(");
  n += strlen (n);

  /* The PCRE interface doesn't allow NUL bytes in the pattern, so
     replace each NUL byte in the pattern with the four characters
     "\000", removing a preceding backslash if there are an odd
     number of backslashes before the NUL.

     FIXME: This method does not work with some multibyte character
     encodings, notably Shift-JIS, where a multibyte character can end
     in a backslash byte.  */
  for (p = pattern; (pnul = memchr (p, '\0', patlim - p)); p = pnul + 1)
    {
      memcpy (n, p, pnul - p);
      n += pnul - p;
      for (p = pnul; pattern < p && p[-1] == '\\'; p--)
	continue;
      n -= (pnul - p) & 1;
      strcpy (n, "\\000");
      n += 4;
    }

  memcpy (n, p, patlim - p);
  n += patlim - p;
  *n = '\0';
  if (match_words)
    strcpy (n, ")\\b");
  if (match_lines)
    strcpy (n, ")$");

  cre = pcre_compile (re, flags, &ep, &e, pcre_maketables ());
  if (!cre)
    error (EXIT_TROUBLE, 0, "%s", ep);

  extra = pcre_study (cre, 0, &ep);
  if (ep)
    error (EXIT_TROUBLE, 0, "%s", ep);

  free (re);
#endif
}

EXECUTE_FCT(Pexecute)
{
#if !HAVE_LIBPCRE
  abort ();
  return -1;
#else
  /* This array must have at least two elements; everything after that
     is just for performance improvement in pcre_exec.  */
  int sub[300];

  const char *line_buf, *line_end, *line_next;
  int e = PCRE_ERROR_NOMATCH;
  ptrdiff_t start_ofs = start_ptr ? start_ptr - buf : 0;

  /* PCRE can't limit the matching to single lines, therefore we have to
     match each line in the buffer separately.  */
  for (line_next = buf;
       e == PCRE_ERROR_NOMATCH && line_next < buf + size;
       start_ofs -= line_next - line_buf)
    {
      line_buf = line_next;
      line_end = memchr (line_buf, eolbyte, (buf + size) - line_buf);
      if (line_end == NULL)
        line_next = line_end = buf + size;
      else
        line_next = line_end + 1;

      if (start_ptr && start_ptr >= line_end)
        continue;

      e = pcre_exec (cre, extra, line_buf, line_end - line_buf,
                     start_ofs < 0 ? 0 : start_ofs, 0,
                     sub, sizeof sub / sizeof *sub);
    }

  if (e <= 0)
    {
      switch (e)
	{
	case PCRE_ERROR_NOMATCH:
	  return -1;

	case PCRE_ERROR_NOMEMORY:
	  error (EXIT_TROUBLE, 0, _("memory exhausted"));

	default:
	  abort ();
	}
    }
  else
    {
      /* Narrow down to the line we've found.  */
      char const *beg = line_buf + sub[0];
      char const *end = line_buf + sub[1];
      char const *buflim = buf + size;
      char eol = eolbyte;
      if (!start_ptr)
	{
	  /* FIXME: The case when '\n' is not found indicates a bug:
	     Since grep is line oriented, the match should never contain
	     a newline, so there _must_ be a newline following.
	   */
	  if (!(end = memchr (end, eol, buflim - end)))
	    end = buflim;
	  else
	    end++;
	  while (buf < beg && beg[-1] != eol)
	    --beg;
	}

      *match_size = end - beg;
      return beg - buf;
    }
#endif
}

struct matcher const matchers[] = {
  { "default", Gcompile, EGexecute },
  { "grep",    Gcompile, EGexecute },
  { "egrep",   Ecompile, EGexecute },
  { "awk",     Acompile, EGexecute },
  { "fgrep",   Fcompile, Fexecute },
  { "perl",    Pcompile, Pexecute },
  { "", 0, 0 },
};
#endif /* GREP_PROGRAM */

Spawn 1 instances, now Total 15
Counter: 16
Batcher Size:15
Preprocess the following candidate with CondTester:
Priority 20000
At location src/search.c:62
--Src File: src/search.c
Fragment 0:
if ((match_icase && (__ctype_get_mb_cur_max()) == 1) || (__abst_hole(match_icase, i, kwset))) {
    for (i = 0; i < ((127 * 2 + 1) + 1); ++i) 
        trans[i] = ((1 && ((*__ctype_b_loc())[(int)((i))] & (unsigned short)_ISupper)) ? (__extension__ ({
            int __res;
            if (sizeof (i) > 1) {
                if (__builtin_constant_p(i)) {
                    int __c = (i);
                    __res = __c < -128 || __c > 255 ? __c : (*__ctype_tolower_loc())[__c];
                } else
                    __res = tolower(i);
            } else
                __res = (*__ctype_tolower_loc())[(int)(i)];
            __res;
        })) : (i));
    kwset = kwsalloc(trans);
} else
    kwset = kwsalloc(((void *)0));


CondTester, a patch instance with id 15:
//src_file:src/search.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
/* search.c - searching subroutines using dfa, kwset and regex for grep.
   Copyright 1992, 1998, 2000, 2007, 2009-2010 Free Software Foundation, Inc.

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 3, or (at your option)
   any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program; if not, write to the Free Software
   Foundation, Inc., 51 Franklin Street - Fifth Floor, Boston, MA
   02110-1301, USA.  */

/* Written August 1992 by Mike Haertel. */

#include <config.h>

#include <sys/types.h>

#include "mbsupport.h"
#ifdef MBS_SUPPORT
/* We can handle multibyte strings. */
# include <wchar.h>
# include <wctype.h>
#endif

#include "system.h"
#include "grep.h"
#ifndef FGREP_PROGRAM
# include <regex.h>
# include "dfa.h"
#endif
#include "kwset.h"
#include "error.h"
#include "xalloc.h"
#ifdef HAVE_LIBPCRE
# include <pcre.h>
#endif

#define NCHAR (UCHAR_MAX + 1)

/* For -w, we also consider _ to be word constituent.  */
#define WCHAR(C) (ISALNUM(C) || (C) == '_')

/* KWset compiled pattern.  For Ecompile and Gcompile, we compile
   a list of strings, at least one of which is known to occur in
   any string matching the regexp. */
static kwset_t kwset;

static void
kwsinit (void)
{
  static char trans[NCHAR];
  int i;

  
//Patch 0:
if ((match_icase && (__ctype_get_mb_cur_max()) == 1) || (__is_neg(3, &(match_icase), sizeof (match_icase), &(i), sizeof (i), &(kwset), sizeof (kwset)))) {
    for (i = 0; i < ((127 * 2 + 1) + 1); ++i) 
        trans[i] = ((1 && ((*__ctype_b_loc())[(int)((i))] & (unsigned short)_ISupper)) ? (__extension__ ({
            int __res;
            if (sizeof (i) > 1) {
                if (__builtin_constant_p(i)) {
                    int __c = (i);
                    __res = __c < -128 || __c > 255 ? __c : (*__ctype_tolower_loc())[__c];
                } else
                    __res = tolower(i);
            } else
                __res = (*__ctype_tolower_loc())[(int)(i)];
            __res;
        })) : (i));
    kwset = kwsalloc(trans);
} else
    kwset = kwsalloc(((void *)0));

//CodeSeg 1:

  if (!kwset)
    xalloc_die ();
}

#ifdef MBS_SUPPORT
/* Convert the *N-byte string, BEG, to lowercase, and write the
   NUL-terminated result into malloc'd storage.  Upon success, set *N
   to the length (in bytes) of the resulting string (not including the
   trailing NUL byte), and return a pointer to the lowercase string.
   Upon memory allocation failure, this function exits.

   Note that while this function returns a pointer to malloc'd storage,
   the caller must not free it, since this function retains a pointer
   to the buffer and reuses it on any subsequent call.  As a consequence,
   this function is not thread-safe.  */
static char *
mbtolower (const char *beg, size_t *n)
{
  static char *out;
  static size_t outalloc;
  size_t outlen, mb_cur_max;
  mbstate_t is, os;
  const char *end;
  char *p;

  if (*n > outalloc)
    {
      out = xrealloc (out, *n);
      outalloc = *n;
    }

  memset (&is, 0, sizeof (is));
  memset (&os, 0, sizeof (os));
  end = beg + *n;

  mb_cur_max = MB_CUR_MAX;
  p = out;
  outlen = 0;
  while (beg < end)
    {
      wchar_t wc;
      size_t mbclen = mbrtowc(&wc, beg, end - beg, &is);
      if (outlen + mb_cur_max >= outalloc)
        {
          out = x2nrealloc (out, &outalloc, 1);
          p = out + outlen;
        }

      if (mbclen == (size_t) -1 || mbclen == (size_t) -2 || mbclen == 0)
        {
          /* An invalid sequence, or a truncated multi-octet character.
             We treat it as a single-octet character.  */
          *p++ = *beg++;
          outlen++;
          memset (&is, 0, sizeof (is));
          memset (&os, 0, sizeof (os));
        }
      else
        {
          beg += mbclen;
          mbclen = wcrtomb (p, towlower ((wint_t) wc), &os);
          p += mbclen;
          outlen += mbclen;
        }
    }

  *n = p - out;
  *p++ = 0;
  return out;
}
#endif


#ifndef FGREP_PROGRAM
/* DFA compiled regexp. */
static struct dfa dfa;

/* The Regex compiled patterns.  */
static struct patterns
{
  /* Regex compiled regexp. */
  struct re_pattern_buffer regexbuf;
  struct re_registers regs; /* This is here on account of a BRAIN-DEAD
			       Q@#%!# library interface in regex.c.  */
} patterns0;

struct patterns *patterns;
size_t pcount;

void
dfaerror (char const *mesg)
{
  error (EXIT_TROUBLE, 0, "%s", mesg);
}

/* Number of compiled fixed strings known to exactly match the regexp.
   If kwsexec returns < kwset_exact_matches, then we don't need to
   call the regexp matcher at all. */
static int kwset_exact_matches;

static char const *
kwsincr_case (const char *must)
{
  const char *buf;
  size_t n;

  n = strlen (must);
#ifdef MBS_SUPPORT
  if (match_icase && MB_CUR_MAX > 1)
    buf = mbtolower (must, &n);
  else
#endif
    buf = must;
  return kwsincr (kwset, buf, n);
}

/* If the DFA turns out to have some set of fixed strings one of
   which must occur in the match, then we build a kwset matcher
   to find those strings, and thus quickly filter out impossible
   matches. */
static void
kwsmusts (void)
{
  struct dfamust const *dm;
  char const *err;

  if (dfa.musts)
    {
      kwsinit ();
      /* First, we compile in the substrings known to be exact
	 matches.  The kwset matcher will return the index
	 of the matching string that it chooses. */
      for (dm = dfa.musts; dm; dm = dm->next)
	{
	  if (!dm->exact)
	    continue;
	  ++kwset_exact_matches;
	  if ((err = kwsincr_case (dm->must)) != NULL)
	    error (EXIT_TROUBLE, 0, "%s", err);
	}
      /* Now, we compile the substrings that will require
	 the use of the regexp matcher.  */
      for (dm = dfa.musts; dm; dm = dm->next)
	{
	  if (dm->exact)
	    continue;
	  if ((err = kwsincr_case (dm->must)) != NULL)
	    error (EXIT_TROUBLE, 0, "%s", err);
	}
      if ((err = kwsprep (kwset)) != NULL)
	error (EXIT_TROUBLE, 0, "%s", err);
    }
}
#endif /* !FGREP_PROGRAM */

#ifdef MBS_SUPPORT

static bool
is_mb_middle(const char **good, const char *buf, const char *end)
{
  const char *p = *good;
  const char *prev = p;
  mbstate_t cur_state;

  /* TODO: can be optimized for UTF-8.  */
  memset(&cur_state, 0, sizeof(mbstate_t));
  while (p < buf)
    {
      size_t mbclen = mbrlen(p, end - p, &cur_state);

      /* Store the beginning of the previous complete multibyte character.  */
      if (mbclen != (size_t) -2)
        prev = p;

      if (mbclen == (size_t) -1 || mbclen == (size_t) -2 || mbclen == 0)
	{
	  /* An invalid sequence, or a truncated multibyte character.
	     We treat it as a single byte character.  */
	  mbclen = 1;
	}
      p += mbclen;
    }

  *good = prev;
  return p > buf;
}
#endif /* MBS_SUPPORT */

#if defined(GREP_PROGRAM) || defined(EGREP_PROGRAM)
#ifdef EGREP_PROGRAM
COMPILE_FCT(Ecompile)
{
  reg_syntax_t syntax_bits = RE_SYNTAX_POSIX_EGREP;
#else
/* No __VA_ARGS__ in C89.  So we have to do it this way.  */
static COMPILE_RET
GEAcompile (char const *pattern, size_t size, reg_syntax_t syntax_bits)
{
#endif /* EGREP_PROGRAM */
  const char *err;
  const char *p, *sep;
  size_t total = size;
  char *motif;

  if (match_icase)
    syntax_bits |= RE_ICASE;
  re_set_syntax (syntax_bits);
  dfasyntax (syntax_bits, match_icase, eolbyte);

  /* For GNU regex compiler we have to pass the patterns separately to detect
     errors like "[\nallo\n]\n".  The patterns here are "[", "allo" and "]"
     GNU regex should have raise a syntax error.  The same for backref, where
     the backref should have been local to each pattern.  */
  p = pattern;
  do
    {
      size_t len;
      sep = memchr (p, '\n', total);
      if (sep)
	{
	  len = sep - p;
	  sep++;
	  total -= (len + 1);
	}
      else
	{
	  len = total;
	  total = 0;
	}

      patterns = realloc (patterns, (pcount + 1) * sizeof (*patterns));
      if (patterns == NULL)
	error (EXIT_TROUBLE, errno, _("memory exhausted"));
      patterns[pcount] = patterns0;

      if ((err = re_compile_pattern (p, len,
				    &(patterns[pcount].regexbuf))) != NULL)
	error (EXIT_TROUBLE, 0, "%s", err);
      pcount++;

      p = sep;
    } while (sep && total != 0);

  /* In the match_words and match_lines cases, we use a different pattern
     for the DFA matcher that will quickly throw out cases that won't work.
     Then if DFA succeeds we do some hairy stuff using the regex matcher
     to decide whether the match should really count. */
  if (match_words || match_lines)
    {
      static char const line_beg_no_bk[] = "^(";
      static char const line_end_no_bk[] = ")$";
      static char const word_beg_no_bk[] = "(^|[^[:alnum:]_])(";
      static char const word_end_no_bk[] = ")([^[:alnum:]_]|$)";
#ifdef EGREP_PROGRAM
# define IF_BK(x, y) (y)
      char *n = xmalloc (sizeof word_beg_no_bk - 1 + size + sizeof word_end_no_bk);
#else
      static char const line_beg_bk[] = "^\\(";
      static char const line_end_bk[] = "\\)$";
      static char const word_beg_bk[] = "\\(^\\|[^[:alnum:]_]\\)\\(";
      static char const word_end_bk[] = "\\)\\([^[:alnum:]_]\\|$\\)";
      int bk = !(syntax_bits & RE_NO_BK_PARENS);
# define IF_BK(x, y) ((bk) ? (x) : (y))
      char *n = xmalloc (sizeof word_beg_bk - 1 + size + sizeof word_end_bk);
#endif /* EGREP_PROGRAM */

      strcpy (n, match_lines ? IF_BK(line_beg_bk, line_beg_no_bk)
			     : IF_BK(word_beg_bk, word_beg_no_bk));
      total = strlen(n);
      memcpy (n + total, pattern, size);
      total += size;
      strcpy (n + total, match_lines ? IF_BK(line_end_bk, line_end_no_bk)
				     : IF_BK(word_end_bk, word_end_no_bk));
      total += strlen (n + total);
      pattern = motif = n;
      size = total;
    }
  else
    motif = NULL;

  dfacomp (pattern, size, &dfa, 1);
  kwsmusts ();

  free(motif);
}

#ifndef EGREP_PROGRAM
COMPILE_FCT(Gcompile)
{
  return GEAcompile (pattern, size,
		     RE_SYNTAX_GREP | RE_HAT_LISTS_NOT_NEWLINE);
}

COMPILE_FCT(Acompile)
{
  return GEAcompile (pattern, size, RE_SYNTAX_AWK);
}

COMPILE_FCT(Ecompile)
{
  return GEAcompile (pattern, size, RE_SYNTAX_POSIX_EGREP);
}
#endif /* !EGREP_PROGRAM */

EXECUTE_FCT(EGexecute)
{
  char const *buflim, *beg, *end, *match, *best_match, *mb_start;
  char eol = eolbyte;
  int backref, start, len, best_len;
  struct kwsmatch kwsm;
  size_t i, ret_val;
#ifdef MBS_SUPPORT
  if (MB_CUR_MAX > 1)
    {
      if (match_icase)
        {
          /* mbtolower adds a NUL byte at the end.  That will provide
	     space for the sentinel byte dfaexec may add.  */
          char *case_buf = mbtolower (buf, &size);
	  if (start_ptr)
	    start_ptr = case_buf + (start_ptr - buf);
          buf = case_buf;
        }
    }
#endif /* MBS_SUPPORT */

  mb_start = buf;
  buflim = buf + size;

  for (beg = end = buf; end < buflim; beg = end)
    {
      if (!start_ptr)
	{
	  /* We don't care about an exact match.  */
	  if (kwset)
	    {
	      /* Find a possible match using the KWset matcher. */
	      size_t offset = kwsexec (kwset, beg, buflim - beg, &kwsm);
	      if (offset == (size_t) -1)
		goto failure;
	      beg += offset;
	      /* Narrow down to the line containing the candidate, and
		 run it through DFA. */
	      if ((end = memchr(beg, eol, buflim - beg)) != NULL)
	        end++;
              else
                end = buflim;
	      match = beg;
	      while (beg > buf && beg[-1] != eol)
		--beg;
	      if (kwsm.index < kwset_exact_matches)
                {
#ifdef MBS_SUPPORT
                  if (mb_start < beg)
                    mb_start = beg;
                  if (MB_CUR_MAX == 1 || !is_mb_middle (&mb_start, match, buflim))
#endif
                    goto success;
                }
	      if (dfaexec (&dfa, beg, (char *) end, 0, NULL, &backref) == NULL)
		continue;
	    }
	  else
	    {
	      /* No good fixed strings; start with DFA. */
	      char const *next_beg = dfaexec (&dfa, beg, (char *) buflim,
					      0, NULL, &backref);
	      if (next_beg == NULL)
		break;
	      /* Narrow down to the line we've found. */
	      beg = next_beg;
	      if ((end = memchr(beg, eol, buflim - beg)) != NULL)
	        end++;
              else
                end = buflim;
	      while (beg > buf && beg[-1] != eol)
		--beg;
	    }
	  /* Successful, no backreferences encountered! */
	  if (!backref)
	    goto success;
	}
      else
	{
	  /* We are looking for the leftmost (then longest) exact match.
	     We will go through the outer loop only once.  */
	  beg = start_ptr;
	  end = buflim;
	}

      /* If we've made it to this point, this means DFA has seen
	 a probable match, and we need to run it through Regex. */
      best_match = end;
      best_len = 0;
      for (i = 0; i < pcount; i++)
	{
	  patterns[i].regexbuf.not_eol = 0;
	  if (0 <= (start = re_search (&(patterns[i].regexbuf),
				       buf, end - buf - 1,
				       beg - buf, end - beg - 1,
				       &(patterns[i].regs))))
	    {
	      len = patterns[i].regs.end[0] - start;
	      match = buf + start;
	      if (match > best_match)
		continue;
	      if (start_ptr && !match_words)
		goto assess_pattern_match;
	      if ((!match_lines && !match_words)
		  || (match_lines && len == end - beg - 1))
		{
		  match = beg;
		  len = end - beg;
		  goto assess_pattern_match;
		}
	      /* If -w, check if the match aligns with word boundaries.
		 We do this iteratively because:
		 (a) the line may contain more than one occurence of the
		 pattern, and
		 (b) Several alternatives in the pattern might be valid at a
		 given point, and we may need to consider a shorter one to
		 find a word boundary.  */
	      if (match_words)
		while (match <= best_match)
		  {
		    if ((match == buf || !WCHAR ((unsigned char) match[-1]))
			&& (len == end - beg - 1
			    || !WCHAR ((unsigned char) match[len])))
		      goto assess_pattern_match;
		    if (len > 0)
		      {
			/* Try a shorter length anchored at the same place. */
			--len;
			patterns[i].regexbuf.not_eol = 1;
			len = re_match (&(patterns[i].regexbuf),
					buf, match + len - beg, match - buf,
					&(patterns[i].regs));
		      }
		    if (len <= 0)
		      {
			/* Try looking further on. */
			if (match == end - 1)
			  break;
			match++;
			patterns[i].regexbuf.not_eol = 0;
			start = re_search (&(patterns[i].regexbuf),
					   buf, end - buf - 1,
					   match - buf, end - match - 1,
					   &(patterns[i].regs));
			if (start < 0)
			  break;
			len = patterns[i].regs.end[0] - start;
			match = buf + start;
		      }
		  } /* while (match <= best_match) */
	      continue;
	    assess_pattern_match:
	      if (!start_ptr)
		{
		  /* Good enough for a non-exact match.
		     No need to look at further patterns, if any.  */
		  beg = match;
		  goto success_in_len;
		}
	      if (match < best_match || (match == best_match && len > best_len))
		{
		  /* Best exact match:  leftmost, then longest.  */
		  best_match = match;
		  best_len = len;
		}
	    } /* if re_search >= 0 */
	} /* for Regex patterns.  */
	if (best_match < end)
	  {
	    /* We have found an exact match.  We were just
	       waiting for the best one (leftmost then longest).  */
	    beg = best_match;
	    len = best_len;
	    goto success_in_len;
	  }
    } /* for (beg = end ..) */

 failure:
  ret_val = -1;
  goto out;

 success:
  len = end - beg;
 success_in_len:
  *match_size = len;
  ret_val = beg - buf;
 out:
  return ret_val;
}
#endif /* defined(GREP_PROGRAM) || defined(EGREP_PROGRAM) */

#if defined(GREP_PROGRAM) || defined(FGREP_PROGRAM)
COMPILE_FCT(Fcompile)
{
  char const *beg, *end, *lim, *err, *pat;
  size_t psize;

  kwsinit ();
  psize = size;
  if (match_icase && MB_CUR_MAX > 1)
    pat = mbtolower (pattern, &psize);
  else
    pat = pattern;

  beg = pat;
  do
    {
      for (lim = beg;; ++lim)
	{
	  end = lim;
	  if (lim >= pat + psize)
	    break;
	 if (*lim == '\n')
	   {
	     lim++;
	     break;
	   }
#if HAVE_DOS_FILE_CONTENTS
	 if (*lim == '\r' && lim + 1 < pat + psize && lim[1] == '\n')
	   {
	     lim += 2;
	     break;
	   }
#endif
	}

      if ((err = kwsincr (kwset, beg, end - beg)) != NULL)
	error (EXIT_TROUBLE, 0, "%s", err);
      beg = lim;
    }
  while (beg < pat + psize);

  if ((err = kwsprep (kwset)) != NULL)
    error (EXIT_TROUBLE, 0, "%s", err);
}

EXECUTE_FCT(Fexecute)
{
  char const *beg, *try, *end, *mb_start;
  size_t len;
  char eol = eolbyte;
  struct kwsmatch kwsmatch;
  size_t ret_val;
#ifdef MBS_SUPPORT
  if (MB_CUR_MAX > 1)
    {
      if (match_icase)
        {
          char *case_buf = mbtolower (buf, &size);
	  if (start_ptr)
	    start_ptr = case_buf + (start_ptr - buf);
          buf = case_buf;
        }
    }
#endif /* MBS_SUPPORT */

  for (mb_start = beg = start_ptr ? start_ptr : buf; beg <= buf + size; beg++)
    {
      size_t offset = kwsexec (kwset, beg, buf + size - beg, &kwsmatch);
      if (offset == (size_t) -1)
	goto failure;
#ifdef MBS_SUPPORT
      if (MB_CUR_MAX > 1 && is_mb_middle (&mb_start, beg + offset, buf + size))
        {
          beg = mb_start - 1;
          continue; /* It is a part of multibyte character.  */
        }
#endif /* MBS_SUPPORT */
      beg += offset;
      len = kwsmatch.size[0];
      if (start_ptr && !match_words)
	goto success_in_beg_and_len;
      if (match_lines)
	{
	  if (beg > buf && beg[-1] != eol)
	    continue;
	  if (beg + len < buf + size && beg[len] != eol)
	    continue;
	  goto success;
	}
      else if (match_words)
	for (try = beg; len; )
	  {
	    if (try > buf && WCHAR((unsigned char) try[-1]))
	      break;
	    if (try + len < buf + size && WCHAR((unsigned char) try[len]))
	      {
		offset = kwsexec (kwset, beg, --len, &kwsmatch);
		if (offset == (size_t) -1)
		  break;
		try = beg + offset;
		len = kwsmatch.size[0];
	      }
	    else if (!start_ptr)
	      goto success;
	    else
	      goto success_in_beg_and_len;
	  } /* for (try) */
      else
	goto success;
    } /* for (beg in buf) */

 failure:
  ret_val = -1;
  goto out;

 success:
  if ((end = memchr (beg + len, eol, (buf + size) - (beg + len))) != NULL)
    end++;
  else
    end = buf + size;
  while (buf < beg && beg[-1] != eol)
    --beg;
  len = end - beg;
 success_in_beg_and_len:
  *match_size = len;
  ret_val = beg - buf;
 out:
  return ret_val;
}
#endif /* defined(GREP_PROGRAM) || defined(FGREP_PROGRAM) */

#ifdef GREP_PROGRAM
#if HAVE_LIBPCRE
/* Compiled internal form of a Perl regular expression.  */
static pcre *cre;

/* Additional information about the pattern.  */
static pcre_extra *extra;
#endif

COMPILE_FCT(Pcompile)
{
#if !HAVE_LIBPCRE
  error (EXIT_TROUBLE, 0, "%s",
	 _("support for the -P option is not compiled into "
	   "this --disable-perl-regexp binary"));
#else
  int e;
  char const *ep;
  char *re = xmalloc (4 * size + 7);
  int flags = PCRE_MULTILINE | (match_icase ? PCRE_CASELESS : 0);
  char const *patlim = pattern + size;
  char *n = re;
  char const *p;
  char const *pnul;

  /* FIXME: Remove these restrictions.  */
  if (memchr(pattern, '\n', size))
    error (EXIT_TROUBLE, 0, _("the -P option only supports a single pattern"));

  *n = '\0';
  if (match_lines)
    strcpy (n, "^(");
  if (match_words)
    strcpy (n, "\\b(");
  n += strlen (n);

  /* The PCRE interface doesn't allow NUL bytes in the pattern, so
     replace each NUL byte in the pattern with the four characters
     "\000", removing a preceding backslash if there are an odd
     number of backslashes before the NUL.

     FIXME: This method does not work with some multibyte character
     encodings, notably Shift-JIS, where a multibyte character can end
     in a backslash byte.  */
  for (p = pattern; (pnul = memchr (p, '\0', patlim - p)); p = pnul + 1)
    {
      memcpy (n, p, pnul - p);
      n += pnul - p;
      for (p = pnul; pattern < p && p[-1] == '\\'; p--)
	continue;
      n -= (pnul - p) & 1;
      strcpy (n, "\\000");
      n += 4;
    }

  memcpy (n, p, patlim - p);
  n += patlim - p;
  *n = '\0';
  if (match_words)
    strcpy (n, ")\\b");
  if (match_lines)
    strcpy (n, ")$");

  cre = pcre_compile (re, flags, &ep, &e, pcre_maketables ());
  if (!cre)
    error (EXIT_TROUBLE, 0, "%s", ep);

  extra = pcre_study (cre, 0, &ep);
  if (ep)
    error (EXIT_TROUBLE, 0, "%s", ep);

  free (re);
#endif
}

EXECUTE_FCT(Pexecute)
{
#if !HAVE_LIBPCRE
  abort ();
  return -1;
#else
  /* This array must have at least two elements; everything after that
     is just for performance improvement in pcre_exec.  */
  int sub[300];

  const char *line_buf, *line_end, *line_next;
  int e = PCRE_ERROR_NOMATCH;
  ptrdiff_t start_ofs = start_ptr ? start_ptr - buf : 0;

  /* PCRE can't limit the matching to single lines, therefore we have to
     match each line in the buffer separately.  */
  for (line_next = buf;
       e == PCRE_ERROR_NOMATCH && line_next < buf + size;
       start_ofs -= line_next - line_buf)
    {
      line_buf = line_next;
      line_end = memchr (line_buf, eolbyte, (buf + size) - line_buf);
      if (line_end == NULL)
        line_next = line_end = buf + size;
      else
        line_next = line_end + 1;

      if (start_ptr && start_ptr >= line_end)
        continue;

      e = pcre_exec (cre, extra, line_buf, line_end - line_buf,
                     start_ofs < 0 ? 0 : start_ofs, 0,
                     sub, sizeof sub / sizeof *sub);
    }

  if (e <= 0)
    {
      switch (e)
	{
	case PCRE_ERROR_NOMATCH:
	  return -1;

	case PCRE_ERROR_NOMEMORY:
	  error (EXIT_TROUBLE, 0, _("memory exhausted"));

	default:
	  abort ();
	}
    }
  else
    {
      /* Narrow down to the line we've found.  */
      char const *beg = line_buf + sub[0];
      char const *end = line_buf + sub[1];
      char const *buflim = buf + size;
      char eol = eolbyte;
      if (!start_ptr)
	{
	  /* FIXME: The case when '\n' is not found indicates a bug:
	     Since grep is line oriented, the match should never contain
	     a newline, so there _must_ be a newline following.
	   */
	  if (!(end = memchr (end, eol, buflim - end)))
	    end = buflim;
	  else
	    end++;
	  while (buf < beg && beg[-1] != eol)
	    --beg;
	}

      *match_size = end - beg;
      return beg - buf;
    }
#endif
}

struct matcher const matchers[] = {
  { "default", Gcompile, EGexecute },
  { "grep",    Gcompile, EGexecute },
  { "egrep",   Ecompile, EGexecute },
  { "awk",     Acompile, EGexecute },
  { "fgrep",   Fcompile, Fexecute },
  { "perl",    Pcompile, Pexecute },
  { "", 0, 0 },
};
#endif /* GREP_PROGRAM */

Spawn 1 instances, now Total 16
Counter: 17
Batcher Size:16
Preprocess the following candidate with CondTester:
Priority 20000
At location src/search.c:62
--Src File: src/search.c
Fragment 0:
if (((match_icase) || (__abst_hole(match_icase, i, kwset))) && (__ctype_get_mb_cur_max()) == 1) {
    for (i = 0; i < ((127 * 2 + 1) + 1); ++i) 
        trans[i] = ((1 && ((*__ctype_b_loc())[(int)((i))] & (unsigned short)_ISupper)) ? (__extension__ ({
            int __res;
            if (sizeof (i) > 1) {
                if (__builtin_constant_p(i)) {
                    int __c = (i);
                    __res = __c < -128 || __c > 255 ? __c : (*__ctype_tolower_loc())[__c];
                } else
                    __res = tolower(i);
            } else
                __res = (*__ctype_tolower_loc())[(int)(i)];
            __res;
        })) : (i));
    kwset = kwsalloc(trans);
} else
    kwset = kwsalloc(((void *)0));


CondTester, a patch instance with id 16:
//src_file:src/search.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
/* search.c - searching subroutines using dfa, kwset and regex for grep.
   Copyright 1992, 1998, 2000, 2007, 2009-2010 Free Software Foundation, Inc.

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 3, or (at your option)
   any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program; if not, write to the Free Software
   Foundation, Inc., 51 Franklin Street - Fifth Floor, Boston, MA
   02110-1301, USA.  */

/* Written August 1992 by Mike Haertel. */

#include <config.h>

#include <sys/types.h>

#include "mbsupport.h"
#ifdef MBS_SUPPORT
/* We can handle multibyte strings. */
# include <wchar.h>
# include <wctype.h>
#endif

#include "system.h"
#include "grep.h"
#ifndef FGREP_PROGRAM
# include <regex.h>
# include "dfa.h"
#endif
#include "kwset.h"
#include "error.h"
#include "xalloc.h"
#ifdef HAVE_LIBPCRE
# include <pcre.h>
#endif

#define NCHAR (UCHAR_MAX + 1)

/* For -w, we also consider _ to be word constituent.  */
#define WCHAR(C) (ISALNUM(C) || (C) == '_')

/* KWset compiled pattern.  For Ecompile and Gcompile, we compile
   a list of strings, at least one of which is known to occur in
   any string matching the regexp. */
static kwset_t kwset;

static void
kwsinit (void)
{
  static char trans[NCHAR];
  int i;

  
//Patch 0:
if (((match_icase) || (__is_neg(3, &(match_icase), sizeof (match_icase), &(i), sizeof (i), &(kwset), sizeof (kwset)))) && (__ctype_get_mb_cur_max()) == 1) {
    for (i = 0; i < ((127 * 2 + 1) + 1); ++i) 
        trans[i] = ((1 && ((*__ctype_b_loc())[(int)((i))] & (unsigned short)_ISupper)) ? (__extension__ ({
            int __res;
            if (sizeof (i) > 1) {
                if (__builtin_constant_p(i)) {
                    int __c = (i);
                    __res = __c < -128 || __c > 255 ? __c : (*__ctype_tolower_loc())[__c];
                } else
                    __res = tolower(i);
            } else
                __res = (*__ctype_tolower_loc())[(int)(i)];
            __res;
        })) : (i));
    kwset = kwsalloc(trans);
} else
    kwset = kwsalloc(((void *)0));

//CodeSeg 1:

  if (!kwset)
    xalloc_die ();
}

#ifdef MBS_SUPPORT
/* Convert the *N-byte string, BEG, to lowercase, and write the
   NUL-terminated result into malloc'd storage.  Upon success, set *N
   to the length (in bytes) of the resulting string (not including the
   trailing NUL byte), and return a pointer to the lowercase string.
   Upon memory allocation failure, this function exits.

   Note that while this function returns a pointer to malloc'd storage,
   the caller must not free it, since this function retains a pointer
   to the buffer and reuses it on any subsequent call.  As a consequence,
   this function is not thread-safe.  */
static char *
mbtolower (const char *beg, size_t *n)
{
  static char *out;
  static size_t outalloc;
  size_t outlen, mb_cur_max;
  mbstate_t is, os;
  const char *end;
  char *p;

  if (*n > outalloc)
    {
      out = xrealloc (out, *n);
      outalloc = *n;
    }

  memset (&is, 0, sizeof (is));
  memset (&os, 0, sizeof (os));
  end = beg + *n;

  mb_cur_max = MB_CUR_MAX;
  p = out;
  outlen = 0;
  while (beg < end)
    {
      wchar_t wc;
      size_t mbclen = mbrtowc(&wc, beg, end - beg, &is);
      if (outlen + mb_cur_max >= outalloc)
        {
          out = x2nrealloc (out, &outalloc, 1);
          p = out + outlen;
        }

      if (mbclen == (size_t) -1 || mbclen == (size_t) -2 || mbclen == 0)
        {
          /* An invalid sequence, or a truncated multi-octet character.
             We treat it as a single-octet character.  */
          *p++ = *beg++;
          outlen++;
          memset (&is, 0, sizeof (is));
          memset (&os, 0, sizeof (os));
        }
      else
        {
          beg += mbclen;
          mbclen = wcrtomb (p, towlower ((wint_t) wc), &os);
          p += mbclen;
          outlen += mbclen;
        }
    }

  *n = p - out;
  *p++ = 0;
  return out;
}
#endif


#ifndef FGREP_PROGRAM
/* DFA compiled regexp. */
static struct dfa dfa;

/* The Regex compiled patterns.  */
static struct patterns
{
  /* Regex compiled regexp. */
  struct re_pattern_buffer regexbuf;
  struct re_registers regs; /* This is here on account of a BRAIN-DEAD
			       Q@#%!# library interface in regex.c.  */
} patterns0;

struct patterns *patterns;
size_t pcount;

void
dfaerror (char const *mesg)
{
  error (EXIT_TROUBLE, 0, "%s", mesg);
}

/* Number of compiled fixed strings known to exactly match the regexp.
   If kwsexec returns < kwset_exact_matches, then we don't need to
   call the regexp matcher at all. */
static int kwset_exact_matches;

static char const *
kwsincr_case (const char *must)
{
  const char *buf;
  size_t n;

  n = strlen (must);
#ifdef MBS_SUPPORT
  if (match_icase && MB_CUR_MAX > 1)
    buf = mbtolower (must, &n);
  else
#endif
    buf = must;
  return kwsincr (kwset, buf, n);
}

/* If the DFA turns out to have some set of fixed strings one of
   which must occur in the match, then we build a kwset matcher
   to find those strings, and thus quickly filter out impossible
   matches. */
static void
kwsmusts (void)
{
  struct dfamust const *dm;
  char const *err;

  if (dfa.musts)
    {
      kwsinit ();
      /* First, we compile in the substrings known to be exact
	 matches.  The kwset matcher will return the index
	 of the matching string that it chooses. */
      for (dm = dfa.musts; dm; dm = dm->next)
	{
	  if (!dm->exact)
	    continue;
	  ++kwset_exact_matches;
	  if ((err = kwsincr_case (dm->must)) != NULL)
	    error (EXIT_TROUBLE, 0, "%s", err);
	}
      /* Now, we compile the substrings that will require
	 the use of the regexp matcher.  */
      for (dm = dfa.musts; dm; dm = dm->next)
	{
	  if (dm->exact)
	    continue;
	  if ((err = kwsincr_case (dm->must)) != NULL)
	    error (EXIT_TROUBLE, 0, "%s", err);
	}
      if ((err = kwsprep (kwset)) != NULL)
	error (EXIT_TROUBLE, 0, "%s", err);
    }
}
#endif /* !FGREP_PROGRAM */

#ifdef MBS_SUPPORT

static bool
is_mb_middle(const char **good, const char *buf, const char *end)
{
  const char *p = *good;
  const char *prev = p;
  mbstate_t cur_state;

  /* TODO: can be optimized for UTF-8.  */
  memset(&cur_state, 0, sizeof(mbstate_t));
  while (p < buf)
    {
      size_t mbclen = mbrlen(p, end - p, &cur_state);

      /* Store the beginning of the previous complete multibyte character.  */
      if (mbclen != (size_t) -2)
        prev = p;

      if (mbclen == (size_t) -1 || mbclen == (size_t) -2 || mbclen == 0)
	{
	  /* An invalid sequence, or a truncated multibyte character.
	     We treat it as a single byte character.  */
	  mbclen = 1;
	}
      p += mbclen;
    }

  *good = prev;
  return p > buf;
}
#endif /* MBS_SUPPORT */

#if defined(GREP_PROGRAM) || defined(EGREP_PROGRAM)
#ifdef EGREP_PROGRAM
COMPILE_FCT(Ecompile)
{
  reg_syntax_t syntax_bits = RE_SYNTAX_POSIX_EGREP;
#else
/* No __VA_ARGS__ in C89.  So we have to do it this way.  */
static COMPILE_RET
GEAcompile (char const *pattern, size_t size, reg_syntax_t syntax_bits)
{
#endif /* EGREP_PROGRAM */
  const char *err;
  const char *p, *sep;
  size_t total = size;
  char *motif;

  if (match_icase)
    syntax_bits |= RE_ICASE;
  re_set_syntax (syntax_bits);
  dfasyntax (syntax_bits, match_icase, eolbyte);

  /* For GNU regex compiler we have to pass the patterns separately to detect
     errors like "[\nallo\n]\n".  The patterns here are "[", "allo" and "]"
     GNU regex should have raise a syntax error.  The same for backref, where
     the backref should have been local to each pattern.  */
  p = pattern;
  do
    {
      size_t len;
      sep = memchr (p, '\n', total);
      if (sep)
	{
	  len = sep - p;
	  sep++;
	  total -= (len + 1);
	}
      else
	{
	  len = total;
	  total = 0;
	}

      patterns = realloc (patterns, (pcount + 1) * sizeof (*patterns));
      if (patterns == NULL)
	error (EXIT_TROUBLE, errno, _("memory exhausted"));
      patterns[pcount] = patterns0;

      if ((err = re_compile_pattern (p, len,
				    &(patterns[pcount].regexbuf))) != NULL)
	error (EXIT_TROUBLE, 0, "%s", err);
      pcount++;

      p = sep;
    } while (sep && total != 0);

  /* In the match_words and match_lines cases, we use a different pattern
     for the DFA matcher that will quickly throw out cases that won't work.
     Then if DFA succeeds we do some hairy stuff using the regex matcher
     to decide whether the match should really count. */
  if (match_words || match_lines)
    {
      static char const line_beg_no_bk[] = "^(";
      static char const line_end_no_bk[] = ")$";
      static char const word_beg_no_bk[] = "(^|[^[:alnum:]_])(";
      static char const word_end_no_bk[] = ")([^[:alnum:]_]|$)";
#ifdef EGREP_PROGRAM
# define IF_BK(x, y) (y)
      char *n = xmalloc (sizeof word_beg_no_bk - 1 + size + sizeof word_end_no_bk);
#else
      static char const line_beg_bk[] = "^\\(";
      static char const line_end_bk[] = "\\)$";
      static char const word_beg_bk[] = "\\(^\\|[^[:alnum:]_]\\)\\(";
      static char const word_end_bk[] = "\\)\\([^[:alnum:]_]\\|$\\)";
      int bk = !(syntax_bits & RE_NO_BK_PARENS);
# define IF_BK(x, y) ((bk) ? (x) : (y))
      char *n = xmalloc (sizeof word_beg_bk - 1 + size + sizeof word_end_bk);
#endif /* EGREP_PROGRAM */

      strcpy (n, match_lines ? IF_BK(line_beg_bk, line_beg_no_bk)
			     : IF_BK(word_beg_bk, word_beg_no_bk));
      total = strlen(n);
      memcpy (n + total, pattern, size);
      total += size;
      strcpy (n + total, match_lines ? IF_BK(line_end_bk, line_end_no_bk)
				     : IF_BK(word_end_bk, word_end_no_bk));
      total += strlen (n + total);
      pattern = motif = n;
      size = total;
    }
  else
    motif = NULL;

  dfacomp (pattern, size, &dfa, 1);
  kwsmusts ();

  free(motif);
}

#ifndef EGREP_PROGRAM
COMPILE_FCT(Gcompile)
{
  return GEAcompile (pattern, size,
		     RE_SYNTAX_GREP | RE_HAT_LISTS_NOT_NEWLINE);
}

COMPILE_FCT(Acompile)
{
  return GEAcompile (pattern, size, RE_SYNTAX_AWK);
}

COMPILE_FCT(Ecompile)
{
  return GEAcompile (pattern, size, RE_SYNTAX_POSIX_EGREP);
}
#endif /* !EGREP_PROGRAM */

EXECUTE_FCT(EGexecute)
{
  char const *buflim, *beg, *end, *match, *best_match, *mb_start;
  char eol = eolbyte;
  int backref, start, len, best_len;
  struct kwsmatch kwsm;
  size_t i, ret_val;
#ifdef MBS_SUPPORT
  if (MB_CUR_MAX > 1)
    {
      if (match_icase)
        {
          /* mbtolower adds a NUL byte at the end.  That will provide
	     space for the sentinel byte dfaexec may add.  */
          char *case_buf = mbtolower (buf, &size);
	  if (start_ptr)
	    start_ptr = case_buf + (start_ptr - buf);
          buf = case_buf;
        }
    }
#endif /* MBS_SUPPORT */

  mb_start = buf;
  buflim = buf + size;

  for (beg = end = buf; end < buflim; beg = end)
    {
      if (!start_ptr)
	{
	  /* We don't care about an exact match.  */
	  if (kwset)
	    {
	      /* Find a possible match using the KWset matcher. */
	      size_t offset = kwsexec (kwset, beg, buflim - beg, &kwsm);
	      if (offset == (size_t) -1)
		goto failure;
	      beg += offset;
	      /* Narrow down to the line containing the candidate, and
		 run it through DFA. */
	      if ((end = memchr(beg, eol, buflim - beg)) != NULL)
	        end++;
              else
                end = buflim;
	      match = beg;
	      while (beg > buf && beg[-1] != eol)
		--beg;
	      if (kwsm.index < kwset_exact_matches)
                {
#ifdef MBS_SUPPORT
                  if (mb_start < beg)
                    mb_start = beg;
                  if (MB_CUR_MAX == 1 || !is_mb_middle (&mb_start, match, buflim))
#endif
                    goto success;
                }
	      if (dfaexec (&dfa, beg, (char *) end, 0, NULL, &backref) == NULL)
		continue;
	    }
	  else
	    {
	      /* No good fixed strings; start with DFA. */
	      char const *next_beg = dfaexec (&dfa, beg, (char *) buflim,
					      0, NULL, &backref);
	      if (next_beg == NULL)
		break;
	      /* Narrow down to the line we've found. */
	      beg = next_beg;
	      if ((end = memchr(beg, eol, buflim - beg)) != NULL)
	        end++;
              else
                end = buflim;
	      while (beg > buf && beg[-1] != eol)
		--beg;
	    }
	  /* Successful, no backreferences encountered! */
	  if (!backref)
	    goto success;
	}
      else
	{
	  /* We are looking for the leftmost (then longest) exact match.
	     We will go through the outer loop only once.  */
	  beg = start_ptr;
	  end = buflim;
	}

      /* If we've made it to this point, this means DFA has seen
	 a probable match, and we need to run it through Regex. */
      best_match = end;
      best_len = 0;
      for (i = 0; i < pcount; i++)
	{
	  patterns[i].regexbuf.not_eol = 0;
	  if (0 <= (start = re_search (&(patterns[i].regexbuf),
				       buf, end - buf - 1,
				       beg - buf, end - beg - 1,
				       &(patterns[i].regs))))
	    {
	      len = patterns[i].regs.end[0] - start;
	      match = buf + start;
	      if (match > best_match)
		continue;
	      if (start_ptr && !match_words)
		goto assess_pattern_match;
	      if ((!match_lines && !match_words)
		  || (match_lines && len == end - beg - 1))
		{
		  match = beg;
		  len = end - beg;
		  goto assess_pattern_match;
		}
	      /* If -w, check if the match aligns with word boundaries.
		 We do this iteratively because:
		 (a) the line may contain more than one occurence of the
		 pattern, and
		 (b) Several alternatives in the pattern might be valid at a
		 given point, and we may need to consider a shorter one to
		 find a word boundary.  */
	      if (match_words)
		while (match <= best_match)
		  {
		    if ((match == buf || !WCHAR ((unsigned char) match[-1]))
			&& (len == end - beg - 1
			    || !WCHAR ((unsigned char) match[len])))
		      goto assess_pattern_match;
		    if (len > 0)
		      {
			/* Try a shorter length anchored at the same place. */
			--len;
			patterns[i].regexbuf.not_eol = 1;
			len = re_match (&(patterns[i].regexbuf),
					buf, match + len - beg, match - buf,
					&(patterns[i].regs));
		      }
		    if (len <= 0)
		      {
			/* Try looking further on. */
			if (match == end - 1)
			  break;
			match++;
			patterns[i].regexbuf.not_eol = 0;
			start = re_search (&(patterns[i].regexbuf),
					   buf, end - buf - 1,
					   match - buf, end - match - 1,
					   &(patterns[i].regs));
			if (start < 0)
			  break;
			len = patterns[i].regs.end[0] - start;
			match = buf + start;
		      }
		  } /* while (match <= best_match) */
	      continue;
	    assess_pattern_match:
	      if (!start_ptr)
		{
		  /* Good enough for a non-exact match.
		     No need to look at further patterns, if any.  */
		  beg = match;
		  goto success_in_len;
		}
	      if (match < best_match || (match == best_match && len > best_len))
		{
		  /* Best exact match:  leftmost, then longest.  */
		  best_match = match;
		  best_len = len;
		}
	    } /* if re_search >= 0 */
	} /* for Regex patterns.  */
	if (best_match < end)
	  {
	    /* We have found an exact match.  We were just
	       waiting for the best one (leftmost then longest).  */
	    beg = best_match;
	    len = best_len;
	    goto success_in_len;
	  }
    } /* for (beg = end ..) */

 failure:
  ret_val = -1;
  goto out;

 success:
  len = end - beg;
 success_in_len:
  *match_size = len;
  ret_val = beg - buf;
 out:
  return ret_val;
}
#endif /* defined(GREP_PROGRAM) || defined(EGREP_PROGRAM) */

#if defined(GREP_PROGRAM) || defined(FGREP_PROGRAM)
COMPILE_FCT(Fcompile)
{
  char const *beg, *end, *lim, *err, *pat;
  size_t psize;

  kwsinit ();
  psize = size;
  if (match_icase && MB_CUR_MAX > 1)
    pat = mbtolower (pattern, &psize);
  else
    pat = pattern;

  beg = pat;
  do
    {
      for (lim = beg;; ++lim)
	{
	  end = lim;
	  if (lim >= pat + psize)
	    break;
	 if (*lim == '\n')
	   {
	     lim++;
	     break;
	   }
#if HAVE_DOS_FILE_CONTENTS
	 if (*lim == '\r' && lim + 1 < pat + psize && lim[1] == '\n')
	   {
	     lim += 2;
	     break;
	   }
#endif
	}

      if ((err = kwsincr (kwset, beg, end - beg)) != NULL)
	error (EXIT_TROUBLE, 0, "%s", err);
      beg = lim;
    }
  while (beg < pat + psize);

  if ((err = kwsprep (kwset)) != NULL)
    error (EXIT_TROUBLE, 0, "%s", err);
}

EXECUTE_FCT(Fexecute)
{
  char const *beg, *try, *end, *mb_start;
  size_t len;
  char eol = eolbyte;
  struct kwsmatch kwsmatch;
  size_t ret_val;
#ifdef MBS_SUPPORT
  if (MB_CUR_MAX > 1)
    {
      if (match_icase)
        {
          char *case_buf = mbtolower (buf, &size);
	  if (start_ptr)
	    start_ptr = case_buf + (start_ptr - buf);
          buf = case_buf;
        }
    }
#endif /* MBS_SUPPORT */

  for (mb_start = beg = start_ptr ? start_ptr : buf; beg <= buf + size; beg++)
    {
      size_t offset = kwsexec (kwset, beg, buf + size - beg, &kwsmatch);
      if (offset == (size_t) -1)
	goto failure;
#ifdef MBS_SUPPORT
      if (MB_CUR_MAX > 1 && is_mb_middle (&mb_start, beg + offset, buf + size))
        {
          beg = mb_start - 1;
          continue; /* It is a part of multibyte character.  */
        }
#endif /* MBS_SUPPORT */
      beg += offset;
      len = kwsmatch.size[0];
      if (start_ptr && !match_words)
	goto success_in_beg_and_len;
      if (match_lines)
	{
	  if (beg > buf && beg[-1] != eol)
	    continue;
	  if (beg + len < buf + size && beg[len] != eol)
	    continue;
	  goto success;
	}
      else if (match_words)
	for (try = beg; len; )
	  {
	    if (try > buf && WCHAR((unsigned char) try[-1]))
	      break;
	    if (try + len < buf + size && WCHAR((unsigned char) try[len]))
	      {
		offset = kwsexec (kwset, beg, --len, &kwsmatch);
		if (offset == (size_t) -1)
		  break;
		try = beg + offset;
		len = kwsmatch.size[0];
	      }
	    else if (!start_ptr)
	      goto success;
	    else
	      goto success_in_beg_and_len;
	  } /* for (try) */
      else
	goto success;
    } /* for (beg in buf) */

 failure:
  ret_val = -1;
  goto out;

 success:
  if ((end = memchr (beg + len, eol, (buf + size) - (beg + len))) != NULL)
    end++;
  else
    end = buf + size;
  while (buf < beg && beg[-1] != eol)
    --beg;
  len = end - beg;
 success_in_beg_and_len:
  *match_size = len;
  ret_val = beg - buf;
 out:
  return ret_val;
}
#endif /* defined(GREP_PROGRAM) || defined(FGREP_PROGRAM) */

#ifdef GREP_PROGRAM
#if HAVE_LIBPCRE
/* Compiled internal form of a Perl regular expression.  */
static pcre *cre;

/* Additional information about the pattern.  */
static pcre_extra *extra;
#endif

COMPILE_FCT(Pcompile)
{
#if !HAVE_LIBPCRE
  error (EXIT_TROUBLE, 0, "%s",
	 _("support for the -P option is not compiled into "
	   "this --disable-perl-regexp binary"));
#else
  int e;
  char const *ep;
  char *re = xmalloc (4 * size + 7);
  int flags = PCRE_MULTILINE | (match_icase ? PCRE_CASELESS : 0);
  char const *patlim = pattern + size;
  char *n = re;
  char const *p;
  char const *pnul;

  /* FIXME: Remove these restrictions.  */
  if (memchr(pattern, '\n', size))
    error (EXIT_TROUBLE, 0, _("the -P option only supports a single pattern"));

  *n = '\0';
  if (match_lines)
    strcpy (n, "^(");
  if (match_words)
    strcpy (n, "\\b(");
  n += strlen (n);

  /* The PCRE interface doesn't allow NUL bytes in the pattern, so
     replace each NUL byte in the pattern with the four characters
     "\000", removing a preceding backslash if there are an odd
     number of backslashes before the NUL.

     FIXME: This method does not work with some multibyte character
     encodings, notably Shift-JIS, where a multibyte character can end
     in a backslash byte.  */
  for (p = pattern; (pnul = memchr (p, '\0', patlim - p)); p = pnul + 1)
    {
      memcpy (n, p, pnul - p);
      n += pnul - p;
      for (p = pnul; pattern < p && p[-1] == '\\'; p--)
	continue;
      n -= (pnul - p) & 1;
      strcpy (n, "\\000");
      n += 4;
    }

  memcpy (n, p, patlim - p);
  n += patlim - p;
  *n = '\0';
  if (match_words)
    strcpy (n, ")\\b");
  if (match_lines)
    strcpy (n, ")$");

  cre = pcre_compile (re, flags, &ep, &e, pcre_maketables ());
  if (!cre)
    error (EXIT_TROUBLE, 0, "%s", ep);

  extra = pcre_study (cre, 0, &ep);
  if (ep)
    error (EXIT_TROUBLE, 0, "%s", ep);

  free (re);
#endif
}

EXECUTE_FCT(Pexecute)
{
#if !HAVE_LIBPCRE
  abort ();
  return -1;
#else
  /* This array must have at least two elements; everything after that
     is just for performance improvement in pcre_exec.  */
  int sub[300];

  const char *line_buf, *line_end, *line_next;
  int e = PCRE_ERROR_NOMATCH;
  ptrdiff_t start_ofs = start_ptr ? start_ptr - buf : 0;

  /* PCRE can't limit the matching to single lines, therefore we have to
     match each line in the buffer separately.  */
  for (line_next = buf;
       e == PCRE_ERROR_NOMATCH && line_next < buf + size;
       start_ofs -= line_next - line_buf)
    {
      line_buf = line_next;
      line_end = memchr (line_buf, eolbyte, (buf + size) - line_buf);
      if (line_end == NULL)
        line_next = line_end = buf + size;
      else
        line_next = line_end + 1;

      if (start_ptr && start_ptr >= line_end)
        continue;

      e = pcre_exec (cre, extra, line_buf, line_end - line_buf,
                     start_ofs < 0 ? 0 : start_ofs, 0,
                     sub, sizeof sub / sizeof *sub);
    }

  if (e <= 0)
    {
      switch (e)
	{
	case PCRE_ERROR_NOMATCH:
	  return -1;

	case PCRE_ERROR_NOMEMORY:
	  error (EXIT_TROUBLE, 0, _("memory exhausted"));

	default:
	  abort ();
	}
    }
  else
    {
      /* Narrow down to the line we've found.  */
      char const *beg = line_buf + sub[0];
      char const *end = line_buf + sub[1];
      char const *buflim = buf + size;
      char eol = eolbyte;
      if (!start_ptr)
	{
	  /* FIXME: The case when '\n' is not found indicates a bug:
	     Since grep is line oriented, the match should never contain
	     a newline, so there _must_ be a newline following.
	   */
	  if (!(end = memchr (end, eol, buflim - end)))
	    end = buflim;
	  else
	    end++;
	  while (buf < beg && beg[-1] != eol)
	    --beg;
	}

      *match_size = end - beg;
      return beg - buf;
    }
#endif
}

struct matcher const matchers[] = {
  { "default", Gcompile, EGexecute },
  { "grep",    Gcompile, EGexecute },
  { "egrep",   Ecompile, EGexecute },
  { "awk",     Acompile, EGexecute },
  { "fgrep",   Fcompile, Fexecute },
  { "perl",    Pcompile, Pexecute },
  { "", 0, 0 },
};
#endif /* GREP_PROGRAM */

Spawn 1 instances, now Total 17
Counter: 18
Batcher Size:17
Preprocess the following candidate with CondTester:
Priority 20000
At location src/search.c:587
--Src File: src/search.c
Fragment 0:
if ((lim >= pat + psize) && !(__abst_hole(lim, pat, psize, end, beg, pattern, match_icase, size, err, kwset)))
    break;


CondTester, a patch instance with id 17:
//src_file:src/search.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
/* search.c - searching subroutines using dfa, kwset and regex for grep.
   Copyright 1992, 1998, 2000, 2007, 2009-2010 Free Software Foundation, Inc.

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 3, or (at your option)
   any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program; if not, write to the Free Software
   Foundation, Inc., 51 Franklin Street - Fifth Floor, Boston, MA
   02110-1301, USA.  */

/* Written August 1992 by Mike Haertel. */

#include <config.h>

#include <sys/types.h>

#include "mbsupport.h"
#ifdef MBS_SUPPORT
/* We can handle multibyte strings. */
# include <wchar.h>
# include <wctype.h>
#endif

#include "system.h"
#include "grep.h"
#ifndef FGREP_PROGRAM
# include <regex.h>
# include "dfa.h"
#endif
#include "kwset.h"
#include "error.h"
#include "xalloc.h"
#ifdef HAVE_LIBPCRE
# include <pcre.h>
#endif

#define NCHAR (UCHAR_MAX + 1)

/* For -w, we also consider _ to be word constituent.  */
#define WCHAR(C) (ISALNUM(C) || (C) == '_')

/* KWset compiled pattern.  For Ecompile and Gcompile, we compile
   a list of strings, at least one of which is known to occur in
   any string matching the regexp. */
static kwset_t kwset;

static void
kwsinit (void)
{
  static char trans[NCHAR];
  int i;

  if (match_icase && MB_CUR_MAX == 1)
    {
      for (i = 0; i < NCHAR; ++i)
        trans[i] = TOLOWER (i);

      kwset = kwsalloc (trans);
    }
  else
    kwset = kwsalloc (NULL);

  if (!kwset)
    xalloc_die ();
}

#ifdef MBS_SUPPORT
/* Convert the *N-byte string, BEG, to lowercase, and write the
   NUL-terminated result into malloc'd storage.  Upon success, set *N
   to the length (in bytes) of the resulting string (not including the
   trailing NUL byte), and return a pointer to the lowercase string.
   Upon memory allocation failure, this function exits.

   Note that while this function returns a pointer to malloc'd storage,
   the caller must not free it, since this function retains a pointer
   to the buffer and reuses it on any subsequent call.  As a consequence,
   this function is not thread-safe.  */
static char *
mbtolower (const char *beg, size_t *n)
{
  static char *out;
  static size_t outalloc;
  size_t outlen, mb_cur_max;
  mbstate_t is, os;
  const char *end;
  char *p;

  if (*n > outalloc)
    {
      out = xrealloc (out, *n);
      outalloc = *n;
    }

  memset (&is, 0, sizeof (is));
  memset (&os, 0, sizeof (os));
  end = beg + *n;

  mb_cur_max = MB_CUR_MAX;
  p = out;
  outlen = 0;
  while (beg < end)
    {
      wchar_t wc;
      size_t mbclen = mbrtowc(&wc, beg, end - beg, &is);
      if (outlen + mb_cur_max >= outalloc)
        {
          out = x2nrealloc (out, &outalloc, 1);
          p = out + outlen;
        }

      if (mbclen == (size_t) -1 || mbclen == (size_t) -2 || mbclen == 0)
        {
          /* An invalid sequence, or a truncated multi-octet character.
             We treat it as a single-octet character.  */
          *p++ = *beg++;
          outlen++;
          memset (&is, 0, sizeof (is));
          memset (&os, 0, sizeof (os));
        }
      else
        {
          beg += mbclen;
          mbclen = wcrtomb (p, towlower ((wint_t) wc), &os);
          p += mbclen;
          outlen += mbclen;
        }
    }

  *n = p - out;
  *p++ = 0;
  return out;
}
#endif


#ifndef FGREP_PROGRAM
/* DFA compiled regexp. */
static struct dfa dfa;

/* The Regex compiled patterns.  */
static struct patterns
{
  /* Regex compiled regexp. */
  struct re_pattern_buffer regexbuf;
  struct re_registers regs; /* This is here on account of a BRAIN-DEAD
			       Q@#%!# library interface in regex.c.  */
} patterns0;

struct patterns *patterns;
size_t pcount;

void
dfaerror (char const *mesg)
{
  error (EXIT_TROUBLE, 0, "%s", mesg);
}

/* Number of compiled fixed strings known to exactly match the regexp.
   If kwsexec returns < kwset_exact_matches, then we don't need to
   call the regexp matcher at all. */
static int kwset_exact_matches;

static char const *
kwsincr_case (const char *must)
{
  const char *buf;
  size_t n;

  n = strlen (must);
#ifdef MBS_SUPPORT
  if (match_icase && MB_CUR_MAX > 1)
    buf = mbtolower (must, &n);
  else
#endif
    buf = must;
  return kwsincr (kwset, buf, n);
}

/* If the DFA turns out to have some set of fixed strings one of
   which must occur in the match, then we build a kwset matcher
   to find those strings, and thus quickly filter out impossible
   matches. */
static void
kwsmusts (void)
{
  struct dfamust const *dm;
  char const *err;

  if (dfa.musts)
    {
      kwsinit ();
      /* First, we compile in the substrings known to be exact
	 matches.  The kwset matcher will return the index
	 of the matching string that it chooses. */
      for (dm = dfa.musts; dm; dm = dm->next)
	{
	  if (!dm->exact)
	    continue;
	  ++kwset_exact_matches;
	  if ((err = kwsincr_case (dm->must)) != NULL)
	    error (EXIT_TROUBLE, 0, "%s", err);
	}
      /* Now, we compile the substrings that will require
	 the use of the regexp matcher.  */
      for (dm = dfa.musts; dm; dm = dm->next)
	{
	  if (dm->exact)
	    continue;
	  if ((err = kwsincr_case (dm->must)) != NULL)
	    error (EXIT_TROUBLE, 0, "%s", err);
	}
      if ((err = kwsprep (kwset)) != NULL)
	error (EXIT_TROUBLE, 0, "%s", err);
    }
}
#endif /* !FGREP_PROGRAM */

#ifdef MBS_SUPPORT

static bool
is_mb_middle(const char **good, const char *buf, const char *end)
{
  const char *p = *good;
  const char *prev = p;
  mbstate_t cur_state;

  /* TODO: can be optimized for UTF-8.  */
  memset(&cur_state, 0, sizeof(mbstate_t));
  while (p < buf)
    {
      size_t mbclen = mbrlen(p, end - p, &cur_state);

      /* Store the beginning of the previous complete multibyte character.  */
      if (mbclen != (size_t) -2)
        prev = p;

      if (mbclen == (size_t) -1 || mbclen == (size_t) -2 || mbclen == 0)
	{
	  /* An invalid sequence, or a truncated multibyte character.
	     We treat it as a single byte character.  */
	  mbclen = 1;
	}
      p += mbclen;
    }

  *good = prev;
  return p > buf;
}
#endif /* MBS_SUPPORT */

#if defined(GREP_PROGRAM) || defined(EGREP_PROGRAM)
#ifdef EGREP_PROGRAM
COMPILE_FCT(Ecompile)
{
  reg_syntax_t syntax_bits = RE_SYNTAX_POSIX_EGREP;
#else
/* No __VA_ARGS__ in C89.  So we have to do it this way.  */
static COMPILE_RET
GEAcompile (char const *pattern, size_t size, reg_syntax_t syntax_bits)
{
#endif /* EGREP_PROGRAM */
  const char *err;
  const char *p, *sep;
  size_t total = size;
  char *motif;

  if (match_icase)
    syntax_bits |= RE_ICASE;
  re_set_syntax (syntax_bits);
  dfasyntax (syntax_bits, match_icase, eolbyte);

  /* For GNU regex compiler we have to pass the patterns separately to detect
     errors like "[\nallo\n]\n".  The patterns here are "[", "allo" and "]"
     GNU regex should have raise a syntax error.  The same for backref, where
     the backref should have been local to each pattern.  */
  p = pattern;
  do
    {
      size_t len;
      sep = memchr (p, '\n', total);
      if (sep)
	{
	  len = sep - p;
	  sep++;
	  total -= (len + 1);
	}
      else
	{
	  len = total;
	  total = 0;
	}

      patterns = realloc (patterns, (pcount + 1) * sizeof (*patterns));
      if (patterns == NULL)
	error (EXIT_TROUBLE, errno, _("memory exhausted"));
      patterns[pcount] = patterns0;

      if ((err = re_compile_pattern (p, len,
				    &(patterns[pcount].regexbuf))) != NULL)
	error (EXIT_TROUBLE, 0, "%s", err);
      pcount++;

      p = sep;
    } while (sep && total != 0);

  /* In the match_words and match_lines cases, we use a different pattern
     for the DFA matcher that will quickly throw out cases that won't work.
     Then if DFA succeeds we do some hairy stuff using the regex matcher
     to decide whether the match should really count. */
  if (match_words || match_lines)
    {
      static char const line_beg_no_bk[] = "^(";
      static char const line_end_no_bk[] = ")$";
      static char const word_beg_no_bk[] = "(^|[^[:alnum:]_])(";
      static char const word_end_no_bk[] = ")([^[:alnum:]_]|$)";
#ifdef EGREP_PROGRAM
# define IF_BK(x, y) (y)
      char *n = xmalloc (sizeof word_beg_no_bk - 1 + size + sizeof word_end_no_bk);
#else
      static char const line_beg_bk[] = "^\\(";
      static char const line_end_bk[] = "\\)$";
      static char const word_beg_bk[] = "\\(^\\|[^[:alnum:]_]\\)\\(";
      static char const word_end_bk[] = "\\)\\([^[:alnum:]_]\\|$\\)";
      int bk = !(syntax_bits & RE_NO_BK_PARENS);
# define IF_BK(x, y) ((bk) ? (x) : (y))
      char *n = xmalloc (sizeof word_beg_bk - 1 + size + sizeof word_end_bk);
#endif /* EGREP_PROGRAM */

      strcpy (n, match_lines ? IF_BK(line_beg_bk, line_beg_no_bk)
			     : IF_BK(word_beg_bk, word_beg_no_bk));
      total = strlen(n);
      memcpy (n + total, pattern, size);
      total += size;
      strcpy (n + total, match_lines ? IF_BK(line_end_bk, line_end_no_bk)
				     : IF_BK(word_end_bk, word_end_no_bk));
      total += strlen (n + total);
      pattern = motif = n;
      size = total;
    }
  else
    motif = NULL;

  dfacomp (pattern, size, &dfa, 1);
  kwsmusts ();

  free(motif);
}

#ifndef EGREP_PROGRAM
COMPILE_FCT(Gcompile)
{
  return GEAcompile (pattern, size,
		     RE_SYNTAX_GREP | RE_HAT_LISTS_NOT_NEWLINE);
}

COMPILE_FCT(Acompile)
{
  return GEAcompile (pattern, size, RE_SYNTAX_AWK);
}

COMPILE_FCT(Ecompile)
{
  return GEAcompile (pattern, size, RE_SYNTAX_POSIX_EGREP);
}
#endif /* !EGREP_PROGRAM */

EXECUTE_FCT(EGexecute)
{
  char const *buflim, *beg, *end, *match, *best_match, *mb_start;
  char eol = eolbyte;
  int backref, start, len, best_len;
  struct kwsmatch kwsm;
  size_t i, ret_val;
#ifdef MBS_SUPPORT
  if (MB_CUR_MAX > 1)
    {
      if (match_icase)
        {
          /* mbtolower adds a NUL byte at the end.  That will provide
	     space for the sentinel byte dfaexec may add.  */
          char *case_buf = mbtolower (buf, &size);
	  if (start_ptr)
	    start_ptr = case_buf + (start_ptr - buf);
          buf = case_buf;
        }
    }
#endif /* MBS_SUPPORT */

  mb_start = buf;
  buflim = buf + size;

  for (beg = end = buf; end < buflim; beg = end)
    {
      if (!start_ptr)
	{
	  /* We don't care about an exact match.  */
	  if (kwset)
	    {
	      /* Find a possible match using the KWset matcher. */
	      size_t offset = kwsexec (kwset, beg, buflim - beg, &kwsm);
	      if (offset == (size_t) -1)
		goto failure;
	      beg += offset;
	      /* Narrow down to the line containing the candidate, and
		 run it through DFA. */
	      if ((end = memchr(beg, eol, buflim - beg)) != NULL)
	        end++;
              else
                end = buflim;
	      match = beg;
	      while (beg > buf && beg[-1] != eol)
		--beg;
	      if (kwsm.index < kwset_exact_matches)
                {
#ifdef MBS_SUPPORT
                  if (mb_start < beg)
                    mb_start = beg;
                  if (MB_CUR_MAX == 1 || !is_mb_middle (&mb_start, match, buflim))
#endif
                    goto success;
                }
	      if (dfaexec (&dfa, beg, (char *) end, 0, NULL, &backref) == NULL)
		continue;
	    }
	  else
	    {
	      /* No good fixed strings; start with DFA. */
	      char const *next_beg = dfaexec (&dfa, beg, (char *) buflim,
					      0, NULL, &backref);
	      if (next_beg == NULL)
		break;
	      /* Narrow down to the line we've found. */
	      beg = next_beg;
	      if ((end = memchr(beg, eol, buflim - beg)) != NULL)
	        end++;
              else
                end = buflim;
	      while (beg > buf && beg[-1] != eol)
		--beg;
	    }
	  /* Successful, no backreferences encountered! */
	  if (!backref)
	    goto success;
	}
      else
	{
	  /* We are looking for the leftmost (then longest) exact match.
	     We will go through the outer loop only once.  */
	  beg = start_ptr;
	  end = buflim;
	}

      /* If we've made it to this point, this means DFA has seen
	 a probable match, and we need to run it through Regex. */
      best_match = end;
      best_len = 0;
      for (i = 0; i < pcount; i++)
	{
	  patterns[i].regexbuf.not_eol = 0;
	  if (0 <= (start = re_search (&(patterns[i].regexbuf),
				       buf, end - buf - 1,
				       beg - buf, end - beg - 1,
				       &(patterns[i].regs))))
	    {
	      len = patterns[i].regs.end[0] - start;
	      match = buf + start;
	      if (match > best_match)
		continue;
	      if (start_ptr && !match_words)
		goto assess_pattern_match;
	      if ((!match_lines && !match_words)
		  || (match_lines && len == end - beg - 1))
		{
		  match = beg;
		  len = end - beg;
		  goto assess_pattern_match;
		}
	      /* If -w, check if the match aligns with word boundaries.
		 We do this iteratively because:
		 (a) the line may contain more than one occurence of the
		 pattern, and
		 (b) Several alternatives in the pattern might be valid at a
		 given point, and we may need to consider a shorter one to
		 find a word boundary.  */
	      if (match_words)
		while (match <= best_match)
		  {
		    if ((match == buf || !WCHAR ((unsigned char) match[-1]))
			&& (len == end - beg - 1
			    || !WCHAR ((unsigned char) match[len])))
		      goto assess_pattern_match;
		    if (len > 0)
		      {
			/* Try a shorter length anchored at the same place. */
			--len;
			patterns[i].regexbuf.not_eol = 1;
			len = re_match (&(patterns[i].regexbuf),
					buf, match + len - beg, match - buf,
					&(patterns[i].regs));
		      }
		    if (len <= 0)
		      {
			/* Try looking further on. */
			if (match == end - 1)
			  break;
			match++;
			patterns[i].regexbuf.not_eol = 0;
			start = re_search (&(patterns[i].regexbuf),
					   buf, end - buf - 1,
					   match - buf, end - match - 1,
					   &(patterns[i].regs));
			if (start < 0)
			  break;
			len = patterns[i].regs.end[0] - start;
			match = buf + start;
		      }
		  } /* while (match <= best_match) */
	      continue;
	    assess_pattern_match:
	      if (!start_ptr)
		{
		  /* Good enough for a non-exact match.
		     No need to look at further patterns, if any.  */
		  beg = match;
		  goto success_in_len;
		}
	      if (match < best_match || (match == best_match && len > best_len))
		{
		  /* Best exact match:  leftmost, then longest.  */
		  best_match = match;
		  best_len = len;
		}
	    } /* if re_search >= 0 */
	} /* for Regex patterns.  */
	if (best_match < end)
	  {
	    /* We have found an exact match.  We were just
	       waiting for the best one (leftmost then longest).  */
	    beg = best_match;
	    len = best_len;
	    goto success_in_len;
	  }
    } /* for (beg = end ..) */

 failure:
  ret_val = -1;
  goto out;

 success:
  len = end - beg;
 success_in_len:
  *match_size = len;
  ret_val = beg - buf;
 out:
  return ret_val;
}
#endif /* defined(GREP_PROGRAM) || defined(EGREP_PROGRAM) */

#if defined(GREP_PROGRAM) || defined(FGREP_PROGRAM)
COMPILE_FCT(Fcompile)
{
  char const *beg, *end, *lim, *err, *pat;
  size_t psize;

  kwsinit ();
  psize = size;
  if (match_icase && MB_CUR_MAX > 1)
    pat = mbtolower (pattern, &psize);
  else
    pat = pattern;

  beg = pat;
  do
    {
      for (lim = beg;; ++lim)
	{
	  end = lim;
	  
//Patch 0:
if ((lim >= pat + psize) && !(__is_neg(10, &(lim), sizeof (lim), &(pat), sizeof (pat), &(psize), sizeof (psize), &(end), sizeof (end), &(beg), sizeof (beg), &(pattern), sizeof (pattern), &(match_icase), sizeof (match_icase), &(size), sizeof (size), &(err), sizeof (err), &(kwset), sizeof (kwset))))
    break;

//CodeSeg 1:
	 if (*lim == '\n')
	   {
	     lim++;
	     break;
	   }
#if HAVE_DOS_FILE_CONTENTS
	 if (*lim == '\r' && lim + 1 < pat + psize && lim[1] == '\n')
	   {
	     lim += 2;
	     break;
	   }
#endif
	}

      if ((err = kwsincr (kwset, beg, end - beg)) != NULL)
	error (EXIT_TROUBLE, 0, "%s", err);
      beg = lim;
    }
  while (beg < pat + psize);

  if ((err = kwsprep (kwset)) != NULL)
    error (EXIT_TROUBLE, 0, "%s", err);
}

EXECUTE_FCT(Fexecute)
{
  char const *beg, *try, *end, *mb_start;
  size_t len;
  char eol = eolbyte;
  struct kwsmatch kwsmatch;
  size_t ret_val;
#ifdef MBS_SUPPORT
  if (MB_CUR_MAX > 1)
    {
      if (match_icase)
        {
          char *case_buf = mbtolower (buf, &size);
	  if (start_ptr)
	    start_ptr = case_buf + (start_ptr - buf);
          buf = case_buf;
        }
    }
#endif /* MBS_SUPPORT */

  for (mb_start = beg = start_ptr ? start_ptr : buf; beg <= buf + size; beg++)
    {
      size_t offset = kwsexec (kwset, beg, buf + size - beg, &kwsmatch);
      if (offset == (size_t) -1)
	goto failure;
#ifdef MBS_SUPPORT
      if (MB_CUR_MAX > 1 && is_mb_middle (&mb_start, beg + offset, buf + size))
        {
          beg = mb_start - 1;
          continue; /* It is a part of multibyte character.  */
        }
#endif /* MBS_SUPPORT */
      beg += offset;
      len = kwsmatch.size[0];
      if (start_ptr && !match_words)
	goto success_in_beg_and_len;
      if (match_lines)
	{
	  if (beg > buf && beg[-1] != eol)
	    continue;
	  if (beg + len < buf + size && beg[len] != eol)
	    continue;
	  goto success;
	}
      else if (match_words)
	for (try = beg; len; )
	  {
	    if (try > buf && WCHAR((unsigned char) try[-1]))
	      break;
	    if (try + len < buf + size && WCHAR((unsigned char) try[len]))
	      {
		offset = kwsexec (kwset, beg, --len, &kwsmatch);
		if (offset == (size_t) -1)
		  break;
		try = beg + offset;
		len = kwsmatch.size[0];
	      }
	    else if (!start_ptr)
	      goto success;
	    else
	      goto success_in_beg_and_len;
	  } /* for (try) */
      else
	goto success;
    } /* for (beg in buf) */

 failure:
  ret_val = -1;
  goto out;

 success:
  if ((end = memchr (beg + len, eol, (buf + size) - (beg + len))) != NULL)
    end++;
  else
    end = buf + size;
  while (buf < beg && beg[-1] != eol)
    --beg;
  len = end - beg;
 success_in_beg_and_len:
  *match_size = len;
  ret_val = beg - buf;
 out:
  return ret_val;
}
#endif /* defined(GREP_PROGRAM) || defined(FGREP_PROGRAM) */

#ifdef GREP_PROGRAM
#if HAVE_LIBPCRE
/* Compiled internal form of a Perl regular expression.  */
static pcre *cre;

/* Additional information about the pattern.  */
static pcre_extra *extra;
#endif

COMPILE_FCT(Pcompile)
{
#if !HAVE_LIBPCRE
  error (EXIT_TROUBLE, 0, "%s",
	 _("support for the -P option is not compiled into "
	   "this --disable-perl-regexp binary"));
#else
  int e;
  char const *ep;
  char *re = xmalloc (4 * size + 7);
  int flags = PCRE_MULTILINE | (match_icase ? PCRE_CASELESS : 0);
  char const *patlim = pattern + size;
  char *n = re;
  char const *p;
  char const *pnul;

  /* FIXME: Remove these restrictions.  */
  if (memchr(pattern, '\n', size))
    error (EXIT_TROUBLE, 0, _("the -P option only supports a single pattern"));

  *n = '\0';
  if (match_lines)
    strcpy (n, "^(");
  if (match_words)
    strcpy (n, "\\b(");
  n += strlen (n);

  /* The PCRE interface doesn't allow NUL bytes in the pattern, so
     replace each NUL byte in the pattern with the four characters
     "\000", removing a preceding backslash if there are an odd
     number of backslashes before the NUL.

     FIXME: This method does not work with some multibyte character
     encodings, notably Shift-JIS, where a multibyte character can end
     in a backslash byte.  */
  for (p = pattern; (pnul = memchr (p, '\0', patlim - p)); p = pnul + 1)
    {
      memcpy (n, p, pnul - p);
      n += pnul - p;
      for (p = pnul; pattern < p && p[-1] == '\\'; p--)
	continue;
      n -= (pnul - p) & 1;
      strcpy (n, "\\000");
      n += 4;
    }

  memcpy (n, p, patlim - p);
  n += patlim - p;
  *n = '\0';
  if (match_words)
    strcpy (n, ")\\b");
  if (match_lines)
    strcpy (n, ")$");

  cre = pcre_compile (re, flags, &ep, &e, pcre_maketables ());
  if (!cre)
    error (EXIT_TROUBLE, 0, "%s", ep);

  extra = pcre_study (cre, 0, &ep);
  if (ep)
    error (EXIT_TROUBLE, 0, "%s", ep);

  free (re);
#endif
}

EXECUTE_FCT(Pexecute)
{
#if !HAVE_LIBPCRE
  abort ();
  return -1;
#else
  /* This array must have at least two elements; everything after that
     is just for performance improvement in pcre_exec.  */
  int sub[300];

  const char *line_buf, *line_end, *line_next;
  int e = PCRE_ERROR_NOMATCH;
  ptrdiff_t start_ofs = start_ptr ? start_ptr - buf : 0;

  /* PCRE can't limit the matching to single lines, therefore we have to
     match each line in the buffer separately.  */
  for (line_next = buf;
       e == PCRE_ERROR_NOMATCH && line_next < buf + size;
       start_ofs -= line_next - line_buf)
    {
      line_buf = line_next;
      line_end = memchr (line_buf, eolbyte, (buf + size) - line_buf);
      if (line_end == NULL)
        line_next = line_end = buf + size;
      else
        line_next = line_end + 1;

      if (start_ptr && start_ptr >= line_end)
        continue;

      e = pcre_exec (cre, extra, line_buf, line_end - line_buf,
                     start_ofs < 0 ? 0 : start_ofs, 0,
                     sub, sizeof sub / sizeof *sub);
    }

  if (e <= 0)
    {
      switch (e)
	{
	case PCRE_ERROR_NOMATCH:
	  return -1;

	case PCRE_ERROR_NOMEMORY:
	  error (EXIT_TROUBLE, 0, _("memory exhausted"));

	default:
	  abort ();
	}
    }
  else
    {
      /* Narrow down to the line we've found.  */
      char const *beg = line_buf + sub[0];
      char const *end = line_buf + sub[1];
      char const *buflim = buf + size;
      char eol = eolbyte;
      if (!start_ptr)
	{
	  /* FIXME: The case when '\n' is not found indicates a bug:
	     Since grep is line oriented, the match should never contain
	     a newline, so there _must_ be a newline following.
	   */
	  if (!(end = memchr (end, eol, buflim - end)))
	    end = buflim;
	  else
	    end++;
	  while (buf < beg && beg[-1] != eol)
	    --beg;
	}

      *match_size = end - beg;
      return beg - buf;
    }
#endif
}

struct matcher const matchers[] = {
  { "default", Gcompile, EGexecute },
  { "grep",    Gcompile, EGexecute },
  { "egrep",   Ecompile, EGexecute },
  { "awk",     Acompile, EGexecute },
  { "fgrep",   Fcompile, Fexecute },
  { "perl",    Pcompile, Pexecute },
  { "", 0, 0 },
};
#endif /* GREP_PROGRAM */

Spawn 1 instances, now Total 18
Counter: 19
Batcher Size:18
Preprocess the following candidate with CondTester:
Priority 20000
At location src/search.c:589
--Src File: src/search.c
Fragment 0:
if ((*lim == '\n') && !(__abst_hole(lim, pat, psize, end, beg, pattern, match_icase, size, err, kwset))) {
    lim++;
    break;
}


CondTester, a patch instance with id 18:
//src_file:src/search.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
/* search.c - searching subroutines using dfa, kwset and regex for grep.
   Copyright 1992, 1998, 2000, 2007, 2009-2010 Free Software Foundation, Inc.

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 3, or (at your option)
   any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program; if not, write to the Free Software
   Foundation, Inc., 51 Franklin Street - Fifth Floor, Boston, MA
   02110-1301, USA.  */

/* Written August 1992 by Mike Haertel. */

#include <config.h>

#include <sys/types.h>

#include "mbsupport.h"
#ifdef MBS_SUPPORT
/* We can handle multibyte strings. */
# include <wchar.h>
# include <wctype.h>
#endif

#include "system.h"
#include "grep.h"
#ifndef FGREP_PROGRAM
# include <regex.h>
# include "dfa.h"
#endif
#include "kwset.h"
#include "error.h"
#include "xalloc.h"
#ifdef HAVE_LIBPCRE
# include <pcre.h>
#endif

#define NCHAR (UCHAR_MAX + 1)

/* For -w, we also consider _ to be word constituent.  */
#define WCHAR(C) (ISALNUM(C) || (C) == '_')

/* KWset compiled pattern.  For Ecompile and Gcompile, we compile
   a list of strings, at least one of which is known to occur in
   any string matching the regexp. */
static kwset_t kwset;

static void
kwsinit (void)
{
  static char trans[NCHAR];
  int i;

  if (match_icase && MB_CUR_MAX == 1)
    {
      for (i = 0; i < NCHAR; ++i)
        trans[i] = TOLOWER (i);

      kwset = kwsalloc (trans);
    }
  else
    kwset = kwsalloc (NULL);

  if (!kwset)
    xalloc_die ();
}

#ifdef MBS_SUPPORT
/* Convert the *N-byte string, BEG, to lowercase, and write the
   NUL-terminated result into malloc'd storage.  Upon success, set *N
   to the length (in bytes) of the resulting string (not including the
   trailing NUL byte), and return a pointer to the lowercase string.
   Upon memory allocation failure, this function exits.

   Note that while this function returns a pointer to malloc'd storage,
   the caller must not free it, since this function retains a pointer
   to the buffer and reuses it on any subsequent call.  As a consequence,
   this function is not thread-safe.  */
static char *
mbtolower (const char *beg, size_t *n)
{
  static char *out;
  static size_t outalloc;
  size_t outlen, mb_cur_max;
  mbstate_t is, os;
  const char *end;
  char *p;

  if (*n > outalloc)
    {
      out = xrealloc (out, *n);
      outalloc = *n;
    }

  memset (&is, 0, sizeof (is));
  memset (&os, 0, sizeof (os));
  end = beg + *n;

  mb_cur_max = MB_CUR_MAX;
  p = out;
  outlen = 0;
  while (beg < end)
    {
      wchar_t wc;
      size_t mbclen = mbrtowc(&wc, beg, end - beg, &is);
      if (outlen + mb_cur_max >= outalloc)
        {
          out = x2nrealloc (out, &outalloc, 1);
          p = out + outlen;
        }

      if (mbclen == (size_t) -1 || mbclen == (size_t) -2 || mbclen == 0)
        {
          /* An invalid sequence, or a truncated multi-octet character.
             We treat it as a single-octet character.  */
          *p++ = *beg++;
          outlen++;
          memset (&is, 0, sizeof (is));
          memset (&os, 0, sizeof (os));
        }
      else
        {
          beg += mbclen;
          mbclen = wcrtomb (p, towlower ((wint_t) wc), &os);
          p += mbclen;
          outlen += mbclen;
        }
    }

  *n = p - out;
  *p++ = 0;
  return out;
}
#endif


#ifndef FGREP_PROGRAM
/* DFA compiled regexp. */
static struct dfa dfa;

/* The Regex compiled patterns.  */
static struct patterns
{
  /* Regex compiled regexp. */
  struct re_pattern_buffer regexbuf;
  struct re_registers regs; /* This is here on account of a BRAIN-DEAD
			       Q@#%!# library interface in regex.c.  */
} patterns0;

struct patterns *patterns;
size_t pcount;

void
dfaerror (char const *mesg)
{
  error (EXIT_TROUBLE, 0, "%s", mesg);
}

/* Number of compiled fixed strings known to exactly match the regexp.
   If kwsexec returns < kwset_exact_matches, then we don't need to
   call the regexp matcher at all. */
static int kwset_exact_matches;

static char const *
kwsincr_case (const char *must)
{
  const char *buf;
  size_t n;

  n = strlen (must);
#ifdef MBS_SUPPORT
  if (match_icase && MB_CUR_MAX > 1)
    buf = mbtolower (must, &n);
  else
#endif
    buf = must;
  return kwsincr (kwset, buf, n);
}

/* If the DFA turns out to have some set of fixed strings one of
   which must occur in the match, then we build a kwset matcher
   to find those strings, and thus quickly filter out impossible
   matches. */
static void
kwsmusts (void)
{
  struct dfamust const *dm;
  char const *err;

  if (dfa.musts)
    {
      kwsinit ();
      /* First, we compile in the substrings known to be exact
	 matches.  The kwset matcher will return the index
	 of the matching string that it chooses. */
      for (dm = dfa.musts; dm; dm = dm->next)
	{
	  if (!dm->exact)
	    continue;
	  ++kwset_exact_matches;
	  if ((err = kwsincr_case (dm->must)) != NULL)
	    error (EXIT_TROUBLE, 0, "%s", err);
	}
      /* Now, we compile the substrings that will require
	 the use of the regexp matcher.  */
      for (dm = dfa.musts; dm; dm = dm->next)
	{
	  if (dm->exact)
	    continue;
	  if ((err = kwsincr_case (dm->must)) != NULL)
	    error (EXIT_TROUBLE, 0, "%s", err);
	}
      if ((err = kwsprep (kwset)) != NULL)
	error (EXIT_TROUBLE, 0, "%s", err);
    }
}
#endif /* !FGREP_PROGRAM */

#ifdef MBS_SUPPORT

static bool
is_mb_middle(const char **good, const char *buf, const char *end)
{
  const char *p = *good;
  const char *prev = p;
  mbstate_t cur_state;

  /* TODO: can be optimized for UTF-8.  */
  memset(&cur_state, 0, sizeof(mbstate_t));
  while (p < buf)
    {
      size_t mbclen = mbrlen(p, end - p, &cur_state);

      /* Store the beginning of the previous complete multibyte character.  */
      if (mbclen != (size_t) -2)
        prev = p;

      if (mbclen == (size_t) -1 || mbclen == (size_t) -2 || mbclen == 0)
	{
	  /* An invalid sequence, or a truncated multibyte character.
	     We treat it as a single byte character.  */
	  mbclen = 1;
	}
      p += mbclen;
    }

  *good = prev;
  return p > buf;
}
#endif /* MBS_SUPPORT */

#if defined(GREP_PROGRAM) || defined(EGREP_PROGRAM)
#ifdef EGREP_PROGRAM
COMPILE_FCT(Ecompile)
{
  reg_syntax_t syntax_bits = RE_SYNTAX_POSIX_EGREP;
#else
/* No __VA_ARGS__ in C89.  So we have to do it this way.  */
static COMPILE_RET
GEAcompile (char const *pattern, size_t size, reg_syntax_t syntax_bits)
{
#endif /* EGREP_PROGRAM */
  const char *err;
  const char *p, *sep;
  size_t total = size;
  char *motif;

  if (match_icase)
    syntax_bits |= RE_ICASE;
  re_set_syntax (syntax_bits);
  dfasyntax (syntax_bits, match_icase, eolbyte);

  /* For GNU regex compiler we have to pass the patterns separately to detect
     errors like "[\nallo\n]\n".  The patterns here are "[", "allo" and "]"
     GNU regex should have raise a syntax error.  The same for backref, where
     the backref should have been local to each pattern.  */
  p = pattern;
  do
    {
      size_t len;
      sep = memchr (p, '\n', total);
      if (sep)
	{
	  len = sep - p;
	  sep++;
	  total -= (len + 1);
	}
      else
	{
	  len = total;
	  total = 0;
	}

      patterns = realloc (patterns, (pcount + 1) * sizeof (*patterns));
      if (patterns == NULL)
	error (EXIT_TROUBLE, errno, _("memory exhausted"));
      patterns[pcount] = patterns0;

      if ((err = re_compile_pattern (p, len,
				    &(patterns[pcount].regexbuf))) != NULL)
	error (EXIT_TROUBLE, 0, "%s", err);
      pcount++;

      p = sep;
    } while (sep && total != 0);

  /* In the match_words and match_lines cases, we use a different pattern
     for the DFA matcher that will quickly throw out cases that won't work.
     Then if DFA succeeds we do some hairy stuff using the regex matcher
     to decide whether the match should really count. */
  if (match_words || match_lines)
    {
      static char const line_beg_no_bk[] = "^(";
      static char const line_end_no_bk[] = ")$";
      static char const word_beg_no_bk[] = "(^|[^[:alnum:]_])(";
      static char const word_end_no_bk[] = ")([^[:alnum:]_]|$)";
#ifdef EGREP_PROGRAM
# define IF_BK(x, y) (y)
      char *n = xmalloc (sizeof word_beg_no_bk - 1 + size + sizeof word_end_no_bk);
#else
      static char const line_beg_bk[] = "^\\(";
      static char const line_end_bk[] = "\\)$";
      static char const word_beg_bk[] = "\\(^\\|[^[:alnum:]_]\\)\\(";
      static char const word_end_bk[] = "\\)\\([^[:alnum:]_]\\|$\\)";
      int bk = !(syntax_bits & RE_NO_BK_PARENS);
# define IF_BK(x, y) ((bk) ? (x) : (y))
      char *n = xmalloc (sizeof word_beg_bk - 1 + size + sizeof word_end_bk);
#endif /* EGREP_PROGRAM */

      strcpy (n, match_lines ? IF_BK(line_beg_bk, line_beg_no_bk)
			     : IF_BK(word_beg_bk, word_beg_no_bk));
      total = strlen(n);
      memcpy (n + total, pattern, size);
      total += size;
      strcpy (n + total, match_lines ? IF_BK(line_end_bk, line_end_no_bk)
				     : IF_BK(word_end_bk, word_end_no_bk));
      total += strlen (n + total);
      pattern = motif = n;
      size = total;
    }
  else
    motif = NULL;

  dfacomp (pattern, size, &dfa, 1);
  kwsmusts ();

  free(motif);
}

#ifndef EGREP_PROGRAM
COMPILE_FCT(Gcompile)
{
  return GEAcompile (pattern, size,
		     RE_SYNTAX_GREP | RE_HAT_LISTS_NOT_NEWLINE);
}

COMPILE_FCT(Acompile)
{
  return GEAcompile (pattern, size, RE_SYNTAX_AWK);
}

COMPILE_FCT(Ecompile)
{
  return GEAcompile (pattern, size, RE_SYNTAX_POSIX_EGREP);
}
#endif /* !EGREP_PROGRAM */

EXECUTE_FCT(EGexecute)
{
  char const *buflim, *beg, *end, *match, *best_match, *mb_start;
  char eol = eolbyte;
  int backref, start, len, best_len;
  struct kwsmatch kwsm;
  size_t i, ret_val;
#ifdef MBS_SUPPORT
  if (MB_CUR_MAX > 1)
    {
      if (match_icase)
        {
          /* mbtolower adds a NUL byte at the end.  That will provide
	     space for the sentinel byte dfaexec may add.  */
          char *case_buf = mbtolower (buf, &size);
	  if (start_ptr)
	    start_ptr = case_buf + (start_ptr - buf);
          buf = case_buf;
        }
    }
#endif /* MBS_SUPPORT */

  mb_start = buf;
  buflim = buf + size;

  for (beg = end = buf; end < buflim; beg = end)
    {
      if (!start_ptr)
	{
	  /* We don't care about an exact match.  */
	  if (kwset)
	    {
	      /* Find a possible match using the KWset matcher. */
	      size_t offset = kwsexec (kwset, beg, buflim - beg, &kwsm);
	      if (offset == (size_t) -1)
		goto failure;
	      beg += offset;
	      /* Narrow down to the line containing the candidate, and
		 run it through DFA. */
	      if ((end = memchr(beg, eol, buflim - beg)) != NULL)
	        end++;
              else
                end = buflim;
	      match = beg;
	      while (beg > buf && beg[-1] != eol)
		--beg;
	      if (kwsm.index < kwset_exact_matches)
                {
#ifdef MBS_SUPPORT
                  if (mb_start < beg)
                    mb_start = beg;
                  if (MB_CUR_MAX == 1 || !is_mb_middle (&mb_start, match, buflim))
#endif
                    goto success;
                }
	      if (dfaexec (&dfa, beg, (char *) end, 0, NULL, &backref) == NULL)
		continue;
	    }
	  else
	    {
	      /* No good fixed strings; start with DFA. */
	      char const *next_beg = dfaexec (&dfa, beg, (char *) buflim,
					      0, NULL, &backref);
	      if (next_beg == NULL)
		break;
	      /* Narrow down to the line we've found. */
	      beg = next_beg;
	      if ((end = memchr(beg, eol, buflim - beg)) != NULL)
	        end++;
              else
                end = buflim;
	      while (beg > buf && beg[-1] != eol)
		--beg;
	    }
	  /* Successful, no backreferences encountered! */
	  if (!backref)
	    goto success;
	}
      else
	{
	  /* We are looking for the leftmost (then longest) exact match.
	     We will go through the outer loop only once.  */
	  beg = start_ptr;
	  end = buflim;
	}

      /* If we've made it to this point, this means DFA has seen
	 a probable match, and we need to run it through Regex. */
      best_match = end;
      best_len = 0;
      for (i = 0; i < pcount; i++)
	{
	  patterns[i].regexbuf.not_eol = 0;
	  if (0 <= (start = re_search (&(patterns[i].regexbuf),
				       buf, end - buf - 1,
				       beg - buf, end - beg - 1,
				       &(patterns[i].regs))))
	    {
	      len = patterns[i].regs.end[0] - start;
	      match = buf + start;
	      if (match > best_match)
		continue;
	      if (start_ptr && !match_words)
		goto assess_pattern_match;
	      if ((!match_lines && !match_words)
		  || (match_lines && len == end - beg - 1))
		{
		  match = beg;
		  len = end - beg;
		  goto assess_pattern_match;
		}
	      /* If -w, check if the match aligns with word boundaries.
		 We do this iteratively because:
		 (a) the line may contain more than one occurence of the
		 pattern, and
		 (b) Several alternatives in the pattern might be valid at a
		 given point, and we may need to consider a shorter one to
		 find a word boundary.  */
	      if (match_words)
		while (match <= best_match)
		  {
		    if ((match == buf || !WCHAR ((unsigned char) match[-1]))
			&& (len == end - beg - 1
			    || !WCHAR ((unsigned char) match[len])))
		      goto assess_pattern_match;
		    if (len > 0)
		      {
			/* Try a shorter length anchored at the same place. */
			--len;
			patterns[i].regexbuf.not_eol = 1;
			len = re_match (&(patterns[i].regexbuf),
					buf, match + len - beg, match - buf,
					&(patterns[i].regs));
		      }
		    if (len <= 0)
		      {
			/* Try looking further on. */
			if (match == end - 1)
			  break;
			match++;
			patterns[i].regexbuf.not_eol = 0;
			start = re_search (&(patterns[i].regexbuf),
					   buf, end - buf - 1,
					   match - buf, end - match - 1,
					   &(patterns[i].regs));
			if (start < 0)
			  break;
			len = patterns[i].regs.end[0] - start;
			match = buf + start;
		      }
		  } /* while (match <= best_match) */
	      continue;
	    assess_pattern_match:
	      if (!start_ptr)
		{
		  /* Good enough for a non-exact match.
		     No need to look at further patterns, if any.  */
		  beg = match;
		  goto success_in_len;
		}
	      if (match < best_match || (match == best_match && len > best_len))
		{
		  /* Best exact match:  leftmost, then longest.  */
		  best_match = match;
		  best_len = len;
		}
	    } /* if re_search >= 0 */
	} /* for Regex patterns.  */
	if (best_match < end)
	  {
	    /* We have found an exact match.  We were just
	       waiting for the best one (leftmost then longest).  */
	    beg = best_match;
	    len = best_len;
	    goto success_in_len;
	  }
    } /* for (beg = end ..) */

 failure:
  ret_val = -1;
  goto out;

 success:
  len = end - beg;
 success_in_len:
  *match_size = len;
  ret_val = beg - buf;
 out:
  return ret_val;
}
#endif /* defined(GREP_PROGRAM) || defined(EGREP_PROGRAM) */

#if defined(GREP_PROGRAM) || defined(FGREP_PROGRAM)
COMPILE_FCT(Fcompile)
{
  char const *beg, *end, *lim, *err, *pat;
  size_t psize;

  kwsinit ();
  psize = size;
  if (match_icase && MB_CUR_MAX > 1)
    pat = mbtolower (pattern, &psize);
  else
    pat = pattern;

  beg = pat;
  do
    {
      for (lim = beg;; ++lim)
	{
	  end = lim;
	  if (lim >= pat + psize)
	    break;
	 
//Patch 0:
if ((*lim == '\n') && !(__is_neg(10, &(lim), sizeof (lim), &(pat), sizeof (pat), &(psize), sizeof (psize), &(end), sizeof (end), &(beg), sizeof (beg), &(pattern), sizeof (pattern), &(match_icase), sizeof (match_icase), &(size), sizeof (size), &(err), sizeof (err), &(kwset), sizeof (kwset)))) {
    lim++;
    break;
}

//CodeSeg 1:
#if HAVE_DOS_FILE_CONTENTS
	 if (*lim == '\r' && lim + 1 < pat + psize && lim[1] == '\n')
	   {
	     lim += 2;
	     break;
	   }
#endif
	}

      if ((err = kwsincr (kwset, beg, end - beg)) != NULL)
	error (EXIT_TROUBLE, 0, "%s", err);
      beg = lim;
    }
  while (beg < pat + psize);

  if ((err = kwsprep (kwset)) != NULL)
    error (EXIT_TROUBLE, 0, "%s", err);
}

EXECUTE_FCT(Fexecute)
{
  char const *beg, *try, *end, *mb_start;
  size_t len;
  char eol = eolbyte;
  struct kwsmatch kwsmatch;
  size_t ret_val;
#ifdef MBS_SUPPORT
  if (MB_CUR_MAX > 1)
    {
      if (match_icase)
        {
          char *case_buf = mbtolower (buf, &size);
	  if (start_ptr)
	    start_ptr = case_buf + (start_ptr - buf);
          buf = case_buf;
        }
    }
#endif /* MBS_SUPPORT */

  for (mb_start = beg = start_ptr ? start_ptr : buf; beg <= buf + size; beg++)
    {
      size_t offset = kwsexec (kwset, beg, buf + size - beg, &kwsmatch);
      if (offset == (size_t) -1)
	goto failure;
#ifdef MBS_SUPPORT
      if (MB_CUR_MAX > 1 && is_mb_middle (&mb_start, beg + offset, buf + size))
        {
          beg = mb_start - 1;
          continue; /* It is a part of multibyte character.  */
        }
#endif /* MBS_SUPPORT */
      beg += offset;
      len = kwsmatch.size[0];
      if (start_ptr && !match_words)
	goto success_in_beg_and_len;
      if (match_lines)
	{
	  if (beg > buf && beg[-1] != eol)
	    continue;
	  if (beg + len < buf + size && beg[len] != eol)
	    continue;
	  goto success;
	}
      else if (match_words)
	for (try = beg; len; )
	  {
	    if (try > buf && WCHAR((unsigned char) try[-1]))
	      break;
	    if (try + len < buf + size && WCHAR((unsigned char) try[len]))
	      {
		offset = kwsexec (kwset, beg, --len, &kwsmatch);
		if (offset == (size_t) -1)
		  break;
		try = beg + offset;
		len = kwsmatch.size[0];
	      }
	    else if (!start_ptr)
	      goto success;
	    else
	      goto success_in_beg_and_len;
	  } /* for (try) */
      else
	goto success;
    } /* for (beg in buf) */

 failure:
  ret_val = -1;
  goto out;

 success:
  if ((end = memchr (beg + len, eol, (buf + size) - (beg + len))) != NULL)
    end++;
  else
    end = buf + size;
  while (buf < beg && beg[-1] != eol)
    --beg;
  len = end - beg;
 success_in_beg_and_len:
  *match_size = len;
  ret_val = beg - buf;
 out:
  return ret_val;
}
#endif /* defined(GREP_PROGRAM) || defined(FGREP_PROGRAM) */

#ifdef GREP_PROGRAM
#if HAVE_LIBPCRE
/* Compiled internal form of a Perl regular expression.  */
static pcre *cre;

/* Additional information about the pattern.  */
static pcre_extra *extra;
#endif

COMPILE_FCT(Pcompile)
{
#if !HAVE_LIBPCRE
  error (EXIT_TROUBLE, 0, "%s",
	 _("support for the -P option is not compiled into "
	   "this --disable-perl-regexp binary"));
#else
  int e;
  char const *ep;
  char *re = xmalloc (4 * size + 7);
  int flags = PCRE_MULTILINE | (match_icase ? PCRE_CASELESS : 0);
  char const *patlim = pattern + size;
  char *n = re;
  char const *p;
  char const *pnul;

  /* FIXME: Remove these restrictions.  */
  if (memchr(pattern, '\n', size))
    error (EXIT_TROUBLE, 0, _("the -P option only supports a single pattern"));

  *n = '\0';
  if (match_lines)
    strcpy (n, "^(");
  if (match_words)
    strcpy (n, "\\b(");
  n += strlen (n);

  /* The PCRE interface doesn't allow NUL bytes in the pattern, so
     replace each NUL byte in the pattern with the four characters
     "\000", removing a preceding backslash if there are an odd
     number of backslashes before the NUL.

     FIXME: This method does not work with some multibyte character
     encodings, notably Shift-JIS, where a multibyte character can end
     in a backslash byte.  */
  for (p = pattern; (pnul = memchr (p, '\0', patlim - p)); p = pnul + 1)
    {
      memcpy (n, p, pnul - p);
      n += pnul - p;
      for (p = pnul; pattern < p && p[-1] == '\\'; p--)
	continue;
      n -= (pnul - p) & 1;
      strcpy (n, "\\000");
      n += 4;
    }

  memcpy (n, p, patlim - p);
  n += patlim - p;
  *n = '\0';
  if (match_words)
    strcpy (n, ")\\b");
  if (match_lines)
    strcpy (n, ")$");

  cre = pcre_compile (re, flags, &ep, &e, pcre_maketables ());
  if (!cre)
    error (EXIT_TROUBLE, 0, "%s", ep);

  extra = pcre_study (cre, 0, &ep);
  if (ep)
    error (EXIT_TROUBLE, 0, "%s", ep);

  free (re);
#endif
}

EXECUTE_FCT(Pexecute)
{
#if !HAVE_LIBPCRE
  abort ();
  return -1;
#else
  /* This array must have at least two elements; everything after that
     is just for performance improvement in pcre_exec.  */
  int sub[300];

  const char *line_buf, *line_end, *line_next;
  int e = PCRE_ERROR_NOMATCH;
  ptrdiff_t start_ofs = start_ptr ? start_ptr - buf : 0;

  /* PCRE can't limit the matching to single lines, therefore we have to
     match each line in the buffer separately.  */
  for (line_next = buf;
       e == PCRE_ERROR_NOMATCH && line_next < buf + size;
       start_ofs -= line_next - line_buf)
    {
      line_buf = line_next;
      line_end = memchr (line_buf, eolbyte, (buf + size) - line_buf);
      if (line_end == NULL)
        line_next = line_end = buf + size;
      else
        line_next = line_end + 1;

      if (start_ptr && start_ptr >= line_end)
        continue;

      e = pcre_exec (cre, extra, line_buf, line_end - line_buf,
                     start_ofs < 0 ? 0 : start_ofs, 0,
                     sub, sizeof sub / sizeof *sub);
    }

  if (e <= 0)
    {
      switch (e)
	{
	case PCRE_ERROR_NOMATCH:
	  return -1;

	case PCRE_ERROR_NOMEMORY:
	  error (EXIT_TROUBLE, 0, _("memory exhausted"));

	default:
	  abort ();
	}
    }
  else
    {
      /* Narrow down to the line we've found.  */
      char const *beg = line_buf + sub[0];
      char const *end = line_buf + sub[1];
      char const *buflim = buf + size;
      char eol = eolbyte;
      if (!start_ptr)
	{
	  /* FIXME: The case when '\n' is not found indicates a bug:
	     Since grep is line oriented, the match should never contain
	     a newline, so there _must_ be a newline following.
	   */
	  if (!(end = memchr (end, eol, buflim - end)))
	    end = buflim;
	  else
	    end++;
	  while (buf < beg && beg[-1] != eol)
	    --beg;
	}

      *match_size = end - beg;
      return beg - buf;
    }
#endif
}

struct matcher const matchers[] = {
  { "default", Gcompile, EGexecute },
  { "grep",    Gcompile, EGexecute },
  { "egrep",   Ecompile, EGexecute },
  { "awk",     Acompile, EGexecute },
  { "fgrep",   Fcompile, Fexecute },
  { "perl",    Pcompile, Pexecute },
  { "", 0, 0 },
};
#endif /* GREP_PROGRAM */

Spawn 1 instances, now Total 19
Counter: 20
Batcher Size:19
Preprocess the following candidate with CondTester:
Priority 20000
At location src/search.c:589
--Src File: src/search.c
Fragment 0:
if ((*lim == '\n') || (__abst_hole(lim, pat, psize, end, beg, pattern, match_icase, size, err, kwset))) {
    lim++;
    break;
}


CondTester, a patch instance with id 19:
//src_file:src/search.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
/* search.c - searching subroutines using dfa, kwset and regex for grep.
   Copyright 1992, 1998, 2000, 2007, 2009-2010 Free Software Foundation, Inc.

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 3, or (at your option)
   any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program; if not, write to the Free Software
   Foundation, Inc., 51 Franklin Street - Fifth Floor, Boston, MA
   02110-1301, USA.  */

/* Written August 1992 by Mike Haertel. */

#include <config.h>

#include <sys/types.h>

#include "mbsupport.h"
#ifdef MBS_SUPPORT
/* We can handle multibyte strings. */
# include <wchar.h>
# include <wctype.h>
#endif

#include "system.h"
#include "grep.h"
#ifndef FGREP_PROGRAM
# include <regex.h>
# include "dfa.h"
#endif
#include "kwset.h"
#include "error.h"
#include "xalloc.h"
#ifdef HAVE_LIBPCRE
# include <pcre.h>
#endif

#define NCHAR (UCHAR_MAX + 1)

/* For -w, we also consider _ to be word constituent.  */
#define WCHAR(C) (ISALNUM(C) || (C) == '_')

/* KWset compiled pattern.  For Ecompile and Gcompile, we compile
   a list of strings, at least one of which is known to occur in
   any string matching the regexp. */
static kwset_t kwset;

static void
kwsinit (void)
{
  static char trans[NCHAR];
  int i;

  if (match_icase && MB_CUR_MAX == 1)
    {
      for (i = 0; i < NCHAR; ++i)
        trans[i] = TOLOWER (i);

      kwset = kwsalloc (trans);
    }
  else
    kwset = kwsalloc (NULL);

  if (!kwset)
    xalloc_die ();
}

#ifdef MBS_SUPPORT
/* Convert the *N-byte string, BEG, to lowercase, and write the
   NUL-terminated result into malloc'd storage.  Upon success, set *N
   to the length (in bytes) of the resulting string (not including the
   trailing NUL byte), and return a pointer to the lowercase string.
   Upon memory allocation failure, this function exits.

   Note that while this function returns a pointer to malloc'd storage,
   the caller must not free it, since this function retains a pointer
   to the buffer and reuses it on any subsequent call.  As a consequence,
   this function is not thread-safe.  */
static char *
mbtolower (const char *beg, size_t *n)
{
  static char *out;
  static size_t outalloc;
  size_t outlen, mb_cur_max;
  mbstate_t is, os;
  const char *end;
  char *p;

  if (*n > outalloc)
    {
      out = xrealloc (out, *n);
      outalloc = *n;
    }

  memset (&is, 0, sizeof (is));
  memset (&os, 0, sizeof (os));
  end = beg + *n;

  mb_cur_max = MB_CUR_MAX;
  p = out;
  outlen = 0;
  while (beg < end)
    {
      wchar_t wc;
      size_t mbclen = mbrtowc(&wc, beg, end - beg, &is);
      if (outlen + mb_cur_max >= outalloc)
        {
          out = x2nrealloc (out, &outalloc, 1);
          p = out + outlen;
        }

      if (mbclen == (size_t) -1 || mbclen == (size_t) -2 || mbclen == 0)
        {
          /* An invalid sequence, or a truncated multi-octet character.
             We treat it as a single-octet character.  */
          *p++ = *beg++;
          outlen++;
          memset (&is, 0, sizeof (is));
          memset (&os, 0, sizeof (os));
        }
      else
        {
          beg += mbclen;
          mbclen = wcrtomb (p, towlower ((wint_t) wc), &os);
          p += mbclen;
          outlen += mbclen;
        }
    }

  *n = p - out;
  *p++ = 0;
  return out;
}
#endif


#ifndef FGREP_PROGRAM
/* DFA compiled regexp. */
static struct dfa dfa;

/* The Regex compiled patterns.  */
static struct patterns
{
  /* Regex compiled regexp. */
  struct re_pattern_buffer regexbuf;
  struct re_registers regs; /* This is here on account of a BRAIN-DEAD
			       Q@#%!# library interface in regex.c.  */
} patterns0;

struct patterns *patterns;
size_t pcount;

void
dfaerror (char const *mesg)
{
  error (EXIT_TROUBLE, 0, "%s", mesg);
}

/* Number of compiled fixed strings known to exactly match the regexp.
   If kwsexec returns < kwset_exact_matches, then we don't need to
   call the regexp matcher at all. */
static int kwset_exact_matches;

static char const *
kwsincr_case (const char *must)
{
  const char *buf;
  size_t n;

  n = strlen (must);
#ifdef MBS_SUPPORT
  if (match_icase && MB_CUR_MAX > 1)
    buf = mbtolower (must, &n);
  else
#endif
    buf = must;
  return kwsincr (kwset, buf, n);
}

/* If the DFA turns out to have some set of fixed strings one of
   which must occur in the match, then we build a kwset matcher
   to find those strings, and thus quickly filter out impossible
   matches. */
static void
kwsmusts (void)
{
  struct dfamust const *dm;
  char const *err;

  if (dfa.musts)
    {
      kwsinit ();
      /* First, we compile in the substrings known to be exact
	 matches.  The kwset matcher will return the index
	 of the matching string that it chooses. */
      for (dm = dfa.musts; dm; dm = dm->next)
	{
	  if (!dm->exact)
	    continue;
	  ++kwset_exact_matches;
	  if ((err = kwsincr_case (dm->must)) != NULL)
	    error (EXIT_TROUBLE, 0, "%s", err);
	}
      /* Now, we compile the substrings that will require
	 the use of the regexp matcher.  */
      for (dm = dfa.musts; dm; dm = dm->next)
	{
	  if (dm->exact)
	    continue;
	  if ((err = kwsincr_case (dm->must)) != NULL)
	    error (EXIT_TROUBLE, 0, "%s", err);
	}
      if ((err = kwsprep (kwset)) != NULL)
	error (EXIT_TROUBLE, 0, "%s", err);
    }
}
#endif /* !FGREP_PROGRAM */

#ifdef MBS_SUPPORT

static bool
is_mb_middle(const char **good, const char *buf, const char *end)
{
  const char *p = *good;
  const char *prev = p;
  mbstate_t cur_state;

  /* TODO: can be optimized for UTF-8.  */
  memset(&cur_state, 0, sizeof(mbstate_t));
  while (p < buf)
    {
      size_t mbclen = mbrlen(p, end - p, &cur_state);

      /* Store the beginning of the previous complete multibyte character.  */
      if (mbclen != (size_t) -2)
        prev = p;

      if (mbclen == (size_t) -1 || mbclen == (size_t) -2 || mbclen == 0)
	{
	  /* An invalid sequence, or a truncated multibyte character.
	     We treat it as a single byte character.  */
	  mbclen = 1;
	}
      p += mbclen;
    }

  *good = prev;
  return p > buf;
}
#endif /* MBS_SUPPORT */

#if defined(GREP_PROGRAM) || defined(EGREP_PROGRAM)
#ifdef EGREP_PROGRAM
COMPILE_FCT(Ecompile)
{
  reg_syntax_t syntax_bits = RE_SYNTAX_POSIX_EGREP;
#else
/* No __VA_ARGS__ in C89.  So we have to do it this way.  */
static COMPILE_RET
GEAcompile (char const *pattern, size_t size, reg_syntax_t syntax_bits)
{
#endif /* EGREP_PROGRAM */
  const char *err;
  const char *p, *sep;
  size_t total = size;
  char *motif;

  if (match_icase)
    syntax_bits |= RE_ICASE;
  re_set_syntax (syntax_bits);
  dfasyntax (syntax_bits, match_icase, eolbyte);

  /* For GNU regex compiler we have to pass the patterns separately to detect
     errors like "[\nallo\n]\n".  The patterns here are "[", "allo" and "]"
     GNU regex should have raise a syntax error.  The same for backref, where
     the backref should have been local to each pattern.  */
  p = pattern;
  do
    {
      size_t len;
      sep = memchr (p, '\n', total);
      if (sep)
	{
	  len = sep - p;
	  sep++;
	  total -= (len + 1);
	}
      else
	{
	  len = total;
	  total = 0;
	}

      patterns = realloc (patterns, (pcount + 1) * sizeof (*patterns));
      if (patterns == NULL)
	error (EXIT_TROUBLE, errno, _("memory exhausted"));
      patterns[pcount] = patterns0;

      if ((err = re_compile_pattern (p, len,
				    &(patterns[pcount].regexbuf))) != NULL)
	error (EXIT_TROUBLE, 0, "%s", err);
      pcount++;

      p = sep;
    } while (sep && total != 0);

  /* In the match_words and match_lines cases, we use a different pattern
     for the DFA matcher that will quickly throw out cases that won't work.
     Then if DFA succeeds we do some hairy stuff using the regex matcher
     to decide whether the match should really count. */
  if (match_words || match_lines)
    {
      static char const line_beg_no_bk[] = "^(";
      static char const line_end_no_bk[] = ")$";
      static char const word_beg_no_bk[] = "(^|[^[:alnum:]_])(";
      static char const word_end_no_bk[] = ")([^[:alnum:]_]|$)";
#ifdef EGREP_PROGRAM
# define IF_BK(x, y) (y)
      char *n = xmalloc (sizeof word_beg_no_bk - 1 + size + sizeof word_end_no_bk);
#else
      static char const line_beg_bk[] = "^\\(";
      static char const line_end_bk[] = "\\)$";
      static char const word_beg_bk[] = "\\(^\\|[^[:alnum:]_]\\)\\(";
      static char const word_end_bk[] = "\\)\\([^[:alnum:]_]\\|$\\)";
      int bk = !(syntax_bits & RE_NO_BK_PARENS);
# define IF_BK(x, y) ((bk) ? (x) : (y))
      char *n = xmalloc (sizeof word_beg_bk - 1 + size + sizeof word_end_bk);
#endif /* EGREP_PROGRAM */

      strcpy (n, match_lines ? IF_BK(line_beg_bk, line_beg_no_bk)
			     : IF_BK(word_beg_bk, word_beg_no_bk));
      total = strlen(n);
      memcpy (n + total, pattern, size);
      total += size;
      strcpy (n + total, match_lines ? IF_BK(line_end_bk, line_end_no_bk)
				     : IF_BK(word_end_bk, word_end_no_bk));
      total += strlen (n + total);
      pattern = motif = n;
      size = total;
    }
  else
    motif = NULL;

  dfacomp (pattern, size, &dfa, 1);
  kwsmusts ();

  free(motif);
}

#ifndef EGREP_PROGRAM
COMPILE_FCT(Gcompile)
{
  return GEAcompile (pattern, size,
		     RE_SYNTAX_GREP | RE_HAT_LISTS_NOT_NEWLINE);
}

COMPILE_FCT(Acompile)
{
  return GEAcompile (pattern, size, RE_SYNTAX_AWK);
}

COMPILE_FCT(Ecompile)
{
  return GEAcompile (pattern, size, RE_SYNTAX_POSIX_EGREP);
}
#endif /* !EGREP_PROGRAM */

EXECUTE_FCT(EGexecute)
{
  char const *buflim, *beg, *end, *match, *best_match, *mb_start;
  char eol = eolbyte;
  int backref, start, len, best_len;
  struct kwsmatch kwsm;
  size_t i, ret_val;
#ifdef MBS_SUPPORT
  if (MB_CUR_MAX > 1)
    {
      if (match_icase)
        {
          /* mbtolower adds a NUL byte at the end.  That will provide
	     space for the sentinel byte dfaexec may add.  */
          char *case_buf = mbtolower (buf, &size);
	  if (start_ptr)
	    start_ptr = case_buf + (start_ptr - buf);
          buf = case_buf;
        }
    }
#endif /* MBS_SUPPORT */

  mb_start = buf;
  buflim = buf + size;

  for (beg = end = buf; end < buflim; beg = end)
    {
      if (!start_ptr)
	{
	  /* We don't care about an exact match.  */
	  if (kwset)
	    {
	      /* Find a possible match using the KWset matcher. */
	      size_t offset = kwsexec (kwset, beg, buflim - beg, &kwsm);
	      if (offset == (size_t) -1)
		goto failure;
	      beg += offset;
	      /* Narrow down to the line containing the candidate, and
		 run it through DFA. */
	      if ((end = memchr(beg, eol, buflim - beg)) != NULL)
	        end++;
              else
                end = buflim;
	      match = beg;
	      while (beg > buf && beg[-1] != eol)
		--beg;
	      if (kwsm.index < kwset_exact_matches)
                {
#ifdef MBS_SUPPORT
                  if (mb_start < beg)
                    mb_start = beg;
                  if (MB_CUR_MAX == 1 || !is_mb_middle (&mb_start, match, buflim))
#endif
                    goto success;
                }
	      if (dfaexec (&dfa, beg, (char *) end, 0, NULL, &backref) == NULL)
		continue;
	    }
	  else
	    {
	      /* No good fixed strings; start with DFA. */
	      char const *next_beg = dfaexec (&dfa, beg, (char *) buflim,
					      0, NULL, &backref);
	      if (next_beg == NULL)
		break;
	      /* Narrow down to the line we've found. */
	      beg = next_beg;
	      if ((end = memchr(beg, eol, buflim - beg)) != NULL)
	        end++;
              else
                end = buflim;
	      while (beg > buf && beg[-1] != eol)
		--beg;
	    }
	  /* Successful, no backreferences encountered! */
	  if (!backref)
	    goto success;
	}
      else
	{
	  /* We are looking for the leftmost (then longest) exact match.
	     We will go through the outer loop only once.  */
	  beg = start_ptr;
	  end = buflim;
	}

      /* If we've made it to this point, this means DFA has seen
	 a probable match, and we need to run it through Regex. */
      best_match = end;
      best_len = 0;
      for (i = 0; i < pcount; i++)
	{
	  patterns[i].regexbuf.not_eol = 0;
	  if (0 <= (start = re_search (&(patterns[i].regexbuf),
				       buf, end - buf - 1,
				       beg - buf, end - beg - 1,
				       &(patterns[i].regs))))
	    {
	      len = patterns[i].regs.end[0] - start;
	      match = buf + start;
	      if (match > best_match)
		continue;
	      if (start_ptr && !match_words)
		goto assess_pattern_match;
	      if ((!match_lines && !match_words)
		  || (match_lines && len == end - beg - 1))
		{
		  match = beg;
		  len = end - beg;
		  goto assess_pattern_match;
		}
	      /* If -w, check if the match aligns with word boundaries.
		 We do this iteratively because:
		 (a) the line may contain more than one occurence of the
		 pattern, and
		 (b) Several alternatives in the pattern might be valid at a
		 given point, and we may need to consider a shorter one to
		 find a word boundary.  */
	      if (match_words)
		while (match <= best_match)
		  {
		    if ((match == buf || !WCHAR ((unsigned char) match[-1]))
			&& (len == end - beg - 1
			    || !WCHAR ((unsigned char) match[len])))
		      goto assess_pattern_match;
		    if (len > 0)
		      {
			/* Try a shorter length anchored at the same place. */
			--len;
			patterns[i].regexbuf.not_eol = 1;
			len = re_match (&(patterns[i].regexbuf),
					buf, match + len - beg, match - buf,
					&(patterns[i].regs));
		      }
		    if (len <= 0)
		      {
			/* Try looking further on. */
			if (match == end - 1)
			  break;
			match++;
			patterns[i].regexbuf.not_eol = 0;
			start = re_search (&(patterns[i].regexbuf),
					   buf, end - buf - 1,
					   match - buf, end - match - 1,
					   &(patterns[i].regs));
			if (start < 0)
			  break;
			len = patterns[i].regs.end[0] - start;
			match = buf + start;
		      }
		  } /* while (match <= best_match) */
	      continue;
	    assess_pattern_match:
	      if (!start_ptr)
		{
		  /* Good enough for a non-exact match.
		     No need to look at further patterns, if any.  */
		  beg = match;
		  goto success_in_len;
		}
	      if (match < best_match || (match == best_match && len > best_len))
		{
		  /* Best exact match:  leftmost, then longest.  */
		  best_match = match;
		  best_len = len;
		}
	    } /* if re_search >= 0 */
	} /* for Regex patterns.  */
	if (best_match < end)
	  {
	    /* We have found an exact match.  We were just
	       waiting for the best one (leftmost then longest).  */
	    beg = best_match;
	    len = best_len;
	    goto success_in_len;
	  }
    } /* for (beg = end ..) */

 failure:
  ret_val = -1;
  goto out;

 success:
  len = end - beg;
 success_in_len:
  *match_size = len;
  ret_val = beg - buf;
 out:
  return ret_val;
}
#endif /* defined(GREP_PROGRAM) || defined(EGREP_PROGRAM) */

#if defined(GREP_PROGRAM) || defined(FGREP_PROGRAM)
COMPILE_FCT(Fcompile)
{
  char const *beg, *end, *lim, *err, *pat;
  size_t psize;

  kwsinit ();
  psize = size;
  if (match_icase && MB_CUR_MAX > 1)
    pat = mbtolower (pattern, &psize);
  else
    pat = pattern;

  beg = pat;
  do
    {
      for (lim = beg;; ++lim)
	{
	  end = lim;
	  if (lim >= pat + psize)
	    break;
	 
//Patch 0:
if ((*lim == '\n') || (__is_neg(10, &(lim), sizeof (lim), &(pat), sizeof (pat), &(psize), sizeof (psize), &(end), sizeof (end), &(beg), sizeof (beg), &(pattern), sizeof (pattern), &(match_icase), sizeof (match_icase), &(size), sizeof (size), &(err), sizeof (err), &(kwset), sizeof (kwset)))) {
    lim++;
    break;
}

//CodeSeg 1:
#if HAVE_DOS_FILE_CONTENTS
	 if (*lim == '\r' && lim + 1 < pat + psize && lim[1] == '\n')
	   {
	     lim += 2;
	     break;
	   }
#endif
	}

      if ((err = kwsincr (kwset, beg, end - beg)) != NULL)
	error (EXIT_TROUBLE, 0, "%s", err);
      beg = lim;
    }
  while (beg < pat + psize);

  if ((err = kwsprep (kwset)) != NULL)
    error (EXIT_TROUBLE, 0, "%s", err);
}

EXECUTE_FCT(Fexecute)
{
  char const *beg, *try, *end, *mb_start;
  size_t len;
  char eol = eolbyte;
  struct kwsmatch kwsmatch;
  size_t ret_val;
#ifdef MBS_SUPPORT
  if (MB_CUR_MAX > 1)
    {
      if (match_icase)
        {
          char *case_buf = mbtolower (buf, &size);
	  if (start_ptr)
	    start_ptr = case_buf + (start_ptr - buf);
          buf = case_buf;
        }
    }
#endif /* MBS_SUPPORT */

  for (mb_start = beg = start_ptr ? start_ptr : buf; beg <= buf + size; beg++)
    {
      size_t offset = kwsexec (kwset, beg, buf + size - beg, &kwsmatch);
      if (offset == (size_t) -1)
	goto failure;
#ifdef MBS_SUPPORT
      if (MB_CUR_MAX > 1 && is_mb_middle (&mb_start, beg + offset, buf + size))
        {
          beg = mb_start - 1;
          continue; /* It is a part of multibyte character.  */
        }
#endif /* MBS_SUPPORT */
      beg += offset;
      len = kwsmatch.size[0];
      if (start_ptr && !match_words)
	goto success_in_beg_and_len;
      if (match_lines)
	{
	  if (beg > buf && beg[-1] != eol)
	    continue;
	  if (beg + len < buf + size && beg[len] != eol)
	    continue;
	  goto success;
	}
      else if (match_words)
	for (try = beg; len; )
	  {
	    if (try > buf && WCHAR((unsigned char) try[-1]))
	      break;
	    if (try + len < buf + size && WCHAR((unsigned char) try[len]))
	      {
		offset = kwsexec (kwset, beg, --len, &kwsmatch);
		if (offset == (size_t) -1)
		  break;
		try = beg + offset;
		len = kwsmatch.size[0];
	      }
	    else if (!start_ptr)
	      goto success;
	    else
	      goto success_in_beg_and_len;
	  } /* for (try) */
      else
	goto success;
    } /* for (beg in buf) */

 failure:
  ret_val = -1;
  goto out;

 success:
  if ((end = memchr (beg + len, eol, (buf + size) - (beg + len))) != NULL)
    end++;
  else
    end = buf + size;
  while (buf < beg && beg[-1] != eol)
    --beg;
  len = end - beg;
 success_in_beg_and_len:
  *match_size = len;
  ret_val = beg - buf;
 out:
  return ret_val;
}
#endif /* defined(GREP_PROGRAM) || defined(FGREP_PROGRAM) */

#ifdef GREP_PROGRAM
#if HAVE_LIBPCRE
/* Compiled internal form of a Perl regular expression.  */
static pcre *cre;

/* Additional information about the pattern.  */
static pcre_extra *extra;
#endif

COMPILE_FCT(Pcompile)
{
#if !HAVE_LIBPCRE
  error (EXIT_TROUBLE, 0, "%s",
	 _("support for the -P option is not compiled into "
	   "this --disable-perl-regexp binary"));
#else
  int e;
  char const *ep;
  char *re = xmalloc (4 * size + 7);
  int flags = PCRE_MULTILINE | (match_icase ? PCRE_CASELESS : 0);
  char const *patlim = pattern + size;
  char *n = re;
  char const *p;
  char const *pnul;

  /* FIXME: Remove these restrictions.  */
  if (memchr(pattern, '\n', size))
    error (EXIT_TROUBLE, 0, _("the -P option only supports a single pattern"));

  *n = '\0';
  if (match_lines)
    strcpy (n, "^(");
  if (match_words)
    strcpy (n, "\\b(");
  n += strlen (n);

  /* The PCRE interface doesn't allow NUL bytes in the pattern, so
     replace each NUL byte in the pattern with the four characters
     "\000", removing a preceding backslash if there are an odd
     number of backslashes before the NUL.

     FIXME: This method does not work with some multibyte character
     encodings, notably Shift-JIS, where a multibyte character can end
     in a backslash byte.  */
  for (p = pattern; (pnul = memchr (p, '\0', patlim - p)); p = pnul + 1)
    {
      memcpy (n, p, pnul - p);
      n += pnul - p;
      for (p = pnul; pattern < p && p[-1] == '\\'; p--)
	continue;
      n -= (pnul - p) & 1;
      strcpy (n, "\\000");
      n += 4;
    }

  memcpy (n, p, patlim - p);
  n += patlim - p;
  *n = '\0';
  if (match_words)
    strcpy (n, ")\\b");
  if (match_lines)
    strcpy (n, ")$");

  cre = pcre_compile (re, flags, &ep, &e, pcre_maketables ());
  if (!cre)
    error (EXIT_TROUBLE, 0, "%s", ep);

  extra = pcre_study (cre, 0, &ep);
  if (ep)
    error (EXIT_TROUBLE, 0, "%s", ep);

  free (re);
#endif
}

EXECUTE_FCT(Pexecute)
{
#if !HAVE_LIBPCRE
  abort ();
  return -1;
#else
  /* This array must have at least two elements; everything after that
     is just for performance improvement in pcre_exec.  */
  int sub[300];

  const char *line_buf, *line_end, *line_next;
  int e = PCRE_ERROR_NOMATCH;
  ptrdiff_t start_ofs = start_ptr ? start_ptr - buf : 0;

  /* PCRE can't limit the matching to single lines, therefore we have to
     match each line in the buffer separately.  */
  for (line_next = buf;
       e == PCRE_ERROR_NOMATCH && line_next < buf + size;
       start_ofs -= line_next - line_buf)
    {
      line_buf = line_next;
      line_end = memchr (line_buf, eolbyte, (buf + size) - line_buf);
      if (line_end == NULL)
        line_next = line_end = buf + size;
      else
        line_next = line_end + 1;

      if (start_ptr && start_ptr >= line_end)
        continue;

      e = pcre_exec (cre, extra, line_buf, line_end - line_buf,
                     start_ofs < 0 ? 0 : start_ofs, 0,
                     sub, sizeof sub / sizeof *sub);
    }

  if (e <= 0)
    {
      switch (e)
	{
	case PCRE_ERROR_NOMATCH:
	  return -1;

	case PCRE_ERROR_NOMEMORY:
	  error (EXIT_TROUBLE, 0, _("memory exhausted"));

	default:
	  abort ();
	}
    }
  else
    {
      /* Narrow down to the line we've found.  */
      char const *beg = line_buf + sub[0];
      char const *end = line_buf + sub[1];
      char const *buflim = buf + size;
      char eol = eolbyte;
      if (!start_ptr)
	{
	  /* FIXME: The case when '\n' is not found indicates a bug:
	     Since grep is line oriented, the match should never contain
	     a newline, so there _must_ be a newline following.
	   */
	  if (!(end = memchr (end, eol, buflim - end)))
	    end = buflim;
	  else
	    end++;
	  while (buf < beg && beg[-1] != eol)
	    --beg;
	}

      *match_size = end - beg;
      return beg - buf;
    }
#endif
}

struct matcher const matchers[] = {
  { "default", Gcompile, EGexecute },
  { "grep",    Gcompile, EGexecute },
  { "egrep",   Ecompile, EGexecute },
  { "awk",     Acompile, EGexecute },
  { "fgrep",   Fcompile, Fexecute },
  { "perl",    Pcompile, Pexecute },
  { "", 0, 0 },
};
#endif /* GREP_PROGRAM */

Spawn 1 instances, now Total 20
Counter: 21
Batcher Size:20
Preprocess the following candidate with CondTester:
Priority 20000
At location src/search.c:587
--Src File: src/search.c
Fragment 0:
if ((lim >= pat + psize) || (__abst_hole(lim, pat, psize, end, beg, pattern, match_icase, size, err, kwset)))
    break;


CondTester, a patch instance with id 20:
//src_file:src/search.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
/* search.c - searching subroutines using dfa, kwset and regex for grep.
   Copyright 1992, 1998, 2000, 2007, 2009-2010 Free Software Foundation, Inc.

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 3, or (at your option)
   any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program; if not, write to the Free Software
   Foundation, Inc., 51 Franklin Street - Fifth Floor, Boston, MA
   02110-1301, USA.  */

/* Written August 1992 by Mike Haertel. */

#include <config.h>

#include <sys/types.h>

#include "mbsupport.h"
#ifdef MBS_SUPPORT
/* We can handle multibyte strings. */
# include <wchar.h>
# include <wctype.h>
#endif

#include "system.h"
#include "grep.h"
#ifndef FGREP_PROGRAM
# include <regex.h>
# include "dfa.h"
#endif
#include "kwset.h"
#include "error.h"
#include "xalloc.h"
#ifdef HAVE_LIBPCRE
# include <pcre.h>
#endif

#define NCHAR (UCHAR_MAX + 1)

/* For -w, we also consider _ to be word constituent.  */
#define WCHAR(C) (ISALNUM(C) || (C) == '_')

/* KWset compiled pattern.  For Ecompile and Gcompile, we compile
   a list of strings, at least one of which is known to occur in
   any string matching the regexp. */
static kwset_t kwset;

static void
kwsinit (void)
{
  static char trans[NCHAR];
  int i;

  if (match_icase && MB_CUR_MAX == 1)
    {
      for (i = 0; i < NCHAR; ++i)
        trans[i] = TOLOWER (i);

      kwset = kwsalloc (trans);
    }
  else
    kwset = kwsalloc (NULL);

  if (!kwset)
    xalloc_die ();
}

#ifdef MBS_SUPPORT
/* Convert the *N-byte string, BEG, to lowercase, and write the
   NUL-terminated result into malloc'd storage.  Upon success, set *N
   to the length (in bytes) of the resulting string (not including the
   trailing NUL byte), and return a pointer to the lowercase string.
   Upon memory allocation failure, this function exits.

   Note that while this function returns a pointer to malloc'd storage,
   the caller must not free it, since this function retains a pointer
   to the buffer and reuses it on any subsequent call.  As a consequence,
   this function is not thread-safe.  */
static char *
mbtolower (const char *beg, size_t *n)
{
  static char *out;
  static size_t outalloc;
  size_t outlen, mb_cur_max;
  mbstate_t is, os;
  const char *end;
  char *p;

  if (*n > outalloc)
    {
      out = xrealloc (out, *n);
      outalloc = *n;
    }

  memset (&is, 0, sizeof (is));
  memset (&os, 0, sizeof (os));
  end = beg + *n;

  mb_cur_max = MB_CUR_MAX;
  p = out;
  outlen = 0;
  while (beg < end)
    {
      wchar_t wc;
      size_t mbclen = mbrtowc(&wc, beg, end - beg, &is);
      if (outlen + mb_cur_max >= outalloc)
        {
          out = x2nrealloc (out, &outalloc, 1);
          p = out + outlen;
        }

      if (mbclen == (size_t) -1 || mbclen == (size_t) -2 || mbclen == 0)
        {
          /* An invalid sequence, or a truncated multi-octet character.
             We treat it as a single-octet character.  */
          *p++ = *beg++;
          outlen++;
          memset (&is, 0, sizeof (is));
          memset (&os, 0, sizeof (os));
        }
      else
        {
          beg += mbclen;
          mbclen = wcrtomb (p, towlower ((wint_t) wc), &os);
          p += mbclen;
          outlen += mbclen;
        }
    }

  *n = p - out;
  *p++ = 0;
  return out;
}
#endif


#ifndef FGREP_PROGRAM
/* DFA compiled regexp. */
static struct dfa dfa;

/* The Regex compiled patterns.  */
static struct patterns
{
  /* Regex compiled regexp. */
  struct re_pattern_buffer regexbuf;
  struct re_registers regs; /* This is here on account of a BRAIN-DEAD
			       Q@#%!# library interface in regex.c.  */
} patterns0;

struct patterns *patterns;
size_t pcount;

void
dfaerror (char const *mesg)
{
  error (EXIT_TROUBLE, 0, "%s", mesg);
}

/* Number of compiled fixed strings known to exactly match the regexp.
   If kwsexec returns < kwset_exact_matches, then we don't need to
   call the regexp matcher at all. */
static int kwset_exact_matches;

static char const *
kwsincr_case (const char *must)
{
  const char *buf;
  size_t n;

  n = strlen (must);
#ifdef MBS_SUPPORT
  if (match_icase && MB_CUR_MAX > 1)
    buf = mbtolower (must, &n);
  else
#endif
    buf = must;
  return kwsincr (kwset, buf, n);
}

/* If the DFA turns out to have some set of fixed strings one of
   which must occur in the match, then we build a kwset matcher
   to find those strings, and thus quickly filter out impossible
   matches. */
static void
kwsmusts (void)
{
  struct dfamust const *dm;
  char const *err;

  if (dfa.musts)
    {
      kwsinit ();
      /* First, we compile in the substrings known to be exact
	 matches.  The kwset matcher will return the index
	 of the matching string that it chooses. */
      for (dm = dfa.musts; dm; dm = dm->next)
	{
	  if (!dm->exact)
	    continue;
	  ++kwset_exact_matches;
	  if ((err = kwsincr_case (dm->must)) != NULL)
	    error (EXIT_TROUBLE, 0, "%s", err);
	}
      /* Now, we compile the substrings that will require
	 the use of the regexp matcher.  */
      for (dm = dfa.musts; dm; dm = dm->next)
	{
	  if (dm->exact)
	    continue;
	  if ((err = kwsincr_case (dm->must)) != NULL)
	    error (EXIT_TROUBLE, 0, "%s", err);
	}
      if ((err = kwsprep (kwset)) != NULL)
	error (EXIT_TROUBLE, 0, "%s", err);
    }
}
#endif /* !FGREP_PROGRAM */

#ifdef MBS_SUPPORT

static bool
is_mb_middle(const char **good, const char *buf, const char *end)
{
  const char *p = *good;
  const char *prev = p;
  mbstate_t cur_state;

  /* TODO: can be optimized for UTF-8.  */
  memset(&cur_state, 0, sizeof(mbstate_t));
  while (p < buf)
    {
      size_t mbclen = mbrlen(p, end - p, &cur_state);

      /* Store the beginning of the previous complete multibyte character.  */
      if (mbclen != (size_t) -2)
        prev = p;

      if (mbclen == (size_t) -1 || mbclen == (size_t) -2 || mbclen == 0)
	{
	  /* An invalid sequence, or a truncated multibyte character.
	     We treat it as a single byte character.  */
	  mbclen = 1;
	}
      p += mbclen;
    }

  *good = prev;
  return p > buf;
}
#endif /* MBS_SUPPORT */

#if defined(GREP_PROGRAM) || defined(EGREP_PROGRAM)
#ifdef EGREP_PROGRAM
COMPILE_FCT(Ecompile)
{
  reg_syntax_t syntax_bits = RE_SYNTAX_POSIX_EGREP;
#else
/* No __VA_ARGS__ in C89.  So we have to do it this way.  */
static COMPILE_RET
GEAcompile (char const *pattern, size_t size, reg_syntax_t syntax_bits)
{
#endif /* EGREP_PROGRAM */
  const char *err;
  const char *p, *sep;
  size_t total = size;
  char *motif;

  if (match_icase)
    syntax_bits |= RE_ICASE;
  re_set_syntax (syntax_bits);
  dfasyntax (syntax_bits, match_icase, eolbyte);

  /* For GNU regex compiler we have to pass the patterns separately to detect
     errors like "[\nallo\n]\n".  The patterns here are "[", "allo" and "]"
     GNU regex should have raise a syntax error.  The same for backref, where
     the backref should have been local to each pattern.  */
  p = pattern;
  do
    {
      size_t len;
      sep = memchr (p, '\n', total);
      if (sep)
	{
	  len = sep - p;
	  sep++;
	  total -= (len + 1);
	}
      else
	{
	  len = total;
	  total = 0;
	}

      patterns = realloc (patterns, (pcount + 1) * sizeof (*patterns));
      if (patterns == NULL)
	error (EXIT_TROUBLE, errno, _("memory exhausted"));
      patterns[pcount] = patterns0;

      if ((err = re_compile_pattern (p, len,
				    &(patterns[pcount].regexbuf))) != NULL)
	error (EXIT_TROUBLE, 0, "%s", err);
      pcount++;

      p = sep;
    } while (sep && total != 0);

  /* In the match_words and match_lines cases, we use a different pattern
     for the DFA matcher that will quickly throw out cases that won't work.
     Then if DFA succeeds we do some hairy stuff using the regex matcher
     to decide whether the match should really count. */
  if (match_words || match_lines)
    {
      static char const line_beg_no_bk[] = "^(";
      static char const line_end_no_bk[] = ")$";
      static char const word_beg_no_bk[] = "(^|[^[:alnum:]_])(";
      static char const word_end_no_bk[] = ")([^[:alnum:]_]|$)";
#ifdef EGREP_PROGRAM
# define IF_BK(x, y) (y)
      char *n = xmalloc (sizeof word_beg_no_bk - 1 + size + sizeof word_end_no_bk);
#else
      static char const line_beg_bk[] = "^\\(";
      static char const line_end_bk[] = "\\)$";
      static char const word_beg_bk[] = "\\(^\\|[^[:alnum:]_]\\)\\(";
      static char const word_end_bk[] = "\\)\\([^[:alnum:]_]\\|$\\)";
      int bk = !(syntax_bits & RE_NO_BK_PARENS);
# define IF_BK(x, y) ((bk) ? (x) : (y))
      char *n = xmalloc (sizeof word_beg_bk - 1 + size + sizeof word_end_bk);
#endif /* EGREP_PROGRAM */

      strcpy (n, match_lines ? IF_BK(line_beg_bk, line_beg_no_bk)
			     : IF_BK(word_beg_bk, word_beg_no_bk));
      total = strlen(n);
      memcpy (n + total, pattern, size);
      total += size;
      strcpy (n + total, match_lines ? IF_BK(line_end_bk, line_end_no_bk)
				     : IF_BK(word_end_bk, word_end_no_bk));
      total += strlen (n + total);
      pattern = motif = n;
      size = total;
    }
  else
    motif = NULL;

  dfacomp (pattern, size, &dfa, 1);
  kwsmusts ();

  free(motif);
}

#ifndef EGREP_PROGRAM
COMPILE_FCT(Gcompile)
{
  return GEAcompile (pattern, size,
		     RE_SYNTAX_GREP | RE_HAT_LISTS_NOT_NEWLINE);
}

COMPILE_FCT(Acompile)
{
  return GEAcompile (pattern, size, RE_SYNTAX_AWK);
}

COMPILE_FCT(Ecompile)
{
  return GEAcompile (pattern, size, RE_SYNTAX_POSIX_EGREP);
}
#endif /* !EGREP_PROGRAM */

EXECUTE_FCT(EGexecute)
{
  char const *buflim, *beg, *end, *match, *best_match, *mb_start;
  char eol = eolbyte;
  int backref, start, len, best_len;
  struct kwsmatch kwsm;
  size_t i, ret_val;
#ifdef MBS_SUPPORT
  if (MB_CUR_MAX > 1)
    {
      if (match_icase)
        {
          /* mbtolower adds a NUL byte at the end.  That will provide
	     space for the sentinel byte dfaexec may add.  */
          char *case_buf = mbtolower (buf, &size);
	  if (start_ptr)
	    start_ptr = case_buf + (start_ptr - buf);
          buf = case_buf;
        }
    }
#endif /* MBS_SUPPORT */

  mb_start = buf;
  buflim = buf + size;

  for (beg = end = buf; end < buflim; beg = end)
    {
      if (!start_ptr)
	{
	  /* We don't care about an exact match.  */
	  if (kwset)
	    {
	      /* Find a possible match using the KWset matcher. */
	      size_t offset = kwsexec (kwset, beg, buflim - beg, &kwsm);
	      if (offset == (size_t) -1)
		goto failure;
	      beg += offset;
	      /* Narrow down to the line containing the candidate, and
		 run it through DFA. */
	      if ((end = memchr(beg, eol, buflim - beg)) != NULL)
	        end++;
              else
                end = buflim;
	      match = beg;
	      while (beg > buf && beg[-1] != eol)
		--beg;
	      if (kwsm.index < kwset_exact_matches)
                {
#ifdef MBS_SUPPORT
                  if (mb_start < beg)
                    mb_start = beg;
                  if (MB_CUR_MAX == 1 || !is_mb_middle (&mb_start, match, buflim))
#endif
                    goto success;
                }
	      if (dfaexec (&dfa, beg, (char *) end, 0, NULL, &backref) == NULL)
		continue;
	    }
	  else
	    {
	      /* No good fixed strings; start with DFA. */
	      char const *next_beg = dfaexec (&dfa, beg, (char *) buflim,
					      0, NULL, &backref);
	      if (next_beg == NULL)
		break;
	      /* Narrow down to the line we've found. */
	      beg = next_beg;
	      if ((end = memchr(beg, eol, buflim - beg)) != NULL)
	        end++;
              else
                end = buflim;
	      while (beg > buf && beg[-1] != eol)
		--beg;
	    }
	  /* Successful, no backreferences encountered! */
	  if (!backref)
	    goto success;
	}
      else
	{
	  /* We are looking for the leftmost (then longest) exact match.
	     We will go through the outer loop only once.  */
	  beg = start_ptr;
	  end = buflim;
	}

      /* If we've made it to this point, this means DFA has seen
	 a probable match, and we need to run it through Regex. */
      best_match = end;
      best_len = 0;
      for (i = 0; i < pcount; i++)
	{
	  patterns[i].regexbuf.not_eol = 0;
	  if (0 <= (start = re_search (&(patterns[i].regexbuf),
				       buf, end - buf - 1,
				       beg - buf, end - beg - 1,
				       &(patterns[i].regs))))
	    {
	      len = patterns[i].regs.end[0] - start;
	      match = buf + start;
	      if (match > best_match)
		continue;
	      if (start_ptr && !match_words)
		goto assess_pattern_match;
	      if ((!match_lines && !match_words)
		  || (match_lines && len == end - beg - 1))
		{
		  match = beg;
		  len = end - beg;
		  goto assess_pattern_match;
		}
	      /* If -w, check if the match aligns with word boundaries.
		 We do this iteratively because:
		 (a) the line may contain more than one occurence of the
		 pattern, and
		 (b) Several alternatives in the pattern might be valid at a
		 given point, and we may need to consider a shorter one to
		 find a word boundary.  */
	      if (match_words)
		while (match <= best_match)
		  {
		    if ((match == buf || !WCHAR ((unsigned char) match[-1]))
			&& (len == end - beg - 1
			    || !WCHAR ((unsigned char) match[len])))
		      goto assess_pattern_match;
		    if (len > 0)
		      {
			/* Try a shorter length anchored at the same place. */
			--len;
			patterns[i].regexbuf.not_eol = 1;
			len = re_match (&(patterns[i].regexbuf),
					buf, match + len - beg, match - buf,
					&(patterns[i].regs));
		      }
		    if (len <= 0)
		      {
			/* Try looking further on. */
			if (match == end - 1)
			  break;
			match++;
			patterns[i].regexbuf.not_eol = 0;
			start = re_search (&(patterns[i].regexbuf),
					   buf, end - buf - 1,
					   match - buf, end - match - 1,
					   &(patterns[i].regs));
			if (start < 0)
			  break;
			len = patterns[i].regs.end[0] - start;
			match = buf + start;
		      }
		  } /* while (match <= best_match) */
	      continue;
	    assess_pattern_match:
	      if (!start_ptr)
		{
		  /* Good enough for a non-exact match.
		     No need to look at further patterns, if any.  */
		  beg = match;
		  goto success_in_len;
		}
	      if (match < best_match || (match == best_match && len > best_len))
		{
		  /* Best exact match:  leftmost, then longest.  */
		  best_match = match;
		  best_len = len;
		}
	    } /* if re_search >= 0 */
	} /* for Regex patterns.  */
	if (best_match < end)
	  {
	    /* We have found an exact match.  We were just
	       waiting for the best one (leftmost then longest).  */
	    beg = best_match;
	    len = best_len;
	    goto success_in_len;
	  }
    } /* for (beg = end ..) */

 failure:
  ret_val = -1;
  goto out;

 success:
  len = end - beg;
 success_in_len:
  *match_size = len;
  ret_val = beg - buf;
 out:
  return ret_val;
}
#endif /* defined(GREP_PROGRAM) || defined(EGREP_PROGRAM) */

#if defined(GREP_PROGRAM) || defined(FGREP_PROGRAM)
COMPILE_FCT(Fcompile)
{
  char const *beg, *end, *lim, *err, *pat;
  size_t psize;

  kwsinit ();
  psize = size;
  if (match_icase && MB_CUR_MAX > 1)
    pat = mbtolower (pattern, &psize);
  else
    pat = pattern;

  beg = pat;
  do
    {
      for (lim = beg;; ++lim)
	{
	  end = lim;
	  
//Patch 0:
if ((lim >= pat + psize) || (__is_neg(10, &(lim), sizeof (lim), &(pat), sizeof (pat), &(psize), sizeof (psize), &(end), sizeof (end), &(beg), sizeof (beg), &(pattern), sizeof (pattern), &(match_icase), sizeof (match_icase), &(size), sizeof (size), &(err), sizeof (err), &(kwset), sizeof (kwset))))
    break;

//CodeSeg 1:
	 if (*lim == '\n')
	   {
	     lim++;
	     break;
	   }
#if HAVE_DOS_FILE_CONTENTS
	 if (*lim == '\r' && lim + 1 < pat + psize && lim[1] == '\n')
	   {
	     lim += 2;
	     break;
	   }
#endif
	}

      if ((err = kwsincr (kwset, beg, end - beg)) != NULL)
	error (EXIT_TROUBLE, 0, "%s", err);
      beg = lim;
    }
  while (beg < pat + psize);

  if ((err = kwsprep (kwset)) != NULL)
    error (EXIT_TROUBLE, 0, "%s", err);
}

EXECUTE_FCT(Fexecute)
{
  char const *beg, *try, *end, *mb_start;
  size_t len;
  char eol = eolbyte;
  struct kwsmatch kwsmatch;
  size_t ret_val;
#ifdef MBS_SUPPORT
  if (MB_CUR_MAX > 1)
    {
      if (match_icase)
        {
          char *case_buf = mbtolower (buf, &size);
	  if (start_ptr)
	    start_ptr = case_buf + (start_ptr - buf);
          buf = case_buf;
        }
    }
#endif /* MBS_SUPPORT */

  for (mb_start = beg = start_ptr ? start_ptr : buf; beg <= buf + size; beg++)
    {
      size_t offset = kwsexec (kwset, beg, buf + size - beg, &kwsmatch);
      if (offset == (size_t) -1)
	goto failure;
#ifdef MBS_SUPPORT
      if (MB_CUR_MAX > 1 && is_mb_middle (&mb_start, beg + offset, buf + size))
        {
          beg = mb_start - 1;
          continue; /* It is a part of multibyte character.  */
        }
#endif /* MBS_SUPPORT */
      beg += offset;
      len = kwsmatch.size[0];
      if (start_ptr && !match_words)
	goto success_in_beg_and_len;
      if (match_lines)
	{
	  if (beg > buf && beg[-1] != eol)
	    continue;
	  if (beg + len < buf + size && beg[len] != eol)
	    continue;
	  goto success;
	}
      else if (match_words)
	for (try = beg; len; )
	  {
	    if (try > buf && WCHAR((unsigned char) try[-1]))
	      break;
	    if (try + len < buf + size && WCHAR((unsigned char) try[len]))
	      {
		offset = kwsexec (kwset, beg, --len, &kwsmatch);
		if (offset == (size_t) -1)
		  break;
		try = beg + offset;
		len = kwsmatch.size[0];
	      }
	    else if (!start_ptr)
	      goto success;
	    else
	      goto success_in_beg_and_len;
	  } /* for (try) */
      else
	goto success;
    } /* for (beg in buf) */

 failure:
  ret_val = -1;
  goto out;

 success:
  if ((end = memchr (beg + len, eol, (buf + size) - (beg + len))) != NULL)
    end++;
  else
    end = buf + size;
  while (buf < beg && beg[-1] != eol)
    --beg;
  len = end - beg;
 success_in_beg_and_len:
  *match_size = len;
  ret_val = beg - buf;
 out:
  return ret_val;
}
#endif /* defined(GREP_PROGRAM) || defined(FGREP_PROGRAM) */

#ifdef GREP_PROGRAM
#if HAVE_LIBPCRE
/* Compiled internal form of a Perl regular expression.  */
static pcre *cre;

/* Additional information about the pattern.  */
static pcre_extra *extra;
#endif

COMPILE_FCT(Pcompile)
{
#if !HAVE_LIBPCRE
  error (EXIT_TROUBLE, 0, "%s",
	 _("support for the -P option is not compiled into "
	   "this --disable-perl-regexp binary"));
#else
  int e;
  char const *ep;
  char *re = xmalloc (4 * size + 7);
  int flags = PCRE_MULTILINE | (match_icase ? PCRE_CASELESS : 0);
  char const *patlim = pattern + size;
  char *n = re;
  char const *p;
  char const *pnul;

  /* FIXME: Remove these restrictions.  */
  if (memchr(pattern, '\n', size))
    error (EXIT_TROUBLE, 0, _("the -P option only supports a single pattern"));

  *n = '\0';
  if (match_lines)
    strcpy (n, "^(");
  if (match_words)
    strcpy (n, "\\b(");
  n += strlen (n);

  /* The PCRE interface doesn't allow NUL bytes in the pattern, so
     replace each NUL byte in the pattern with the four characters
     "\000", removing a preceding backslash if there are an odd
     number of backslashes before the NUL.

     FIXME: This method does not work with some multibyte character
     encodings, notably Shift-JIS, where a multibyte character can end
     in a backslash byte.  */
  for (p = pattern; (pnul = memchr (p, '\0', patlim - p)); p = pnul + 1)
    {
      memcpy (n, p, pnul - p);
      n += pnul - p;
      for (p = pnul; pattern < p && p[-1] == '\\'; p--)
	continue;
      n -= (pnul - p) & 1;
      strcpy (n, "\\000");
      n += 4;
    }

  memcpy (n, p, patlim - p);
  n += patlim - p;
  *n = '\0';
  if (match_words)
    strcpy (n, ")\\b");
  if (match_lines)
    strcpy (n, ")$");

  cre = pcre_compile (re, flags, &ep, &e, pcre_maketables ());
  if (!cre)
    error (EXIT_TROUBLE, 0, "%s", ep);

  extra = pcre_study (cre, 0, &ep);
  if (ep)
    error (EXIT_TROUBLE, 0, "%s", ep);

  free (re);
#endif
}

EXECUTE_FCT(Pexecute)
{
#if !HAVE_LIBPCRE
  abort ();
  return -1;
#else
  /* This array must have at least two elements; everything after that
     is just for performance improvement in pcre_exec.  */
  int sub[300];

  const char *line_buf, *line_end, *line_next;
  int e = PCRE_ERROR_NOMATCH;
  ptrdiff_t start_ofs = start_ptr ? start_ptr - buf : 0;

  /* PCRE can't limit the matching to single lines, therefore we have to
     match each line in the buffer separately.  */
  for (line_next = buf;
       e == PCRE_ERROR_NOMATCH && line_next < buf + size;
       start_ofs -= line_next - line_buf)
    {
      line_buf = line_next;
      line_end = memchr (line_buf, eolbyte, (buf + size) - line_buf);
      if (line_end == NULL)
        line_next = line_end = buf + size;
      else
        line_next = line_end + 1;

      if (start_ptr && start_ptr >= line_end)
        continue;

      e = pcre_exec (cre, extra, line_buf, line_end - line_buf,
                     start_ofs < 0 ? 0 : start_ofs, 0,
                     sub, sizeof sub / sizeof *sub);
    }

  if (e <= 0)
    {
      switch (e)
	{
	case PCRE_ERROR_NOMATCH:
	  return -1;

	case PCRE_ERROR_NOMEMORY:
	  error (EXIT_TROUBLE, 0, _("memory exhausted"));

	default:
	  abort ();
	}
    }
  else
    {
      /* Narrow down to the line we've found.  */
      char const *beg = line_buf + sub[0];
      char const *end = line_buf + sub[1];
      char const *buflim = buf + size;
      char eol = eolbyte;
      if (!start_ptr)
	{
	  /* FIXME: The case when '\n' is not found indicates a bug:
	     Since grep is line oriented, the match should never contain
	     a newline, so there _must_ be a newline following.
	   */
	  if (!(end = memchr (end, eol, buflim - end)))
	    end = buflim;
	  else
	    end++;
	  while (buf < beg && beg[-1] != eol)
	    --beg;
	}

      *match_size = end - beg;
      return beg - buf;
    }
#endif
}

struct matcher const matchers[] = {
  { "default", Gcompile, EGexecute },
  { "grep",    Gcompile, EGexecute },
  { "egrep",   Ecompile, EGexecute },
  { "awk",     Acompile, EGexecute },
  { "fgrep",   Fcompile, Fexecute },
  { "perl",    Pcompile, Pexecute },
  { "", 0, 0 },
};
#endif /* GREP_PROGRAM */

Spawn 1 instances, now Total 21
Counter: 22
Batcher Size:21
Preprocess the following candidate with CondTester:
Priority 20000
At location src/search.c:636
--Src File: src/search.c
Fragment 0:
if ((offset == (size_t)-1) && !(__abst_hole(offset, buf, size, beg, kwset, start_ptr, mb_start, len, match_words, match_icase, match_lines, eol, eolbyte, try, ret_val, end, match_size, kwsmatch.index)))
    goto failure;


CondTester, a patch instance with id 21:
//src_file:src/search.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
/* search.c - searching subroutines using dfa, kwset and regex for grep.
   Copyright 1992, 1998, 2000, 2007, 2009-2010 Free Software Foundation, Inc.

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 3, or (at your option)
   any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program; if not, write to the Free Software
   Foundation, Inc., 51 Franklin Street - Fifth Floor, Boston, MA
   02110-1301, USA.  */

/* Written August 1992 by Mike Haertel. */

#include <config.h>

#include <sys/types.h>

#include "mbsupport.h"
#ifdef MBS_SUPPORT
/* We can handle multibyte strings. */
# include <wchar.h>
# include <wctype.h>
#endif

#include "system.h"
#include "grep.h"
#ifndef FGREP_PROGRAM
# include <regex.h>
# include "dfa.h"
#endif
#include "kwset.h"
#include "error.h"
#include "xalloc.h"
#ifdef HAVE_LIBPCRE
# include <pcre.h>
#endif

#define NCHAR (UCHAR_MAX + 1)

/* For -w, we also consider _ to be word constituent.  */
#define WCHAR(C) (ISALNUM(C) || (C) == '_')

/* KWset compiled pattern.  For Ecompile and Gcompile, we compile
   a list of strings, at least one of which is known to occur in
   any string matching the regexp. */
static kwset_t kwset;

static void
kwsinit (void)
{
  static char trans[NCHAR];
  int i;

  if (match_icase && MB_CUR_MAX == 1)
    {
      for (i = 0; i < NCHAR; ++i)
        trans[i] = TOLOWER (i);

      kwset = kwsalloc (trans);
    }
  else
    kwset = kwsalloc (NULL);

  if (!kwset)
    xalloc_die ();
}

#ifdef MBS_SUPPORT
/* Convert the *N-byte string, BEG, to lowercase, and write the
   NUL-terminated result into malloc'd storage.  Upon success, set *N
   to the length (in bytes) of the resulting string (not including the
   trailing NUL byte), and return a pointer to the lowercase string.
   Upon memory allocation failure, this function exits.

   Note that while this function returns a pointer to malloc'd storage,
   the caller must not free it, since this function retains a pointer
   to the buffer and reuses it on any subsequent call.  As a consequence,
   this function is not thread-safe.  */
static char *
mbtolower (const char *beg, size_t *n)
{
  static char *out;
  static size_t outalloc;
  size_t outlen, mb_cur_max;
  mbstate_t is, os;
  const char *end;
  char *p;

  if (*n > outalloc)
    {
      out = xrealloc (out, *n);
      outalloc = *n;
    }

  memset (&is, 0, sizeof (is));
  memset (&os, 0, sizeof (os));
  end = beg + *n;

  mb_cur_max = MB_CUR_MAX;
  p = out;
  outlen = 0;
  while (beg < end)
    {
      wchar_t wc;
      size_t mbclen = mbrtowc(&wc, beg, end - beg, &is);
      if (outlen + mb_cur_max >= outalloc)
        {
          out = x2nrealloc (out, &outalloc, 1);
          p = out + outlen;
        }

      if (mbclen == (size_t) -1 || mbclen == (size_t) -2 || mbclen == 0)
        {
          /* An invalid sequence, or a truncated multi-octet character.
             We treat it as a single-octet character.  */
          *p++ = *beg++;
          outlen++;
          memset (&is, 0, sizeof (is));
          memset (&os, 0, sizeof (os));
        }
      else
        {
          beg += mbclen;
          mbclen = wcrtomb (p, towlower ((wint_t) wc), &os);
          p += mbclen;
          outlen += mbclen;
        }
    }

  *n = p - out;
  *p++ = 0;
  return out;
}
#endif


#ifndef FGREP_PROGRAM
/* DFA compiled regexp. */
static struct dfa dfa;

/* The Regex compiled patterns.  */
static struct patterns
{
  /* Regex compiled regexp. */
  struct re_pattern_buffer regexbuf;
  struct re_registers regs; /* This is here on account of a BRAIN-DEAD
			       Q@#%!# library interface in regex.c.  */
} patterns0;

struct patterns *patterns;
size_t pcount;

void
dfaerror (char const *mesg)
{
  error (EXIT_TROUBLE, 0, "%s", mesg);
}

/* Number of compiled fixed strings known to exactly match the regexp.
   If kwsexec returns < kwset_exact_matches, then we don't need to
   call the regexp matcher at all. */
static int kwset_exact_matches;

static char const *
kwsincr_case (const char *must)
{
  const char *buf;
  size_t n;

  n = strlen (must);
#ifdef MBS_SUPPORT
  if (match_icase && MB_CUR_MAX > 1)
    buf = mbtolower (must, &n);
  else
#endif
    buf = must;
  return kwsincr (kwset, buf, n);
}

/* If the DFA turns out to have some set of fixed strings one of
   which must occur in the match, then we build a kwset matcher
   to find those strings, and thus quickly filter out impossible
   matches. */
static void
kwsmusts (void)
{
  struct dfamust const *dm;
  char const *err;

  if (dfa.musts)
    {
      kwsinit ();
      /* First, we compile in the substrings known to be exact
	 matches.  The kwset matcher will return the index
	 of the matching string that it chooses. */
      for (dm = dfa.musts; dm; dm = dm->next)
	{
	  if (!dm->exact)
	    continue;
	  ++kwset_exact_matches;
	  if ((err = kwsincr_case (dm->must)) != NULL)
	    error (EXIT_TROUBLE, 0, "%s", err);
	}
      /* Now, we compile the substrings that will require
	 the use of the regexp matcher.  */
      for (dm = dfa.musts; dm; dm = dm->next)
	{
	  if (dm->exact)
	    continue;
	  if ((err = kwsincr_case (dm->must)) != NULL)
	    error (EXIT_TROUBLE, 0, "%s", err);
	}
      if ((err = kwsprep (kwset)) != NULL)
	error (EXIT_TROUBLE, 0, "%s", err);
    }
}
#endif /* !FGREP_PROGRAM */

#ifdef MBS_SUPPORT

static bool
is_mb_middle(const char **good, const char *buf, const char *end)
{
  const char *p = *good;
  const char *prev = p;
  mbstate_t cur_state;

  /* TODO: can be optimized for UTF-8.  */
  memset(&cur_state, 0, sizeof(mbstate_t));
  while (p < buf)
    {
      size_t mbclen = mbrlen(p, end - p, &cur_state);

      /* Store the beginning of the previous complete multibyte character.  */
      if (mbclen != (size_t) -2)
        prev = p;

      if (mbclen == (size_t) -1 || mbclen == (size_t) -2 || mbclen == 0)
	{
	  /* An invalid sequence, or a truncated multibyte character.
	     We treat it as a single byte character.  */
	  mbclen = 1;
	}
      p += mbclen;
    }

  *good = prev;
  return p > buf;
}
#endif /* MBS_SUPPORT */

#if defined(GREP_PROGRAM) || defined(EGREP_PROGRAM)
#ifdef EGREP_PROGRAM
COMPILE_FCT(Ecompile)
{
  reg_syntax_t syntax_bits = RE_SYNTAX_POSIX_EGREP;
#else
/* No __VA_ARGS__ in C89.  So we have to do it this way.  */
static COMPILE_RET
GEAcompile (char const *pattern, size_t size, reg_syntax_t syntax_bits)
{
#endif /* EGREP_PROGRAM */
  const char *err;
  const char *p, *sep;
  size_t total = size;
  char *motif;

  if (match_icase)
    syntax_bits |= RE_ICASE;
  re_set_syntax (syntax_bits);
  dfasyntax (syntax_bits, match_icase, eolbyte);

  /* For GNU regex compiler we have to pass the patterns separately to detect
     errors like "[\nallo\n]\n".  The patterns here are "[", "allo" and "]"
     GNU regex should have raise a syntax error.  The same for backref, where
     the backref should have been local to each pattern.  */
  p = pattern;
  do
    {
      size_t len;
      sep = memchr (p, '\n', total);
      if (sep)
	{
	  len = sep - p;
	  sep++;
	  total -= (len + 1);
	}
      else
	{
	  len = total;
	  total = 0;
	}

      patterns = realloc (patterns, (pcount + 1) * sizeof (*patterns));
      if (patterns == NULL)
	error (EXIT_TROUBLE, errno, _("memory exhausted"));
      patterns[pcount] = patterns0;

      if ((err = re_compile_pattern (p, len,
				    &(patterns[pcount].regexbuf))) != NULL)
	error (EXIT_TROUBLE, 0, "%s", err);
      pcount++;

      p = sep;
    } while (sep && total != 0);

  /* In the match_words and match_lines cases, we use a different pattern
     for the DFA matcher that will quickly throw out cases that won't work.
     Then if DFA succeeds we do some hairy stuff using the regex matcher
     to decide whether the match should really count. */
  if (match_words || match_lines)
    {
      static char const line_beg_no_bk[] = "^(";
      static char const line_end_no_bk[] = ")$";
      static char const word_beg_no_bk[] = "(^|[^[:alnum:]_])(";
      static char const word_end_no_bk[] = ")([^[:alnum:]_]|$)";
#ifdef EGREP_PROGRAM
# define IF_BK(x, y) (y)
      char *n = xmalloc (sizeof word_beg_no_bk - 1 + size + sizeof word_end_no_bk);
#else
      static char const line_beg_bk[] = "^\\(";
      static char const line_end_bk[] = "\\)$";
      static char const word_beg_bk[] = "\\(^\\|[^[:alnum:]_]\\)\\(";
      static char const word_end_bk[] = "\\)\\([^[:alnum:]_]\\|$\\)";
      int bk = !(syntax_bits & RE_NO_BK_PARENS);
# define IF_BK(x, y) ((bk) ? (x) : (y))
      char *n = xmalloc (sizeof word_beg_bk - 1 + size + sizeof word_end_bk);
#endif /* EGREP_PROGRAM */

      strcpy (n, match_lines ? IF_BK(line_beg_bk, line_beg_no_bk)
			     : IF_BK(word_beg_bk, word_beg_no_bk));
      total = strlen(n);
      memcpy (n + total, pattern, size);
      total += size;
      strcpy (n + total, match_lines ? IF_BK(line_end_bk, line_end_no_bk)
				     : IF_BK(word_end_bk, word_end_no_bk));
      total += strlen (n + total);
      pattern = motif = n;
      size = total;
    }
  else
    motif = NULL;

  dfacomp (pattern, size, &dfa, 1);
  kwsmusts ();

  free(motif);
}

#ifndef EGREP_PROGRAM
COMPILE_FCT(Gcompile)
{
  return GEAcompile (pattern, size,
		     RE_SYNTAX_GREP | RE_HAT_LISTS_NOT_NEWLINE);
}

COMPILE_FCT(Acompile)
{
  return GEAcompile (pattern, size, RE_SYNTAX_AWK);
}

COMPILE_FCT(Ecompile)
{
  return GEAcompile (pattern, size, RE_SYNTAX_POSIX_EGREP);
}
#endif /* !EGREP_PROGRAM */

EXECUTE_FCT(EGexecute)
{
  char const *buflim, *beg, *end, *match, *best_match, *mb_start;
  char eol = eolbyte;
  int backref, start, len, best_len;
  struct kwsmatch kwsm;
  size_t i, ret_val;
#ifdef MBS_SUPPORT
  if (MB_CUR_MAX > 1)
    {
      if (match_icase)
        {
          /* mbtolower adds a NUL byte at the end.  That will provide
	     space for the sentinel byte dfaexec may add.  */
          char *case_buf = mbtolower (buf, &size);
	  if (start_ptr)
	    start_ptr = case_buf + (start_ptr - buf);
          buf = case_buf;
        }
    }
#endif /* MBS_SUPPORT */

  mb_start = buf;
  buflim = buf + size;

  for (beg = end = buf; end < buflim; beg = end)
    {
      if (!start_ptr)
	{
	  /* We don't care about an exact match.  */
	  if (kwset)
	    {
	      /* Find a possible match using the KWset matcher. */
	      size_t offset = kwsexec (kwset, beg, buflim - beg, &kwsm);
	      if (offset == (size_t) -1)
		goto failure;
	      beg += offset;
	      /* Narrow down to the line containing the candidate, and
		 run it through DFA. */
	      if ((end = memchr(beg, eol, buflim - beg)) != NULL)
	        end++;
              else
                end = buflim;
	      match = beg;
	      while (beg > buf && beg[-1] != eol)
		--beg;
	      if (kwsm.index < kwset_exact_matches)
                {
#ifdef MBS_SUPPORT
                  if (mb_start < beg)
                    mb_start = beg;
                  if (MB_CUR_MAX == 1 || !is_mb_middle (&mb_start, match, buflim))
#endif
                    goto success;
                }
	      if (dfaexec (&dfa, beg, (char *) end, 0, NULL, &backref) == NULL)
		continue;
	    }
	  else
	    {
	      /* No good fixed strings; start with DFA. */
	      char const *next_beg = dfaexec (&dfa, beg, (char *) buflim,
					      0, NULL, &backref);
	      if (next_beg == NULL)
		break;
	      /* Narrow down to the line we've found. */
	      beg = next_beg;
	      if ((end = memchr(beg, eol, buflim - beg)) != NULL)
	        end++;
              else
                end = buflim;
	      while (beg > buf && beg[-1] != eol)
		--beg;
	    }
	  /* Successful, no backreferences encountered! */
	  if (!backref)
	    goto success;
	}
      else
	{
	  /* We are looking for the leftmost (then longest) exact match.
	     We will go through the outer loop only once.  */
	  beg = start_ptr;
	  end = buflim;
	}

      /* If we've made it to this point, this means DFA has seen
	 a probable match, and we need to run it through Regex. */
      best_match = end;
      best_len = 0;
      for (i = 0; i < pcount; i++)
	{
	  patterns[i].regexbuf.not_eol = 0;
	  if (0 <= (start = re_search (&(patterns[i].regexbuf),
				       buf, end - buf - 1,
				       beg - buf, end - beg - 1,
				       &(patterns[i].regs))))
	    {
	      len = patterns[i].regs.end[0] - start;
	      match = buf + start;
	      if (match > best_match)
		continue;
	      if (start_ptr && !match_words)
		goto assess_pattern_match;
	      if ((!match_lines && !match_words)
		  || (match_lines && len == end - beg - 1))
		{
		  match = beg;
		  len = end - beg;
		  goto assess_pattern_match;
		}
	      /* If -w, check if the match aligns with word boundaries.
		 We do this iteratively because:
		 (a) the line may contain more than one occurence of the
		 pattern, and
		 (b) Several alternatives in the pattern might be valid at a
		 given point, and we may need to consider a shorter one to
		 find a word boundary.  */
	      if (match_words)
		while (match <= best_match)
		  {
		    if ((match == buf || !WCHAR ((unsigned char) match[-1]))
			&& (len == end - beg - 1
			    || !WCHAR ((unsigned char) match[len])))
		      goto assess_pattern_match;
		    if (len > 0)
		      {
			/* Try a shorter length anchored at the same place. */
			--len;
			patterns[i].regexbuf.not_eol = 1;
			len = re_match (&(patterns[i].regexbuf),
					buf, match + len - beg, match - buf,
					&(patterns[i].regs));
		      }
		    if (len <= 0)
		      {
			/* Try looking further on. */
			if (match == end - 1)
			  break;
			match++;
			patterns[i].regexbuf.not_eol = 0;
			start = re_search (&(patterns[i].regexbuf),
					   buf, end - buf - 1,
					   match - buf, end - match - 1,
					   &(patterns[i].regs));
			if (start < 0)
			  break;
			len = patterns[i].regs.end[0] - start;
			match = buf + start;
		      }
		  } /* while (match <= best_match) */
	      continue;
	    assess_pattern_match:
	      if (!start_ptr)
		{
		  /* Good enough for a non-exact match.
		     No need to look at further patterns, if any.  */
		  beg = match;
		  goto success_in_len;
		}
	      if (match < best_match || (match == best_match && len > best_len))
		{
		  /* Best exact match:  leftmost, then longest.  */
		  best_match = match;
		  best_len = len;
		}
	    } /* if re_search >= 0 */
	} /* for Regex patterns.  */
	if (best_match < end)
	  {
	    /* We have found an exact match.  We were just
	       waiting for the best one (leftmost then longest).  */
	    beg = best_match;
	    len = best_len;
	    goto success_in_len;
	  }
    } /* for (beg = end ..) */

 failure:
  ret_val = -1;
  goto out;

 success:
  len = end - beg;
 success_in_len:
  *match_size = len;
  ret_val = beg - buf;
 out:
  return ret_val;
}
#endif /* defined(GREP_PROGRAM) || defined(EGREP_PROGRAM) */

#if defined(GREP_PROGRAM) || defined(FGREP_PROGRAM)
COMPILE_FCT(Fcompile)
{
  char const *beg, *end, *lim, *err, *pat;
  size_t psize;

  kwsinit ();
  psize = size;
  if (match_icase && MB_CUR_MAX > 1)
    pat = mbtolower (pattern, &psize);
  else
    pat = pattern;

  beg = pat;
  do
    {
      for (lim = beg;; ++lim)
	{
	  end = lim;
	  if (lim >= pat + psize)
	    break;
	 if (*lim == '\n')
	   {
	     lim++;
	     break;
	   }
#if HAVE_DOS_FILE_CONTENTS
	 if (*lim == '\r' && lim + 1 < pat + psize && lim[1] == '\n')
	   {
	     lim += 2;
	     break;
	   }
#endif
	}

      if ((err = kwsincr (kwset, beg, end - beg)) != NULL)
	error (EXIT_TROUBLE, 0, "%s", err);
      beg = lim;
    }
  while (beg < pat + psize);

  if ((err = kwsprep (kwset)) != NULL)
    error (EXIT_TROUBLE, 0, "%s", err);
}

EXECUTE_FCT(Fexecute)
{
  char const *beg, *try, *end, *mb_start;
  size_t len;
  char eol = eolbyte;
  struct kwsmatch kwsmatch;
  size_t ret_val;
#ifdef MBS_SUPPORT
  if (MB_CUR_MAX > 1)
    {
      if (match_icase)
        {
          char *case_buf = mbtolower (buf, &size);
	  if (start_ptr)
	    start_ptr = case_buf + (start_ptr - buf);
          buf = case_buf;
        }
    }
#endif /* MBS_SUPPORT */

  for (mb_start = beg = start_ptr ? start_ptr : buf; beg <= buf + size; beg++)
    {
      size_t offset = kwsexec (kwset, beg, buf + size - beg, &kwsmatch);
      
//Patch 0:
if ((offset == (size_t)-1) && !(__is_neg(18, &(offset), sizeof (offset), &(buf), sizeof (buf), &(size), sizeof (size), &(beg), sizeof (beg), &(kwset), sizeof (kwset), &(start_ptr), sizeof (start_ptr), &(mb_start), sizeof (mb_start), &(len), sizeof (len), &(match_words), sizeof (match_words), &(match_icase), sizeof (match_icase), &(match_lines), sizeof (match_lines), &(eol), sizeof (eol), &(eolbyte), sizeof (eolbyte), &(try), sizeof (try), &(ret_val), sizeof (ret_val), &(end), sizeof (end), &(match_size), sizeof (match_size), &(kwsmatch.index), sizeof (kwsmatch.index))))
    goto failure;

//CodeSeg 1:
#ifdef MBS_SUPPORT
      if (MB_CUR_MAX > 1 && is_mb_middle (&mb_start, beg + offset, buf + size))
        {
          beg = mb_start - 1;
          continue; /* It is a part of multibyte character.  */
        }
#endif /* MBS_SUPPORT */
      beg += offset;
      len = kwsmatch.size[0];
      if (start_ptr && !match_words)
	goto success_in_beg_and_len;
      if (match_lines)
	{
	  if (beg > buf && beg[-1] != eol)
	    continue;
	  if (beg + len < buf + size && beg[len] != eol)
	    continue;
	  goto success;
	}
      else if (match_words)
	for (try = beg; len; )
	  {
	    if (try > buf && WCHAR((unsigned char) try[-1]))
	      break;
	    if (try + len < buf + size && WCHAR((unsigned char) try[len]))
	      {
		offset = kwsexec (kwset, beg, --len, &kwsmatch);
		if (offset == (size_t) -1)
		  break;
		try = beg + offset;
		len = kwsmatch.size[0];
	      }
	    else if (!start_ptr)
	      goto success;
	    else
	      goto success_in_beg_and_len;
	  } /* for (try) */
      else
	goto success;
    } /* for (beg in buf) */

 failure:
  ret_val = -1;
  goto out;

 success:
  if ((end = memchr (beg + len, eol, (buf + size) - (beg + len))) != NULL)
    end++;
  else
    end = buf + size;
  while (buf < beg && beg[-1] != eol)
    --beg;
  len = end - beg;
 success_in_beg_and_len:
  *match_size = len;
  ret_val = beg - buf;
 out:
  return ret_val;
}
#endif /* defined(GREP_PROGRAM) || defined(FGREP_PROGRAM) */

#ifdef GREP_PROGRAM
#if HAVE_LIBPCRE
/* Compiled internal form of a Perl regular expression.  */
static pcre *cre;

/* Additional information about the pattern.  */
static pcre_extra *extra;
#endif

COMPILE_FCT(Pcompile)
{
#if !HAVE_LIBPCRE
  error (EXIT_TROUBLE, 0, "%s",
	 _("support for the -P option is not compiled into "
	   "this --disable-perl-regexp binary"));
#else
  int e;
  char const *ep;
  char *re = xmalloc (4 * size + 7);
  int flags = PCRE_MULTILINE | (match_icase ? PCRE_CASELESS : 0);
  char const *patlim = pattern + size;
  char *n = re;
  char const *p;
  char const *pnul;

  /* FIXME: Remove these restrictions.  */
  if (memchr(pattern, '\n', size))
    error (EXIT_TROUBLE, 0, _("the -P option only supports a single pattern"));

  *n = '\0';
  if (match_lines)
    strcpy (n, "^(");
  if (match_words)
    strcpy (n, "\\b(");
  n += strlen (n);

  /* The PCRE interface doesn't allow NUL bytes in the pattern, so
     replace each NUL byte in the pattern with the four characters
     "\000", removing a preceding backslash if there are an odd
     number of backslashes before the NUL.

     FIXME: This method does not work with some multibyte character
     encodings, notably Shift-JIS, where a multibyte character can end
     in a backslash byte.  */
  for (p = pattern; (pnul = memchr (p, '\0', patlim - p)); p = pnul + 1)
    {
      memcpy (n, p, pnul - p);
      n += pnul - p;
      for (p = pnul; pattern < p && p[-1] == '\\'; p--)
	continue;
      n -= (pnul - p) & 1;
      strcpy (n, "\\000");
      n += 4;
    }

  memcpy (n, p, patlim - p);
  n += patlim - p;
  *n = '\0';
  if (match_words)
    strcpy (n, ")\\b");
  if (match_lines)
    strcpy (n, ")$");

  cre = pcre_compile (re, flags, &ep, &e, pcre_maketables ());
  if (!cre)
    error (EXIT_TROUBLE, 0, "%s", ep);

  extra = pcre_study (cre, 0, &ep);
  if (ep)
    error (EXIT_TROUBLE, 0, "%s", ep);

  free (re);
#endif
}

EXECUTE_FCT(Pexecute)
{
#if !HAVE_LIBPCRE
  abort ();
  return -1;
#else
  /* This array must have at least two elements; everything after that
     is just for performance improvement in pcre_exec.  */
  int sub[300];

  const char *line_buf, *line_end, *line_next;
  int e = PCRE_ERROR_NOMATCH;
  ptrdiff_t start_ofs = start_ptr ? start_ptr - buf : 0;

  /* PCRE can't limit the matching to single lines, therefore we have to
     match each line in the buffer separately.  */
  for (line_next = buf;
       e == PCRE_ERROR_NOMATCH && line_next < buf + size;
       start_ofs -= line_next - line_buf)
    {
      line_buf = line_next;
      line_end = memchr (line_buf, eolbyte, (buf + size) - line_buf);
      if (line_end == NULL)
        line_next = line_end = buf + size;
      else
        line_next = line_end + 1;

      if (start_ptr && start_ptr >= line_end)
        continue;

      e = pcre_exec (cre, extra, line_buf, line_end - line_buf,
                     start_ofs < 0 ? 0 : start_ofs, 0,
                     sub, sizeof sub / sizeof *sub);
    }

  if (e <= 0)
    {
      switch (e)
	{
	case PCRE_ERROR_NOMATCH:
	  return -1;

	case PCRE_ERROR_NOMEMORY:
	  error (EXIT_TROUBLE, 0, _("memory exhausted"));

	default:
	  abort ();
	}
    }
  else
    {
      /* Narrow down to the line we've found.  */
      char const *beg = line_buf + sub[0];
      char const *end = line_buf + sub[1];
      char const *buflim = buf + size;
      char eol = eolbyte;
      if (!start_ptr)
	{
	  /* FIXME: The case when '\n' is not found indicates a bug:
	     Since grep is line oriented, the match should never contain
	     a newline, so there _must_ be a newline following.
	   */
	  if (!(end = memchr (end, eol, buflim - end)))
	    end = buflim;
	  else
	    end++;
	  while (buf < beg && beg[-1] != eol)
	    --beg;
	}

      *match_size = end - beg;
      return beg - buf;
    }
#endif
}

struct matcher const matchers[] = {
  { "default", Gcompile, EGexecute },
  { "grep",    Gcompile, EGexecute },
  { "egrep",   Ecompile, EGexecute },
  { "awk",     Acompile, EGexecute },
  { "fgrep",   Fcompile, Fexecute },
  { "perl",    Pcompile, Pexecute },
  { "", 0, 0 },
};
#endif /* GREP_PROGRAM */

Spawn 1 instances, now Total 22
Counter: 23
Batcher Size:22
Preprocess the following candidate with CondTester:
Priority 20000
At location src/search.c:636
--Src File: src/search.c
Fragment 0:
if ((offset == (size_t)-1) || (__abst_hole(offset, buf, size, beg, kwset, start_ptr, mb_start, len, match_words, match_icase, match_lines, eol, eolbyte, try, ret_val, end, match_size, kwsmatch.index)))
    goto failure;


CondTester, a patch instance with id 22:
//src_file:src/search.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
/* search.c - searching subroutines using dfa, kwset and regex for grep.
   Copyright 1992, 1998, 2000, 2007, 2009-2010 Free Software Foundation, Inc.

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 3, or (at your option)
   any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program; if not, write to the Free Software
   Foundation, Inc., 51 Franklin Street - Fifth Floor, Boston, MA
   02110-1301, USA.  */

/* Written August 1992 by Mike Haertel. */

#include <config.h>

#include <sys/types.h>

#include "mbsupport.h"
#ifdef MBS_SUPPORT
/* We can handle multibyte strings. */
# include <wchar.h>
# include <wctype.h>
#endif

#include "system.h"
#include "grep.h"
#ifndef FGREP_PROGRAM
# include <regex.h>
# include "dfa.h"
#endif
#include "kwset.h"
#include "error.h"
#include "xalloc.h"
#ifdef HAVE_LIBPCRE
# include <pcre.h>
#endif

#define NCHAR (UCHAR_MAX + 1)

/* For -w, we also consider _ to be word constituent.  */
#define WCHAR(C) (ISALNUM(C) || (C) == '_')

/* KWset compiled pattern.  For Ecompile and Gcompile, we compile
   a list of strings, at least one of which is known to occur in
   any string matching the regexp. */
static kwset_t kwset;

static void
kwsinit (void)
{
  static char trans[NCHAR];
  int i;

  if (match_icase && MB_CUR_MAX == 1)
    {
      for (i = 0; i < NCHAR; ++i)
        trans[i] = TOLOWER (i);

      kwset = kwsalloc (trans);
    }
  else
    kwset = kwsalloc (NULL);

  if (!kwset)
    xalloc_die ();
}

#ifdef MBS_SUPPORT
/* Convert the *N-byte string, BEG, to lowercase, and write the
   NUL-terminated result into malloc'd storage.  Upon success, set *N
   to the length (in bytes) of the resulting string (not including the
   trailing NUL byte), and return a pointer to the lowercase string.
   Upon memory allocation failure, this function exits.

   Note that while this function returns a pointer to malloc'd storage,
   the caller must not free it, since this function retains a pointer
   to the buffer and reuses it on any subsequent call.  As a consequence,
   this function is not thread-safe.  */
static char *
mbtolower (const char *beg, size_t *n)
{
  static char *out;
  static size_t outalloc;
  size_t outlen, mb_cur_max;
  mbstate_t is, os;
  const char *end;
  char *p;

  if (*n > outalloc)
    {
      out = xrealloc (out, *n);
      outalloc = *n;
    }

  memset (&is, 0, sizeof (is));
  memset (&os, 0, sizeof (os));
  end = beg + *n;

  mb_cur_max = MB_CUR_MAX;
  p = out;
  outlen = 0;
  while (beg < end)
    {
      wchar_t wc;
      size_t mbclen = mbrtowc(&wc, beg, end - beg, &is);
      if (outlen + mb_cur_max >= outalloc)
        {
          out = x2nrealloc (out, &outalloc, 1);
          p = out + outlen;
        }

      if (mbclen == (size_t) -1 || mbclen == (size_t) -2 || mbclen == 0)
        {
          /* An invalid sequence, or a truncated multi-octet character.
             We treat it as a single-octet character.  */
          *p++ = *beg++;
          outlen++;
          memset (&is, 0, sizeof (is));
          memset (&os, 0, sizeof (os));
        }
      else
        {
          beg += mbclen;
          mbclen = wcrtomb (p, towlower ((wint_t) wc), &os);
          p += mbclen;
          outlen += mbclen;
        }
    }

  *n = p - out;
  *p++ = 0;
  return out;
}
#endif


#ifndef FGREP_PROGRAM
/* DFA compiled regexp. */
static struct dfa dfa;

/* The Regex compiled patterns.  */
static struct patterns
{
  /* Regex compiled regexp. */
  struct re_pattern_buffer regexbuf;
  struct re_registers regs; /* This is here on account of a BRAIN-DEAD
			       Q@#%!# library interface in regex.c.  */
} patterns0;

struct patterns *patterns;
size_t pcount;

void
dfaerror (char const *mesg)
{
  error (EXIT_TROUBLE, 0, "%s", mesg);
}

/* Number of compiled fixed strings known to exactly match the regexp.
   If kwsexec returns < kwset_exact_matches, then we don't need to
   call the regexp matcher at all. */
static int kwset_exact_matches;

static char const *
kwsincr_case (const char *must)
{
  const char *buf;
  size_t n;

  n = strlen (must);
#ifdef MBS_SUPPORT
  if (match_icase && MB_CUR_MAX > 1)
    buf = mbtolower (must, &n);
  else
#endif
    buf = must;
  return kwsincr (kwset, buf, n);
}

/* If the DFA turns out to have some set of fixed strings one of
   which must occur in the match, then we build a kwset matcher
   to find those strings, and thus quickly filter out impossible
   matches. */
static void
kwsmusts (void)
{
  struct dfamust const *dm;
  char const *err;

  if (dfa.musts)
    {
      kwsinit ();
      /* First, we compile in the substrings known to be exact
	 matches.  The kwset matcher will return the index
	 of the matching string that it chooses. */
      for (dm = dfa.musts; dm; dm = dm->next)
	{
	  if (!dm->exact)
	    continue;
	  ++kwset_exact_matches;
	  if ((err = kwsincr_case (dm->must)) != NULL)
	    error (EXIT_TROUBLE, 0, "%s", err);
	}
      /* Now, we compile the substrings that will require
	 the use of the regexp matcher.  */
      for (dm = dfa.musts; dm; dm = dm->next)
	{
	  if (dm->exact)
	    continue;
	  if ((err = kwsincr_case (dm->must)) != NULL)
	    error (EXIT_TROUBLE, 0, "%s", err);
	}
      if ((err = kwsprep (kwset)) != NULL)
	error (EXIT_TROUBLE, 0, "%s", err);
    }
}
#endif /* !FGREP_PROGRAM */

#ifdef MBS_SUPPORT

static bool
is_mb_middle(const char **good, const char *buf, const char *end)
{
  const char *p = *good;
  const char *prev = p;
  mbstate_t cur_state;

  /* TODO: can be optimized for UTF-8.  */
  memset(&cur_state, 0, sizeof(mbstate_t));
  while (p < buf)
    {
      size_t mbclen = mbrlen(p, end - p, &cur_state);

      /* Store the beginning of the previous complete multibyte character.  */
      if (mbclen != (size_t) -2)
        prev = p;

      if (mbclen == (size_t) -1 || mbclen == (size_t) -2 || mbclen == 0)
	{
	  /* An invalid sequence, or a truncated multibyte character.
	     We treat it as a single byte character.  */
	  mbclen = 1;
	}
      p += mbclen;
    }

  *good = prev;
  return p > buf;
}
#endif /* MBS_SUPPORT */

#if defined(GREP_PROGRAM) || defined(EGREP_PROGRAM)
#ifdef EGREP_PROGRAM
COMPILE_FCT(Ecompile)
{
  reg_syntax_t syntax_bits = RE_SYNTAX_POSIX_EGREP;
#else
/* No __VA_ARGS__ in C89.  So we have to do it this way.  */
static COMPILE_RET
GEAcompile (char const *pattern, size_t size, reg_syntax_t syntax_bits)
{
#endif /* EGREP_PROGRAM */
  const char *err;
  const char *p, *sep;
  size_t total = size;
  char *motif;

  if (match_icase)
    syntax_bits |= RE_ICASE;
  re_set_syntax (syntax_bits);
  dfasyntax (syntax_bits, match_icase, eolbyte);

  /* For GNU regex compiler we have to pass the patterns separately to detect
     errors like "[\nallo\n]\n".  The patterns here are "[", "allo" and "]"
     GNU regex should have raise a syntax error.  The same for backref, where
     the backref should have been local to each pattern.  */
  p = pattern;
  do
    {
      size_t len;
      sep = memchr (p, '\n', total);
      if (sep)
	{
	  len = sep - p;
	  sep++;
	  total -= (len + 1);
	}
      else
	{
	  len = total;
	  total = 0;
	}

      patterns = realloc (patterns, (pcount + 1) * sizeof (*patterns));
      if (patterns == NULL)
	error (EXIT_TROUBLE, errno, _("memory exhausted"));
      patterns[pcount] = patterns0;

      if ((err = re_compile_pattern (p, len,
				    &(patterns[pcount].regexbuf))) != NULL)
	error (EXIT_TROUBLE, 0, "%s", err);
      pcount++;

      p = sep;
    } while (sep && total != 0);

  /* In the match_words and match_lines cases, we use a different pattern
     for the DFA matcher that will quickly throw out cases that won't work.
     Then if DFA succeeds we do some hairy stuff using the regex matcher
     to decide whether the match should really count. */
  if (match_words || match_lines)
    {
      static char const line_beg_no_bk[] = "^(";
      static char const line_end_no_bk[] = ")$";
      static char const word_beg_no_bk[] = "(^|[^[:alnum:]_])(";
      static char const word_end_no_bk[] = ")([^[:alnum:]_]|$)";
#ifdef EGREP_PROGRAM
# define IF_BK(x, y) (y)
      char *n = xmalloc (sizeof word_beg_no_bk - 1 + size + sizeof word_end_no_bk);
#else
      static char const line_beg_bk[] = "^\\(";
      static char const line_end_bk[] = "\\)$";
      static char const word_beg_bk[] = "\\(^\\|[^[:alnum:]_]\\)\\(";
      static char const word_end_bk[] = "\\)\\([^[:alnum:]_]\\|$\\)";
      int bk = !(syntax_bits & RE_NO_BK_PARENS);
# define IF_BK(x, y) ((bk) ? (x) : (y))
      char *n = xmalloc (sizeof word_beg_bk - 1 + size + sizeof word_end_bk);
#endif /* EGREP_PROGRAM */

      strcpy (n, match_lines ? IF_BK(line_beg_bk, line_beg_no_bk)
			     : IF_BK(word_beg_bk, word_beg_no_bk));
      total = strlen(n);
      memcpy (n + total, pattern, size);
      total += size;
      strcpy (n + total, match_lines ? IF_BK(line_end_bk, line_end_no_bk)
				     : IF_BK(word_end_bk, word_end_no_bk));
      total += strlen (n + total);
      pattern = motif = n;
      size = total;
    }
  else
    motif = NULL;

  dfacomp (pattern, size, &dfa, 1);
  kwsmusts ();

  free(motif);
}

#ifndef EGREP_PROGRAM
COMPILE_FCT(Gcompile)
{
  return GEAcompile (pattern, size,
		     RE_SYNTAX_GREP | RE_HAT_LISTS_NOT_NEWLINE);
}

COMPILE_FCT(Acompile)
{
  return GEAcompile (pattern, size, RE_SYNTAX_AWK);
}

COMPILE_FCT(Ecompile)
{
  return GEAcompile (pattern, size, RE_SYNTAX_POSIX_EGREP);
}
#endif /* !EGREP_PROGRAM */

EXECUTE_FCT(EGexecute)
{
  char const *buflim, *beg, *end, *match, *best_match, *mb_start;
  char eol = eolbyte;
  int backref, start, len, best_len;
  struct kwsmatch kwsm;
  size_t i, ret_val;
#ifdef MBS_SUPPORT
  if (MB_CUR_MAX > 1)
    {
      if (match_icase)
        {
          /* mbtolower adds a NUL byte at the end.  That will provide
	     space for the sentinel byte dfaexec may add.  */
          char *case_buf = mbtolower (buf, &size);
	  if (start_ptr)
	    start_ptr = case_buf + (start_ptr - buf);
          buf = case_buf;
        }
    }
#endif /* MBS_SUPPORT */

  mb_start = buf;
  buflim = buf + size;

  for (beg = end = buf; end < buflim; beg = end)
    {
      if (!start_ptr)
	{
	  /* We don't care about an exact match.  */
	  if (kwset)
	    {
	      /* Find a possible match using the KWset matcher. */
	      size_t offset = kwsexec (kwset, beg, buflim - beg, &kwsm);
	      if (offset == (size_t) -1)
		goto failure;
	      beg += offset;
	      /* Narrow down to the line containing the candidate, and
		 run it through DFA. */
	      if ((end = memchr(beg, eol, buflim - beg)) != NULL)
	        end++;
              else
                end = buflim;
	      match = beg;
	      while (beg > buf && beg[-1] != eol)
		--beg;
	      if (kwsm.index < kwset_exact_matches)
                {
#ifdef MBS_SUPPORT
                  if (mb_start < beg)
                    mb_start = beg;
                  if (MB_CUR_MAX == 1 || !is_mb_middle (&mb_start, match, buflim))
#endif
                    goto success;
                }
	      if (dfaexec (&dfa, beg, (char *) end, 0, NULL, &backref) == NULL)
		continue;
	    }
	  else
	    {
	      /* No good fixed strings; start with DFA. */
	      char const *next_beg = dfaexec (&dfa, beg, (char *) buflim,
					      0, NULL, &backref);
	      if (next_beg == NULL)
		break;
	      /* Narrow down to the line we've found. */
	      beg = next_beg;
	      if ((end = memchr(beg, eol, buflim - beg)) != NULL)
	        end++;
              else
                end = buflim;
	      while (beg > buf && beg[-1] != eol)
		--beg;
	    }
	  /* Successful, no backreferences encountered! */
	  if (!backref)
	    goto success;
	}
      else
	{
	  /* We are looking for the leftmost (then longest) exact match.
	     We will go through the outer loop only once.  */
	  beg = start_ptr;
	  end = buflim;
	}

      /* If we've made it to this point, this means DFA has seen
	 a probable match, and we need to run it through Regex. */
      best_match = end;
      best_len = 0;
      for (i = 0; i < pcount; i++)
	{
	  patterns[i].regexbuf.not_eol = 0;
	  if (0 <= (start = re_search (&(patterns[i].regexbuf),
				       buf, end - buf - 1,
				       beg - buf, end - beg - 1,
				       &(patterns[i].regs))))
	    {
	      len = patterns[i].regs.end[0] - start;
	      match = buf + start;
	      if (match > best_match)
		continue;
	      if (start_ptr && !match_words)
		goto assess_pattern_match;
	      if ((!match_lines && !match_words)
		  || (match_lines && len == end - beg - 1))
		{
		  match = beg;
		  len = end - beg;
		  goto assess_pattern_match;
		}
	      /* If -w, check if the match aligns with word boundaries.
		 We do this iteratively because:
		 (a) the line may contain more than one occurence of the
		 pattern, and
		 (b) Several alternatives in the pattern might be valid at a
		 given point, and we may need to consider a shorter one to
		 find a word boundary.  */
	      if (match_words)
		while (match <= best_match)
		  {
		    if ((match == buf || !WCHAR ((unsigned char) match[-1]))
			&& (len == end - beg - 1
			    || !WCHAR ((unsigned char) match[len])))
		      goto assess_pattern_match;
		    if (len > 0)
		      {
			/* Try a shorter length anchored at the same place. */
			--len;
			patterns[i].regexbuf.not_eol = 1;
			len = re_match (&(patterns[i].regexbuf),
					buf, match + len - beg, match - buf,
					&(patterns[i].regs));
		      }
		    if (len <= 0)
		      {
			/* Try looking further on. */
			if (match == end - 1)
			  break;
			match++;
			patterns[i].regexbuf.not_eol = 0;
			start = re_search (&(patterns[i].regexbuf),
					   buf, end - buf - 1,
					   match - buf, end - match - 1,
					   &(patterns[i].regs));
			if (start < 0)
			  break;
			len = patterns[i].regs.end[0] - start;
			match = buf + start;
		      }
		  } /* while (match <= best_match) */
	      continue;
	    assess_pattern_match:
	      if (!start_ptr)
		{
		  /* Good enough for a non-exact match.
		     No need to look at further patterns, if any.  */
		  beg = match;
		  goto success_in_len;
		}
	      if (match < best_match || (match == best_match && len > best_len))
		{
		  /* Best exact match:  leftmost, then longest.  */
		  best_match = match;
		  best_len = len;
		}
	    } /* if re_search >= 0 */
	} /* for Regex patterns.  */
	if (best_match < end)
	  {
	    /* We have found an exact match.  We were just
	       waiting for the best one (leftmost then longest).  */
	    beg = best_match;
	    len = best_len;
	    goto success_in_len;
	  }
    } /* for (beg = end ..) */

 failure:
  ret_val = -1;
  goto out;

 success:
  len = end - beg;
 success_in_len:
  *match_size = len;
  ret_val = beg - buf;
 out:
  return ret_val;
}
#endif /* defined(GREP_PROGRAM) || defined(EGREP_PROGRAM) */

#if defined(GREP_PROGRAM) || defined(FGREP_PROGRAM)
COMPILE_FCT(Fcompile)
{
  char const *beg, *end, *lim, *err, *pat;
  size_t psize;

  kwsinit ();
  psize = size;
  if (match_icase && MB_CUR_MAX > 1)
    pat = mbtolower (pattern, &psize);
  else
    pat = pattern;

  beg = pat;
  do
    {
      for (lim = beg;; ++lim)
	{
	  end = lim;
	  if (lim >= pat + psize)
	    break;
	 if (*lim == '\n')
	   {
	     lim++;
	     break;
	   }
#if HAVE_DOS_FILE_CONTENTS
	 if (*lim == '\r' && lim + 1 < pat + psize && lim[1] == '\n')
	   {
	     lim += 2;
	     break;
	   }
#endif
	}

      if ((err = kwsincr (kwset, beg, end - beg)) != NULL)
	error (EXIT_TROUBLE, 0, "%s", err);
      beg = lim;
    }
  while (beg < pat + psize);

  if ((err = kwsprep (kwset)) != NULL)
    error (EXIT_TROUBLE, 0, "%s", err);
}

EXECUTE_FCT(Fexecute)
{
  char const *beg, *try, *end, *mb_start;
  size_t len;
  char eol = eolbyte;
  struct kwsmatch kwsmatch;
  size_t ret_val;
#ifdef MBS_SUPPORT
  if (MB_CUR_MAX > 1)
    {
      if (match_icase)
        {
          char *case_buf = mbtolower (buf, &size);
	  if (start_ptr)
	    start_ptr = case_buf + (start_ptr - buf);
          buf = case_buf;
        }
    }
#endif /* MBS_SUPPORT */

  for (mb_start = beg = start_ptr ? start_ptr : buf; beg <= buf + size; beg++)
    {
      size_t offset = kwsexec (kwset, beg, buf + size - beg, &kwsmatch);
      
//Patch 0:
if ((offset == (size_t)-1) || (__is_neg(18, &(offset), sizeof (offset), &(buf), sizeof (buf), &(size), sizeof (size), &(beg), sizeof (beg), &(kwset), sizeof (kwset), &(start_ptr), sizeof (start_ptr), &(mb_start), sizeof (mb_start), &(len), sizeof (len), &(match_words), sizeof (match_words), &(match_icase), sizeof (match_icase), &(match_lines), sizeof (match_lines), &(eol), sizeof (eol), &(eolbyte), sizeof (eolbyte), &(try), sizeof (try), &(ret_val), sizeof (ret_val), &(end), sizeof (end), &(match_size), sizeof (match_size), &(kwsmatch.index), sizeof (kwsmatch.index))))
    goto failure;

//CodeSeg 1:
#ifdef MBS_SUPPORT
      if (MB_CUR_MAX > 1 && is_mb_middle (&mb_start, beg + offset, buf + size))
        {
          beg = mb_start - 1;
          continue; /* It is a part of multibyte character.  */
        }
#endif /* MBS_SUPPORT */
      beg += offset;
      len = kwsmatch.size[0];
      if (start_ptr && !match_words)
	goto success_in_beg_and_len;
      if (match_lines)
	{
	  if (beg > buf && beg[-1] != eol)
	    continue;
	  if (beg + len < buf + size && beg[len] != eol)
	    continue;
	  goto success;
	}
      else if (match_words)
	for (try = beg; len; )
	  {
	    if (try > buf && WCHAR((unsigned char) try[-1]))
	      break;
	    if (try + len < buf + size && WCHAR((unsigned char) try[len]))
	      {
		offset = kwsexec (kwset, beg, --len, &kwsmatch);
		if (offset == (size_t) -1)
		  break;
		try = beg + offset;
		len = kwsmatch.size[0];
	      }
	    else if (!start_ptr)
	      goto success;
	    else
	      goto success_in_beg_and_len;
	  } /* for (try) */
      else
	goto success;
    } /* for (beg in buf) */

 failure:
  ret_val = -1;
  goto out;

 success:
  if ((end = memchr (beg + len, eol, (buf + size) - (beg + len))) != NULL)
    end++;
  else
    end = buf + size;
  while (buf < beg && beg[-1] != eol)
    --beg;
  len = end - beg;
 success_in_beg_and_len:
  *match_size = len;
  ret_val = beg - buf;
 out:
  return ret_val;
}
#endif /* defined(GREP_PROGRAM) || defined(FGREP_PROGRAM) */

#ifdef GREP_PROGRAM
#if HAVE_LIBPCRE
/* Compiled internal form of a Perl regular expression.  */
static pcre *cre;

/* Additional information about the pattern.  */
static pcre_extra *extra;
#endif

COMPILE_FCT(Pcompile)
{
#if !HAVE_LIBPCRE
  error (EXIT_TROUBLE, 0, "%s",
	 _("support for the -P option is not compiled into "
	   "this --disable-perl-regexp binary"));
#else
  int e;
  char const *ep;
  char *re = xmalloc (4 * size + 7);
  int flags = PCRE_MULTILINE | (match_icase ? PCRE_CASELESS : 0);
  char const *patlim = pattern + size;
  char *n = re;
  char const *p;
  char const *pnul;

  /* FIXME: Remove these restrictions.  */
  if (memchr(pattern, '\n', size))
    error (EXIT_TROUBLE, 0, _("the -P option only supports a single pattern"));

  *n = '\0';
  if (match_lines)
    strcpy (n, "^(");
  if (match_words)
    strcpy (n, "\\b(");
  n += strlen (n);

  /* The PCRE interface doesn't allow NUL bytes in the pattern, so
     replace each NUL byte in the pattern with the four characters
     "\000", removing a preceding backslash if there are an odd
     number of backslashes before the NUL.

     FIXME: This method does not work with some multibyte character
     encodings, notably Shift-JIS, where a multibyte character can end
     in a backslash byte.  */
  for (p = pattern; (pnul = memchr (p, '\0', patlim - p)); p = pnul + 1)
    {
      memcpy (n, p, pnul - p);
      n += pnul - p;
      for (p = pnul; pattern < p && p[-1] == '\\'; p--)
	continue;
      n -= (pnul - p) & 1;
      strcpy (n, "\\000");
      n += 4;
    }

  memcpy (n, p, patlim - p);
  n += patlim - p;
  *n = '\0';
  if (match_words)
    strcpy (n, ")\\b");
  if (match_lines)
    strcpy (n, ")$");

  cre = pcre_compile (re, flags, &ep, &e, pcre_maketables ());
  if (!cre)
    error (EXIT_TROUBLE, 0, "%s", ep);

  extra = pcre_study (cre, 0, &ep);
  if (ep)
    error (EXIT_TROUBLE, 0, "%s", ep);

  free (re);
#endif
}

EXECUTE_FCT(Pexecute)
{
#if !HAVE_LIBPCRE
  abort ();
  return -1;
#else
  /* This array must have at least two elements; everything after that
     is just for performance improvement in pcre_exec.  */
  int sub[300];

  const char *line_buf, *line_end, *line_next;
  int e = PCRE_ERROR_NOMATCH;
  ptrdiff_t start_ofs = start_ptr ? start_ptr - buf : 0;

  /* PCRE can't limit the matching to single lines, therefore we have to
     match each line in the buffer separately.  */
  for (line_next = buf;
       e == PCRE_ERROR_NOMATCH && line_next < buf + size;
       start_ofs -= line_next - line_buf)
    {
      line_buf = line_next;
      line_end = memchr (line_buf, eolbyte, (buf + size) - line_buf);
      if (line_end == NULL)
        line_next = line_end = buf + size;
      else
        line_next = line_end + 1;

      if (start_ptr && start_ptr >= line_end)
        continue;

      e = pcre_exec (cre, extra, line_buf, line_end - line_buf,
                     start_ofs < 0 ? 0 : start_ofs, 0,
                     sub, sizeof sub / sizeof *sub);
    }

  if (e <= 0)
    {
      switch (e)
	{
	case PCRE_ERROR_NOMATCH:
	  return -1;

	case PCRE_ERROR_NOMEMORY:
	  error (EXIT_TROUBLE, 0, _("memory exhausted"));

	default:
	  abort ();
	}
    }
  else
    {
      /* Narrow down to the line we've found.  */
      char const *beg = line_buf + sub[0];
      char const *end = line_buf + sub[1];
      char const *buflim = buf + size;
      char eol = eolbyte;
      if (!start_ptr)
	{
	  /* FIXME: The case when '\n' is not found indicates a bug:
	     Since grep is line oriented, the match should never contain
	     a newline, so there _must_ be a newline following.
	   */
	  if (!(end = memchr (end, eol, buflim - end)))
	    end = buflim;
	  else
	    end++;
	  while (buf < beg && beg[-1] != eol)
	    --beg;
	}

      *match_size = end - beg;
      return beg - buf;
    }
#endif
}

struct matcher const matchers[] = {
  { "default", Gcompile, EGexecute },
  { "grep",    Gcompile, EGexecute },
  { "egrep",   Ecompile, EGexecute },
  { "awk",     Acompile, EGexecute },
  { "fgrep",   Fcompile, Fexecute },
  { "perl",    Pcompile, Pexecute },
  { "", 0, 0 },
};
#endif /* GREP_PROGRAM */

Spawn 1 instances, now Total 23
Counter: 24
Batcher Size:23
Preprocess the following candidate with CondTester:
Priority 20000
At location src/search.c:246
--Src File: src/search.c
Fragment 0:
if ((mbclen == (size_t)-1 || mbclen == (size_t)-2 || mbclen == 0) && !(__abst_hole(mbclen, p, prev, end, buf, good))) {
    mbclen = 1;
}


CondTester, a patch instance with id 23:
//src_file:src/search.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
/* search.c - searching subroutines using dfa, kwset and regex for grep.
   Copyright 1992, 1998, 2000, 2007, 2009-2010 Free Software Foundation, Inc.

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 3, or (at your option)
   any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program; if not, write to the Free Software
   Foundation, Inc., 51 Franklin Street - Fifth Floor, Boston, MA
   02110-1301, USA.  */

/* Written August 1992 by Mike Haertel. */

#include <config.h>

#include <sys/types.h>

#include "mbsupport.h"
#ifdef MBS_SUPPORT
/* We can handle multibyte strings. */
# include <wchar.h>
# include <wctype.h>
#endif

#include "system.h"
#include "grep.h"
#ifndef FGREP_PROGRAM
# include <regex.h>
# include "dfa.h"
#endif
#include "kwset.h"
#include "error.h"
#include "xalloc.h"
#ifdef HAVE_LIBPCRE
# include <pcre.h>
#endif

#define NCHAR (UCHAR_MAX + 1)

/* For -w, we also consider _ to be word constituent.  */
#define WCHAR(C) (ISALNUM(C) || (C) == '_')

/* KWset compiled pattern.  For Ecompile and Gcompile, we compile
   a list of strings, at least one of which is known to occur in
   any string matching the regexp. */
static kwset_t kwset;

static void
kwsinit (void)
{
  static char trans[NCHAR];
  int i;

  if (match_icase && MB_CUR_MAX == 1)
    {
      for (i = 0; i < NCHAR; ++i)
        trans[i] = TOLOWER (i);

      kwset = kwsalloc (trans);
    }
  else
    kwset = kwsalloc (NULL);

  if (!kwset)
    xalloc_die ();
}

#ifdef MBS_SUPPORT
/* Convert the *N-byte string, BEG, to lowercase, and write the
   NUL-terminated result into malloc'd storage.  Upon success, set *N
   to the length (in bytes) of the resulting string (not including the
   trailing NUL byte), and return a pointer to the lowercase string.
   Upon memory allocation failure, this function exits.

   Note that while this function returns a pointer to malloc'd storage,
   the caller must not free it, since this function retains a pointer
   to the buffer and reuses it on any subsequent call.  As a consequence,
   this function is not thread-safe.  */
static char *
mbtolower (const char *beg, size_t *n)
{
  static char *out;
  static size_t outalloc;
  size_t outlen, mb_cur_max;
  mbstate_t is, os;
  const char *end;
  char *p;

  if (*n > outalloc)
    {
      out = xrealloc (out, *n);
      outalloc = *n;
    }

  memset (&is, 0, sizeof (is));
  memset (&os, 0, sizeof (os));
  end = beg + *n;

  mb_cur_max = MB_CUR_MAX;
  p = out;
  outlen = 0;
  while (beg < end)
    {
      wchar_t wc;
      size_t mbclen = mbrtowc(&wc, beg, end - beg, &is);
      if (outlen + mb_cur_max >= outalloc)
        {
          out = x2nrealloc (out, &outalloc, 1);
          p = out + outlen;
        }

      if (mbclen == (size_t) -1 || mbclen == (size_t) -2 || mbclen == 0)
        {
          /* An invalid sequence, or a truncated multi-octet character.
             We treat it as a single-octet character.  */
          *p++ = *beg++;
          outlen++;
          memset (&is, 0, sizeof (is));
          memset (&os, 0, sizeof (os));
        }
      else
        {
          beg += mbclen;
          mbclen = wcrtomb (p, towlower ((wint_t) wc), &os);
          p += mbclen;
          outlen += mbclen;
        }
    }

  *n = p - out;
  *p++ = 0;
  return out;
}
#endif


#ifndef FGREP_PROGRAM
/* DFA compiled regexp. */
static struct dfa dfa;

/* The Regex compiled patterns.  */
static struct patterns
{
  /* Regex compiled regexp. */
  struct re_pattern_buffer regexbuf;
  struct re_registers regs; /* This is here on account of a BRAIN-DEAD
			       Q@#%!# library interface in regex.c.  */
} patterns0;

struct patterns *patterns;
size_t pcount;

void
dfaerror (char const *mesg)
{
  error (EXIT_TROUBLE, 0, "%s", mesg);
}

/* Number of compiled fixed strings known to exactly match the regexp.
   If kwsexec returns < kwset_exact_matches, then we don't need to
   call the regexp matcher at all. */
static int kwset_exact_matches;

static char const *
kwsincr_case (const char *must)
{
  const char *buf;
  size_t n;

  n = strlen (must);
#ifdef MBS_SUPPORT
  if (match_icase && MB_CUR_MAX > 1)
    buf = mbtolower (must, &n);
  else
#endif
    buf = must;
  return kwsincr (kwset, buf, n);
}

/* If the DFA turns out to have some set of fixed strings one of
   which must occur in the match, then we build a kwset matcher
   to find those strings, and thus quickly filter out impossible
   matches. */
static void
kwsmusts (void)
{
  struct dfamust const *dm;
  char const *err;

  if (dfa.musts)
    {
      kwsinit ();
      /* First, we compile in the substrings known to be exact
	 matches.  The kwset matcher will return the index
	 of the matching string that it chooses. */
      for (dm = dfa.musts; dm; dm = dm->next)
	{
	  if (!dm->exact)
	    continue;
	  ++kwset_exact_matches;
	  if ((err = kwsincr_case (dm->must)) != NULL)
	    error (EXIT_TROUBLE, 0, "%s", err);
	}
      /* Now, we compile the substrings that will require
	 the use of the regexp matcher.  */
      for (dm = dfa.musts; dm; dm = dm->next)
	{
	  if (dm->exact)
	    continue;
	  if ((err = kwsincr_case (dm->must)) != NULL)
	    error (EXIT_TROUBLE, 0, "%s", err);
	}
      if ((err = kwsprep (kwset)) != NULL)
	error (EXIT_TROUBLE, 0, "%s", err);
    }
}
#endif /* !FGREP_PROGRAM */

#ifdef MBS_SUPPORT

static bool
is_mb_middle(const char **good, const char *buf, const char *end)
{
  const char *p = *good;
  const char *prev = p;
  mbstate_t cur_state;

  /* TODO: can be optimized for UTF-8.  */
  memset(&cur_state, 0, sizeof(mbstate_t));
  while (p < buf)
    {
      size_t mbclen = mbrlen(p, end - p, &cur_state);

      /* Store the beginning of the previous complete multibyte character.  */
      if (mbclen != (size_t) -2)
        prev = p;

      
//Patch 0:
if ((mbclen == (size_t)-1 || mbclen == (size_t)-2 || mbclen == 0) && !(__is_neg(6, &(mbclen), sizeof (mbclen), &(p), sizeof (p), &(prev), sizeof (prev), &(end), sizeof (end), &(buf), sizeof (buf), &(good), sizeof (good)))) {
    mbclen = 1;
}

//CodeSeg 1:
      p += mbclen;
    }

  *good = prev;
  return p > buf;
}
#endif /* MBS_SUPPORT */

#if defined(GREP_PROGRAM) || defined(EGREP_PROGRAM)
#ifdef EGREP_PROGRAM
COMPILE_FCT(Ecompile)
{
  reg_syntax_t syntax_bits = RE_SYNTAX_POSIX_EGREP;
#else
/* No __VA_ARGS__ in C89.  So we have to do it this way.  */
static COMPILE_RET
GEAcompile (char const *pattern, size_t size, reg_syntax_t syntax_bits)
{
#endif /* EGREP_PROGRAM */
  const char *err;
  const char *p, *sep;
  size_t total = size;
  char *motif;

  if (match_icase)
    syntax_bits |= RE_ICASE;
  re_set_syntax (syntax_bits);
  dfasyntax (syntax_bits, match_icase, eolbyte);

  /* For GNU regex compiler we have to pass the patterns separately to detect
     errors like "[\nallo\n]\n".  The patterns here are "[", "allo" and "]"
     GNU regex should have raise a syntax error.  The same for backref, where
     the backref should have been local to each pattern.  */
  p = pattern;
  do
    {
      size_t len;
      sep = memchr (p, '\n', total);
      if (sep)
	{
	  len = sep - p;
	  sep++;
	  total -= (len + 1);
	}
      else
	{
	  len = total;
	  total = 0;
	}

      patterns = realloc (patterns, (pcount + 1) * sizeof (*patterns));
      if (patterns == NULL)
	error (EXIT_TROUBLE, errno, _("memory exhausted"));
      patterns[pcount] = patterns0;

      if ((err = re_compile_pattern (p, len,
				    &(patterns[pcount].regexbuf))) != NULL)
	error (EXIT_TROUBLE, 0, "%s", err);
      pcount++;

      p = sep;
    } while (sep && total != 0);

  /* In the match_words and match_lines cases, we use a different pattern
     for the DFA matcher that will quickly throw out cases that won't work.
     Then if DFA succeeds we do some hairy stuff using the regex matcher
     to decide whether the match should really count. */
  if (match_words || match_lines)
    {
      static char const line_beg_no_bk[] = "^(";
      static char const line_end_no_bk[] = ")$";
      static char const word_beg_no_bk[] = "(^|[^[:alnum:]_])(";
      static char const word_end_no_bk[] = ")([^[:alnum:]_]|$)";
#ifdef EGREP_PROGRAM
# define IF_BK(x, y) (y)
      char *n = xmalloc (sizeof word_beg_no_bk - 1 + size + sizeof word_end_no_bk);
#else
      static char const line_beg_bk[] = "^\\(";
      static char const line_end_bk[] = "\\)$";
      static char const word_beg_bk[] = "\\(^\\|[^[:alnum:]_]\\)\\(";
      static char const word_end_bk[] = "\\)\\([^[:alnum:]_]\\|$\\)";
      int bk = !(syntax_bits & RE_NO_BK_PARENS);
# define IF_BK(x, y) ((bk) ? (x) : (y))
      char *n = xmalloc (sizeof word_beg_bk - 1 + size + sizeof word_end_bk);
#endif /* EGREP_PROGRAM */

      strcpy (n, match_lines ? IF_BK(line_beg_bk, line_beg_no_bk)
			     : IF_BK(word_beg_bk, word_beg_no_bk));
      total = strlen(n);
      memcpy (n + total, pattern, size);
      total += size;
      strcpy (n + total, match_lines ? IF_BK(line_end_bk, line_end_no_bk)
				     : IF_BK(word_end_bk, word_end_no_bk));
      total += strlen (n + total);
      pattern = motif = n;
      size = total;
    }
  else
    motif = NULL;

  dfacomp (pattern, size, &dfa, 1);
  kwsmusts ();

  free(motif);
}

#ifndef EGREP_PROGRAM
COMPILE_FCT(Gcompile)
{
  return GEAcompile (pattern, size,
		     RE_SYNTAX_GREP | RE_HAT_LISTS_NOT_NEWLINE);
}

COMPILE_FCT(Acompile)
{
  return GEAcompile (pattern, size, RE_SYNTAX_AWK);
}

COMPILE_FCT(Ecompile)
{
  return GEAcompile (pattern, size, RE_SYNTAX_POSIX_EGREP);
}
#endif /* !EGREP_PROGRAM */

EXECUTE_FCT(EGexecute)
{
  char const *buflim, *beg, *end, *match, *best_match, *mb_start;
  char eol = eolbyte;
  int backref, start, len, best_len;
  struct kwsmatch kwsm;
  size_t i, ret_val;
#ifdef MBS_SUPPORT
  if (MB_CUR_MAX > 1)
    {
      if (match_icase)
        {
          /* mbtolower adds a NUL byte at the end.  That will provide
	     space for the sentinel byte dfaexec may add.  */
          char *case_buf = mbtolower (buf, &size);
	  if (start_ptr)
	    start_ptr = case_buf + (start_ptr - buf);
          buf = case_buf;
        }
    }
#endif /* MBS_SUPPORT */

  mb_start = buf;
  buflim = buf + size;

  for (beg = end = buf; end < buflim; beg = end)
    {
      if (!start_ptr)
	{
	  /* We don't care about an exact match.  */
	  if (kwset)
	    {
	      /* Find a possible match using the KWset matcher. */
	      size_t offset = kwsexec (kwset, beg, buflim - beg, &kwsm);
	      if (offset == (size_t) -1)
		goto failure;
	      beg += offset;
	      /* Narrow down to the line containing the candidate, and
		 run it through DFA. */
	      if ((end = memchr(beg, eol, buflim - beg)) != NULL)
	        end++;
              else
                end = buflim;
	      match = beg;
	      while (beg > buf && beg[-1] != eol)
		--beg;
	      if (kwsm.index < kwset_exact_matches)
                {
#ifdef MBS_SUPPORT
                  if (mb_start < beg)
                    mb_start = beg;
                  if (MB_CUR_MAX == 1 || !is_mb_middle (&mb_start, match, buflim))
#endif
                    goto success;
                }
	      if (dfaexec (&dfa, beg, (char *) end, 0, NULL, &backref) == NULL)
		continue;
	    }
	  else
	    {
	      /* No good fixed strings; start with DFA. */
	      char const *next_beg = dfaexec (&dfa, beg, (char *) buflim,
					      0, NULL, &backref);
	      if (next_beg == NULL)
		break;
	      /* Narrow down to the line we've found. */
	      beg = next_beg;
	      if ((end = memchr(beg, eol, buflim - beg)) != NULL)
	        end++;
              else
                end = buflim;
	      while (beg > buf && beg[-1] != eol)
		--beg;
	    }
	  /* Successful, no backreferences encountered! */
	  if (!backref)
	    goto success;
	}
      else
	{
	  /* We are looking for the leftmost (then longest) exact match.
	     We will go through the outer loop only once.  */
	  beg = start_ptr;
	  end = buflim;
	}

      /* If we've made it to this point, this means DFA has seen
	 a probable match, and we need to run it through Regex. */
      best_match = end;
      best_len = 0;
      for (i = 0; i < pcount; i++)
	{
	  patterns[i].regexbuf.not_eol = 0;
	  if (0 <= (start = re_search (&(patterns[i].regexbuf),
				       buf, end - buf - 1,
				       beg - buf, end - beg - 1,
				       &(patterns[i].regs))))
	    {
	      len = patterns[i].regs.end[0] - start;
	      match = buf + start;
	      if (match > best_match)
		continue;
	      if (start_ptr && !match_words)
		goto assess_pattern_match;
	      if ((!match_lines && !match_words)
		  || (match_lines && len == end - beg - 1))
		{
		  match = beg;
		  len = end - beg;
		  goto assess_pattern_match;
		}
	      /* If -w, check if the match aligns with word boundaries.
		 We do this iteratively because:
		 (a) the line may contain more than one occurence of the
		 pattern, and
		 (b) Several alternatives in the pattern might be valid at a
		 given point, and we may need to consider a shorter one to
		 find a word boundary.  */
	      if (match_words)
		while (match <= best_match)
		  {
		    if ((match == buf || !WCHAR ((unsigned char) match[-1]))
			&& (len == end - beg - 1
			    || !WCHAR ((unsigned char) match[len])))
		      goto assess_pattern_match;
		    if (len > 0)
		      {
			/* Try a shorter length anchored at the same place. */
			--len;
			patterns[i].regexbuf.not_eol = 1;
			len = re_match (&(patterns[i].regexbuf),
					buf, match + len - beg, match - buf,
					&(patterns[i].regs));
		      }
		    if (len <= 0)
		      {
			/* Try looking further on. */
			if (match == end - 1)
			  break;
			match++;
			patterns[i].regexbuf.not_eol = 0;
			start = re_search (&(patterns[i].regexbuf),
					   buf, end - buf - 1,
					   match - buf, end - match - 1,
					   &(patterns[i].regs));
			if (start < 0)
			  break;
			len = patterns[i].regs.end[0] - start;
			match = buf + start;
		      }
		  } /* while (match <= best_match) */
	      continue;
	    assess_pattern_match:
	      if (!start_ptr)
		{
		  /* Good enough for a non-exact match.
		     No need to look at further patterns, if any.  */
		  beg = match;
		  goto success_in_len;
		}
	      if (match < best_match || (match == best_match && len > best_len))
		{
		  /* Best exact match:  leftmost, then longest.  */
		  best_match = match;
		  best_len = len;
		}
	    } /* if re_search >= 0 */
	} /* for Regex patterns.  */
	if (best_match < end)
	  {
	    /* We have found an exact match.  We were just
	       waiting for the best one (leftmost then longest).  */
	    beg = best_match;
	    len = best_len;
	    goto success_in_len;
	  }
    } /* for (beg = end ..) */

 failure:
  ret_val = -1;
  goto out;

 success:
  len = end - beg;
 success_in_len:
  *match_size = len;
  ret_val = beg - buf;
 out:
  return ret_val;
}
#endif /* defined(GREP_PROGRAM) || defined(EGREP_PROGRAM) */

#if defined(GREP_PROGRAM) || defined(FGREP_PROGRAM)
COMPILE_FCT(Fcompile)
{
  char const *beg, *end, *lim, *err, *pat;
  size_t psize;

  kwsinit ();
  psize = size;
  if (match_icase && MB_CUR_MAX > 1)
    pat = mbtolower (pattern, &psize);
  else
    pat = pattern;

  beg = pat;
  do
    {
      for (lim = beg;; ++lim)
	{
	  end = lim;
	  if (lim >= pat + psize)
	    break;
	 if (*lim == '\n')
	   {
	     lim++;
	     break;
	   }
#if HAVE_DOS_FILE_CONTENTS
	 if (*lim == '\r' && lim + 1 < pat + psize && lim[1] == '\n')
	   {
	     lim += 2;
	     break;
	   }
#endif
	}

      if ((err = kwsincr (kwset, beg, end - beg)) != NULL)
	error (EXIT_TROUBLE, 0, "%s", err);
      beg = lim;
    }
  while (beg < pat + psize);

  if ((err = kwsprep (kwset)) != NULL)
    error (EXIT_TROUBLE, 0, "%s", err);
}

EXECUTE_FCT(Fexecute)
{
  char const *beg, *try, *end, *mb_start;
  size_t len;
  char eol = eolbyte;
  struct kwsmatch kwsmatch;
  size_t ret_val;
#ifdef MBS_SUPPORT
  if (MB_CUR_MAX > 1)
    {
      if (match_icase)
        {
          char *case_buf = mbtolower (buf, &size);
	  if (start_ptr)
	    start_ptr = case_buf + (start_ptr - buf);
          buf = case_buf;
        }
    }
#endif /* MBS_SUPPORT */

  for (mb_start = beg = start_ptr ? start_ptr : buf; beg <= buf + size; beg++)
    {
      size_t offset = kwsexec (kwset, beg, buf + size - beg, &kwsmatch);
      if (offset == (size_t) -1)
	goto failure;
#ifdef MBS_SUPPORT
      if (MB_CUR_MAX > 1 && is_mb_middle (&mb_start, beg + offset, buf + size))
        {
          beg = mb_start - 1;
          continue; /* It is a part of multibyte character.  */
        }
#endif /* MBS_SUPPORT */
      beg += offset;
      len = kwsmatch.size[0];
      if (start_ptr && !match_words)
	goto success_in_beg_and_len;
      if (match_lines)
	{
	  if (beg > buf && beg[-1] != eol)
	    continue;
	  if (beg + len < buf + size && beg[len] != eol)
	    continue;
	  goto success;
	}
      else if (match_words)
	for (try = beg; len; )
	  {
	    if (try > buf && WCHAR((unsigned char) try[-1]))
	      break;
	    if (try + len < buf + size && WCHAR((unsigned char) try[len]))
	      {
		offset = kwsexec (kwset, beg, --len, &kwsmatch);
		if (offset == (size_t) -1)
		  break;
		try = beg + offset;
		len = kwsmatch.size[0];
	      }
	    else if (!start_ptr)
	      goto success;
	    else
	      goto success_in_beg_and_len;
	  } /* for (try) */
      else
	goto success;
    } /* for (beg in buf) */

 failure:
  ret_val = -1;
  goto out;

 success:
  if ((end = memchr (beg + len, eol, (buf + size) - (beg + len))) != NULL)
    end++;
  else
    end = buf + size;
  while (buf < beg && beg[-1] != eol)
    --beg;
  len = end - beg;
 success_in_beg_and_len:
  *match_size = len;
  ret_val = beg - buf;
 out:
  return ret_val;
}
#endif /* defined(GREP_PROGRAM) || defined(FGREP_PROGRAM) */

#ifdef GREP_PROGRAM
#if HAVE_LIBPCRE
/* Compiled internal form of a Perl regular expression.  */
static pcre *cre;

/* Additional information about the pattern.  */
static pcre_extra *extra;
#endif

COMPILE_FCT(Pcompile)
{
#if !HAVE_LIBPCRE
  error (EXIT_TROUBLE, 0, "%s",
	 _("support for the -P option is not compiled into "
	   "this --disable-perl-regexp binary"));
#else
  int e;
  char const *ep;
  char *re = xmalloc (4 * size + 7);
  int flags = PCRE_MULTILINE | (match_icase ? PCRE_CASELESS : 0);
  char const *patlim = pattern + size;
  char *n = re;
  char const *p;
  char const *pnul;

  /* FIXME: Remove these restrictions.  */
  if (memchr(pattern, '\n', size))
    error (EXIT_TROUBLE, 0, _("the -P option only supports a single pattern"));

  *n = '\0';
  if (match_lines)
    strcpy (n, "^(");
  if (match_words)
    strcpy (n, "\\b(");
  n += strlen (n);

  /* The PCRE interface doesn't allow NUL bytes in the pattern, so
     replace each NUL byte in the pattern with the four characters
     "\000", removing a preceding backslash if there are an odd
     number of backslashes before the NUL.

     FIXME: This method does not work with some multibyte character
     encodings, notably Shift-JIS, where a multibyte character can end
     in a backslash byte.  */
  for (p = pattern; (pnul = memchr (p, '\0', patlim - p)); p = pnul + 1)
    {
      memcpy (n, p, pnul - p);
      n += pnul - p;
      for (p = pnul; pattern < p && p[-1] == '\\'; p--)
	continue;
      n -= (pnul - p) & 1;
      strcpy (n, "\\000");
      n += 4;
    }

  memcpy (n, p, patlim - p);
  n += patlim - p;
  *n = '\0';
  if (match_words)
    strcpy (n, ")\\b");
  if (match_lines)
    strcpy (n, ")$");

  cre = pcre_compile (re, flags, &ep, &e, pcre_maketables ());
  if (!cre)
    error (EXIT_TROUBLE, 0, "%s", ep);

  extra = pcre_study (cre, 0, &ep);
  if (ep)
    error (EXIT_TROUBLE, 0, "%s", ep);

  free (re);
#endif
}

EXECUTE_FCT(Pexecute)
{
#if !HAVE_LIBPCRE
  abort ();
  return -1;
#else
  /* This array must have at least two elements; everything after that
     is just for performance improvement in pcre_exec.  */
  int sub[300];

  const char *line_buf, *line_end, *line_next;
  int e = PCRE_ERROR_NOMATCH;
  ptrdiff_t start_ofs = start_ptr ? start_ptr - buf : 0;

  /* PCRE can't limit the matching to single lines, therefore we have to
     match each line in the buffer separately.  */
  for (line_next = buf;
       e == PCRE_ERROR_NOMATCH && line_next < buf + size;
       start_ofs -= line_next - line_buf)
    {
      line_buf = line_next;
      line_end = memchr (line_buf, eolbyte, (buf + size) - line_buf);
      if (line_end == NULL)
        line_next = line_end = buf + size;
      else
        line_next = line_end + 1;

      if (start_ptr && start_ptr >= line_end)
        continue;

      e = pcre_exec (cre, extra, line_buf, line_end - line_buf,
                     start_ofs < 0 ? 0 : start_ofs, 0,
                     sub, sizeof sub / sizeof *sub);
    }

  if (e <= 0)
    {
      switch (e)
	{
	case PCRE_ERROR_NOMATCH:
	  return -1;

	case PCRE_ERROR_NOMEMORY:
	  error (EXIT_TROUBLE, 0, _("memory exhausted"));

	default:
	  abort ();
	}
    }
  else
    {
      /* Narrow down to the line we've found.  */
      char const *beg = line_buf + sub[0];
      char const *end = line_buf + sub[1];
      char const *buflim = buf + size;
      char eol = eolbyte;
      if (!start_ptr)
	{
	  /* FIXME: The case when '\n' is not found indicates a bug:
	     Since grep is line oriented, the match should never contain
	     a newline, so there _must_ be a newline following.
	   */
	  if (!(end = memchr (end, eol, buflim - end)))
	    end = buflim;
	  else
	    end++;
	  while (buf < beg && beg[-1] != eol)
	    --beg;
	}

      *match_size = end - beg;
      return beg - buf;
    }
#endif
}

struct matcher const matchers[] = {
  { "default", Gcompile, EGexecute },
  { "grep",    Gcompile, EGexecute },
  { "egrep",   Ecompile, EGexecute },
  { "awk",     Acompile, EGexecute },
  { "fgrep",   Fcompile, Fexecute },
  { "perl",    Pcompile, Pexecute },
  { "", 0, 0 },
};
#endif /* GREP_PROGRAM */

Spawn 1 instances, now Total 24
Counter: 25
Batcher Size:24
Preprocess the following candidate with CondTester:
Priority 20000
At location src/search.c:623
--Src File: src/search.c
Fragment 0:
if ((match_icase) && !(__abst_hole(match_icase, buf, size, start_ptr, eolbyte, beg, mb_start, kwset, len, match_words, match_lines, eol, try, ret_val, end, match_size))) {
    char *case_buf = mbtolower(buf, &size);
    if (start_ptr)
        start_ptr = case_buf + (start_ptr - buf);
    buf = case_buf;
}


CondTester, a patch instance with id 24:
//src_file:src/search.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
/* search.c - searching subroutines using dfa, kwset and regex for grep.
   Copyright 1992, 1998, 2000, 2007, 2009-2010 Free Software Foundation, Inc.

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 3, or (at your option)
   any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program; if not, write to the Free Software
   Foundation, Inc., 51 Franklin Street - Fifth Floor, Boston, MA
   02110-1301, USA.  */

/* Written August 1992 by Mike Haertel. */

#include <config.h>

#include <sys/types.h>

#include "mbsupport.h"
#ifdef MBS_SUPPORT
/* We can handle multibyte strings. */
# include <wchar.h>
# include <wctype.h>
#endif

#include "system.h"
#include "grep.h"
#ifndef FGREP_PROGRAM
# include <regex.h>
# include "dfa.h"
#endif
#include "kwset.h"
#include "error.h"
#include "xalloc.h"
#ifdef HAVE_LIBPCRE
# include <pcre.h>
#endif

#define NCHAR (UCHAR_MAX + 1)

/* For -w, we also consider _ to be word constituent.  */
#define WCHAR(C) (ISALNUM(C) || (C) == '_')

/* KWset compiled pattern.  For Ecompile and Gcompile, we compile
   a list of strings, at least one of which is known to occur in
   any string matching the regexp. */
static kwset_t kwset;

static void
kwsinit (void)
{
  static char trans[NCHAR];
  int i;

  if (match_icase && MB_CUR_MAX == 1)
    {
      for (i = 0; i < NCHAR; ++i)
        trans[i] = TOLOWER (i);

      kwset = kwsalloc (trans);
    }
  else
    kwset = kwsalloc (NULL);

  if (!kwset)
    xalloc_die ();
}

#ifdef MBS_SUPPORT
/* Convert the *N-byte string, BEG, to lowercase, and write the
   NUL-terminated result into malloc'd storage.  Upon success, set *N
   to the length (in bytes) of the resulting string (not including the
   trailing NUL byte), and return a pointer to the lowercase string.
   Upon memory allocation failure, this function exits.

   Note that while this function returns a pointer to malloc'd storage,
   the caller must not free it, since this function retains a pointer
   to the buffer and reuses it on any subsequent call.  As a consequence,
   this function is not thread-safe.  */
static char *
mbtolower (const char *beg, size_t *n)
{
  static char *out;
  static size_t outalloc;
  size_t outlen, mb_cur_max;
  mbstate_t is, os;
  const char *end;
  char *p;

  if (*n > outalloc)
    {
      out = xrealloc (out, *n);
      outalloc = *n;
    }

  memset (&is, 0, sizeof (is));
  memset (&os, 0, sizeof (os));
  end = beg + *n;

  mb_cur_max = MB_CUR_MAX;
  p = out;
  outlen = 0;
  while (beg < end)
    {
      wchar_t wc;
      size_t mbclen = mbrtowc(&wc, beg, end - beg, &is);
      if (outlen + mb_cur_max >= outalloc)
        {
          out = x2nrealloc (out, &outalloc, 1);
          p = out + outlen;
        }

      if (mbclen == (size_t) -1 || mbclen == (size_t) -2 || mbclen == 0)
        {
          /* An invalid sequence, or a truncated multi-octet character.
             We treat it as a single-octet character.  */
          *p++ = *beg++;
          outlen++;
          memset (&is, 0, sizeof (is));
          memset (&os, 0, sizeof (os));
        }
      else
        {
          beg += mbclen;
          mbclen = wcrtomb (p, towlower ((wint_t) wc), &os);
          p += mbclen;
          outlen += mbclen;
        }
    }

  *n = p - out;
  *p++ = 0;
  return out;
}
#endif


#ifndef FGREP_PROGRAM
/* DFA compiled regexp. */
static struct dfa dfa;

/* The Regex compiled patterns.  */
static struct patterns
{
  /* Regex compiled regexp. */
  struct re_pattern_buffer regexbuf;
  struct re_registers regs; /* This is here on account of a BRAIN-DEAD
			       Q@#%!# library interface in regex.c.  */
} patterns0;

struct patterns *patterns;
size_t pcount;

void
dfaerror (char const *mesg)
{
  error (EXIT_TROUBLE, 0, "%s", mesg);
}

/* Number of compiled fixed strings known to exactly match the regexp.
   If kwsexec returns < kwset_exact_matches, then we don't need to
   call the regexp matcher at all. */
static int kwset_exact_matches;

static char const *
kwsincr_case (const char *must)
{
  const char *buf;
  size_t n;

  n = strlen (must);
#ifdef MBS_SUPPORT
  if (match_icase && MB_CUR_MAX > 1)
    buf = mbtolower (must, &n);
  else
#endif
    buf = must;
  return kwsincr (kwset, buf, n);
}

/* If the DFA turns out to have some set of fixed strings one of
   which must occur in the match, then we build a kwset matcher
   to find those strings, and thus quickly filter out impossible
   matches. */
static void
kwsmusts (void)
{
  struct dfamust const *dm;
  char const *err;

  if (dfa.musts)
    {
      kwsinit ();
      /* First, we compile in the substrings known to be exact
	 matches.  The kwset matcher will return the index
	 of the matching string that it chooses. */
      for (dm = dfa.musts; dm; dm = dm->next)
	{
	  if (!dm->exact)
	    continue;
	  ++kwset_exact_matches;
	  if ((err = kwsincr_case (dm->must)) != NULL)
	    error (EXIT_TROUBLE, 0, "%s", err);
	}
      /* Now, we compile the substrings that will require
	 the use of the regexp matcher.  */
      for (dm = dfa.musts; dm; dm = dm->next)
	{
	  if (dm->exact)
	    continue;
	  if ((err = kwsincr_case (dm->must)) != NULL)
	    error (EXIT_TROUBLE, 0, "%s", err);
	}
      if ((err = kwsprep (kwset)) != NULL)
	error (EXIT_TROUBLE, 0, "%s", err);
    }
}
#endif /* !FGREP_PROGRAM */

#ifdef MBS_SUPPORT

static bool
is_mb_middle(const char **good, const char *buf, const char *end)
{
  const char *p = *good;
  const char *prev = p;
  mbstate_t cur_state;

  /* TODO: can be optimized for UTF-8.  */
  memset(&cur_state, 0, sizeof(mbstate_t));
  while (p < buf)
    {
      size_t mbclen = mbrlen(p, end - p, &cur_state);

      /* Store the beginning of the previous complete multibyte character.  */
      if (mbclen != (size_t) -2)
        prev = p;

      if (mbclen == (size_t) -1 || mbclen == (size_t) -2 || mbclen == 0)
	{
	  /* An invalid sequence, or a truncated multibyte character.
	     We treat it as a single byte character.  */
	  mbclen = 1;
	}
      p += mbclen;
    }

  *good = prev;
  return p > buf;
}
#endif /* MBS_SUPPORT */

#if defined(GREP_PROGRAM) || defined(EGREP_PROGRAM)
#ifdef EGREP_PROGRAM
COMPILE_FCT(Ecompile)
{
  reg_syntax_t syntax_bits = RE_SYNTAX_POSIX_EGREP;
#else
/* No __VA_ARGS__ in C89.  So we have to do it this way.  */
static COMPILE_RET
GEAcompile (char const *pattern, size_t size, reg_syntax_t syntax_bits)
{
#endif /* EGREP_PROGRAM */
  const char *err;
  const char *p, *sep;
  size_t total = size;
  char *motif;

  if (match_icase)
    syntax_bits |= RE_ICASE;
  re_set_syntax (syntax_bits);
  dfasyntax (syntax_bits, match_icase, eolbyte);

  /* For GNU regex compiler we have to pass the patterns separately to detect
     errors like "[\nallo\n]\n".  The patterns here are "[", "allo" and "]"
     GNU regex should have raise a syntax error.  The same for backref, where
     the backref should have been local to each pattern.  */
  p = pattern;
  do
    {
      size_t len;
      sep = memchr (p, '\n', total);
      if (sep)
	{
	  len = sep - p;
	  sep++;
	  total -= (len + 1);
	}
      else
	{
	  len = total;
	  total = 0;
	}

      patterns = realloc (patterns, (pcount + 1) * sizeof (*patterns));
      if (patterns == NULL)
	error (EXIT_TROUBLE, errno, _("memory exhausted"));
      patterns[pcount] = patterns0;

      if ((err = re_compile_pattern (p, len,
				    &(patterns[pcount].regexbuf))) != NULL)
	error (EXIT_TROUBLE, 0, "%s", err);
      pcount++;

      p = sep;
    } while (sep && total != 0);

  /* In the match_words and match_lines cases, we use a different pattern
     for the DFA matcher that will quickly throw out cases that won't work.
     Then if DFA succeeds we do some hairy stuff using the regex matcher
     to decide whether the match should really count. */
  if (match_words || match_lines)
    {
      static char const line_beg_no_bk[] = "^(";
      static char const line_end_no_bk[] = ")$";
      static char const word_beg_no_bk[] = "(^|[^[:alnum:]_])(";
      static char const word_end_no_bk[] = ")([^[:alnum:]_]|$)";
#ifdef EGREP_PROGRAM
# define IF_BK(x, y) (y)
      char *n = xmalloc (sizeof word_beg_no_bk - 1 + size + sizeof word_end_no_bk);
#else
      static char const line_beg_bk[] = "^\\(";
      static char const line_end_bk[] = "\\)$";
      static char const word_beg_bk[] = "\\(^\\|[^[:alnum:]_]\\)\\(";
      static char const word_end_bk[] = "\\)\\([^[:alnum:]_]\\|$\\)";
      int bk = !(syntax_bits & RE_NO_BK_PARENS);
# define IF_BK(x, y) ((bk) ? (x) : (y))
      char *n = xmalloc (sizeof word_beg_bk - 1 + size + sizeof word_end_bk);
#endif /* EGREP_PROGRAM */

      strcpy (n, match_lines ? IF_BK(line_beg_bk, line_beg_no_bk)
			     : IF_BK(word_beg_bk, word_beg_no_bk));
      total = strlen(n);
      memcpy (n + total, pattern, size);
      total += size;
      strcpy (n + total, match_lines ? IF_BK(line_end_bk, line_end_no_bk)
				     : IF_BK(word_end_bk, word_end_no_bk));
      total += strlen (n + total);
      pattern = motif = n;
      size = total;
    }
  else
    motif = NULL;

  dfacomp (pattern, size, &dfa, 1);
  kwsmusts ();

  free(motif);
}

#ifndef EGREP_PROGRAM
COMPILE_FCT(Gcompile)
{
  return GEAcompile (pattern, size,
		     RE_SYNTAX_GREP | RE_HAT_LISTS_NOT_NEWLINE);
}

COMPILE_FCT(Acompile)
{
  return GEAcompile (pattern, size, RE_SYNTAX_AWK);
}

COMPILE_FCT(Ecompile)
{
  return GEAcompile (pattern, size, RE_SYNTAX_POSIX_EGREP);
}
#endif /* !EGREP_PROGRAM */

EXECUTE_FCT(EGexecute)
{
  char const *buflim, *beg, *end, *match, *best_match, *mb_start;
  char eol = eolbyte;
  int backref, start, len, best_len;
  struct kwsmatch kwsm;
  size_t i, ret_val;
#ifdef MBS_SUPPORT
  if (MB_CUR_MAX > 1)
    {
      if (match_icase)
        {
          /* mbtolower adds a NUL byte at the end.  That will provide
	     space for the sentinel byte dfaexec may add.  */
          char *case_buf = mbtolower (buf, &size);
	  if (start_ptr)
	    start_ptr = case_buf + (start_ptr - buf);
          buf = case_buf;
        }
    }
#endif /* MBS_SUPPORT */

  mb_start = buf;
  buflim = buf + size;

  for (beg = end = buf; end < buflim; beg = end)
    {
      if (!start_ptr)
	{
	  /* We don't care about an exact match.  */
	  if (kwset)
	    {
	      /* Find a possible match using the KWset matcher. */
	      size_t offset = kwsexec (kwset, beg, buflim - beg, &kwsm);
	      if (offset == (size_t) -1)
		goto failure;
	      beg += offset;
	      /* Narrow down to the line containing the candidate, and
		 run it through DFA. */
	      if ((end = memchr(beg, eol, buflim - beg)) != NULL)
	        end++;
              else
                end = buflim;
	      match = beg;
	      while (beg > buf && beg[-1] != eol)
		--beg;
	      if (kwsm.index < kwset_exact_matches)
                {
#ifdef MBS_SUPPORT
                  if (mb_start < beg)
                    mb_start = beg;
                  if (MB_CUR_MAX == 1 || !is_mb_middle (&mb_start, match, buflim))
#endif
                    goto success;
                }
	      if (dfaexec (&dfa, beg, (char *) end, 0, NULL, &backref) == NULL)
		continue;
	    }
	  else
	    {
	      /* No good fixed strings; start with DFA. */
	      char const *next_beg = dfaexec (&dfa, beg, (char *) buflim,
					      0, NULL, &backref);
	      if (next_beg == NULL)
		break;
	      /* Narrow down to the line we've found. */
	      beg = next_beg;
	      if ((end = memchr(beg, eol, buflim - beg)) != NULL)
	        end++;
              else
                end = buflim;
	      while (beg > buf && beg[-1] != eol)
		--beg;
	    }
	  /* Successful, no backreferences encountered! */
	  if (!backref)
	    goto success;
	}
      else
	{
	  /* We are looking for the leftmost (then longest) exact match.
	     We will go through the outer loop only once.  */
	  beg = start_ptr;
	  end = buflim;
	}

      /* If we've made it to this point, this means DFA has seen
	 a probable match, and we need to run it through Regex. */
      best_match = end;
      best_len = 0;
      for (i = 0; i < pcount; i++)
	{
	  patterns[i].regexbuf.not_eol = 0;
	  if (0 <= (start = re_search (&(patterns[i].regexbuf),
				       buf, end - buf - 1,
				       beg - buf, end - beg - 1,
				       &(patterns[i].regs))))
	    {
	      len = patterns[i].regs.end[0] - start;
	      match = buf + start;
	      if (match > best_match)
		continue;
	      if (start_ptr && !match_words)
		goto assess_pattern_match;
	      if ((!match_lines && !match_words)
		  || (match_lines && len == end - beg - 1))
		{
		  match = beg;
		  len = end - beg;
		  goto assess_pattern_match;
		}
	      /* If -w, check if the match aligns with word boundaries.
		 We do this iteratively because:
		 (a) the line may contain more than one occurence of the
		 pattern, and
		 (b) Several alternatives in the pattern might be valid at a
		 given point, and we may need to consider a shorter one to
		 find a word boundary.  */
	      if (match_words)
		while (match <= best_match)
		  {
		    if ((match == buf || !WCHAR ((unsigned char) match[-1]))
			&& (len == end - beg - 1
			    || !WCHAR ((unsigned char) match[len])))
		      goto assess_pattern_match;
		    if (len > 0)
		      {
			/* Try a shorter length anchored at the same place. */
			--len;
			patterns[i].regexbuf.not_eol = 1;
			len = re_match (&(patterns[i].regexbuf),
					buf, match + len - beg, match - buf,
					&(patterns[i].regs));
		      }
		    if (len <= 0)
		      {
			/* Try looking further on. */
			if (match == end - 1)
			  break;
			match++;
			patterns[i].regexbuf.not_eol = 0;
			start = re_search (&(patterns[i].regexbuf),
					   buf, end - buf - 1,
					   match - buf, end - match - 1,
					   &(patterns[i].regs));
			if (start < 0)
			  break;
			len = patterns[i].regs.end[0] - start;
			match = buf + start;
		      }
		  } /* while (match <= best_match) */
	      continue;
	    assess_pattern_match:
	      if (!start_ptr)
		{
		  /* Good enough for a non-exact match.
		     No need to look at further patterns, if any.  */
		  beg = match;
		  goto success_in_len;
		}
	      if (match < best_match || (match == best_match && len > best_len))
		{
		  /* Best exact match:  leftmost, then longest.  */
		  best_match = match;
		  best_len = len;
		}
	    } /* if re_search >= 0 */
	} /* for Regex patterns.  */
	if (best_match < end)
	  {
	    /* We have found an exact match.  We were just
	       waiting for the best one (leftmost then longest).  */
	    beg = best_match;
	    len = best_len;
	    goto success_in_len;
	  }
    } /* for (beg = end ..) */

 failure:
  ret_val = -1;
  goto out;

 success:
  len = end - beg;
 success_in_len:
  *match_size = len;
  ret_val = beg - buf;
 out:
  return ret_val;
}
#endif /* defined(GREP_PROGRAM) || defined(EGREP_PROGRAM) */

#if defined(GREP_PROGRAM) || defined(FGREP_PROGRAM)
COMPILE_FCT(Fcompile)
{
  char const *beg, *end, *lim, *err, *pat;
  size_t psize;

  kwsinit ();
  psize = size;
  if (match_icase && MB_CUR_MAX > 1)
    pat = mbtolower (pattern, &psize);
  else
    pat = pattern;

  beg = pat;
  do
    {
      for (lim = beg;; ++lim)
	{
	  end = lim;
	  if (lim >= pat + psize)
	    break;
	 if (*lim == '\n')
	   {
	     lim++;
	     break;
	   }
#if HAVE_DOS_FILE_CONTENTS
	 if (*lim == '\r' && lim + 1 < pat + psize && lim[1] == '\n')
	   {
	     lim += 2;
	     break;
	   }
#endif
	}

      if ((err = kwsincr (kwset, beg, end - beg)) != NULL)
	error (EXIT_TROUBLE, 0, "%s", err);
      beg = lim;
    }
  while (beg < pat + psize);

  if ((err = kwsprep (kwset)) != NULL)
    error (EXIT_TROUBLE, 0, "%s", err);
}

EXECUTE_FCT(Fexecute)
{
  char const *beg, *try, *end, *mb_start;
  size_t len;
  char eol = eolbyte;
  struct kwsmatch kwsmatch;
  size_t ret_val;
#ifdef MBS_SUPPORT
  if (MB_CUR_MAX > 1)
    {
      
//Patch 0:
if ((match_icase) && !(__is_neg(16, &(match_icase), sizeof (match_icase), &(buf), sizeof (buf), &(size), sizeof (size), &(start_ptr), sizeof (start_ptr), &(eolbyte), sizeof (eolbyte), &(beg), sizeof (beg), &(mb_start), sizeof (mb_start), &(kwset), sizeof (kwset), &(len), sizeof (len), &(match_words), sizeof (match_words), &(match_lines), sizeof (match_lines), &(eol), sizeof (eol), &(try), sizeof (try), &(ret_val), sizeof (ret_val), &(end), sizeof (end), &(match_size), sizeof (match_size)))) {
    char *case_buf = mbtolower(buf, &size);
    if (start_ptr)
        start_ptr = case_buf + (start_ptr - buf);
    buf = case_buf;
}

//CodeSeg 1:
    }
#endif /* MBS_SUPPORT */

  for (mb_start = beg = start_ptr ? start_ptr : buf; beg <= buf + size; beg++)
    {
      size_t offset = kwsexec (kwset, beg, buf + size - beg, &kwsmatch);
      if (offset == (size_t) -1)
	goto failure;
#ifdef MBS_SUPPORT
      if (MB_CUR_MAX > 1 && is_mb_middle (&mb_start, beg + offset, buf + size))
        {
          beg = mb_start - 1;
          continue; /* It is a part of multibyte character.  */
        }
#endif /* MBS_SUPPORT */
      beg += offset;
      len = kwsmatch.size[0];
      if (start_ptr && !match_words)
	goto success_in_beg_and_len;
      if (match_lines)
	{
	  if (beg > buf && beg[-1] != eol)
	    continue;
	  if (beg + len < buf + size && beg[len] != eol)
	    continue;
	  goto success;
	}
      else if (match_words)
	for (try = beg; len; )
	  {
	    if (try > buf && WCHAR((unsigned char) try[-1]))
	      break;
	    if (try + len < buf + size && WCHAR((unsigned char) try[len]))
	      {
		offset = kwsexec (kwset, beg, --len, &kwsmatch);
		if (offset == (size_t) -1)
		  break;
		try = beg + offset;
		len = kwsmatch.size[0];
	      }
	    else if (!start_ptr)
	      goto success;
	    else
	      goto success_in_beg_and_len;
	  } /* for (try) */
      else
	goto success;
    } /* for (beg in buf) */

 failure:
  ret_val = -1;
  goto out;

 success:
  if ((end = memchr (beg + len, eol, (buf + size) - (beg + len))) != NULL)
    end++;
  else
    end = buf + size;
  while (buf < beg && beg[-1] != eol)
    --beg;
  len = end - beg;
 success_in_beg_and_len:
  *match_size = len;
  ret_val = beg - buf;
 out:
  return ret_val;
}
#endif /* defined(GREP_PROGRAM) || defined(FGREP_PROGRAM) */

#ifdef GREP_PROGRAM
#if HAVE_LIBPCRE
/* Compiled internal form of a Perl regular expression.  */
static pcre *cre;

/* Additional information about the pattern.  */
static pcre_extra *extra;
#endif

COMPILE_FCT(Pcompile)
{
#if !HAVE_LIBPCRE
  error (EXIT_TROUBLE, 0, "%s",
	 _("support for the -P option is not compiled into "
	   "this --disable-perl-regexp binary"));
#else
  int e;
  char const *ep;
  char *re = xmalloc (4 * size + 7);
  int flags = PCRE_MULTILINE | (match_icase ? PCRE_CASELESS : 0);
  char const *patlim = pattern + size;
  char *n = re;
  char const *p;
  char const *pnul;

  /* FIXME: Remove these restrictions.  */
  if (memchr(pattern, '\n', size))
    error (EXIT_TROUBLE, 0, _("the -P option only supports a single pattern"));

  *n = '\0';
  if (match_lines)
    strcpy (n, "^(");
  if (match_words)
    strcpy (n, "\\b(");
  n += strlen (n);

  /* The PCRE interface doesn't allow NUL bytes in the pattern, so
     replace each NUL byte in the pattern with the four characters
     "\000", removing a preceding backslash if there are an odd
     number of backslashes before the NUL.

     FIXME: This method does not work with some multibyte character
     encodings, notably Shift-JIS, where a multibyte character can end
     in a backslash byte.  */
  for (p = pattern; (pnul = memchr (p, '\0', patlim - p)); p = pnul + 1)
    {
      memcpy (n, p, pnul - p);
      n += pnul - p;
      for (p = pnul; pattern < p && p[-1] == '\\'; p--)
	continue;
      n -= (pnul - p) & 1;
      strcpy (n, "\\000");
      n += 4;
    }

  memcpy (n, p, patlim - p);
  n += patlim - p;
  *n = '\0';
  if (match_words)
    strcpy (n, ")\\b");
  if (match_lines)
    strcpy (n, ")$");

  cre = pcre_compile (re, flags, &ep, &e, pcre_maketables ());
  if (!cre)
    error (EXIT_TROUBLE, 0, "%s", ep);

  extra = pcre_study (cre, 0, &ep);
  if (ep)
    error (EXIT_TROUBLE, 0, "%s", ep);

  free (re);
#endif
}

EXECUTE_FCT(Pexecute)
{
#if !HAVE_LIBPCRE
  abort ();
  return -1;
#else
  /* This array must have at least two elements; everything after that
     is just for performance improvement in pcre_exec.  */
  int sub[300];

  const char *line_buf, *line_end, *line_next;
  int e = PCRE_ERROR_NOMATCH;
  ptrdiff_t start_ofs = start_ptr ? start_ptr - buf : 0;

  /* PCRE can't limit the matching to single lines, therefore we have to
     match each line in the buffer separately.  */
  for (line_next = buf;
       e == PCRE_ERROR_NOMATCH && line_next < buf + size;
       start_ofs -= line_next - line_buf)
    {
      line_buf = line_next;
      line_end = memchr (line_buf, eolbyte, (buf + size) - line_buf);
      if (line_end == NULL)
        line_next = line_end = buf + size;
      else
        line_next = line_end + 1;

      if (start_ptr && start_ptr >= line_end)
        continue;

      e = pcre_exec (cre, extra, line_buf, line_end - line_buf,
                     start_ofs < 0 ? 0 : start_ofs, 0,
                     sub, sizeof sub / sizeof *sub);
    }

  if (e <= 0)
    {
      switch (e)
	{
	case PCRE_ERROR_NOMATCH:
	  return -1;

	case PCRE_ERROR_NOMEMORY:
	  error (EXIT_TROUBLE, 0, _("memory exhausted"));

	default:
	  abort ();
	}
    }
  else
    {
      /* Narrow down to the line we've found.  */
      char const *beg = line_buf + sub[0];
      char const *end = line_buf + sub[1];
      char const *buflim = buf + size;
      char eol = eolbyte;
      if (!start_ptr)
	{
	  /* FIXME: The case when '\n' is not found indicates a bug:
	     Since grep is line oriented, the match should never contain
	     a newline, so there _must_ be a newline following.
	   */
	  if (!(end = memchr (end, eol, buflim - end)))
	    end = buflim;
	  else
	    end++;
	  while (buf < beg && beg[-1] != eol)
	    --beg;
	}

      *match_size = end - beg;
      return beg - buf;
    }
#endif
}

struct matcher const matchers[] = {
  { "default", Gcompile, EGexecute },
  { "grep",    Gcompile, EGexecute },
  { "egrep",   Ecompile, EGexecute },
  { "awk",     Acompile, EGexecute },
  { "fgrep",   Fcompile, Fexecute },
  { "perl",    Pcompile, Pexecute },
  { "", 0, 0 },
};
#endif /* GREP_PROGRAM */

Spawn 1 instances, now Total 25
Counter: 26
Batcher Size:25
Preprocess the following candidate with CondTester:
Priority 20000
At location src/search.c:623
--Src File: src/search.c
Fragment 0:
if ((match_icase) || (__abst_hole(match_icase, buf, size, start_ptr, eolbyte, beg, mb_start, kwset, len, match_words, match_lines, eol, try, ret_val, end, match_size))) {
    char *case_buf = mbtolower(buf, &size);
    if (start_ptr)
        start_ptr = case_buf + (start_ptr - buf);
    buf = case_buf;
}


CondTester, a patch instance with id 25:
//src_file:src/search.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
/* search.c - searching subroutines using dfa, kwset and regex for grep.
   Copyright 1992, 1998, 2000, 2007, 2009-2010 Free Software Foundation, Inc.

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 3, or (at your option)
   any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program; if not, write to the Free Software
   Foundation, Inc., 51 Franklin Street - Fifth Floor, Boston, MA
   02110-1301, USA.  */

/* Written August 1992 by Mike Haertel. */

#include <config.h>

#include <sys/types.h>

#include "mbsupport.h"
#ifdef MBS_SUPPORT
/* We can handle multibyte strings. */
# include <wchar.h>
# include <wctype.h>
#endif

#include "system.h"
#include "grep.h"
#ifndef FGREP_PROGRAM
# include <regex.h>
# include "dfa.h"
#endif
#include "kwset.h"
#include "error.h"
#include "xalloc.h"
#ifdef HAVE_LIBPCRE
# include <pcre.h>
#endif

#define NCHAR (UCHAR_MAX + 1)

/* For -w, we also consider _ to be word constituent.  */
#define WCHAR(C) (ISALNUM(C) || (C) == '_')

/* KWset compiled pattern.  For Ecompile and Gcompile, we compile
   a list of strings, at least one of which is known to occur in
   any string matching the regexp. */
static kwset_t kwset;

static void
kwsinit (void)
{
  static char trans[NCHAR];
  int i;

  if (match_icase && MB_CUR_MAX == 1)
    {
      for (i = 0; i < NCHAR; ++i)
        trans[i] = TOLOWER (i);

      kwset = kwsalloc (trans);
    }
  else
    kwset = kwsalloc (NULL);

  if (!kwset)
    xalloc_die ();
}

#ifdef MBS_SUPPORT
/* Convert the *N-byte string, BEG, to lowercase, and write the
   NUL-terminated result into malloc'd storage.  Upon success, set *N
   to the length (in bytes) of the resulting string (not including the
   trailing NUL byte), and return a pointer to the lowercase string.
   Upon memory allocation failure, this function exits.

   Note that while this function returns a pointer to malloc'd storage,
   the caller must not free it, since this function retains a pointer
   to the buffer and reuses it on any subsequent call.  As a consequence,
   this function is not thread-safe.  */
static char *
mbtolower (const char *beg, size_t *n)
{
  static char *out;
  static size_t outalloc;
  size_t outlen, mb_cur_max;
  mbstate_t is, os;
  const char *end;
  char *p;

  if (*n > outalloc)
    {
      out = xrealloc (out, *n);
      outalloc = *n;
    }

  memset (&is, 0, sizeof (is));
  memset (&os, 0, sizeof (os));
  end = beg + *n;

  mb_cur_max = MB_CUR_MAX;
  p = out;
  outlen = 0;
  while (beg < end)
    {
      wchar_t wc;
      size_t mbclen = mbrtowc(&wc, beg, end - beg, &is);
      if (outlen + mb_cur_max >= outalloc)
        {
          out = x2nrealloc (out, &outalloc, 1);
          p = out + outlen;
        }

      if (mbclen == (size_t) -1 || mbclen == (size_t) -2 || mbclen == 0)
        {
          /* An invalid sequence, or a truncated multi-octet character.
             We treat it as a single-octet character.  */
          *p++ = *beg++;
          outlen++;
          memset (&is, 0, sizeof (is));
          memset (&os, 0, sizeof (os));
        }
      else
        {
          beg += mbclen;
          mbclen = wcrtomb (p, towlower ((wint_t) wc), &os);
          p += mbclen;
          outlen += mbclen;
        }
    }

  *n = p - out;
  *p++ = 0;
  return out;
}
#endif


#ifndef FGREP_PROGRAM
/* DFA compiled regexp. */
static struct dfa dfa;

/* The Regex compiled patterns.  */
static struct patterns
{
  /* Regex compiled regexp. */
  struct re_pattern_buffer regexbuf;
  struct re_registers regs; /* This is here on account of a BRAIN-DEAD
			       Q@#%!# library interface in regex.c.  */
} patterns0;

struct patterns *patterns;
size_t pcount;

void
dfaerror (char const *mesg)
{
  error (EXIT_TROUBLE, 0, "%s", mesg);
}

/* Number of compiled fixed strings known to exactly match the regexp.
   If kwsexec returns < kwset_exact_matches, then we don't need to
   call the regexp matcher at all. */
static int kwset_exact_matches;

static char const *
kwsincr_case (const char *must)
{
  const char *buf;
  size_t n;

  n = strlen (must);
#ifdef MBS_SUPPORT
  if (match_icase && MB_CUR_MAX > 1)
    buf = mbtolower (must, &n);
  else
#endif
    buf = must;
  return kwsincr (kwset, buf, n);
}

/* If the DFA turns out to have some set of fixed strings one of
   which must occur in the match, then we build a kwset matcher
   to find those strings, and thus quickly filter out impossible
   matches. */
static void
kwsmusts (void)
{
  struct dfamust const *dm;
  char const *err;

  if (dfa.musts)
    {
      kwsinit ();
      /* First, we compile in the substrings known to be exact
	 matches.  The kwset matcher will return the index
	 of the matching string that it chooses. */
      for (dm = dfa.musts; dm; dm = dm->next)
	{
	  if (!dm->exact)
	    continue;
	  ++kwset_exact_matches;
	  if ((err = kwsincr_case (dm->must)) != NULL)
	    error (EXIT_TROUBLE, 0, "%s", err);
	}
      /* Now, we compile the substrings that will require
	 the use of the regexp matcher.  */
      for (dm = dfa.musts; dm; dm = dm->next)
	{
	  if (dm->exact)
	    continue;
	  if ((err = kwsincr_case (dm->must)) != NULL)
	    error (EXIT_TROUBLE, 0, "%s", err);
	}
      if ((err = kwsprep (kwset)) != NULL)
	error (EXIT_TROUBLE, 0, "%s", err);
    }
}
#endif /* !FGREP_PROGRAM */

#ifdef MBS_SUPPORT

static bool
is_mb_middle(const char **good, const char *buf, const char *end)
{
  const char *p = *good;
  const char *prev = p;
  mbstate_t cur_state;

  /* TODO: can be optimized for UTF-8.  */
  memset(&cur_state, 0, sizeof(mbstate_t));
  while (p < buf)
    {
      size_t mbclen = mbrlen(p, end - p, &cur_state);

      /* Store the beginning of the previous complete multibyte character.  */
      if (mbclen != (size_t) -2)
        prev = p;

      if (mbclen == (size_t) -1 || mbclen == (size_t) -2 || mbclen == 0)
	{
	  /* An invalid sequence, or a truncated multibyte character.
	     We treat it as a single byte character.  */
	  mbclen = 1;
	}
      p += mbclen;
    }

  *good = prev;
  return p > buf;
}
#endif /* MBS_SUPPORT */

#if defined(GREP_PROGRAM) || defined(EGREP_PROGRAM)
#ifdef EGREP_PROGRAM
COMPILE_FCT(Ecompile)
{
  reg_syntax_t syntax_bits = RE_SYNTAX_POSIX_EGREP;
#else
/* No __VA_ARGS__ in C89.  So we have to do it this way.  */
static COMPILE_RET
GEAcompile (char const *pattern, size_t size, reg_syntax_t syntax_bits)
{
#endif /* EGREP_PROGRAM */
  const char *err;
  const char *p, *sep;
  size_t total = size;
  char *motif;

  if (match_icase)
    syntax_bits |= RE_ICASE;
  re_set_syntax (syntax_bits);
  dfasyntax (syntax_bits, match_icase, eolbyte);

  /* For GNU regex compiler we have to pass the patterns separately to detect
     errors like "[\nallo\n]\n".  The patterns here are "[", "allo" and "]"
     GNU regex should have raise a syntax error.  The same for backref, where
     the backref should have been local to each pattern.  */
  p = pattern;
  do
    {
      size_t len;
      sep = memchr (p, '\n', total);
      if (sep)
	{
	  len = sep - p;
	  sep++;
	  total -= (len + 1);
	}
      else
	{
	  len = total;
	  total = 0;
	}

      patterns = realloc (patterns, (pcount + 1) * sizeof (*patterns));
      if (patterns == NULL)
	error (EXIT_TROUBLE, errno, _("memory exhausted"));
      patterns[pcount] = patterns0;

      if ((err = re_compile_pattern (p, len,
				    &(patterns[pcount].regexbuf))) != NULL)
	error (EXIT_TROUBLE, 0, "%s", err);
      pcount++;

      p = sep;
    } while (sep && total != 0);

  /* In the match_words and match_lines cases, we use a different pattern
     for the DFA matcher that will quickly throw out cases that won't work.
     Then if DFA succeeds we do some hairy stuff using the regex matcher
     to decide whether the match should really count. */
  if (match_words || match_lines)
    {
      static char const line_beg_no_bk[] = "^(";
      static char const line_end_no_bk[] = ")$";
      static char const word_beg_no_bk[] = "(^|[^[:alnum:]_])(";
      static char const word_end_no_bk[] = ")([^[:alnum:]_]|$)";
#ifdef EGREP_PROGRAM
# define IF_BK(x, y) (y)
      char *n = xmalloc (sizeof word_beg_no_bk - 1 + size + sizeof word_end_no_bk);
#else
      static char const line_beg_bk[] = "^\\(";
      static char const line_end_bk[] = "\\)$";
      static char const word_beg_bk[] = "\\(^\\|[^[:alnum:]_]\\)\\(";
      static char const word_end_bk[] = "\\)\\([^[:alnum:]_]\\|$\\)";
      int bk = !(syntax_bits & RE_NO_BK_PARENS);
# define IF_BK(x, y) ((bk) ? (x) : (y))
      char *n = xmalloc (sizeof word_beg_bk - 1 + size + sizeof word_end_bk);
#endif /* EGREP_PROGRAM */

      strcpy (n, match_lines ? IF_BK(line_beg_bk, line_beg_no_bk)
			     : IF_BK(word_beg_bk, word_beg_no_bk));
      total = strlen(n);
      memcpy (n + total, pattern, size);
      total += size;
      strcpy (n + total, match_lines ? IF_BK(line_end_bk, line_end_no_bk)
				     : IF_BK(word_end_bk, word_end_no_bk));
      total += strlen (n + total);
      pattern = motif = n;
      size = total;
    }
  else
    motif = NULL;

  dfacomp (pattern, size, &dfa, 1);
  kwsmusts ();

  free(motif);
}

#ifndef EGREP_PROGRAM
COMPILE_FCT(Gcompile)
{
  return GEAcompile (pattern, size,
		     RE_SYNTAX_GREP | RE_HAT_LISTS_NOT_NEWLINE);
}

COMPILE_FCT(Acompile)
{
  return GEAcompile (pattern, size, RE_SYNTAX_AWK);
}

COMPILE_FCT(Ecompile)
{
  return GEAcompile (pattern, size, RE_SYNTAX_POSIX_EGREP);
}
#endif /* !EGREP_PROGRAM */

EXECUTE_FCT(EGexecute)
{
  char const *buflim, *beg, *end, *match, *best_match, *mb_start;
  char eol = eolbyte;
  int backref, start, len, best_len;
  struct kwsmatch kwsm;
  size_t i, ret_val;
#ifdef MBS_SUPPORT
  if (MB_CUR_MAX > 1)
    {
      if (match_icase)
        {
          /* mbtolower adds a NUL byte at the end.  That will provide
	     space for the sentinel byte dfaexec may add.  */
          char *case_buf = mbtolower (buf, &size);
	  if (start_ptr)
	    start_ptr = case_buf + (start_ptr - buf);
          buf = case_buf;
        }
    }
#endif /* MBS_SUPPORT */

  mb_start = buf;
  buflim = buf + size;

  for (beg = end = buf; end < buflim; beg = end)
    {
      if (!start_ptr)
	{
	  /* We don't care about an exact match.  */
	  if (kwset)
	    {
	      /* Find a possible match using the KWset matcher. */
	      size_t offset = kwsexec (kwset, beg, buflim - beg, &kwsm);
	      if (offset == (size_t) -1)
		goto failure;
	      beg += offset;
	      /* Narrow down to the line containing the candidate, and
		 run it through DFA. */
	      if ((end = memchr(beg, eol, buflim - beg)) != NULL)
	        end++;
              else
                end = buflim;
	      match = beg;
	      while (beg > buf && beg[-1] != eol)
		--beg;
	      if (kwsm.index < kwset_exact_matches)
                {
#ifdef MBS_SUPPORT
                  if (mb_start < beg)
                    mb_start = beg;
                  if (MB_CUR_MAX == 1 || !is_mb_middle (&mb_start, match, buflim))
#endif
                    goto success;
                }
	      if (dfaexec (&dfa, beg, (char *) end, 0, NULL, &backref) == NULL)
		continue;
	    }
	  else
	    {
	      /* No good fixed strings; start with DFA. */
	      char const *next_beg = dfaexec (&dfa, beg, (char *) buflim,
					      0, NULL, &backref);
	      if (next_beg == NULL)
		break;
	      /* Narrow down to the line we've found. */
	      beg = next_beg;
	      if ((end = memchr(beg, eol, buflim - beg)) != NULL)
	        end++;
              else
                end = buflim;
	      while (beg > buf && beg[-1] != eol)
		--beg;
	    }
	  /* Successful, no backreferences encountered! */
	  if (!backref)
	    goto success;
	}
      else
	{
	  /* We are looking for the leftmost (then longest) exact match.
	     We will go through the outer loop only once.  */
	  beg = start_ptr;
	  end = buflim;
	}

      /* If we've made it to this point, this means DFA has seen
	 a probable match, and we need to run it through Regex. */
      best_match = end;
      best_len = 0;
      for (i = 0; i < pcount; i++)
	{
	  patterns[i].regexbuf.not_eol = 0;
	  if (0 <= (start = re_search (&(patterns[i].regexbuf),
				       buf, end - buf - 1,
				       beg - buf, end - beg - 1,
				       &(patterns[i].regs))))
	    {
	      len = patterns[i].regs.end[0] - start;
	      match = buf + start;
	      if (match > best_match)
		continue;
	      if (start_ptr && !match_words)
		goto assess_pattern_match;
	      if ((!match_lines && !match_words)
		  || (match_lines && len == end - beg - 1))
		{
		  match = beg;
		  len = end - beg;
		  goto assess_pattern_match;
		}
	      /* If -w, check if the match aligns with word boundaries.
		 We do this iteratively because:
		 (a) the line may contain more than one occurence of the
		 pattern, and
		 (b) Several alternatives in the pattern might be valid at a
		 given point, and we may need to consider a shorter one to
		 find a word boundary.  */
	      if (match_words)
		while (match <= best_match)
		  {
		    if ((match == buf || !WCHAR ((unsigned char) match[-1]))
			&& (len == end - beg - 1
			    || !WCHAR ((unsigned char) match[len])))
		      goto assess_pattern_match;
		    if (len > 0)
		      {
			/* Try a shorter length anchored at the same place. */
			--len;
			patterns[i].regexbuf.not_eol = 1;
			len = re_match (&(patterns[i].regexbuf),
					buf, match + len - beg, match - buf,
					&(patterns[i].regs));
		      }
		    if (len <= 0)
		      {
			/* Try looking further on. */
			if (match == end - 1)
			  break;
			match++;
			patterns[i].regexbuf.not_eol = 0;
			start = re_search (&(patterns[i].regexbuf),
					   buf, end - buf - 1,
					   match - buf, end - match - 1,
					   &(patterns[i].regs));
			if (start < 0)
			  break;
			len = patterns[i].regs.end[0] - start;
			match = buf + start;
		      }
		  } /* while (match <= best_match) */
	      continue;
	    assess_pattern_match:
	      if (!start_ptr)
		{
		  /* Good enough for a non-exact match.
		     No need to look at further patterns, if any.  */
		  beg = match;
		  goto success_in_len;
		}
	      if (match < best_match || (match == best_match && len > best_len))
		{
		  /* Best exact match:  leftmost, then longest.  */
		  best_match = match;
		  best_len = len;
		}
	    } /* if re_search >= 0 */
	} /* for Regex patterns.  */
	if (best_match < end)
	  {
	    /* We have found an exact match.  We were just
	       waiting for the best one (leftmost then longest).  */
	    beg = best_match;
	    len = best_len;
	    goto success_in_len;
	  }
    } /* for (beg = end ..) */

 failure:
  ret_val = -1;
  goto out;

 success:
  len = end - beg;
 success_in_len:
  *match_size = len;
  ret_val = beg - buf;
 out:
  return ret_val;
}
#endif /* defined(GREP_PROGRAM) || defined(EGREP_PROGRAM) */

#if defined(GREP_PROGRAM) || defined(FGREP_PROGRAM)
COMPILE_FCT(Fcompile)
{
  char const *beg, *end, *lim, *err, *pat;
  size_t psize;

  kwsinit ();
  psize = size;
  if (match_icase && MB_CUR_MAX > 1)
    pat = mbtolower (pattern, &psize);
  else
    pat = pattern;

  beg = pat;
  do
    {
      for (lim = beg;; ++lim)
	{
	  end = lim;
	  if (lim >= pat + psize)
	    break;
	 if (*lim == '\n')
	   {
	     lim++;
	     break;
	   }
#if HAVE_DOS_FILE_CONTENTS
	 if (*lim == '\r' && lim + 1 < pat + psize && lim[1] == '\n')
	   {
	     lim += 2;
	     break;
	   }
#endif
	}

      if ((err = kwsincr (kwset, beg, end - beg)) != NULL)
	error (EXIT_TROUBLE, 0, "%s", err);
      beg = lim;
    }
  while (beg < pat + psize);

  if ((err = kwsprep (kwset)) != NULL)
    error (EXIT_TROUBLE, 0, "%s", err);
}

EXECUTE_FCT(Fexecute)
{
  char const *beg, *try, *end, *mb_start;
  size_t len;
  char eol = eolbyte;
  struct kwsmatch kwsmatch;
  size_t ret_val;
#ifdef MBS_SUPPORT
  if (MB_CUR_MAX > 1)
    {
      
//Patch 0:
if ((match_icase) || (__is_neg(16, &(match_icase), sizeof (match_icase), &(buf), sizeof (buf), &(size), sizeof (size), &(start_ptr), sizeof (start_ptr), &(eolbyte), sizeof (eolbyte), &(beg), sizeof (beg), &(mb_start), sizeof (mb_start), &(kwset), sizeof (kwset), &(len), sizeof (len), &(match_words), sizeof (match_words), &(match_lines), sizeof (match_lines), &(eol), sizeof (eol), &(try), sizeof (try), &(ret_val), sizeof (ret_val), &(end), sizeof (end), &(match_size), sizeof (match_size)))) {
    char *case_buf = mbtolower(buf, &size);
    if (start_ptr)
        start_ptr = case_buf + (start_ptr - buf);
    buf = case_buf;
}

//CodeSeg 1:
    }
#endif /* MBS_SUPPORT */

  for (mb_start = beg = start_ptr ? start_ptr : buf; beg <= buf + size; beg++)
    {
      size_t offset = kwsexec (kwset, beg, buf + size - beg, &kwsmatch);
      if (offset == (size_t) -1)
	goto failure;
#ifdef MBS_SUPPORT
      if (MB_CUR_MAX > 1 && is_mb_middle (&mb_start, beg + offset, buf + size))
        {
          beg = mb_start - 1;
          continue; /* It is a part of multibyte character.  */
        }
#endif /* MBS_SUPPORT */
      beg += offset;
      len = kwsmatch.size[0];
      if (start_ptr && !match_words)
	goto success_in_beg_and_len;
      if (match_lines)
	{
	  if (beg > buf && beg[-1] != eol)
	    continue;
	  if (beg + len < buf + size && beg[len] != eol)
	    continue;
	  goto success;
	}
      else if (match_words)
	for (try = beg; len; )
	  {
	    if (try > buf && WCHAR((unsigned char) try[-1]))
	      break;
	    if (try + len < buf + size && WCHAR((unsigned char) try[len]))
	      {
		offset = kwsexec (kwset, beg, --len, &kwsmatch);
		if (offset == (size_t) -1)
		  break;
		try = beg + offset;
		len = kwsmatch.size[0];
	      }
	    else if (!start_ptr)
	      goto success;
	    else
	      goto success_in_beg_and_len;
	  } /* for (try) */
      else
	goto success;
    } /* for (beg in buf) */

 failure:
  ret_val = -1;
  goto out;

 success:
  if ((end = memchr (beg + len, eol, (buf + size) - (beg + len))) != NULL)
    end++;
  else
    end = buf + size;
  while (buf < beg && beg[-1] != eol)
    --beg;
  len = end - beg;
 success_in_beg_and_len:
  *match_size = len;
  ret_val = beg - buf;
 out:
  return ret_val;
}
#endif /* defined(GREP_PROGRAM) || defined(FGREP_PROGRAM) */

#ifdef GREP_PROGRAM
#if HAVE_LIBPCRE
/* Compiled internal form of a Perl regular expression.  */
static pcre *cre;

/* Additional information about the pattern.  */
static pcre_extra *extra;
#endif

COMPILE_FCT(Pcompile)
{
#if !HAVE_LIBPCRE
  error (EXIT_TROUBLE, 0, "%s",
	 _("support for the -P option is not compiled into "
	   "this --disable-perl-regexp binary"));
#else
  int e;
  char const *ep;
  char *re = xmalloc (4 * size + 7);
  int flags = PCRE_MULTILINE | (match_icase ? PCRE_CASELESS : 0);
  char const *patlim = pattern + size;
  char *n = re;
  char const *p;
  char const *pnul;

  /* FIXME: Remove these restrictions.  */
  if (memchr(pattern, '\n', size))
    error (EXIT_TROUBLE, 0, _("the -P option only supports a single pattern"));

  *n = '\0';
  if (match_lines)
    strcpy (n, "^(");
  if (match_words)
    strcpy (n, "\\b(");
  n += strlen (n);

  /* The PCRE interface doesn't allow NUL bytes in the pattern, so
     replace each NUL byte in the pattern with the four characters
     "\000", removing a preceding backslash if there are an odd
     number of backslashes before the NUL.

     FIXME: This method does not work with some multibyte character
     encodings, notably Shift-JIS, where a multibyte character can end
     in a backslash byte.  */
  for (p = pattern; (pnul = memchr (p, '\0', patlim - p)); p = pnul + 1)
    {
      memcpy (n, p, pnul - p);
      n += pnul - p;
      for (p = pnul; pattern < p && p[-1] == '\\'; p--)
	continue;
      n -= (pnul - p) & 1;
      strcpy (n, "\\000");
      n += 4;
    }

  memcpy (n, p, patlim - p);
  n += patlim - p;
  *n = '\0';
  if (match_words)
    strcpy (n, ")\\b");
  if (match_lines)
    strcpy (n, ")$");

  cre = pcre_compile (re, flags, &ep, &e, pcre_maketables ());
  if (!cre)
    error (EXIT_TROUBLE, 0, "%s", ep);

  extra = pcre_study (cre, 0, &ep);
  if (ep)
    error (EXIT_TROUBLE, 0, "%s", ep);

  free (re);
#endif
}

EXECUTE_FCT(Pexecute)
{
#if !HAVE_LIBPCRE
  abort ();
  return -1;
#else
  /* This array must have at least two elements; everything after that
     is just for performance improvement in pcre_exec.  */
  int sub[300];

  const char *line_buf, *line_end, *line_next;
  int e = PCRE_ERROR_NOMATCH;
  ptrdiff_t start_ofs = start_ptr ? start_ptr - buf : 0;

  /* PCRE can't limit the matching to single lines, therefore we have to
     match each line in the buffer separately.  */
  for (line_next = buf;
       e == PCRE_ERROR_NOMATCH && line_next < buf + size;
       start_ofs -= line_next - line_buf)
    {
      line_buf = line_next;
      line_end = memchr (line_buf, eolbyte, (buf + size) - line_buf);
      if (line_end == NULL)
        line_next = line_end = buf + size;
      else
        line_next = line_end + 1;

      if (start_ptr && start_ptr >= line_end)
        continue;

      e = pcre_exec (cre, extra, line_buf, line_end - line_buf,
                     start_ofs < 0 ? 0 : start_ofs, 0,
                     sub, sizeof sub / sizeof *sub);
    }

  if (e <= 0)
    {
      switch (e)
	{
	case PCRE_ERROR_NOMATCH:
	  return -1;

	case PCRE_ERROR_NOMEMORY:
	  error (EXIT_TROUBLE, 0, _("memory exhausted"));

	default:
	  abort ();
	}
    }
  else
    {
      /* Narrow down to the line we've found.  */
      char const *beg = line_buf + sub[0];
      char const *end = line_buf + sub[1];
      char const *buflim = buf + size;
      char eol = eolbyte;
      if (!start_ptr)
	{
	  /* FIXME: The case when '\n' is not found indicates a bug:
	     Since grep is line oriented, the match should never contain
	     a newline, so there _must_ be a newline following.
	   */
	  if (!(end = memchr (end, eol, buflim - end)))
	    end = buflim;
	  else
	    end++;
	  while (buf < beg && beg[-1] != eol)
	    --beg;
	}

      *match_size = end - beg;
      return beg - buf;
    }
#endif
}

struct matcher const matchers[] = {
  { "default", Gcompile, EGexecute },
  { "grep",    Gcompile, EGexecute },
  { "egrep",   Ecompile, EGexecute },
  { "awk",     Acompile, EGexecute },
  { "fgrep",   Fcompile, Fexecute },
  { "perl",    Pcompile, Pexecute },
  { "", 0, 0 },
};
#endif /* GREP_PROGRAM */

Spawn 1 instances, now Total 26
Counter: 27
Batcher Size:26
Preprocess the following candidate with CondTester:
Priority 20000
At location src/search.c:621
--Src File: src/search.c
Fragment 0:
if (((__ctype_get_mb_cur_max()) > 1) && !(__abst_hole(match_icase, buf, size, eolbyte, start_ptr, beg, mb_start, kwset, len, match_words, match_lines, eol, try, ret_val, end, match_size))) {
    if (match_icase) {
        char *case_buf = mbtolower(buf, &size);
        if (start_ptr)
            start_ptr = case_buf + (start_ptr - buf);
        buf = case_buf;
    }
}


CondTester, a patch instance with id 26:
//src_file:src/search.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
/* search.c - searching subroutines using dfa, kwset and regex for grep.
   Copyright 1992, 1998, 2000, 2007, 2009-2010 Free Software Foundation, Inc.

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 3, or (at your option)
   any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program; if not, write to the Free Software
   Foundation, Inc., 51 Franklin Street - Fifth Floor, Boston, MA
   02110-1301, USA.  */

/* Written August 1992 by Mike Haertel. */

#include <config.h>

#include <sys/types.h>

#include "mbsupport.h"
#ifdef MBS_SUPPORT
/* We can handle multibyte strings. */
# include <wchar.h>
# include <wctype.h>
#endif

#include "system.h"
#include "grep.h"
#ifndef FGREP_PROGRAM
# include <regex.h>
# include "dfa.h"
#endif
#include "kwset.h"
#include "error.h"
#include "xalloc.h"
#ifdef HAVE_LIBPCRE
# include <pcre.h>
#endif

#define NCHAR (UCHAR_MAX + 1)

/* For -w, we also consider _ to be word constituent.  */
#define WCHAR(C) (ISALNUM(C) || (C) == '_')

/* KWset compiled pattern.  For Ecompile and Gcompile, we compile
   a list of strings, at least one of which is known to occur in
   any string matching the regexp. */
static kwset_t kwset;

static void
kwsinit (void)
{
  static char trans[NCHAR];
  int i;

  if (match_icase && MB_CUR_MAX == 1)
    {
      for (i = 0; i < NCHAR; ++i)
        trans[i] = TOLOWER (i);

      kwset = kwsalloc (trans);
    }
  else
    kwset = kwsalloc (NULL);

  if (!kwset)
    xalloc_die ();
}

#ifdef MBS_SUPPORT
/* Convert the *N-byte string, BEG, to lowercase, and write the
   NUL-terminated result into malloc'd storage.  Upon success, set *N
   to the length (in bytes) of the resulting string (not including the
   trailing NUL byte), and return a pointer to the lowercase string.
   Upon memory allocation failure, this function exits.

   Note that while this function returns a pointer to malloc'd storage,
   the caller must not free it, since this function retains a pointer
   to the buffer and reuses it on any subsequent call.  As a consequence,
   this function is not thread-safe.  */
static char *
mbtolower (const char *beg, size_t *n)
{
  static char *out;
  static size_t outalloc;
  size_t outlen, mb_cur_max;
  mbstate_t is, os;
  const char *end;
  char *p;

  if (*n > outalloc)
    {
      out = xrealloc (out, *n);
      outalloc = *n;
    }

  memset (&is, 0, sizeof (is));
  memset (&os, 0, sizeof (os));
  end = beg + *n;

  mb_cur_max = MB_CUR_MAX;
  p = out;
  outlen = 0;
  while (beg < end)
    {
      wchar_t wc;
      size_t mbclen = mbrtowc(&wc, beg, end - beg, &is);
      if (outlen + mb_cur_max >= outalloc)
        {
          out = x2nrealloc (out, &outalloc, 1);
          p = out + outlen;
        }

      if (mbclen == (size_t) -1 || mbclen == (size_t) -2 || mbclen == 0)
        {
          /* An invalid sequence, or a truncated multi-octet character.
             We treat it as a single-octet character.  */
          *p++ = *beg++;
          outlen++;
          memset (&is, 0, sizeof (is));
          memset (&os, 0, sizeof (os));
        }
      else
        {
          beg += mbclen;
          mbclen = wcrtomb (p, towlower ((wint_t) wc), &os);
          p += mbclen;
          outlen += mbclen;
        }
    }

  *n = p - out;
  *p++ = 0;
  return out;
}
#endif


#ifndef FGREP_PROGRAM
/* DFA compiled regexp. */
static struct dfa dfa;

/* The Regex compiled patterns.  */
static struct patterns
{
  /* Regex compiled regexp. */
  struct re_pattern_buffer regexbuf;
  struct re_registers regs; /* This is here on account of a BRAIN-DEAD
			       Q@#%!# library interface in regex.c.  */
} patterns0;

struct patterns *patterns;
size_t pcount;

void
dfaerror (char const *mesg)
{
  error (EXIT_TROUBLE, 0, "%s", mesg);
}

/* Number of compiled fixed strings known to exactly match the regexp.
   If kwsexec returns < kwset_exact_matches, then we don't need to
   call the regexp matcher at all. */
static int kwset_exact_matches;

static char const *
kwsincr_case (const char *must)
{
  const char *buf;
  size_t n;

  n = strlen (must);
#ifdef MBS_SUPPORT
  if (match_icase && MB_CUR_MAX > 1)
    buf = mbtolower (must, &n);
  else
#endif
    buf = must;
  return kwsincr (kwset, buf, n);
}

/* If the DFA turns out to have some set of fixed strings one of
   which must occur in the match, then we build a kwset matcher
   to find those strings, and thus quickly filter out impossible
   matches. */
static void
kwsmusts (void)
{
  struct dfamust const *dm;
  char const *err;

  if (dfa.musts)
    {
      kwsinit ();
      /* First, we compile in the substrings known to be exact
	 matches.  The kwset matcher will return the index
	 of the matching string that it chooses. */
      for (dm = dfa.musts; dm; dm = dm->next)
	{
	  if (!dm->exact)
	    continue;
	  ++kwset_exact_matches;
	  if ((err = kwsincr_case (dm->must)) != NULL)
	    error (EXIT_TROUBLE, 0, "%s", err);
	}
      /* Now, we compile the substrings that will require
	 the use of the regexp matcher.  */
      for (dm = dfa.musts; dm; dm = dm->next)
	{
	  if (dm->exact)
	    continue;
	  if ((err = kwsincr_case (dm->must)) != NULL)
	    error (EXIT_TROUBLE, 0, "%s", err);
	}
      if ((err = kwsprep (kwset)) != NULL)
	error (EXIT_TROUBLE, 0, "%s", err);
    }
}
#endif /* !FGREP_PROGRAM */

#ifdef MBS_SUPPORT

static bool
is_mb_middle(const char **good, const char *buf, const char *end)
{
  const char *p = *good;
  const char *prev = p;
  mbstate_t cur_state;

  /* TODO: can be optimized for UTF-8.  */
  memset(&cur_state, 0, sizeof(mbstate_t));
  while (p < buf)
    {
      size_t mbclen = mbrlen(p, end - p, &cur_state);

      /* Store the beginning of the previous complete multibyte character.  */
      if (mbclen != (size_t) -2)
        prev = p;

      if (mbclen == (size_t) -1 || mbclen == (size_t) -2 || mbclen == 0)
	{
	  /* An invalid sequence, or a truncated multibyte character.
	     We treat it as a single byte character.  */
	  mbclen = 1;
	}
      p += mbclen;
    }

  *good = prev;
  return p > buf;
}
#endif /* MBS_SUPPORT */

#if defined(GREP_PROGRAM) || defined(EGREP_PROGRAM)
#ifdef EGREP_PROGRAM
COMPILE_FCT(Ecompile)
{
  reg_syntax_t syntax_bits = RE_SYNTAX_POSIX_EGREP;
#else
/* No __VA_ARGS__ in C89.  So we have to do it this way.  */
static COMPILE_RET
GEAcompile (char const *pattern, size_t size, reg_syntax_t syntax_bits)
{
#endif /* EGREP_PROGRAM */
  const char *err;
  const char *p, *sep;
  size_t total = size;
  char *motif;

  if (match_icase)
    syntax_bits |= RE_ICASE;
  re_set_syntax (syntax_bits);
  dfasyntax (syntax_bits, match_icase, eolbyte);

  /* For GNU regex compiler we have to pass the patterns separately to detect
     errors like "[\nallo\n]\n".  The patterns here are "[", "allo" and "]"
     GNU regex should have raise a syntax error.  The same for backref, where
     the backref should have been local to each pattern.  */
  p = pattern;
  do
    {
      size_t len;
      sep = memchr (p, '\n', total);
      if (sep)
	{
	  len = sep - p;
	  sep++;
	  total -= (len + 1);
	}
      else
	{
	  len = total;
	  total = 0;
	}

      patterns = realloc (patterns, (pcount + 1) * sizeof (*patterns));
      if (patterns == NULL)
	error (EXIT_TROUBLE, errno, _("memory exhausted"));
      patterns[pcount] = patterns0;

      if ((err = re_compile_pattern (p, len,
				    &(patterns[pcount].regexbuf))) != NULL)
	error (EXIT_TROUBLE, 0, "%s", err);
      pcount++;

      p = sep;
    } while (sep && total != 0);

  /* In the match_words and match_lines cases, we use a different pattern
     for the DFA matcher that will quickly throw out cases that won't work.
     Then if DFA succeeds we do some hairy stuff using the regex matcher
     to decide whether the match should really count. */
  if (match_words || match_lines)
    {
      static char const line_beg_no_bk[] = "^(";
      static char const line_end_no_bk[] = ")$";
      static char const word_beg_no_bk[] = "(^|[^[:alnum:]_])(";
      static char const word_end_no_bk[] = ")([^[:alnum:]_]|$)";
#ifdef EGREP_PROGRAM
# define IF_BK(x, y) (y)
      char *n = xmalloc (sizeof word_beg_no_bk - 1 + size + sizeof word_end_no_bk);
#else
      static char const line_beg_bk[] = "^\\(";
      static char const line_end_bk[] = "\\)$";
      static char const word_beg_bk[] = "\\(^\\|[^[:alnum:]_]\\)\\(";
      static char const word_end_bk[] = "\\)\\([^[:alnum:]_]\\|$\\)";
      int bk = !(syntax_bits & RE_NO_BK_PARENS);
# define IF_BK(x, y) ((bk) ? (x) : (y))
      char *n = xmalloc (sizeof word_beg_bk - 1 + size + sizeof word_end_bk);
#endif /* EGREP_PROGRAM */

      strcpy (n, match_lines ? IF_BK(line_beg_bk, line_beg_no_bk)
			     : IF_BK(word_beg_bk, word_beg_no_bk));
      total = strlen(n);
      memcpy (n + total, pattern, size);
      total += size;
      strcpy (n + total, match_lines ? IF_BK(line_end_bk, line_end_no_bk)
				     : IF_BK(word_end_bk, word_end_no_bk));
      total += strlen (n + total);
      pattern = motif = n;
      size = total;
    }
  else
    motif = NULL;

  dfacomp (pattern, size, &dfa, 1);
  kwsmusts ();

  free(motif);
}

#ifndef EGREP_PROGRAM
COMPILE_FCT(Gcompile)
{
  return GEAcompile (pattern, size,
		     RE_SYNTAX_GREP | RE_HAT_LISTS_NOT_NEWLINE);
}

COMPILE_FCT(Acompile)
{
  return GEAcompile (pattern, size, RE_SYNTAX_AWK);
}

COMPILE_FCT(Ecompile)
{
  return GEAcompile (pattern, size, RE_SYNTAX_POSIX_EGREP);
}
#endif /* !EGREP_PROGRAM */

EXECUTE_FCT(EGexecute)
{
  char const *buflim, *beg, *end, *match, *best_match, *mb_start;
  char eol = eolbyte;
  int backref, start, len, best_len;
  struct kwsmatch kwsm;
  size_t i, ret_val;
#ifdef MBS_SUPPORT
  if (MB_CUR_MAX > 1)
    {
      if (match_icase)
        {
          /* mbtolower adds a NUL byte at the end.  That will provide
	     space for the sentinel byte dfaexec may add.  */
          char *case_buf = mbtolower (buf, &size);
	  if (start_ptr)
	    start_ptr = case_buf + (start_ptr - buf);
          buf = case_buf;
        }
    }
#endif /* MBS_SUPPORT */

  mb_start = buf;
  buflim = buf + size;

  for (beg = end = buf; end < buflim; beg = end)
    {
      if (!start_ptr)
	{
	  /* We don't care about an exact match.  */
	  if (kwset)
	    {
	      /* Find a possible match using the KWset matcher. */
	      size_t offset = kwsexec (kwset, beg, buflim - beg, &kwsm);
	      if (offset == (size_t) -1)
		goto failure;
	      beg += offset;
	      /* Narrow down to the line containing the candidate, and
		 run it through DFA. */
	      if ((end = memchr(beg, eol, buflim - beg)) != NULL)
	        end++;
              else
                end = buflim;
	      match = beg;
	      while (beg > buf && beg[-1] != eol)
		--beg;
	      if (kwsm.index < kwset_exact_matches)
                {
#ifdef MBS_SUPPORT
                  if (mb_start < beg)
                    mb_start = beg;
                  if (MB_CUR_MAX == 1 || !is_mb_middle (&mb_start, match, buflim))
#endif
                    goto success;
                }
	      if (dfaexec (&dfa, beg, (char *) end, 0, NULL, &backref) == NULL)
		continue;
	    }
	  else
	    {
	      /* No good fixed strings; start with DFA. */
	      char const *next_beg = dfaexec (&dfa, beg, (char *) buflim,
					      0, NULL, &backref);
	      if (next_beg == NULL)
		break;
	      /* Narrow down to the line we've found. */
	      beg = next_beg;
	      if ((end = memchr(beg, eol, buflim - beg)) != NULL)
	        end++;
              else
                end = buflim;
	      while (beg > buf && beg[-1] != eol)
		--beg;
	    }
	  /* Successful, no backreferences encountered! */
	  if (!backref)
	    goto success;
	}
      else
	{
	  /* We are looking for the leftmost (then longest) exact match.
	     We will go through the outer loop only once.  */
	  beg = start_ptr;
	  end = buflim;
	}

      /* If we've made it to this point, this means DFA has seen
	 a probable match, and we need to run it through Regex. */
      best_match = end;
      best_len = 0;
      for (i = 0; i < pcount; i++)
	{
	  patterns[i].regexbuf.not_eol = 0;
	  if (0 <= (start = re_search (&(patterns[i].regexbuf),
				       buf, end - buf - 1,
				       beg - buf, end - beg - 1,
				       &(patterns[i].regs))))
	    {
	      len = patterns[i].regs.end[0] - start;
	      match = buf + start;
	      if (match > best_match)
		continue;
	      if (start_ptr && !match_words)
		goto assess_pattern_match;
	      if ((!match_lines && !match_words)
		  || (match_lines && len == end - beg - 1))
		{
		  match = beg;
		  len = end - beg;
		  goto assess_pattern_match;
		}
	      /* If -w, check if the match aligns with word boundaries.
		 We do this iteratively because:
		 (a) the line may contain more than one occurence of the
		 pattern, and
		 (b) Several alternatives in the pattern might be valid at a
		 given point, and we may need to consider a shorter one to
		 find a word boundary.  */
	      if (match_words)
		while (match <= best_match)
		  {
		    if ((match == buf || !WCHAR ((unsigned char) match[-1]))
			&& (len == end - beg - 1
			    || !WCHAR ((unsigned char) match[len])))
		      goto assess_pattern_match;
		    if (len > 0)
		      {
			/* Try a shorter length anchored at the same place. */
			--len;
			patterns[i].regexbuf.not_eol = 1;
			len = re_match (&(patterns[i].regexbuf),
					buf, match + len - beg, match - buf,
					&(patterns[i].regs));
		      }
		    if (len <= 0)
		      {
			/* Try looking further on. */
			if (match == end - 1)
			  break;
			match++;
			patterns[i].regexbuf.not_eol = 0;
			start = re_search (&(patterns[i].regexbuf),
					   buf, end - buf - 1,
					   match - buf, end - match - 1,
					   &(patterns[i].regs));
			if (start < 0)
			  break;
			len = patterns[i].regs.end[0] - start;
			match = buf + start;
		      }
		  } /* while (match <= best_match) */
	      continue;
	    assess_pattern_match:
	      if (!start_ptr)
		{
		  /* Good enough for a non-exact match.
		     No need to look at further patterns, if any.  */
		  beg = match;
		  goto success_in_len;
		}
	      if (match < best_match || (match == best_match && len > best_len))
		{
		  /* Best exact match:  leftmost, then longest.  */
		  best_match = match;
		  best_len = len;
		}
	    } /* if re_search >= 0 */
	} /* for Regex patterns.  */
	if (best_match < end)
	  {
	    /* We have found an exact match.  We were just
	       waiting for the best one (leftmost then longest).  */
	    beg = best_match;
	    len = best_len;
	    goto success_in_len;
	  }
    } /* for (beg = end ..) */

 failure:
  ret_val = -1;
  goto out;

 success:
  len = end - beg;
 success_in_len:
  *match_size = len;
  ret_val = beg - buf;
 out:
  return ret_val;
}
#endif /* defined(GREP_PROGRAM) || defined(EGREP_PROGRAM) */

#if defined(GREP_PROGRAM) || defined(FGREP_PROGRAM)
COMPILE_FCT(Fcompile)
{
  char const *beg, *end, *lim, *err, *pat;
  size_t psize;

  kwsinit ();
  psize = size;
  if (match_icase && MB_CUR_MAX > 1)
    pat = mbtolower (pattern, &psize);
  else
    pat = pattern;

  beg = pat;
  do
    {
      for (lim = beg;; ++lim)
	{
	  end = lim;
	  if (lim >= pat + psize)
	    break;
	 if (*lim == '\n')
	   {
	     lim++;
	     break;
	   }
#if HAVE_DOS_FILE_CONTENTS
	 if (*lim == '\r' && lim + 1 < pat + psize && lim[1] == '\n')
	   {
	     lim += 2;
	     break;
	   }
#endif
	}

      if ((err = kwsincr (kwset, beg, end - beg)) != NULL)
	error (EXIT_TROUBLE, 0, "%s", err);
      beg = lim;
    }
  while (beg < pat + psize);

  if ((err = kwsprep (kwset)) != NULL)
    error (EXIT_TROUBLE, 0, "%s", err);
}

EXECUTE_FCT(Fexecute)
{
  char const *beg, *try, *end, *mb_start;
  size_t len;
  char eol = eolbyte;
  struct kwsmatch kwsmatch;
  size_t ret_val;
#ifdef MBS_SUPPORT
  
//Patch 0:
if (((__ctype_get_mb_cur_max()) > 1) && !(__is_neg(16, &(match_icase), sizeof (match_icase), &(buf), sizeof (buf), &(size), sizeof (size), &(eolbyte), sizeof (eolbyte), &(start_ptr), sizeof (start_ptr), &(beg), sizeof (beg), &(mb_start), sizeof (mb_start), &(kwset), sizeof (kwset), &(len), sizeof (len), &(match_words), sizeof (match_words), &(match_lines), sizeof (match_lines), &(eol), sizeof (eol), &(try), sizeof (try), &(ret_val), sizeof (ret_val), &(end), sizeof (end), &(match_size), sizeof (match_size)))) {
    if (match_icase) {
        char *case_buf = mbtolower(buf, &size);
        if (start_ptr)
            start_ptr = case_buf + (start_ptr - buf);
        buf = case_buf;
    }
}

//CodeSeg 1:
#endif /* MBS_SUPPORT */

  for (mb_start = beg = start_ptr ? start_ptr : buf; beg <= buf + size; beg++)
    {
      size_t offset = kwsexec (kwset, beg, buf + size - beg, &kwsmatch);
      if (offset == (size_t) -1)
	goto failure;
#ifdef MBS_SUPPORT
      if (MB_CUR_MAX > 1 && is_mb_middle (&mb_start, beg + offset, buf + size))
        {
          beg = mb_start - 1;
          continue; /* It is a part of multibyte character.  */
        }
#endif /* MBS_SUPPORT */
      beg += offset;
      len = kwsmatch.size[0];
      if (start_ptr && !match_words)
	goto success_in_beg_and_len;
      if (match_lines)
	{
	  if (beg > buf && beg[-1] != eol)
	    continue;
	  if (beg + len < buf + size && beg[len] != eol)
	    continue;
	  goto success;
	}
      else if (match_words)
	for (try = beg; len; )
	  {
	    if (try > buf && WCHAR((unsigned char) try[-1]))
	      break;
	    if (try + len < buf + size && WCHAR((unsigned char) try[len]))
	      {
		offset = kwsexec (kwset, beg, --len, &kwsmatch);
		if (offset == (size_t) -1)
		  break;
		try = beg + offset;
		len = kwsmatch.size[0];
	      }
	    else if (!start_ptr)
	      goto success;
	    else
	      goto success_in_beg_and_len;
	  } /* for (try) */
      else
	goto success;
    } /* for (beg in buf) */

 failure:
  ret_val = -1;
  goto out;

 success:
  if ((end = memchr (beg + len, eol, (buf + size) - (beg + len))) != NULL)
    end++;
  else
    end = buf + size;
  while (buf < beg && beg[-1] != eol)
    --beg;
  len = end - beg;
 success_in_beg_and_len:
  *match_size = len;
  ret_val = beg - buf;
 out:
  return ret_val;
}
#endif /* defined(GREP_PROGRAM) || defined(FGREP_PROGRAM) */

#ifdef GREP_PROGRAM
#if HAVE_LIBPCRE
/* Compiled internal form of a Perl regular expression.  */
static pcre *cre;

/* Additional information about the pattern.  */
static pcre_extra *extra;
#endif

COMPILE_FCT(Pcompile)
{
#if !HAVE_LIBPCRE
  error (EXIT_TROUBLE, 0, "%s",
	 _("support for the -P option is not compiled into "
	   "this --disable-perl-regexp binary"));
#else
  int e;
  char const *ep;
  char *re = xmalloc (4 * size + 7);
  int flags = PCRE_MULTILINE | (match_icase ? PCRE_CASELESS : 0);
  char const *patlim = pattern + size;
  char *n = re;
  char const *p;
  char const *pnul;

  /* FIXME: Remove these restrictions.  */
  if (memchr(pattern, '\n', size))
    error (EXIT_TROUBLE, 0, _("the -P option only supports a single pattern"));

  *n = '\0';
  if (match_lines)
    strcpy (n, "^(");
  if (match_words)
    strcpy (n, "\\b(");
  n += strlen (n);

  /* The PCRE interface doesn't allow NUL bytes in the pattern, so
     replace each NUL byte in the pattern with the four characters
     "\000", removing a preceding backslash if there are an odd
     number of backslashes before the NUL.

     FIXME: This method does not work with some multibyte character
     encodings, notably Shift-JIS, where a multibyte character can end
     in a backslash byte.  */
  for (p = pattern; (pnul = memchr (p, '\0', patlim - p)); p = pnul + 1)
    {
      memcpy (n, p, pnul - p);
      n += pnul - p;
      for (p = pnul; pattern < p && p[-1] == '\\'; p--)
	continue;
      n -= (pnul - p) & 1;
      strcpy (n, "\\000");
      n += 4;
    }

  memcpy (n, p, patlim - p);
  n += patlim - p;
  *n = '\0';
  if (match_words)
    strcpy (n, ")\\b");
  if (match_lines)
    strcpy (n, ")$");

  cre = pcre_compile (re, flags, &ep, &e, pcre_maketables ());
  if (!cre)
    error (EXIT_TROUBLE, 0, "%s", ep);

  extra = pcre_study (cre, 0, &ep);
  if (ep)
    error (EXIT_TROUBLE, 0, "%s", ep);

  free (re);
#endif
}

EXECUTE_FCT(Pexecute)
{
#if !HAVE_LIBPCRE
  abort ();
  return -1;
#else
  /* This array must have at least two elements; everything after that
     is just for performance improvement in pcre_exec.  */
  int sub[300];

  const char *line_buf, *line_end, *line_next;
  int e = PCRE_ERROR_NOMATCH;
  ptrdiff_t start_ofs = start_ptr ? start_ptr - buf : 0;

  /* PCRE can't limit the matching to single lines, therefore we have to
     match each line in the buffer separately.  */
  for (line_next = buf;
       e == PCRE_ERROR_NOMATCH && line_next < buf + size;
       start_ofs -= line_next - line_buf)
    {
      line_buf = line_next;
      line_end = memchr (line_buf, eolbyte, (buf + size) - line_buf);
      if (line_end == NULL)
        line_next = line_end = buf + size;
      else
        line_next = line_end + 1;

      if (start_ptr && start_ptr >= line_end)
        continue;

      e = pcre_exec (cre, extra, line_buf, line_end - line_buf,
                     start_ofs < 0 ? 0 : start_ofs, 0,
                     sub, sizeof sub / sizeof *sub);
    }

  if (e <= 0)
    {
      switch (e)
	{
	case PCRE_ERROR_NOMATCH:
	  return -1;

	case PCRE_ERROR_NOMEMORY:
	  error (EXIT_TROUBLE, 0, _("memory exhausted"));

	default:
	  abort ();
	}
    }
  else
    {
      /* Narrow down to the line we've found.  */
      char const *beg = line_buf + sub[0];
      char const *end = line_buf + sub[1];
      char const *buflim = buf + size;
      char eol = eolbyte;
      if (!start_ptr)
	{
	  /* FIXME: The case when '\n' is not found indicates a bug:
	     Since grep is line oriented, the match should never contain
	     a newline, so there _must_ be a newline following.
	   */
	  if (!(end = memchr (end, eol, buflim - end)))
	    end = buflim;
	  else
	    end++;
	  while (buf < beg && beg[-1] != eol)
	    --beg;
	}

      *match_size = end - beg;
      return beg - buf;
    }
#endif
}

struct matcher const matchers[] = {
  { "default", Gcompile, EGexecute },
  { "grep",    Gcompile, EGexecute },
  { "egrep",   Ecompile, EGexecute },
  { "awk",     Acompile, EGexecute },
  { "fgrep",   Fcompile, Fexecute },
  { "perl",    Pcompile, Pexecute },
  { "", 0, 0 },
};
#endif /* GREP_PROGRAM */

Spawn 1 instances, now Total 27
Counter: 28
Batcher Size:27
Preprocess the following candidate with CondTester:
Priority 20000
At location src/search.c:621
--Src File: src/search.c
Fragment 0:
if (((__ctype_get_mb_cur_max()) > 1) || (__abst_hole(match_icase, buf, size, eolbyte, start_ptr, beg, mb_start, kwset, len, match_words, match_lines, eol, try, ret_val, end, match_size))) {
    if (match_icase) {
        char *case_buf = mbtolower(buf, &size);
        if (start_ptr)
            start_ptr = case_buf + (start_ptr - buf);
        buf = case_buf;
    }
}


CondTester, a patch instance with id 27:
//src_file:src/search.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
/* search.c - searching subroutines using dfa, kwset and regex for grep.
   Copyright 1992, 1998, 2000, 2007, 2009-2010 Free Software Foundation, Inc.

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 3, or (at your option)
   any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program; if not, write to the Free Software
   Foundation, Inc., 51 Franklin Street - Fifth Floor, Boston, MA
   02110-1301, USA.  */

/* Written August 1992 by Mike Haertel. */

#include <config.h>

#include <sys/types.h>

#include "mbsupport.h"
#ifdef MBS_SUPPORT
/* We can handle multibyte strings. */
# include <wchar.h>
# include <wctype.h>
#endif

#include "system.h"
#include "grep.h"
#ifndef FGREP_PROGRAM
# include <regex.h>
# include "dfa.h"
#endif
#include "kwset.h"
#include "error.h"
#include "xalloc.h"
#ifdef HAVE_LIBPCRE
# include <pcre.h>
#endif

#define NCHAR (UCHAR_MAX + 1)

/* For -w, we also consider _ to be word constituent.  */
#define WCHAR(C) (ISALNUM(C) || (C) == '_')

/* KWset compiled pattern.  For Ecompile and Gcompile, we compile
   a list of strings, at least one of which is known to occur in
   any string matching the regexp. */
static kwset_t kwset;

static void
kwsinit (void)
{
  static char trans[NCHAR];
  int i;

  if (match_icase && MB_CUR_MAX == 1)
    {
      for (i = 0; i < NCHAR; ++i)
        trans[i] = TOLOWER (i);

      kwset = kwsalloc (trans);
    }
  else
    kwset = kwsalloc (NULL);

  if (!kwset)
    xalloc_die ();
}

#ifdef MBS_SUPPORT
/* Convert the *N-byte string, BEG, to lowercase, and write the
   NUL-terminated result into malloc'd storage.  Upon success, set *N
   to the length (in bytes) of the resulting string (not including the
   trailing NUL byte), and return a pointer to the lowercase string.
   Upon memory allocation failure, this function exits.

   Note that while this function returns a pointer to malloc'd storage,
   the caller must not free it, since this function retains a pointer
   to the buffer and reuses it on any subsequent call.  As a consequence,
   this function is not thread-safe.  */
static char *
mbtolower (const char *beg, size_t *n)
{
  static char *out;
  static size_t outalloc;
  size_t outlen, mb_cur_max;
  mbstate_t is, os;
  const char *end;
  char *p;

  if (*n > outalloc)
    {
      out = xrealloc (out, *n);
      outalloc = *n;
    }

  memset (&is, 0, sizeof (is));
  memset (&os, 0, sizeof (os));
  end = beg + *n;

  mb_cur_max = MB_CUR_MAX;
  p = out;
  outlen = 0;
  while (beg < end)
    {
      wchar_t wc;
      size_t mbclen = mbrtowc(&wc, beg, end - beg, &is);
      if (outlen + mb_cur_max >= outalloc)
        {
          out = x2nrealloc (out, &outalloc, 1);
          p = out + outlen;
        }

      if (mbclen == (size_t) -1 || mbclen == (size_t) -2 || mbclen == 0)
        {
          /* An invalid sequence, or a truncated multi-octet character.
             We treat it as a single-octet character.  */
          *p++ = *beg++;
          outlen++;
          memset (&is, 0, sizeof (is));
          memset (&os, 0, sizeof (os));
        }
      else
        {
          beg += mbclen;
          mbclen = wcrtomb (p, towlower ((wint_t) wc), &os);
          p += mbclen;
          outlen += mbclen;
        }
    }

  *n = p - out;
  *p++ = 0;
  return out;
}
#endif


#ifndef FGREP_PROGRAM
/* DFA compiled regexp. */
static struct dfa dfa;

/* The Regex compiled patterns.  */
static struct patterns
{
  /* Regex compiled regexp. */
  struct re_pattern_buffer regexbuf;
  struct re_registers regs; /* This is here on account of a BRAIN-DEAD
			       Q@#%!# library interface in regex.c.  */
} patterns0;

struct patterns *patterns;
size_t pcount;

void
dfaerror (char const *mesg)
{
  error (EXIT_TROUBLE, 0, "%s", mesg);
}

/* Number of compiled fixed strings known to exactly match the regexp.
   If kwsexec returns < kwset_exact_matches, then we don't need to
   call the regexp matcher at all. */
static int kwset_exact_matches;

static char const *
kwsincr_case (const char *must)
{
  const char *buf;
  size_t n;

  n = strlen (must);
#ifdef MBS_SUPPORT
  if (match_icase && MB_CUR_MAX > 1)
    buf = mbtolower (must, &n);
  else
#endif
    buf = must;
  return kwsincr (kwset, buf, n);
}

/* If the DFA turns out to have some set of fixed strings one of
   which must occur in the match, then we build a kwset matcher
   to find those strings, and thus quickly filter out impossible
   matches. */
static void
kwsmusts (void)
{
  struct dfamust const *dm;
  char const *err;

  if (dfa.musts)
    {
      kwsinit ();
      /* First, we compile in the substrings known to be exact
	 matches.  The kwset matcher will return the index
	 of the matching string that it chooses. */
      for (dm = dfa.musts; dm; dm = dm->next)
	{
	  if (!dm->exact)
	    continue;
	  ++kwset_exact_matches;
	  if ((err = kwsincr_case (dm->must)) != NULL)
	    error (EXIT_TROUBLE, 0, "%s", err);
	}
      /* Now, we compile the substrings that will require
	 the use of the regexp matcher.  */
      for (dm = dfa.musts; dm; dm = dm->next)
	{
	  if (dm->exact)
	    continue;
	  if ((err = kwsincr_case (dm->must)) != NULL)
	    error (EXIT_TROUBLE, 0, "%s", err);
	}
      if ((err = kwsprep (kwset)) != NULL)
	error (EXIT_TROUBLE, 0, "%s", err);
    }
}
#endif /* !FGREP_PROGRAM */

#ifdef MBS_SUPPORT

static bool
is_mb_middle(const char **good, const char *buf, const char *end)
{
  const char *p = *good;
  const char *prev = p;
  mbstate_t cur_state;

  /* TODO: can be optimized for UTF-8.  */
  memset(&cur_state, 0, sizeof(mbstate_t));
  while (p < buf)
    {
      size_t mbclen = mbrlen(p, end - p, &cur_state);

      /* Store the beginning of the previous complete multibyte character.  */
      if (mbclen != (size_t) -2)
        prev = p;

      if (mbclen == (size_t) -1 || mbclen == (size_t) -2 || mbclen == 0)
	{
	  /* An invalid sequence, or a truncated multibyte character.
	     We treat it as a single byte character.  */
	  mbclen = 1;
	}
      p += mbclen;
    }

  *good = prev;
  return p > buf;
}
#endif /* MBS_SUPPORT */

#if defined(GREP_PROGRAM) || defined(EGREP_PROGRAM)
#ifdef EGREP_PROGRAM
COMPILE_FCT(Ecompile)
{
  reg_syntax_t syntax_bits = RE_SYNTAX_POSIX_EGREP;
#else
/* No __VA_ARGS__ in C89.  So we have to do it this way.  */
static COMPILE_RET
GEAcompile (char const *pattern, size_t size, reg_syntax_t syntax_bits)
{
#endif /* EGREP_PROGRAM */
  const char *err;
  const char *p, *sep;
  size_t total = size;
  char *motif;

  if (match_icase)
    syntax_bits |= RE_ICASE;
  re_set_syntax (syntax_bits);
  dfasyntax (syntax_bits, match_icase, eolbyte);

  /* For GNU regex compiler we have to pass the patterns separately to detect
     errors like "[\nallo\n]\n".  The patterns here are "[", "allo" and "]"
     GNU regex should have raise a syntax error.  The same for backref, where
     the backref should have been local to each pattern.  */
  p = pattern;
  do
    {
      size_t len;
      sep = memchr (p, '\n', total);
      if (sep)
	{
	  len = sep - p;
	  sep++;
	  total -= (len + 1);
	}
      else
	{
	  len = total;
	  total = 0;
	}

      patterns = realloc (patterns, (pcount + 1) * sizeof (*patterns));
      if (patterns == NULL)
	error (EXIT_TROUBLE, errno, _("memory exhausted"));
      patterns[pcount] = patterns0;

      if ((err = re_compile_pattern (p, len,
				    &(patterns[pcount].regexbuf))) != NULL)
	error (EXIT_TROUBLE, 0, "%s", err);
      pcount++;

      p = sep;
    } while (sep && total != 0);

  /* In the match_words and match_lines cases, we use a different pattern
     for the DFA matcher that will quickly throw out cases that won't work.
     Then if DFA succeeds we do some hairy stuff using the regex matcher
     to decide whether the match should really count. */
  if (match_words || match_lines)
    {
      static char const line_beg_no_bk[] = "^(";
      static char const line_end_no_bk[] = ")$";
      static char const word_beg_no_bk[] = "(^|[^[:alnum:]_])(";
      static char const word_end_no_bk[] = ")([^[:alnum:]_]|$)";
#ifdef EGREP_PROGRAM
# define IF_BK(x, y) (y)
      char *n = xmalloc (sizeof word_beg_no_bk - 1 + size + sizeof word_end_no_bk);
#else
      static char const line_beg_bk[] = "^\\(";
      static char const line_end_bk[] = "\\)$";
      static char const word_beg_bk[] = "\\(^\\|[^[:alnum:]_]\\)\\(";
      static char const word_end_bk[] = "\\)\\([^[:alnum:]_]\\|$\\)";
      int bk = !(syntax_bits & RE_NO_BK_PARENS);
# define IF_BK(x, y) ((bk) ? (x) : (y))
      char *n = xmalloc (sizeof word_beg_bk - 1 + size + sizeof word_end_bk);
#endif /* EGREP_PROGRAM */

      strcpy (n, match_lines ? IF_BK(line_beg_bk, line_beg_no_bk)
			     : IF_BK(word_beg_bk, word_beg_no_bk));
      total = strlen(n);
      memcpy (n + total, pattern, size);
      total += size;
      strcpy (n + total, match_lines ? IF_BK(line_end_bk, line_end_no_bk)
				     : IF_BK(word_end_bk, word_end_no_bk));
      total += strlen (n + total);
      pattern = motif = n;
      size = total;
    }
  else
    motif = NULL;

  dfacomp (pattern, size, &dfa, 1);
  kwsmusts ();

  free(motif);
}

#ifndef EGREP_PROGRAM
COMPILE_FCT(Gcompile)
{
  return GEAcompile (pattern, size,
		     RE_SYNTAX_GREP | RE_HAT_LISTS_NOT_NEWLINE);
}

COMPILE_FCT(Acompile)
{
  return GEAcompile (pattern, size, RE_SYNTAX_AWK);
}

COMPILE_FCT(Ecompile)
{
  return GEAcompile (pattern, size, RE_SYNTAX_POSIX_EGREP);
}
#endif /* !EGREP_PROGRAM */

EXECUTE_FCT(EGexecute)
{
  char const *buflim, *beg, *end, *match, *best_match, *mb_start;
  char eol = eolbyte;
  int backref, start, len, best_len;
  struct kwsmatch kwsm;
  size_t i, ret_val;
#ifdef MBS_SUPPORT
  if (MB_CUR_MAX > 1)
    {
      if (match_icase)
        {
          /* mbtolower adds a NUL byte at the end.  That will provide
	     space for the sentinel byte dfaexec may add.  */
          char *case_buf = mbtolower (buf, &size);
	  if (start_ptr)
	    start_ptr = case_buf + (start_ptr - buf);
          buf = case_buf;
        }
    }
#endif /* MBS_SUPPORT */

  mb_start = buf;
  buflim = buf + size;

  for (beg = end = buf; end < buflim; beg = end)
    {
      if (!start_ptr)
	{
	  /* We don't care about an exact match.  */
	  if (kwset)
	    {
	      /* Find a possible match using the KWset matcher. */
	      size_t offset = kwsexec (kwset, beg, buflim - beg, &kwsm);
	      if (offset == (size_t) -1)
		goto failure;
	      beg += offset;
	      /* Narrow down to the line containing the candidate, and
		 run it through DFA. */
	      if ((end = memchr(beg, eol, buflim - beg)) != NULL)
	        end++;
              else
                end = buflim;
	      match = beg;
	      while (beg > buf && beg[-1] != eol)
		--beg;
	      if (kwsm.index < kwset_exact_matches)
                {
#ifdef MBS_SUPPORT
                  if (mb_start < beg)
                    mb_start = beg;
                  if (MB_CUR_MAX == 1 || !is_mb_middle (&mb_start, match, buflim))
#endif
                    goto success;
                }
	      if (dfaexec (&dfa, beg, (char *) end, 0, NULL, &backref) == NULL)
		continue;
	    }
	  else
	    {
	      /* No good fixed strings; start with DFA. */
	      char const *next_beg = dfaexec (&dfa, beg, (char *) buflim,
					      0, NULL, &backref);
	      if (next_beg == NULL)
		break;
	      /* Narrow down to the line we've found. */
	      beg = next_beg;
	      if ((end = memchr(beg, eol, buflim - beg)) != NULL)
	        end++;
              else
                end = buflim;
	      while (beg > buf && beg[-1] != eol)
		--beg;
	    }
	  /* Successful, no backreferences encountered! */
	  if (!backref)
	    goto success;
	}
      else
	{
	  /* We are looking for the leftmost (then longest) exact match.
	     We will go through the outer loop only once.  */
	  beg = start_ptr;
	  end = buflim;
	}

      /* If we've made it to this point, this means DFA has seen
	 a probable match, and we need to run it through Regex. */
      best_match = end;
      best_len = 0;
      for (i = 0; i < pcount; i++)
	{
	  patterns[i].regexbuf.not_eol = 0;
	  if (0 <= (start = re_search (&(patterns[i].regexbuf),
				       buf, end - buf - 1,
				       beg - buf, end - beg - 1,
				       &(patterns[i].regs))))
	    {
	      len = patterns[i].regs.end[0] - start;
	      match = buf + start;
	      if (match > best_match)
		continue;
	      if (start_ptr && !match_words)
		goto assess_pattern_match;
	      if ((!match_lines && !match_words)
		  || (match_lines && len == end - beg - 1))
		{
		  match = beg;
		  len = end - beg;
		  goto assess_pattern_match;
		}
	      /* If -w, check if the match aligns with word boundaries.
		 We do this iteratively because:
		 (a) the line may contain more than one occurence of the
		 pattern, and
		 (b) Several alternatives in the pattern might be valid at a
		 given point, and we may need to consider a shorter one to
		 find a word boundary.  */
	      if (match_words)
		while (match <= best_match)
		  {
		    if ((match == buf || !WCHAR ((unsigned char) match[-1]))
			&& (len == end - beg - 1
			    || !WCHAR ((unsigned char) match[len])))
		      goto assess_pattern_match;
		    if (len > 0)
		      {
			/* Try a shorter length anchored at the same place. */
			--len;
			patterns[i].regexbuf.not_eol = 1;
			len = re_match (&(patterns[i].regexbuf),
					buf, match + len - beg, match - buf,
					&(patterns[i].regs));
		      }
		    if (len <= 0)
		      {
			/* Try looking further on. */
			if (match == end - 1)
			  break;
			match++;
			patterns[i].regexbuf.not_eol = 0;
			start = re_search (&(patterns[i].regexbuf),
					   buf, end - buf - 1,
					   match - buf, end - match - 1,
					   &(patterns[i].regs));
			if (start < 0)
			  break;
			len = patterns[i].regs.end[0] - start;
			match = buf + start;
		      }
		  } /* while (match <= best_match) */
	      continue;
	    assess_pattern_match:
	      if (!start_ptr)
		{
		  /* Good enough for a non-exact match.
		     No need to look at further patterns, if any.  */
		  beg = match;
		  goto success_in_len;
		}
	      if (match < best_match || (match == best_match && len > best_len))
		{
		  /* Best exact match:  leftmost, then longest.  */
		  best_match = match;
		  best_len = len;
		}
	    } /* if re_search >= 0 */
	} /* for Regex patterns.  */
	if (best_match < end)
	  {
	    /* We have found an exact match.  We were just
	       waiting for the best one (leftmost then longest).  */
	    beg = best_match;
	    len = best_len;
	    goto success_in_len;
	  }
    } /* for (beg = end ..) */

 failure:
  ret_val = -1;
  goto out;

 success:
  len = end - beg;
 success_in_len:
  *match_size = len;
  ret_val = beg - buf;
 out:
  return ret_val;
}
#endif /* defined(GREP_PROGRAM) || defined(EGREP_PROGRAM) */

#if defined(GREP_PROGRAM) || defined(FGREP_PROGRAM)
COMPILE_FCT(Fcompile)
{
  char const *beg, *end, *lim, *err, *pat;
  size_t psize;

  kwsinit ();
  psize = size;
  if (match_icase && MB_CUR_MAX > 1)
    pat = mbtolower (pattern, &psize);
  else
    pat = pattern;

  beg = pat;
  do
    {
      for (lim = beg;; ++lim)
	{
	  end = lim;
	  if (lim >= pat + psize)
	    break;
	 if (*lim == '\n')
	   {
	     lim++;
	     break;
	   }
#if HAVE_DOS_FILE_CONTENTS
	 if (*lim == '\r' && lim + 1 < pat + psize && lim[1] == '\n')
	   {
	     lim += 2;
	     break;
	   }
#endif
	}

      if ((err = kwsincr (kwset, beg, end - beg)) != NULL)
	error (EXIT_TROUBLE, 0, "%s", err);
      beg = lim;
    }
  while (beg < pat + psize);

  if ((err = kwsprep (kwset)) != NULL)
    error (EXIT_TROUBLE, 0, "%s", err);
}

EXECUTE_FCT(Fexecute)
{
  char const *beg, *try, *end, *mb_start;
  size_t len;
  char eol = eolbyte;
  struct kwsmatch kwsmatch;
  size_t ret_val;
#ifdef MBS_SUPPORT
  
//Patch 0:
if (((__ctype_get_mb_cur_max()) > 1) || (__is_neg(16, &(match_icase), sizeof (match_icase), &(buf), sizeof (buf), &(size), sizeof (size), &(eolbyte), sizeof (eolbyte), &(start_ptr), sizeof (start_ptr), &(beg), sizeof (beg), &(mb_start), sizeof (mb_start), &(kwset), sizeof (kwset), &(len), sizeof (len), &(match_words), sizeof (match_words), &(match_lines), sizeof (match_lines), &(eol), sizeof (eol), &(try), sizeof (try), &(ret_val), sizeof (ret_val), &(end), sizeof (end), &(match_size), sizeof (match_size)))) {
    if (match_icase) {
        char *case_buf = mbtolower(buf, &size);
        if (start_ptr)
            start_ptr = case_buf + (start_ptr - buf);
        buf = case_buf;
    }
}

//CodeSeg 1:
#endif /* MBS_SUPPORT */

  for (mb_start = beg = start_ptr ? start_ptr : buf; beg <= buf + size; beg++)
    {
      size_t offset = kwsexec (kwset, beg, buf + size - beg, &kwsmatch);
      if (offset == (size_t) -1)
	goto failure;
#ifdef MBS_SUPPORT
      if (MB_CUR_MAX > 1 && is_mb_middle (&mb_start, beg + offset, buf + size))
        {
          beg = mb_start - 1;
          continue; /* It is a part of multibyte character.  */
        }
#endif /* MBS_SUPPORT */
      beg += offset;
      len = kwsmatch.size[0];
      if (start_ptr && !match_words)
	goto success_in_beg_and_len;
      if (match_lines)
	{
	  if (beg > buf && beg[-1] != eol)
	    continue;
	  if (beg + len < buf + size && beg[len] != eol)
	    continue;
	  goto success;
	}
      else if (match_words)
	for (try = beg; len; )
	  {
	    if (try > buf && WCHAR((unsigned char) try[-1]))
	      break;
	    if (try + len < buf + size && WCHAR((unsigned char) try[len]))
	      {
		offset = kwsexec (kwset, beg, --len, &kwsmatch);
		if (offset == (size_t) -1)
		  break;
		try = beg + offset;
		len = kwsmatch.size[0];
	      }
	    else if (!start_ptr)
	      goto success;
	    else
	      goto success_in_beg_and_len;
	  } /* for (try) */
      else
	goto success;
    } /* for (beg in buf) */

 failure:
  ret_val = -1;
  goto out;

 success:
  if ((end = memchr (beg + len, eol, (buf + size) - (beg + len))) != NULL)
    end++;
  else
    end = buf + size;
  while (buf < beg && beg[-1] != eol)
    --beg;
  len = end - beg;
 success_in_beg_and_len:
  *match_size = len;
  ret_val = beg - buf;
 out:
  return ret_val;
}
#endif /* defined(GREP_PROGRAM) || defined(FGREP_PROGRAM) */

#ifdef GREP_PROGRAM
#if HAVE_LIBPCRE
/* Compiled internal form of a Perl regular expression.  */
static pcre *cre;

/* Additional information about the pattern.  */
static pcre_extra *extra;
#endif

COMPILE_FCT(Pcompile)
{
#if !HAVE_LIBPCRE
  error (EXIT_TROUBLE, 0, "%s",
	 _("support for the -P option is not compiled into "
	   "this --disable-perl-regexp binary"));
#else
  int e;
  char const *ep;
  char *re = xmalloc (4 * size + 7);
  int flags = PCRE_MULTILINE | (match_icase ? PCRE_CASELESS : 0);
  char const *patlim = pattern + size;
  char *n = re;
  char const *p;
  char const *pnul;

  /* FIXME: Remove these restrictions.  */
  if (memchr(pattern, '\n', size))
    error (EXIT_TROUBLE, 0, _("the -P option only supports a single pattern"));

  *n = '\0';
  if (match_lines)
    strcpy (n, "^(");
  if (match_words)
    strcpy (n, "\\b(");
  n += strlen (n);

  /* The PCRE interface doesn't allow NUL bytes in the pattern, so
     replace each NUL byte in the pattern with the four characters
     "\000", removing a preceding backslash if there are an odd
     number of backslashes before the NUL.

     FIXME: This method does not work with some multibyte character
     encodings, notably Shift-JIS, where a multibyte character can end
     in a backslash byte.  */
  for (p = pattern; (pnul = memchr (p, '\0', patlim - p)); p = pnul + 1)
    {
      memcpy (n, p, pnul - p);
      n += pnul - p;
      for (p = pnul; pattern < p && p[-1] == '\\'; p--)
	continue;
      n -= (pnul - p) & 1;
      strcpy (n, "\\000");
      n += 4;
    }

  memcpy (n, p, patlim - p);
  n += patlim - p;
  *n = '\0';
  if (match_words)
    strcpy (n, ")\\b");
  if (match_lines)
    strcpy (n, ")$");

  cre = pcre_compile (re, flags, &ep, &e, pcre_maketables ());
  if (!cre)
    error (EXIT_TROUBLE, 0, "%s", ep);

  extra = pcre_study (cre, 0, &ep);
  if (ep)
    error (EXIT_TROUBLE, 0, "%s", ep);

  free (re);
#endif
}

EXECUTE_FCT(Pexecute)
{
#if !HAVE_LIBPCRE
  abort ();
  return -1;
#else
  /* This array must have at least two elements; everything after that
     is just for performance improvement in pcre_exec.  */
  int sub[300];

  const char *line_buf, *line_end, *line_next;
  int e = PCRE_ERROR_NOMATCH;
  ptrdiff_t start_ofs = start_ptr ? start_ptr - buf : 0;

  /* PCRE can't limit the matching to single lines, therefore we have to
     match each line in the buffer separately.  */
  for (line_next = buf;
       e == PCRE_ERROR_NOMATCH && line_next < buf + size;
       start_ofs -= line_next - line_buf)
    {
      line_buf = line_next;
      line_end = memchr (line_buf, eolbyte, (buf + size) - line_buf);
      if (line_end == NULL)
        line_next = line_end = buf + size;
      else
        line_next = line_end + 1;

      if (start_ptr && start_ptr >= line_end)
        continue;

      e = pcre_exec (cre, extra, line_buf, line_end - line_buf,
                     start_ofs < 0 ? 0 : start_ofs, 0,
                     sub, sizeof sub / sizeof *sub);
    }

  if (e <= 0)
    {
      switch (e)
	{
	case PCRE_ERROR_NOMATCH:
	  return -1;

	case PCRE_ERROR_NOMEMORY:
	  error (EXIT_TROUBLE, 0, _("memory exhausted"));

	default:
	  abort ();
	}
    }
  else
    {
      /* Narrow down to the line we've found.  */
      char const *beg = line_buf + sub[0];
      char const *end = line_buf + sub[1];
      char const *buflim = buf + size;
      char eol = eolbyte;
      if (!start_ptr)
	{
	  /* FIXME: The case when '\n' is not found indicates a bug:
	     Since grep is line oriented, the match should never contain
	     a newline, so there _must_ be a newline following.
	   */
	  if (!(end = memchr (end, eol, buflim - end)))
	    end = buflim;
	  else
	    end++;
	  while (buf < beg && beg[-1] != eol)
	    --beg;
	}

      *match_size = end - beg;
      return beg - buf;
    }
#endif
}

struct matcher const matchers[] = {
  { "default", Gcompile, EGexecute },
  { "grep",    Gcompile, EGexecute },
  { "egrep",   Ecompile, EGexecute },
  { "awk",     Acompile, EGexecute },
  { "fgrep",   Fcompile, Fexecute },
  { "perl",    Pcompile, Pexecute },
  { "", 0, 0 },
};
#endif /* GREP_PROGRAM */

Spawn 1 instances, now Total 28
Counter: 29
Batcher Size:28
Preprocess the following candidate with CondTester:
Priority 20000
At location src/search.c:246
--Src File: src/search.c
Fragment 0:
if ((mbclen == (size_t)-1 || mbclen == (size_t)-2 || mbclen == 0) || (__abst_hole(mbclen, p, prev, end, buf, good))) {
    mbclen = 1;
}


CondTester, a patch instance with id 28:
//src_file:src/search.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
/* search.c - searching subroutines using dfa, kwset and regex for grep.
   Copyright 1992, 1998, 2000, 2007, 2009-2010 Free Software Foundation, Inc.

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 3, or (at your option)
   any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program; if not, write to the Free Software
   Foundation, Inc., 51 Franklin Street - Fifth Floor, Boston, MA
   02110-1301, USA.  */

/* Written August 1992 by Mike Haertel. */

#include <config.h>

#include <sys/types.h>

#include "mbsupport.h"
#ifdef MBS_SUPPORT
/* We can handle multibyte strings. */
# include <wchar.h>
# include <wctype.h>
#endif

#include "system.h"
#include "grep.h"
#ifndef FGREP_PROGRAM
# include <regex.h>
# include "dfa.h"
#endif
#include "kwset.h"
#include "error.h"
#include "xalloc.h"
#ifdef HAVE_LIBPCRE
# include <pcre.h>
#endif

#define NCHAR (UCHAR_MAX + 1)

/* For -w, we also consider _ to be word constituent.  */
#define WCHAR(C) (ISALNUM(C) || (C) == '_')

/* KWset compiled pattern.  For Ecompile and Gcompile, we compile
   a list of strings, at least one of which is known to occur in
   any string matching the regexp. */
static kwset_t kwset;

static void
kwsinit (void)
{
  static char trans[NCHAR];
  int i;

  if (match_icase && MB_CUR_MAX == 1)
    {
      for (i = 0; i < NCHAR; ++i)
        trans[i] = TOLOWER (i);

      kwset = kwsalloc (trans);
    }
  else
    kwset = kwsalloc (NULL);

  if (!kwset)
    xalloc_die ();
}

#ifdef MBS_SUPPORT
/* Convert the *N-byte string, BEG, to lowercase, and write the
   NUL-terminated result into malloc'd storage.  Upon success, set *N
   to the length (in bytes) of the resulting string (not including the
   trailing NUL byte), and return a pointer to the lowercase string.
   Upon memory allocation failure, this function exits.

   Note that while this function returns a pointer to malloc'd storage,
   the caller must not free it, since this function retains a pointer
   to the buffer and reuses it on any subsequent call.  As a consequence,
   this function is not thread-safe.  */
static char *
mbtolower (const char *beg, size_t *n)
{
  static char *out;
  static size_t outalloc;
  size_t outlen, mb_cur_max;
  mbstate_t is, os;
  const char *end;
  char *p;

  if (*n > outalloc)
    {
      out = xrealloc (out, *n);
      outalloc = *n;
    }

  memset (&is, 0, sizeof (is));
  memset (&os, 0, sizeof (os));
  end = beg + *n;

  mb_cur_max = MB_CUR_MAX;
  p = out;
  outlen = 0;
  while (beg < end)
    {
      wchar_t wc;
      size_t mbclen = mbrtowc(&wc, beg, end - beg, &is);
      if (outlen + mb_cur_max >= outalloc)
        {
          out = x2nrealloc (out, &outalloc, 1);
          p = out + outlen;
        }

      if (mbclen == (size_t) -1 || mbclen == (size_t) -2 || mbclen == 0)
        {
          /* An invalid sequence, or a truncated multi-octet character.
             We treat it as a single-octet character.  */
          *p++ = *beg++;
          outlen++;
          memset (&is, 0, sizeof (is));
          memset (&os, 0, sizeof (os));
        }
      else
        {
          beg += mbclen;
          mbclen = wcrtomb (p, towlower ((wint_t) wc), &os);
          p += mbclen;
          outlen += mbclen;
        }
    }

  *n = p - out;
  *p++ = 0;
  return out;
}
#endif


#ifndef FGREP_PROGRAM
/* DFA compiled regexp. */
static struct dfa dfa;

/* The Regex compiled patterns.  */
static struct patterns
{
  /* Regex compiled regexp. */
  struct re_pattern_buffer regexbuf;
  struct re_registers regs; /* This is here on account of a BRAIN-DEAD
			       Q@#%!# library interface in regex.c.  */
} patterns0;

struct patterns *patterns;
size_t pcount;

void
dfaerror (char const *mesg)
{
  error (EXIT_TROUBLE, 0, "%s", mesg);
}

/* Number of compiled fixed strings known to exactly match the regexp.
   If kwsexec returns < kwset_exact_matches, then we don't need to
   call the regexp matcher at all. */
static int kwset_exact_matches;

static char const *
kwsincr_case (const char *must)
{
  const char *buf;
  size_t n;

  n = strlen (must);
#ifdef MBS_SUPPORT
  if (match_icase && MB_CUR_MAX > 1)
    buf = mbtolower (must, &n);
  else
#endif
    buf = must;
  return kwsincr (kwset, buf, n);
}

/* If the DFA turns out to have some set of fixed strings one of
   which must occur in the match, then we build a kwset matcher
   to find those strings, and thus quickly filter out impossible
   matches. */
static void
kwsmusts (void)
{
  struct dfamust const *dm;
  char const *err;

  if (dfa.musts)
    {
      kwsinit ();
      /* First, we compile in the substrings known to be exact
	 matches.  The kwset matcher will return the index
	 of the matching string that it chooses. */
      for (dm = dfa.musts; dm; dm = dm->next)
	{
	  if (!dm->exact)
	    continue;
	  ++kwset_exact_matches;
	  if ((err = kwsincr_case (dm->must)) != NULL)
	    error (EXIT_TROUBLE, 0, "%s", err);
	}
      /* Now, we compile the substrings that will require
	 the use of the regexp matcher.  */
      for (dm = dfa.musts; dm; dm = dm->next)
	{
	  if (dm->exact)
	    continue;
	  if ((err = kwsincr_case (dm->must)) != NULL)
	    error (EXIT_TROUBLE, 0, "%s", err);
	}
      if ((err = kwsprep (kwset)) != NULL)
	error (EXIT_TROUBLE, 0, "%s", err);
    }
}
#endif /* !FGREP_PROGRAM */

#ifdef MBS_SUPPORT

static bool
is_mb_middle(const char **good, const char *buf, const char *end)
{
  const char *p = *good;
  const char *prev = p;
  mbstate_t cur_state;

  /* TODO: can be optimized for UTF-8.  */
  memset(&cur_state, 0, sizeof(mbstate_t));
  while (p < buf)
    {
      size_t mbclen = mbrlen(p, end - p, &cur_state);

      /* Store the beginning of the previous complete multibyte character.  */
      if (mbclen != (size_t) -2)
        prev = p;

      
//Patch 0:
if ((mbclen == (size_t)-1 || mbclen == (size_t)-2 || mbclen == 0) || (__is_neg(6, &(mbclen), sizeof (mbclen), &(p), sizeof (p), &(prev), sizeof (prev), &(end), sizeof (end), &(buf), sizeof (buf), &(good), sizeof (good)))) {
    mbclen = 1;
}

//CodeSeg 1:
      p += mbclen;
    }

  *good = prev;
  return p > buf;
}
#endif /* MBS_SUPPORT */

#if defined(GREP_PROGRAM) || defined(EGREP_PROGRAM)
#ifdef EGREP_PROGRAM
COMPILE_FCT(Ecompile)
{
  reg_syntax_t syntax_bits = RE_SYNTAX_POSIX_EGREP;
#else
/* No __VA_ARGS__ in C89.  So we have to do it this way.  */
static COMPILE_RET
GEAcompile (char const *pattern, size_t size, reg_syntax_t syntax_bits)
{
#endif /* EGREP_PROGRAM */
  const char *err;
  const char *p, *sep;
  size_t total = size;
  char *motif;

  if (match_icase)
    syntax_bits |= RE_ICASE;
  re_set_syntax (syntax_bits);
  dfasyntax (syntax_bits, match_icase, eolbyte);

  /* For GNU regex compiler we have to pass the patterns separately to detect
     errors like "[\nallo\n]\n".  The patterns here are "[", "allo" and "]"
     GNU regex should have raise a syntax error.  The same for backref, where
     the backref should have been local to each pattern.  */
  p = pattern;
  do
    {
      size_t len;
      sep = memchr (p, '\n', total);
      if (sep)
	{
	  len = sep - p;
	  sep++;
	  total -= (len + 1);
	}
      else
	{
	  len = total;
	  total = 0;
	}

      patterns = realloc (patterns, (pcount + 1) * sizeof (*patterns));
      if (patterns == NULL)
	error (EXIT_TROUBLE, errno, _("memory exhausted"));
      patterns[pcount] = patterns0;

      if ((err = re_compile_pattern (p, len,
				    &(patterns[pcount].regexbuf))) != NULL)
	error (EXIT_TROUBLE, 0, "%s", err);
      pcount++;

      p = sep;
    } while (sep && total != 0);

  /* In the match_words and match_lines cases, we use a different pattern
     for the DFA matcher that will quickly throw out cases that won't work.
     Then if DFA succeeds we do some hairy stuff using the regex matcher
     to decide whether the match should really count. */
  if (match_words || match_lines)
    {
      static char const line_beg_no_bk[] = "^(";
      static char const line_end_no_bk[] = ")$";
      static char const word_beg_no_bk[] = "(^|[^[:alnum:]_])(";
      static char const word_end_no_bk[] = ")([^[:alnum:]_]|$)";
#ifdef EGREP_PROGRAM
# define IF_BK(x, y) (y)
      char *n = xmalloc (sizeof word_beg_no_bk - 1 + size + sizeof word_end_no_bk);
#else
      static char const line_beg_bk[] = "^\\(";
      static char const line_end_bk[] = "\\)$";
      static char const word_beg_bk[] = "\\(^\\|[^[:alnum:]_]\\)\\(";
      static char const word_end_bk[] = "\\)\\([^[:alnum:]_]\\|$\\)";
      int bk = !(syntax_bits & RE_NO_BK_PARENS);
# define IF_BK(x, y) ((bk) ? (x) : (y))
      char *n = xmalloc (sizeof word_beg_bk - 1 + size + sizeof word_end_bk);
#endif /* EGREP_PROGRAM */

      strcpy (n, match_lines ? IF_BK(line_beg_bk, line_beg_no_bk)
			     : IF_BK(word_beg_bk, word_beg_no_bk));
      total = strlen(n);
      memcpy (n + total, pattern, size);
      total += size;
      strcpy (n + total, match_lines ? IF_BK(line_end_bk, line_end_no_bk)
				     : IF_BK(word_end_bk, word_end_no_bk));
      total += strlen (n + total);
      pattern = motif = n;
      size = total;
    }
  else
    motif = NULL;

  dfacomp (pattern, size, &dfa, 1);
  kwsmusts ();

  free(motif);
}

#ifndef EGREP_PROGRAM
COMPILE_FCT(Gcompile)
{
  return GEAcompile (pattern, size,
		     RE_SYNTAX_GREP | RE_HAT_LISTS_NOT_NEWLINE);
}

COMPILE_FCT(Acompile)
{
  return GEAcompile (pattern, size, RE_SYNTAX_AWK);
}

COMPILE_FCT(Ecompile)
{
  return GEAcompile (pattern, size, RE_SYNTAX_POSIX_EGREP);
}
#endif /* !EGREP_PROGRAM */

EXECUTE_FCT(EGexecute)
{
  char const *buflim, *beg, *end, *match, *best_match, *mb_start;
  char eol = eolbyte;
  int backref, start, len, best_len;
  struct kwsmatch kwsm;
  size_t i, ret_val;
#ifdef MBS_SUPPORT
  if (MB_CUR_MAX > 1)
    {
      if (match_icase)
        {
          /* mbtolower adds a NUL byte at the end.  That will provide
	     space for the sentinel byte dfaexec may add.  */
          char *case_buf = mbtolower (buf, &size);
	  if (start_ptr)
	    start_ptr = case_buf + (start_ptr - buf);
          buf = case_buf;
        }
    }
#endif /* MBS_SUPPORT */

  mb_start = buf;
  buflim = buf + size;

  for (beg = end = buf; end < buflim; beg = end)
    {
      if (!start_ptr)
	{
	  /* We don't care about an exact match.  */
	  if (kwset)
	    {
	      /* Find a possible match using the KWset matcher. */
	      size_t offset = kwsexec (kwset, beg, buflim - beg, &kwsm);
	      if (offset == (size_t) -1)
		goto failure;
	      beg += offset;
	      /* Narrow down to the line containing the candidate, and
		 run it through DFA. */
	      if ((end = memchr(beg, eol, buflim - beg)) != NULL)
	        end++;
              else
                end = buflim;
	      match = beg;
	      while (beg > buf && beg[-1] != eol)
		--beg;
	      if (kwsm.index < kwset_exact_matches)
                {
#ifdef MBS_SUPPORT
                  if (mb_start < beg)
                    mb_start = beg;
                  if (MB_CUR_MAX == 1 || !is_mb_middle (&mb_start, match, buflim))
#endif
                    goto success;
                }
	      if (dfaexec (&dfa, beg, (char *) end, 0, NULL, &backref) == NULL)
		continue;
	    }
	  else
	    {
	      /* No good fixed strings; start with DFA. */
	      char const *next_beg = dfaexec (&dfa, beg, (char *) buflim,
					      0, NULL, &backref);
	      if (next_beg == NULL)
		break;
	      /* Narrow down to the line we've found. */
	      beg = next_beg;
	      if ((end = memchr(beg, eol, buflim - beg)) != NULL)
	        end++;
              else
                end = buflim;
	      while (beg > buf && beg[-1] != eol)
		--beg;
	    }
	  /* Successful, no backreferences encountered! */
	  if (!backref)
	    goto success;
	}
      else
	{
	  /* We are looking for the leftmost (then longest) exact match.
	     We will go through the outer loop only once.  */
	  beg = start_ptr;
	  end = buflim;
	}

      /* If we've made it to this point, this means DFA has seen
	 a probable match, and we need to run it through Regex. */
      best_match = end;
      best_len = 0;
      for (i = 0; i < pcount; i++)
	{
	  patterns[i].regexbuf.not_eol = 0;
	  if (0 <= (start = re_search (&(patterns[i].regexbuf),
				       buf, end - buf - 1,
				       beg - buf, end - beg - 1,
				       &(patterns[i].regs))))
	    {
	      len = patterns[i].regs.end[0] - start;
	      match = buf + start;
	      if (match > best_match)
		continue;
	      if (start_ptr && !match_words)
		goto assess_pattern_match;
	      if ((!match_lines && !match_words)
		  || (match_lines && len == end - beg - 1))
		{
		  match = beg;
		  len = end - beg;
		  goto assess_pattern_match;
		}
	      /* If -w, check if the match aligns with word boundaries.
		 We do this iteratively because:
		 (a) the line may contain more than one occurence of the
		 pattern, and
		 (b) Several alternatives in the pattern might be valid at a
		 given point, and we may need to consider a shorter one to
		 find a word boundary.  */
	      if (match_words)
		while (match <= best_match)
		  {
		    if ((match == buf || !WCHAR ((unsigned char) match[-1]))
			&& (len == end - beg - 1
			    || !WCHAR ((unsigned char) match[len])))
		      goto assess_pattern_match;
		    if (len > 0)
		      {
			/* Try a shorter length anchored at the same place. */
			--len;
			patterns[i].regexbuf.not_eol = 1;
			len = re_match (&(patterns[i].regexbuf),
					buf, match + len - beg, match - buf,
					&(patterns[i].regs));
		      }
		    if (len <= 0)
		      {
			/* Try looking further on. */
			if (match == end - 1)
			  break;
			match++;
			patterns[i].regexbuf.not_eol = 0;
			start = re_search (&(patterns[i].regexbuf),
					   buf, end - buf - 1,
					   match - buf, end - match - 1,
					   &(patterns[i].regs));
			if (start < 0)
			  break;
			len = patterns[i].regs.end[0] - start;
			match = buf + start;
		      }
		  } /* while (match <= best_match) */
	      continue;
	    assess_pattern_match:
	      if (!start_ptr)
		{
		  /* Good enough for a non-exact match.
		     No need to look at further patterns, if any.  */
		  beg = match;
		  goto success_in_len;
		}
	      if (match < best_match || (match == best_match && len > best_len))
		{
		  /* Best exact match:  leftmost, then longest.  */
		  best_match = match;
		  best_len = len;
		}
	    } /* if re_search >= 0 */
	} /* for Regex patterns.  */
	if (best_match < end)
	  {
	    /* We have found an exact match.  We were just
	       waiting for the best one (leftmost then longest).  */
	    beg = best_match;
	    len = best_len;
	    goto success_in_len;
	  }
    } /* for (beg = end ..) */

 failure:
  ret_val = -1;
  goto out;

 success:
  len = end - beg;
 success_in_len:
  *match_size = len;
  ret_val = beg - buf;
 out:
  return ret_val;
}
#endif /* defined(GREP_PROGRAM) || defined(EGREP_PROGRAM) */

#if defined(GREP_PROGRAM) || defined(FGREP_PROGRAM)
COMPILE_FCT(Fcompile)
{
  char const *beg, *end, *lim, *err, *pat;
  size_t psize;

  kwsinit ();
  psize = size;
  if (match_icase && MB_CUR_MAX > 1)
    pat = mbtolower (pattern, &psize);
  else
    pat = pattern;

  beg = pat;
  do
    {
      for (lim = beg;; ++lim)
	{
	  end = lim;
	  if (lim >= pat + psize)
	    break;
	 if (*lim == '\n')
	   {
	     lim++;
	     break;
	   }
#if HAVE_DOS_FILE_CONTENTS
	 if (*lim == '\r' && lim + 1 < pat + psize && lim[1] == '\n')
	   {
	     lim += 2;
	     break;
	   }
#endif
	}

      if ((err = kwsincr (kwset, beg, end - beg)) != NULL)
	error (EXIT_TROUBLE, 0, "%s", err);
      beg = lim;
    }
  while (beg < pat + psize);

  if ((err = kwsprep (kwset)) != NULL)
    error (EXIT_TROUBLE, 0, "%s", err);
}

EXECUTE_FCT(Fexecute)
{
  char const *beg, *try, *end, *mb_start;
  size_t len;
  char eol = eolbyte;
  struct kwsmatch kwsmatch;
  size_t ret_val;
#ifdef MBS_SUPPORT
  if (MB_CUR_MAX > 1)
    {
      if (match_icase)
        {
          char *case_buf = mbtolower (buf, &size);
	  if (start_ptr)
	    start_ptr = case_buf + (start_ptr - buf);
          buf = case_buf;
        }
    }
#endif /* MBS_SUPPORT */

  for (mb_start = beg = start_ptr ? start_ptr : buf; beg <= buf + size; beg++)
    {
      size_t offset = kwsexec (kwset, beg, buf + size - beg, &kwsmatch);
      if (offset == (size_t) -1)
	goto failure;
#ifdef MBS_SUPPORT
      if (MB_CUR_MAX > 1 && is_mb_middle (&mb_start, beg + offset, buf + size))
        {
          beg = mb_start - 1;
          continue; /* It is a part of multibyte character.  */
        }
#endif /* MBS_SUPPORT */
      beg += offset;
      len = kwsmatch.size[0];
      if (start_ptr && !match_words)
	goto success_in_beg_and_len;
      if (match_lines)
	{
	  if (beg > buf && beg[-1] != eol)
	    continue;
	  if (beg + len < buf + size && beg[len] != eol)
	    continue;
	  goto success;
	}
      else if (match_words)
	for (try = beg; len; )
	  {
	    if (try > buf && WCHAR((unsigned char) try[-1]))
	      break;
	    if (try + len < buf + size && WCHAR((unsigned char) try[len]))
	      {
		offset = kwsexec (kwset, beg, --len, &kwsmatch);
		if (offset == (size_t) -1)
		  break;
		try = beg + offset;
		len = kwsmatch.size[0];
	      }
	    else if (!start_ptr)
	      goto success;
	    else
	      goto success_in_beg_and_len;
	  } /* for (try) */
      else
	goto success;
    } /* for (beg in buf) */

 failure:
  ret_val = -1;
  goto out;

 success:
  if ((end = memchr (beg + len, eol, (buf + size) - (beg + len))) != NULL)
    end++;
  else
    end = buf + size;
  while (buf < beg && beg[-1] != eol)
    --beg;
  len = end - beg;
 success_in_beg_and_len:
  *match_size = len;
  ret_val = beg - buf;
 out:
  return ret_val;
}
#endif /* defined(GREP_PROGRAM) || defined(FGREP_PROGRAM) */

#ifdef GREP_PROGRAM
#if HAVE_LIBPCRE
/* Compiled internal form of a Perl regular expression.  */
static pcre *cre;

/* Additional information about the pattern.  */
static pcre_extra *extra;
#endif

COMPILE_FCT(Pcompile)
{
#if !HAVE_LIBPCRE
  error (EXIT_TROUBLE, 0, "%s",
	 _("support for the -P option is not compiled into "
	   "this --disable-perl-regexp binary"));
#else
  int e;
  char const *ep;
  char *re = xmalloc (4 * size + 7);
  int flags = PCRE_MULTILINE | (match_icase ? PCRE_CASELESS : 0);
  char const *patlim = pattern + size;
  char *n = re;
  char const *p;
  char const *pnul;

  /* FIXME: Remove these restrictions.  */
  if (memchr(pattern, '\n', size))
    error (EXIT_TROUBLE, 0, _("the -P option only supports a single pattern"));

  *n = '\0';
  if (match_lines)
    strcpy (n, "^(");
  if (match_words)
    strcpy (n, "\\b(");
  n += strlen (n);

  /* The PCRE interface doesn't allow NUL bytes in the pattern, so
     replace each NUL byte in the pattern with the four characters
     "\000", removing a preceding backslash if there are an odd
     number of backslashes before the NUL.

     FIXME: This method does not work with some multibyte character
     encodings, notably Shift-JIS, where a multibyte character can end
     in a backslash byte.  */
  for (p = pattern; (pnul = memchr (p, '\0', patlim - p)); p = pnul + 1)
    {
      memcpy (n, p, pnul - p);
      n += pnul - p;
      for (p = pnul; pattern < p && p[-1] == '\\'; p--)
	continue;
      n -= (pnul - p) & 1;
      strcpy (n, "\\000");
      n += 4;
    }

  memcpy (n, p, patlim - p);
  n += patlim - p;
  *n = '\0';
  if (match_words)
    strcpy (n, ")\\b");
  if (match_lines)
    strcpy (n, ")$");

  cre = pcre_compile (re, flags, &ep, &e, pcre_maketables ());
  if (!cre)
    error (EXIT_TROUBLE, 0, "%s", ep);

  extra = pcre_study (cre, 0, &ep);
  if (ep)
    error (EXIT_TROUBLE, 0, "%s", ep);

  free (re);
#endif
}

EXECUTE_FCT(Pexecute)
{
#if !HAVE_LIBPCRE
  abort ();
  return -1;
#else
  /* This array must have at least two elements; everything after that
     is just for performance improvement in pcre_exec.  */
  int sub[300];

  const char *line_buf, *line_end, *line_next;
  int e = PCRE_ERROR_NOMATCH;
  ptrdiff_t start_ofs = start_ptr ? start_ptr - buf : 0;

  /* PCRE can't limit the matching to single lines, therefore we have to
     match each line in the buffer separately.  */
  for (line_next = buf;
       e == PCRE_ERROR_NOMATCH && line_next < buf + size;
       start_ofs -= line_next - line_buf)
    {
      line_buf = line_next;
      line_end = memchr (line_buf, eolbyte, (buf + size) - line_buf);
      if (line_end == NULL)
        line_next = line_end = buf + size;
      else
        line_next = line_end + 1;

      if (start_ptr && start_ptr >= line_end)
        continue;

      e = pcre_exec (cre, extra, line_buf, line_end - line_buf,
                     start_ofs < 0 ? 0 : start_ofs, 0,
                     sub, sizeof sub / sizeof *sub);
    }

  if (e <= 0)
    {
      switch (e)
	{
	case PCRE_ERROR_NOMATCH:
	  return -1;

	case PCRE_ERROR_NOMEMORY:
	  error (EXIT_TROUBLE, 0, _("memory exhausted"));

	default:
	  abort ();
	}
    }
  else
    {
      /* Narrow down to the line we've found.  */
      char const *beg = line_buf + sub[0];
      char const *end = line_buf + sub[1];
      char const *buflim = buf + size;
      char eol = eolbyte;
      if (!start_ptr)
	{
	  /* FIXME: The case when '\n' is not found indicates a bug:
	     Since grep is line oriented, the match should never contain
	     a newline, so there _must_ be a newline following.
	   */
	  if (!(end = memchr (end, eol, buflim - end)))
	    end = buflim;
	  else
	    end++;
	  while (buf < beg && beg[-1] != eol)
	    --beg;
	}

      *match_size = end - beg;
      return beg - buf;
    }
#endif
}

struct matcher const matchers[] = {
  { "default", Gcompile, EGexecute },
  { "grep",    Gcompile, EGexecute },
  { "egrep",   Ecompile, EGexecute },
  { "awk",     Acompile, EGexecute },
  { "fgrep",   Fcompile, Fexecute },
  { "perl",    Pcompile, Pexecute },
  { "", 0, 0 },
};
#endif /* GREP_PROGRAM */

Spawn 1 instances, now Total 29
Counter: 30
Batcher Size:29
Preprocess the following candidate with BasicTester:
Priority 7489
At location src/search.c:237
--Src File: src/search.c
Fragment 0:
prev = (end);
memset(&cur_state, 0, sizeof(mbstate_t));


BasicTester, a patch instance with id 0:
//src_file:src/search.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
/* search.c - searching subroutines using dfa, kwset and regex for grep.
   Copyright 1992, 1998, 2000, 2007, 2009-2010 Free Software Foundation, Inc.

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 3, or (at your option)
   any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program; if not, write to the Free Software
   Foundation, Inc., 51 Franklin Street - Fifth Floor, Boston, MA
   02110-1301, USA.  */

/* Written August 1992 by Mike Haertel. */

#include <config.h>

#include <sys/types.h>

#include "mbsupport.h"
#ifdef MBS_SUPPORT
/* We can handle multibyte strings. */
# include <wchar.h>
# include <wctype.h>
#endif

#include "system.h"
#include "grep.h"
#ifndef FGREP_PROGRAM
# include <regex.h>
# include "dfa.h"
#endif
#include "kwset.h"
#include "error.h"
#include "xalloc.h"
#ifdef HAVE_LIBPCRE
# include <pcre.h>
#endif

#define NCHAR (UCHAR_MAX + 1)

/* For -w, we also consider _ to be word constituent.  */
#define WCHAR(C) (ISALNUM(C) || (C) == '_')

/* KWset compiled pattern.  For Ecompile and Gcompile, we compile
   a list of strings, at least one of which is known to occur in
   any string matching the regexp. */
static kwset_t kwset;

static void
kwsinit (void)
{
  static char trans[NCHAR];
  int i;

  if (match_icase && MB_CUR_MAX == 1)
    {
      for (i = 0; i < NCHAR; ++i)
        trans[i] = TOLOWER (i);

      kwset = kwsalloc (trans);
    }
  else
    kwset = kwsalloc (NULL);

  if (!kwset)
    xalloc_die ();
}

#ifdef MBS_SUPPORT
/* Convert the *N-byte string, BEG, to lowercase, and write the
   NUL-terminated result into malloc'd storage.  Upon success, set *N
   to the length (in bytes) of the resulting string (not including the
   trailing NUL byte), and return a pointer to the lowercase string.
   Upon memory allocation failure, this function exits.

   Note that while this function returns a pointer to malloc'd storage,
   the caller must not free it, since this function retains a pointer
   to the buffer and reuses it on any subsequent call.  As a consequence,
   this function is not thread-safe.  */
static char *
mbtolower (const char *beg, size_t *n)
{
  static char *out;
  static size_t outalloc;
  size_t outlen, mb_cur_max;
  mbstate_t is, os;
  const char *end;
  char *p;

  if (*n > outalloc)
    {
      out = xrealloc (out, *n);
      outalloc = *n;
    }

  memset (&is, 0, sizeof (is));
  memset (&os, 0, sizeof (os));
  end = beg + *n;

  mb_cur_max = MB_CUR_MAX;
  p = out;
  outlen = 0;
  while (beg < end)
    {
      wchar_t wc;
      size_t mbclen = mbrtowc(&wc, beg, end - beg, &is);
      if (outlen + mb_cur_max >= outalloc)
        {
          out = x2nrealloc (out, &outalloc, 1);
          p = out + outlen;
        }

      if (mbclen == (size_t) -1 || mbclen == (size_t) -2 || mbclen == 0)
        {
          /* An invalid sequence, or a truncated multi-octet character.
             We treat it as a single-octet character.  */
          *p++ = *beg++;
          outlen++;
          memset (&is, 0, sizeof (is));
          memset (&os, 0, sizeof (os));
        }
      else
        {
          beg += mbclen;
          mbclen = wcrtomb (p, towlower ((wint_t) wc), &os);
          p += mbclen;
          outlen += mbclen;
        }
    }

  *n = p - out;
  *p++ = 0;
  return out;
}
#endif


#ifndef FGREP_PROGRAM
/* DFA compiled regexp. */
static struct dfa dfa;

/* The Regex compiled patterns.  */
static struct patterns
{
  /* Regex compiled regexp. */
  struct re_pattern_buffer regexbuf;
  struct re_registers regs; /* This is here on account of a BRAIN-DEAD
			       Q@#%!# library interface in regex.c.  */
} patterns0;

struct patterns *patterns;
size_t pcount;

void
dfaerror (char const *mesg)
{
  error (EXIT_TROUBLE, 0, "%s", mesg);
}

/* Number of compiled fixed strings known to exactly match the regexp.
   If kwsexec returns < kwset_exact_matches, then we don't need to
   call the regexp matcher at all. */
static int kwset_exact_matches;

static char const *
kwsincr_case (const char *must)
{
  const char *buf;
  size_t n;

  n = strlen (must);
#ifdef MBS_SUPPORT
  if (match_icase && MB_CUR_MAX > 1)
    buf = mbtolower (must, &n);
  else
#endif
    buf = must;
  return kwsincr (kwset, buf, n);
}

/* If the DFA turns out to have some set of fixed strings one of
   which must occur in the match, then we build a kwset matcher
   to find those strings, and thus quickly filter out impossible
   matches. */
static void
kwsmusts (void)
{
  struct dfamust const *dm;
  char const *err;

  if (dfa.musts)
    {
      kwsinit ();
      /* First, we compile in the substrings known to be exact
	 matches.  The kwset matcher will return the index
	 of the matching string that it chooses. */
      for (dm = dfa.musts; dm; dm = dm->next)
	{
	  if (!dm->exact)
	    continue;
	  ++kwset_exact_matches;
	  if ((err = kwsincr_case (dm->must)) != NULL)
	    error (EXIT_TROUBLE, 0, "%s", err);
	}
      /* Now, we compile the substrings that will require
	 the use of the regexp matcher.  */
      for (dm = dfa.musts; dm; dm = dm->next)
	{
	  if (dm->exact)
	    continue;
	  if ((err = kwsincr_case (dm->must)) != NULL)
	    error (EXIT_TROUBLE, 0, "%s", err);
	}
      if ((err = kwsprep (kwset)) != NULL)
	error (EXIT_TROUBLE, 0, "%s", err);
    }
}
#endif /* !FGREP_PROGRAM */

#ifdef MBS_SUPPORT

static bool
is_mb_middle(const char **good, const char *buf, const char *end)
{
  const char *p = *good;
  const char *prev = p;
  mbstate_t cur_state;

  /* TODO: can be optimized for UTF-8.  */
  
//Patch 0:
prev = (end);
memset(&cur_state, 0, sizeof(mbstate_t));

//CodeSeg 1:
  while (p < buf)
    {
      size_t mbclen = mbrlen(p, end - p, &cur_state);

      /* Store the beginning of the previous complete multibyte character.  */
      if (mbclen != (size_t) -2)
        prev = p;

      if (mbclen == (size_t) -1 || mbclen == (size_t) -2 || mbclen == 0)
	{
	  /* An invalid sequence, or a truncated multibyte character.
	     We treat it as a single byte character.  */
	  mbclen = 1;
	}
      p += mbclen;
    }

  *good = prev;
  return p > buf;
}
#endif /* MBS_SUPPORT */

#if defined(GREP_PROGRAM) || defined(EGREP_PROGRAM)
#ifdef EGREP_PROGRAM
COMPILE_FCT(Ecompile)
{
  reg_syntax_t syntax_bits = RE_SYNTAX_POSIX_EGREP;
#else
/* No __VA_ARGS__ in C89.  So we have to do it this way.  */
static COMPILE_RET
GEAcompile (char const *pattern, size_t size, reg_syntax_t syntax_bits)
{
#endif /* EGREP_PROGRAM */
  const char *err;
  const char *p, *sep;
  size_t total = size;
  char *motif;

  if (match_icase)
    syntax_bits |= RE_ICASE;
  re_set_syntax (syntax_bits);
  dfasyntax (syntax_bits, match_icase, eolbyte);

  /* For GNU regex compiler we have to pass the patterns separately to detect
     errors like "[\nallo\n]\n".  The patterns here are "[", "allo" and "]"
     GNU regex should have raise a syntax error.  The same for backref, where
     the backref should have been local to each pattern.  */
  p = pattern;
  do
    {
      size_t len;
      sep = memchr (p, '\n', total);
      if (sep)
	{
	  len = sep - p;
	  sep++;
	  total -= (len + 1);
	}
      else
	{
	  len = total;
	  total = 0;
	}

      patterns = realloc (patterns, (pcount + 1) * sizeof (*patterns));
      if (patterns == NULL)
	error (EXIT_TROUBLE, errno, _("memory exhausted"));
      patterns[pcount] = patterns0;

      if ((err = re_compile_pattern (p, len,
				    &(patterns[pcount].regexbuf))) != NULL)
	error (EXIT_TROUBLE, 0, "%s", err);
      pcount++;

      p = sep;
    } while (sep && total != 0);

  /* In the match_words and match_lines cases, we use a different pattern
     for the DFA matcher that will quickly throw out cases that won't work.
     Then if DFA succeeds we do some hairy stuff using the regex matcher
     to decide whether the match should really count. */
  if (match_words || match_lines)
    {
      static char const line_beg_no_bk[] = "^(";
      static char const line_end_no_bk[] = ")$";
      static char const word_beg_no_bk[] = "(^|[^[:alnum:]_])(";
      static char const word_end_no_bk[] = ")([^[:alnum:]_]|$)";
#ifdef EGREP_PROGRAM
# define IF_BK(x, y) (y)
      char *n = xmalloc (sizeof word_beg_no_bk - 1 + size + sizeof word_end_no_bk);
#else
      static char const line_beg_bk[] = "^\\(";
      static char const line_end_bk[] = "\\)$";
      static char const word_beg_bk[] = "\\(^\\|[^[:alnum:]_]\\)\\(";
      static char const word_end_bk[] = "\\)\\([^[:alnum:]_]\\|$\\)";
      int bk = !(syntax_bits & RE_NO_BK_PARENS);
# define IF_BK(x, y) ((bk) ? (x) : (y))
      char *n = xmalloc (sizeof word_beg_bk - 1 + size + sizeof word_end_bk);
#endif /* EGREP_PROGRAM */

      strcpy (n, match_lines ? IF_BK(line_beg_bk, line_beg_no_bk)
			     : IF_BK(word_beg_bk, word_beg_no_bk));
      total = strlen(n);
      memcpy (n + total, pattern, size);
      total += size;
      strcpy (n + total, match_lines ? IF_BK(line_end_bk, line_end_no_bk)
				     : IF_BK(word_end_bk, word_end_no_bk));
      total += strlen (n + total);
      pattern = motif = n;
      size = total;
    }
  else
    motif = NULL;

  dfacomp (pattern, size, &dfa, 1);
  kwsmusts ();

  free(motif);
}

#ifndef EGREP_PROGRAM
COMPILE_FCT(Gcompile)
{
  return GEAcompile (pattern, size,
		     RE_SYNTAX_GREP | RE_HAT_LISTS_NOT_NEWLINE);
}

COMPILE_FCT(Acompile)
{
  return GEAcompile (pattern, size, RE_SYNTAX_AWK);
}

COMPILE_FCT(Ecompile)
{
  return GEAcompile (pattern, size, RE_SYNTAX_POSIX_EGREP);
}
#endif /* !EGREP_PROGRAM */

EXECUTE_FCT(EGexecute)
{
  char const *buflim, *beg, *end, *match, *best_match, *mb_start;
  char eol = eolbyte;
  int backref, start, len, best_len;
  struct kwsmatch kwsm;
  size_t i, ret_val;
#ifdef MBS_SUPPORT
  if (MB_CUR_MAX > 1)
    {
      if (match_icase)
        {
          /* mbtolower adds a NUL byte at the end.  That will provide
	     space for the sentinel byte dfaexec may add.  */
          char *case_buf = mbtolower (buf, &size);
	  if (start_ptr)
	    start_ptr = case_buf + (start_ptr - buf);
          buf = case_buf;
        }
    }
#endif /* MBS_SUPPORT */

  mb_start = buf;
  buflim = buf + size;

  for (beg = end = buf; end < buflim; beg = end)
    {
      if (!start_ptr)
	{
	  /* We don't care about an exact match.  */
	  if (kwset)
	    {
	      /* Find a possible match using the KWset matcher. */
	      size_t offset = kwsexec (kwset, beg, buflim - beg, &kwsm);
	      if (offset == (size_t) -1)
		goto failure;
	      beg += offset;
	      /* Narrow down to the line containing the candidate, and
		 run it through DFA. */
	      if ((end = memchr(beg, eol, buflim - beg)) != NULL)
	        end++;
              else
                end = buflim;
	      match = beg;
	      while (beg > buf && beg[-1] != eol)
		--beg;
	      if (kwsm.index < kwset_exact_matches)
                {
#ifdef MBS_SUPPORT
                  if (mb_start < beg)
                    mb_start = beg;
                  if (MB_CUR_MAX == 1 || !is_mb_middle (&mb_start, match, buflim))
#endif
                    goto success;
                }
	      if (dfaexec (&dfa, beg, (char *) end, 0, NULL, &backref) == NULL)
		continue;
	    }
	  else
	    {
	      /* No good fixed strings; start with DFA. */
	      char const *next_beg = dfaexec (&dfa, beg, (char *) buflim,
					      0, NULL, &backref);
	      if (next_beg == NULL)
		break;
	      /* Narrow down to the line we've found. */
	      beg = next_beg;
	      if ((end = memchr(beg, eol, buflim - beg)) != NULL)
	        end++;
              else
                end = buflim;
	      while (beg > buf && beg[-1] != eol)
		--beg;
	    }
	  /* Successful, no backreferences encountered! */
	  if (!backref)
	    goto success;
	}
      else
	{
	  /* We are looking for the leftmost (then longest) exact match.
	     We will go through the outer loop only once.  */
	  beg = start_ptr;
	  end = buflim;
	}

      /* If we've made it to this point, this means DFA has seen
	 a probable match, and we need to run it through Regex. */
      best_match = end;
      best_len = 0;
      for (i = 0; i < pcount; i++)
	{
	  patterns[i].regexbuf.not_eol = 0;
	  if (0 <= (start = re_search (&(patterns[i].regexbuf),
				       buf, end - buf - 1,
				       beg - buf, end - beg - 1,
				       &(patterns[i].regs))))
	    {
	      len = patterns[i].regs.end[0] - start;
	      match = buf + start;
	      if (match > best_match)
		continue;
	      if (start_ptr && !match_words)
		goto assess_pattern_match;
	      if ((!match_lines && !match_words)
		  || (match_lines && len == end - beg - 1))
		{
		  match = beg;
		  len = end - beg;
		  goto assess_pattern_match;
		}
	      /* If -w, check if the match aligns with word boundaries.
		 We do this iteratively because:
		 (a) the line may contain more than one occurence of the
		 pattern, and
		 (b) Several alternatives in the pattern might be valid at a
		 given point, and we may need to consider a shorter one to
		 find a word boundary.  */
	      if (match_words)
		while (match <= best_match)
		  {
		    if ((match == buf || !WCHAR ((unsigned char) match[-1]))
			&& (len == end - beg - 1
			    || !WCHAR ((unsigned char) match[len])))
		      goto assess_pattern_match;
		    if (len > 0)
		      {
			/* Try a shorter length anchored at the same place. */
			--len;
			patterns[i].regexbuf.not_eol = 1;
			len = re_match (&(patterns[i].regexbuf),
					buf, match + len - beg, match - buf,
					&(patterns[i].regs));
		      }
		    if (len <= 0)
		      {
			/* Try looking further on. */
			if (match == end - 1)
			  break;
			match++;
			patterns[i].regexbuf.not_eol = 0;
			start = re_search (&(patterns[i].regexbuf),
					   buf, end - buf - 1,
					   match - buf, end - match - 1,
					   &(patterns[i].regs));
			if (start < 0)
			  break;
			len = patterns[i].regs.end[0] - start;
			match = buf + start;
		      }
		  } /* while (match <= best_match) */
	      continue;
	    assess_pattern_match:
	      if (!start_ptr)
		{
		  /* Good enough for a non-exact match.
		     No need to look at further patterns, if any.  */
		  beg = match;
		  goto success_in_len;
		}
	      if (match < best_match || (match == best_match && len > best_len))
		{
		  /* Best exact match:  leftmost, then longest.  */
		  best_match = match;
		  best_len = len;
		}
	    } /* if re_search >= 0 */
	} /* for Regex patterns.  */
	if (best_match < end)
	  {
	    /* We have found an exact match.  We were just
	       waiting for the best one (leftmost then longest).  */
	    beg = best_match;
	    len = best_len;
	    goto success_in_len;
	  }
    } /* for (beg = end ..) */

 failure:
  ret_val = -1;
  goto out;

 success:
  len = end - beg;
 success_in_len:
  *match_size = len;
  ret_val = beg - buf;
 out:
  return ret_val;
}
#endif /* defined(GREP_PROGRAM) || defined(EGREP_PROGRAM) */

#if defined(GREP_PROGRAM) || defined(FGREP_PROGRAM)
COMPILE_FCT(Fcompile)
{
  char const *beg, *end, *lim, *err, *pat;
  size_t psize;

  kwsinit ();
  psize = size;
  if (match_icase && MB_CUR_MAX > 1)
    pat = mbtolower (pattern, &psize);
  else
    pat = pattern;

  beg = pat;
  do
    {
      for (lim = beg;; ++lim)
	{
	  end = lim;
	  if (lim >= pat + psize)
	    break;
	 if (*lim == '\n')
	   {
	     lim++;
	     break;
	   }
#if HAVE_DOS_FILE_CONTENTS
	 if (*lim == '\r' && lim + 1 < pat + psize && lim[1] == '\n')
	   {
	     lim += 2;
	     break;
	   }
#endif
	}

      if ((err = kwsincr (kwset, beg, end - beg)) != NULL)
	error (EXIT_TROUBLE, 0, "%s", err);
      beg = lim;
    }
  while (beg < pat + psize);

  if ((err = kwsprep (kwset)) != NULL)
    error (EXIT_TROUBLE, 0, "%s", err);
}

EXECUTE_FCT(Fexecute)
{
  char const *beg, *try, *end, *mb_start;
  size_t len;
  char eol = eolbyte;
  struct kwsmatch kwsmatch;
  size_t ret_val;
#ifdef MBS_SUPPORT
  if (MB_CUR_MAX > 1)
    {
      if (match_icase)
        {
          char *case_buf = mbtolower (buf, &size);
	  if (start_ptr)
	    start_ptr = case_buf + (start_ptr - buf);
          buf = case_buf;
        }
    }
#endif /* MBS_SUPPORT */

  for (mb_start = beg = start_ptr ? start_ptr : buf; beg <= buf + size; beg++)
    {
      size_t offset = kwsexec (kwset, beg, buf + size - beg, &kwsmatch);
      if (offset == (size_t) -1)
	goto failure;
#ifdef MBS_SUPPORT
      if (MB_CUR_MAX > 1 && is_mb_middle (&mb_start, beg + offset, buf + size))
        {
          beg = mb_start - 1;
          continue; /* It is a part of multibyte character.  */
        }
#endif /* MBS_SUPPORT */
      beg += offset;
      len = kwsmatch.size[0];
      if (start_ptr && !match_words)
	goto success_in_beg_and_len;
      if (match_lines)
	{
	  if (beg > buf && beg[-1] != eol)
	    continue;
	  if (beg + len < buf + size && beg[len] != eol)
	    continue;
	  goto success;
	}
      else if (match_words)
	for (try = beg; len; )
	  {
	    if (try > buf && WCHAR((unsigned char) try[-1]))
	      break;
	    if (try + len < buf + size && WCHAR((unsigned char) try[len]))
	      {
		offset = kwsexec (kwset, beg, --len, &kwsmatch);
		if (offset == (size_t) -1)
		  break;
		try = beg + offset;
		len = kwsmatch.size[0];
	      }
	    else if (!start_ptr)
	      goto success;
	    else
	      goto success_in_beg_and_len;
	  } /* for (try) */
      else
	goto success;
    } /* for (beg in buf) */

 failure:
  ret_val = -1;
  goto out;

 success:
  if ((end = memchr (beg + len, eol, (buf + size) - (beg + len))) != NULL)
    end++;
  else
    end = buf + size;
  while (buf < beg && beg[-1] != eol)
    --beg;
  len = end - beg;
 success_in_beg_and_len:
  *match_size = len;
  ret_val = beg - buf;
 out:
  return ret_val;
}
#endif /* defined(GREP_PROGRAM) || defined(FGREP_PROGRAM) */

#ifdef GREP_PROGRAM
#if HAVE_LIBPCRE
/* Compiled internal form of a Perl regular expression.  */
static pcre *cre;

/* Additional information about the pattern.  */
static pcre_extra *extra;
#endif

COMPILE_FCT(Pcompile)
{
#if !HAVE_LIBPCRE
  error (EXIT_TROUBLE, 0, "%s",
	 _("support for the -P option is not compiled into "
	   "this --disable-perl-regexp binary"));
#else
  int e;
  char const *ep;
  char *re = xmalloc (4 * size + 7);
  int flags = PCRE_MULTILINE | (match_icase ? PCRE_CASELESS : 0);
  char const *patlim = pattern + size;
  char *n = re;
  char const *p;
  char const *pnul;

  /* FIXME: Remove these restrictions.  */
  if (memchr(pattern, '\n', size))
    error (EXIT_TROUBLE, 0, _("the -P option only supports a single pattern"));

  *n = '\0';
  if (match_lines)
    strcpy (n, "^(");
  if (match_words)
    strcpy (n, "\\b(");
  n += strlen (n);

  /* The PCRE interface doesn't allow NUL bytes in the pattern, so
     replace each NUL byte in the pattern with the four characters
     "\000", removing a preceding backslash if there are an odd
     number of backslashes before the NUL.

     FIXME: This method does not work with some multibyte character
     encodings, notably Shift-JIS, where a multibyte character can end
     in a backslash byte.  */
  for (p = pattern; (pnul = memchr (p, '\0', patlim - p)); p = pnul + 1)
    {
      memcpy (n, p, pnul - p);
      n += pnul - p;
      for (p = pnul; pattern < p && p[-1] == '\\'; p--)
	continue;
      n -= (pnul - p) & 1;
      strcpy (n, "\\000");
      n += 4;
    }

  memcpy (n, p, patlim - p);
  n += patlim - p;
  *n = '\0';
  if (match_words)
    strcpy (n, ")\\b");
  if (match_lines)
    strcpy (n, ")$");

  cre = pcre_compile (re, flags, &ep, &e, pcre_maketables ());
  if (!cre)
    error (EXIT_TROUBLE, 0, "%s", ep);

  extra = pcre_study (cre, 0, &ep);
  if (ep)
    error (EXIT_TROUBLE, 0, "%s", ep);

  free (re);
#endif
}

EXECUTE_FCT(Pexecute)
{
#if !HAVE_LIBPCRE
  abort ();
  return -1;
#else
  /* This array must have at least two elements; everything after that
     is just for performance improvement in pcre_exec.  */
  int sub[300];

  const char *line_buf, *line_end, *line_next;
  int e = PCRE_ERROR_NOMATCH;
  ptrdiff_t start_ofs = start_ptr ? start_ptr - buf : 0;

  /* PCRE can't limit the matching to single lines, therefore we have to
     match each line in the buffer separately.  */
  for (line_next = buf;
       e == PCRE_ERROR_NOMATCH && line_next < buf + size;
       start_ofs -= line_next - line_buf)
    {
      line_buf = line_next;
      line_end = memchr (line_buf, eolbyte, (buf + size) - line_buf);
      if (line_end == NULL)
        line_next = line_end = buf + size;
      else
        line_next = line_end + 1;

      if (start_ptr && start_ptr >= line_end)
        continue;

      e = pcre_exec (cre, extra, line_buf, line_end - line_buf,
                     start_ofs < 0 ? 0 : start_ofs, 0,
                     sub, sizeof sub / sizeof *sub);
    }

  if (e <= 0)
    {
      switch (e)
	{
	case PCRE_ERROR_NOMATCH:
	  return -1;

	case PCRE_ERROR_NOMEMORY:
	  error (EXIT_TROUBLE, 0, _("memory exhausted"));

	default:
	  abort ();
	}
    }
  else
    {
      /* Narrow down to the line we've found.  */
      char const *beg = line_buf + sub[0];
      char const *end = line_buf + sub[1];
      char const *buflim = buf + size;
      char eol = eolbyte;
      if (!start_ptr)
	{
	  /* FIXME: The case when '\n' is not found indicates a bug:
	     Since grep is line oriented, the match should never contain
	     a newline, so there _must_ be a newline following.
	   */
	  if (!(end = memchr (end, eol, buflim - end)))
	    end = buflim;
	  else
	    end++;
	  while (buf < beg && beg[-1] != eol)
	    --beg;
	}

      *match_size = end - beg;
      return beg - buf;
    }
#endif
}

struct matcher const matchers[] = {
  { "default", Gcompile, EGexecute },
  { "grep",    Gcompile, EGexecute },
  { "egrep",   Ecompile, EGexecute },
  { "awk",     Acompile, EGexecute },
  { "fgrep",   Fcompile, Fexecute },
  { "perl",    Pcompile, Pexecute },
  { "", 0, 0 },
};
#endif /* GREP_PROGRAM */

Spawn 1 instances, now Total 30
Counter: 31
Batcher Size:30
Preprocess the following candidate with BasicTester:
Priority 7489
At location src/search.c:237
--Src File: src/search.c
Fragment 0:
prev = (p);
memset(&cur_state, 0, sizeof(mbstate_t));


BasicTester, a patch instance with id 1:
//src_file:src/search.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
/* search.c - searching subroutines using dfa, kwset and regex for grep.
   Copyright 1992, 1998, 2000, 2007, 2009-2010 Free Software Foundation, Inc.

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 3, or (at your option)
   any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program; if not, write to the Free Software
   Foundation, Inc., 51 Franklin Street - Fifth Floor, Boston, MA
   02110-1301, USA.  */

/* Written August 1992 by Mike Haertel. */

#include <config.h>

#include <sys/types.h>

#include "mbsupport.h"
#ifdef MBS_SUPPORT
/* We can handle multibyte strings. */
# include <wchar.h>
# include <wctype.h>
#endif

#include "system.h"
#include "grep.h"
#ifndef FGREP_PROGRAM
# include <regex.h>
# include "dfa.h"
#endif
#include "kwset.h"
#include "error.h"
#include "xalloc.h"
#ifdef HAVE_LIBPCRE
# include <pcre.h>
#endif

#define NCHAR (UCHAR_MAX + 1)

/* For -w, we also consider _ to be word constituent.  */
#define WCHAR(C) (ISALNUM(C) || (C) == '_')

/* KWset compiled pattern.  For Ecompile and Gcompile, we compile
   a list of strings, at least one of which is known to occur in
   any string matching the regexp. */
static kwset_t kwset;

static void
kwsinit (void)
{
  static char trans[NCHAR];
  int i;

  if (match_icase && MB_CUR_MAX == 1)
    {
      for (i = 0; i < NCHAR; ++i)
        trans[i] = TOLOWER (i);

      kwset = kwsalloc (trans);
    }
  else
    kwset = kwsalloc (NULL);

  if (!kwset)
    xalloc_die ();
}

#ifdef MBS_SUPPORT
/* Convert the *N-byte string, BEG, to lowercase, and write the
   NUL-terminated result into malloc'd storage.  Upon success, set *N
   to the length (in bytes) of the resulting string (not including the
   trailing NUL byte), and return a pointer to the lowercase string.
   Upon memory allocation failure, this function exits.

   Note that while this function returns a pointer to malloc'd storage,
   the caller must not free it, since this function retains a pointer
   to the buffer and reuses it on any subsequent call.  As a consequence,
   this function is not thread-safe.  */
static char *
mbtolower (const char *beg, size_t *n)
{
  static char *out;
  static size_t outalloc;
  size_t outlen, mb_cur_max;
  mbstate_t is, os;
  const char *end;
  char *p;

  if (*n > outalloc)
    {
      out = xrealloc (out, *n);
      outalloc = *n;
    }

  memset (&is, 0, sizeof (is));
  memset (&os, 0, sizeof (os));
  end = beg + *n;

  mb_cur_max = MB_CUR_MAX;
  p = out;
  outlen = 0;
  while (beg < end)
    {
      wchar_t wc;
      size_t mbclen = mbrtowc(&wc, beg, end - beg, &is);
      if (outlen + mb_cur_max >= outalloc)
        {
          out = x2nrealloc (out, &outalloc, 1);
          p = out + outlen;
        }

      if (mbclen == (size_t) -1 || mbclen == (size_t) -2 || mbclen == 0)
        {
          /* An invalid sequence, or a truncated multi-octet character.
             We treat it as a single-octet character.  */
          *p++ = *beg++;
          outlen++;
          memset (&is, 0, sizeof (is));
          memset (&os, 0, sizeof (os));
        }
      else
        {
          beg += mbclen;
          mbclen = wcrtomb (p, towlower ((wint_t) wc), &os);
          p += mbclen;
          outlen += mbclen;
        }
    }

  *n = p - out;
  *p++ = 0;
  return out;
}
#endif


#ifndef FGREP_PROGRAM
/* DFA compiled regexp. */
static struct dfa dfa;

/* The Regex compiled patterns.  */
static struct patterns
{
  /* Regex compiled regexp. */
  struct re_pattern_buffer regexbuf;
  struct re_registers regs; /* This is here on account of a BRAIN-DEAD
			       Q@#%!# library interface in regex.c.  */
} patterns0;

struct patterns *patterns;
size_t pcount;

void
dfaerror (char const *mesg)
{
  error (EXIT_TROUBLE, 0, "%s", mesg);
}

/* Number of compiled fixed strings known to exactly match the regexp.
   If kwsexec returns < kwset_exact_matches, then we don't need to
   call the regexp matcher at all. */
static int kwset_exact_matches;

static char const *
kwsincr_case (const char *must)
{
  const char *buf;
  size_t n;

  n = strlen (must);
#ifdef MBS_SUPPORT
  if (match_icase && MB_CUR_MAX > 1)
    buf = mbtolower (must, &n);
  else
#endif
    buf = must;
  return kwsincr (kwset, buf, n);
}

/* If the DFA turns out to have some set of fixed strings one of
   which must occur in the match, then we build a kwset matcher
   to find those strings, and thus quickly filter out impossible
   matches. */
static void
kwsmusts (void)
{
  struct dfamust const *dm;
  char const *err;

  if (dfa.musts)
    {
      kwsinit ();
      /* First, we compile in the substrings known to be exact
	 matches.  The kwset matcher will return the index
	 of the matching string that it chooses. */
      for (dm = dfa.musts; dm; dm = dm->next)
	{
	  if (!dm->exact)
	    continue;
	  ++kwset_exact_matches;
	  if ((err = kwsincr_case (dm->must)) != NULL)
	    error (EXIT_TROUBLE, 0, "%s", err);
	}
      /* Now, we compile the substrings that will require
	 the use of the regexp matcher.  */
      for (dm = dfa.musts; dm; dm = dm->next)
	{
	  if (dm->exact)
	    continue;
	  if ((err = kwsincr_case (dm->must)) != NULL)
	    error (EXIT_TROUBLE, 0, "%s", err);
	}
      if ((err = kwsprep (kwset)) != NULL)
	error (EXIT_TROUBLE, 0, "%s", err);
    }
}
#endif /* !FGREP_PROGRAM */

#ifdef MBS_SUPPORT

static bool
is_mb_middle(const char **good, const char *buf, const char *end)
{
  const char *p = *good;
  const char *prev = p;
  mbstate_t cur_state;

  /* TODO: can be optimized for UTF-8.  */
  
//Patch 0:
prev = (p);
memset(&cur_state, 0, sizeof(mbstate_t));

//CodeSeg 1:
  while (p < buf)
    {
      size_t mbclen = mbrlen(p, end - p, &cur_state);

      /* Store the beginning of the previous complete multibyte character.  */
      if (mbclen != (size_t) -2)
        prev = p;

      if (mbclen == (size_t) -1 || mbclen == (size_t) -2 || mbclen == 0)
	{
	  /* An invalid sequence, or a truncated multibyte character.
	     We treat it as a single byte character.  */
	  mbclen = 1;
	}
      p += mbclen;
    }

  *good = prev;
  return p > buf;
}
#endif /* MBS_SUPPORT */

#if defined(GREP_PROGRAM) || defined(EGREP_PROGRAM)
#ifdef EGREP_PROGRAM
COMPILE_FCT(Ecompile)
{
  reg_syntax_t syntax_bits = RE_SYNTAX_POSIX_EGREP;
#else
/* No __VA_ARGS__ in C89.  So we have to do it this way.  */
static COMPILE_RET
GEAcompile (char const *pattern, size_t size, reg_syntax_t syntax_bits)
{
#endif /* EGREP_PROGRAM */
  const char *err;
  const char *p, *sep;
  size_t total = size;
  char *motif;

  if (match_icase)
    syntax_bits |= RE_ICASE;
  re_set_syntax (syntax_bits);
  dfasyntax (syntax_bits, match_icase, eolbyte);

  /* For GNU regex compiler we have to pass the patterns separately to detect
     errors like "[\nallo\n]\n".  The patterns here are "[", "allo" and "]"
     GNU regex should have raise a syntax error.  The same for backref, where
     the backref should have been local to each pattern.  */
  p = pattern;
  do
    {
      size_t len;
      sep = memchr (p, '\n', total);
      if (sep)
	{
	  len = sep - p;
	  sep++;
	  total -= (len + 1);
	}
      else
	{
	  len = total;
	  total = 0;
	}

      patterns = realloc (patterns, (pcount + 1) * sizeof (*patterns));
      if (patterns == NULL)
	error (EXIT_TROUBLE, errno, _("memory exhausted"));
      patterns[pcount] = patterns0;

      if ((err = re_compile_pattern (p, len,
				    &(patterns[pcount].regexbuf))) != NULL)
	error (EXIT_TROUBLE, 0, "%s", err);
      pcount++;

      p = sep;
    } while (sep && total != 0);

  /* In the match_words and match_lines cases, we use a different pattern
     for the DFA matcher that will quickly throw out cases that won't work.
     Then if DFA succeeds we do some hairy stuff using the regex matcher
     to decide whether the match should really count. */
  if (match_words || match_lines)
    {
      static char const line_beg_no_bk[] = "^(";
      static char const line_end_no_bk[] = ")$";
      static char const word_beg_no_bk[] = "(^|[^[:alnum:]_])(";
      static char const word_end_no_bk[] = ")([^[:alnum:]_]|$)";
#ifdef EGREP_PROGRAM
# define IF_BK(x, y) (y)
      char *n = xmalloc (sizeof word_beg_no_bk - 1 + size + sizeof word_end_no_bk);
#else
      static char const line_beg_bk[] = "^\\(";
      static char const line_end_bk[] = "\\)$";
      static char const word_beg_bk[] = "\\(^\\|[^[:alnum:]_]\\)\\(";
      static char const word_end_bk[] = "\\)\\([^[:alnum:]_]\\|$\\)";
      int bk = !(syntax_bits & RE_NO_BK_PARENS);
# define IF_BK(x, y) ((bk) ? (x) : (y))
      char *n = xmalloc (sizeof word_beg_bk - 1 + size + sizeof word_end_bk);
#endif /* EGREP_PROGRAM */

      strcpy (n, match_lines ? IF_BK(line_beg_bk, line_beg_no_bk)
			     : IF_BK(word_beg_bk, word_beg_no_bk));
      total = strlen(n);
      memcpy (n + total, pattern, size);
      total += size;
      strcpy (n + total, match_lines ? IF_BK(line_end_bk, line_end_no_bk)
				     : IF_BK(word_end_bk, word_end_no_bk));
      total += strlen (n + total);
      pattern = motif = n;
      size = total;
    }
  else
    motif = NULL;

  dfacomp (pattern, size, &dfa, 1);
  kwsmusts ();

  free(motif);
}

#ifndef EGREP_PROGRAM
COMPILE_FCT(Gcompile)
{
  return GEAcompile (pattern, size,
		     RE_SYNTAX_GREP | RE_HAT_LISTS_NOT_NEWLINE);
}

COMPILE_FCT(Acompile)
{
  return GEAcompile (pattern, size, RE_SYNTAX_AWK);
}

COMPILE_FCT(Ecompile)
{
  return GEAcompile (pattern, size, RE_SYNTAX_POSIX_EGREP);
}
#endif /* !EGREP_PROGRAM */

EXECUTE_FCT(EGexecute)
{
  char const *buflim, *beg, *end, *match, *best_match, *mb_start;
  char eol = eolbyte;
  int backref, start, len, best_len;
  struct kwsmatch kwsm;
  size_t i, ret_val;
#ifdef MBS_SUPPORT
  if (MB_CUR_MAX > 1)
    {
      if (match_icase)
        {
          /* mbtolower adds a NUL byte at the end.  That will provide
	     space for the sentinel byte dfaexec may add.  */
          char *case_buf = mbtolower (buf, &size);
	  if (start_ptr)
	    start_ptr = case_buf + (start_ptr - buf);
          buf = case_buf;
        }
    }
#endif /* MBS_SUPPORT */

  mb_start = buf;
  buflim = buf + size;

  for (beg = end = buf; end < buflim; beg = end)
    {
      if (!start_ptr)
	{
	  /* We don't care about an exact match.  */
	  if (kwset)
	    {
	      /* Find a possible match using the KWset matcher. */
	      size_t offset = kwsexec (kwset, beg, buflim - beg, &kwsm);
	      if (offset == (size_t) -1)
		goto failure;
	      beg += offset;
	      /* Narrow down to the line containing the candidate, and
		 run it through DFA. */
	      if ((end = memchr(beg, eol, buflim - beg)) != NULL)
	        end++;
              else
                end = buflim;
	      match = beg;
	      while (beg > buf && beg[-1] != eol)
		--beg;
	      if (kwsm.index < kwset_exact_matches)
                {
#ifdef MBS_SUPPORT
                  if (mb_start < beg)
                    mb_start = beg;
                  if (MB_CUR_MAX == 1 || !is_mb_middle (&mb_start, match, buflim))
#endif
                    goto success;
                }
	      if (dfaexec (&dfa, beg, (char *) end, 0, NULL, &backref) == NULL)
		continue;
	    }
	  else
	    {
	      /* No good fixed strings; start with DFA. */
	      char const *next_beg = dfaexec (&dfa, beg, (char *) buflim,
					      0, NULL, &backref);
	      if (next_beg == NULL)
		break;
	      /* Narrow down to the line we've found. */
	      beg = next_beg;
	      if ((end = memchr(beg, eol, buflim - beg)) != NULL)
	        end++;
              else
                end = buflim;
	      while (beg > buf && beg[-1] != eol)
		--beg;
	    }
	  /* Successful, no backreferences encountered! */
	  if (!backref)
	    goto success;
	}
      else
	{
	  /* We are looking for the leftmost (then longest) exact match.
	     We will go through the outer loop only once.  */
	  beg = start_ptr;
	  end = buflim;
	}

      /* If we've made it to this point, this means DFA has seen
	 a probable match, and we need to run it through Regex. */
      best_match = end;
      best_len = 0;
      for (i = 0; i < pcount; i++)
	{
	  patterns[i].regexbuf.not_eol = 0;
	  if (0 <= (start = re_search (&(patterns[i].regexbuf),
				       buf, end - buf - 1,
				       beg - buf, end - beg - 1,
				       &(patterns[i].regs))))
	    {
	      len = patterns[i].regs.end[0] - start;
	      match = buf + start;
	      if (match > best_match)
		continue;
	      if (start_ptr && !match_words)
		goto assess_pattern_match;
	      if ((!match_lines && !match_words)
		  || (match_lines && len == end - beg - 1))
		{
		  match = beg;
		  len = end - beg;
		  goto assess_pattern_match;
		}
	      /* If -w, check if the match aligns with word boundaries.
		 We do this iteratively because:
		 (a) the line may contain more than one occurence of the
		 pattern, and
		 (b) Several alternatives in the pattern might be valid at a
		 given point, and we may need to consider a shorter one to
		 find a word boundary.  */
	      if (match_words)
		while (match <= best_match)
		  {
		    if ((match == buf || !WCHAR ((unsigned char) match[-1]))
			&& (len == end - beg - 1
			    || !WCHAR ((unsigned char) match[len])))
		      goto assess_pattern_match;
		    if (len > 0)
		      {
			/* Try a shorter length anchored at the same place. */
			--len;
			patterns[i].regexbuf.not_eol = 1;
			len = re_match (&(patterns[i].regexbuf),
					buf, match + len - beg, match - buf,
					&(patterns[i].regs));
		      }
		    if (len <= 0)
		      {
			/* Try looking further on. */
			if (match == end - 1)
			  break;
			match++;
			patterns[i].regexbuf.not_eol = 0;
			start = re_search (&(patterns[i].regexbuf),
					   buf, end - buf - 1,
					   match - buf, end - match - 1,
					   &(patterns[i].regs));
			if (start < 0)
			  break;
			len = patterns[i].regs.end[0] - start;
			match = buf + start;
		      }
		  } /* while (match <= best_match) */
	      continue;
	    assess_pattern_match:
	      if (!start_ptr)
		{
		  /* Good enough for a non-exact match.
		     No need to look at further patterns, if any.  */
		  beg = match;
		  goto success_in_len;
		}
	      if (match < best_match || (match == best_match && len > best_len))
		{
		  /* Best exact match:  leftmost, then longest.  */
		  best_match = match;
		  best_len = len;
		}
	    } /* if re_search >= 0 */
	} /* for Regex patterns.  */
	if (best_match < end)
	  {
	    /* We have found an exact match.  We were just
	       waiting for the best one (leftmost then longest).  */
	    beg = best_match;
	    len = best_len;
	    goto success_in_len;
	  }
    } /* for (beg = end ..) */

 failure:
  ret_val = -1;
  goto out;

 success:
  len = end - beg;
 success_in_len:
  *match_size = len;
  ret_val = beg - buf;
 out:
  return ret_val;
}
#endif /* defined(GREP_PROGRAM) || defined(EGREP_PROGRAM) */

#if defined(GREP_PROGRAM) || defined(FGREP_PROGRAM)
COMPILE_FCT(Fcompile)
{
  char const *beg, *end, *lim, *err, *pat;
  size_t psize;

  kwsinit ();
  psize = size;
  if (match_icase && MB_CUR_MAX > 1)
    pat = mbtolower (pattern, &psize);
  else
    pat = pattern;

  beg = pat;
  do
    {
      for (lim = beg;; ++lim)
	{
	  end = lim;
	  if (lim >= pat + psize)
	    break;
	 if (*lim == '\n')
	   {
	     lim++;
	     break;
	   }
#if HAVE_DOS_FILE_CONTENTS
	 if (*lim == '\r' && lim + 1 < pat + psize && lim[1] == '\n')
	   {
	     lim += 2;
	     break;
	   }
#endif
	}

      if ((err = kwsincr (kwset, beg, end - beg)) != NULL)
	error (EXIT_TROUBLE, 0, "%s", err);
      beg = lim;
    }
  while (beg < pat + psize);

  if ((err = kwsprep (kwset)) != NULL)
    error (EXIT_TROUBLE, 0, "%s", err);
}

EXECUTE_FCT(Fexecute)
{
  char const *beg, *try, *end, *mb_start;
  size_t len;
  char eol = eolbyte;
  struct kwsmatch kwsmatch;
  size_t ret_val;
#ifdef MBS_SUPPORT
  if (MB_CUR_MAX > 1)
    {
      if (match_icase)
        {
          char *case_buf = mbtolower (buf, &size);
	  if (start_ptr)
	    start_ptr = case_buf + (start_ptr - buf);
          buf = case_buf;
        }
    }
#endif /* MBS_SUPPORT */

  for (mb_start = beg = start_ptr ? start_ptr : buf; beg <= buf + size; beg++)
    {
      size_t offset = kwsexec (kwset, beg, buf + size - beg, &kwsmatch);
      if (offset == (size_t) -1)
	goto failure;
#ifdef MBS_SUPPORT
      if (MB_CUR_MAX > 1 && is_mb_middle (&mb_start, beg + offset, buf + size))
        {
          beg = mb_start - 1;
          continue; /* It is a part of multibyte character.  */
        }
#endif /* MBS_SUPPORT */
      beg += offset;
      len = kwsmatch.size[0];
      if (start_ptr && !match_words)
	goto success_in_beg_and_len;
      if (match_lines)
	{
	  if (beg > buf && beg[-1] != eol)
	    continue;
	  if (beg + len < buf + size && beg[len] != eol)
	    continue;
	  goto success;
	}
      else if (match_words)
	for (try = beg; len; )
	  {
	    if (try > buf && WCHAR((unsigned char) try[-1]))
	      break;
	    if (try + len < buf + size && WCHAR((unsigned char) try[len]))
	      {
		offset = kwsexec (kwset, beg, --len, &kwsmatch);
		if (offset == (size_t) -1)
		  break;
		try = beg + offset;
		len = kwsmatch.size[0];
	      }
	    else if (!start_ptr)
	      goto success;
	    else
	      goto success_in_beg_and_len;
	  } /* for (try) */
      else
	goto success;
    } /* for (beg in buf) */

 failure:
  ret_val = -1;
  goto out;

 success:
  if ((end = memchr (beg + len, eol, (buf + size) - (beg + len))) != NULL)
    end++;
  else
    end = buf + size;
  while (buf < beg && beg[-1] != eol)
    --beg;
  len = end - beg;
 success_in_beg_and_len:
  *match_size = len;
  ret_val = beg - buf;
 out:
  return ret_val;
}
#endif /* defined(GREP_PROGRAM) || defined(FGREP_PROGRAM) */

#ifdef GREP_PROGRAM
#if HAVE_LIBPCRE
/* Compiled internal form of a Perl regular expression.  */
static pcre *cre;

/* Additional information about the pattern.  */
static pcre_extra *extra;
#endif

COMPILE_FCT(Pcompile)
{
#if !HAVE_LIBPCRE
  error (EXIT_TROUBLE, 0, "%s",
	 _("support for the -P option is not compiled into "
	   "this --disable-perl-regexp binary"));
#else
  int e;
  char const *ep;
  char *re = xmalloc (4 * size + 7);
  int flags = PCRE_MULTILINE | (match_icase ? PCRE_CASELESS : 0);
  char const *patlim = pattern + size;
  char *n = re;
  char const *p;
  char const *pnul;

  /* FIXME: Remove these restrictions.  */
  if (memchr(pattern, '\n', size))
    error (EXIT_TROUBLE, 0, _("the -P option only supports a single pattern"));

  *n = '\0';
  if (match_lines)
    strcpy (n, "^(");
  if (match_words)
    strcpy (n, "\\b(");
  n += strlen (n);

  /* The PCRE interface doesn't allow NUL bytes in the pattern, so
     replace each NUL byte in the pattern with the four characters
     "\000", removing a preceding backslash if there are an odd
     number of backslashes before the NUL.

     FIXME: This method does not work with some multibyte character
     encodings, notably Shift-JIS, where a multibyte character can end
     in a backslash byte.  */
  for (p = pattern; (pnul = memchr (p, '\0', patlim - p)); p = pnul + 1)
    {
      memcpy (n, p, pnul - p);
      n += pnul - p;
      for (p = pnul; pattern < p && p[-1] == '\\'; p--)
	continue;
      n -= (pnul - p) & 1;
      strcpy (n, "\\000");
      n += 4;
    }

  memcpy (n, p, patlim - p);
  n += patlim - p;
  *n = '\0';
  if (match_words)
    strcpy (n, ")\\b");
  if (match_lines)
    strcpy (n, ")$");

  cre = pcre_compile (re, flags, &ep, &e, pcre_maketables ());
  if (!cre)
    error (EXIT_TROUBLE, 0, "%s", ep);

  extra = pcre_study (cre, 0, &ep);
  if (ep)
    error (EXIT_TROUBLE, 0, "%s", ep);

  free (re);
#endif
}

EXECUTE_FCT(Pexecute)
{
#if !HAVE_LIBPCRE
  abort ();
  return -1;
#else
  /* This array must have at least two elements; everything after that
     is just for performance improvement in pcre_exec.  */
  int sub[300];

  const char *line_buf, *line_end, *line_next;
  int e = PCRE_ERROR_NOMATCH;
  ptrdiff_t start_ofs = start_ptr ? start_ptr - buf : 0;

  /* PCRE can't limit the matching to single lines, therefore we have to
     match each line in the buffer separately.  */
  for (line_next = buf;
       e == PCRE_ERROR_NOMATCH && line_next < buf + size;
       start_ofs -= line_next - line_buf)
    {
      line_buf = line_next;
      line_end = memchr (line_buf, eolbyte, (buf + size) - line_buf);
      if (line_end == NULL)
        line_next = line_end = buf + size;
      else
        line_next = line_end + 1;

      if (start_ptr && start_ptr >= line_end)
        continue;

      e = pcre_exec (cre, extra, line_buf, line_end - line_buf,
                     start_ofs < 0 ? 0 : start_ofs, 0,
                     sub, sizeof sub / sizeof *sub);
    }

  if (e <= 0)
    {
      switch (e)
	{
	case PCRE_ERROR_NOMATCH:
	  return -1;

	case PCRE_ERROR_NOMEMORY:
	  error (EXIT_TROUBLE, 0, _("memory exhausted"));

	default:
	  abort ();
	}
    }
  else
    {
      /* Narrow down to the line we've found.  */
      char const *beg = line_buf + sub[0];
      char const *end = line_buf + sub[1];
      char const *buflim = buf + size;
      char eol = eolbyte;
      if (!start_ptr)
	{
	  /* FIXME: The case when '\n' is not found indicates a bug:
	     Since grep is line oriented, the match should never contain
	     a newline, so there _must_ be a newline following.
	   */
	  if (!(end = memchr (end, eol, buflim - end)))
	    end = buflim;
	  else
	    end++;
	  while (buf < beg && beg[-1] != eol)
	    --beg;
	}

      *match_size = end - beg;
      return beg - buf;
    }
#endif
}

struct matcher const matchers[] = {
  { "default", Gcompile, EGexecute },
  { "grep",    Gcompile, EGexecute },
  { "egrep",   Ecompile, EGexecute },
  { "awk",     Acompile, EGexecute },
  { "fgrep",   Fcompile, Fexecute },
  { "perl",    Pcompile, Pexecute },
  { "", 0, 0 },
};
#endif /* GREP_PROGRAM */

Spawn 1 instances, now Total 31
Counter: 32
Batcher Size:31
Preprocess the following candidate with BasicTester:
Priority 7489
At location src/search.c:237
--Src File: src/search.c
Fragment 0:
xalloc_die();
memset(&cur_state, 0, sizeof(mbstate_t));


BasicTester, a patch instance with id 2:
//src_file:src/search.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
/* search.c - searching subroutines using dfa, kwset and regex for grep.
   Copyright 1992, 1998, 2000, 2007, 2009-2010 Free Software Foundation, Inc.

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 3, or (at your option)
   any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program; if not, write to the Free Software
   Foundation, Inc., 51 Franklin Street - Fifth Floor, Boston, MA
   02110-1301, USA.  */

/* Written August 1992 by Mike Haertel. */

#include <config.h>

#include <sys/types.h>

#include "mbsupport.h"
#ifdef MBS_SUPPORT
/* We can handle multibyte strings. */
# include <wchar.h>
# include <wctype.h>
#endif

#include "system.h"
#include "grep.h"
#ifndef FGREP_PROGRAM
# include <regex.h>
# include "dfa.h"
#endif
#include "kwset.h"
#include "error.h"
#include "xalloc.h"
#ifdef HAVE_LIBPCRE
# include <pcre.h>
#endif

#define NCHAR (UCHAR_MAX + 1)

/* For -w, we also consider _ to be word constituent.  */
#define WCHAR(C) (ISALNUM(C) || (C) == '_')

/* KWset compiled pattern.  For Ecompile and Gcompile, we compile
   a list of strings, at least one of which is known to occur in
   any string matching the regexp. */
static kwset_t kwset;

static void
kwsinit (void)
{
  static char trans[NCHAR];
  int i;

  if (match_icase && MB_CUR_MAX == 1)
    {
      for (i = 0; i < NCHAR; ++i)
        trans[i] = TOLOWER (i);

      kwset = kwsalloc (trans);
    }
  else
    kwset = kwsalloc (NULL);

  if (!kwset)
    xalloc_die ();
}

#ifdef MBS_SUPPORT
/* Convert the *N-byte string, BEG, to lowercase, and write the
   NUL-terminated result into malloc'd storage.  Upon success, set *N
   to the length (in bytes) of the resulting string (not including the
   trailing NUL byte), and return a pointer to the lowercase string.
   Upon memory allocation failure, this function exits.

   Note that while this function returns a pointer to malloc'd storage,
   the caller must not free it, since this function retains a pointer
   to the buffer and reuses it on any subsequent call.  As a consequence,
   this function is not thread-safe.  */
static char *
mbtolower (const char *beg, size_t *n)
{
  static char *out;
  static size_t outalloc;
  size_t outlen, mb_cur_max;
  mbstate_t is, os;
  const char *end;
  char *p;

  if (*n > outalloc)
    {
      out = xrealloc (out, *n);
      outalloc = *n;
    }

  memset (&is, 0, sizeof (is));
  memset (&os, 0, sizeof (os));
  end = beg + *n;

  mb_cur_max = MB_CUR_MAX;
  p = out;
  outlen = 0;
  while (beg < end)
    {
      wchar_t wc;
      size_t mbclen = mbrtowc(&wc, beg, end - beg, &is);
      if (outlen + mb_cur_max >= outalloc)
        {
          out = x2nrealloc (out, &outalloc, 1);
          p = out + outlen;
        }

      if (mbclen == (size_t) -1 || mbclen == (size_t) -2 || mbclen == 0)
        {
          /* An invalid sequence, or a truncated multi-octet character.
             We treat it as a single-octet character.  */
          *p++ = *beg++;
          outlen++;
          memset (&is, 0, sizeof (is));
          memset (&os, 0, sizeof (os));
        }
      else
        {
          beg += mbclen;
          mbclen = wcrtomb (p, towlower ((wint_t) wc), &os);
          p += mbclen;
          outlen += mbclen;
        }
    }

  *n = p - out;
  *p++ = 0;
  return out;
}
#endif


#ifndef FGREP_PROGRAM
/* DFA compiled regexp. */
static struct dfa dfa;

/* The Regex compiled patterns.  */
static struct patterns
{
  /* Regex compiled regexp. */
  struct re_pattern_buffer regexbuf;
  struct re_registers regs; /* This is here on account of a BRAIN-DEAD
			       Q@#%!# library interface in regex.c.  */
} patterns0;

struct patterns *patterns;
size_t pcount;

void
dfaerror (char const *mesg)
{
  error (EXIT_TROUBLE, 0, "%s", mesg);
}

/* Number of compiled fixed strings known to exactly match the regexp.
   If kwsexec returns < kwset_exact_matches, then we don't need to
   call the regexp matcher at all. */
static int kwset_exact_matches;

static char const *
kwsincr_case (const char *must)
{
  const char *buf;
  size_t n;

  n = strlen (must);
#ifdef MBS_SUPPORT
  if (match_icase && MB_CUR_MAX > 1)
    buf = mbtolower (must, &n);
  else
#endif
    buf = must;
  return kwsincr (kwset, buf, n);
}

/* If the DFA turns out to have some set of fixed strings one of
   which must occur in the match, then we build a kwset matcher
   to find those strings, and thus quickly filter out impossible
   matches. */
static void
kwsmusts (void)
{
  struct dfamust const *dm;
  char const *err;

  if (dfa.musts)
    {
      kwsinit ();
      /* First, we compile in the substrings known to be exact
	 matches.  The kwset matcher will return the index
	 of the matching string that it chooses. */
      for (dm = dfa.musts; dm; dm = dm->next)
	{
	  if (!dm->exact)
	    continue;
	  ++kwset_exact_matches;
	  if ((err = kwsincr_case (dm->must)) != NULL)
	    error (EXIT_TROUBLE, 0, "%s", err);
	}
      /* Now, we compile the substrings that will require
	 the use of the regexp matcher.  */
      for (dm = dfa.musts; dm; dm = dm->next)
	{
	  if (dm->exact)
	    continue;
	  if ((err = kwsincr_case (dm->must)) != NULL)
	    error (EXIT_TROUBLE, 0, "%s", err);
	}
      if ((err = kwsprep (kwset)) != NULL)
	error (EXIT_TROUBLE, 0, "%s", err);
    }
}
#endif /* !FGREP_PROGRAM */

#ifdef MBS_SUPPORT

static bool
is_mb_middle(const char **good, const char *buf, const char *end)
{
  const char *p = *good;
  const char *prev = p;
  mbstate_t cur_state;

  /* TODO: can be optimized for UTF-8.  */
  
//Patch 0:
xalloc_die();
memset(&cur_state, 0, sizeof(mbstate_t));

//CodeSeg 1:
  while (p < buf)
    {
      size_t mbclen = mbrlen(p, end - p, &cur_state);

      /* Store the beginning of the previous complete multibyte character.  */
      if (mbclen != (size_t) -2)
        prev = p;

      if (mbclen == (size_t) -1 || mbclen == (size_t) -2 || mbclen == 0)
	{
	  /* An invalid sequence, or a truncated multibyte character.
	     We treat it as a single byte character.  */
	  mbclen = 1;
	}
      p += mbclen;
    }

  *good = prev;
  return p > buf;
}
#endif /* MBS_SUPPORT */

#if defined(GREP_PROGRAM) || defined(EGREP_PROGRAM)
#ifdef EGREP_PROGRAM
COMPILE_FCT(Ecompile)
{
  reg_syntax_t syntax_bits = RE_SYNTAX_POSIX_EGREP;
#else
/* No __VA_ARGS__ in C89.  So we have to do it this way.  */
static COMPILE_RET
GEAcompile (char const *pattern, size_t size, reg_syntax_t syntax_bits)
{
#endif /* EGREP_PROGRAM */
  const char *err;
  const char *p, *sep;
  size_t total = size;
  char *motif;

  if (match_icase)
    syntax_bits |= RE_ICASE;
  re_set_syntax (syntax_bits);
  dfasyntax (syntax_bits, match_icase, eolbyte);

  /* For GNU regex compiler we have to pass the patterns separately to detect
     errors like "[\nallo\n]\n".  The patterns here are "[", "allo" and "]"
     GNU regex should have raise a syntax error.  The same for backref, where
     the backref should have been local to each pattern.  */
  p = pattern;
  do
    {
      size_t len;
      sep = memchr (p, '\n', total);
      if (sep)
	{
	  len = sep - p;
	  sep++;
	  total -= (len + 1);
	}
      else
	{
	  len = total;
	  total = 0;
	}

      patterns = realloc (patterns, (pcount + 1) * sizeof (*patterns));
      if (patterns == NULL)
	error (EXIT_TROUBLE, errno, _("memory exhausted"));
      patterns[pcount] = patterns0;

      if ((err = re_compile_pattern (p, len,
				    &(patterns[pcount].regexbuf))) != NULL)
	error (EXIT_TROUBLE, 0, "%s", err);
      pcount++;

      p = sep;
    } while (sep && total != 0);

  /* In the match_words and match_lines cases, we use a different pattern
     for the DFA matcher that will quickly throw out cases that won't work.
     Then if DFA succeeds we do some hairy stuff using the regex matcher
     to decide whether the match should really count. */
  if (match_words || match_lines)
    {
      static char const line_beg_no_bk[] = "^(";
      static char const line_end_no_bk[] = ")$";
      static char const word_beg_no_bk[] = "(^|[^[:alnum:]_])(";
      static char const word_end_no_bk[] = ")([^[:alnum:]_]|$)";
#ifdef EGREP_PROGRAM
# define IF_BK(x, y) (y)
      char *n = xmalloc (sizeof word_beg_no_bk - 1 + size + sizeof word_end_no_bk);
#else
      static char const line_beg_bk[] = "^\\(";
      static char const line_end_bk[] = "\\)$";
      static char const word_beg_bk[] = "\\(^\\|[^[:alnum:]_]\\)\\(";
      static char const word_end_bk[] = "\\)\\([^[:alnum:]_]\\|$\\)";
      int bk = !(syntax_bits & RE_NO_BK_PARENS);
# define IF_BK(x, y) ((bk) ? (x) : (y))
      char *n = xmalloc (sizeof word_beg_bk - 1 + size + sizeof word_end_bk);
#endif /* EGREP_PROGRAM */

      strcpy (n, match_lines ? IF_BK(line_beg_bk, line_beg_no_bk)
			     : IF_BK(word_beg_bk, word_beg_no_bk));
      total = strlen(n);
      memcpy (n + total, pattern, size);
      total += size;
      strcpy (n + total, match_lines ? IF_BK(line_end_bk, line_end_no_bk)
				     : IF_BK(word_end_bk, word_end_no_bk));
      total += strlen (n + total);
      pattern = motif = n;
      size = total;
    }
  else
    motif = NULL;

  dfacomp (pattern, size, &dfa, 1);
  kwsmusts ();

  free(motif);
}

#ifndef EGREP_PROGRAM
COMPILE_FCT(Gcompile)
{
  return GEAcompile (pattern, size,
		     RE_SYNTAX_GREP | RE_HAT_LISTS_NOT_NEWLINE);
}

COMPILE_FCT(Acompile)
{
  return GEAcompile (pattern, size, RE_SYNTAX_AWK);
}

COMPILE_FCT(Ecompile)
{
  return GEAcompile (pattern, size, RE_SYNTAX_POSIX_EGREP);
}
#endif /* !EGREP_PROGRAM */

EXECUTE_FCT(EGexecute)
{
  char const *buflim, *beg, *end, *match, *best_match, *mb_start;
  char eol = eolbyte;
  int backref, start, len, best_len;
  struct kwsmatch kwsm;
  size_t i, ret_val;
#ifdef MBS_SUPPORT
  if (MB_CUR_MAX > 1)
    {
      if (match_icase)
        {
          /* mbtolower adds a NUL byte at the end.  That will provide
	     space for the sentinel byte dfaexec may add.  */
          char *case_buf = mbtolower (buf, &size);
	  if (start_ptr)
	    start_ptr = case_buf + (start_ptr - buf);
          buf = case_buf;
        }
    }
#endif /* MBS_SUPPORT */

  mb_start = buf;
  buflim = buf + size;

  for (beg = end = buf; end < buflim; beg = end)
    {
      if (!start_ptr)
	{
	  /* We don't care about an exact match.  */
	  if (kwset)
	    {
	      /* Find a possible match using the KWset matcher. */
	      size_t offset = kwsexec (kwset, beg, buflim - beg, &kwsm);
	      if (offset == (size_t) -1)
		goto failure;
	      beg += offset;
	      /* Narrow down to the line containing the candidate, and
		 run it through DFA. */
	      if ((end = memchr(beg, eol, buflim - beg)) != NULL)
	        end++;
              else
                end = buflim;
	      match = beg;
	      while (beg > buf && beg[-1] != eol)
		--beg;
	      if (kwsm.index < kwset_exact_matches)
                {
#ifdef MBS_SUPPORT
                  if (mb_start < beg)
                    mb_start = beg;
                  if (MB_CUR_MAX == 1 || !is_mb_middle (&mb_start, match, buflim))
#endif
                    goto success;
                }
	      if (dfaexec (&dfa, beg, (char *) end, 0, NULL, &backref) == NULL)
		continue;
	    }
	  else
	    {
	      /* No good fixed strings; start with DFA. */
	      char const *next_beg = dfaexec (&dfa, beg, (char *) buflim,
					      0, NULL, &backref);
	      if (next_beg == NULL)
		break;
	      /* Narrow down to the line we've found. */
	      beg = next_beg;
	      if ((end = memchr(beg, eol, buflim - beg)) != NULL)
	        end++;
              else
                end = buflim;
	      while (beg > buf && beg[-1] != eol)
		--beg;
	    }
	  /* Successful, no backreferences encountered! */
	  if (!backref)
	    goto success;
	}
      else
	{
	  /* We are looking for the leftmost (then longest) exact match.
	     We will go through the outer loop only once.  */
	  beg = start_ptr;
	  end = buflim;
	}

      /* If we've made it to this point, this means DFA has seen
	 a probable match, and we need to run it through Regex. */
      best_match = end;
      best_len = 0;
      for (i = 0; i < pcount; i++)
	{
	  patterns[i].regexbuf.not_eol = 0;
	  if (0 <= (start = re_search (&(patterns[i].regexbuf),
				       buf, end - buf - 1,
				       beg - buf, end - beg - 1,
				       &(patterns[i].regs))))
	    {
	      len = patterns[i].regs.end[0] - start;
	      match = buf + start;
	      if (match > best_match)
		continue;
	      if (start_ptr && !match_words)
		goto assess_pattern_match;
	      if ((!match_lines && !match_words)
		  || (match_lines && len == end - beg - 1))
		{
		  match = beg;
		  len = end - beg;
		  goto assess_pattern_match;
		}
	      /* If -w, check if the match aligns with word boundaries.
		 We do this iteratively because:
		 (a) the line may contain more than one occurence of the
		 pattern, and
		 (b) Several alternatives in the pattern might be valid at a
		 given point, and we may need to consider a shorter one to
		 find a word boundary.  */
	      if (match_words)
		while (match <= best_match)
		  {
		    if ((match == buf || !WCHAR ((unsigned char) match[-1]))
			&& (len == end - beg - 1
			    || !WCHAR ((unsigned char) match[len])))
		      goto assess_pattern_match;
		    if (len > 0)
		      {
			/* Try a shorter length anchored at the same place. */
			--len;
			patterns[i].regexbuf.not_eol = 1;
			len = re_match (&(patterns[i].regexbuf),
					buf, match + len - beg, match - buf,
					&(patterns[i].regs));
		      }
		    if (len <= 0)
		      {
			/* Try looking further on. */
			if (match == end - 1)
			  break;
			match++;
			patterns[i].regexbuf.not_eol = 0;
			start = re_search (&(patterns[i].regexbuf),
					   buf, end - buf - 1,
					   match - buf, end - match - 1,
					   &(patterns[i].regs));
			if (start < 0)
			  break;
			len = patterns[i].regs.end[0] - start;
			match = buf + start;
		      }
		  } /* while (match <= best_match) */
	      continue;
	    assess_pattern_match:
	      if (!start_ptr)
		{
		  /* Good enough for a non-exact match.
		     No need to look at further patterns, if any.  */
		  beg = match;
		  goto success_in_len;
		}
	      if (match < best_match || (match == best_match && len > best_len))
		{
		  /* Best exact match:  leftmost, then longest.  */
		  best_match = match;
		  best_len = len;
		}
	    } /* if re_search >= 0 */
	} /* for Regex patterns.  */
	if (best_match < end)
	  {
	    /* We have found an exact match.  We were just
	       waiting for the best one (leftmost then longest).  */
	    beg = best_match;
	    len = best_len;
	    goto success_in_len;
	  }
    } /* for (beg = end ..) */

 failure:
  ret_val = -1;
  goto out;

 success:
  len = end - beg;
 success_in_len:
  *match_size = len;
  ret_val = beg - buf;
 out:
  return ret_val;
}
#endif /* defined(GREP_PROGRAM) || defined(EGREP_PROGRAM) */

#if defined(GREP_PROGRAM) || defined(FGREP_PROGRAM)
COMPILE_FCT(Fcompile)
{
  char const *beg, *end, *lim, *err, *pat;
  size_t psize;

  kwsinit ();
  psize = size;
  if (match_icase && MB_CUR_MAX > 1)
    pat = mbtolower (pattern, &psize);
  else
    pat = pattern;

  beg = pat;
  do
    {
      for (lim = beg;; ++lim)
	{
	  end = lim;
	  if (lim >= pat + psize)
	    break;
	 if (*lim == '\n')
	   {
	     lim++;
	     break;
	   }
#if HAVE_DOS_FILE_CONTENTS
	 if (*lim == '\r' && lim + 1 < pat + psize && lim[1] == '\n')
	   {
	     lim += 2;
	     break;
	   }
#endif
	}

      if ((err = kwsincr (kwset, beg, end - beg)) != NULL)
	error (EXIT_TROUBLE, 0, "%s", err);
      beg = lim;
    }
  while (beg < pat + psize);

  if ((err = kwsprep (kwset)) != NULL)
    error (EXIT_TROUBLE, 0, "%s", err);
}

EXECUTE_FCT(Fexecute)
{
  char const *beg, *try, *end, *mb_start;
  size_t len;
  char eol = eolbyte;
  struct kwsmatch kwsmatch;
  size_t ret_val;
#ifdef MBS_SUPPORT
  if (MB_CUR_MAX > 1)
    {
      if (match_icase)
        {
          char *case_buf = mbtolower (buf, &size);
	  if (start_ptr)
	    start_ptr = case_buf + (start_ptr - buf);
          buf = case_buf;
        }
    }
#endif /* MBS_SUPPORT */

  for (mb_start = beg = start_ptr ? start_ptr : buf; beg <= buf + size; beg++)
    {
      size_t offset = kwsexec (kwset, beg, buf + size - beg, &kwsmatch);
      if (offset == (size_t) -1)
	goto failure;
#ifdef MBS_SUPPORT
      if (MB_CUR_MAX > 1 && is_mb_middle (&mb_start, beg + offset, buf + size))
        {
          beg = mb_start - 1;
          continue; /* It is a part of multibyte character.  */
        }
#endif /* MBS_SUPPORT */
      beg += offset;
      len = kwsmatch.size[0];
      if (start_ptr && !match_words)
	goto success_in_beg_and_len;
      if (match_lines)
	{
	  if (beg > buf && beg[-1] != eol)
	    continue;
	  if (beg + len < buf + size && beg[len] != eol)
	    continue;
	  goto success;
	}
      else if (match_words)
	for (try = beg; len; )
	  {
	    if (try > buf && WCHAR((unsigned char) try[-1]))
	      break;
	    if (try + len < buf + size && WCHAR((unsigned char) try[len]))
	      {
		offset = kwsexec (kwset, beg, --len, &kwsmatch);
		if (offset == (size_t) -1)
		  break;
		try = beg + offset;
		len = kwsmatch.size[0];
	      }
	    else if (!start_ptr)
	      goto success;
	    else
	      goto success_in_beg_and_len;
	  } /* for (try) */
      else
	goto success;
    } /* for (beg in buf) */

 failure:
  ret_val = -1;
  goto out;

 success:
  if ((end = memchr (beg + len, eol, (buf + size) - (beg + len))) != NULL)
    end++;
  else
    end = buf + size;
  while (buf < beg && beg[-1] != eol)
    --beg;
  len = end - beg;
 success_in_beg_and_len:
  *match_size = len;
  ret_val = beg - buf;
 out:
  return ret_val;
}
#endif /* defined(GREP_PROGRAM) || defined(FGREP_PROGRAM) */

#ifdef GREP_PROGRAM
#if HAVE_LIBPCRE
/* Compiled internal form of a Perl regular expression.  */
static pcre *cre;

/* Additional information about the pattern.  */
static pcre_extra *extra;
#endif

COMPILE_FCT(Pcompile)
{
#if !HAVE_LIBPCRE
  error (EXIT_TROUBLE, 0, "%s",
	 _("support for the -P option is not compiled into "
	   "this --disable-perl-regexp binary"));
#else
  int e;
  char const *ep;
  char *re = xmalloc (4 * size + 7);
  int flags = PCRE_MULTILINE | (match_icase ? PCRE_CASELESS : 0);
  char const *patlim = pattern + size;
  char *n = re;
  char const *p;
  char const *pnul;

  /* FIXME: Remove these restrictions.  */
  if (memchr(pattern, '\n', size))
    error (EXIT_TROUBLE, 0, _("the -P option only supports a single pattern"));

  *n = '\0';
  if (match_lines)
    strcpy (n, "^(");
  if (match_words)
    strcpy (n, "\\b(");
  n += strlen (n);

  /* The PCRE interface doesn't allow NUL bytes in the pattern, so
     replace each NUL byte in the pattern with the four characters
     "\000", removing a preceding backslash if there are an odd
     number of backslashes before the NUL.

     FIXME: This method does not work with some multibyte character
     encodings, notably Shift-JIS, where a multibyte character can end
     in a backslash byte.  */
  for (p = pattern; (pnul = memchr (p, '\0', patlim - p)); p = pnul + 1)
    {
      memcpy (n, p, pnul - p);
      n += pnul - p;
      for (p = pnul; pattern < p && p[-1] == '\\'; p--)
	continue;
      n -= (pnul - p) & 1;
      strcpy (n, "\\000");
      n += 4;
    }

  memcpy (n, p, patlim - p);
  n += patlim - p;
  *n = '\0';
  if (match_words)
    strcpy (n, ")\\b");
  if (match_lines)
    strcpy (n, ")$");

  cre = pcre_compile (re, flags, &ep, &e, pcre_maketables ());
  if (!cre)
    error (EXIT_TROUBLE, 0, "%s", ep);

  extra = pcre_study (cre, 0, &ep);
  if (ep)
    error (EXIT_TROUBLE, 0, "%s", ep);

  free (re);
#endif
}

EXECUTE_FCT(Pexecute)
{
#if !HAVE_LIBPCRE
  abort ();
  return -1;
#else
  /* This array must have at least two elements; everything after that
     is just for performance improvement in pcre_exec.  */
  int sub[300];

  const char *line_buf, *line_end, *line_next;
  int e = PCRE_ERROR_NOMATCH;
  ptrdiff_t start_ofs = start_ptr ? start_ptr - buf : 0;

  /* PCRE can't limit the matching to single lines, therefore we have to
     match each line in the buffer separately.  */
  for (line_next = buf;
       e == PCRE_ERROR_NOMATCH && line_next < buf + size;
       start_ofs -= line_next - line_buf)
    {
      line_buf = line_next;
      line_end = memchr (line_buf, eolbyte, (buf + size) - line_buf);
      if (line_end == NULL)
        line_next = line_end = buf + size;
      else
        line_next = line_end + 1;

      if (start_ptr && start_ptr >= line_end)
        continue;

      e = pcre_exec (cre, extra, line_buf, line_end - line_buf,
                     start_ofs < 0 ? 0 : start_ofs, 0,
                     sub, sizeof sub / sizeof *sub);
    }

  if (e <= 0)
    {
      switch (e)
	{
	case PCRE_ERROR_NOMATCH:
	  return -1;

	case PCRE_ERROR_NOMEMORY:
	  error (EXIT_TROUBLE, 0, _("memory exhausted"));

	default:
	  abort ();
	}
    }
  else
    {
      /* Narrow down to the line we've found.  */
      char const *beg = line_buf + sub[0];
      char const *end = line_buf + sub[1];
      char const *buflim = buf + size;
      char eol = eolbyte;
      if (!start_ptr)
	{
	  /* FIXME: The case when '\n' is not found indicates a bug:
	     Since grep is line oriented, the match should never contain
	     a newline, so there _must_ be a newline following.
	   */
	  if (!(end = memchr (end, eol, buflim - end)))
	    end = buflim;
	  else
	    end++;
	  while (buf < beg && beg[-1] != eol)
	    --beg;
	}

      *match_size = end - beg;
      return beg - buf;
    }
#endif
}

struct matcher const matchers[] = {
  { "default", Gcompile, EGexecute },
  { "grep",    Gcompile, EGexecute },
  { "egrep",   Ecompile, EGexecute },
  { "awk",     Acompile, EGexecute },
  { "fgrep",   Fcompile, Fexecute },
  { "perl",    Pcompile, Pexecute },
  { "", 0, 0 },
};
#endif /* GREP_PROGRAM */

Spawn 1 instances, now Total 32
Counter: 33
Batcher Size:32
Preprocess the following candidate with BasicTester:
Priority 7489
At location src/search.c:237
--Src File: src/search.c
Fragment 0:
prev = (prev);
memset(&cur_state, 0, sizeof(mbstate_t));


BasicTester, a patch instance with id 3:
//src_file:src/search.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
/* search.c - searching subroutines using dfa, kwset and regex for grep.
   Copyright 1992, 1998, 2000, 2007, 2009-2010 Free Software Foundation, Inc.

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 3, or (at your option)
   any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program; if not, write to the Free Software
   Foundation, Inc., 51 Franklin Street - Fifth Floor, Boston, MA
   02110-1301, USA.  */

/* Written August 1992 by Mike Haertel. */

#include <config.h>

#include <sys/types.h>

#include "mbsupport.h"
#ifdef MBS_SUPPORT
/* We can handle multibyte strings. */
# include <wchar.h>
# include <wctype.h>
#endif

#include "system.h"
#include "grep.h"
#ifndef FGREP_PROGRAM
# include <regex.h>
# include "dfa.h"
#endif
#include "kwset.h"
#include "error.h"
#include "xalloc.h"
#ifdef HAVE_LIBPCRE
# include <pcre.h>
#endif

#define NCHAR (UCHAR_MAX + 1)

/* For -w, we also consider _ to be word constituent.  */
#define WCHAR(C) (ISALNUM(C) || (C) == '_')

/* KWset compiled pattern.  For Ecompile and Gcompile, we compile
   a list of strings, at least one of which is known to occur in
   any string matching the regexp. */
static kwset_t kwset;

static void
kwsinit (void)
{
  static char trans[NCHAR];
  int i;

  if (match_icase && MB_CUR_MAX == 1)
    {
      for (i = 0; i < NCHAR; ++i)
        trans[i] = TOLOWER (i);

      kwset = kwsalloc (trans);
    }
  else
    kwset = kwsalloc (NULL);

  if (!kwset)
    xalloc_die ();
}

#ifdef MBS_SUPPORT
/* Convert the *N-byte string, BEG, to lowercase, and write the
   NUL-terminated result into malloc'd storage.  Upon success, set *N
   to the length (in bytes) of the resulting string (not including the
   trailing NUL byte), and return a pointer to the lowercase string.
   Upon memory allocation failure, this function exits.

   Note that while this function returns a pointer to malloc'd storage,
   the caller must not free it, since this function retains a pointer
   to the buffer and reuses it on any subsequent call.  As a consequence,
   this function is not thread-safe.  */
static char *
mbtolower (const char *beg, size_t *n)
{
  static char *out;
  static size_t outalloc;
  size_t outlen, mb_cur_max;
  mbstate_t is, os;
  const char *end;
  char *p;

  if (*n > outalloc)
    {
      out = xrealloc (out, *n);
      outalloc = *n;
    }

  memset (&is, 0, sizeof (is));
  memset (&os, 0, sizeof (os));
  end = beg + *n;

  mb_cur_max = MB_CUR_MAX;
  p = out;
  outlen = 0;
  while (beg < end)
    {
      wchar_t wc;
      size_t mbclen = mbrtowc(&wc, beg, end - beg, &is);
      if (outlen + mb_cur_max >= outalloc)
        {
          out = x2nrealloc (out, &outalloc, 1);
          p = out + outlen;
        }

      if (mbclen == (size_t) -1 || mbclen == (size_t) -2 || mbclen == 0)
        {
          /* An invalid sequence, or a truncated multi-octet character.
             We treat it as a single-octet character.  */
          *p++ = *beg++;
          outlen++;
          memset (&is, 0, sizeof (is));
          memset (&os, 0, sizeof (os));
        }
      else
        {
          beg += mbclen;
          mbclen = wcrtomb (p, towlower ((wint_t) wc), &os);
          p += mbclen;
          outlen += mbclen;
        }
    }

  *n = p - out;
  *p++ = 0;
  return out;
}
#endif


#ifndef FGREP_PROGRAM
/* DFA compiled regexp. */
static struct dfa dfa;

/* The Regex compiled patterns.  */
static struct patterns
{
  /* Regex compiled regexp. */
  struct re_pattern_buffer regexbuf;
  struct re_registers regs; /* This is here on account of a BRAIN-DEAD
			       Q@#%!# library interface in regex.c.  */
} patterns0;

struct patterns *patterns;
size_t pcount;

void
dfaerror (char const *mesg)
{
  error (EXIT_TROUBLE, 0, "%s", mesg);
}

/* Number of compiled fixed strings known to exactly match the regexp.
   If kwsexec returns < kwset_exact_matches, then we don't need to
   call the regexp matcher at all. */
static int kwset_exact_matches;

static char const *
kwsincr_case (const char *must)
{
  const char *buf;
  size_t n;

  n = strlen (must);
#ifdef MBS_SUPPORT
  if (match_icase && MB_CUR_MAX > 1)
    buf = mbtolower (must, &n);
  else
#endif
    buf = must;
  return kwsincr (kwset, buf, n);
}

/* If the DFA turns out to have some set of fixed strings one of
   which must occur in the match, then we build a kwset matcher
   to find those strings, and thus quickly filter out impossible
   matches. */
static void
kwsmusts (void)
{
  struct dfamust const *dm;
  char const *err;

  if (dfa.musts)
    {
      kwsinit ();
      /* First, we compile in the substrings known to be exact
	 matches.  The kwset matcher will return the index
	 of the matching string that it chooses. */
      for (dm = dfa.musts; dm; dm = dm->next)
	{
	  if (!dm->exact)
	    continue;
	  ++kwset_exact_matches;
	  if ((err = kwsincr_case (dm->must)) != NULL)
	    error (EXIT_TROUBLE, 0, "%s", err);
	}
      /* Now, we compile the substrings that will require
	 the use of the regexp matcher.  */
      for (dm = dfa.musts; dm; dm = dm->next)
	{
	  if (dm->exact)
	    continue;
	  if ((err = kwsincr_case (dm->must)) != NULL)
	    error (EXIT_TROUBLE, 0, "%s", err);
	}
      if ((err = kwsprep (kwset)) != NULL)
	error (EXIT_TROUBLE, 0, "%s", err);
    }
}
#endif /* !FGREP_PROGRAM */

#ifdef MBS_SUPPORT

static bool
is_mb_middle(const char **good, const char *buf, const char *end)
{
  const char *p = *good;
  const char *prev = p;
  mbstate_t cur_state;

  /* TODO: can be optimized for UTF-8.  */
  
//Patch 0:
prev = (prev);
memset(&cur_state, 0, sizeof(mbstate_t));

//CodeSeg 1:
  while (p < buf)
    {
      size_t mbclen = mbrlen(p, end - p, &cur_state);

      /* Store the beginning of the previous complete multibyte character.  */
      if (mbclen != (size_t) -2)
        prev = p;

      if (mbclen == (size_t) -1 || mbclen == (size_t) -2 || mbclen == 0)
	{
	  /* An invalid sequence, or a truncated multibyte character.
	     We treat it as a single byte character.  */
	  mbclen = 1;
	}
      p += mbclen;
    }

  *good = prev;
  return p > buf;
}
#endif /* MBS_SUPPORT */

#if defined(GREP_PROGRAM) || defined(EGREP_PROGRAM)
#ifdef EGREP_PROGRAM
COMPILE_FCT(Ecompile)
{
  reg_syntax_t syntax_bits = RE_SYNTAX_POSIX_EGREP;
#else
/* No __VA_ARGS__ in C89.  So we have to do it this way.  */
static COMPILE_RET
GEAcompile (char const *pattern, size_t size, reg_syntax_t syntax_bits)
{
#endif /* EGREP_PROGRAM */
  const char *err;
  const char *p, *sep;
  size_t total = size;
  char *motif;

  if (match_icase)
    syntax_bits |= RE_ICASE;
  re_set_syntax (syntax_bits);
  dfasyntax (syntax_bits, match_icase, eolbyte);

  /* For GNU regex compiler we have to pass the patterns separately to detect
     errors like "[\nallo\n]\n".  The patterns here are "[", "allo" and "]"
     GNU regex should have raise a syntax error.  The same for backref, where
     the backref should have been local to each pattern.  */
  p = pattern;
  do
    {
      size_t len;
      sep = memchr (p, '\n', total);
      if (sep)
	{
	  len = sep - p;
	  sep++;
	  total -= (len + 1);
	}
      else
	{
	  len = total;
	  total = 0;
	}

      patterns = realloc (patterns, (pcount + 1) * sizeof (*patterns));
      if (patterns == NULL)
	error (EXIT_TROUBLE, errno, _("memory exhausted"));
      patterns[pcount] = patterns0;

      if ((err = re_compile_pattern (p, len,
				    &(patterns[pcount].regexbuf))) != NULL)
	error (EXIT_TROUBLE, 0, "%s", err);
      pcount++;

      p = sep;
    } while (sep && total != 0);

  /* In the match_words and match_lines cases, we use a different pattern
     for the DFA matcher that will quickly throw out cases that won't work.
     Then if DFA succeeds we do some hairy stuff using the regex matcher
     to decide whether the match should really count. */
  if (match_words || match_lines)
    {
      static char const line_beg_no_bk[] = "^(";
      static char const line_end_no_bk[] = ")$";
      static char const word_beg_no_bk[] = "(^|[^[:alnum:]_])(";
      static char const word_end_no_bk[] = ")([^[:alnum:]_]|$)";
#ifdef EGREP_PROGRAM
# define IF_BK(x, y) (y)
      char *n = xmalloc (sizeof word_beg_no_bk - 1 + size + sizeof word_end_no_bk);
#else
      static char const line_beg_bk[] = "^\\(";
      static char const line_end_bk[] = "\\)$";
      static char const word_beg_bk[] = "\\(^\\|[^[:alnum:]_]\\)\\(";
      static char const word_end_bk[] = "\\)\\([^[:alnum:]_]\\|$\\)";
      int bk = !(syntax_bits & RE_NO_BK_PARENS);
# define IF_BK(x, y) ((bk) ? (x) : (y))
      char *n = xmalloc (sizeof word_beg_bk - 1 + size + sizeof word_end_bk);
#endif /* EGREP_PROGRAM */

      strcpy (n, match_lines ? IF_BK(line_beg_bk, line_beg_no_bk)
			     : IF_BK(word_beg_bk, word_beg_no_bk));
      total = strlen(n);
      memcpy (n + total, pattern, size);
      total += size;
      strcpy (n + total, match_lines ? IF_BK(line_end_bk, line_end_no_bk)
				     : IF_BK(word_end_bk, word_end_no_bk));
      total += strlen (n + total);
      pattern = motif = n;
      size = total;
    }
  else
    motif = NULL;

  dfacomp (pattern, size, &dfa, 1);
  kwsmusts ();

  free(motif);
}

#ifndef EGREP_PROGRAM
COMPILE_FCT(Gcompile)
{
  return GEAcompile (pattern, size,
		     RE_SYNTAX_GREP | RE_HAT_LISTS_NOT_NEWLINE);
}

COMPILE_FCT(Acompile)
{
  return GEAcompile (pattern, size, RE_SYNTAX_AWK);
}

COMPILE_FCT(Ecompile)
{
  return GEAcompile (pattern, size, RE_SYNTAX_POSIX_EGREP);
}
#endif /* !EGREP_PROGRAM */

EXECUTE_FCT(EGexecute)
{
  char const *buflim, *beg, *end, *match, *best_match, *mb_start;
  char eol = eolbyte;
  int backref, start, len, best_len;
  struct kwsmatch kwsm;
  size_t i, ret_val;
#ifdef MBS_SUPPORT
  if (MB_CUR_MAX > 1)
    {
      if (match_icase)
        {
          /* mbtolower adds a NUL byte at the end.  That will provide
	     space for the sentinel byte dfaexec may add.  */
          char *case_buf = mbtolower (buf, &size);
	  if (start_ptr)
	    start_ptr = case_buf + (start_ptr - buf);
          buf = case_buf;
        }
    }
#endif /* MBS_SUPPORT */

  mb_start = buf;
  buflim = buf + size;

  for (beg = end = buf; end < buflim; beg = end)
    {
      if (!start_ptr)
	{
	  /* We don't care about an exact match.  */
	  if (kwset)
	    {
	      /* Find a possible match using the KWset matcher. */
	      size_t offset = kwsexec (kwset, beg, buflim - beg, &kwsm);
	      if (offset == (size_t) -1)
		goto failure;
	      beg += offset;
	      /* Narrow down to the line containing the candidate, and
		 run it through DFA. */
	      if ((end = memchr(beg, eol, buflim - beg)) != NULL)
	        end++;
              else
                end = buflim;
	      match = beg;
	      while (beg > buf && beg[-1] != eol)
		--beg;
	      if (kwsm.index < kwset_exact_matches)
                {
#ifdef MBS_SUPPORT
                  if (mb_start < beg)
                    mb_start = beg;
                  if (MB_CUR_MAX == 1 || !is_mb_middle (&mb_start, match, buflim))
#endif
                    goto success;
                }
	      if (dfaexec (&dfa, beg, (char *) end, 0, NULL, &backref) == NULL)
		continue;
	    }
	  else
	    {
	      /* No good fixed strings; start with DFA. */
	      char const *next_beg = dfaexec (&dfa, beg, (char *) buflim,
					      0, NULL, &backref);
	      if (next_beg == NULL)
		break;
	      /* Narrow down to the line we've found. */
	      beg = next_beg;
	      if ((end = memchr(beg, eol, buflim - beg)) != NULL)
	        end++;
              else
                end = buflim;
	      while (beg > buf && beg[-1] != eol)
		--beg;
	    }
	  /* Successful, no backreferences encountered! */
	  if (!backref)
	    goto success;
	}
      else
	{
	  /* We are looking for the leftmost (then longest) exact match.
	     We will go through the outer loop only once.  */
	  beg = start_ptr;
	  end = buflim;
	}

      /* If we've made it to this point, this means DFA has seen
	 a probable match, and we need to run it through Regex. */
      best_match = end;
      best_len = 0;
      for (i = 0; i < pcount; i++)
	{
	  patterns[i].regexbuf.not_eol = 0;
	  if (0 <= (start = re_search (&(patterns[i].regexbuf),
				       buf, end - buf - 1,
				       beg - buf, end - beg - 1,
				       &(patterns[i].regs))))
	    {
	      len = patterns[i].regs.end[0] - start;
	      match = buf + start;
	      if (match > best_match)
		continue;
	      if (start_ptr && !match_words)
		goto assess_pattern_match;
	      if ((!match_lines && !match_words)
		  || (match_lines && len == end - beg - 1))
		{
		  match = beg;
		  len = end - beg;
		  goto assess_pattern_match;
		}
	      /* If -w, check if the match aligns with word boundaries.
		 We do this iteratively because:
		 (a) the line may contain more than one occurence of the
		 pattern, and
		 (b) Several alternatives in the pattern might be valid at a
		 given point, and we may need to consider a shorter one to
		 find a word boundary.  */
	      if (match_words)
		while (match <= best_match)
		  {
		    if ((match == buf || !WCHAR ((unsigned char) match[-1]))
			&& (len == end - beg - 1
			    || !WCHAR ((unsigned char) match[len])))
		      goto assess_pattern_match;
		    if (len > 0)
		      {
			/* Try a shorter length anchored at the same place. */
			--len;
			patterns[i].regexbuf.not_eol = 1;
			len = re_match (&(patterns[i].regexbuf),
					buf, match + len - beg, match - buf,
					&(patterns[i].regs));
		      }
		    if (len <= 0)
		      {
			/* Try looking further on. */
			if (match == end - 1)
			  break;
			match++;
			patterns[i].regexbuf.not_eol = 0;
			start = re_search (&(patterns[i].regexbuf),
					   buf, end - buf - 1,
					   match - buf, end - match - 1,
					   &(patterns[i].regs));
			if (start < 0)
			  break;
			len = patterns[i].regs.end[0] - start;
			match = buf + start;
		      }
		  } /* while (match <= best_match) */
	      continue;
	    assess_pattern_match:
	      if (!start_ptr)
		{
		  /* Good enough for a non-exact match.
		     No need to look at further patterns, if any.  */
		  beg = match;
		  goto success_in_len;
		}
	      if (match < best_match || (match == best_match && len > best_len))
		{
		  /* Best exact match:  leftmost, then longest.  */
		  best_match = match;
		  best_len = len;
		}
	    } /* if re_search >= 0 */
	} /* for Regex patterns.  */
	if (best_match < end)
	  {
	    /* We have found an exact match.  We were just
	       waiting for the best one (leftmost then longest).  */
	    beg = best_match;
	    len = best_len;
	    goto success_in_len;
	  }
    } /* for (beg = end ..) */

 failure:
  ret_val = -1;
  goto out;

 success:
  len = end - beg;
 success_in_len:
  *match_size = len;
  ret_val = beg - buf;
 out:
  return ret_val;
}
#endif /* defined(GREP_PROGRAM) || defined(EGREP_PROGRAM) */

#if defined(GREP_PROGRAM) || defined(FGREP_PROGRAM)
COMPILE_FCT(Fcompile)
{
  char const *beg, *end, *lim, *err, *pat;
  size_t psize;

  kwsinit ();
  psize = size;
  if (match_icase && MB_CUR_MAX > 1)
    pat = mbtolower (pattern, &psize);
  else
    pat = pattern;

  beg = pat;
  do
    {
      for (lim = beg;; ++lim)
	{
	  end = lim;
	  if (lim >= pat + psize)
	    break;
	 if (*lim == '\n')
	   {
	     lim++;
	     break;
	   }
#if HAVE_DOS_FILE_CONTENTS
	 if (*lim == '\r' && lim + 1 < pat + psize && lim[1] == '\n')
	   {
	     lim += 2;
	     break;
	   }
#endif
	}

      if ((err = kwsincr (kwset, beg, end - beg)) != NULL)
	error (EXIT_TROUBLE, 0, "%s", err);
      beg = lim;
    }
  while (beg < pat + psize);

  if ((err = kwsprep (kwset)) != NULL)
    error (EXIT_TROUBLE, 0, "%s", err);
}

EXECUTE_FCT(Fexecute)
{
  char const *beg, *try, *end, *mb_start;
  size_t len;
  char eol = eolbyte;
  struct kwsmatch kwsmatch;
  size_t ret_val;
#ifdef MBS_SUPPORT
  if (MB_CUR_MAX > 1)
    {
      if (match_icase)
        {
          char *case_buf = mbtolower (buf, &size);
	  if (start_ptr)
	    start_ptr = case_buf + (start_ptr - buf);
          buf = case_buf;
        }
    }
#endif /* MBS_SUPPORT */

  for (mb_start = beg = start_ptr ? start_ptr : buf; beg <= buf + size; beg++)
    {
      size_t offset = kwsexec (kwset, beg, buf + size - beg, &kwsmatch);
      if (offset == (size_t) -1)
	goto failure;
#ifdef MBS_SUPPORT
      if (MB_CUR_MAX > 1 && is_mb_middle (&mb_start, beg + offset, buf + size))
        {
          beg = mb_start - 1;
          continue; /* It is a part of multibyte character.  */
        }
#endif /* MBS_SUPPORT */
      beg += offset;
      len = kwsmatch.size[0];
      if (start_ptr && !match_words)
	goto success_in_beg_and_len;
      if (match_lines)
	{
	  if (beg > buf && beg[-1] != eol)
	    continue;
	  if (beg + len < buf + size && beg[len] != eol)
	    continue;
	  goto success;
	}
      else if (match_words)
	for (try = beg; len; )
	  {
	    if (try > buf && WCHAR((unsigned char) try[-1]))
	      break;
	    if (try + len < buf + size && WCHAR((unsigned char) try[len]))
	      {
		offset = kwsexec (kwset, beg, --len, &kwsmatch);
		if (offset == (size_t) -1)
		  break;
		try = beg + offset;
		len = kwsmatch.size[0];
	      }
	    else if (!start_ptr)
	      goto success;
	    else
	      goto success_in_beg_and_len;
	  } /* for (try) */
      else
	goto success;
    } /* for (beg in buf) */

 failure:
  ret_val = -1;
  goto out;

 success:
  if ((end = memchr (beg + len, eol, (buf + size) - (beg + len))) != NULL)
    end++;
  else
    end = buf + size;
  while (buf < beg && beg[-1] != eol)
    --beg;
  len = end - beg;
 success_in_beg_and_len:
  *match_size = len;
  ret_val = beg - buf;
 out:
  return ret_val;
}
#endif /* defined(GREP_PROGRAM) || defined(FGREP_PROGRAM) */

#ifdef GREP_PROGRAM
#if HAVE_LIBPCRE
/* Compiled internal form of a Perl regular expression.  */
static pcre *cre;

/* Additional information about the pattern.  */
static pcre_extra *extra;
#endif

COMPILE_FCT(Pcompile)
{
#if !HAVE_LIBPCRE
  error (EXIT_TROUBLE, 0, "%s",
	 _("support for the -P option is not compiled into "
	   "this --disable-perl-regexp binary"));
#else
  int e;
  char const *ep;
  char *re = xmalloc (4 * size + 7);
  int flags = PCRE_MULTILINE | (match_icase ? PCRE_CASELESS : 0);
  char const *patlim = pattern + size;
  char *n = re;
  char const *p;
  char const *pnul;

  /* FIXME: Remove these restrictions.  */
  if (memchr(pattern, '\n', size))
    error (EXIT_TROUBLE, 0, _("the -P option only supports a single pattern"));

  *n = '\0';
  if (match_lines)
    strcpy (n, "^(");
  if (match_words)
    strcpy (n, "\\b(");
  n += strlen (n);

  /* The PCRE interface doesn't allow NUL bytes in the pattern, so
     replace each NUL byte in the pattern with the four characters
     "\000", removing a preceding backslash if there are an odd
     number of backslashes before the NUL.

     FIXME: This method does not work with some multibyte character
     encodings, notably Shift-JIS, where a multibyte character can end
     in a backslash byte.  */
  for (p = pattern; (pnul = memchr (p, '\0', patlim - p)); p = pnul + 1)
    {
      memcpy (n, p, pnul - p);
      n += pnul - p;
      for (p = pnul; pattern < p && p[-1] == '\\'; p--)
	continue;
      n -= (pnul - p) & 1;
      strcpy (n, "\\000");
      n += 4;
    }

  memcpy (n, p, patlim - p);
  n += patlim - p;
  *n = '\0';
  if (match_words)
    strcpy (n, ")\\b");
  if (match_lines)
    strcpy (n, ")$");

  cre = pcre_compile (re, flags, &ep, &e, pcre_maketables ());
  if (!cre)
    error (EXIT_TROUBLE, 0, "%s", ep);

  extra = pcre_study (cre, 0, &ep);
  if (ep)
    error (EXIT_TROUBLE, 0, "%s", ep);

  free (re);
#endif
}

EXECUTE_FCT(Pexecute)
{
#if !HAVE_LIBPCRE
  abort ();
  return -1;
#else
  /* This array must have at least two elements; everything after that
     is just for performance improvement in pcre_exec.  */
  int sub[300];

  const char *line_buf, *line_end, *line_next;
  int e = PCRE_ERROR_NOMATCH;
  ptrdiff_t start_ofs = start_ptr ? start_ptr - buf : 0;

  /* PCRE can't limit the matching to single lines, therefore we have to
     match each line in the buffer separately.  */
  for (line_next = buf;
       e == PCRE_ERROR_NOMATCH && line_next < buf + size;
       start_ofs -= line_next - line_buf)
    {
      line_buf = line_next;
      line_end = memchr (line_buf, eolbyte, (buf + size) - line_buf);
      if (line_end == NULL)
        line_next = line_end = buf + size;
      else
        line_next = line_end + 1;

      if (start_ptr && start_ptr >= line_end)
        continue;

      e = pcre_exec (cre, extra, line_buf, line_end - line_buf,
                     start_ofs < 0 ? 0 : start_ofs, 0,
                     sub, sizeof sub / sizeof *sub);
    }

  if (e <= 0)
    {
      switch (e)
	{
	case PCRE_ERROR_NOMATCH:
	  return -1;

	case PCRE_ERROR_NOMEMORY:
	  error (EXIT_TROUBLE, 0, _("memory exhausted"));

	default:
	  abort ();
	}
    }
  else
    {
      /* Narrow down to the line we've found.  */
      char const *beg = line_buf + sub[0];
      char const *end = line_buf + sub[1];
      char const *buflim = buf + size;
      char eol = eolbyte;
      if (!start_ptr)
	{
	  /* FIXME: The case when '\n' is not found indicates a bug:
	     Since grep is line oriented, the match should never contain
	     a newline, so there _must_ be a newline following.
	   */
	  if (!(end = memchr (end, eol, buflim - end)))
	    end = buflim;
	  else
	    end++;
	  while (buf < beg && beg[-1] != eol)
	    --beg;
	}

      *match_size = end - beg;
      return beg - buf;
    }
#endif
}

struct matcher const matchers[] = {
  { "default", Gcompile, EGexecute },
  { "grep",    Gcompile, EGexecute },
  { "egrep",   Ecompile, EGexecute },
  { "awk",     Acompile, EGexecute },
  { "fgrep",   Fcompile, Fexecute },
  { "perl",    Pcompile, Pexecute },
  { "", 0, 0 },
};
#endif /* GREP_PROGRAM */

Spawn 1 instances, now Total 33
Counter: 34
Batcher Size:33
Preprocess the following candidate with BasicTester:
Priority 7489
At location src/search.c:237
--Src File: src/search.c
Fragment 0:
prev = p;
memset(&cur_state, 0, sizeof(mbstate_t));


BasicTester, a patch instance with id 4:
//src_file:src/search.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
/* search.c - searching subroutines using dfa, kwset and regex for grep.
   Copyright 1992, 1998, 2000, 2007, 2009-2010 Free Software Foundation, Inc.

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 3, or (at your option)
   any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program; if not, write to the Free Software
   Foundation, Inc., 51 Franklin Street - Fifth Floor, Boston, MA
   02110-1301, USA.  */

/* Written August 1992 by Mike Haertel. */

#include <config.h>

#include <sys/types.h>

#include "mbsupport.h"
#ifdef MBS_SUPPORT
/* We can handle multibyte strings. */
# include <wchar.h>
# include <wctype.h>
#endif

#include "system.h"
#include "grep.h"
#ifndef FGREP_PROGRAM
# include <regex.h>
# include "dfa.h"
#endif
#include "kwset.h"
#include "error.h"
#include "xalloc.h"
#ifdef HAVE_LIBPCRE
# include <pcre.h>
#endif

#define NCHAR (UCHAR_MAX + 1)

/* For -w, we also consider _ to be word constituent.  */
#define WCHAR(C) (ISALNUM(C) || (C) == '_')

/* KWset compiled pattern.  For Ecompile and Gcompile, we compile
   a list of strings, at least one of which is known to occur in
   any string matching the regexp. */
static kwset_t kwset;

static void
kwsinit (void)
{
  static char trans[NCHAR];
  int i;

  if (match_icase && MB_CUR_MAX == 1)
    {
      for (i = 0; i < NCHAR; ++i)
        trans[i] = TOLOWER (i);

      kwset = kwsalloc (trans);
    }
  else
    kwset = kwsalloc (NULL);

  if (!kwset)
    xalloc_die ();
}

#ifdef MBS_SUPPORT
/* Convert the *N-byte string, BEG, to lowercase, and write the
   NUL-terminated result into malloc'd storage.  Upon success, set *N
   to the length (in bytes) of the resulting string (not including the
   trailing NUL byte), and return a pointer to the lowercase string.
   Upon memory allocation failure, this function exits.

   Note that while this function returns a pointer to malloc'd storage,
   the caller must not free it, since this function retains a pointer
   to the buffer and reuses it on any subsequent call.  As a consequence,
   this function is not thread-safe.  */
static char *
mbtolower (const char *beg, size_t *n)
{
  static char *out;
  static size_t outalloc;
  size_t outlen, mb_cur_max;
  mbstate_t is, os;
  const char *end;
  char *p;

  if (*n > outalloc)
    {
      out = xrealloc (out, *n);
      outalloc = *n;
    }

  memset (&is, 0, sizeof (is));
  memset (&os, 0, sizeof (os));
  end = beg + *n;

  mb_cur_max = MB_CUR_MAX;
  p = out;
  outlen = 0;
  while (beg < end)
    {
      wchar_t wc;
      size_t mbclen = mbrtowc(&wc, beg, end - beg, &is);
      if (outlen + mb_cur_max >= outalloc)
        {
          out = x2nrealloc (out, &outalloc, 1);
          p = out + outlen;
        }

      if (mbclen == (size_t) -1 || mbclen == (size_t) -2 || mbclen == 0)
        {
          /* An invalid sequence, or a truncated multi-octet character.
             We treat it as a single-octet character.  */
          *p++ = *beg++;
          outlen++;
          memset (&is, 0, sizeof (is));
          memset (&os, 0, sizeof (os));
        }
      else
        {
          beg += mbclen;
          mbclen = wcrtomb (p, towlower ((wint_t) wc), &os);
          p += mbclen;
          outlen += mbclen;
        }
    }

  *n = p - out;
  *p++ = 0;
  return out;
}
#endif


#ifndef FGREP_PROGRAM
/* DFA compiled regexp. */
static struct dfa dfa;

/* The Regex compiled patterns.  */
static struct patterns
{
  /* Regex compiled regexp. */
  struct re_pattern_buffer regexbuf;
  struct re_registers regs; /* This is here on account of a BRAIN-DEAD
			       Q@#%!# library interface in regex.c.  */
} patterns0;

struct patterns *patterns;
size_t pcount;

void
dfaerror (char const *mesg)
{
  error (EXIT_TROUBLE, 0, "%s", mesg);
}

/* Number of compiled fixed strings known to exactly match the regexp.
   If kwsexec returns < kwset_exact_matches, then we don't need to
   call the regexp matcher at all. */
static int kwset_exact_matches;

static char const *
kwsincr_case (const char *must)
{
  const char *buf;
  size_t n;

  n = strlen (must);
#ifdef MBS_SUPPORT
  if (match_icase && MB_CUR_MAX > 1)
    buf = mbtolower (must, &n);
  else
#endif
    buf = must;
  return kwsincr (kwset, buf, n);
}

/* If the DFA turns out to have some set of fixed strings one of
   which must occur in the match, then we build a kwset matcher
   to find those strings, and thus quickly filter out impossible
   matches. */
static void
kwsmusts (void)
{
  struct dfamust const *dm;
  char const *err;

  if (dfa.musts)
    {
      kwsinit ();
      /* First, we compile in the substrings known to be exact
	 matches.  The kwset matcher will return the index
	 of the matching string that it chooses. */
      for (dm = dfa.musts; dm; dm = dm->next)
	{
	  if (!dm->exact)
	    continue;
	  ++kwset_exact_matches;
	  if ((err = kwsincr_case (dm->must)) != NULL)
	    error (EXIT_TROUBLE, 0, "%s", err);
	}
      /* Now, we compile the substrings that will require
	 the use of the regexp matcher.  */
      for (dm = dfa.musts; dm; dm = dm->next)
	{
	  if (dm->exact)
	    continue;
	  if ((err = kwsincr_case (dm->must)) != NULL)
	    error (EXIT_TROUBLE, 0, "%s", err);
	}
      if ((err = kwsprep (kwset)) != NULL)
	error (EXIT_TROUBLE, 0, "%s", err);
    }
}
#endif /* !FGREP_PROGRAM */

#ifdef MBS_SUPPORT

static bool
is_mb_middle(const char **good, const char *buf, const char *end)
{
  const char *p = *good;
  const char *prev = p;
  mbstate_t cur_state;

  /* TODO: can be optimized for UTF-8.  */
  
//Patch 0:
prev = p;
memset(&cur_state, 0, sizeof(mbstate_t));

//CodeSeg 1:
  while (p < buf)
    {
      size_t mbclen = mbrlen(p, end - p, &cur_state);

      /* Store the beginning of the previous complete multibyte character.  */
      if (mbclen != (size_t) -2)
        prev = p;

      if (mbclen == (size_t) -1 || mbclen == (size_t) -2 || mbclen == 0)
	{
	  /* An invalid sequence, or a truncated multibyte character.
	     We treat it as a single byte character.  */
	  mbclen = 1;
	}
      p += mbclen;
    }

  *good = prev;
  return p > buf;
}
#endif /* MBS_SUPPORT */

#if defined(GREP_PROGRAM) || defined(EGREP_PROGRAM)
#ifdef EGREP_PROGRAM
COMPILE_FCT(Ecompile)
{
  reg_syntax_t syntax_bits = RE_SYNTAX_POSIX_EGREP;
#else
/* No __VA_ARGS__ in C89.  So we have to do it this way.  */
static COMPILE_RET
GEAcompile (char const *pattern, size_t size, reg_syntax_t syntax_bits)
{
#endif /* EGREP_PROGRAM */
  const char *err;
  const char *p, *sep;
  size_t total = size;
  char *motif;

  if (match_icase)
    syntax_bits |= RE_ICASE;
  re_set_syntax (syntax_bits);
  dfasyntax (syntax_bits, match_icase, eolbyte);

  /* For GNU regex compiler we have to pass the patterns separately to detect
     errors like "[\nallo\n]\n".  The patterns here are "[", "allo" and "]"
     GNU regex should have raise a syntax error.  The same for backref, where
     the backref should have been local to each pattern.  */
  p = pattern;
  do
    {
      size_t len;
      sep = memchr (p, '\n', total);
      if (sep)
	{
	  len = sep - p;
	  sep++;
	  total -= (len + 1);
	}
      else
	{
	  len = total;
	  total = 0;
	}

      patterns = realloc (patterns, (pcount + 1) * sizeof (*patterns));
      if (patterns == NULL)
	error (EXIT_TROUBLE, errno, _("memory exhausted"));
      patterns[pcount] = patterns0;

      if ((err = re_compile_pattern (p, len,
				    &(patterns[pcount].regexbuf))) != NULL)
	error (EXIT_TROUBLE, 0, "%s", err);
      pcount++;

      p = sep;
    } while (sep && total != 0);

  /* In the match_words and match_lines cases, we use a different pattern
     for the DFA matcher that will quickly throw out cases that won't work.
     Then if DFA succeeds we do some hairy stuff using the regex matcher
     to decide whether the match should really count. */
  if (match_words || match_lines)
    {
      static char const line_beg_no_bk[] = "^(";
      static char const line_end_no_bk[] = ")$";
      static char const word_beg_no_bk[] = "(^|[^[:alnum:]_])(";
      static char const word_end_no_bk[] = ")([^[:alnum:]_]|$)";
#ifdef EGREP_PROGRAM
# define IF_BK(x, y) (y)
      char *n = xmalloc (sizeof word_beg_no_bk - 1 + size + sizeof word_end_no_bk);
#else
      static char const line_beg_bk[] = "^\\(";
      static char const line_end_bk[] = "\\)$";
      static char const word_beg_bk[] = "\\(^\\|[^[:alnum:]_]\\)\\(";
      static char const word_end_bk[] = "\\)\\([^[:alnum:]_]\\|$\\)";
      int bk = !(syntax_bits & RE_NO_BK_PARENS);
# define IF_BK(x, y) ((bk) ? (x) : (y))
      char *n = xmalloc (sizeof word_beg_bk - 1 + size + sizeof word_end_bk);
#endif /* EGREP_PROGRAM */

      strcpy (n, match_lines ? IF_BK(line_beg_bk, line_beg_no_bk)
			     : IF_BK(word_beg_bk, word_beg_no_bk));
      total = strlen(n);
      memcpy (n + total, pattern, size);
      total += size;
      strcpy (n + total, match_lines ? IF_BK(line_end_bk, line_end_no_bk)
				     : IF_BK(word_end_bk, word_end_no_bk));
      total += strlen (n + total);
      pattern = motif = n;
      size = total;
    }
  else
    motif = NULL;

  dfacomp (pattern, size, &dfa, 1);
  kwsmusts ();

  free(motif);
}

#ifndef EGREP_PROGRAM
COMPILE_FCT(Gcompile)
{
  return GEAcompile (pattern, size,
		     RE_SYNTAX_GREP | RE_HAT_LISTS_NOT_NEWLINE);
}

COMPILE_FCT(Acompile)
{
  return GEAcompile (pattern, size, RE_SYNTAX_AWK);
}

COMPILE_FCT(Ecompile)
{
  return GEAcompile (pattern, size, RE_SYNTAX_POSIX_EGREP);
}
#endif /* !EGREP_PROGRAM */

EXECUTE_FCT(EGexecute)
{
  char const *buflim, *beg, *end, *match, *best_match, *mb_start;
  char eol = eolbyte;
  int backref, start, len, best_len;
  struct kwsmatch kwsm;
  size_t i, ret_val;
#ifdef MBS_SUPPORT
  if (MB_CUR_MAX > 1)
    {
      if (match_icase)
        {
          /* mbtolower adds a NUL byte at the end.  That will provide
	     space for the sentinel byte dfaexec may add.  */
          char *case_buf = mbtolower (buf, &size);
	  if (start_ptr)
	    start_ptr = case_buf + (start_ptr - buf);
          buf = case_buf;
        }
    }
#endif /* MBS_SUPPORT */

  mb_start = buf;
  buflim = buf + size;

  for (beg = end = buf; end < buflim; beg = end)
    {
      if (!start_ptr)
	{
	  /* We don't care about an exact match.  */
	  if (kwset)
	    {
	      /* Find a possible match using the KWset matcher. */
	      size_t offset = kwsexec (kwset, beg, buflim - beg, &kwsm);
	      if (offset == (size_t) -1)
		goto failure;
	      beg += offset;
	      /* Narrow down to the line containing the candidate, and
		 run it through DFA. */
	      if ((end = memchr(beg, eol, buflim - beg)) != NULL)
	        end++;
              else
                end = buflim;
	      match = beg;
	      while (beg > buf && beg[-1] != eol)
		--beg;
	      if (kwsm.index < kwset_exact_matches)
                {
#ifdef MBS_SUPPORT
                  if (mb_start < beg)
                    mb_start = beg;
                  if (MB_CUR_MAX == 1 || !is_mb_middle (&mb_start, match, buflim))
#endif
                    goto success;
                }
	      if (dfaexec (&dfa, beg, (char *) end, 0, NULL, &backref) == NULL)
		continue;
	    }
	  else
	    {
	      /* No good fixed strings; start with DFA. */
	      char const *next_beg = dfaexec (&dfa, beg, (char *) buflim,
					      0, NULL, &backref);
	      if (next_beg == NULL)
		break;
	      /* Narrow down to the line we've found. */
	      beg = next_beg;
	      if ((end = memchr(beg, eol, buflim - beg)) != NULL)
	        end++;
              else
                end = buflim;
	      while (beg > buf && beg[-1] != eol)
		--beg;
	    }
	  /* Successful, no backreferences encountered! */
	  if (!backref)
	    goto success;
	}
      else
	{
	  /* We are looking for the leftmost (then longest) exact match.
	     We will go through the outer loop only once.  */
	  beg = start_ptr;
	  end = buflim;
	}

      /* If we've made it to this point, this means DFA has seen
	 a probable match, and we need to run it through Regex. */
      best_match = end;
      best_len = 0;
      for (i = 0; i < pcount; i++)
	{
	  patterns[i].regexbuf.not_eol = 0;
	  if (0 <= (start = re_search (&(patterns[i].regexbuf),
				       buf, end - buf - 1,
				       beg - buf, end - beg - 1,
				       &(patterns[i].regs))))
	    {
	      len = patterns[i].regs.end[0] - start;
	      match = buf + start;
	      if (match > best_match)
		continue;
	      if (start_ptr && !match_words)
		goto assess_pattern_match;
	      if ((!match_lines && !match_words)
		  || (match_lines && len == end - beg - 1))
		{
		  match = beg;
		  len = end - beg;
		  goto assess_pattern_match;
		}
	      /* If -w, check if the match aligns with word boundaries.
		 We do this iteratively because:
		 (a) the line may contain more than one occurence of the
		 pattern, and
		 (b) Several alternatives in the pattern might be valid at a
		 given point, and we may need to consider a shorter one to
		 find a word boundary.  */
	      if (match_words)
		while (match <= best_match)
		  {
		    if ((match == buf || !WCHAR ((unsigned char) match[-1]))
			&& (len == end - beg - 1
			    || !WCHAR ((unsigned char) match[len])))
		      goto assess_pattern_match;
		    if (len > 0)
		      {
			/* Try a shorter length anchored at the same place. */
			--len;
			patterns[i].regexbuf.not_eol = 1;
			len = re_match (&(patterns[i].regexbuf),
					buf, match + len - beg, match - buf,
					&(patterns[i].regs));
		      }
		    if (len <= 0)
		      {
			/* Try looking further on. */
			if (match == end - 1)
			  break;
			match++;
			patterns[i].regexbuf.not_eol = 0;
			start = re_search (&(patterns[i].regexbuf),
					   buf, end - buf - 1,
					   match - buf, end - match - 1,
					   &(patterns[i].regs));
			if (start < 0)
			  break;
			len = patterns[i].regs.end[0] - start;
			match = buf + start;
		      }
		  } /* while (match <= best_match) */
	      continue;
	    assess_pattern_match:
	      if (!start_ptr)
		{
		  /* Good enough for a non-exact match.
		     No need to look at further patterns, if any.  */
		  beg = match;
		  goto success_in_len;
		}
	      if (match < best_match || (match == best_match && len > best_len))
		{
		  /* Best exact match:  leftmost, then longest.  */
		  best_match = match;
		  best_len = len;
		}
	    } /* if re_search >= 0 */
	} /* for Regex patterns.  */
	if (best_match < end)
	  {
	    /* We have found an exact match.  We were just
	       waiting for the best one (leftmost then longest).  */
	    beg = best_match;
	    len = best_len;
	    goto success_in_len;
	  }
    } /* for (beg = end ..) */

 failure:
  ret_val = -1;
  goto out;

 success:
  len = end - beg;
 success_in_len:
  *match_size = len;
  ret_val = beg - buf;
 out:
  return ret_val;
}
#endif /* defined(GREP_PROGRAM) || defined(EGREP_PROGRAM) */

#if defined(GREP_PROGRAM) || defined(FGREP_PROGRAM)
COMPILE_FCT(Fcompile)
{
  char const *beg, *end, *lim, *err, *pat;
  size_t psize;

  kwsinit ();
  psize = size;
  if (match_icase && MB_CUR_MAX > 1)
    pat = mbtolower (pattern, &psize);
  else
    pat = pattern;

  beg = pat;
  do
    {
      for (lim = beg;; ++lim)
	{
	  end = lim;
	  if (lim >= pat + psize)
	    break;
	 if (*lim == '\n')
	   {
	     lim++;
	     break;
	   }
#if HAVE_DOS_FILE_CONTENTS
	 if (*lim == '\r' && lim + 1 < pat + psize && lim[1] == '\n')
	   {
	     lim += 2;
	     break;
	   }
#endif
	}

      if ((err = kwsincr (kwset, beg, end - beg)) != NULL)
	error (EXIT_TROUBLE, 0, "%s", err);
      beg = lim;
    }
  while (beg < pat + psize);

  if ((err = kwsprep (kwset)) != NULL)
    error (EXIT_TROUBLE, 0, "%s", err);
}

EXECUTE_FCT(Fexecute)
{
  char const *beg, *try, *end, *mb_start;
  size_t len;
  char eol = eolbyte;
  struct kwsmatch kwsmatch;
  size_t ret_val;
#ifdef MBS_SUPPORT
  if (MB_CUR_MAX > 1)
    {
      if (match_icase)
        {
          char *case_buf = mbtolower (buf, &size);
	  if (start_ptr)
	    start_ptr = case_buf + (start_ptr - buf);
          buf = case_buf;
        }
    }
#endif /* MBS_SUPPORT */

  for (mb_start = beg = start_ptr ? start_ptr : buf; beg <= buf + size; beg++)
    {
      size_t offset = kwsexec (kwset, beg, buf + size - beg, &kwsmatch);
      if (offset == (size_t) -1)
	goto failure;
#ifdef MBS_SUPPORT
      if (MB_CUR_MAX > 1 && is_mb_middle (&mb_start, beg + offset, buf + size))
        {
          beg = mb_start - 1;
          continue; /* It is a part of multibyte character.  */
        }
#endif /* MBS_SUPPORT */
      beg += offset;
      len = kwsmatch.size[0];
      if (start_ptr && !match_words)
	goto success_in_beg_and_len;
      if (match_lines)
	{
	  if (beg > buf && beg[-1] != eol)
	    continue;
	  if (beg + len < buf + size && beg[len] != eol)
	    continue;
	  goto success;
	}
      else if (match_words)
	for (try = beg; len; )
	  {
	    if (try > buf && WCHAR((unsigned char) try[-1]))
	      break;
	    if (try + len < buf + size && WCHAR((unsigned char) try[len]))
	      {
		offset = kwsexec (kwset, beg, --len, &kwsmatch);
		if (offset == (size_t) -1)
		  break;
		try = beg + offset;
		len = kwsmatch.size[0];
	      }
	    else if (!start_ptr)
	      goto success;
	    else
	      goto success_in_beg_and_len;
	  } /* for (try) */
      else
	goto success;
    } /* for (beg in buf) */

 failure:
  ret_val = -1;
  goto out;

 success:
  if ((end = memchr (beg + len, eol, (buf + size) - (beg + len))) != NULL)
    end++;
  else
    end = buf + size;
  while (buf < beg && beg[-1] != eol)
    --beg;
  len = end - beg;
 success_in_beg_and_len:
  *match_size = len;
  ret_val = beg - buf;
 out:
  return ret_val;
}
#endif /* defined(GREP_PROGRAM) || defined(FGREP_PROGRAM) */

#ifdef GREP_PROGRAM
#if HAVE_LIBPCRE
/* Compiled internal form of a Perl regular expression.  */
static pcre *cre;

/* Additional information about the pattern.  */
static pcre_extra *extra;
#endif

COMPILE_FCT(Pcompile)
{
#if !HAVE_LIBPCRE
  error (EXIT_TROUBLE, 0, "%s",
	 _("support for the -P option is not compiled into "
	   "this --disable-perl-regexp binary"));
#else
  int e;
  char const *ep;
  char *re = xmalloc (4 * size + 7);
  int flags = PCRE_MULTILINE | (match_icase ? PCRE_CASELESS : 0);
  char const *patlim = pattern + size;
  char *n = re;
  char const *p;
  char const *pnul;

  /* FIXME: Remove these restrictions.  */
  if (memchr(pattern, '\n', size))
    error (EXIT_TROUBLE, 0, _("the -P option only supports a single pattern"));

  *n = '\0';
  if (match_lines)
    strcpy (n, "^(");
  if (match_words)
    strcpy (n, "\\b(");
  n += strlen (n);

  /* The PCRE interface doesn't allow NUL bytes in the pattern, so
     replace each NUL byte in the pattern with the four characters
     "\000", removing a preceding backslash if there are an odd
     number of backslashes before the NUL.

     FIXME: This method does not work with some multibyte character
     encodings, notably Shift-JIS, where a multibyte character can end
     in a backslash byte.  */
  for (p = pattern; (pnul = memchr (p, '\0', patlim - p)); p = pnul + 1)
    {
      memcpy (n, p, pnul - p);
      n += pnul - p;
      for (p = pnul; pattern < p && p[-1] == '\\'; p--)
	continue;
      n -= (pnul - p) & 1;
      strcpy (n, "\\000");
      n += 4;
    }

  memcpy (n, p, patlim - p);
  n += patlim - p;
  *n = '\0';
  if (match_words)
    strcpy (n, ")\\b");
  if (match_lines)
    strcpy (n, ")$");

  cre = pcre_compile (re, flags, &ep, &e, pcre_maketables ());
  if (!cre)
    error (EXIT_TROUBLE, 0, "%s", ep);

  extra = pcre_study (cre, 0, &ep);
  if (ep)
    error (EXIT_TROUBLE, 0, "%s", ep);

  free (re);
#endif
}

EXECUTE_FCT(Pexecute)
{
#if !HAVE_LIBPCRE
  abort ();
  return -1;
#else
  /* This array must have at least two elements; everything after that
     is just for performance improvement in pcre_exec.  */
  int sub[300];

  const char *line_buf, *line_end, *line_next;
  int e = PCRE_ERROR_NOMATCH;
  ptrdiff_t start_ofs = start_ptr ? start_ptr - buf : 0;

  /* PCRE can't limit the matching to single lines, therefore we have to
     match each line in the buffer separately.  */
  for (line_next = buf;
       e == PCRE_ERROR_NOMATCH && line_next < buf + size;
       start_ofs -= line_next - line_buf)
    {
      line_buf = line_next;
      line_end = memchr (line_buf, eolbyte, (buf + size) - line_buf);
      if (line_end == NULL)
        line_next = line_end = buf + size;
      else
        line_next = line_end + 1;

      if (start_ptr && start_ptr >= line_end)
        continue;

      e = pcre_exec (cre, extra, line_buf, line_end - line_buf,
                     start_ofs < 0 ? 0 : start_ofs, 0,
                     sub, sizeof sub / sizeof *sub);
    }

  if (e <= 0)
    {
      switch (e)
	{
	case PCRE_ERROR_NOMATCH:
	  return -1;

	case PCRE_ERROR_NOMEMORY:
	  error (EXIT_TROUBLE, 0, _("memory exhausted"));

	default:
	  abort ();
	}
    }
  else
    {
      /* Narrow down to the line we've found.  */
      char const *beg = line_buf + sub[0];
      char const *end = line_buf + sub[1];
      char const *buflim = buf + size;
      char eol = eolbyte;
      if (!start_ptr)
	{
	  /* FIXME: The case when '\n' is not found indicates a bug:
	     Since grep is line oriented, the match should never contain
	     a newline, so there _must_ be a newline following.
	   */
	  if (!(end = memchr (end, eol, buflim - end)))
	    end = buflim;
	  else
	    end++;
	  while (buf < beg && beg[-1] != eol)
	    --beg;
	}

      *match_size = end - beg;
      return beg - buf;
    }
#endif
}

struct matcher const matchers[] = {
  { "default", Gcompile, EGexecute },
  { "grep",    Gcompile, EGexecute },
  { "egrep",   Ecompile, EGexecute },
  { "awk",     Acompile, EGexecute },
  { "fgrep",   Fcompile, Fexecute },
  { "perl",    Pcompile, Pexecute },
  { "", 0, 0 },
};
#endif /* GREP_PROGRAM */

Spawn 1 instances, now Total 34
Counter: 35
Batcher Size:34
Preprocess the following candidate with BasicTester:
Priority 7489
At location src/search.c:237
--Src File: src/search.c
Fragment 0:
kwset = kwsalloc(((void *)0));
memset(&cur_state, 0, sizeof(mbstate_t));


BasicTester, a patch instance with id 5:
//src_file:src/search.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
/* search.c - searching subroutines using dfa, kwset and regex for grep.
   Copyright 1992, 1998, 2000, 2007, 2009-2010 Free Software Foundation, Inc.

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 3, or (at your option)
   any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program; if not, write to the Free Software
   Foundation, Inc., 51 Franklin Street - Fifth Floor, Boston, MA
   02110-1301, USA.  */

/* Written August 1992 by Mike Haertel. */

#include <config.h>

#include <sys/types.h>

#include "mbsupport.h"
#ifdef MBS_SUPPORT
/* We can handle multibyte strings. */
# include <wchar.h>
# include <wctype.h>
#endif

#include "system.h"
#include "grep.h"
#ifndef FGREP_PROGRAM
# include <regex.h>
# include "dfa.h"
#endif
#include "kwset.h"
#include "error.h"
#include "xalloc.h"
#ifdef HAVE_LIBPCRE
# include <pcre.h>
#endif

#define NCHAR (UCHAR_MAX + 1)

/* For -w, we also consider _ to be word constituent.  */
#define WCHAR(C) (ISALNUM(C) || (C) == '_')

/* KWset compiled pattern.  For Ecompile and Gcompile, we compile
   a list of strings, at least one of which is known to occur in
   any string matching the regexp. */
static kwset_t kwset;

static void
kwsinit (void)
{
  static char trans[NCHAR];
  int i;

  if (match_icase && MB_CUR_MAX == 1)
    {
      for (i = 0; i < NCHAR; ++i)
        trans[i] = TOLOWER (i);

      kwset = kwsalloc (trans);
    }
  else
    kwset = kwsalloc (NULL);

  if (!kwset)
    xalloc_die ();
}

#ifdef MBS_SUPPORT
/* Convert the *N-byte string, BEG, to lowercase, and write the
   NUL-terminated result into malloc'd storage.  Upon success, set *N
   to the length (in bytes) of the resulting string (not including the
   trailing NUL byte), and return a pointer to the lowercase string.
   Upon memory allocation failure, this function exits.

   Note that while this function returns a pointer to malloc'd storage,
   the caller must not free it, since this function retains a pointer
   to the buffer and reuses it on any subsequent call.  As a consequence,
   this function is not thread-safe.  */
static char *
mbtolower (const char *beg, size_t *n)
{
  static char *out;
  static size_t outalloc;
  size_t outlen, mb_cur_max;
  mbstate_t is, os;
  const char *end;
  char *p;

  if (*n > outalloc)
    {
      out = xrealloc (out, *n);
      outalloc = *n;
    }

  memset (&is, 0, sizeof (is));
  memset (&os, 0, sizeof (os));
  end = beg + *n;

  mb_cur_max = MB_CUR_MAX;
  p = out;
  outlen = 0;
  while (beg < end)
    {
      wchar_t wc;
      size_t mbclen = mbrtowc(&wc, beg, end - beg, &is);
      if (outlen + mb_cur_max >= outalloc)
        {
          out = x2nrealloc (out, &outalloc, 1);
          p = out + outlen;
        }

      if (mbclen == (size_t) -1 || mbclen == (size_t) -2 || mbclen == 0)
        {
          /* An invalid sequence, or a truncated multi-octet character.
             We treat it as a single-octet character.  */
          *p++ = *beg++;
          outlen++;
          memset (&is, 0, sizeof (is));
          memset (&os, 0, sizeof (os));
        }
      else
        {
          beg += mbclen;
          mbclen = wcrtomb (p, towlower ((wint_t) wc), &os);
          p += mbclen;
          outlen += mbclen;
        }
    }

  *n = p - out;
  *p++ = 0;
  return out;
}
#endif


#ifndef FGREP_PROGRAM
/* DFA compiled regexp. */
static struct dfa dfa;

/* The Regex compiled patterns.  */
static struct patterns
{
  /* Regex compiled regexp. */
  struct re_pattern_buffer regexbuf;
  struct re_registers regs; /* This is here on account of a BRAIN-DEAD
			       Q@#%!# library interface in regex.c.  */
} patterns0;

struct patterns *patterns;
size_t pcount;

void
dfaerror (char const *mesg)
{
  error (EXIT_TROUBLE, 0, "%s", mesg);
}

/* Number of compiled fixed strings known to exactly match the regexp.
   If kwsexec returns < kwset_exact_matches, then we don't need to
   call the regexp matcher at all. */
static int kwset_exact_matches;

static char const *
kwsincr_case (const char *must)
{
  const char *buf;
  size_t n;

  n = strlen (must);
#ifdef MBS_SUPPORT
  if (match_icase && MB_CUR_MAX > 1)
    buf = mbtolower (must, &n);
  else
#endif
    buf = must;
  return kwsincr (kwset, buf, n);
}

/* If the DFA turns out to have some set of fixed strings one of
   which must occur in the match, then we build a kwset matcher
   to find those strings, and thus quickly filter out impossible
   matches. */
static void
kwsmusts (void)
{
  struct dfamust const *dm;
  char const *err;

  if (dfa.musts)
    {
      kwsinit ();
      /* First, we compile in the substrings known to be exact
	 matches.  The kwset matcher will return the index
	 of the matching string that it chooses. */
      for (dm = dfa.musts; dm; dm = dm->next)
	{
	  if (!dm->exact)
	    continue;
	  ++kwset_exact_matches;
	  if ((err = kwsincr_case (dm->must)) != NULL)
	    error (EXIT_TROUBLE, 0, "%s", err);
	}
      /* Now, we compile the substrings that will require
	 the use of the regexp matcher.  */
      for (dm = dfa.musts; dm; dm = dm->next)
	{
	  if (dm->exact)
	    continue;
	  if ((err = kwsincr_case (dm->must)) != NULL)
	    error (EXIT_TROUBLE, 0, "%s", err);
	}
      if ((err = kwsprep (kwset)) != NULL)
	error (EXIT_TROUBLE, 0, "%s", err);
    }
}
#endif /* !FGREP_PROGRAM */

#ifdef MBS_SUPPORT

static bool
is_mb_middle(const char **good, const char *buf, const char *end)
{
  const char *p = *good;
  const char *prev = p;
  mbstate_t cur_state;

  /* TODO: can be optimized for UTF-8.  */
  
//Patch 0:
kwset = kwsalloc(((void *)0));
memset(&cur_state, 0, sizeof(mbstate_t));

//CodeSeg 1:
  while (p < buf)
    {
      size_t mbclen = mbrlen(p, end - p, &cur_state);

      /* Store the beginning of the previous complete multibyte character.  */
      if (mbclen != (size_t) -2)
        prev = p;

      if (mbclen == (size_t) -1 || mbclen == (size_t) -2 || mbclen == 0)
	{
	  /* An invalid sequence, or a truncated multibyte character.
	     We treat it as a single byte character.  */
	  mbclen = 1;
	}
      p += mbclen;
    }

  *good = prev;
  return p > buf;
}
#endif /* MBS_SUPPORT */

#if defined(GREP_PROGRAM) || defined(EGREP_PROGRAM)
#ifdef EGREP_PROGRAM
COMPILE_FCT(Ecompile)
{
  reg_syntax_t syntax_bits = RE_SYNTAX_POSIX_EGREP;
#else
/* No __VA_ARGS__ in C89.  So we have to do it this way.  */
static COMPILE_RET
GEAcompile (char const *pattern, size_t size, reg_syntax_t syntax_bits)
{
#endif /* EGREP_PROGRAM */
  const char *err;
  const char *p, *sep;
  size_t total = size;
  char *motif;

  if (match_icase)
    syntax_bits |= RE_ICASE;
  re_set_syntax (syntax_bits);
  dfasyntax (syntax_bits, match_icase, eolbyte);

  /* For GNU regex compiler we have to pass the patterns separately to detect
     errors like "[\nallo\n]\n".  The patterns here are "[", "allo" and "]"
     GNU regex should have raise a syntax error.  The same for backref, where
     the backref should have been local to each pattern.  */
  p = pattern;
  do
    {
      size_t len;
      sep = memchr (p, '\n', total);
      if (sep)
	{
	  len = sep - p;
	  sep++;
	  total -= (len + 1);
	}
      else
	{
	  len = total;
	  total = 0;
	}

      patterns = realloc (patterns, (pcount + 1) * sizeof (*patterns));
      if (patterns == NULL)
	error (EXIT_TROUBLE, errno, _("memory exhausted"));
      patterns[pcount] = patterns0;

      if ((err = re_compile_pattern (p, len,
				    &(patterns[pcount].regexbuf))) != NULL)
	error (EXIT_TROUBLE, 0, "%s", err);
      pcount++;

      p = sep;
    } while (sep && total != 0);

  /* In the match_words and match_lines cases, we use a different pattern
     for the DFA matcher that will quickly throw out cases that won't work.
     Then if DFA succeeds we do some hairy stuff using the regex matcher
     to decide whether the match should really count. */
  if (match_words || match_lines)
    {
      static char const line_beg_no_bk[] = "^(";
      static char const line_end_no_bk[] = ")$";
      static char const word_beg_no_bk[] = "(^|[^[:alnum:]_])(";
      static char const word_end_no_bk[] = ")([^[:alnum:]_]|$)";
#ifdef EGREP_PROGRAM
# define IF_BK(x, y) (y)
      char *n = xmalloc (sizeof word_beg_no_bk - 1 + size + sizeof word_end_no_bk);
#else
      static char const line_beg_bk[] = "^\\(";
      static char const line_end_bk[] = "\\)$";
      static char const word_beg_bk[] = "\\(^\\|[^[:alnum:]_]\\)\\(";
      static char const word_end_bk[] = "\\)\\([^[:alnum:]_]\\|$\\)";
      int bk = !(syntax_bits & RE_NO_BK_PARENS);
# define IF_BK(x, y) ((bk) ? (x) : (y))
      char *n = xmalloc (sizeof word_beg_bk - 1 + size + sizeof word_end_bk);
#endif /* EGREP_PROGRAM */

      strcpy (n, match_lines ? IF_BK(line_beg_bk, line_beg_no_bk)
			     : IF_BK(word_beg_bk, word_beg_no_bk));
      total = strlen(n);
      memcpy (n + total, pattern, size);
      total += size;
      strcpy (n + total, match_lines ? IF_BK(line_end_bk, line_end_no_bk)
				     : IF_BK(word_end_bk, word_end_no_bk));
      total += strlen (n + total);
      pattern = motif = n;
      size = total;
    }
  else
    motif = NULL;

  dfacomp (pattern, size, &dfa, 1);
  kwsmusts ();

  free(motif);
}

#ifndef EGREP_PROGRAM
COMPILE_FCT(Gcompile)
{
  return GEAcompile (pattern, size,
		     RE_SYNTAX_GREP | RE_HAT_LISTS_NOT_NEWLINE);
}

COMPILE_FCT(Acompile)
{
  return GEAcompile (pattern, size, RE_SYNTAX_AWK);
}

COMPILE_FCT(Ecompile)
{
  return GEAcompile (pattern, size, RE_SYNTAX_POSIX_EGREP);
}
#endif /* !EGREP_PROGRAM */

EXECUTE_FCT(EGexecute)
{
  char const *buflim, *beg, *end, *match, *best_match, *mb_start;
  char eol = eolbyte;
  int backref, start, len, best_len;
  struct kwsmatch kwsm;
  size_t i, ret_val;
#ifdef MBS_SUPPORT
  if (MB_CUR_MAX > 1)
    {
      if (match_icase)
        {
          /* mbtolower adds a NUL byte at the end.  That will provide
	     space for the sentinel byte dfaexec may add.  */
          char *case_buf = mbtolower (buf, &size);
	  if (start_ptr)
	    start_ptr = case_buf + (start_ptr - buf);
          buf = case_buf;
        }
    }
#endif /* MBS_SUPPORT */

  mb_start = buf;
  buflim = buf + size;

  for (beg = end = buf; end < buflim; beg = end)
    {
      if (!start_ptr)
	{
	  /* We don't care about an exact match.  */
	  if (kwset)
	    {
	      /* Find a possible match using the KWset matcher. */
	      size_t offset = kwsexec (kwset, beg, buflim - beg, &kwsm);
	      if (offset == (size_t) -1)
		goto failure;
	      beg += offset;
	      /* Narrow down to the line containing the candidate, and
		 run it through DFA. */
	      if ((end = memchr(beg, eol, buflim - beg)) != NULL)
	        end++;
              else
                end = buflim;
	      match = beg;
	      while (beg > buf && beg[-1] != eol)
		--beg;
	      if (kwsm.index < kwset_exact_matches)
                {
#ifdef MBS_SUPPORT
                  if (mb_start < beg)
                    mb_start = beg;
                  if (MB_CUR_MAX == 1 || !is_mb_middle (&mb_start, match, buflim))
#endif
                    goto success;
                }
	      if (dfaexec (&dfa, beg, (char *) end, 0, NULL, &backref) == NULL)
		continue;
	    }
	  else
	    {
	      /* No good fixed strings; start with DFA. */
	      char const *next_beg = dfaexec (&dfa, beg, (char *) buflim,
					      0, NULL, &backref);
	      if (next_beg == NULL)
		break;
	      /* Narrow down to the line we've found. */
	      beg = next_beg;
	      if ((end = memchr(beg, eol, buflim - beg)) != NULL)
	        end++;
              else
                end = buflim;
	      while (beg > buf && beg[-1] != eol)
		--beg;
	    }
	  /* Successful, no backreferences encountered! */
	  if (!backref)
	    goto success;
	}
      else
	{
	  /* We are looking for the leftmost (then longest) exact match.
	     We will go through the outer loop only once.  */
	  beg = start_ptr;
	  end = buflim;
	}

      /* If we've made it to this point, this means DFA has seen
	 a probable match, and we need to run it through Regex. */
      best_match = end;
      best_len = 0;
      for (i = 0; i < pcount; i++)
	{
	  patterns[i].regexbuf.not_eol = 0;
	  if (0 <= (start = re_search (&(patterns[i].regexbuf),
				       buf, end - buf - 1,
				       beg - buf, end - beg - 1,
				       &(patterns[i].regs))))
	    {
	      len = patterns[i].regs.end[0] - start;
	      match = buf + start;
	      if (match > best_match)
		continue;
	      if (start_ptr && !match_words)
		goto assess_pattern_match;
	      if ((!match_lines && !match_words)
		  || (match_lines && len == end - beg - 1))
		{
		  match = beg;
		  len = end - beg;
		  goto assess_pattern_match;
		}
	      /* If -w, check if the match aligns with word boundaries.
		 We do this iteratively because:
		 (a) the line may contain more than one occurence of the
		 pattern, and
		 (b) Several alternatives in the pattern might be valid at a
		 given point, and we may need to consider a shorter one to
		 find a word boundary.  */
	      if (match_words)
		while (match <= best_match)
		  {
		    if ((match == buf || !WCHAR ((unsigned char) match[-1]))
			&& (len == end - beg - 1
			    || !WCHAR ((unsigned char) match[len])))
		      goto assess_pattern_match;
		    if (len > 0)
		      {
			/* Try a shorter length anchored at the same place. */
			--len;
			patterns[i].regexbuf.not_eol = 1;
			len = re_match (&(patterns[i].regexbuf),
					buf, match + len - beg, match - buf,
					&(patterns[i].regs));
		      }
		    if (len <= 0)
		      {
			/* Try looking further on. */
			if (match == end - 1)
			  break;
			match++;
			patterns[i].regexbuf.not_eol = 0;
			start = re_search (&(patterns[i].regexbuf),
					   buf, end - buf - 1,
					   match - buf, end - match - 1,
					   &(patterns[i].regs));
			if (start < 0)
			  break;
			len = patterns[i].regs.end[0] - start;
			match = buf + start;
		      }
		  } /* while (match <= best_match) */
	      continue;
	    assess_pattern_match:
	      if (!start_ptr)
		{
		  /* Good enough for a non-exact match.
		     No need to look at further patterns, if any.  */
		  beg = match;
		  goto success_in_len;
		}
	      if (match < best_match || (match == best_match && len > best_len))
		{
		  /* Best exact match:  leftmost, then longest.  */
		  best_match = match;
		  best_len = len;
		}
	    } /* if re_search >= 0 */
	} /* for Regex patterns.  */
	if (best_match < end)
	  {
	    /* We have found an exact match.  We were just
	       waiting for the best one (leftmost then longest).  */
	    beg = best_match;
	    len = best_len;
	    goto success_in_len;
	  }
    } /* for (beg = end ..) */

 failure:
  ret_val = -1;
  goto out;

 success:
  len = end - beg;
 success_in_len:
  *match_size = len;
  ret_val = beg - buf;
 out:
  return ret_val;
}
#endif /* defined(GREP_PROGRAM) || defined(EGREP_PROGRAM) */

#if defined(GREP_PROGRAM) || defined(FGREP_PROGRAM)
COMPILE_FCT(Fcompile)
{
  char const *beg, *end, *lim, *err, *pat;
  size_t psize;

  kwsinit ();
  psize = size;
  if (match_icase && MB_CUR_MAX > 1)
    pat = mbtolower (pattern, &psize);
  else
    pat = pattern;

  beg = pat;
  do
    {
      for (lim = beg;; ++lim)
	{
	  end = lim;
	  if (lim >= pat + psize)
	    break;
	 if (*lim == '\n')
	   {
	     lim++;
	     break;
	   }
#if HAVE_DOS_FILE_CONTENTS
	 if (*lim == '\r' && lim + 1 < pat + psize && lim[1] == '\n')
	   {
	     lim += 2;
	     break;
	   }
#endif
	}

      if ((err = kwsincr (kwset, beg, end - beg)) != NULL)
	error (EXIT_TROUBLE, 0, "%s", err);
      beg = lim;
    }
  while (beg < pat + psize);

  if ((err = kwsprep (kwset)) != NULL)
    error (EXIT_TROUBLE, 0, "%s", err);
}

EXECUTE_FCT(Fexecute)
{
  char const *beg, *try, *end, *mb_start;
  size_t len;
  char eol = eolbyte;
  struct kwsmatch kwsmatch;
  size_t ret_val;
#ifdef MBS_SUPPORT
  if (MB_CUR_MAX > 1)
    {
      if (match_icase)
        {
          char *case_buf = mbtolower (buf, &size);
	  if (start_ptr)
	    start_ptr = case_buf + (start_ptr - buf);
          buf = case_buf;
        }
    }
#endif /* MBS_SUPPORT */

  for (mb_start = beg = start_ptr ? start_ptr : buf; beg <= buf + size; beg++)
    {
      size_t offset = kwsexec (kwset, beg, buf + size - beg, &kwsmatch);
      if (offset == (size_t) -1)
	goto failure;
#ifdef MBS_SUPPORT
      if (MB_CUR_MAX > 1 && is_mb_middle (&mb_start, beg + offset, buf + size))
        {
          beg = mb_start - 1;
          continue; /* It is a part of multibyte character.  */
        }
#endif /* MBS_SUPPORT */
      beg += offset;
      len = kwsmatch.size[0];
      if (start_ptr && !match_words)
	goto success_in_beg_and_len;
      if (match_lines)
	{
	  if (beg > buf && beg[-1] != eol)
	    continue;
	  if (beg + len < buf + size && beg[len] != eol)
	    continue;
	  goto success;
	}
      else if (match_words)
	for (try = beg; len; )
	  {
	    if (try > buf && WCHAR((unsigned char) try[-1]))
	      break;
	    if (try + len < buf + size && WCHAR((unsigned char) try[len]))
	      {
		offset = kwsexec (kwset, beg, --len, &kwsmatch);
		if (offset == (size_t) -1)
		  break;
		try = beg + offset;
		len = kwsmatch.size[0];
	      }
	    else if (!start_ptr)
	      goto success;
	    else
	      goto success_in_beg_and_len;
	  } /* for (try) */
      else
	goto success;
    } /* for (beg in buf) */

 failure:
  ret_val = -1;
  goto out;

 success:
  if ((end = memchr (beg + len, eol, (buf + size) - (beg + len))) != NULL)
    end++;
  else
    end = buf + size;
  while (buf < beg && beg[-1] != eol)
    --beg;
  len = end - beg;
 success_in_beg_and_len:
  *match_size = len;
  ret_val = beg - buf;
 out:
  return ret_val;
}
#endif /* defined(GREP_PROGRAM) || defined(FGREP_PROGRAM) */

#ifdef GREP_PROGRAM
#if HAVE_LIBPCRE
/* Compiled internal form of a Perl regular expression.  */
static pcre *cre;

/* Additional information about the pattern.  */
static pcre_extra *extra;
#endif

COMPILE_FCT(Pcompile)
{
#if !HAVE_LIBPCRE
  error (EXIT_TROUBLE, 0, "%s",
	 _("support for the -P option is not compiled into "
	   "this --disable-perl-regexp binary"));
#else
  int e;
  char const *ep;
  char *re = xmalloc (4 * size + 7);
  int flags = PCRE_MULTILINE | (match_icase ? PCRE_CASELESS : 0);
  char const *patlim = pattern + size;
  char *n = re;
  char const *p;
  char const *pnul;

  /* FIXME: Remove these restrictions.  */
  if (memchr(pattern, '\n', size))
    error (EXIT_TROUBLE, 0, _("the -P option only supports a single pattern"));

  *n = '\0';
  if (match_lines)
    strcpy (n, "^(");
  if (match_words)
    strcpy (n, "\\b(");
  n += strlen (n);

  /* The PCRE interface doesn't allow NUL bytes in the pattern, so
     replace each NUL byte in the pattern with the four characters
     "\000", removing a preceding backslash if there are an odd
     number of backslashes before the NUL.

     FIXME: This method does not work with some multibyte character
     encodings, notably Shift-JIS, where a multibyte character can end
     in a backslash byte.  */
  for (p = pattern; (pnul = memchr (p, '\0', patlim - p)); p = pnul + 1)
    {
      memcpy (n, p, pnul - p);
      n += pnul - p;
      for (p = pnul; pattern < p && p[-1] == '\\'; p--)
	continue;
      n -= (pnul - p) & 1;
      strcpy (n, "\\000");
      n += 4;
    }

  memcpy (n, p, patlim - p);
  n += patlim - p;
  *n = '\0';
  if (match_words)
    strcpy (n, ")\\b");
  if (match_lines)
    strcpy (n, ")$");

  cre = pcre_compile (re, flags, &ep, &e, pcre_maketables ());
  if (!cre)
    error (EXIT_TROUBLE, 0, "%s", ep);

  extra = pcre_study (cre, 0, &ep);
  if (ep)
    error (EXIT_TROUBLE, 0, "%s", ep);

  free (re);
#endif
}

EXECUTE_FCT(Pexecute)
{
#if !HAVE_LIBPCRE
  abort ();
  return -1;
#else
  /* This array must have at least two elements; everything after that
     is just for performance improvement in pcre_exec.  */
  int sub[300];

  const char *line_buf, *line_end, *line_next;
  int e = PCRE_ERROR_NOMATCH;
  ptrdiff_t start_ofs = start_ptr ? start_ptr - buf : 0;

  /* PCRE can't limit the matching to single lines, therefore we have to
     match each line in the buffer separately.  */
  for (line_next = buf;
       e == PCRE_ERROR_NOMATCH && line_next < buf + size;
       start_ofs -= line_next - line_buf)
    {
      line_buf = line_next;
      line_end = memchr (line_buf, eolbyte, (buf + size) - line_buf);
      if (line_end == NULL)
        line_next = line_end = buf + size;
      else
        line_next = line_end + 1;

      if (start_ptr && start_ptr >= line_end)
        continue;

      e = pcre_exec (cre, extra, line_buf, line_end - line_buf,
                     start_ofs < 0 ? 0 : start_ofs, 0,
                     sub, sizeof sub / sizeof *sub);
    }

  if (e <= 0)
    {
      switch (e)
	{
	case PCRE_ERROR_NOMATCH:
	  return -1;

	case PCRE_ERROR_NOMEMORY:
	  error (EXIT_TROUBLE, 0, _("memory exhausted"));

	default:
	  abort ();
	}
    }
  else
    {
      /* Narrow down to the line we've found.  */
      char const *beg = line_buf + sub[0];
      char const *end = line_buf + sub[1];
      char const *buflim = buf + size;
      char eol = eolbyte;
      if (!start_ptr)
	{
	  /* FIXME: The case when '\n' is not found indicates a bug:
	     Since grep is line oriented, the match should never contain
	     a newline, so there _must_ be a newline following.
	   */
	  if (!(end = memchr (end, eol, buflim - end)))
	    end = buflim;
	  else
	    end++;
	  while (buf < beg && beg[-1] != eol)
	    --beg;
	}

      *match_size = end - beg;
      return beg - buf;
    }
#endif
}

struct matcher const matchers[] = {
  { "default", Gcompile, EGexecute },
  { "grep",    Gcompile, EGexecute },
  { "egrep",   Ecompile, EGexecute },
  { "awk",     Acompile, EGexecute },
  { "fgrep",   Fcompile, Fexecute },
  { "perl",    Pcompile, Pexecute },
  { "", 0, 0 },
};
#endif /* GREP_PROGRAM */

Spawn 1 instances, now Total 35
Counter: 36
Batcher Size:35
Preprocess the following candidate with BasicTester:
Priority 7489
At location src/search.c:237
--Src File: src/search.c
Fragment 0:
patterns = realloc(patterns, (pcount + 1) * sizeof (*patterns));
memset(&cur_state, 0, sizeof(mbstate_t));


BasicTester, a patch instance with id 6:
//src_file:src/search.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
/* search.c - searching subroutines using dfa, kwset and regex for grep.
   Copyright 1992, 1998, 2000, 2007, 2009-2010 Free Software Foundation, Inc.

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 3, or (at your option)
   any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program; if not, write to the Free Software
   Foundation, Inc., 51 Franklin Street - Fifth Floor, Boston, MA
   02110-1301, USA.  */

/* Written August 1992 by Mike Haertel. */

#include <config.h>

#include <sys/types.h>

#include "mbsupport.h"
#ifdef MBS_SUPPORT
/* We can handle multibyte strings. */
# include <wchar.h>
# include <wctype.h>
#endif

#include "system.h"
#include "grep.h"
#ifndef FGREP_PROGRAM
# include <regex.h>
# include "dfa.h"
#endif
#include "kwset.h"
#include "error.h"
#include "xalloc.h"
#ifdef HAVE_LIBPCRE
# include <pcre.h>
#endif

#define NCHAR (UCHAR_MAX + 1)

/* For -w, we also consider _ to be word constituent.  */
#define WCHAR(C) (ISALNUM(C) || (C) == '_')

/* KWset compiled pattern.  For Ecompile and Gcompile, we compile
   a list of strings, at least one of which is known to occur in
   any string matching the regexp. */
static kwset_t kwset;

static void
kwsinit (void)
{
  static char trans[NCHAR];
  int i;

  if (match_icase && MB_CUR_MAX == 1)
    {
      for (i = 0; i < NCHAR; ++i)
        trans[i] = TOLOWER (i);

      kwset = kwsalloc (trans);
    }
  else
    kwset = kwsalloc (NULL);

  if (!kwset)
    xalloc_die ();
}

#ifdef MBS_SUPPORT
/* Convert the *N-byte string, BEG, to lowercase, and write the
   NUL-terminated result into malloc'd storage.  Upon success, set *N
   to the length (in bytes) of the resulting string (not including the
   trailing NUL byte), and return a pointer to the lowercase string.
   Upon memory allocation failure, this function exits.

   Note that while this function returns a pointer to malloc'd storage,
   the caller must not free it, since this function retains a pointer
   to the buffer and reuses it on any subsequent call.  As a consequence,
   this function is not thread-safe.  */
static char *
mbtolower (const char *beg, size_t *n)
{
  static char *out;
  static size_t outalloc;
  size_t outlen, mb_cur_max;
  mbstate_t is, os;
  const char *end;
  char *p;

  if (*n > outalloc)
    {
      out = xrealloc (out, *n);
      outalloc = *n;
    }

  memset (&is, 0, sizeof (is));
  memset (&os, 0, sizeof (os));
  end = beg + *n;

  mb_cur_max = MB_CUR_MAX;
  p = out;
  outlen = 0;
  while (beg < end)
    {
      wchar_t wc;
      size_t mbclen = mbrtowc(&wc, beg, end - beg, &is);
      if (outlen + mb_cur_max >= outalloc)
        {
          out = x2nrealloc (out, &outalloc, 1);
          p = out + outlen;
        }

      if (mbclen == (size_t) -1 || mbclen == (size_t) -2 || mbclen == 0)
        {
          /* An invalid sequence, or a truncated multi-octet character.
             We treat it as a single-octet character.  */
          *p++ = *beg++;
          outlen++;
          memset (&is, 0, sizeof (is));
          memset (&os, 0, sizeof (os));
        }
      else
        {
          beg += mbclen;
          mbclen = wcrtomb (p, towlower ((wint_t) wc), &os);
          p += mbclen;
          outlen += mbclen;
        }
    }

  *n = p - out;
  *p++ = 0;
  return out;
}
#endif


#ifndef FGREP_PROGRAM
/* DFA compiled regexp. */
static struct dfa dfa;

/* The Regex compiled patterns.  */
static struct patterns
{
  /* Regex compiled regexp. */
  struct re_pattern_buffer regexbuf;
  struct re_registers regs; /* This is here on account of a BRAIN-DEAD
			       Q@#%!# library interface in regex.c.  */
} patterns0;

struct patterns *patterns;
size_t pcount;

void
dfaerror (char const *mesg)
{
  error (EXIT_TROUBLE, 0, "%s", mesg);
}

/* Number of compiled fixed strings known to exactly match the regexp.
   If kwsexec returns < kwset_exact_matches, then we don't need to
   call the regexp matcher at all. */
static int kwset_exact_matches;

static char const *
kwsincr_case (const char *must)
{
  const char *buf;
  size_t n;

  n = strlen (must);
#ifdef MBS_SUPPORT
  if (match_icase && MB_CUR_MAX > 1)
    buf = mbtolower (must, &n);
  else
#endif
    buf = must;
  return kwsincr (kwset, buf, n);
}

/* If the DFA turns out to have some set of fixed strings one of
   which must occur in the match, then we build a kwset matcher
   to find those strings, and thus quickly filter out impossible
   matches. */
static void
kwsmusts (void)
{
  struct dfamust const *dm;
  char const *err;

  if (dfa.musts)
    {
      kwsinit ();
      /* First, we compile in the substrings known to be exact
	 matches.  The kwset matcher will return the index
	 of the matching string that it chooses. */
      for (dm = dfa.musts; dm; dm = dm->next)
	{
	  if (!dm->exact)
	    continue;
	  ++kwset_exact_matches;
	  if ((err = kwsincr_case (dm->must)) != NULL)
	    error (EXIT_TROUBLE, 0, "%s", err);
	}
      /* Now, we compile the substrings that will require
	 the use of the regexp matcher.  */
      for (dm = dfa.musts; dm; dm = dm->next)
	{
	  if (dm->exact)
	    continue;
	  if ((err = kwsincr_case (dm->must)) != NULL)
	    error (EXIT_TROUBLE, 0, "%s", err);
	}
      if ((err = kwsprep (kwset)) != NULL)
	error (EXIT_TROUBLE, 0, "%s", err);
    }
}
#endif /* !FGREP_PROGRAM */

#ifdef MBS_SUPPORT

static bool
is_mb_middle(const char **good, const char *buf, const char *end)
{
  const char *p = *good;
  const char *prev = p;
  mbstate_t cur_state;

  /* TODO: can be optimized for UTF-8.  */
  
//Patch 0:
patterns = realloc(patterns, (pcount + 1) * sizeof (*patterns));
memset(&cur_state, 0, sizeof(mbstate_t));

//CodeSeg 1:
  while (p < buf)
    {
      size_t mbclen = mbrlen(p, end - p, &cur_state);

      /* Store the beginning of the previous complete multibyte character.  */
      if (mbclen != (size_t) -2)
        prev = p;

      if (mbclen == (size_t) -1 || mbclen == (size_t) -2 || mbclen == 0)
	{
	  /* An invalid sequence, or a truncated multibyte character.
	     We treat it as a single byte character.  */
	  mbclen = 1;
	}
      p += mbclen;
    }

  *good = prev;
  return p > buf;
}
#endif /* MBS_SUPPORT */

#if defined(GREP_PROGRAM) || defined(EGREP_PROGRAM)
#ifdef EGREP_PROGRAM
COMPILE_FCT(Ecompile)
{
  reg_syntax_t syntax_bits = RE_SYNTAX_POSIX_EGREP;
#else
/* No __VA_ARGS__ in C89.  So we have to do it this way.  */
static COMPILE_RET
GEAcompile (char const *pattern, size_t size, reg_syntax_t syntax_bits)
{
#endif /* EGREP_PROGRAM */
  const char *err;
  const char *p, *sep;
  size_t total = size;
  char *motif;

  if (match_icase)
    syntax_bits |= RE_ICASE;
  re_set_syntax (syntax_bits);
  dfasyntax (syntax_bits, match_icase, eolbyte);

  /* For GNU regex compiler we have to pass the patterns separately to detect
     errors like "[\nallo\n]\n".  The patterns here are "[", "allo" and "]"
     GNU regex should have raise a syntax error.  The same for backref, where
     the backref should have been local to each pattern.  */
  p = pattern;
  do
    {
      size_t len;
      sep = memchr (p, '\n', total);
      if (sep)
	{
	  len = sep - p;
	  sep++;
	  total -= (len + 1);
	}
      else
	{
	  len = total;
	  total = 0;
	}

      patterns = realloc (patterns, (pcount + 1) * sizeof (*patterns));
      if (patterns == NULL)
	error (EXIT_TROUBLE, errno, _("memory exhausted"));
      patterns[pcount] = patterns0;

      if ((err = re_compile_pattern (p, len,
				    &(patterns[pcount].regexbuf))) != NULL)
	error (EXIT_TROUBLE, 0, "%s", err);
      pcount++;

      p = sep;
    } while (sep && total != 0);

  /* In the match_words and match_lines cases, we use a different pattern
     for the DFA matcher that will quickly throw out cases that won't work.
     Then if DFA succeeds we do some hairy stuff using the regex matcher
     to decide whether the match should really count. */
  if (match_words || match_lines)
    {
      static char const line_beg_no_bk[] = "^(";
      static char const line_end_no_bk[] = ")$";
      static char const word_beg_no_bk[] = "(^|[^[:alnum:]_])(";
      static char const word_end_no_bk[] = ")([^[:alnum:]_]|$)";
#ifdef EGREP_PROGRAM
# define IF_BK(x, y) (y)
      char *n = xmalloc (sizeof word_beg_no_bk - 1 + size + sizeof word_end_no_bk);
#else
      static char const line_beg_bk[] = "^\\(";
      static char const line_end_bk[] = "\\)$";
      static char const word_beg_bk[] = "\\(^\\|[^[:alnum:]_]\\)\\(";
      static char const word_end_bk[] = "\\)\\([^[:alnum:]_]\\|$\\)";
      int bk = !(syntax_bits & RE_NO_BK_PARENS);
# define IF_BK(x, y) ((bk) ? (x) : (y))
      char *n = xmalloc (sizeof word_beg_bk - 1 + size + sizeof word_end_bk);
#endif /* EGREP_PROGRAM */

      strcpy (n, match_lines ? IF_BK(line_beg_bk, line_beg_no_bk)
			     : IF_BK(word_beg_bk, word_beg_no_bk));
      total = strlen(n);
      memcpy (n + total, pattern, size);
      total += size;
      strcpy (n + total, match_lines ? IF_BK(line_end_bk, line_end_no_bk)
				     : IF_BK(word_end_bk, word_end_no_bk));
      total += strlen (n + total);
      pattern = motif = n;
      size = total;
    }
  else
    motif = NULL;

  dfacomp (pattern, size, &dfa, 1);
  kwsmusts ();

  free(motif);
}

#ifndef EGREP_PROGRAM
COMPILE_FCT(Gcompile)
{
  return GEAcompile (pattern, size,
		     RE_SYNTAX_GREP | RE_HAT_LISTS_NOT_NEWLINE);
}

COMPILE_FCT(Acompile)
{
  return GEAcompile (pattern, size, RE_SYNTAX_AWK);
}

COMPILE_FCT(Ecompile)
{
  return GEAcompile (pattern, size, RE_SYNTAX_POSIX_EGREP);
}
#endif /* !EGREP_PROGRAM */

EXECUTE_FCT(EGexecute)
{
  char const *buflim, *beg, *end, *match, *best_match, *mb_start;
  char eol = eolbyte;
  int backref, start, len, best_len;
  struct kwsmatch kwsm;
  size_t i, ret_val;
#ifdef MBS_SUPPORT
  if (MB_CUR_MAX > 1)
    {
      if (match_icase)
        {
          /* mbtolower adds a NUL byte at the end.  That will provide
	     space for the sentinel byte dfaexec may add.  */
          char *case_buf = mbtolower (buf, &size);
	  if (start_ptr)
	    start_ptr = case_buf + (start_ptr - buf);
          buf = case_buf;
        }
    }
#endif /* MBS_SUPPORT */

  mb_start = buf;
  buflim = buf + size;

  for (beg = end = buf; end < buflim; beg = end)
    {
      if (!start_ptr)
	{
	  /* We don't care about an exact match.  */
	  if (kwset)
	    {
	      /* Find a possible match using the KWset matcher. */
	      size_t offset = kwsexec (kwset, beg, buflim - beg, &kwsm);
	      if (offset == (size_t) -1)
		goto failure;
	      beg += offset;
	      /* Narrow down to the line containing the candidate, and
		 run it through DFA. */
	      if ((end = memchr(beg, eol, buflim - beg)) != NULL)
	        end++;
              else
                end = buflim;
	      match = beg;
	      while (beg > buf && beg[-1] != eol)
		--beg;
	      if (kwsm.index < kwset_exact_matches)
                {
#ifdef MBS_SUPPORT
                  if (mb_start < beg)
                    mb_start = beg;
                  if (MB_CUR_MAX == 1 || !is_mb_middle (&mb_start, match, buflim))
#endif
                    goto success;
                }
	      if (dfaexec (&dfa, beg, (char *) end, 0, NULL, &backref) == NULL)
		continue;
	    }
	  else
	    {
	      /* No good fixed strings; start with DFA. */
	      char const *next_beg = dfaexec (&dfa, beg, (char *) buflim,
					      0, NULL, &backref);
	      if (next_beg == NULL)
		break;
	      /* Narrow down to the line we've found. */
	      beg = next_beg;
	      if ((end = memchr(beg, eol, buflim - beg)) != NULL)
	        end++;
              else
                end = buflim;
	      while (beg > buf && beg[-1] != eol)
		--beg;
	    }
	  /* Successful, no backreferences encountered! */
	  if (!backref)
	    goto success;
	}
      else
	{
	  /* We are looking for the leftmost (then longest) exact match.
	     We will go through the outer loop only once.  */
	  beg = start_ptr;
	  end = buflim;
	}

      /* If we've made it to this point, this means DFA has seen
	 a probable match, and we need to run it through Regex. */
      best_match = end;
      best_len = 0;
      for (i = 0; i < pcount; i++)
	{
	  patterns[i].regexbuf.not_eol = 0;
	  if (0 <= (start = re_search (&(patterns[i].regexbuf),
				       buf, end - buf - 1,
				       beg - buf, end - beg - 1,
				       &(patterns[i].regs))))
	    {
	      len = patterns[i].regs.end[0] - start;
	      match = buf + start;
	      if (match > best_match)
		continue;
	      if (start_ptr && !match_words)
		goto assess_pattern_match;
	      if ((!match_lines && !match_words)
		  || (match_lines && len == end - beg - 1))
		{
		  match = beg;
		  len = end - beg;
		  goto assess_pattern_match;
		}
	      /* If -w, check if the match aligns with word boundaries.
		 We do this iteratively because:
		 (a) the line may contain more than one occurence of the
		 pattern, and
		 (b) Several alternatives in the pattern might be valid at a
		 given point, and we may need to consider a shorter one to
		 find a word boundary.  */
	      if (match_words)
		while (match <= best_match)
		  {
		    if ((match == buf || !WCHAR ((unsigned char) match[-1]))
			&& (len == end - beg - 1
			    || !WCHAR ((unsigned char) match[len])))
		      goto assess_pattern_match;
		    if (len > 0)
		      {
			/* Try a shorter length anchored at the same place. */
			--len;
			patterns[i].regexbuf.not_eol = 1;
			len = re_match (&(patterns[i].regexbuf),
					buf, match + len - beg, match - buf,
					&(patterns[i].regs));
		      }
		    if (len <= 0)
		      {
			/* Try looking further on. */
			if (match == end - 1)
			  break;
			match++;
			patterns[i].regexbuf.not_eol = 0;
			start = re_search (&(patterns[i].regexbuf),
					   buf, end - buf - 1,
					   match - buf, end - match - 1,
					   &(patterns[i].regs));
			if (start < 0)
			  break;
			len = patterns[i].regs.end[0] - start;
			match = buf + start;
		      }
		  } /* while (match <= best_match) */
	      continue;
	    assess_pattern_match:
	      if (!start_ptr)
		{
		  /* Good enough for a non-exact match.
		     No need to look at further patterns, if any.  */
		  beg = match;
		  goto success_in_len;
		}
	      if (match < best_match || (match == best_match && len > best_len))
		{
		  /* Best exact match:  leftmost, then longest.  */
		  best_match = match;
		  best_len = len;
		}
	    } /* if re_search >= 0 */
	} /* for Regex patterns.  */
	if (best_match < end)
	  {
	    /* We have found an exact match.  We were just
	       waiting for the best one (leftmost then longest).  */
	    beg = best_match;
	    len = best_len;
	    goto success_in_len;
	  }
    } /* for (beg = end ..) */

 failure:
  ret_val = -1;
  goto out;

 success:
  len = end - beg;
 success_in_len:
  *match_size = len;
  ret_val = beg - buf;
 out:
  return ret_val;
}
#endif /* defined(GREP_PROGRAM) || defined(EGREP_PROGRAM) */

#if defined(GREP_PROGRAM) || defined(FGREP_PROGRAM)
COMPILE_FCT(Fcompile)
{
  char const *beg, *end, *lim, *err, *pat;
  size_t psize;

  kwsinit ();
  psize = size;
  if (match_icase && MB_CUR_MAX > 1)
    pat = mbtolower (pattern, &psize);
  else
    pat = pattern;

  beg = pat;
  do
    {
      for (lim = beg;; ++lim)
	{
	  end = lim;
	  if (lim >= pat + psize)
	    break;
	 if (*lim == '\n')
	   {
	     lim++;
	     break;
	   }
#if HAVE_DOS_FILE_CONTENTS
	 if (*lim == '\r' && lim + 1 < pat + psize && lim[1] == '\n')
	   {
	     lim += 2;
	     break;
	   }
#endif
	}

      if ((err = kwsincr (kwset, beg, end - beg)) != NULL)
	error (EXIT_TROUBLE, 0, "%s", err);
      beg = lim;
    }
  while (beg < pat + psize);

  if ((err = kwsprep (kwset)) != NULL)
    error (EXIT_TROUBLE, 0, "%s", err);
}

EXECUTE_FCT(Fexecute)
{
  char const *beg, *try, *end, *mb_start;
  size_t len;
  char eol = eolbyte;
  struct kwsmatch kwsmatch;
  size_t ret_val;
#ifdef MBS_SUPPORT
  if (MB_CUR_MAX > 1)
    {
      if (match_icase)
        {
          char *case_buf = mbtolower (buf, &size);
	  if (start_ptr)
	    start_ptr = case_buf + (start_ptr - buf);
          buf = case_buf;
        }
    }
#endif /* MBS_SUPPORT */

  for (mb_start = beg = start_ptr ? start_ptr : buf; beg <= buf + size; beg++)
    {
      size_t offset = kwsexec (kwset, beg, buf + size - beg, &kwsmatch);
      if (offset == (size_t) -1)
	goto failure;
#ifdef MBS_SUPPORT
      if (MB_CUR_MAX > 1 && is_mb_middle (&mb_start, beg + offset, buf + size))
        {
          beg = mb_start - 1;
          continue; /* It is a part of multibyte character.  */
        }
#endif /* MBS_SUPPORT */
      beg += offset;
      len = kwsmatch.size[0];
      if (start_ptr && !match_words)
	goto success_in_beg_and_len;
      if (match_lines)
	{
	  if (beg > buf && beg[-1] != eol)
	    continue;
	  if (beg + len < buf + size && beg[len] != eol)
	    continue;
	  goto success;
	}
      else if (match_words)
	for (try = beg; len; )
	  {
	    if (try > buf && WCHAR((unsigned char) try[-1]))
	      break;
	    if (try + len < buf + size && WCHAR((unsigned char) try[len]))
	      {
		offset = kwsexec (kwset, beg, --len, &kwsmatch);
		if (offset == (size_t) -1)
		  break;
		try = beg + offset;
		len = kwsmatch.size[0];
	      }
	    else if (!start_ptr)
	      goto success;
	    else
	      goto success_in_beg_and_len;
	  } /* for (try) */
      else
	goto success;
    } /* for (beg in buf) */

 failure:
  ret_val = -1;
  goto out;

 success:
  if ((end = memchr (beg + len, eol, (buf + size) - (beg + len))) != NULL)
    end++;
  else
    end = buf + size;
  while (buf < beg && beg[-1] != eol)
    --beg;
  len = end - beg;
 success_in_beg_and_len:
  *match_size = len;
  ret_val = beg - buf;
 out:
  return ret_val;
}
#endif /* defined(GREP_PROGRAM) || defined(FGREP_PROGRAM) */

#ifdef GREP_PROGRAM
#if HAVE_LIBPCRE
/* Compiled internal form of a Perl regular expression.  */
static pcre *cre;

/* Additional information about the pattern.  */
static pcre_extra *extra;
#endif

COMPILE_FCT(Pcompile)
{
#if !HAVE_LIBPCRE
  error (EXIT_TROUBLE, 0, "%s",
	 _("support for the -P option is not compiled into "
	   "this --disable-perl-regexp binary"));
#else
  int e;
  char const *ep;
  char *re = xmalloc (4 * size + 7);
  int flags = PCRE_MULTILINE | (match_icase ? PCRE_CASELESS : 0);
  char const *patlim = pattern + size;
  char *n = re;
  char const *p;
  char const *pnul;

  /* FIXME: Remove these restrictions.  */
  if (memchr(pattern, '\n', size))
    error (EXIT_TROUBLE, 0, _("the -P option only supports a single pattern"));

  *n = '\0';
  if (match_lines)
    strcpy (n, "^(");
  if (match_words)
    strcpy (n, "\\b(");
  n += strlen (n);

  /* The PCRE interface doesn't allow NUL bytes in the pattern, so
     replace each NUL byte in the pattern with the four characters
     "\000", removing a preceding backslash if there are an odd
     number of backslashes before the NUL.

     FIXME: This method does not work with some multibyte character
     encodings, notably Shift-JIS, where a multibyte character can end
     in a backslash byte.  */
  for (p = pattern; (pnul = memchr (p, '\0', patlim - p)); p = pnul + 1)
    {
      memcpy (n, p, pnul - p);
      n += pnul - p;
      for (p = pnul; pattern < p && p[-1] == '\\'; p--)
	continue;
      n -= (pnul - p) & 1;
      strcpy (n, "\\000");
      n += 4;
    }

  memcpy (n, p, patlim - p);
  n += patlim - p;
  *n = '\0';
  if (match_words)
    strcpy (n, ")\\b");
  if (match_lines)
    strcpy (n, ")$");

  cre = pcre_compile (re, flags, &ep, &e, pcre_maketables ());
  if (!cre)
    error (EXIT_TROUBLE, 0, "%s", ep);

  extra = pcre_study (cre, 0, &ep);
  if (ep)
    error (EXIT_TROUBLE, 0, "%s", ep);

  free (re);
#endif
}

EXECUTE_FCT(Pexecute)
{
#if !HAVE_LIBPCRE
  abort ();
  return -1;
#else
  /* This array must have at least two elements; everything after that
     is just for performance improvement in pcre_exec.  */
  int sub[300];

  const char *line_buf, *line_end, *line_next;
  int e = PCRE_ERROR_NOMATCH;
  ptrdiff_t start_ofs = start_ptr ? start_ptr - buf : 0;

  /* PCRE can't limit the matching to single lines, therefore we have to
     match each line in the buffer separately.  */
  for (line_next = buf;
       e == PCRE_ERROR_NOMATCH && line_next < buf + size;
       start_ofs -= line_next - line_buf)
    {
      line_buf = line_next;
      line_end = memchr (line_buf, eolbyte, (buf + size) - line_buf);
      if (line_end == NULL)
        line_next = line_end = buf + size;
      else
        line_next = line_end + 1;

      if (start_ptr && start_ptr >= line_end)
        continue;

      e = pcre_exec (cre, extra, line_buf, line_end - line_buf,
                     start_ofs < 0 ? 0 : start_ofs, 0,
                     sub, sizeof sub / sizeof *sub);
    }

  if (e <= 0)
    {
      switch (e)
	{
	case PCRE_ERROR_NOMATCH:
	  return -1;

	case PCRE_ERROR_NOMEMORY:
	  error (EXIT_TROUBLE, 0, _("memory exhausted"));

	default:
	  abort ();
	}
    }
  else
    {
      /* Narrow down to the line we've found.  */
      char const *beg = line_buf + sub[0];
      char const *end = line_buf + sub[1];
      char const *buflim = buf + size;
      char eol = eolbyte;
      if (!start_ptr)
	{
	  /* FIXME: The case when '\n' is not found indicates a bug:
	     Since grep is line oriented, the match should never contain
	     a newline, so there _must_ be a newline following.
	   */
	  if (!(end = memchr (end, eol, buflim - end)))
	    end = buflim;
	  else
	    end++;
	  while (buf < beg && beg[-1] != eol)
	    --beg;
	}

      *match_size = end - beg;
      return beg - buf;
    }
#endif
}

struct matcher const matchers[] = {
  { "default", Gcompile, EGexecute },
  { "grep",    Gcompile, EGexecute },
  { "egrep",   Ecompile, EGexecute },
  { "awk",     Acompile, EGexecute },
  { "fgrep",   Fcompile, Fexecute },
  { "perl",    Pcompile, Pexecute },
  { "", 0, 0 },
};
#endif /* GREP_PROGRAM */

Spawn 1 instances, now Total 36
Counter: 37
Batcher Size:36
Preprocess the following candidate with BasicTester:
Priority 7489
At location src/search.c:237
--Src File: src/search.c
Fragment 0:
pcount++;
memset(&cur_state, 0, sizeof(mbstate_t));


BasicTester, a patch instance with id 7:
//src_file:src/search.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
/* search.c - searching subroutines using dfa, kwset and regex for grep.
   Copyright 1992, 1998, 2000, 2007, 2009-2010 Free Software Foundation, Inc.

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 3, or (at your option)
   any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program; if not, write to the Free Software
   Foundation, Inc., 51 Franklin Street - Fifth Floor, Boston, MA
   02110-1301, USA.  */

/* Written August 1992 by Mike Haertel. */

#include <config.h>

#include <sys/types.h>

#include "mbsupport.h"
#ifdef MBS_SUPPORT
/* We can handle multibyte strings. */
# include <wchar.h>
# include <wctype.h>
#endif

#include "system.h"
#include "grep.h"
#ifndef FGREP_PROGRAM
# include <regex.h>
# include "dfa.h"
#endif
#include "kwset.h"
#include "error.h"
#include "xalloc.h"
#ifdef HAVE_LIBPCRE
# include <pcre.h>
#endif

#define NCHAR (UCHAR_MAX + 1)

/* For -w, we also consider _ to be word constituent.  */
#define WCHAR(C) (ISALNUM(C) || (C) == '_')

/* KWset compiled pattern.  For Ecompile and Gcompile, we compile
   a list of strings, at least one of which is known to occur in
   any string matching the regexp. */
static kwset_t kwset;

static void
kwsinit (void)
{
  static char trans[NCHAR];
  int i;

  if (match_icase && MB_CUR_MAX == 1)
    {
      for (i = 0; i < NCHAR; ++i)
        trans[i] = TOLOWER (i);

      kwset = kwsalloc (trans);
    }
  else
    kwset = kwsalloc (NULL);

  if (!kwset)
    xalloc_die ();
}

#ifdef MBS_SUPPORT
/* Convert the *N-byte string, BEG, to lowercase, and write the
   NUL-terminated result into malloc'd storage.  Upon success, set *N
   to the length (in bytes) of the resulting string (not including the
   trailing NUL byte), and return a pointer to the lowercase string.
   Upon memory allocation failure, this function exits.

   Note that while this function returns a pointer to malloc'd storage,
   the caller must not free it, since this function retains a pointer
   to the buffer and reuses it on any subsequent call.  As a consequence,
   this function is not thread-safe.  */
static char *
mbtolower (const char *beg, size_t *n)
{
  static char *out;
  static size_t outalloc;
  size_t outlen, mb_cur_max;
  mbstate_t is, os;
  const char *end;
  char *p;

  if (*n > outalloc)
    {
      out = xrealloc (out, *n);
      outalloc = *n;
    }

  memset (&is, 0, sizeof (is));
  memset (&os, 0, sizeof (os));
  end = beg + *n;

  mb_cur_max = MB_CUR_MAX;
  p = out;
  outlen = 0;
  while (beg < end)
    {
      wchar_t wc;
      size_t mbclen = mbrtowc(&wc, beg, end - beg, &is);
      if (outlen + mb_cur_max >= outalloc)
        {
          out = x2nrealloc (out, &outalloc, 1);
          p = out + outlen;
        }

      if (mbclen == (size_t) -1 || mbclen == (size_t) -2 || mbclen == 0)
        {
          /* An invalid sequence, or a truncated multi-octet character.
             We treat it as a single-octet character.  */
          *p++ = *beg++;
          outlen++;
          memset (&is, 0, sizeof (is));
          memset (&os, 0, sizeof (os));
        }
      else
        {
          beg += mbclen;
          mbclen = wcrtomb (p, towlower ((wint_t) wc), &os);
          p += mbclen;
          outlen += mbclen;
        }
    }

  *n = p - out;
  *p++ = 0;
  return out;
}
#endif


#ifndef FGREP_PROGRAM
/* DFA compiled regexp. */
static struct dfa dfa;

/* The Regex compiled patterns.  */
static struct patterns
{
  /* Regex compiled regexp. */
  struct re_pattern_buffer regexbuf;
  struct re_registers regs; /* This is here on account of a BRAIN-DEAD
			       Q@#%!# library interface in regex.c.  */
} patterns0;

struct patterns *patterns;
size_t pcount;

void
dfaerror (char const *mesg)
{
  error (EXIT_TROUBLE, 0, "%s", mesg);
}

/* Number of compiled fixed strings known to exactly match the regexp.
   If kwsexec returns < kwset_exact_matches, then we don't need to
   call the regexp matcher at all. */
static int kwset_exact_matches;

static char const *
kwsincr_case (const char *must)
{
  const char *buf;
  size_t n;

  n = strlen (must);
#ifdef MBS_SUPPORT
  if (match_icase && MB_CUR_MAX > 1)
    buf = mbtolower (must, &n);
  else
#endif
    buf = must;
  return kwsincr (kwset, buf, n);
}

/* If the DFA turns out to have some set of fixed strings one of
   which must occur in the match, then we build a kwset matcher
   to find those strings, and thus quickly filter out impossible
   matches. */
static void
kwsmusts (void)
{
  struct dfamust const *dm;
  char const *err;

  if (dfa.musts)
    {
      kwsinit ();
      /* First, we compile in the substrings known to be exact
	 matches.  The kwset matcher will return the index
	 of the matching string that it chooses. */
      for (dm = dfa.musts; dm; dm = dm->next)
	{
	  if (!dm->exact)
	    continue;
	  ++kwset_exact_matches;
	  if ((err = kwsincr_case (dm->must)) != NULL)
	    error (EXIT_TROUBLE, 0, "%s", err);
	}
      /* Now, we compile the substrings that will require
	 the use of the regexp matcher.  */
      for (dm = dfa.musts; dm; dm = dm->next)
	{
	  if (dm->exact)
	    continue;
	  if ((err = kwsincr_case (dm->must)) != NULL)
	    error (EXIT_TROUBLE, 0, "%s", err);
	}
      if ((err = kwsprep (kwset)) != NULL)
	error (EXIT_TROUBLE, 0, "%s", err);
    }
}
#endif /* !FGREP_PROGRAM */

#ifdef MBS_SUPPORT

static bool
is_mb_middle(const char **good, const char *buf, const char *end)
{
  const char *p = *good;
  const char *prev = p;
  mbstate_t cur_state;

  /* TODO: can be optimized for UTF-8.  */
  
//Patch 0:
pcount++;
memset(&cur_state, 0, sizeof(mbstate_t));

//CodeSeg 1:
  while (p < buf)
    {
      size_t mbclen = mbrlen(p, end - p, &cur_state);

      /* Store the beginning of the previous complete multibyte character.  */
      if (mbclen != (size_t) -2)
        prev = p;

      if (mbclen == (size_t) -1 || mbclen == (size_t) -2 || mbclen == 0)
	{
	  /* An invalid sequence, or a truncated multibyte character.
	     We treat it as a single byte character.  */
	  mbclen = 1;
	}
      p += mbclen;
    }

  *good = prev;
  return p > buf;
}
#endif /* MBS_SUPPORT */

#if defined(GREP_PROGRAM) || defined(EGREP_PROGRAM)
#ifdef EGREP_PROGRAM
COMPILE_FCT(Ecompile)
{
  reg_syntax_t syntax_bits = RE_SYNTAX_POSIX_EGREP;
#else
/* No __VA_ARGS__ in C89.  So we have to do it this way.  */
static COMPILE_RET
GEAcompile (char const *pattern, size_t size, reg_syntax_t syntax_bits)
{
#endif /* EGREP_PROGRAM */
  const char *err;
  const char *p, *sep;
  size_t total = size;
  char *motif;

  if (match_icase)
    syntax_bits |= RE_ICASE;
  re_set_syntax (syntax_bits);
  dfasyntax (syntax_bits, match_icase, eolbyte);

  /* For GNU regex compiler we have to pass the patterns separately to detect
     errors like "[\nallo\n]\n".  The patterns here are "[", "allo" and "]"
     GNU regex should have raise a syntax error.  The same for backref, where
     the backref should have been local to each pattern.  */
  p = pattern;
  do
    {
      size_t len;
      sep = memchr (p, '\n', total);
      if (sep)
	{
	  len = sep - p;
	  sep++;
	  total -= (len + 1);
	}
      else
	{
	  len = total;
	  total = 0;
	}

      patterns = realloc (patterns, (pcount + 1) * sizeof (*patterns));
      if (patterns == NULL)
	error (EXIT_TROUBLE, errno, _("memory exhausted"));
      patterns[pcount] = patterns0;

      if ((err = re_compile_pattern (p, len,
				    &(patterns[pcount].regexbuf))) != NULL)
	error (EXIT_TROUBLE, 0, "%s", err);
      pcount++;

      p = sep;
    } while (sep && total != 0);

  /* In the match_words and match_lines cases, we use a different pattern
     for the DFA matcher that will quickly throw out cases that won't work.
     Then if DFA succeeds we do some hairy stuff using the regex matcher
     to decide whether the match should really count. */
  if (match_words || match_lines)
    {
      static char const line_beg_no_bk[] = "^(";
      static char const line_end_no_bk[] = ")$";
      static char const word_beg_no_bk[] = "(^|[^[:alnum:]_])(";
      static char const word_end_no_bk[] = ")([^[:alnum:]_]|$)";
#ifdef EGREP_PROGRAM
# define IF_BK(x, y) (y)
      char *n = xmalloc (sizeof word_beg_no_bk - 1 + size + sizeof word_end_no_bk);
#else
      static char const line_beg_bk[] = "^\\(";
      static char const line_end_bk[] = "\\)$";
      static char const word_beg_bk[] = "\\(^\\|[^[:alnum:]_]\\)\\(";
      static char const word_end_bk[] = "\\)\\([^[:alnum:]_]\\|$\\)";
      int bk = !(syntax_bits & RE_NO_BK_PARENS);
# define IF_BK(x, y) ((bk) ? (x) : (y))
      char *n = xmalloc (sizeof word_beg_bk - 1 + size + sizeof word_end_bk);
#endif /* EGREP_PROGRAM */

      strcpy (n, match_lines ? IF_BK(line_beg_bk, line_beg_no_bk)
			     : IF_BK(word_beg_bk, word_beg_no_bk));
      total = strlen(n);
      memcpy (n + total, pattern, size);
      total += size;
      strcpy (n + total, match_lines ? IF_BK(line_end_bk, line_end_no_bk)
				     : IF_BK(word_end_bk, word_end_no_bk));
      total += strlen (n + total);
      pattern = motif = n;
      size = total;
    }
  else
    motif = NULL;

  dfacomp (pattern, size, &dfa, 1);
  kwsmusts ();

  free(motif);
}

#ifndef EGREP_PROGRAM
COMPILE_FCT(Gcompile)
{
  return GEAcompile (pattern, size,
		     RE_SYNTAX_GREP | RE_HAT_LISTS_NOT_NEWLINE);
}

COMPILE_FCT(Acompile)
{
  return GEAcompile (pattern, size, RE_SYNTAX_AWK);
}

COMPILE_FCT(Ecompile)
{
  return GEAcompile (pattern, size, RE_SYNTAX_POSIX_EGREP);
}
#endif /* !EGREP_PROGRAM */

EXECUTE_FCT(EGexecute)
{
  char const *buflim, *beg, *end, *match, *best_match, *mb_start;
  char eol = eolbyte;
  int backref, start, len, best_len;
  struct kwsmatch kwsm;
  size_t i, ret_val;
#ifdef MBS_SUPPORT
  if (MB_CUR_MAX > 1)
    {
      if (match_icase)
        {
          /* mbtolower adds a NUL byte at the end.  That will provide
	     space for the sentinel byte dfaexec may add.  */
          char *case_buf = mbtolower (buf, &size);
	  if (start_ptr)
	    start_ptr = case_buf + (start_ptr - buf);
          buf = case_buf;
        }
    }
#endif /* MBS_SUPPORT */

  mb_start = buf;
  buflim = buf + size;

  for (beg = end = buf; end < buflim; beg = end)
    {
      if (!start_ptr)
	{
	  /* We don't care about an exact match.  */
	  if (kwset)
	    {
	      /* Find a possible match using the KWset matcher. */
	      size_t offset = kwsexec (kwset, beg, buflim - beg, &kwsm);
	      if (offset == (size_t) -1)
		goto failure;
	      beg += offset;
	      /* Narrow down to the line containing the candidate, and
		 run it through DFA. */
	      if ((end = memchr(beg, eol, buflim - beg)) != NULL)
	        end++;
              else
                end = buflim;
	      match = beg;
	      while (beg > buf && beg[-1] != eol)
		--beg;
	      if (kwsm.index < kwset_exact_matches)
                {
#ifdef MBS_SUPPORT
                  if (mb_start < beg)
                    mb_start = beg;
                  if (MB_CUR_MAX == 1 || !is_mb_middle (&mb_start, match, buflim))
#endif
                    goto success;
                }
	      if (dfaexec (&dfa, beg, (char *) end, 0, NULL, &backref) == NULL)
		continue;
	    }
	  else
	    {
	      /* No good fixed strings; start with DFA. */
	      char const *next_beg = dfaexec (&dfa, beg, (char *) buflim,
					      0, NULL, &backref);
	      if (next_beg == NULL)
		break;
	      /* Narrow down to the line we've found. */
	      beg = next_beg;
	      if ((end = memchr(beg, eol, buflim - beg)) != NULL)
	        end++;
              else
                end = buflim;
	      while (beg > buf && beg[-1] != eol)
		--beg;
	    }
	  /* Successful, no backreferences encountered! */
	  if (!backref)
	    goto success;
	}
      else
	{
	  /* We are looking for the leftmost (then longest) exact match.
	     We will go through the outer loop only once.  */
	  beg = start_ptr;
	  end = buflim;
	}

      /* If we've made it to this point, this means DFA has seen
	 a probable match, and we need to run it through Regex. */
      best_match = end;
      best_len = 0;
      for (i = 0; i < pcount; i++)
	{
	  patterns[i].regexbuf.not_eol = 0;
	  if (0 <= (start = re_search (&(patterns[i].regexbuf),
				       buf, end - buf - 1,
				       beg - buf, end - beg - 1,
				       &(patterns[i].regs))))
	    {
	      len = patterns[i].regs.end[0] - start;
	      match = buf + start;
	      if (match > best_match)
		continue;
	      if (start_ptr && !match_words)
		goto assess_pattern_match;
	      if ((!match_lines && !match_words)
		  || (match_lines && len == end - beg - 1))
		{
		  match = beg;
		  len = end - beg;
		  goto assess_pattern_match;
		}
	      /* If -w, check if the match aligns with word boundaries.
		 We do this iteratively because:
		 (a) the line may contain more than one occurence of the
		 pattern, and
		 (b) Several alternatives in the pattern might be valid at a
		 given point, and we may need to consider a shorter one to
		 find a word boundary.  */
	      if (match_words)
		while (match <= best_match)
		  {
		    if ((match == buf || !WCHAR ((unsigned char) match[-1]))
			&& (len == end - beg - 1
			    || !WCHAR ((unsigned char) match[len])))
		      goto assess_pattern_match;
		    if (len > 0)
		      {
			/* Try a shorter length anchored at the same place. */
			--len;
			patterns[i].regexbuf.not_eol = 1;
			len = re_match (&(patterns[i].regexbuf),
					buf, match + len - beg, match - buf,
					&(patterns[i].regs));
		      }
		    if (len <= 0)
		      {
			/* Try looking further on. */
			if (match == end - 1)
			  break;
			match++;
			patterns[i].regexbuf.not_eol = 0;
			start = re_search (&(patterns[i].regexbuf),
					   buf, end - buf - 1,
					   match - buf, end - match - 1,
					   &(patterns[i].regs));
			if (start < 0)
			  break;
			len = patterns[i].regs.end[0] - start;
			match = buf + start;
		      }
		  } /* while (match <= best_match) */
	      continue;
	    assess_pattern_match:
	      if (!start_ptr)
		{
		  /* Good enough for a non-exact match.
		     No need to look at further patterns, if any.  */
		  beg = match;
		  goto success_in_len;
		}
	      if (match < best_match || (match == best_match && len > best_len))
		{
		  /* Best exact match:  leftmost, then longest.  */
		  best_match = match;
		  best_len = len;
		}
	    } /* if re_search >= 0 */
	} /* for Regex patterns.  */
	if (best_match < end)
	  {
	    /* We have found an exact match.  We were just
	       waiting for the best one (leftmost then longest).  */
	    beg = best_match;
	    len = best_len;
	    goto success_in_len;
	  }
    } /* for (beg = end ..) */

 failure:
  ret_val = -1;
  goto out;

 success:
  len = end - beg;
 success_in_len:
  *match_size = len;
  ret_val = beg - buf;
 out:
  return ret_val;
}
#endif /* defined(GREP_PROGRAM) || defined(EGREP_PROGRAM) */

#if defined(GREP_PROGRAM) || defined(FGREP_PROGRAM)
COMPILE_FCT(Fcompile)
{
  char const *beg, *end, *lim, *err, *pat;
  size_t psize;

  kwsinit ();
  psize = size;
  if (match_icase && MB_CUR_MAX > 1)
    pat = mbtolower (pattern, &psize);
  else
    pat = pattern;

  beg = pat;
  do
    {
      for (lim = beg;; ++lim)
	{
	  end = lim;
	  if (lim >= pat + psize)
	    break;
	 if (*lim == '\n')
	   {
	     lim++;
	     break;
	   }
#if HAVE_DOS_FILE_CONTENTS
	 if (*lim == '\r' && lim + 1 < pat + psize && lim[1] == '\n')
	   {
	     lim += 2;
	     break;
	   }
#endif
	}

      if ((err = kwsincr (kwset, beg, end - beg)) != NULL)
	error (EXIT_TROUBLE, 0, "%s", err);
      beg = lim;
    }
  while (beg < pat + psize);

  if ((err = kwsprep (kwset)) != NULL)
    error (EXIT_TROUBLE, 0, "%s", err);
}

EXECUTE_FCT(Fexecute)
{
  char const *beg, *try, *end, *mb_start;
  size_t len;
  char eol = eolbyte;
  struct kwsmatch kwsmatch;
  size_t ret_val;
#ifdef MBS_SUPPORT
  if (MB_CUR_MAX > 1)
    {
      if (match_icase)
        {
          char *case_buf = mbtolower (buf, &size);
	  if (start_ptr)
	    start_ptr = case_buf + (start_ptr - buf);
          buf = case_buf;
        }
    }
#endif /* MBS_SUPPORT */

  for (mb_start = beg = start_ptr ? start_ptr : buf; beg <= buf + size; beg++)
    {
      size_t offset = kwsexec (kwset, beg, buf + size - beg, &kwsmatch);
      if (offset == (size_t) -1)
	goto failure;
#ifdef MBS_SUPPORT
      if (MB_CUR_MAX > 1 && is_mb_middle (&mb_start, beg + offset, buf + size))
        {
          beg = mb_start - 1;
          continue; /* It is a part of multibyte character.  */
        }
#endif /* MBS_SUPPORT */
      beg += offset;
      len = kwsmatch.size[0];
      if (start_ptr && !match_words)
	goto success_in_beg_and_len;
      if (match_lines)
	{
	  if (beg > buf && beg[-1] != eol)
	    continue;
	  if (beg + len < buf + size && beg[len] != eol)
	    continue;
	  goto success;
	}
      else if (match_words)
	for (try = beg; len; )
	  {
	    if (try > buf && WCHAR((unsigned char) try[-1]))
	      break;
	    if (try + len < buf + size && WCHAR((unsigned char) try[len]))
	      {
		offset = kwsexec (kwset, beg, --len, &kwsmatch);
		if (offset == (size_t) -1)
		  break;
		try = beg + offset;
		len = kwsmatch.size[0];
	      }
	    else if (!start_ptr)
	      goto success;
	    else
	      goto success_in_beg_and_len;
	  } /* for (try) */
      else
	goto success;
    } /* for (beg in buf) */

 failure:
  ret_val = -1;
  goto out;

 success:
  if ((end = memchr (beg + len, eol, (buf + size) - (beg + len))) != NULL)
    end++;
  else
    end = buf + size;
  while (buf < beg && beg[-1] != eol)
    --beg;
  len = end - beg;
 success_in_beg_and_len:
  *match_size = len;
  ret_val = beg - buf;
 out:
  return ret_val;
}
#endif /* defined(GREP_PROGRAM) || defined(FGREP_PROGRAM) */

#ifdef GREP_PROGRAM
#if HAVE_LIBPCRE
/* Compiled internal form of a Perl regular expression.  */
static pcre *cre;

/* Additional information about the pattern.  */
static pcre_extra *extra;
#endif

COMPILE_FCT(Pcompile)
{
#if !HAVE_LIBPCRE
  error (EXIT_TROUBLE, 0, "%s",
	 _("support for the -P option is not compiled into "
	   "this --disable-perl-regexp binary"));
#else
  int e;
  char const *ep;
  char *re = xmalloc (4 * size + 7);
  int flags = PCRE_MULTILINE | (match_icase ? PCRE_CASELESS : 0);
  char const *patlim = pattern + size;
  char *n = re;
  char const *p;
  char const *pnul;

  /* FIXME: Remove these restrictions.  */
  if (memchr(pattern, '\n', size))
    error (EXIT_TROUBLE, 0, _("the -P option only supports a single pattern"));

  *n = '\0';
  if (match_lines)
    strcpy (n, "^(");
  if (match_words)
    strcpy (n, "\\b(");
  n += strlen (n);

  /* The PCRE interface doesn't allow NUL bytes in the pattern, so
     replace each NUL byte in the pattern with the four characters
     "\000", removing a preceding backslash if there are an odd
     number of backslashes before the NUL.

     FIXME: This method does not work with some multibyte character
     encodings, notably Shift-JIS, where a multibyte character can end
     in a backslash byte.  */
  for (p = pattern; (pnul = memchr (p, '\0', patlim - p)); p = pnul + 1)
    {
      memcpy (n, p, pnul - p);
      n += pnul - p;
      for (p = pnul; pattern < p && p[-1] == '\\'; p--)
	continue;
      n -= (pnul - p) & 1;
      strcpy (n, "\\000");
      n += 4;
    }

  memcpy (n, p, patlim - p);
  n += patlim - p;
  *n = '\0';
  if (match_words)
    strcpy (n, ")\\b");
  if (match_lines)
    strcpy (n, ")$");

  cre = pcre_compile (re, flags, &ep, &e, pcre_maketables ());
  if (!cre)
    error (EXIT_TROUBLE, 0, "%s", ep);

  extra = pcre_study (cre, 0, &ep);
  if (ep)
    error (EXIT_TROUBLE, 0, "%s", ep);

  free (re);
#endif
}

EXECUTE_FCT(Pexecute)
{
#if !HAVE_LIBPCRE
  abort ();
  return -1;
#else
  /* This array must have at least two elements; everything after that
     is just for performance improvement in pcre_exec.  */
  int sub[300];

  const char *line_buf, *line_end, *line_next;
  int e = PCRE_ERROR_NOMATCH;
  ptrdiff_t start_ofs = start_ptr ? start_ptr - buf : 0;

  /* PCRE can't limit the matching to single lines, therefore we have to
     match each line in the buffer separately.  */
  for (line_next = buf;
       e == PCRE_ERROR_NOMATCH && line_next < buf + size;
       start_ofs -= line_next - line_buf)
    {
      line_buf = line_next;
      line_end = memchr (line_buf, eolbyte, (buf + size) - line_buf);
      if (line_end == NULL)
        line_next = line_end = buf + size;
      else
        line_next = line_end + 1;

      if (start_ptr && start_ptr >= line_end)
        continue;

      e = pcre_exec (cre, extra, line_buf, line_end - line_buf,
                     start_ofs < 0 ? 0 : start_ofs, 0,
                     sub, sizeof sub / sizeof *sub);
    }

  if (e <= 0)
    {
      switch (e)
	{
	case PCRE_ERROR_NOMATCH:
	  return -1;

	case PCRE_ERROR_NOMEMORY:
	  error (EXIT_TROUBLE, 0, _("memory exhausted"));

	default:
	  abort ();
	}
    }
  else
    {
      /* Narrow down to the line we've found.  */
      char const *beg = line_buf + sub[0];
      char const *end = line_buf + sub[1];
      char const *buflim = buf + size;
      char eol = eolbyte;
      if (!start_ptr)
	{
	  /* FIXME: The case when '\n' is not found indicates a bug:
	     Since grep is line oriented, the match should never contain
	     a newline, so there _must_ be a newline following.
	   */
	  if (!(end = memchr (end, eol, buflim - end)))
	    end = buflim;
	  else
	    end++;
	  while (buf < beg && beg[-1] != eol)
	    --beg;
	}

      *match_size = end - beg;
      return beg - buf;
    }
#endif
}

struct matcher const matchers[] = {
  { "default", Gcompile, EGexecute },
  { "grep",    Gcompile, EGexecute },
  { "egrep",   Ecompile, EGexecute },
  { "awk",     Acompile, EGexecute },
  { "fgrep",   Fcompile, Fexecute },
  { "perl",    Pcompile, Pexecute },
  { "", 0, 0 },
};
#endif /* GREP_PROGRAM */

Spawn 1 instances, now Total 37
Counter: 38
Batcher Size:37
Preprocess the following candidate with BasicTester:
Priority 7489
At location src/search.c:237
--Src File: src/search.c
Fragment 0:
prev = (buf);
memset(&cur_state, 0, sizeof(mbstate_t));


BasicTester, a patch instance with id 8:
//src_file:src/search.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
/* search.c - searching subroutines using dfa, kwset and regex for grep.
   Copyright 1992, 1998, 2000, 2007, 2009-2010 Free Software Foundation, Inc.

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 3, or (at your option)
   any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program; if not, write to the Free Software
   Foundation, Inc., 51 Franklin Street - Fifth Floor, Boston, MA
   02110-1301, USA.  */

/* Written August 1992 by Mike Haertel. */

#include <config.h>

#include <sys/types.h>

#include "mbsupport.h"
#ifdef MBS_SUPPORT
/* We can handle multibyte strings. */
# include <wchar.h>
# include <wctype.h>
#endif

#include "system.h"
#include "grep.h"
#ifndef FGREP_PROGRAM
# include <regex.h>
# include "dfa.h"
#endif
#include "kwset.h"
#include "error.h"
#include "xalloc.h"
#ifdef HAVE_LIBPCRE
# include <pcre.h>
#endif

#define NCHAR (UCHAR_MAX + 1)

/* For -w, we also consider _ to be word constituent.  */
#define WCHAR(C) (ISALNUM(C) || (C) == '_')

/* KWset compiled pattern.  For Ecompile and Gcompile, we compile
   a list of strings, at least one of which is known to occur in
   any string matching the regexp. */
static kwset_t kwset;

static void
kwsinit (void)
{
  static char trans[NCHAR];
  int i;

  if (match_icase && MB_CUR_MAX == 1)
    {
      for (i = 0; i < NCHAR; ++i)
        trans[i] = TOLOWER (i);

      kwset = kwsalloc (trans);
    }
  else
    kwset = kwsalloc (NULL);

  if (!kwset)
    xalloc_die ();
}

#ifdef MBS_SUPPORT
/* Convert the *N-byte string, BEG, to lowercase, and write the
   NUL-terminated result into malloc'd storage.  Upon success, set *N
   to the length (in bytes) of the resulting string (not including the
   trailing NUL byte), and return a pointer to the lowercase string.
   Upon memory allocation failure, this function exits.

   Note that while this function returns a pointer to malloc'd storage,
   the caller must not free it, since this function retains a pointer
   to the buffer and reuses it on any subsequent call.  As a consequence,
   this function is not thread-safe.  */
static char *
mbtolower (const char *beg, size_t *n)
{
  static char *out;
  static size_t outalloc;
  size_t outlen, mb_cur_max;
  mbstate_t is, os;
  const char *end;
  char *p;

  if (*n > outalloc)
    {
      out = xrealloc (out, *n);
      outalloc = *n;
    }

  memset (&is, 0, sizeof (is));
  memset (&os, 0, sizeof (os));
  end = beg + *n;

  mb_cur_max = MB_CUR_MAX;
  p = out;
  outlen = 0;
  while (beg < end)
    {
      wchar_t wc;
      size_t mbclen = mbrtowc(&wc, beg, end - beg, &is);
      if (outlen + mb_cur_max >= outalloc)
        {
          out = x2nrealloc (out, &outalloc, 1);
          p = out + outlen;
        }

      if (mbclen == (size_t) -1 || mbclen == (size_t) -2 || mbclen == 0)
        {
          /* An invalid sequence, or a truncated multi-octet character.
             We treat it as a single-octet character.  */
          *p++ = *beg++;
          outlen++;
          memset (&is, 0, sizeof (is));
          memset (&os, 0, sizeof (os));
        }
      else
        {
          beg += mbclen;
          mbclen = wcrtomb (p, towlower ((wint_t) wc), &os);
          p += mbclen;
          outlen += mbclen;
        }
    }

  *n = p - out;
  *p++ = 0;
  return out;
}
#endif


#ifndef FGREP_PROGRAM
/* DFA compiled regexp. */
static struct dfa dfa;

/* The Regex compiled patterns.  */
static struct patterns
{
  /* Regex compiled regexp. */
  struct re_pattern_buffer regexbuf;
  struct re_registers regs; /* This is here on account of a BRAIN-DEAD
			       Q@#%!# library interface in regex.c.  */
} patterns0;

struct patterns *patterns;
size_t pcount;

void
dfaerror (char const *mesg)
{
  error (EXIT_TROUBLE, 0, "%s", mesg);
}

/* Number of compiled fixed strings known to exactly match the regexp.
   If kwsexec returns < kwset_exact_matches, then we don't need to
   call the regexp matcher at all. */
static int kwset_exact_matches;

static char const *
kwsincr_case (const char *must)
{
  const char *buf;
  size_t n;

  n = strlen (must);
#ifdef MBS_SUPPORT
  if (match_icase && MB_CUR_MAX > 1)
    buf = mbtolower (must, &n);
  else
#endif
    buf = must;
  return kwsincr (kwset, buf, n);
}

/* If the DFA turns out to have some set of fixed strings one of
   which must occur in the match, then we build a kwset matcher
   to find those strings, and thus quickly filter out impossible
   matches. */
static void
kwsmusts (void)
{
  struct dfamust const *dm;
  char const *err;

  if (dfa.musts)
    {
      kwsinit ();
      /* First, we compile in the substrings known to be exact
	 matches.  The kwset matcher will return the index
	 of the matching string that it chooses. */
      for (dm = dfa.musts; dm; dm = dm->next)
	{
	  if (!dm->exact)
	    continue;
	  ++kwset_exact_matches;
	  if ((err = kwsincr_case (dm->must)) != NULL)
	    error (EXIT_TROUBLE, 0, "%s", err);
	}
      /* Now, we compile the substrings that will require
	 the use of the regexp matcher.  */
      for (dm = dfa.musts; dm; dm = dm->next)
	{
	  if (dm->exact)
	    continue;
	  if ((err = kwsincr_case (dm->must)) != NULL)
	    error (EXIT_TROUBLE, 0, "%s", err);
	}
      if ((err = kwsprep (kwset)) != NULL)
	error (EXIT_TROUBLE, 0, "%s", err);
    }
}
#endif /* !FGREP_PROGRAM */

#ifdef MBS_SUPPORT

static bool
is_mb_middle(const char **good, const char *buf, const char *end)
{
  const char *p = *good;
  const char *prev = p;
  mbstate_t cur_state;

  /* TODO: can be optimized for UTF-8.  */
  
//Patch 0:
prev = (buf);
memset(&cur_state, 0, sizeof(mbstate_t));

//CodeSeg 1:
  while (p < buf)
    {
      size_t mbclen = mbrlen(p, end - p, &cur_state);

      /* Store the beginning of the previous complete multibyte character.  */
      if (mbclen != (size_t) -2)
        prev = p;

      if (mbclen == (size_t) -1 || mbclen == (size_t) -2 || mbclen == 0)
	{
	  /* An invalid sequence, or a truncated multibyte character.
	     We treat it as a single byte character.  */
	  mbclen = 1;
	}
      p += mbclen;
    }

  *good = prev;
  return p > buf;
}
#endif /* MBS_SUPPORT */

#if defined(GREP_PROGRAM) || defined(EGREP_PROGRAM)
#ifdef EGREP_PROGRAM
COMPILE_FCT(Ecompile)
{
  reg_syntax_t syntax_bits = RE_SYNTAX_POSIX_EGREP;
#else
/* No __VA_ARGS__ in C89.  So we have to do it this way.  */
static COMPILE_RET
GEAcompile (char const *pattern, size_t size, reg_syntax_t syntax_bits)
{
#endif /* EGREP_PROGRAM */
  const char *err;
  const char *p, *sep;
  size_t total = size;
  char *motif;

  if (match_icase)
    syntax_bits |= RE_ICASE;
  re_set_syntax (syntax_bits);
  dfasyntax (syntax_bits, match_icase, eolbyte);

  /* For GNU regex compiler we have to pass the patterns separately to detect
     errors like "[\nallo\n]\n".  The patterns here are "[", "allo" and "]"
     GNU regex should have raise a syntax error.  The same for backref, where
     the backref should have been local to each pattern.  */
  p = pattern;
  do
    {
      size_t len;
      sep = memchr (p, '\n', total);
      if (sep)
	{
	  len = sep - p;
	  sep++;
	  total -= (len + 1);
	}
      else
	{
	  len = total;
	  total = 0;
	}

      patterns = realloc (patterns, (pcount + 1) * sizeof (*patterns));
      if (patterns == NULL)
	error (EXIT_TROUBLE, errno, _("memory exhausted"));
      patterns[pcount] = patterns0;

      if ((err = re_compile_pattern (p, len,
				    &(patterns[pcount].regexbuf))) != NULL)
	error (EXIT_TROUBLE, 0, "%s", err);
      pcount++;

      p = sep;
    } while (sep && total != 0);

  /* In the match_words and match_lines cases, we use a different pattern
     for the DFA matcher that will quickly throw out cases that won't work.
     Then if DFA succeeds we do some hairy stuff using the regex matcher
     to decide whether the match should really count. */
  if (match_words || match_lines)
    {
      static char const line_beg_no_bk[] = "^(";
      static char const line_end_no_bk[] = ")$";
      static char const word_beg_no_bk[] = "(^|[^[:alnum:]_])(";
      static char const word_end_no_bk[] = ")([^[:alnum:]_]|$)";
#ifdef EGREP_PROGRAM
# define IF_BK(x, y) (y)
      char *n = xmalloc (sizeof word_beg_no_bk - 1 + size + sizeof word_end_no_bk);
#else
      static char const line_beg_bk[] = "^\\(";
      static char const line_end_bk[] = "\\)$";
      static char const word_beg_bk[] = "\\(^\\|[^[:alnum:]_]\\)\\(";
      static char const word_end_bk[] = "\\)\\([^[:alnum:]_]\\|$\\)";
      int bk = !(syntax_bits & RE_NO_BK_PARENS);
# define IF_BK(x, y) ((bk) ? (x) : (y))
      char *n = xmalloc (sizeof word_beg_bk - 1 + size + sizeof word_end_bk);
#endif /* EGREP_PROGRAM */

      strcpy (n, match_lines ? IF_BK(line_beg_bk, line_beg_no_bk)
			     : IF_BK(word_beg_bk, word_beg_no_bk));
      total = strlen(n);
      memcpy (n + total, pattern, size);
      total += size;
      strcpy (n + total, match_lines ? IF_BK(line_end_bk, line_end_no_bk)
				     : IF_BK(word_end_bk, word_end_no_bk));
      total += strlen (n + total);
      pattern = motif = n;
      size = total;
    }
  else
    motif = NULL;

  dfacomp (pattern, size, &dfa, 1);
  kwsmusts ();

  free(motif);
}

#ifndef EGREP_PROGRAM
COMPILE_FCT(Gcompile)
{
  return GEAcompile (pattern, size,
		     RE_SYNTAX_GREP | RE_HAT_LISTS_NOT_NEWLINE);
}

COMPILE_FCT(Acompile)
{
  return GEAcompile (pattern, size, RE_SYNTAX_AWK);
}

COMPILE_FCT(Ecompile)
{
  return GEAcompile (pattern, size, RE_SYNTAX_POSIX_EGREP);
}
#endif /* !EGREP_PROGRAM */

EXECUTE_FCT(EGexecute)
{
  char const *buflim, *beg, *end, *match, *best_match, *mb_start;
  char eol = eolbyte;
  int backref, start, len, best_len;
  struct kwsmatch kwsm;
  size_t i, ret_val;
#ifdef MBS_SUPPORT
  if (MB_CUR_MAX > 1)
    {
      if (match_icase)
        {
          /* mbtolower adds a NUL byte at the end.  That will provide
	     space for the sentinel byte dfaexec may add.  */
          char *case_buf = mbtolower (buf, &size);
	  if (start_ptr)
	    start_ptr = case_buf + (start_ptr - buf);
          buf = case_buf;
        }
    }
#endif /* MBS_SUPPORT */

  mb_start = buf;
  buflim = buf + size;

  for (beg = end = buf; end < buflim; beg = end)
    {
      if (!start_ptr)
	{
	  /* We don't care about an exact match.  */
	  if (kwset)
	    {
	      /* Find a possible match using the KWset matcher. */
	      size_t offset = kwsexec (kwset, beg, buflim - beg, &kwsm);
	      if (offset == (size_t) -1)
		goto failure;
	      beg += offset;
	      /* Narrow down to the line containing the candidate, and
		 run it through DFA. */
	      if ((end = memchr(beg, eol, buflim - beg)) != NULL)
	        end++;
              else
                end = buflim;
	      match = beg;
	      while (beg > buf && beg[-1] != eol)
		--beg;
	      if (kwsm.index < kwset_exact_matches)
                {
#ifdef MBS_SUPPORT
                  if (mb_start < beg)
                    mb_start = beg;
                  if (MB_CUR_MAX == 1 || !is_mb_middle (&mb_start, match, buflim))
#endif
                    goto success;
                }
	      if (dfaexec (&dfa, beg, (char *) end, 0, NULL, &backref) == NULL)
		continue;
	    }
	  else
	    {
	      /* No good fixed strings; start with DFA. */
	      char const *next_beg = dfaexec (&dfa, beg, (char *) buflim,
					      0, NULL, &backref);
	      if (next_beg == NULL)
		break;
	      /* Narrow down to the line we've found. */
	      beg = next_beg;
	      if ((end = memchr(beg, eol, buflim - beg)) != NULL)
	        end++;
              else
                end = buflim;
	      while (beg > buf && beg[-1] != eol)
		--beg;
	    }
	  /* Successful, no backreferences encountered! */
	  if (!backref)
	    goto success;
	}
      else
	{
	  /* We are looking for the leftmost (then longest) exact match.
	     We will go through the outer loop only once.  */
	  beg = start_ptr;
	  end = buflim;
	}

      /* If we've made it to this point, this means DFA has seen
	 a probable match, and we need to run it through Regex. */
      best_match = end;
      best_len = 0;
      for (i = 0; i < pcount; i++)
	{
	  patterns[i].regexbuf.not_eol = 0;
	  if (0 <= (start = re_search (&(patterns[i].regexbuf),
				       buf, end - buf - 1,
				       beg - buf, end - beg - 1,
				       &(patterns[i].regs))))
	    {
	      len = patterns[i].regs.end[0] - start;
	      match = buf + start;
	      if (match > best_match)
		continue;
	      if (start_ptr && !match_words)
		goto assess_pattern_match;
	      if ((!match_lines && !match_words)
		  || (match_lines && len == end - beg - 1))
		{
		  match = beg;
		  len = end - beg;
		  goto assess_pattern_match;
		}
	      /* If -w, check if the match aligns with word boundaries.
		 We do this iteratively because:
		 (a) the line may contain more than one occurence of the
		 pattern, and
		 (b) Several alternatives in the pattern might be valid at a
		 given point, and we may need to consider a shorter one to
		 find a word boundary.  */
	      if (match_words)
		while (match <= best_match)
		  {
		    if ((match == buf || !WCHAR ((unsigned char) match[-1]))
			&& (len == end - beg - 1
			    || !WCHAR ((unsigned char) match[len])))
		      goto assess_pattern_match;
		    if (len > 0)
		      {
			/* Try a shorter length anchored at the same place. */
			--len;
			patterns[i].regexbuf.not_eol = 1;
			len = re_match (&(patterns[i].regexbuf),
					buf, match + len - beg, match - buf,
					&(patterns[i].regs));
		      }
		    if (len <= 0)
		      {
			/* Try looking further on. */
			if (match == end - 1)
			  break;
			match++;
			patterns[i].regexbuf.not_eol = 0;
			start = re_search (&(patterns[i].regexbuf),
					   buf, end - buf - 1,
					   match - buf, end - match - 1,
					   &(patterns[i].regs));
			if (start < 0)
			  break;
			len = patterns[i].regs.end[0] - start;
			match = buf + start;
		      }
		  } /* while (match <= best_match) */
	      continue;
	    assess_pattern_match:
	      if (!start_ptr)
		{
		  /* Good enough for a non-exact match.
		     No need to look at further patterns, if any.  */
		  beg = match;
		  goto success_in_len;
		}
	      if (match < best_match || (match == best_match && len > best_len))
		{
		  /* Best exact match:  leftmost, then longest.  */
		  best_match = match;
		  best_len = len;
		}
	    } /* if re_search >= 0 */
	} /* for Regex patterns.  */
	if (best_match < end)
	  {
	    /* We have found an exact match.  We were just
	       waiting for the best one (leftmost then longest).  */
	    beg = best_match;
	    len = best_len;
	    goto success_in_len;
	  }
    } /* for (beg = end ..) */

 failure:
  ret_val = -1;
  goto out;

 success:
  len = end - beg;
 success_in_len:
  *match_size = len;
  ret_val = beg - buf;
 out:
  return ret_val;
}
#endif /* defined(GREP_PROGRAM) || defined(EGREP_PROGRAM) */

#if defined(GREP_PROGRAM) || defined(FGREP_PROGRAM)
COMPILE_FCT(Fcompile)
{
  char const *beg, *end, *lim, *err, *pat;
  size_t psize;

  kwsinit ();
  psize = size;
  if (match_icase && MB_CUR_MAX > 1)
    pat = mbtolower (pattern, &psize);
  else
    pat = pattern;

  beg = pat;
  do
    {
      for (lim = beg;; ++lim)
	{
	  end = lim;
	  if (lim >= pat + psize)
	    break;
	 if (*lim == '\n')
	   {
	     lim++;
	     break;
	   }
#if HAVE_DOS_FILE_CONTENTS
	 if (*lim == '\r' && lim + 1 < pat + psize && lim[1] == '\n')
	   {
	     lim += 2;
	     break;
	   }
#endif
	}

      if ((err = kwsincr (kwset, beg, end - beg)) != NULL)
	error (EXIT_TROUBLE, 0, "%s", err);
      beg = lim;
    }
  while (beg < pat + psize);

  if ((err = kwsprep (kwset)) != NULL)
    error (EXIT_TROUBLE, 0, "%s", err);
}

EXECUTE_FCT(Fexecute)
{
  char const *beg, *try, *end, *mb_start;
  size_t len;
  char eol = eolbyte;
  struct kwsmatch kwsmatch;
  size_t ret_val;
#ifdef MBS_SUPPORT
  if (MB_CUR_MAX > 1)
    {
      if (match_icase)
        {
          char *case_buf = mbtolower (buf, &size);
	  if (start_ptr)
	    start_ptr = case_buf + (start_ptr - buf);
          buf = case_buf;
        }
    }
#endif /* MBS_SUPPORT */

  for (mb_start = beg = start_ptr ? start_ptr : buf; beg <= buf + size; beg++)
    {
      size_t offset = kwsexec (kwset, beg, buf + size - beg, &kwsmatch);
      if (offset == (size_t) -1)
	goto failure;
#ifdef MBS_SUPPORT
      if (MB_CUR_MAX > 1 && is_mb_middle (&mb_start, beg + offset, buf + size))
        {
          beg = mb_start - 1;
          continue; /* It is a part of multibyte character.  */
        }
#endif /* MBS_SUPPORT */
      beg += offset;
      len = kwsmatch.size[0];
      if (start_ptr && !match_words)
	goto success_in_beg_and_len;
      if (match_lines)
	{
	  if (beg > buf && beg[-1] != eol)
	    continue;
	  if (beg + len < buf + size && beg[len] != eol)
	    continue;
	  goto success;
	}
      else if (match_words)
	for (try = beg; len; )
	  {
	    if (try > buf && WCHAR((unsigned char) try[-1]))
	      break;
	    if (try + len < buf + size && WCHAR((unsigned char) try[len]))
	      {
		offset = kwsexec (kwset, beg, --len, &kwsmatch);
		if (offset == (size_t) -1)
		  break;
		try = beg + offset;
		len = kwsmatch.size[0];
	      }
	    else if (!start_ptr)
	      goto success;
	    else
	      goto success_in_beg_and_len;
	  } /* for (try) */
      else
	goto success;
    } /* for (beg in buf) */

 failure:
  ret_val = -1;
  goto out;

 success:
  if ((end = memchr (beg + len, eol, (buf + size) - (beg + len))) != NULL)
    end++;
  else
    end = buf + size;
  while (buf < beg && beg[-1] != eol)
    --beg;
  len = end - beg;
 success_in_beg_and_len:
  *match_size = len;
  ret_val = beg - buf;
 out:
  return ret_val;
}
#endif /* defined(GREP_PROGRAM) || defined(FGREP_PROGRAM) */

#ifdef GREP_PROGRAM
#if HAVE_LIBPCRE
/* Compiled internal form of a Perl regular expression.  */
static pcre *cre;

/* Additional information about the pattern.  */
static pcre_extra *extra;
#endif

COMPILE_FCT(Pcompile)
{
#if !HAVE_LIBPCRE
  error (EXIT_TROUBLE, 0, "%s",
	 _("support for the -P option is not compiled into "
	   "this --disable-perl-regexp binary"));
#else
  int e;
  char const *ep;
  char *re = xmalloc (4 * size + 7);
  int flags = PCRE_MULTILINE | (match_icase ? PCRE_CASELESS : 0);
  char const *patlim = pattern + size;
  char *n = re;
  char const *p;
  char const *pnul;

  /* FIXME: Remove these restrictions.  */
  if (memchr(pattern, '\n', size))
    error (EXIT_TROUBLE, 0, _("the -P option only supports a single pattern"));

  *n = '\0';
  if (match_lines)
    strcpy (n, "^(");
  if (match_words)
    strcpy (n, "\\b(");
  n += strlen (n);

  /* The PCRE interface doesn't allow NUL bytes in the pattern, so
     replace each NUL byte in the pattern with the four characters
     "\000", removing a preceding backslash if there are an odd
     number of backslashes before the NUL.

     FIXME: This method does not work with some multibyte character
     encodings, notably Shift-JIS, where a multibyte character can end
     in a backslash byte.  */
  for (p = pattern; (pnul = memchr (p, '\0', patlim - p)); p = pnul + 1)
    {
      memcpy (n, p, pnul - p);
      n += pnul - p;
      for (p = pnul; pattern < p && p[-1] == '\\'; p--)
	continue;
      n -= (pnul - p) & 1;
      strcpy (n, "\\000");
      n += 4;
    }

  memcpy (n, p, patlim - p);
  n += patlim - p;
  *n = '\0';
  if (match_words)
    strcpy (n, ")\\b");
  if (match_lines)
    strcpy (n, ")$");

  cre = pcre_compile (re, flags, &ep, &e, pcre_maketables ());
  if (!cre)
    error (EXIT_TROUBLE, 0, "%s", ep);

  extra = pcre_study (cre, 0, &ep);
  if (ep)
    error (EXIT_TROUBLE, 0, "%s", ep);

  free (re);
#endif
}

EXECUTE_FCT(Pexecute)
{
#if !HAVE_LIBPCRE
  abort ();
  return -1;
#else
  /* This array must have at least two elements; everything after that
     is just for performance improvement in pcre_exec.  */
  int sub[300];

  const char *line_buf, *line_end, *line_next;
  int e = PCRE_ERROR_NOMATCH;
  ptrdiff_t start_ofs = start_ptr ? start_ptr - buf : 0;

  /* PCRE can't limit the matching to single lines, therefore we have to
     match each line in the buffer separately.  */
  for (line_next = buf;
       e == PCRE_ERROR_NOMATCH && line_next < buf + size;
       start_ofs -= line_next - line_buf)
    {
      line_buf = line_next;
      line_end = memchr (line_buf, eolbyte, (buf + size) - line_buf);
      if (line_end == NULL)
        line_next = line_end = buf + size;
      else
        line_next = line_end + 1;

      if (start_ptr && start_ptr >= line_end)
        continue;

      e = pcre_exec (cre, extra, line_buf, line_end - line_buf,
                     start_ofs < 0 ? 0 : start_ofs, 0,
                     sub, sizeof sub / sizeof *sub);
    }

  if (e <= 0)
    {
      switch (e)
	{
	case PCRE_ERROR_NOMATCH:
	  return -1;

	case PCRE_ERROR_NOMEMORY:
	  error (EXIT_TROUBLE, 0, _("memory exhausted"));

	default:
	  abort ();
	}
    }
  else
    {
      /* Narrow down to the line we've found.  */
      char const *beg = line_buf + sub[0];
      char const *end = line_buf + sub[1];
      char const *buflim = buf + size;
      char eol = eolbyte;
      if (!start_ptr)
	{
	  /* FIXME: The case when '\n' is not found indicates a bug:
	     Since grep is line oriented, the match should never contain
	     a newline, so there _must_ be a newline following.
	   */
	  if (!(end = memchr (end, eol, buflim - end)))
	    end = buflim;
	  else
	    end++;
	  while (buf < beg && beg[-1] != eol)
	    --beg;
	}

      *match_size = end - beg;
      return beg - buf;
    }
#endif
}

struct matcher const matchers[] = {
  { "default", Gcompile, EGexecute },
  { "grep",    Gcompile, EGexecute },
  { "egrep",   Ecompile, EGexecute },
  { "awk",     Acompile, EGexecute },
  { "fgrep",   Fcompile, Fexecute },
  { "perl",    Pcompile, Pexecute },
  { "", 0, 0 },
};
#endif /* GREP_PROGRAM */

Spawn 1 instances, now Total 38
Counter: 39
Batcher Size:38
Preprocess the following candidate with BasicTester:
Priority 7489
At location src/search.c:237
--Src File: src/search.c
Fragment 0:
patterns[pcount] = patterns0;
memset(&cur_state, 0, sizeof(mbstate_t));


BasicTester, a patch instance with id 9:
//src_file:src/search.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
/* search.c - searching subroutines using dfa, kwset and regex for grep.
   Copyright 1992, 1998, 2000, 2007, 2009-2010 Free Software Foundation, Inc.

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 3, or (at your option)
   any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program; if not, write to the Free Software
   Foundation, Inc., 51 Franklin Street - Fifth Floor, Boston, MA
   02110-1301, USA.  */

/* Written August 1992 by Mike Haertel. */

#include <config.h>

#include <sys/types.h>

#include "mbsupport.h"
#ifdef MBS_SUPPORT
/* We can handle multibyte strings. */
# include <wchar.h>
# include <wctype.h>
#endif

#include "system.h"
#include "grep.h"
#ifndef FGREP_PROGRAM
# include <regex.h>
# include "dfa.h"
#endif
#include "kwset.h"
#include "error.h"
#include "xalloc.h"
#ifdef HAVE_LIBPCRE
# include <pcre.h>
#endif

#define NCHAR (UCHAR_MAX + 1)

/* For -w, we also consider _ to be word constituent.  */
#define WCHAR(C) (ISALNUM(C) || (C) == '_')

/* KWset compiled pattern.  For Ecompile and Gcompile, we compile
   a list of strings, at least one of which is known to occur in
   any string matching the regexp. */
static kwset_t kwset;

static void
kwsinit (void)
{
  static char trans[NCHAR];
  int i;

  if (match_icase && MB_CUR_MAX == 1)
    {
      for (i = 0; i < NCHAR; ++i)
        trans[i] = TOLOWER (i);

      kwset = kwsalloc (trans);
    }
  else
    kwset = kwsalloc (NULL);

  if (!kwset)
    xalloc_die ();
}

#ifdef MBS_SUPPORT
/* Convert the *N-byte string, BEG, to lowercase, and write the
   NUL-terminated result into malloc'd storage.  Upon success, set *N
   to the length (in bytes) of the resulting string (not including the
   trailing NUL byte), and return a pointer to the lowercase string.
   Upon memory allocation failure, this function exits.

   Note that while this function returns a pointer to malloc'd storage,
   the caller must not free it, since this function retains a pointer
   to the buffer and reuses it on any subsequent call.  As a consequence,
   this function is not thread-safe.  */
static char *
mbtolower (const char *beg, size_t *n)
{
  static char *out;
  static size_t outalloc;
  size_t outlen, mb_cur_max;
  mbstate_t is, os;
  const char *end;
  char *p;

  if (*n > outalloc)
    {
      out = xrealloc (out, *n);
      outalloc = *n;
    }

  memset (&is, 0, sizeof (is));
  memset (&os, 0, sizeof (os));
  end = beg + *n;

  mb_cur_max = MB_CUR_MAX;
  p = out;
  outlen = 0;
  while (beg < end)
    {
      wchar_t wc;
      size_t mbclen = mbrtowc(&wc, beg, end - beg, &is);
      if (outlen + mb_cur_max >= outalloc)
        {
          out = x2nrealloc (out, &outalloc, 1);
          p = out + outlen;
        }

      if (mbclen == (size_t) -1 || mbclen == (size_t) -2 || mbclen == 0)
        {
          /* An invalid sequence, or a truncated multi-octet character.
             We treat it as a single-octet character.  */
          *p++ = *beg++;
          outlen++;
          memset (&is, 0, sizeof (is));
          memset (&os, 0, sizeof (os));
        }
      else
        {
          beg += mbclen;
          mbclen = wcrtomb (p, towlower ((wint_t) wc), &os);
          p += mbclen;
          outlen += mbclen;
        }
    }

  *n = p - out;
  *p++ = 0;
  return out;
}
#endif


#ifndef FGREP_PROGRAM
/* DFA compiled regexp. */
static struct dfa dfa;

/* The Regex compiled patterns.  */
static struct patterns
{
  /* Regex compiled regexp. */
  struct re_pattern_buffer regexbuf;
  struct re_registers regs; /* This is here on account of a BRAIN-DEAD
			       Q@#%!# library interface in regex.c.  */
} patterns0;

struct patterns *patterns;
size_t pcount;

void
dfaerror (char const *mesg)
{
  error (EXIT_TROUBLE, 0, "%s", mesg);
}

/* Number of compiled fixed strings known to exactly match the regexp.
   If kwsexec returns < kwset_exact_matches, then we don't need to
   call the regexp matcher at all. */
static int kwset_exact_matches;

static char const *
kwsincr_case (const char *must)
{
  const char *buf;
  size_t n;

  n = strlen (must);
#ifdef MBS_SUPPORT
  if (match_icase && MB_CUR_MAX > 1)
    buf = mbtolower (must, &n);
  else
#endif
    buf = must;
  return kwsincr (kwset, buf, n);
}

/* If the DFA turns out to have some set of fixed strings one of
   which must occur in the match, then we build a kwset matcher
   to find those strings, and thus quickly filter out impossible
   matches. */
static void
kwsmusts (void)
{
  struct dfamust const *dm;
  char const *err;

  if (dfa.musts)
    {
      kwsinit ();
      /* First, we compile in the substrings known to be exact
	 matches.  The kwset matcher will return the index
	 of the matching string that it chooses. */
      for (dm = dfa.musts; dm; dm = dm->next)
	{
	  if (!dm->exact)
	    continue;
	  ++kwset_exact_matches;
	  if ((err = kwsincr_case (dm->must)) != NULL)
	    error (EXIT_TROUBLE, 0, "%s", err);
	}
      /* Now, we compile the substrings that will require
	 the use of the regexp matcher.  */
      for (dm = dfa.musts; dm; dm = dm->next)
	{
	  if (dm->exact)
	    continue;
	  if ((err = kwsincr_case (dm->must)) != NULL)
	    error (EXIT_TROUBLE, 0, "%s", err);
	}
      if ((err = kwsprep (kwset)) != NULL)
	error (EXIT_TROUBLE, 0, "%s", err);
    }
}
#endif /* !FGREP_PROGRAM */

#ifdef MBS_SUPPORT

static bool
is_mb_middle(const char **good, const char *buf, const char *end)
{
  const char *p = *good;
  const char *prev = p;
  mbstate_t cur_state;

  /* TODO: can be optimized for UTF-8.  */
  
//Patch 0:
patterns[pcount] = patterns0;
memset(&cur_state, 0, sizeof(mbstate_t));

//CodeSeg 1:
  while (p < buf)
    {
      size_t mbclen = mbrlen(p, end - p, &cur_state);

      /* Store the beginning of the previous complete multibyte character.  */
      if (mbclen != (size_t) -2)
        prev = p;

      if (mbclen == (size_t) -1 || mbclen == (size_t) -2 || mbclen == 0)
	{
	  /* An invalid sequence, or a truncated multibyte character.
	     We treat it as a single byte character.  */
	  mbclen = 1;
	}
      p += mbclen;
    }

  *good = prev;
  return p > buf;
}
#endif /* MBS_SUPPORT */

#if defined(GREP_PROGRAM) || defined(EGREP_PROGRAM)
#ifdef EGREP_PROGRAM
COMPILE_FCT(Ecompile)
{
  reg_syntax_t syntax_bits = RE_SYNTAX_POSIX_EGREP;
#else
/* No __VA_ARGS__ in C89.  So we have to do it this way.  */
static COMPILE_RET
GEAcompile (char const *pattern, size_t size, reg_syntax_t syntax_bits)
{
#endif /* EGREP_PROGRAM */
  const char *err;
  const char *p, *sep;
  size_t total = size;
  char *motif;

  if (match_icase)
    syntax_bits |= RE_ICASE;
  re_set_syntax (syntax_bits);
  dfasyntax (syntax_bits, match_icase, eolbyte);

  /* For GNU regex compiler we have to pass the patterns separately to detect
     errors like "[\nallo\n]\n".  The patterns here are "[", "allo" and "]"
     GNU regex should have raise a syntax error.  The same for backref, where
     the backref should have been local to each pattern.  */
  p = pattern;
  do
    {
      size_t len;
      sep = memchr (p, '\n', total);
      if (sep)
	{
	  len = sep - p;
	  sep++;
	  total -= (len + 1);
	}
      else
	{
	  len = total;
	  total = 0;
	}

      patterns = realloc (patterns, (pcount + 1) * sizeof (*patterns));
      if (patterns == NULL)
	error (EXIT_TROUBLE, errno, _("memory exhausted"));
      patterns[pcount] = patterns0;

      if ((err = re_compile_pattern (p, len,
				    &(patterns[pcount].regexbuf))) != NULL)
	error (EXIT_TROUBLE, 0, "%s", err);
      pcount++;

      p = sep;
    } while (sep && total != 0);

  /* In the match_words and match_lines cases, we use a different pattern
     for the DFA matcher that will quickly throw out cases that won't work.
     Then if DFA succeeds we do some hairy stuff using the regex matcher
     to decide whether the match should really count. */
  if (match_words || match_lines)
    {
      static char const line_beg_no_bk[] = "^(";
      static char const line_end_no_bk[] = ")$";
      static char const word_beg_no_bk[] = "(^|[^[:alnum:]_])(";
      static char const word_end_no_bk[] = ")([^[:alnum:]_]|$)";
#ifdef EGREP_PROGRAM
# define IF_BK(x, y) (y)
      char *n = xmalloc (sizeof word_beg_no_bk - 1 + size + sizeof word_end_no_bk);
#else
      static char const line_beg_bk[] = "^\\(";
      static char const line_end_bk[] = "\\)$";
      static char const word_beg_bk[] = "\\(^\\|[^[:alnum:]_]\\)\\(";
      static char const word_end_bk[] = "\\)\\([^[:alnum:]_]\\|$\\)";
      int bk = !(syntax_bits & RE_NO_BK_PARENS);
# define IF_BK(x, y) ((bk) ? (x) : (y))
      char *n = xmalloc (sizeof word_beg_bk - 1 + size + sizeof word_end_bk);
#endif /* EGREP_PROGRAM */

      strcpy (n, match_lines ? IF_BK(line_beg_bk, line_beg_no_bk)
			     : IF_BK(word_beg_bk, word_beg_no_bk));
      total = strlen(n);
      memcpy (n + total, pattern, size);
      total += size;
      strcpy (n + total, match_lines ? IF_BK(line_end_bk, line_end_no_bk)
				     : IF_BK(word_end_bk, word_end_no_bk));
      total += strlen (n + total);
      pattern = motif = n;
      size = total;
    }
  else
    motif = NULL;

  dfacomp (pattern, size, &dfa, 1);
  kwsmusts ();

  free(motif);
}

#ifndef EGREP_PROGRAM
COMPILE_FCT(Gcompile)
{
  return GEAcompile (pattern, size,
		     RE_SYNTAX_GREP | RE_HAT_LISTS_NOT_NEWLINE);
}

COMPILE_FCT(Acompile)
{
  return GEAcompile (pattern, size, RE_SYNTAX_AWK);
}

COMPILE_FCT(Ecompile)
{
  return GEAcompile (pattern, size, RE_SYNTAX_POSIX_EGREP);
}
#endif /* !EGREP_PROGRAM */

EXECUTE_FCT(EGexecute)
{
  char const *buflim, *beg, *end, *match, *best_match, *mb_start;
  char eol = eolbyte;
  int backref, start, len, best_len;
  struct kwsmatch kwsm;
  size_t i, ret_val;
#ifdef MBS_SUPPORT
  if (MB_CUR_MAX > 1)
    {
      if (match_icase)
        {
          /* mbtolower adds a NUL byte at the end.  That will provide
	     space for the sentinel byte dfaexec may add.  */
          char *case_buf = mbtolower (buf, &size);
	  if (start_ptr)
	    start_ptr = case_buf + (start_ptr - buf);
          buf = case_buf;
        }
    }
#endif /* MBS_SUPPORT */

  mb_start = buf;
  buflim = buf + size;

  for (beg = end = buf; end < buflim; beg = end)
    {
      if (!start_ptr)
	{
	  /* We don't care about an exact match.  */
	  if (kwset)
	    {
	      /* Find a possible match using the KWset matcher. */
	      size_t offset = kwsexec (kwset, beg, buflim - beg, &kwsm);
	      if (offset == (size_t) -1)
		goto failure;
	      beg += offset;
	      /* Narrow down to the line containing the candidate, and
		 run it through DFA. */
	      if ((end = memchr(beg, eol, buflim - beg)) != NULL)
	        end++;
              else
                end = buflim;
	      match = beg;
	      while (beg > buf && beg[-1] != eol)
		--beg;
	      if (kwsm.index < kwset_exact_matches)
                {
#ifdef MBS_SUPPORT
                  if (mb_start < beg)
                    mb_start = beg;
                  if (MB_CUR_MAX == 1 || !is_mb_middle (&mb_start, match, buflim))
#endif
                    goto success;
                }
	      if (dfaexec (&dfa, beg, (char *) end, 0, NULL, &backref) == NULL)
		continue;
	    }
	  else
	    {
	      /* No good fixed strings; start with DFA. */
	      char const *next_beg = dfaexec (&dfa, beg, (char *) buflim,
					      0, NULL, &backref);
	      if (next_beg == NULL)
		break;
	      /* Narrow down to the line we've found. */
	      beg = next_beg;
	      if ((end = memchr(beg, eol, buflim - beg)) != NULL)
	        end++;
              else
                end = buflim;
	      while (beg > buf && beg[-1] != eol)
		--beg;
	    }
	  /* Successful, no backreferences encountered! */
	  if (!backref)
	    goto success;
	}
      else
	{
	  /* We are looking for the leftmost (then longest) exact match.
	     We will go through the outer loop only once.  */
	  beg = start_ptr;
	  end = buflim;
	}

      /* If we've made it to this point, this means DFA has seen
	 a probable match, and we need to run it through Regex. */
      best_match = end;
      best_len = 0;
      for (i = 0; i < pcount; i++)
	{
	  patterns[i].regexbuf.not_eol = 0;
	  if (0 <= (start = re_search (&(patterns[i].regexbuf),
				       buf, end - buf - 1,
				       beg - buf, end - beg - 1,
				       &(patterns[i].regs))))
	    {
	      len = patterns[i].regs.end[0] - start;
	      match = buf + start;
	      if (match > best_match)
		continue;
	      if (start_ptr && !match_words)
		goto assess_pattern_match;
	      if ((!match_lines && !match_words)
		  || (match_lines && len == end - beg - 1))
		{
		  match = beg;
		  len = end - beg;
		  goto assess_pattern_match;
		}
	      /* If -w, check if the match aligns with word boundaries.
		 We do this iteratively because:
		 (a) the line may contain more than one occurence of the
		 pattern, and
		 (b) Several alternatives in the pattern might be valid at a
		 given point, and we may need to consider a shorter one to
		 find a word boundary.  */
	      if (match_words)
		while (match <= best_match)
		  {
		    if ((match == buf || !WCHAR ((unsigned char) match[-1]))
			&& (len == end - beg - 1
			    || !WCHAR ((unsigned char) match[len])))
		      goto assess_pattern_match;
		    if (len > 0)
		      {
			/* Try a shorter length anchored at the same place. */
			--len;
			patterns[i].regexbuf.not_eol = 1;
			len = re_match (&(patterns[i].regexbuf),
					buf, match + len - beg, match - buf,
					&(patterns[i].regs));
		      }
		    if (len <= 0)
		      {
			/* Try looking further on. */
			if (match == end - 1)
			  break;
			match++;
			patterns[i].regexbuf.not_eol = 0;
			start = re_search (&(patterns[i].regexbuf),
					   buf, end - buf - 1,
					   match - buf, end - match - 1,
					   &(patterns[i].regs));
			if (start < 0)
			  break;
			len = patterns[i].regs.end[0] - start;
			match = buf + start;
		      }
		  } /* while (match <= best_match) */
	      continue;
	    assess_pattern_match:
	      if (!start_ptr)
		{
		  /* Good enough for a non-exact match.
		     No need to look at further patterns, if any.  */
		  beg = match;
		  goto success_in_len;
		}
	      if (match < best_match || (match == best_match && len > best_len))
		{
		  /* Best exact match:  leftmost, then longest.  */
		  best_match = match;
		  best_len = len;
		}
	    } /* if re_search >= 0 */
	} /* for Regex patterns.  */
	if (best_match < end)
	  {
	    /* We have found an exact match.  We were just
	       waiting for the best one (leftmost then longest).  */
	    beg = best_match;
	    len = best_len;
	    goto success_in_len;
	  }
    } /* for (beg = end ..) */

 failure:
  ret_val = -1;
  goto out;

 success:
  len = end - beg;
 success_in_len:
  *match_size = len;
  ret_val = beg - buf;
 out:
  return ret_val;
}
#endif /* defined(GREP_PROGRAM) || defined(EGREP_PROGRAM) */

#if defined(GREP_PROGRAM) || defined(FGREP_PROGRAM)
COMPILE_FCT(Fcompile)
{
  char const *beg, *end, *lim, *err, *pat;
  size_t psize;

  kwsinit ();
  psize = size;
  if (match_icase && MB_CUR_MAX > 1)
    pat = mbtolower (pattern, &psize);
  else
    pat = pattern;

  beg = pat;
  do
    {
      for (lim = beg;; ++lim)
	{
	  end = lim;
	  if (lim >= pat + psize)
	    break;
	 if (*lim == '\n')
	   {
	     lim++;
	     break;
	   }
#if HAVE_DOS_FILE_CONTENTS
	 if (*lim == '\r' && lim + 1 < pat + psize && lim[1] == '\n')
	   {
	     lim += 2;
	     break;
	   }
#endif
	}

      if ((err = kwsincr (kwset, beg, end - beg)) != NULL)
	error (EXIT_TROUBLE, 0, "%s", err);
      beg = lim;
    }
  while (beg < pat + psize);

  if ((err = kwsprep (kwset)) != NULL)
    error (EXIT_TROUBLE, 0, "%s", err);
}

EXECUTE_FCT(Fexecute)
{
  char const *beg, *try, *end, *mb_start;
  size_t len;
  char eol = eolbyte;
  struct kwsmatch kwsmatch;
  size_t ret_val;
#ifdef MBS_SUPPORT
  if (MB_CUR_MAX > 1)
    {
      if (match_icase)
        {
          char *case_buf = mbtolower (buf, &size);
	  if (start_ptr)
	    start_ptr = case_buf + (start_ptr - buf);
          buf = case_buf;
        }
    }
#endif /* MBS_SUPPORT */

  for (mb_start = beg = start_ptr ? start_ptr : buf; beg <= buf + size; beg++)
    {
      size_t offset = kwsexec (kwset, beg, buf + size - beg, &kwsmatch);
      if (offset == (size_t) -1)
	goto failure;
#ifdef MBS_SUPPORT
      if (MB_CUR_MAX > 1 && is_mb_middle (&mb_start, beg + offset, buf + size))
        {
          beg = mb_start - 1;
          continue; /* It is a part of multibyte character.  */
        }
#endif /* MBS_SUPPORT */
      beg += offset;
      len = kwsmatch.size[0];
      if (start_ptr && !match_words)
	goto success_in_beg_and_len;
      if (match_lines)
	{
	  if (beg > buf && beg[-1] != eol)
	    continue;
	  if (beg + len < buf + size && beg[len] != eol)
	    continue;
	  goto success;
	}
      else if (match_words)
	for (try = beg; len; )
	  {
	    if (try > buf && WCHAR((unsigned char) try[-1]))
	      break;
	    if (try + len < buf + size && WCHAR((unsigned char) try[len]))
	      {
		offset = kwsexec (kwset, beg, --len, &kwsmatch);
		if (offset == (size_t) -1)
		  break;
		try = beg + offset;
		len = kwsmatch.size[0];
	      }
	    else if (!start_ptr)
	      goto success;
	    else
	      goto success_in_beg_and_len;
	  } /* for (try) */
      else
	goto success;
    } /* for (beg in buf) */

 failure:
  ret_val = -1;
  goto out;

 success:
  if ((end = memchr (beg + len, eol, (buf + size) - (beg + len))) != NULL)
    end++;
  else
    end = buf + size;
  while (buf < beg && beg[-1] != eol)
    --beg;
  len = end - beg;
 success_in_beg_and_len:
  *match_size = len;
  ret_val = beg - buf;
 out:
  return ret_val;
}
#endif /* defined(GREP_PROGRAM) || defined(FGREP_PROGRAM) */

#ifdef GREP_PROGRAM
#if HAVE_LIBPCRE
/* Compiled internal form of a Perl regular expression.  */
static pcre *cre;

/* Additional information about the pattern.  */
static pcre_extra *extra;
#endif

COMPILE_FCT(Pcompile)
{
#if !HAVE_LIBPCRE
  error (EXIT_TROUBLE, 0, "%s",
	 _("support for the -P option is not compiled into "
	   "this --disable-perl-regexp binary"));
#else
  int e;
  char const *ep;
  char *re = xmalloc (4 * size + 7);
  int flags = PCRE_MULTILINE | (match_icase ? PCRE_CASELESS : 0);
  char const *patlim = pattern + size;
  char *n = re;
  char const *p;
  char const *pnul;

  /* FIXME: Remove these restrictions.  */
  if (memchr(pattern, '\n', size))
    error (EXIT_TROUBLE, 0, _("the -P option only supports a single pattern"));

  *n = '\0';
  if (match_lines)
    strcpy (n, "^(");
  if (match_words)
    strcpy (n, "\\b(");
  n += strlen (n);

  /* The PCRE interface doesn't allow NUL bytes in the pattern, so
     replace each NUL byte in the pattern with the four characters
     "\000", removing a preceding backslash if there are an odd
     number of backslashes before the NUL.

     FIXME: This method does not work with some multibyte character
     encodings, notably Shift-JIS, where a multibyte character can end
     in a backslash byte.  */
  for (p = pattern; (pnul = memchr (p, '\0', patlim - p)); p = pnul + 1)
    {
      memcpy (n, p, pnul - p);
      n += pnul - p;
      for (p = pnul; pattern < p && p[-1] == '\\'; p--)
	continue;
      n -= (pnul - p) & 1;
      strcpy (n, "\\000");
      n += 4;
    }

  memcpy (n, p, patlim - p);
  n += patlim - p;
  *n = '\0';
  if (match_words)
    strcpy (n, ")\\b");
  if (match_lines)
    strcpy (n, ")$");

  cre = pcre_compile (re, flags, &ep, &e, pcre_maketables ());
  if (!cre)
    error (EXIT_TROUBLE, 0, "%s", ep);

  extra = pcre_study (cre, 0, &ep);
  if (ep)
    error (EXIT_TROUBLE, 0, "%s", ep);

  free (re);
#endif
}

EXECUTE_FCT(Pexecute)
{
#if !HAVE_LIBPCRE
  abort ();
  return -1;
#else
  /* This array must have at least two elements; everything after that
     is just for performance improvement in pcre_exec.  */
  int sub[300];

  const char *line_buf, *line_end, *line_next;
  int e = PCRE_ERROR_NOMATCH;
  ptrdiff_t start_ofs = start_ptr ? start_ptr - buf : 0;

  /* PCRE can't limit the matching to single lines, therefore we have to
     match each line in the buffer separately.  */
  for (line_next = buf;
       e == PCRE_ERROR_NOMATCH && line_next < buf + size;
       start_ofs -= line_next - line_buf)
    {
      line_buf = line_next;
      line_end = memchr (line_buf, eolbyte, (buf + size) - line_buf);
      if (line_end == NULL)
        line_next = line_end = buf + size;
      else
        line_next = line_end + 1;

      if (start_ptr && start_ptr >= line_end)
        continue;

      e = pcre_exec (cre, extra, line_buf, line_end - line_buf,
                     start_ofs < 0 ? 0 : start_ofs, 0,
                     sub, sizeof sub / sizeof *sub);
    }

  if (e <= 0)
    {
      switch (e)
	{
	case PCRE_ERROR_NOMATCH:
	  return -1;

	case PCRE_ERROR_NOMEMORY:
	  error (EXIT_TROUBLE, 0, _("memory exhausted"));

	default:
	  abort ();
	}
    }
  else
    {
      /* Narrow down to the line we've found.  */
      char const *beg = line_buf + sub[0];
      char const *end = line_buf + sub[1];
      char const *buflim = buf + size;
      char eol = eolbyte;
      if (!start_ptr)
	{
	  /* FIXME: The case when '\n' is not found indicates a bug:
	     Since grep is line oriented, the match should never contain
	     a newline, so there _must_ be a newline following.
	   */
	  if (!(end = memchr (end, eol, buflim - end)))
	    end = buflim;
	  else
	    end++;
	  while (buf < beg && beg[-1] != eol)
	    --beg;
	}

      *match_size = end - beg;
      return beg - buf;
    }
#endif
}

struct matcher const matchers[] = {
  { "default", Gcompile, EGexecute },
  { "grep",    Gcompile, EGexecute },
  { "egrep",   Ecompile, EGexecute },
  { "awk",     Acompile, EGexecute },
  { "fgrep",   Fcompile, Fexecute },
  { "perl",    Pcompile, Pexecute },
  { "", 0, 0 },
};
#endif /* GREP_PROGRAM */

Spawn 1 instances, now Total 39
a batched test job starts!
Building merged code:
src_file: src/search.c
full src: int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
/* search.c - searching subroutines using dfa, kwset and regex for grep.
   Copyright 1992, 1998, 2000, 2007, 2009-2010 Free Software Foundation, Inc.

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 3, or (at your option)
   any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program; if not, write to the Free Software
   Foundation, Inc., 51 Franklin Street - Fifth Floor, Boston, MA
   02110-1301, USA.  */

/* Written August 1992 by Mike Haertel. */

#include <config.h>

#include <sys/types.h>

#include "mbsupport.h"
#ifdef MBS_SUPPORT
/* We can handle multibyte strings. */
# include <wchar.h>
# include <wctype.h>
#endif

#include "system.h"
#include "grep.h"
#ifndef FGREP_PROGRAM
# include <regex.h>
# include "dfa.h"
#endif
#include "kwset.h"
#include "error.h"
#include "xalloc.h"
#ifdef HAVE_LIBPCRE
# include <pcre.h>
#endif

#define NCHAR (UCHAR_MAX + 1)

/* For -w, we also consider _ to be word constituent.  */
#define WCHAR(C) (ISALNUM(C) || (C) == '_')

/* KWset compiled pattern.  For Ecompile and Gcompile, we compile
   a list of strings, at least one of which is known to occur in
   any string matching the regexp. */
static kwset_t kwset;

static void
kwsinit (void)
{
  static char trans[NCHAR];
  int i;

  if (match_icase && MB_CUR_MAX == 1)
    {
      for (i = 0; i < NCHAR; ++i)
        trans[i] = TOLOWER (i);

      kwset = kwsalloc (trans);
    }
  else
    kwset = kwsalloc (NULL);

  if (!kwset)
    xalloc_die ();
}

#ifdef MBS_SUPPORT
/* Convert the *N-byte string, BEG, to lowercase, and write the
   NUL-terminated result into malloc'd storage.  Upon success, set *N
   to the length (in bytes) of the resulting string (not including the
   trailing NUL byte), and return a pointer to the lowercase string.
   Upon memory allocation failure, this function exits.

   Note that while this function returns a pointer to malloc'd storage,
   the caller must not free it, since this function retains a pointer
   to the buffer and reuses it on any subsequent call.  As a consequence,
   this function is not thread-safe.  */
static char *
mbtolower (const char *beg, size_t *n)
{
  static char *out;
  static size_t outalloc;
  size_t outlen, mb_cur_max;
  mbstate_t is, os;
  const char *end;
  char *p;

  if (*n > outalloc)
    {
      out = xrealloc (out, *n);
      outalloc = *n;
    }

  memset (&is, 0, sizeof (is));
  memset (&os, 0, sizeof (os));
  end = beg + *n;

  mb_cur_max = MB_CUR_MAX;
  p = out;
  outlen = 0;
  while (beg < end)
    {
      wchar_t wc;
      size_t mbclen = mbrtowc(&wc, beg, end - beg, &is);
      if (outlen + mb_cur_max >= outalloc)
        {
          out = x2nrealloc (out, &outalloc, 1);
          p = out + outlen;
        }

      if (mbclen == (size_t) -1 || mbclen == (size_t) -2 || mbclen == 0)
        {
          /* An invalid sequence, or a truncated multi-octet character.
             We treat it as a single-octet character.  */
          *p++ = *beg++;
          outlen++;
          memset (&is, 0, sizeof (is));
          memset (&os, 0, sizeof (os));
        }
      else
        {
          beg += mbclen;
          mbclen = wcrtomb (p, towlower ((wint_t) wc), &os);
          p += mbclen;
          outlen += mbclen;
        }
    }

  *n = p - out;
  *p++ = 0;
  return out;
}
#endif


#ifndef FGREP_PROGRAM
/* DFA compiled regexp. */
static struct dfa dfa;

/* The Regex compiled patterns.  */
static struct patterns
{
  /* Regex compiled regexp. */
  struct re_pattern_buffer regexbuf;
  struct re_registers regs; /* This is here on account of a BRAIN-DEAD
			       Q@#%!# library interface in regex.c.  */
} patterns0;

struct patterns *patterns;
size_t pcount;

void
dfaerror (char const *mesg)
{
  error (EXIT_TROUBLE, 0, "%s", mesg);
}

/* Number of compiled fixed strings known to exactly match the regexp.
   If kwsexec returns < kwset_exact_matches, then we don't need to
   call the regexp matcher at all. */
static int kwset_exact_matches;

static char const *
kwsincr_case (const char *must)
{
  const char *buf;
  size_t n;

  n = strlen (must);
#ifdef MBS_SUPPORT
  if (match_icase && MB_CUR_MAX > 1)
    buf = mbtolower (must, &n);
  else
#endif
    buf = must;
  return kwsincr (kwset, buf, n);
}

/* If the DFA turns out to have some set of fixed strings one of
   which must occur in the match, then we build a kwset matcher
   to find those strings, and thus quickly filter out impossible
   matches. */
static void
kwsmusts (void)
{
  struct dfamust const *dm;
  char const *err;

  if (dfa.musts)
    {
      kwsinit ();
      /* First, we compile in the substrings known to be exact
	 matches.  The kwset matcher will return the index
	 of the matching string that it chooses. */
      for (dm = dfa.musts; dm; dm = dm->next)
	{
	  if (!dm->exact)
	    continue;
	  ++kwset_exact_matches;
	  if ((err = kwsincr_case (dm->must)) != NULL)
	    error (EXIT_TROUBLE, 0, "%s", err);
	}
      /* Now, we compile the substrings that will require
	 the use of the regexp matcher.  */
      for (dm = dfa.musts; dm; dm = dm->next)
	{
	  if (dm->exact)
	    continue;
	  if ((err = kwsincr_case (dm->must)) != NULL)
	    error (EXIT_TROUBLE, 0, "%s", err);
	}
      if ((err = kwsprep (kwset)) != NULL)
	error (EXIT_TROUBLE, 0, "%s", err);
    }
}
#endif /* !FGREP_PROGRAM */

#ifdef MBS_SUPPORT

static bool
is_mb_middle(const char **good, const char *buf, const char *end)
{
  const char *p = *good;
  const char *prev = p;
  mbstate_t cur_state;

  /* TODO: can be optimized for UTF-8.  */
  //prophet generated patch
  if (__get_mutant()==0) {
  prev = (end);
  memset(&cur_state, 0, sizeof(mbstate_t));
  }
  else if (__get_mutant()==1) {
  prev = (p);
  memset(&cur_state, 0, sizeof(mbstate_t));
  }
  else if (__get_mutant()==2) {
  xalloc_die();
  memset(&cur_state, 0, sizeof(mbstate_t));
  }
  else if (__get_mutant()==3) {
  prev = (prev);
  memset(&cur_state, 0, sizeof(mbstate_t));
  }
  else if (__get_mutant()==4) {
  prev = p;
  memset(&cur_state, 0, sizeof(mbstate_t));
  }
  else if (__get_mutant()==5) {
  kwset = kwsalloc(((void *)0));
  memset(&cur_state, 0, sizeof(mbstate_t));
  }
  else if (__get_mutant()==6) {
  patterns = realloc(patterns, (pcount + 1) * sizeof (*patterns));
  memset(&cur_state, 0, sizeof(mbstate_t));
  }
  else if (__get_mutant()==7) {
  pcount++;
  memset(&cur_state, 0, sizeof(mbstate_t));
  }
  else if (__get_mutant()==8) {
  prev = (buf);
  memset(&cur_state, 0, sizeof(mbstate_t));
  }
  else if (__get_mutant()==9) {
  patterns[pcount] = patterns0;
  memset(&cur_state, 0, sizeof(mbstate_t));
  }
  while (p < buf)
    {
      size_t mbclen = mbrlen(p, end - p, &cur_state);

      /* Store the beginning of the previous complete multibyte character.  */
      if (mbclen != (size_t) -2)
        prev = p;

      if (mbclen == (size_t) -1 || mbclen == (size_t) -2 || mbclen == 0)
	{
	  /* An invalid sequence, or a truncated multibyte character.
	     We treat it as a single byte character.  */
	  mbclen = 1;
	}
      p += mbclen;
    }

  *good = prev;
  return p > buf;
}
#endif /* MBS_SUPPORT */

#if defined(GREP_PROGRAM) || defined(EGREP_PROGRAM)
#ifdef EGREP_PROGRAM
COMPILE_FCT(Ecompile)
{
  reg_syntax_t syntax_bits = RE_SYNTAX_POSIX_EGREP;
#else
/* No __VA_ARGS__ in C89.  So we have to do it this way.  */
static COMPILE_RET
GEAcompile (char const *pattern, size_t size, reg_syntax_t syntax_bits)
{
#endif /* EGREP_PROGRAM */
  const char *err;
  const char *p, *sep;
  size_t total = size;
  char *motif;

  if (match_icase)
    syntax_bits |= RE_ICASE;
  re_set_syntax (syntax_bits);
  dfasyntax (syntax_bits, match_icase, eolbyte);

  /* For GNU regex compiler we have to pass the patterns separately to detect
     errors like "[\nallo\n]\n".  The patterns here are "[", "allo" and "]"
     GNU regex should have raise a syntax error.  The same for backref, where
     the backref should have been local to each pattern.  */
  p = pattern;
  do
    {
      size_t len;
      sep = memchr (p, '\n', total);
      if (sep)
	{
	  len = sep - p;
	  sep++;
	  total -= (len + 1);
	}
      else
	{
	  len = total;
	  total = 0;
	}

      patterns = realloc (patterns, (pcount + 1) * sizeof (*patterns));
      if (patterns == NULL)
	error (EXIT_TROUBLE, errno, _("memory exhausted"));
      patterns[pcount] = patterns0;

      if ((err = re_compile_pattern (p, len,
				    &(patterns[pcount].regexbuf))) != NULL)
	error (EXIT_TROUBLE, 0, "%s", err);
      pcount++;

      p = sep;
    } while (sep && total != 0);

  /* In the match_words and match_lines cases, we use a different pattern
     for the DFA matcher that will quickly throw out cases that won't work.
     Then if DFA succeeds we do some hairy stuff using the regex matcher
     to decide whether the match should really count. */
  if (match_words || match_lines)
    {
      static char const line_beg_no_bk[] = "^(";
      static char const line_end_no_bk[] = ")$";
      static char const word_beg_no_bk[] = "(^|[^[:alnum:]_])(";
      static char const word_end_no_bk[] = ")([^[:alnum:]_]|$)";
#ifdef EGREP_PROGRAM
# define IF_BK(x, y) (y)
      char *n = xmalloc (sizeof word_beg_no_bk - 1 + size + sizeof word_end_no_bk);
#else
      static char const line_beg_bk[] = "^\\(";
      static char const line_end_bk[] = "\\)$";
      static char const word_beg_bk[] = "\\(^\\|[^[:alnum:]_]\\)\\(";
      static char const word_end_bk[] = "\\)\\([^[:alnum:]_]\\|$\\)";
      int bk = !(syntax_bits & RE_NO_BK_PARENS);
# define IF_BK(x, y) ((bk) ? (x) : (y))
      char *n = xmalloc (sizeof word_beg_bk - 1 + size + sizeof word_end_bk);
#endif /* EGREP_PROGRAM */

      strcpy (n, match_lines ? IF_BK(line_beg_bk, line_beg_no_bk)
			     : IF_BK(word_beg_bk, word_beg_no_bk));
      total = strlen(n);
      memcpy (n + total, pattern, size);
      total += size;
      strcpy (n + total, match_lines ? IF_BK(line_end_bk, line_end_no_bk)
				     : IF_BK(word_end_bk, word_end_no_bk));
      total += strlen (n + total);
      pattern = motif = n;
      size = total;
    }
  else
    motif = NULL;

  dfacomp (pattern, size, &dfa, 1);
  kwsmusts ();

  free(motif);
}

#ifndef EGREP_PROGRAM
COMPILE_FCT(Gcompile)
{
  return GEAcompile (pattern, size,
		     RE_SYNTAX_GREP | RE_HAT_LISTS_NOT_NEWLINE);
}

COMPILE_FCT(Acompile)
{
  return GEAcompile (pattern, size, RE_SYNTAX_AWK);
}

COMPILE_FCT(Ecompile)
{
  return GEAcompile (pattern, size, RE_SYNTAX_POSIX_EGREP);
}
#endif /* !EGREP_PROGRAM */

EXECUTE_FCT(EGexecute)
{
  char const *buflim, *beg, *end, *match, *best_match, *mb_start;
  char eol = eolbyte;
  int backref, start, len, best_len;
  struct kwsmatch kwsm;
  size_t i, ret_val;
#ifdef MBS_SUPPORT
  if (MB_CUR_MAX > 1)
    {
      if (match_icase)
        {
          /* mbtolower adds a NUL byte at the end.  That will provide
	     space for the sentinel byte dfaexec may add.  */
          char *case_buf = mbtolower (buf, &size);
	  if (start_ptr)
	    start_ptr = case_buf + (start_ptr - buf);
          buf = case_buf;
        }
    }
#endif /* MBS_SUPPORT */

  mb_start = buf;
  buflim = buf + size;

  for (beg = end = buf; end < buflim; beg = end)
    {
      if (!start_ptr)
	{
	  /* We don't care about an exact match.  */
	  if (kwset)
	    {
	      /* Find a possible match using the KWset matcher. */
	      size_t offset = kwsexec (kwset, beg, buflim - beg, &kwsm);
	      if (offset == (size_t) -1)
		goto failure;
	      beg += offset;
	      /* Narrow down to the line containing the candidate, and
		 run it through DFA. */
	      if ((end = memchr(beg, eol, buflim - beg)) != NULL)
	        end++;
              else
                end = buflim;
	      match = beg;
	      while (beg > buf && beg[-1] != eol)
		--beg;
	      if (kwsm.index < kwset_exact_matches)
                {
#ifdef MBS_SUPPORT
                  if (mb_start < beg)
                    mb_start = beg;
                  if (MB_CUR_MAX == 1 || !is_mb_middle (&mb_start, match, buflim))
#endif
                    goto success;
                }
	      if (dfaexec (&dfa, beg, (char *) end, 0, NULL, &backref) == NULL)
		continue;
	    }
	  else
	    {
	      /* No good fixed strings; start with DFA. */
	      char const *next_beg = dfaexec (&dfa, beg, (char *) buflim,
					      0, NULL, &backref);
	      if (next_beg == NULL)
		break;
	      /* Narrow down to the line we've found. */
	      beg = next_beg;
	      if ((end = memchr(beg, eol, buflim - beg)) != NULL)
	        end++;
              else
                end = buflim;
	      while (beg > buf && beg[-1] != eol)
		--beg;
	    }
	  /* Successful, no backreferences encountered! */
	  if (!backref)
	    goto success;
	}
      else
	{
	  /* We are looking for the leftmost (then longest) exact match.
	     We will go through the outer loop only once.  */
	  beg = start_ptr;
	  end = buflim;
	}

      /* If we've made it to this point, this means DFA has seen
	 a probable match, and we need to run it through Regex. */
      best_match = end;
      best_len = 0;
      for (i = 0; i < pcount; i++)
	{
	  patterns[i].regexbuf.not_eol = 0;
	  if (0 <= (start = re_search (&(patterns[i].regexbuf),
				       buf, end - buf - 1,
				       beg - buf, end - beg - 1,
				       &(patterns[i].regs))))
	    {
	      len = patterns[i].regs.end[0] - start;
	      match = buf + start;
	      if (match > best_match)
		continue;
	      if (start_ptr && !match_words)
		goto assess_pattern_match;
	      if ((!match_lines && !match_words)
		  || (match_lines && len == end - beg - 1))
		{
		  match = beg;
		  len = end - beg;
		  goto assess_pattern_match;
		}
	      /* If -w, check if the match aligns with word boundaries.
		 We do this iteratively because:
		 (a) the line may contain more than one occurence of the
		 pattern, and
		 (b) Several alternatives in the pattern might be valid at a
		 given point, and we may need to consider a shorter one to
		 find a word boundary.  */
	      if (match_words)
		while (match <= best_match)
		  {
		    if ((match == buf || !WCHAR ((unsigned char) match[-1]))
			&& (len == end - beg - 1
			    || !WCHAR ((unsigned char) match[len])))
		      goto assess_pattern_match;
		    if (len > 0)
		      {
			/* Try a shorter length anchored at the same place. */
			--len;
			patterns[i].regexbuf.not_eol = 1;
			len = re_match (&(patterns[i].regexbuf),
					buf, match + len - beg, match - buf,
					&(patterns[i].regs));
		      }
		    if (len <= 0)
		      {
			/* Try looking further on. */
			if (match == end - 1)
			  break;
			match++;
			patterns[i].regexbuf.not_eol = 0;
			start = re_search (&(patterns[i].regexbuf),
					   buf, end - buf - 1,
					   match - buf, end - match - 1,
					   &(patterns[i].regs));
			if (start < 0)
			  break;
			len = patterns[i].regs.end[0] - start;
			match = buf + start;
		      }
		  } /* while (match <= best_match) */
	      continue;
	    assess_pattern_match:
	      if (!start_ptr)
		{
		  /* Good enough for a non-exact match.
		     No need to look at further patterns, if any.  */
		  beg = match;
		  goto success_in_len;
		}
	      if (match < best_match || (match == best_match && len > best_len))
		{
		  /* Best exact match:  leftmost, then longest.  */
		  best_match = match;
		  best_len = len;
		}
	    } /* if re_search >= 0 */
	} /* for Regex patterns.  */
	if (best_match < end)
	  {
	    /* We have found an exact match.  We were just
	       waiting for the best one (leftmost then longest).  */
	    beg = best_match;
	    len = best_len;
	    goto success_in_len;
	  }
    } /* for (beg = end ..) */

 failure:
  ret_val = -1;
  goto out;

 success:
  len = end - beg;
 success_in_len:
  *match_size = len;
  ret_val = beg - buf;
 out:
  return ret_val;
}
#endif /* defined(GREP_PROGRAM) || defined(EGREP_PROGRAM) */

#if defined(GREP_PROGRAM) || defined(FGREP_PROGRAM)
COMPILE_FCT(Fcompile)
{
  char const *beg, *end, *lim, *err, *pat;
  size_t psize;

  kwsinit ();
  psize = size;
  if (match_icase && MB_CUR_MAX > 1)
    pat = mbtolower (pattern, &psize);
  else
    pat = pattern;

  beg = pat;
  do
    {
      for (lim = beg;; ++lim)
	{
	  end = lim;
	  if (lim >= pat + psize)
	    break;
	 if (*lim == '\n')
	   {
	     lim++;
	     break;
	   }
#if HAVE_DOS_FILE_CONTENTS
	 if (*lim == '\r' && lim + 1 < pat + psize && lim[1] == '\n')
	   {
	     lim += 2;
	     break;
	   }
#endif
	}

      if ((err = kwsincr (kwset, beg, end - beg)) != NULL)
	error (EXIT_TROUBLE, 0, "%s", err);
      beg = lim;
    }
  while (beg < pat + psize);

  if ((err = kwsprep (kwset)) != NULL)
    error (EXIT_TROUBLE, 0, "%s", err);
}

EXECUTE_FCT(Fexecute)
{
  char const *beg, *try, *end, *mb_start;
  size_t len;
  char eol = eolbyte;
  struct kwsmatch kwsmatch;
  size_t ret_val;
#ifdef MBS_SUPPORT
  if (MB_CUR_MAX > 1)
    {
      if (match_icase)
        {
          char *case_buf = mbtolower (buf, &size);
	  if (start_ptr)
	    start_ptr = case_buf + (start_ptr - buf);
          buf = case_buf;
        }
    }
#endif /* MBS_SUPPORT */

  for (mb_start = beg = start_ptr ? start_ptr : buf; beg <= buf + size; beg++)
    {
      size_t offset = kwsexec (kwset, beg, buf + size - beg, &kwsmatch);
      if (offset == (size_t) -1)
	goto failure;
#ifdef MBS_SUPPORT
      if (MB_CUR_MAX > 1 && is_mb_middle (&mb_start, beg + offset, buf + size))
        {
          beg = mb_start - 1;
          continue; /* It is a part of multibyte character.  */
        }
#endif /* MBS_SUPPORT */
      beg += offset;
      len = kwsmatch.size[0];
      if (start_ptr && !match_words)
	goto success_in_beg_and_len;
      if (match_lines)
	{
	  if (beg > buf && beg[-1] != eol)
	    continue;
	  if (beg + len < buf + size && beg[len] != eol)
	    continue;
	  goto success;
	}
      else if (match_words)
	for (try = beg; len; )
	  {
	    if (try > buf && WCHAR((unsigned char) try[-1]))
	      break;
	    if (try + len < buf + size && WCHAR((unsigned char) try[len]))
	      {
		offset = kwsexec (kwset, beg, --len, &kwsmatch);
		if (offset == (size_t) -1)
		  break;
		try = beg + offset;
		len = kwsmatch.size[0];
	      }
	    else if (!start_ptr)
	      goto success;
	    else
	      goto success_in_beg_and_len;
	  } /* for (try) */
      else
	goto success;
    } /* for (beg in buf) */

 failure:
  ret_val = -1;
  goto out;

 success:
  if ((end = memchr (beg + len, eol, (buf + size) - (beg + len))) != NULL)
    end++;
  else
    end = buf + size;
  while (buf < beg && beg[-1] != eol)
    --beg;
  len = end - beg;
 success_in_beg_and_len:
  *match_size = len;
  ret_val = beg - buf;
 out:
  return ret_val;
}
#endif /* defined(GREP_PROGRAM) || defined(FGREP_PROGRAM) */

#ifdef GREP_PROGRAM
#if HAVE_LIBPCRE
/* Compiled internal form of a Perl regular expression.  */
static pcre *cre;

/* Additional information about the pattern.  */
static pcre_extra *extra;
#endif

COMPILE_FCT(Pcompile)
{
#if !HAVE_LIBPCRE
  error (EXIT_TROUBLE, 0, "%s",
	 _("support for the -P option is not compiled into "
	   "this --disable-perl-regexp binary"));
#else
  int e;
  char const *ep;
  char *re = xmalloc (4 * size + 7);
  int flags = PCRE_MULTILINE | (match_icase ? PCRE_CASELESS : 0);
  char const *patlim = pattern + size;
  char *n = re;
  char const *p;
  char const *pnul;

  /* FIXME: Remove these restrictions.  */
  if (memchr(pattern, '\n', size))
    error (EXIT_TROUBLE, 0, _("the -P option only supports a single pattern"));

  *n = '\0';
  if (match_lines)
    strcpy (n, "^(");
  if (match_words)
    strcpy (n, "\\b(");
  n += strlen (n);

  /* The PCRE interface doesn't allow NUL bytes in the pattern, so
     replace each NUL byte in the pattern with the four characters
     "\000", removing a preceding backslash if there are an odd
     number of backslashes before the NUL.

     FIXME: This method does not work with some multibyte character
     encodings, notably Shift-JIS, where a multibyte character can end
     in a backslash byte.  */
  for (p = pattern; (pnul = memchr (p, '\0', patlim - p)); p = pnul + 1)
    {
      memcpy (n, p, pnul - p);
      n += pnul - p;
      for (p = pnul; pattern < p && p[-1] == '\\'; p--)
	continue;
      n -= (pnul - p) & 1;
      strcpy (n, "\\000");
      n += 4;
    }

  memcpy (n, p, patlim - p);
  n += patlim - p;
  *n = '\0';
  if (match_words)
    strcpy (n, ")\\b");
  if (match_lines)
    strcpy (n, ")$");

  cre = pcre_compile (re, flags, &ep, &e, pcre_maketables ());
  if (!cre)
    error (EXIT_TROUBLE, 0, "%s", ep);

  extra = pcre_study (cre, 0, &ep);
  if (ep)
    error (EXIT_TROUBLE, 0, "%s", ep);

  free (re);
#endif
}

EXECUTE_FCT(Pexecute)
{
#if !HAVE_LIBPCRE
  abort ();
  return -1;
#else
  /* This array must have at least two elements; everything after that
     is just for performance improvement in pcre_exec.  */
  int sub[300];

  const char *line_buf, *line_end, *line_next;
  int e = PCRE_ERROR_NOMATCH;
  ptrdiff_t start_ofs = start_ptr ? start_ptr - buf : 0;

  /* PCRE can't limit the matching to single lines, therefore we have to
     match each line in the buffer separately.  */
  for (line_next = buf;
       e == PCRE_ERROR_NOMATCH && line_next < buf + size;
       start_ofs -= line_next - line_buf)
    {
      line_buf = line_next;
      line_end = memchr (line_buf, eolbyte, (buf + size) - line_buf);
      if (line_end == NULL)
        line_next = line_end = buf + size;
      else
        line_next = line_end + 1;

      if (start_ptr && start_ptr >= line_end)
        continue;

      e = pcre_exec (cre, extra, line_buf, line_end - line_buf,
                     start_ofs < 0 ? 0 : start_ofs, 0,
                     sub, sizeof sub / sizeof *sub);
    }

  if (e <= 0)
    {
      switch (e)
	{
	case PCRE_ERROR_NOMATCH:
	  return -1;

	case PCRE_ERROR_NOMEMORY:
	  error (EXIT_TROUBLE, 0, _("memory exhausted"));

	default:
	  abort ();
	}
    }
  else
    {
      /* Narrow down to the line we've found.  */
      char const *beg = line_buf + sub[0];
      char const *end = line_buf + sub[1];
      char const *buflim = buf + size;
      char eol = eolbyte;
      if (!start_ptr)
	{
	  /* FIXME: The case when '\n' is not found indicates a bug:
	     Since grep is line oriented, the match should never contain
	     a newline, so there _must_ be a newline following.
	   */
	  if (!(end = memchr (end, eol, buflim - end)))
	    end = buflim;
	  else
	    end++;
	  while (buf < beg && beg[-1] != eol)
	    --beg;
	}

      *match_size = end - beg;
      return beg - buf;
    }
#endif
}

struct matcher const matchers[] = {
  { "default", Gcompile, EGexecute },
  { "grep",    Gcompile, EGexecute },
  { "egrep",   Ecompile, EGexecute },
  { "awk",     Acompile, EGexecute },
  { "fgrep",   Fcompile, Fexecute },
  { "perl",    Pcompile, Pexecute },
  { "", 0, 0 },
};
#endif /* GREP_PROGRAM */

Building:src at:
/home/ubuntu/spr-fast/tests/corebench/grep/grep-case-deccad69-db9d6340/tempworkdir2/srcMerged code building failed! Going to build saperately!
Building:src at:
/home/ubuntu/spr-fast/tests/corebench/grep/grep-case-deccad69-db9d6340/tempworkdir2/srcBasicTester, Testing instance id 0:
//src_file:src/search.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
/* search.c - searching subroutines using dfa, kwset and regex for grep.
   Copyright 1992, 1998, 2000, 2007, 2009-2010 Free Software Foundation, Inc.

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 3, or (at your option)
   any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program; if not, write to the Free Software
   Foundation, Inc., 51 Franklin Street - Fifth Floor, Boston, MA
   02110-1301, USA.  */

/* Written August 1992 by Mike Haertel. */

#include <config.h>

#include <sys/types.h>

#include "mbsupport.h"
#ifdef MBS_SUPPORT
/* We can handle multibyte strings. */
# include <wchar.h>
# include <wctype.h>
#endif

#include "system.h"
#include "grep.h"
#ifndef FGREP_PROGRAM
# include <regex.h>
# include "dfa.h"
#endif
#include "kwset.h"
#include "error.h"
#include "xalloc.h"
#ifdef HAVE_LIBPCRE
# include <pcre.h>
#endif

#define NCHAR (UCHAR_MAX + 1)

/* For -w, we also consider _ to be word constituent.  */
#define WCHAR(C) (ISALNUM(C) || (C) == '_')

/* KWset compiled pattern.  For Ecompile and Gcompile, we compile
   a list of strings, at least one of which is known to occur in
   any string matching the regexp. */
static kwset_t kwset;

static void
kwsinit (void)
{
  static char trans[NCHAR];
  int i;

  if (match_icase && MB_CUR_MAX == 1)
    {
      for (i = 0; i < NCHAR; ++i)
        trans[i] = TOLOWER (i);

      kwset = kwsalloc (trans);
    }
  else
    kwset = kwsalloc (NULL);

  if (!kwset)
    xalloc_die ();
}

#ifdef MBS_SUPPORT
/* Convert the *N-byte string, BEG, to lowercase, and write the
   NUL-terminated result into malloc'd storage.  Upon success, set *N
   to the length (in bytes) of the resulting string (not including the
   trailing NUL byte), and return a pointer to the lowercase string.
   Upon memory allocation failure, this function exits.

   Note that while this function returns a pointer to malloc'd storage,
   the caller must not free it, since this function retains a pointer
   to the buffer and reuses it on any subsequent call.  As a consequence,
   this function is not thread-safe.  */
static char *
mbtolower (const char *beg, size_t *n)
{
  static char *out;
  static size_t outalloc;
  size_t outlen, mb_cur_max;
  mbstate_t is, os;
  const char *end;
  char *p;

  if (*n > outalloc)
    {
      out = xrealloc (out, *n);
      outalloc = *n;
    }

  memset (&is, 0, sizeof (is));
  memset (&os, 0, sizeof (os));
  end = beg + *n;

  mb_cur_max = MB_CUR_MAX;
  p = out;
  outlen = 0;
  while (beg < end)
    {
      wchar_t wc;
      size_t mbclen = mbrtowc(&wc, beg, end - beg, &is);
      if (outlen + mb_cur_max >= outalloc)
        {
          out = x2nrealloc (out, &outalloc, 1);
          p = out + outlen;
        }

      if (mbclen == (size_t) -1 || mbclen == (size_t) -2 || mbclen == 0)
        {
          /* An invalid sequence, or a truncated multi-octet character.
             We treat it as a single-octet character.  */
          *p++ = *beg++;
          outlen++;
          memset (&is, 0, sizeof (is));
          memset (&os, 0, sizeof (os));
        }
      else
        {
          beg += mbclen;
          mbclen = wcrtomb (p, towlower ((wint_t) wc), &os);
          p += mbclen;
          outlen += mbclen;
        }
    }

  *n = p - out;
  *p++ = 0;
  return out;
}
#endif


#ifndef FGREP_PROGRAM
/* DFA compiled regexp. */
static struct dfa dfa;

/* The Regex compiled patterns.  */
static struct patterns
{
  /* Regex compiled regexp. */
  struct re_pattern_buffer regexbuf;
  struct re_registers regs; /* This is here on account of a BRAIN-DEAD
			       Q@#%!# library interface in regex.c.  */
} patterns0;

struct patterns *patterns;
size_t pcount;

void
dfaerror (char const *mesg)
{
  error (EXIT_TROUBLE, 0, "%s", mesg);
}

/* Number of compiled fixed strings known to exactly match the regexp.
   If kwsexec returns < kwset_exact_matches, then we don't need to
   call the regexp matcher at all. */
static int kwset_exact_matches;

static char const *
kwsincr_case (const char *must)
{
  const char *buf;
  size_t n;

  n = strlen (must);
#ifdef MBS_SUPPORT
  if (match_icase && MB_CUR_MAX > 1)
    buf = mbtolower (must, &n);
  else
#endif
    buf = must;
  return kwsincr (kwset, buf, n);
}

/* If the DFA turns out to have some set of fixed strings one of
   which must occur in the match, then we build a kwset matcher
   to find those strings, and thus quickly filter out impossible
   matches. */
static void
kwsmusts (void)
{
  struct dfamust const *dm;
  char const *err;

  if (dfa.musts)
    {
      kwsinit ();
      /* First, we compile in the substrings known to be exact
	 matches.  The kwset matcher will return the index
	 of the matching string that it chooses. */
      for (dm = dfa.musts; dm; dm = dm->next)
	{
	  if (!dm->exact)
	    continue;
	  ++kwset_exact_matches;
	  if ((err = kwsincr_case (dm->must)) != NULL)
	    error (EXIT_TROUBLE, 0, "%s", err);
	}
      /* Now, we compile the substrings that will require
	 the use of the regexp matcher.  */
      for (dm = dfa.musts; dm; dm = dm->next)
	{
	  if (dm->exact)
	    continue;
	  if ((err = kwsincr_case (dm->must)) != NULL)
	    error (EXIT_TROUBLE, 0, "%s", err);
	}
      if ((err = kwsprep (kwset)) != NULL)
	error (EXIT_TROUBLE, 0, "%s", err);
    }
}
#endif /* !FGREP_PROGRAM */

#ifdef MBS_SUPPORT

static bool
is_mb_middle(const char **good, const char *buf, const char *end)
{
  const char *p = *good;
  const char *prev = p;
  mbstate_t cur_state;

  /* TODO: can be optimized for UTF-8.  */
  
//Patch 0:
prev = (end);
memset(&cur_state, 0, sizeof(mbstate_t));

//CodeSeg 1:
  while (p < buf)
    {
      size_t mbclen = mbrlen(p, end - p, &cur_state);

      /* Store the beginning of the previous complete multibyte character.  */
      if (mbclen != (size_t) -2)
        prev = p;

      if (mbclen == (size_t) -1 || mbclen == (size_t) -2 || mbclen == 0)
	{
	  /* An invalid sequence, or a truncated multibyte character.
	     We treat it as a single byte character.  */
	  mbclen = 1;
	}
      p += mbclen;
    }

  *good = prev;
  return p > buf;
}
#endif /* MBS_SUPPORT */

#if defined(GREP_PROGRAM) || defined(EGREP_PROGRAM)
#ifdef EGREP_PROGRAM
COMPILE_FCT(Ecompile)
{
  reg_syntax_t syntax_bits = RE_SYNTAX_POSIX_EGREP;
#else
/* No __VA_ARGS__ in C89.  So we have to do it this way.  */
static COMPILE_RET
GEAcompile (char const *pattern, size_t size, reg_syntax_t syntax_bits)
{
#endif /* EGREP_PROGRAM */
  const char *err;
  const char *p, *sep;
  size_t total = size;
  char *motif;

  if (match_icase)
    syntax_bits |= RE_ICASE;
  re_set_syntax (syntax_bits);
  dfasyntax (syntax_bits, match_icase, eolbyte);

  /* For GNU regex compiler we have to pass the patterns separately to detect
     errors like "[\nallo\n]\n".  The patterns here are "[", "allo" and "]"
     GNU regex should have raise a syntax error.  The same for backref, where
     the backref should have been local to each pattern.  */
  p = pattern;
  do
    {
      size_t len;
      sep = memchr (p, '\n', total);
      if (sep)
	{
	  len = sep - p;
	  sep++;
	  total -= (len + 1);
	}
      else
	{
	  len = total;
	  total = 0;
	}

      patterns = realloc (patterns, (pcount + 1) * sizeof (*patterns));
      if (patterns == NULL)
	error (EXIT_TROUBLE, errno, _("memory exhausted"));
      patterns[pcount] = patterns0;

      if ((err = re_compile_pattern (p, len,
				    &(patterns[pcount].regexbuf))) != NULL)
	error (EXIT_TROUBLE, 0, "%s", err);
      pcount++;

      p = sep;
    } while (sep && total != 0);

  /* In the match_words and match_lines cases, we use a different pattern
     for the DFA matcher that will quickly throw out cases that won't work.
     Then if DFA succeeds we do some hairy stuff using the regex matcher
     to decide whether the match should really count. */
  if (match_words || match_lines)
    {
      static char const line_beg_no_bk[] = "^(";
      static char const line_end_no_bk[] = ")$";
      static char const word_beg_no_bk[] = "(^|[^[:alnum:]_])(";
      static char const word_end_no_bk[] = ")([^[:alnum:]_]|$)";
#ifdef EGREP_PROGRAM
# define IF_BK(x, y) (y)
      char *n = xmalloc (sizeof word_beg_no_bk - 1 + size + sizeof word_end_no_bk);
#else
      static char const line_beg_bk[] = "^\\(";
      static char const line_end_bk[] = "\\)$";
      static char const word_beg_bk[] = "\\(^\\|[^[:alnum:]_]\\)\\(";
      static char const word_end_bk[] = "\\)\\([^[:alnum:]_]\\|$\\)";
      int bk = !(syntax_bits & RE_NO_BK_PARENS);
# define IF_BK(x, y) ((bk) ? (x) : (y))
      char *n = xmalloc (sizeof word_beg_bk - 1 + size + sizeof word_end_bk);
#endif /* EGREP_PROGRAM */

      strcpy (n, match_lines ? IF_BK(line_beg_bk, line_beg_no_bk)
			     : IF_BK(word_beg_bk, word_beg_no_bk));
      total = strlen(n);
      memcpy (n + total, pattern, size);
      total += size;
      strcpy (n + total, match_lines ? IF_BK(line_end_bk, line_end_no_bk)
				     : IF_BK(word_end_bk, word_end_no_bk));
      total += strlen (n + total);
      pattern = motif = n;
      size = total;
    }
  else
    motif = NULL;

  dfacomp (pattern, size, &dfa, 1);
  kwsmusts ();

  free(motif);
}

#ifndef EGREP_PROGRAM
COMPILE_FCT(Gcompile)
{
  return GEAcompile (pattern, size,
		     RE_SYNTAX_GREP | RE_HAT_LISTS_NOT_NEWLINE);
}

COMPILE_FCT(Acompile)
{
  return GEAcompile (pattern, size, RE_SYNTAX_AWK);
}

COMPILE_FCT(Ecompile)
{
  return GEAcompile (pattern, size, RE_SYNTAX_POSIX_EGREP);
}
#endif /* !EGREP_PROGRAM */

EXECUTE_FCT(EGexecute)
{
  char const *buflim, *beg, *end, *match, *best_match, *mb_start;
  char eol = eolbyte;
  int backref, start, len, best_len;
  struct kwsmatch kwsm;
  size_t i, ret_val;
#ifdef MBS_SUPPORT
  if (MB_CUR_MAX > 1)
    {
      if (match_icase)
        {
          /* mbtolower adds a NUL byte at the end.  That will provide
	     space for the sentinel byte dfaexec may add.  */
          char *case_buf = mbtolower (buf, &size);
	  if (start_ptr)
	    start_ptr = case_buf + (start_ptr - buf);
          buf = case_buf;
        }
    }
#endif /* MBS_SUPPORT */

  mb_start = buf;
  buflim = buf + size;

  for (beg = end = buf; end < buflim; beg = end)
    {
      if (!start_ptr)
	{
	  /* We don't care about an exact match.  */
	  if (kwset)
	    {
	      /* Find a possible match using the KWset matcher. */
	      size_t offset = kwsexec (kwset, beg, buflim - beg, &kwsm);
	      if (offset == (size_t) -1)
		goto failure;
	      beg += offset;
	      /* Narrow down to the line containing the candidate, and
		 run it through DFA. */
	      if ((end = memchr(beg, eol, buflim - beg)) != NULL)
	        end++;
              else
                end = buflim;
	      match = beg;
	      while (beg > buf && beg[-1] != eol)
		--beg;
	      if (kwsm.index < kwset_exact_matches)
                {
#ifdef MBS_SUPPORT
                  if (mb_start < beg)
                    mb_start = beg;
                  if (MB_CUR_MAX == 1 || !is_mb_middle (&mb_start, match, buflim))
#endif
                    goto success;
                }
	      if (dfaexec (&dfa, beg, (char *) end, 0, NULL, &backref) == NULL)
		continue;
	    }
	  else
	    {
	      /* No good fixed strings; start with DFA. */
	      char const *next_beg = dfaexec (&dfa, beg, (char *) buflim,
					      0, NULL, &backref);
	      if (next_beg == NULL)
		break;
	      /* Narrow down to the line we've found. */
	      beg = next_beg;
	      if ((end = memchr(beg, eol, buflim - beg)) != NULL)
	        end++;
              else
                end = buflim;
	      while (beg > buf && beg[-1] != eol)
		--beg;
	    }
	  /* Successful, no backreferences encountered! */
	  if (!backref)
	    goto success;
	}
      else
	{
	  /* We are looking for the leftmost (then longest) exact match.
	     We will go through the outer loop only once.  */
	  beg = start_ptr;
	  end = buflim;
	}

      /* If we've made it to this point, this means DFA has seen
	 a probable match, and we need to run it through Regex. */
      best_match = end;
      best_len = 0;
      for (i = 0; i < pcount; i++)
	{
	  patterns[i].regexbuf.not_eol = 0;
	  if (0 <= (start = re_search (&(patterns[i].regexbuf),
				       buf, end - buf - 1,
				       beg - buf, end - beg - 1,
				       &(patterns[i].regs))))
	    {
	      len = patterns[i].regs.end[0] - start;
	      match = buf + start;
	      if (match > best_match)
		continue;
	      if (start_ptr && !match_words)
		goto assess_pattern_match;
	      if ((!match_lines && !match_words)
		  || (match_lines && len == end - beg - 1))
		{
		  match = beg;
		  len = end - beg;
		  goto assess_pattern_match;
		}
	      /* If -w, check if the match aligns with word boundaries.
		 We do this iteratively because:
		 (a) the line may contain more than one occurence of the
		 pattern, and
		 (b) Several alternatives in the pattern might be valid at a
		 given point, and we may need to consider a shorter one to
		 find a word boundary.  */
	      if (match_words)
		while (match <= best_match)
		  {
		    if ((match == buf || !WCHAR ((unsigned char) match[-1]))
			&& (len == end - beg - 1
			    || !WCHAR ((unsigned char) match[len])))
		      goto assess_pattern_match;
		    if (len > 0)
		      {
			/* Try a shorter length anchored at the same place. */
			--len;
			patterns[i].regexbuf.not_eol = 1;
			len = re_match (&(patterns[i].regexbuf),
					buf, match + len - beg, match - buf,
					&(patterns[i].regs));
		      }
		    if (len <= 0)
		      {
			/* Try looking further on. */
			if (match == end - 1)
			  break;
			match++;
			patterns[i].regexbuf.not_eol = 0;
			start = re_search (&(patterns[i].regexbuf),
					   buf, end - buf - 1,
					   match - buf, end - match - 1,
					   &(patterns[i].regs));
			if (start < 0)
			  break;
			len = patterns[i].regs.end[0] - start;
			match = buf + start;
		      }
		  } /* while (match <= best_match) */
	      continue;
	    assess_pattern_match:
	      if (!start_ptr)
		{
		  /* Good enough for a non-exact match.
		     No need to look at further patterns, if any.  */
		  beg = match;
		  goto success_in_len;
		}
	      if (match < best_match || (match == best_match && len > best_len))
		{
		  /* Best exact match:  leftmost, then longest.  */
		  best_match = match;
		  best_len = len;
		}
	    } /* if re_search >= 0 */
	} /* for Regex patterns.  */
	if (best_match < end)
	  {
	    /* We have found an exact match.  We were just
	       waiting for the best one (leftmost then longest).  */
	    beg = best_match;
	    len = best_len;
	    goto success_in_len;
	  }
    } /* for (beg = end ..) */

 failure:
  ret_val = -1;
  goto out;

 success:
  len = end - beg;
 success_in_len:
  *match_size = len;
  ret_val = beg - buf;
 out:
  return ret_val;
}
#endif /* defined(GREP_PROGRAM) || defined(EGREP_PROGRAM) */

#if defined(GREP_PROGRAM) || defined(FGREP_PROGRAM)
COMPILE_FCT(Fcompile)
{
  char const *beg, *end, *lim, *err, *pat;
  size_t psize;

  kwsinit ();
  psize = size;
  if (match_icase && MB_CUR_MAX > 1)
    pat = mbtolower (pattern, &psize);
  else
    pat = pattern;

  beg = pat;
  do
    {
      for (lim = beg;; ++lim)
	{
	  end = lim;
	  if (lim >= pat + psize)
	    break;
	 if (*lim == '\n')
	   {
	     lim++;
	     break;
	   }
#if HAVE_DOS_FILE_CONTENTS
	 if (*lim == '\r' && lim + 1 < pat + psize && lim[1] == '\n')
	   {
	     lim += 2;
	     break;
	   }
#endif
	}

      if ((err = kwsincr (kwset, beg, end - beg)) != NULL)
	error (EXIT_TROUBLE, 0, "%s", err);
      beg = lim;
    }
  while (beg < pat + psize);

  if ((err = kwsprep (kwset)) != NULL)
    error (EXIT_TROUBLE, 0, "%s", err);
}

EXECUTE_FCT(Fexecute)
{
  char const *beg, *try, *end, *mb_start;
  size_t len;
  char eol = eolbyte;
  struct kwsmatch kwsmatch;
  size_t ret_val;
#ifdef MBS_SUPPORT
  if (MB_CUR_MAX > 1)
    {
      if (match_icase)
        {
          char *case_buf = mbtolower (buf, &size);
	  if (start_ptr)
	    start_ptr = case_buf + (start_ptr - buf);
          buf = case_buf;
        }
    }
#endif /* MBS_SUPPORT */

  for (mb_start = beg = start_ptr ? start_ptr : buf; beg <= buf + size; beg++)
    {
      size_t offset = kwsexec (kwset, beg, buf + size - beg, &kwsmatch);
      if (offset == (size_t) -1)
	goto failure;
#ifdef MBS_SUPPORT
      if (MB_CUR_MAX > 1 && is_mb_middle (&mb_start, beg + offset, buf + size))
        {
          beg = mb_start - 1;
          continue; /* It is a part of multibyte character.  */
        }
#endif /* MBS_SUPPORT */
      beg += offset;
      len = kwsmatch.size[0];
      if (start_ptr && !match_words)
	goto success_in_beg_and_len;
      if (match_lines)
	{
	  if (beg > buf && beg[-1] != eol)
	    continue;
	  if (beg + len < buf + size && beg[len] != eol)
	    continue;
	  goto success;
	}
      else if (match_words)
	for (try = beg; len; )
	  {
	    if (try > buf && WCHAR((unsigned char) try[-1]))
	      break;
	    if (try + len < buf + size && WCHAR((unsigned char) try[len]))
	      {
		offset = kwsexec (kwset, beg, --len, &kwsmatch);
		if (offset == (size_t) -1)
		  break;
		try = beg + offset;
		len = kwsmatch.size[0];
	      }
	    else if (!start_ptr)
	      goto success;
	    else
	      goto success_in_beg_and_len;
	  } /* for (try) */
      else
	goto success;
    } /* for (beg in buf) */

 failure:
  ret_val = -1;
  goto out;

 success:
  if ((end = memchr (beg + len, eol, (buf + size) - (beg + len))) != NULL)
    end++;
  else
    end = buf + size;
  while (buf < beg && beg[-1] != eol)
    --beg;
  len = end - beg;
 success_in_beg_and_len:
  *match_size = len;
  ret_val = beg - buf;
 out:
  return ret_val;
}
#endif /* defined(GREP_PROGRAM) || defined(FGREP_PROGRAM) */

#ifdef GREP_PROGRAM
#if HAVE_LIBPCRE
/* Compiled internal form of a Perl regular expression.  */
static pcre *cre;

/* Additional information about the pattern.  */
static pcre_extra *extra;
#endif

COMPILE_FCT(Pcompile)
{
#if !HAVE_LIBPCRE
  error (EXIT_TROUBLE, 0, "%s",
	 _("support for the -P option is not compiled into "
	   "this --disable-perl-regexp binary"));
#else
  int e;
  char const *ep;
  char *re = xmalloc (4 * size + 7);
  int flags = PCRE_MULTILINE | (match_icase ? PCRE_CASELESS : 0);
  char const *patlim = pattern + size;
  char *n = re;
  char const *p;
  char const *pnul;

  /* FIXME: Remove these restrictions.  */
  if (memchr(pattern, '\n', size))
    error (EXIT_TROUBLE, 0, _("the -P option only supports a single pattern"));

  *n = '\0';
  if (match_lines)
    strcpy (n, "^(");
  if (match_words)
    strcpy (n, "\\b(");
  n += strlen (n);

  /* The PCRE interface doesn't allow NUL bytes in the pattern, so
     replace each NUL byte in the pattern with the four characters
     "\000", removing a preceding backslash if there are an odd
     number of backslashes before the NUL.

     FIXME: This method does not work with some multibyte character
     encodings, notably Shift-JIS, where a multibyte character can end
     in a backslash byte.  */
  for (p = pattern; (pnul = memchr (p, '\0', patlim - p)); p = pnul + 1)
    {
      memcpy (n, p, pnul - p);
      n += pnul - p;
      for (p = pnul; pattern < p && p[-1] == '\\'; p--)
	continue;
      n -= (pnul - p) & 1;
      strcpy (n, "\\000");
      n += 4;
    }

  memcpy (n, p, patlim - p);
  n += patlim - p;
  *n = '\0';
  if (match_words)
    strcpy (n, ")\\b");
  if (match_lines)
    strcpy (n, ")$");

  cre = pcre_compile (re, flags, &ep, &e, pcre_maketables ());
  if (!cre)
    error (EXIT_TROUBLE, 0, "%s", ep);

  extra = pcre_study (cre, 0, &ep);
  if (ep)
    error (EXIT_TROUBLE, 0, "%s", ep);

  free (re);
#endif
}

EXECUTE_FCT(Pexecute)
{
#if !HAVE_LIBPCRE
  abort ();
  return -1;
#else
  /* This array must have at least two elements; everything after that
     is just for performance improvement in pcre_exec.  */
  int sub[300];

  const char *line_buf, *line_end, *line_next;
  int e = PCRE_ERROR_NOMATCH;
  ptrdiff_t start_ofs = start_ptr ? start_ptr - buf : 0;

  /* PCRE can't limit the matching to single lines, therefore we have to
     match each line in the buffer separately.  */
  for (line_next = buf;
       e == PCRE_ERROR_NOMATCH && line_next < buf + size;
       start_ofs -= line_next - line_buf)
    {
      line_buf = line_next;
      line_end = memchr (line_buf, eolbyte, (buf + size) - line_buf);
      if (line_end == NULL)
        line_next = line_end = buf + size;
      else
        line_next = line_end + 1;

      if (start_ptr && start_ptr >= line_end)
        continue;

      e = pcre_exec (cre, extra, line_buf, line_end - line_buf,
                     start_ofs < 0 ? 0 : start_ofs, 0,
                     sub, sizeof sub / sizeof *sub);
    }

  if (e <= 0)
    {
      switch (e)
	{
	case PCRE_ERROR_NOMATCH:
	  return -1;

	case PCRE_ERROR_NOMEMORY:
	  error (EXIT_TROUBLE, 0, _("memory exhausted"));

	default:
	  abort ();
	}
    }
  else
    {
      /* Narrow down to the line we've found.  */
      char const *beg = line_buf + sub[0];
      char const *end = line_buf + sub[1];
      char const *buflim = buf + size;
      char eol = eolbyte;
      if (!start_ptr)
	{
	  /* FIXME: The case when '\n' is not found indicates a bug:
	     Since grep is line oriented, the match should never contain
	     a newline, so there _must_ be a newline following.
	   */
	  if (!(end = memchr (end, eol, buflim - end)))
	    end = buflim;
	  else
	    end++;
	  while (buf < beg && beg[-1] != eol)
	    --beg;
	}

      *match_size = end - beg;
      return beg - buf;
    }
#endif
}

struct matcher const matchers[] = {
  { "default", Gcompile, EGexecute },
  { "grep",    Gcompile, EGexecute },
  { "egrep",   Ecompile, EGexecute },
  { "awk",     Acompile, EGexecute },
  { "fgrep",   Fcompile, Fexecute },
  { "perl",    Pcompile, Pexecute },
  { "", 0, 0 },
};
#endif /* GREP_PROGRAM */

Testing negative cases!
Running test command:
/home/ubuntu/spr-fast/tools/grep-test.py /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-deccad69-db9d6340/tempworkdir2/src /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-deccad69-db9d6340/tempworkdir2/tests /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-deccad69-db9d6340/tempworkdir2 0  > __res
Building:src at:
/home/ubuntu/spr-fast/tests/corebench/grep/grep-case-deccad69-db9d6340/tempworkdir2/srcBasicTester, Testing instance id 1:
//src_file:src/search.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
/* search.c - searching subroutines using dfa, kwset and regex for grep.
   Copyright 1992, 1998, 2000, 2007, 2009-2010 Free Software Foundation, Inc.

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 3, or (at your option)
   any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program; if not, write to the Free Software
   Foundation, Inc., 51 Franklin Street - Fifth Floor, Boston, MA
   02110-1301, USA.  */

/* Written August 1992 by Mike Haertel. */

#include <config.h>

#include <sys/types.h>

#include "mbsupport.h"
#ifdef MBS_SUPPORT
/* We can handle multibyte strings. */
# include <wchar.h>
# include <wctype.h>
#endif

#include "system.h"
#include "grep.h"
#ifndef FGREP_PROGRAM
# include <regex.h>
# include "dfa.h"
#endif
#include "kwset.h"
#include "error.h"
#include "xalloc.h"
#ifdef HAVE_LIBPCRE
# include <pcre.h>
#endif

#define NCHAR (UCHAR_MAX + 1)

/* For -w, we also consider _ to be word constituent.  */
#define WCHAR(C) (ISALNUM(C) || (C) == '_')

/* KWset compiled pattern.  For Ecompile and Gcompile, we compile
   a list of strings, at least one of which is known to occur in
   any string matching the regexp. */
static kwset_t kwset;

static void
kwsinit (void)
{
  static char trans[NCHAR];
  int i;

  if (match_icase && MB_CUR_MAX == 1)
    {
      for (i = 0; i < NCHAR; ++i)
        trans[i] = TOLOWER (i);

      kwset = kwsalloc (trans);
    }
  else
    kwset = kwsalloc (NULL);

  if (!kwset)
    xalloc_die ();
}

#ifdef MBS_SUPPORT
/* Convert the *N-byte string, BEG, to lowercase, and write the
   NUL-terminated result into malloc'd storage.  Upon success, set *N
   to the length (in bytes) of the resulting string (not including the
   trailing NUL byte), and return a pointer to the lowercase string.
   Upon memory allocation failure, this function exits.

   Note that while this function returns a pointer to malloc'd storage,
   the caller must not free it, since this function retains a pointer
   to the buffer and reuses it on any subsequent call.  As a consequence,
   this function is not thread-safe.  */
static char *
mbtolower (const char *beg, size_t *n)
{
  static char *out;
  static size_t outalloc;
  size_t outlen, mb_cur_max;
  mbstate_t is, os;
  const char *end;
  char *p;

  if (*n > outalloc)
    {
      out = xrealloc (out, *n);
      outalloc = *n;
    }

  memset (&is, 0, sizeof (is));
  memset (&os, 0, sizeof (os));
  end = beg + *n;

  mb_cur_max = MB_CUR_MAX;
  p = out;
  outlen = 0;
  while (beg < end)
    {
      wchar_t wc;
      size_t mbclen = mbrtowc(&wc, beg, end - beg, &is);
      if (outlen + mb_cur_max >= outalloc)
        {
          out = x2nrealloc (out, &outalloc, 1);
          p = out + outlen;
        }

      if (mbclen == (size_t) -1 || mbclen == (size_t) -2 || mbclen == 0)
        {
          /* An invalid sequence, or a truncated multi-octet character.
             We treat it as a single-octet character.  */
          *p++ = *beg++;
          outlen++;
          memset (&is, 0, sizeof (is));
          memset (&os, 0, sizeof (os));
        }
      else
        {
          beg += mbclen;
          mbclen = wcrtomb (p, towlower ((wint_t) wc), &os);
          p += mbclen;
          outlen += mbclen;
        }
    }

  *n = p - out;
  *p++ = 0;
  return out;
}
#endif


#ifndef FGREP_PROGRAM
/* DFA compiled regexp. */
static struct dfa dfa;

/* The Regex compiled patterns.  */
static struct patterns
{
  /* Regex compiled regexp. */
  struct re_pattern_buffer regexbuf;
  struct re_registers regs; /* This is here on account of a BRAIN-DEAD
			       Q@#%!# library interface in regex.c.  */
} patterns0;

struct patterns *patterns;
size_t pcount;

void
dfaerror (char const *mesg)
{
  error (EXIT_TROUBLE, 0, "%s", mesg);
}

/* Number of compiled fixed strings known to exactly match the regexp.
   If kwsexec returns < kwset_exact_matches, then we don't need to
   call the regexp matcher at all. */
static int kwset_exact_matches;

static char const *
kwsincr_case (const char *must)
{
  const char *buf;
  size_t n;

  n = strlen (must);
#ifdef MBS_SUPPORT
  if (match_icase && MB_CUR_MAX > 1)
    buf = mbtolower (must, &n);
  else
#endif
    buf = must;
  return kwsincr (kwset, buf, n);
}

/* If the DFA turns out to have some set of fixed strings one of
   which must occur in the match, then we build a kwset matcher
   to find those strings, and thus quickly filter out impossible
   matches. */
static void
kwsmusts (void)
{
  struct dfamust const *dm;
  char const *err;

  if (dfa.musts)
    {
      kwsinit ();
      /* First, we compile in the substrings known to be exact
	 matches.  The kwset matcher will return the index
	 of the matching string that it chooses. */
      for (dm = dfa.musts; dm; dm = dm->next)
	{
	  if (!dm->exact)
	    continue;
	  ++kwset_exact_matches;
	  if ((err = kwsincr_case (dm->must)) != NULL)
	    error (EXIT_TROUBLE, 0, "%s", err);
	}
      /* Now, we compile the substrings that will require
	 the use of the regexp matcher.  */
      for (dm = dfa.musts; dm; dm = dm->next)
	{
	  if (dm->exact)
	    continue;
	  if ((err = kwsincr_case (dm->must)) != NULL)
	    error (EXIT_TROUBLE, 0, "%s", err);
	}
      if ((err = kwsprep (kwset)) != NULL)
	error (EXIT_TROUBLE, 0, "%s", err);
    }
}
#endif /* !FGREP_PROGRAM */

#ifdef MBS_SUPPORT

static bool
is_mb_middle(const char **good, const char *buf, const char *end)
{
  const char *p = *good;
  const char *prev = p;
  mbstate_t cur_state;

  /* TODO: can be optimized for UTF-8.  */
  
//Patch 0:
prev = (p);
memset(&cur_state, 0, sizeof(mbstate_t));

//CodeSeg 1:
  while (p < buf)
    {
      size_t mbclen = mbrlen(p, end - p, &cur_state);

      /* Store the beginning of the previous complete multibyte character.  */
      if (mbclen != (size_t) -2)
        prev = p;

      if (mbclen == (size_t) -1 || mbclen == (size_t) -2 || mbclen == 0)
	{
	  /* An invalid sequence, or a truncated multibyte character.
	     We treat it as a single byte character.  */
	  mbclen = 1;
	}
      p += mbclen;
    }

  *good = prev;
  return p > buf;
}
#endif /* MBS_SUPPORT */

#if defined(GREP_PROGRAM) || defined(EGREP_PROGRAM)
#ifdef EGREP_PROGRAM
COMPILE_FCT(Ecompile)
{
  reg_syntax_t syntax_bits = RE_SYNTAX_POSIX_EGREP;
#else
/* No __VA_ARGS__ in C89.  So we have to do it this way.  */
static COMPILE_RET
GEAcompile (char const *pattern, size_t size, reg_syntax_t syntax_bits)
{
#endif /* EGREP_PROGRAM */
  const char *err;
  const char *p, *sep;
  size_t total = size;
  char *motif;

  if (match_icase)
    syntax_bits |= RE_ICASE;
  re_set_syntax (syntax_bits);
  dfasyntax (syntax_bits, match_icase, eolbyte);

  /* For GNU regex compiler we have to pass the patterns separately to detect
     errors like "[\nallo\n]\n".  The patterns here are "[", "allo" and "]"
     GNU regex should have raise a syntax error.  The same for backref, where
     the backref should have been local to each pattern.  */
  p = pattern;
  do
    {
      size_t len;
      sep = memchr (p, '\n', total);
      if (sep)
	{
	  len = sep - p;
	  sep++;
	  total -= (len + 1);
	}
      else
	{
	  len = total;
	  total = 0;
	}

      patterns = realloc (patterns, (pcount + 1) * sizeof (*patterns));
      if (patterns == NULL)
	error (EXIT_TROUBLE, errno, _("memory exhausted"));
      patterns[pcount] = patterns0;

      if ((err = re_compile_pattern (p, len,
				    &(patterns[pcount].regexbuf))) != NULL)
	error (EXIT_TROUBLE, 0, "%s", err);
      pcount++;

      p = sep;
    } while (sep && total != 0);

  /* In the match_words and match_lines cases, we use a different pattern
     for the DFA matcher that will quickly throw out cases that won't work.
     Then if DFA succeeds we do some hairy stuff using the regex matcher
     to decide whether the match should really count. */
  if (match_words || match_lines)
    {
      static char const line_beg_no_bk[] = "^(";
      static char const line_end_no_bk[] = ")$";
      static char const word_beg_no_bk[] = "(^|[^[:alnum:]_])(";
      static char const word_end_no_bk[] = ")([^[:alnum:]_]|$)";
#ifdef EGREP_PROGRAM
# define IF_BK(x, y) (y)
      char *n = xmalloc (sizeof word_beg_no_bk - 1 + size + sizeof word_end_no_bk);
#else
      static char const line_beg_bk[] = "^\\(";
      static char const line_end_bk[] = "\\)$";
      static char const word_beg_bk[] = "\\(^\\|[^[:alnum:]_]\\)\\(";
      static char const word_end_bk[] = "\\)\\([^[:alnum:]_]\\|$\\)";
      int bk = !(syntax_bits & RE_NO_BK_PARENS);
# define IF_BK(x, y) ((bk) ? (x) : (y))
      char *n = xmalloc (sizeof word_beg_bk - 1 + size + sizeof word_end_bk);
#endif /* EGREP_PROGRAM */

      strcpy (n, match_lines ? IF_BK(line_beg_bk, line_beg_no_bk)
			     : IF_BK(word_beg_bk, word_beg_no_bk));
      total = strlen(n);
      memcpy (n + total, pattern, size);
      total += size;
      strcpy (n + total, match_lines ? IF_BK(line_end_bk, line_end_no_bk)
				     : IF_BK(word_end_bk, word_end_no_bk));
      total += strlen (n + total);
      pattern = motif = n;
      size = total;
    }
  else
    motif = NULL;

  dfacomp (pattern, size, &dfa, 1);
  kwsmusts ();

  free(motif);
}

#ifndef EGREP_PROGRAM
COMPILE_FCT(Gcompile)
{
  return GEAcompile (pattern, size,
		     RE_SYNTAX_GREP | RE_HAT_LISTS_NOT_NEWLINE);
}

COMPILE_FCT(Acompile)
{
  return GEAcompile (pattern, size, RE_SYNTAX_AWK);
}

COMPILE_FCT(Ecompile)
{
  return GEAcompile (pattern, size, RE_SYNTAX_POSIX_EGREP);
}
#endif /* !EGREP_PROGRAM */

EXECUTE_FCT(EGexecute)
{
  char const *buflim, *beg, *end, *match, *best_match, *mb_start;
  char eol = eolbyte;
  int backref, start, len, best_len;
  struct kwsmatch kwsm;
  size_t i, ret_val;
#ifdef MBS_SUPPORT
  if (MB_CUR_MAX > 1)
    {
      if (match_icase)
        {
          /* mbtolower adds a NUL byte at the end.  That will provide
	     space for the sentinel byte dfaexec may add.  */
          char *case_buf = mbtolower (buf, &size);
	  if (start_ptr)
	    start_ptr = case_buf + (start_ptr - buf);
          buf = case_buf;
        }
    }
#endif /* MBS_SUPPORT */

  mb_start = buf;
  buflim = buf + size;

  for (beg = end = buf; end < buflim; beg = end)
    {
      if (!start_ptr)
	{
	  /* We don't care about an exact match.  */
	  if (kwset)
	    {
	      /* Find a possible match using the KWset matcher. */
	      size_t offset = kwsexec (kwset, beg, buflim - beg, &kwsm);
	      if (offset == (size_t) -1)
		goto failure;
	      beg += offset;
	      /* Narrow down to the line containing the candidate, and
		 run it through DFA. */
	      if ((end = memchr(beg, eol, buflim - beg)) != NULL)
	        end++;
              else
                end = buflim;
	      match = beg;
	      while (beg > buf && beg[-1] != eol)
		--beg;
	      if (kwsm.index < kwset_exact_matches)
                {
#ifdef MBS_SUPPORT
                  if (mb_start < beg)
                    mb_start = beg;
                  if (MB_CUR_MAX == 1 || !is_mb_middle (&mb_start, match, buflim))
#endif
                    goto success;
                }
	      if (dfaexec (&dfa, beg, (char *) end, 0, NULL, &backref) == NULL)
		continue;
	    }
	  else
	    {
	      /* No good fixed strings; start with DFA. */
	      char const *next_beg = dfaexec (&dfa, beg, (char *) buflim,
					      0, NULL, &backref);
	      if (next_beg == NULL)
		break;
	      /* Narrow down to the line we've found. */
	      beg = next_beg;
	      if ((end = memchr(beg, eol, buflim - beg)) != NULL)
	        end++;
              else
                end = buflim;
	      while (beg > buf && beg[-1] != eol)
		--beg;
	    }
	  /* Successful, no backreferences encountered! */
	  if (!backref)
	    goto success;
	}
      else
	{
	  /* We are looking for the leftmost (then longest) exact match.
	     We will go through the outer loop only once.  */
	  beg = start_ptr;
	  end = buflim;
	}

      /* If we've made it to this point, this means DFA has seen
	 a probable match, and we need to run it through Regex. */
      best_match = end;
      best_len = 0;
      for (i = 0; i < pcount; i++)
	{
	  patterns[i].regexbuf.not_eol = 0;
	  if (0 <= (start = re_search (&(patterns[i].regexbuf),
				       buf, end - buf - 1,
				       beg - buf, end - beg - 1,
				       &(patterns[i].regs))))
	    {
	      len = patterns[i].regs.end[0] - start;
	      match = buf + start;
	      if (match > best_match)
		continue;
	      if (start_ptr && !match_words)
		goto assess_pattern_match;
	      if ((!match_lines && !match_words)
		  || (match_lines && len == end - beg - 1))
		{
		  match = beg;
		  len = end - beg;
		  goto assess_pattern_match;
		}
	      /* If -w, check if the match aligns with word boundaries.
		 We do this iteratively because:
		 (a) the line may contain more than one occurence of the
		 pattern, and
		 (b) Several alternatives in the pattern might be valid at a
		 given point, and we may need to consider a shorter one to
		 find a word boundary.  */
	      if (match_words)
		while (match <= best_match)
		  {
		    if ((match == buf || !WCHAR ((unsigned char) match[-1]))
			&& (len == end - beg - 1
			    || !WCHAR ((unsigned char) match[len])))
		      goto assess_pattern_match;
		    if (len > 0)
		      {
			/* Try a shorter length anchored at the same place. */
			--len;
			patterns[i].regexbuf.not_eol = 1;
			len = re_match (&(patterns[i].regexbuf),
					buf, match + len - beg, match - buf,
					&(patterns[i].regs));
		      }
		    if (len <= 0)
		      {
			/* Try looking further on. */
			if (match == end - 1)
			  break;
			match++;
			patterns[i].regexbuf.not_eol = 0;
			start = re_search (&(patterns[i].regexbuf),
					   buf, end - buf - 1,
					   match - buf, end - match - 1,
					   &(patterns[i].regs));
			if (start < 0)
			  break;
			len = patterns[i].regs.end[0] - start;
			match = buf + start;
		      }
		  } /* while (match <= best_match) */
	      continue;
	    assess_pattern_match:
	      if (!start_ptr)
		{
		  /* Good enough for a non-exact match.
		     No need to look at further patterns, if any.  */
		  beg = match;
		  goto success_in_len;
		}
	      if (match < best_match || (match == best_match && len > best_len))
		{
		  /* Best exact match:  leftmost, then longest.  */
		  best_match = match;
		  best_len = len;
		}
	    } /* if re_search >= 0 */
	} /* for Regex patterns.  */
	if (best_match < end)
	  {
	    /* We have found an exact match.  We were just
	       waiting for the best one (leftmost then longest).  */
	    beg = best_match;
	    len = best_len;
	    goto success_in_len;
	  }
    } /* for (beg = end ..) */

 failure:
  ret_val = -1;
  goto out;

 success:
  len = end - beg;
 success_in_len:
  *match_size = len;
  ret_val = beg - buf;
 out:
  return ret_val;
}
#endif /* defined(GREP_PROGRAM) || defined(EGREP_PROGRAM) */

#if defined(GREP_PROGRAM) || defined(FGREP_PROGRAM)
COMPILE_FCT(Fcompile)
{
  char const *beg, *end, *lim, *err, *pat;
  size_t psize;

  kwsinit ();
  psize = size;
  if (match_icase && MB_CUR_MAX > 1)
    pat = mbtolower (pattern, &psize);
  else
    pat = pattern;

  beg = pat;
  do
    {
      for (lim = beg;; ++lim)
	{
	  end = lim;
	  if (lim >= pat + psize)
	    break;
	 if (*lim == '\n')
	   {
	     lim++;
	     break;
	   }
#if HAVE_DOS_FILE_CONTENTS
	 if (*lim == '\r' && lim + 1 < pat + psize && lim[1] == '\n')
	   {
	     lim += 2;
	     break;
	   }
#endif
	}

      if ((err = kwsincr (kwset, beg, end - beg)) != NULL)
	error (EXIT_TROUBLE, 0, "%s", err);
      beg = lim;
    }
  while (beg < pat + psize);

  if ((err = kwsprep (kwset)) != NULL)
    error (EXIT_TROUBLE, 0, "%s", err);
}

EXECUTE_FCT(Fexecute)
{
  char const *beg, *try, *end, *mb_start;
  size_t len;
  char eol = eolbyte;
  struct kwsmatch kwsmatch;
  size_t ret_val;
#ifdef MBS_SUPPORT
  if (MB_CUR_MAX > 1)
    {
      if (match_icase)
        {
          char *case_buf = mbtolower (buf, &size);
	  if (start_ptr)
	    start_ptr = case_buf + (start_ptr - buf);
          buf = case_buf;
        }
    }
#endif /* MBS_SUPPORT */

  for (mb_start = beg = start_ptr ? start_ptr : buf; beg <= buf + size; beg++)
    {
      size_t offset = kwsexec (kwset, beg, buf + size - beg, &kwsmatch);
      if (offset == (size_t) -1)
	goto failure;
#ifdef MBS_SUPPORT
      if (MB_CUR_MAX > 1 && is_mb_middle (&mb_start, beg + offset, buf + size))
        {
          beg = mb_start - 1;
          continue; /* It is a part of multibyte character.  */
        }
#endif /* MBS_SUPPORT */
      beg += offset;
      len = kwsmatch.size[0];
      if (start_ptr && !match_words)
	goto success_in_beg_and_len;
      if (match_lines)
	{
	  if (beg > buf && beg[-1] != eol)
	    continue;
	  if (beg + len < buf + size && beg[len] != eol)
	    continue;
	  goto success;
	}
      else if (match_words)
	for (try = beg; len; )
	  {
	    if (try > buf && WCHAR((unsigned char) try[-1]))
	      break;
	    if (try + len < buf + size && WCHAR((unsigned char) try[len]))
	      {
		offset = kwsexec (kwset, beg, --len, &kwsmatch);
		if (offset == (size_t) -1)
		  break;
		try = beg + offset;
		len = kwsmatch.size[0];
	      }
	    else if (!start_ptr)
	      goto success;
	    else
	      goto success_in_beg_and_len;
	  } /* for (try) */
      else
	goto success;
    } /* for (beg in buf) */

 failure:
  ret_val = -1;
  goto out;

 success:
  if ((end = memchr (beg + len, eol, (buf + size) - (beg + len))) != NULL)
    end++;
  else
    end = buf + size;
  while (buf < beg && beg[-1] != eol)
    --beg;
  len = end - beg;
 success_in_beg_and_len:
  *match_size = len;
  ret_val = beg - buf;
 out:
  return ret_val;
}
#endif /* defined(GREP_PROGRAM) || defined(FGREP_PROGRAM) */

#ifdef GREP_PROGRAM
#if HAVE_LIBPCRE
/* Compiled internal form of a Perl regular expression.  */
static pcre *cre;

/* Additional information about the pattern.  */
static pcre_extra *extra;
#endif

COMPILE_FCT(Pcompile)
{
#if !HAVE_LIBPCRE
  error (EXIT_TROUBLE, 0, "%s",
	 _("support for the -P option is not compiled into "
	   "this --disable-perl-regexp binary"));
#else
  int e;
  char const *ep;
  char *re = xmalloc (4 * size + 7);
  int flags = PCRE_MULTILINE | (match_icase ? PCRE_CASELESS : 0);
  char const *patlim = pattern + size;
  char *n = re;
  char const *p;
  char const *pnul;

  /* FIXME: Remove these restrictions.  */
  if (memchr(pattern, '\n', size))
    error (EXIT_TROUBLE, 0, _("the -P option only supports a single pattern"));

  *n = '\0';
  if (match_lines)
    strcpy (n, "^(");
  if (match_words)
    strcpy (n, "\\b(");
  n += strlen (n);

  /* The PCRE interface doesn't allow NUL bytes in the pattern, so
     replace each NUL byte in the pattern with the four characters
     "\000", removing a preceding backslash if there are an odd
     number of backslashes before the NUL.

     FIXME: This method does not work with some multibyte character
     encodings, notably Shift-JIS, where a multibyte character can end
     in a backslash byte.  */
  for (p = pattern; (pnul = memchr (p, '\0', patlim - p)); p = pnul + 1)
    {
      memcpy (n, p, pnul - p);
      n += pnul - p;
      for (p = pnul; pattern < p && p[-1] == '\\'; p--)
	continue;
      n -= (pnul - p) & 1;
      strcpy (n, "\\000");
      n += 4;
    }

  memcpy (n, p, patlim - p);
  n += patlim - p;
  *n = '\0';
  if (match_words)
    strcpy (n, ")\\b");
  if (match_lines)
    strcpy (n, ")$");

  cre = pcre_compile (re, flags, &ep, &e, pcre_maketables ());
  if (!cre)
    error (EXIT_TROUBLE, 0, "%s", ep);

  extra = pcre_study (cre, 0, &ep);
  if (ep)
    error (EXIT_TROUBLE, 0, "%s", ep);

  free (re);
#endif
}

EXECUTE_FCT(Pexecute)
{
#if !HAVE_LIBPCRE
  abort ();
  return -1;
#else
  /* This array must have at least two elements; everything after that
     is just for performance improvement in pcre_exec.  */
  int sub[300];

  const char *line_buf, *line_end, *line_next;
  int e = PCRE_ERROR_NOMATCH;
  ptrdiff_t start_ofs = start_ptr ? start_ptr - buf : 0;

  /* PCRE can't limit the matching to single lines, therefore we have to
     match each line in the buffer separately.  */
  for (line_next = buf;
       e == PCRE_ERROR_NOMATCH && line_next < buf + size;
       start_ofs -= line_next - line_buf)
    {
      line_buf = line_next;
      line_end = memchr (line_buf, eolbyte, (buf + size) - line_buf);
      if (line_end == NULL)
        line_next = line_end = buf + size;
      else
        line_next = line_end + 1;

      if (start_ptr && start_ptr >= line_end)
        continue;

      e = pcre_exec (cre, extra, line_buf, line_end - line_buf,
                     start_ofs < 0 ? 0 : start_ofs, 0,
                     sub, sizeof sub / sizeof *sub);
    }

  if (e <= 0)
    {
      switch (e)
	{
	case PCRE_ERROR_NOMATCH:
	  return -1;

	case PCRE_ERROR_NOMEMORY:
	  error (EXIT_TROUBLE, 0, _("memory exhausted"));

	default:
	  abort ();
	}
    }
  else
    {
      /* Narrow down to the line we've found.  */
      char const *beg = line_buf + sub[0];
      char const *end = line_buf + sub[1];
      char const *buflim = buf + size;
      char eol = eolbyte;
      if (!start_ptr)
	{
	  /* FIXME: The case when '\n' is not found indicates a bug:
	     Since grep is line oriented, the match should never contain
	     a newline, so there _must_ be a newline following.
	   */
	  if (!(end = memchr (end, eol, buflim - end)))
	    end = buflim;
	  else
	    end++;
	  while (buf < beg && beg[-1] != eol)
	    --beg;
	}

      *match_size = end - beg;
      return beg - buf;
    }
#endif
}

struct matcher const matchers[] = {
  { "default", Gcompile, EGexecute },
  { "grep",    Gcompile, EGexecute },
  { "egrep",   Ecompile, EGexecute },
  { "awk",     Acompile, EGexecute },
  { "fgrep",   Fcompile, Fexecute },
  { "perl",    Pcompile, Pexecute },
  { "", 0, 0 },
};
#endif /* GREP_PROGRAM */

Testing negative cases!
Running test command:
/home/ubuntu/spr-fast/tools/grep-test.py /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-deccad69-db9d6340/tempworkdir2/src /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-deccad69-db9d6340/tempworkdir2/tests /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-deccad69-db9d6340/tempworkdir2 0  > __res
Building:src at:
/home/ubuntu/spr-fast/tests/corebench/grep/grep-case-deccad69-db9d6340/tempworkdir2/srcBasicTester, Testing instance id 2:
//src_file:src/search.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
/* search.c - searching subroutines using dfa, kwset and regex for grep.
   Copyright 1992, 1998, 2000, 2007, 2009-2010 Free Software Foundation, Inc.

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 3, or (at your option)
   any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program; if not, write to the Free Software
   Foundation, Inc., 51 Franklin Street - Fifth Floor, Boston, MA
   02110-1301, USA.  */

/* Written August 1992 by Mike Haertel. */

#include <config.h>

#include <sys/types.h>

#include "mbsupport.h"
#ifdef MBS_SUPPORT
/* We can handle multibyte strings. */
# include <wchar.h>
# include <wctype.h>
#endif

#include "system.h"
#include "grep.h"
#ifndef FGREP_PROGRAM
# include <regex.h>
# include "dfa.h"
#endif
#include "kwset.h"
#include "error.h"
#include "xalloc.h"
#ifdef HAVE_LIBPCRE
# include <pcre.h>
#endif

#define NCHAR (UCHAR_MAX + 1)

/* For -w, we also consider _ to be word constituent.  */
#define WCHAR(C) (ISALNUM(C) || (C) == '_')

/* KWset compiled pattern.  For Ecompile and Gcompile, we compile
   a list of strings, at least one of which is known to occur in
   any string matching the regexp. */
static kwset_t kwset;

static void
kwsinit (void)
{
  static char trans[NCHAR];
  int i;

  if (match_icase && MB_CUR_MAX == 1)
    {
      for (i = 0; i < NCHAR; ++i)
        trans[i] = TOLOWER (i);

      kwset = kwsalloc (trans);
    }
  else
    kwset = kwsalloc (NULL);

  if (!kwset)
    xalloc_die ();
}

#ifdef MBS_SUPPORT
/* Convert the *N-byte string, BEG, to lowercase, and write the
   NUL-terminated result into malloc'd storage.  Upon success, set *N
   to the length (in bytes) of the resulting string (not including the
   trailing NUL byte), and return a pointer to the lowercase string.
   Upon memory allocation failure, this function exits.

   Note that while this function returns a pointer to malloc'd storage,
   the caller must not free it, since this function retains a pointer
   to the buffer and reuses it on any subsequent call.  As a consequence,
   this function is not thread-safe.  */
static char *
mbtolower (const char *beg, size_t *n)
{
  static char *out;
  static size_t outalloc;
  size_t outlen, mb_cur_max;
  mbstate_t is, os;
  const char *end;
  char *p;

  if (*n > outalloc)
    {
      out = xrealloc (out, *n);
      outalloc = *n;
    }

  memset (&is, 0, sizeof (is));
  memset (&os, 0, sizeof (os));
  end = beg + *n;

  mb_cur_max = MB_CUR_MAX;
  p = out;
  outlen = 0;
  while (beg < end)
    {
      wchar_t wc;
      size_t mbclen = mbrtowc(&wc, beg, end - beg, &is);
      if (outlen + mb_cur_max >= outalloc)
        {
          out = x2nrealloc (out, &outalloc, 1);
          p = out + outlen;
        }

      if (mbclen == (size_t) -1 || mbclen == (size_t) -2 || mbclen == 0)
        {
          /* An invalid sequence, or a truncated multi-octet character.
             We treat it as a single-octet character.  */
          *p++ = *beg++;
          outlen++;
          memset (&is, 0, sizeof (is));
          memset (&os, 0, sizeof (os));
        }
      else
        {
          beg += mbclen;
          mbclen = wcrtomb (p, towlower ((wint_t) wc), &os);
          p += mbclen;
          outlen += mbclen;
        }
    }

  *n = p - out;
  *p++ = 0;
  return out;
}
#endif


#ifndef FGREP_PROGRAM
/* DFA compiled regexp. */
static struct dfa dfa;

/* The Regex compiled patterns.  */
static struct patterns
{
  /* Regex compiled regexp. */
  struct re_pattern_buffer regexbuf;
  struct re_registers regs; /* This is here on account of a BRAIN-DEAD
			       Q@#%!# library interface in regex.c.  */
} patterns0;

struct patterns *patterns;
size_t pcount;

void
dfaerror (char const *mesg)
{
  error (EXIT_TROUBLE, 0, "%s", mesg);
}

/* Number of compiled fixed strings known to exactly match the regexp.
   If kwsexec returns < kwset_exact_matches, then we don't need to
   call the regexp matcher at all. */
static int kwset_exact_matches;

static char const *
kwsincr_case (const char *must)
{
  const char *buf;
  size_t n;

  n = strlen (must);
#ifdef MBS_SUPPORT
  if (match_icase && MB_CUR_MAX > 1)
    buf = mbtolower (must, &n);
  else
#endif
    buf = must;
  return kwsincr (kwset, buf, n);
}

/* If the DFA turns out to have some set of fixed strings one of
   which must occur in the match, then we build a kwset matcher
   to find those strings, and thus quickly filter out impossible
   matches. */
static void
kwsmusts (void)
{
  struct dfamust const *dm;
  char const *err;

  if (dfa.musts)
    {
      kwsinit ();
      /* First, we compile in the substrings known to be exact
	 matches.  The kwset matcher will return the index
	 of the matching string that it chooses. */
      for (dm = dfa.musts; dm; dm = dm->next)
	{
	  if (!dm->exact)
	    continue;
	  ++kwset_exact_matches;
	  if ((err = kwsincr_case (dm->must)) != NULL)
	    error (EXIT_TROUBLE, 0, "%s", err);
	}
      /* Now, we compile the substrings that will require
	 the use of the regexp matcher.  */
      for (dm = dfa.musts; dm; dm = dm->next)
	{
	  if (dm->exact)
	    continue;
	  if ((err = kwsincr_case (dm->must)) != NULL)
	    error (EXIT_TROUBLE, 0, "%s", err);
	}
      if ((err = kwsprep (kwset)) != NULL)
	error (EXIT_TROUBLE, 0, "%s", err);
    }
}
#endif /* !FGREP_PROGRAM */

#ifdef MBS_SUPPORT

static bool
is_mb_middle(const char **good, const char *buf, const char *end)
{
  const char *p = *good;
  const char *prev = p;
  mbstate_t cur_state;

  /* TODO: can be optimized for UTF-8.  */
  
//Patch 0:
xalloc_die();
memset(&cur_state, 0, sizeof(mbstate_t));

//CodeSeg 1:
  while (p < buf)
    {
      size_t mbclen = mbrlen(p, end - p, &cur_state);

      /* Store the beginning of the previous complete multibyte character.  */
      if (mbclen != (size_t) -2)
        prev = p;

      if (mbclen == (size_t) -1 || mbclen == (size_t) -2 || mbclen == 0)
	{
	  /* An invalid sequence, or a truncated multibyte character.
	     We treat it as a single byte character.  */
	  mbclen = 1;
	}
      p += mbclen;
    }

  *good = prev;
  return p > buf;
}
#endif /* MBS_SUPPORT */

#if defined(GREP_PROGRAM) || defined(EGREP_PROGRAM)
#ifdef EGREP_PROGRAM
COMPILE_FCT(Ecompile)
{
  reg_syntax_t syntax_bits = RE_SYNTAX_POSIX_EGREP;
#else
/* No __VA_ARGS__ in C89.  So we have to do it this way.  */
static COMPILE_RET
GEAcompile (char const *pattern, size_t size, reg_syntax_t syntax_bits)
{
#endif /* EGREP_PROGRAM */
  const char *err;
  const char *p, *sep;
  size_t total = size;
  char *motif;

  if (match_icase)
    syntax_bits |= RE_ICASE;
  re_set_syntax (syntax_bits);
  dfasyntax (syntax_bits, match_icase, eolbyte);

  /* For GNU regex compiler we have to pass the patterns separately to detect
     errors like "[\nallo\n]\n".  The patterns here are "[", "allo" and "]"
     GNU regex should have raise a syntax error.  The same for backref, where
     the backref should have been local to each pattern.  */
  p = pattern;
  do
    {
      size_t len;
      sep = memchr (p, '\n', total);
      if (sep)
	{
	  len = sep - p;
	  sep++;
	  total -= (len + 1);
	}
      else
	{
	  len = total;
	  total = 0;
	}

      patterns = realloc (patterns, (pcount + 1) * sizeof (*patterns));
      if (patterns == NULL)
	error (EXIT_TROUBLE, errno, _("memory exhausted"));
      patterns[pcount] = patterns0;

      if ((err = re_compile_pattern (p, len,
				    &(patterns[pcount].regexbuf))) != NULL)
	error (EXIT_TROUBLE, 0, "%s", err);
      pcount++;

      p = sep;
    } while (sep && total != 0);

  /* In the match_words and match_lines cases, we use a different pattern
     for the DFA matcher that will quickly throw out cases that won't work.
     Then if DFA succeeds we do some hairy stuff using the regex matcher
     to decide whether the match should really count. */
  if (match_words || match_lines)
    {
      static char const line_beg_no_bk[] = "^(";
      static char const line_end_no_bk[] = ")$";
      static char const word_beg_no_bk[] = "(^|[^[:alnum:]_])(";
      static char const word_end_no_bk[] = ")([^[:alnum:]_]|$)";
#ifdef EGREP_PROGRAM
# define IF_BK(x, y) (y)
      char *n = xmalloc (sizeof word_beg_no_bk - 1 + size + sizeof word_end_no_bk);
#else
      static char const line_beg_bk[] = "^\\(";
      static char const line_end_bk[] = "\\)$";
      static char const word_beg_bk[] = "\\(^\\|[^[:alnum:]_]\\)\\(";
      static char const word_end_bk[] = "\\)\\([^[:alnum:]_]\\|$\\)";
      int bk = !(syntax_bits & RE_NO_BK_PARENS);
# define IF_BK(x, y) ((bk) ? (x) : (y))
      char *n = xmalloc (sizeof word_beg_bk - 1 + size + sizeof word_end_bk);
#endif /* EGREP_PROGRAM */

      strcpy (n, match_lines ? IF_BK(line_beg_bk, line_beg_no_bk)
			     : IF_BK(word_beg_bk, word_beg_no_bk));
      total = strlen(n);
      memcpy (n + total, pattern, size);
      total += size;
      strcpy (n + total, match_lines ? IF_BK(line_end_bk, line_end_no_bk)
				     : IF_BK(word_end_bk, word_end_no_bk));
      total += strlen (n + total);
      pattern = motif = n;
      size = total;
    }
  else
    motif = NULL;

  dfacomp (pattern, size, &dfa, 1);
  kwsmusts ();

  free(motif);
}

#ifndef EGREP_PROGRAM
COMPILE_FCT(Gcompile)
{
  return GEAcompile (pattern, size,
		     RE_SYNTAX_GREP | RE_HAT_LISTS_NOT_NEWLINE);
}

COMPILE_FCT(Acompile)
{
  return GEAcompile (pattern, size, RE_SYNTAX_AWK);
}

COMPILE_FCT(Ecompile)
{
  return GEAcompile (pattern, size, RE_SYNTAX_POSIX_EGREP);
}
#endif /* !EGREP_PROGRAM */

EXECUTE_FCT(EGexecute)
{
  char const *buflim, *beg, *end, *match, *best_match, *mb_start;
  char eol = eolbyte;
  int backref, start, len, best_len;
  struct kwsmatch kwsm;
  size_t i, ret_val;
#ifdef MBS_SUPPORT
  if (MB_CUR_MAX > 1)
    {
      if (match_icase)
        {
          /* mbtolower adds a NUL byte at the end.  That will provide
	     space for the sentinel byte dfaexec may add.  */
          char *case_buf = mbtolower (buf, &size);
	  if (start_ptr)
	    start_ptr = case_buf + (start_ptr - buf);
          buf = case_buf;
        }
    }
#endif /* MBS_SUPPORT */

  mb_start = buf;
  buflim = buf + size;

  for (beg = end = buf; end < buflim; beg = end)
    {
      if (!start_ptr)
	{
	  /* We don't care about an exact match.  */
	  if (kwset)
	    {
	      /* Find a possible match using the KWset matcher. */
	      size_t offset = kwsexec (kwset, beg, buflim - beg, &kwsm);
	      if (offset == (size_t) -1)
		goto failure;
	      beg += offset;
	      /* Narrow down to the line containing the candidate, and
		 run it through DFA. */
	      if ((end = memchr(beg, eol, buflim - beg)) != NULL)
	        end++;
              else
                end = buflim;
	      match = beg;
	      while (beg > buf && beg[-1] != eol)
		--beg;
	      if (kwsm.index < kwset_exact_matches)
                {
#ifdef MBS_SUPPORT
                  if (mb_start < beg)
                    mb_start = beg;
                  if (MB_CUR_MAX == 1 || !is_mb_middle (&mb_start, match, buflim))
#endif
                    goto success;
                }
	      if (dfaexec (&dfa, beg, (char *) end, 0, NULL, &backref) == NULL)
		continue;
	    }
	  else
	    {
	      /* No good fixed strings; start with DFA. */
	      char const *next_beg = dfaexec (&dfa, beg, (char *) buflim,
					      0, NULL, &backref);
	      if (next_beg == NULL)
		break;
	      /* Narrow down to the line we've found. */
	      beg = next_beg;
	      if ((end = memchr(beg, eol, buflim - beg)) != NULL)
	        end++;
              else
                end = buflim;
	      while (beg > buf && beg[-1] != eol)
		--beg;
	    }
	  /* Successful, no backreferences encountered! */
	  if (!backref)
	    goto success;
	}
      else
	{
	  /* We are looking for the leftmost (then longest) exact match.
	     We will go through the outer loop only once.  */
	  beg = start_ptr;
	  end = buflim;
	}

      /* If we've made it to this point, this means DFA has seen
	 a probable match, and we need to run it through Regex. */
      best_match = end;
      best_len = 0;
      for (i = 0; i < pcount; i++)
	{
	  patterns[i].regexbuf.not_eol = 0;
	  if (0 <= (start = re_search (&(patterns[i].regexbuf),
				       buf, end - buf - 1,
				       beg - buf, end - beg - 1,
				       &(patterns[i].regs))))
	    {
	      len = patterns[i].regs.end[0] - start;
	      match = buf + start;
	      if (match > best_match)
		continue;
	      if (start_ptr && !match_words)
		goto assess_pattern_match;
	      if ((!match_lines && !match_words)
		  || (match_lines && len == end - beg - 1))
		{
		  match = beg;
		  len = end - beg;
		  goto assess_pattern_match;
		}
	      /* If -w, check if the match aligns with word boundaries.
		 We do this iteratively because:
		 (a) the line may contain more than one occurence of the
		 pattern, and
		 (b) Several alternatives in the pattern might be valid at a
		 given point, and we may need to consider a shorter one to
		 find a word boundary.  */
	      if (match_words)
		while (match <= best_match)
		  {
		    if ((match == buf || !WCHAR ((unsigned char) match[-1]))
			&& (len == end - beg - 1
			    || !WCHAR ((unsigned char) match[len])))
		      goto assess_pattern_match;
		    if (len > 0)
		      {
			/* Try a shorter length anchored at the same place. */
			--len;
			patterns[i].regexbuf.not_eol = 1;
			len = re_match (&(patterns[i].regexbuf),
					buf, match + len - beg, match - buf,
					&(patterns[i].regs));
		      }
		    if (len <= 0)
		      {
			/* Try looking further on. */
			if (match == end - 1)
			  break;
			match++;
			patterns[i].regexbuf.not_eol = 0;
			start = re_search (&(patterns[i].regexbuf),
					   buf, end - buf - 1,
					   match - buf, end - match - 1,
					   &(patterns[i].regs));
			if (start < 0)
			  break;
			len = patterns[i].regs.end[0] - start;
			match = buf + start;
		      }
		  } /* while (match <= best_match) */
	      continue;
	    assess_pattern_match:
	      if (!start_ptr)
		{
		  /* Good enough for a non-exact match.
		     No need to look at further patterns, if any.  */
		  beg = match;
		  goto success_in_len;
		}
	      if (match < best_match || (match == best_match && len > best_len))
		{
		  /* Best exact match:  leftmost, then longest.  */
		  best_match = match;
		  best_len = len;
		}
	    } /* if re_search >= 0 */
	} /* for Regex patterns.  */
	if (best_match < end)
	  {
	    /* We have found an exact match.  We were just
	       waiting for the best one (leftmost then longest).  */
	    beg = best_match;
	    len = best_len;
	    goto success_in_len;
	  }
    } /* for (beg = end ..) */

 failure:
  ret_val = -1;
  goto out;

 success:
  len = end - beg;
 success_in_len:
  *match_size = len;
  ret_val = beg - buf;
 out:
  return ret_val;
}
#endif /* defined(GREP_PROGRAM) || defined(EGREP_PROGRAM) */

#if defined(GREP_PROGRAM) || defined(FGREP_PROGRAM)
COMPILE_FCT(Fcompile)
{
  char const *beg, *end, *lim, *err, *pat;
  size_t psize;

  kwsinit ();
  psize = size;
  if (match_icase && MB_CUR_MAX > 1)
    pat = mbtolower (pattern, &psize);
  else
    pat = pattern;

  beg = pat;
  do
    {
      for (lim = beg;; ++lim)
	{
	  end = lim;
	  if (lim >= pat + psize)
	    break;
	 if (*lim == '\n')
	   {
	     lim++;
	     break;
	   }
#if HAVE_DOS_FILE_CONTENTS
	 if (*lim == '\r' && lim + 1 < pat + psize && lim[1] == '\n')
	   {
	     lim += 2;
	     break;
	   }
#endif
	}

      if ((err = kwsincr (kwset, beg, end - beg)) != NULL)
	error (EXIT_TROUBLE, 0, "%s", err);
      beg = lim;
    }
  while (beg < pat + psize);

  if ((err = kwsprep (kwset)) != NULL)
    error (EXIT_TROUBLE, 0, "%s", err);
}

EXECUTE_FCT(Fexecute)
{
  char const *beg, *try, *end, *mb_start;
  size_t len;
  char eol = eolbyte;
  struct kwsmatch kwsmatch;
  size_t ret_val;
#ifdef MBS_SUPPORT
  if (MB_CUR_MAX > 1)
    {
      if (match_icase)
        {
          char *case_buf = mbtolower (buf, &size);
	  if (start_ptr)
	    start_ptr = case_buf + (start_ptr - buf);
          buf = case_buf;
        }
    }
#endif /* MBS_SUPPORT */

  for (mb_start = beg = start_ptr ? start_ptr : buf; beg <= buf + size; beg++)
    {
      size_t offset = kwsexec (kwset, beg, buf + size - beg, &kwsmatch);
      if (offset == (size_t) -1)
	goto failure;
#ifdef MBS_SUPPORT
      if (MB_CUR_MAX > 1 && is_mb_middle (&mb_start, beg + offset, buf + size))
        {
          beg = mb_start - 1;
          continue; /* It is a part of multibyte character.  */
        }
#endif /* MBS_SUPPORT */
      beg += offset;
      len = kwsmatch.size[0];
      if (start_ptr && !match_words)
	goto success_in_beg_and_len;
      if (match_lines)
	{
	  if (beg > buf && beg[-1] != eol)
	    continue;
	  if (beg + len < buf + size && beg[len] != eol)
	    continue;
	  goto success;
	}
      else if (match_words)
	for (try = beg; len; )
	  {
	    if (try > buf && WCHAR((unsigned char) try[-1]))
	      break;
	    if (try + len < buf + size && WCHAR((unsigned char) try[len]))
	      {
		offset = kwsexec (kwset, beg, --len, &kwsmatch);
		if (offset == (size_t) -1)
		  break;
		try = beg + offset;
		len = kwsmatch.size[0];
	      }
	    else if (!start_ptr)
	      goto success;
	    else
	      goto success_in_beg_and_len;
	  } /* for (try) */
      else
	goto success;
    } /* for (beg in buf) */

 failure:
  ret_val = -1;
  goto out;

 success:
  if ((end = memchr (beg + len, eol, (buf + size) - (beg + len))) != NULL)
    end++;
  else
    end = buf + size;
  while (buf < beg && beg[-1] != eol)
    --beg;
  len = end - beg;
 success_in_beg_and_len:
  *match_size = len;
  ret_val = beg - buf;
 out:
  return ret_val;
}
#endif /* defined(GREP_PROGRAM) || defined(FGREP_PROGRAM) */

#ifdef GREP_PROGRAM
#if HAVE_LIBPCRE
/* Compiled internal form of a Perl regular expression.  */
static pcre *cre;

/* Additional information about the pattern.  */
static pcre_extra *extra;
#endif

COMPILE_FCT(Pcompile)
{
#if !HAVE_LIBPCRE
  error (EXIT_TROUBLE, 0, "%s",
	 _("support for the -P option is not compiled into "
	   "this --disable-perl-regexp binary"));
#else
  int e;
  char const *ep;
  char *re = xmalloc (4 * size + 7);
  int flags = PCRE_MULTILINE | (match_icase ? PCRE_CASELESS : 0);
  char const *patlim = pattern + size;
  char *n = re;
  char const *p;
  char const *pnul;

  /* FIXME: Remove these restrictions.  */
  if (memchr(pattern, '\n', size))
    error (EXIT_TROUBLE, 0, _("the -P option only supports a single pattern"));

  *n = '\0';
  if (match_lines)
    strcpy (n, "^(");
  if (match_words)
    strcpy (n, "\\b(");
  n += strlen (n);

  /* The PCRE interface doesn't allow NUL bytes in the pattern, so
     replace each NUL byte in the pattern with the four characters
     "\000", removing a preceding backslash if there are an odd
     number of backslashes before the NUL.

     FIXME: This method does not work with some multibyte character
     encodings, notably Shift-JIS, where a multibyte character can end
     in a backslash byte.  */
  for (p = pattern; (pnul = memchr (p, '\0', patlim - p)); p = pnul + 1)
    {
      memcpy (n, p, pnul - p);
      n += pnul - p;
      for (p = pnul; pattern < p && p[-1] == '\\'; p--)
	continue;
      n -= (pnul - p) & 1;
      strcpy (n, "\\000");
      n += 4;
    }

  memcpy (n, p, patlim - p);
  n += patlim - p;
  *n = '\0';
  if (match_words)
    strcpy (n, ")\\b");
  if (match_lines)
    strcpy (n, ")$");

  cre = pcre_compile (re, flags, &ep, &e, pcre_maketables ());
  if (!cre)
    error (EXIT_TROUBLE, 0, "%s", ep);

  extra = pcre_study (cre, 0, &ep);
  if (ep)
    error (EXIT_TROUBLE, 0, "%s", ep);

  free (re);
#endif
}

EXECUTE_FCT(Pexecute)
{
#if !HAVE_LIBPCRE
  abort ();
  return -1;
#else
  /* This array must have at least two elements; everything after that
     is just for performance improvement in pcre_exec.  */
  int sub[300];

  const char *line_buf, *line_end, *line_next;
  int e = PCRE_ERROR_NOMATCH;
  ptrdiff_t start_ofs = start_ptr ? start_ptr - buf : 0;

  /* PCRE can't limit the matching to single lines, therefore we have to
     match each line in the buffer separately.  */
  for (line_next = buf;
       e == PCRE_ERROR_NOMATCH && line_next < buf + size;
       start_ofs -= line_next - line_buf)
    {
      line_buf = line_next;
      line_end = memchr (line_buf, eolbyte, (buf + size) - line_buf);
      if (line_end == NULL)
        line_next = line_end = buf + size;
      else
        line_next = line_end + 1;

      if (start_ptr && start_ptr >= line_end)
        continue;

      e = pcre_exec (cre, extra, line_buf, line_end - line_buf,
                     start_ofs < 0 ? 0 : start_ofs, 0,
                     sub, sizeof sub / sizeof *sub);
    }

  if (e <= 0)
    {
      switch (e)
	{
	case PCRE_ERROR_NOMATCH:
	  return -1;

	case PCRE_ERROR_NOMEMORY:
	  error (EXIT_TROUBLE, 0, _("memory exhausted"));

	default:
	  abort ();
	}
    }
  else
    {
      /* Narrow down to the line we've found.  */
      char const *beg = line_buf + sub[0];
      char const *end = line_buf + sub[1];
      char const *buflim = buf + size;
      char eol = eolbyte;
      if (!start_ptr)
	{
	  /* FIXME: The case when '\n' is not found indicates a bug:
	     Since grep is line oriented, the match should never contain
	     a newline, so there _must_ be a newline following.
	   */
	  if (!(end = memchr (end, eol, buflim - end)))
	    end = buflim;
	  else
	    end++;
	  while (buf < beg && beg[-1] != eol)
	    --beg;
	}

      *match_size = end - beg;
      return beg - buf;
    }
#endif
}

struct matcher const matchers[] = {
  { "default", Gcompile, EGexecute },
  { "grep",    Gcompile, EGexecute },
  { "egrep",   Ecompile, EGexecute },
  { "awk",     Acompile, EGexecute },
  { "fgrep",   Fcompile, Fexecute },
  { "perl",    Pcompile, Pexecute },
  { "", 0, 0 },
};
#endif /* GREP_PROGRAM */

Testing negative cases!
Running test command:
/home/ubuntu/spr-fast/tools/grep-test.py /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-deccad69-db9d6340/tempworkdir2/src /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-deccad69-db9d6340/tempworkdir2/tests /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-deccad69-db9d6340/tempworkdir2 0  > __res
Passed Negative Cases with BasicTester
Testing positive cases!
Running test command:
/home/ubuntu/spr-fast/tools/grep-test.py /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-deccad69-db9d6340/tempworkdir2/src /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-deccad69-db9d6340/tempworkdir2/tests /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-deccad69-db9d6340/tempworkdir2 3  > __res
Running test command:
/home/ubuntu/spr-fast/tools/grep-test.py /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-deccad69-db9d6340/tempworkdir2/src /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-deccad69-db9d6340/tempworkdir2/tests /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-deccad69-db9d6340/tempworkdir2 4  > __res
Running test command:
/home/ubuntu/spr-fast/tools/grep-test.py /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-deccad69-db9d6340/tempworkdir2/src /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-deccad69-db9d6340/tempworkdir2/tests /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-deccad69-db9d6340/tempworkdir2 5  > __res
Running test command:
/home/ubuntu/spr-fast/tools/grep-test.py /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-deccad69-db9d6340/tempworkdir2/src /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-deccad69-db9d6340/tempworkdir2/tests /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-deccad69-db9d6340/tempworkdir2 6  > __res
Running test command:
/home/ubuntu/spr-fast/tools/grep-test.py /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-deccad69-db9d6340/tempworkdir2/src /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-deccad69-db9d6340/tempworkdir2/tests /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-deccad69-db9d6340/tempworkdir2 9  > __res
Running test command:
/home/ubuntu/spr-fast/tools/grep-test.py /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-deccad69-db9d6340/tempworkdir2/src /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-deccad69-db9d6340/tempworkdir2/tests /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-deccad69-db9d6340/tempworkdir2 11  > __res
Running test command:
/home/ubuntu/spr-fast/tools/grep-test.py /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-deccad69-db9d6340/tempworkdir2/src /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-deccad69-db9d6340/tempworkdir2/tests /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-deccad69-db9d6340/tempworkdir2 12  > __res
Running test command:
/home/ubuntu/spr-fast/tools/grep-test.py /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-deccad69-db9d6340/tempworkdir2/src /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-deccad69-db9d6340/tempworkdir2/tests /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-deccad69-db9d6340/tempworkdir2 13  > __res
Running test command:
/home/ubuntu/spr-fast/tools/grep-test.py /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-deccad69-db9d6340/tempworkdir2/src /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-deccad69-db9d6340/tempworkdir2/tests /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-deccad69-db9d6340/tempworkdir2 14  > __res
Running test command:
/home/ubuntu/spr-fast/tools/grep-test.py /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-deccad69-db9d6340/tempworkdir2/src /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-deccad69-db9d6340/tempworkdir2/tests /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-deccad69-db9d6340/tempworkdir2 15  > __res
Running test command:
/home/ubuntu/spr-fast/tools/grep-test.py /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-deccad69-db9d6340/tempworkdir2/src /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-deccad69-db9d6340/tempworkdir2/tests /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-deccad69-db9d6340/tempworkdir2 17  > __res
Running test command:
/home/ubuntu/spr-fast/tools/grep-test.py /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-deccad69-db9d6340/tempworkdir2/src /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-deccad69-db9d6340/tempworkdir2/tests /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-deccad69-db9d6340/tempworkdir2 18  > __res
Running test command:
/home/ubuntu/spr-fast/tools/grep-test.py /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-deccad69-db9d6340/tempworkdir2/src /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-deccad69-db9d6340/tempworkdir2/tests /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-deccad69-db9d6340/tempworkdir2 20  > __res
Failed positive case 20
Building:src at:
/home/ubuntu/spr-fast/tests/corebench/grep/grep-case-deccad69-db9d6340/tempworkdir2/srcBasicTester, Testing instance id 3:
//src_file:src/search.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
/* search.c - searching subroutines using dfa, kwset and regex for grep.
   Copyright 1992, 1998, 2000, 2007, 2009-2010 Free Software Foundation, Inc.

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 3, or (at your option)
   any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program; if not, write to the Free Software
   Foundation, Inc., 51 Franklin Street - Fifth Floor, Boston, MA
   02110-1301, USA.  */

/* Written August 1992 by Mike Haertel. */

#include <config.h>

#include <sys/types.h>

#include "mbsupport.h"
#ifdef MBS_SUPPORT
/* We can handle multibyte strings. */
# include <wchar.h>
# include <wctype.h>
#endif

#include "system.h"
#include "grep.h"
#ifndef FGREP_PROGRAM
# include <regex.h>
# include "dfa.h"
#endif
#include "kwset.h"
#include "error.h"
#include "xalloc.h"
#ifdef HAVE_LIBPCRE
# include <pcre.h>
#endif

#define NCHAR (UCHAR_MAX + 1)

/* For -w, we also consider _ to be word constituent.  */
#define WCHAR(C) (ISALNUM(C) || (C) == '_')

/* KWset compiled pattern.  For Ecompile and Gcompile, we compile
   a list of strings, at least one of which is known to occur in
   any string matching the regexp. */
static kwset_t kwset;

static void
kwsinit (void)
{
  static char trans[NCHAR];
  int i;

  if (match_icase && MB_CUR_MAX == 1)
    {
      for (i = 0; i < NCHAR; ++i)
        trans[i] = TOLOWER (i);

      kwset = kwsalloc (trans);
    }
  else
    kwset = kwsalloc (NULL);

  if (!kwset)
    xalloc_die ();
}

#ifdef MBS_SUPPORT
/* Convert the *N-byte string, BEG, to lowercase, and write the
   NUL-terminated result into malloc'd storage.  Upon success, set *N
   to the length (in bytes) of the resulting string (not including the
   trailing NUL byte), and return a pointer to the lowercase string.
   Upon memory allocation failure, this function exits.

   Note that while this function returns a pointer to malloc'd storage,
   the caller must not free it, since this function retains a pointer
   to the buffer and reuses it on any subsequent call.  As a consequence,
   this function is not thread-safe.  */
static char *
mbtolower (const char *beg, size_t *n)
{
  static char *out;
  static size_t outalloc;
  size_t outlen, mb_cur_max;
  mbstate_t is, os;
  const char *end;
  char *p;

  if (*n > outalloc)
    {
      out = xrealloc (out, *n);
      outalloc = *n;
    }

  memset (&is, 0, sizeof (is));
  memset (&os, 0, sizeof (os));
  end = beg + *n;

  mb_cur_max = MB_CUR_MAX;
  p = out;
  outlen = 0;
  while (beg < end)
    {
      wchar_t wc;
      size_t mbclen = mbrtowc(&wc, beg, end - beg, &is);
      if (outlen + mb_cur_max >= outalloc)
        {
          out = x2nrealloc (out, &outalloc, 1);
          p = out + outlen;
        }

      if (mbclen == (size_t) -1 || mbclen == (size_t) -2 || mbclen == 0)
        {
          /* An invalid sequence, or a truncated multi-octet character.
             We treat it as a single-octet character.  */
          *p++ = *beg++;
          outlen++;
          memset (&is, 0, sizeof (is));
          memset (&os, 0, sizeof (os));
        }
      else
        {
          beg += mbclen;
          mbclen = wcrtomb (p, towlower ((wint_t) wc), &os);
          p += mbclen;
          outlen += mbclen;
        }
    }

  *n = p - out;
  *p++ = 0;
  return out;
}
#endif


#ifndef FGREP_PROGRAM
/* DFA compiled regexp. */
static struct dfa dfa;

/* The Regex compiled patterns.  */
static struct patterns
{
  /* Regex compiled regexp. */
  struct re_pattern_buffer regexbuf;
  struct re_registers regs; /* This is here on account of a BRAIN-DEAD
			       Q@#%!# library interface in regex.c.  */
} patterns0;

struct patterns *patterns;
size_t pcount;

void
dfaerror (char const *mesg)
{
  error (EXIT_TROUBLE, 0, "%s", mesg);
}

/* Number of compiled fixed strings known to exactly match the regexp.
   If kwsexec returns < kwset_exact_matches, then we don't need to
   call the regexp matcher at all. */
static int kwset_exact_matches;

static char const *
kwsincr_case (const char *must)
{
  const char *buf;
  size_t n;

  n = strlen (must);
#ifdef MBS_SUPPORT
  if (match_icase && MB_CUR_MAX > 1)
    buf = mbtolower (must, &n);
  else
#endif
    buf = must;
  return kwsincr (kwset, buf, n);
}

/* If the DFA turns out to have some set of fixed strings one of
   which must occur in the match, then we build a kwset matcher
   to find those strings, and thus quickly filter out impossible
   matches. */
static void
kwsmusts (void)
{
  struct dfamust const *dm;
  char const *err;

  if (dfa.musts)
    {
      kwsinit ();
      /* First, we compile in the substrings known to be exact
	 matches.  The kwset matcher will return the index
	 of the matching string that it chooses. */
      for (dm = dfa.musts; dm; dm = dm->next)
	{
	  if (!dm->exact)
	    continue;
	  ++kwset_exact_matches;
	  if ((err = kwsincr_case (dm->must)) != NULL)
	    error (EXIT_TROUBLE, 0, "%s", err);
	}
      /* Now, we compile the substrings that will require
	 the use of the regexp matcher.  */
      for (dm = dfa.musts; dm; dm = dm->next)
	{
	  if (dm->exact)
	    continue;
	  if ((err = kwsincr_case (dm->must)) != NULL)
	    error (EXIT_TROUBLE, 0, "%s", err);
	}
      if ((err = kwsprep (kwset)) != NULL)
	error (EXIT_TROUBLE, 0, "%s", err);
    }
}
#endif /* !FGREP_PROGRAM */

#ifdef MBS_SUPPORT

static bool
is_mb_middle(const char **good, const char *buf, const char *end)
{
  const char *p = *good;
  const char *prev = p;
  mbstate_t cur_state;

  /* TODO: can be optimized for UTF-8.  */
  
//Patch 0:
prev = (prev);
memset(&cur_state, 0, sizeof(mbstate_t));

//CodeSeg 1:
  while (p < buf)
    {
      size_t mbclen = mbrlen(p, end - p, &cur_state);

      /* Store the beginning of the previous complete multibyte character.  */
      if (mbclen != (size_t) -2)
        prev = p;

      if (mbclen == (size_t) -1 || mbclen == (size_t) -2 || mbclen == 0)
	{
	  /* An invalid sequence, or a truncated multibyte character.
	     We treat it as a single byte character.  */
	  mbclen = 1;
	}
      p += mbclen;
    }

  *good = prev;
  return p > buf;
}
#endif /* MBS_SUPPORT */

#if defined(GREP_PROGRAM) || defined(EGREP_PROGRAM)
#ifdef EGREP_PROGRAM
COMPILE_FCT(Ecompile)
{
  reg_syntax_t syntax_bits = RE_SYNTAX_POSIX_EGREP;
#else
/* No __VA_ARGS__ in C89.  So we have to do it this way.  */
static COMPILE_RET
GEAcompile (char const *pattern, size_t size, reg_syntax_t syntax_bits)
{
#endif /* EGREP_PROGRAM */
  const char *err;
  const char *p, *sep;
  size_t total = size;
  char *motif;

  if (match_icase)
    syntax_bits |= RE_ICASE;
  re_set_syntax (syntax_bits);
  dfasyntax (syntax_bits, match_icase, eolbyte);

  /* For GNU regex compiler we have to pass the patterns separately to detect
     errors like "[\nallo\n]\n".  The patterns here are "[", "allo" and "]"
     GNU regex should have raise a syntax error.  The same for backref, where
     the backref should have been local to each pattern.  */
  p = pattern;
  do
    {
      size_t len;
      sep = memchr (p, '\n', total);
      if (sep)
	{
	  len = sep - p;
	  sep++;
	  total -= (len + 1);
	}
      else
	{
	  len = total;
	  total = 0;
	}

      patterns = realloc (patterns, (pcount + 1) * sizeof (*patterns));
      if (patterns == NULL)
	error (EXIT_TROUBLE, errno, _("memory exhausted"));
      patterns[pcount] = patterns0;

      if ((err = re_compile_pattern (p, len,
				    &(patterns[pcount].regexbuf))) != NULL)
	error (EXIT_TROUBLE, 0, "%s", err);
      pcount++;

      p = sep;
    } while (sep && total != 0);

  /* In the match_words and match_lines cases, we use a different pattern
     for the DFA matcher that will quickly throw out cases that won't work.
     Then if DFA succeeds we do some hairy stuff using the regex matcher
     to decide whether the match should really count. */
  if (match_words || match_lines)
    {
      static char const line_beg_no_bk[] = "^(";
      static char const line_end_no_bk[] = ")$";
      static char const word_beg_no_bk[] = "(^|[^[:alnum:]_])(";
      static char const word_end_no_bk[] = ")([^[:alnum:]_]|$)";
#ifdef EGREP_PROGRAM
# define IF_BK(x, y) (y)
      char *n = xmalloc (sizeof word_beg_no_bk - 1 + size + sizeof word_end_no_bk);
#else
      static char const line_beg_bk[] = "^\\(";
      static char const line_end_bk[] = "\\)$";
      static char const word_beg_bk[] = "\\(^\\|[^[:alnum:]_]\\)\\(";
      static char const word_end_bk[] = "\\)\\([^[:alnum:]_]\\|$\\)";
      int bk = !(syntax_bits & RE_NO_BK_PARENS);
# define IF_BK(x, y) ((bk) ? (x) : (y))
      char *n = xmalloc (sizeof word_beg_bk - 1 + size + sizeof word_end_bk);
#endif /* EGREP_PROGRAM */

      strcpy (n, match_lines ? IF_BK(line_beg_bk, line_beg_no_bk)
			     : IF_BK(word_beg_bk, word_beg_no_bk));
      total = strlen(n);
      memcpy (n + total, pattern, size);
      total += size;
      strcpy (n + total, match_lines ? IF_BK(line_end_bk, line_end_no_bk)
				     : IF_BK(word_end_bk, word_end_no_bk));
      total += strlen (n + total);
      pattern = motif = n;
      size = total;
    }
  else
    motif = NULL;

  dfacomp (pattern, size, &dfa, 1);
  kwsmusts ();

  free(motif);
}

#ifndef EGREP_PROGRAM
COMPILE_FCT(Gcompile)
{
  return GEAcompile (pattern, size,
		     RE_SYNTAX_GREP | RE_HAT_LISTS_NOT_NEWLINE);
}

COMPILE_FCT(Acompile)
{
  return GEAcompile (pattern, size, RE_SYNTAX_AWK);
}

COMPILE_FCT(Ecompile)
{
  return GEAcompile (pattern, size, RE_SYNTAX_POSIX_EGREP);
}
#endif /* !EGREP_PROGRAM */

EXECUTE_FCT(EGexecute)
{
  char const *buflim, *beg, *end, *match, *best_match, *mb_start;
  char eol = eolbyte;
  int backref, start, len, best_len;
  struct kwsmatch kwsm;
  size_t i, ret_val;
#ifdef MBS_SUPPORT
  if (MB_CUR_MAX > 1)
    {
      if (match_icase)
        {
          /* mbtolower adds a NUL byte at the end.  That will provide
	     space for the sentinel byte dfaexec may add.  */
          char *case_buf = mbtolower (buf, &size);
	  if (start_ptr)
	    start_ptr = case_buf + (start_ptr - buf);
          buf = case_buf;
        }
    }
#endif /* MBS_SUPPORT */

  mb_start = buf;
  buflim = buf + size;

  for (beg = end = buf; end < buflim; beg = end)
    {
      if (!start_ptr)
	{
	  /* We don't care about an exact match.  */
	  if (kwset)
	    {
	      /* Find a possible match using the KWset matcher. */
	      size_t offset = kwsexec (kwset, beg, buflim - beg, &kwsm);
	      if (offset == (size_t) -1)
		goto failure;
	      beg += offset;
	      /* Narrow down to the line containing the candidate, and
		 run it through DFA. */
	      if ((end = memchr(beg, eol, buflim - beg)) != NULL)
	        end++;
              else
                end = buflim;
	      match = beg;
	      while (beg > buf && beg[-1] != eol)
		--beg;
	      if (kwsm.index < kwset_exact_matches)
                {
#ifdef MBS_SUPPORT
                  if (mb_start < beg)
                    mb_start = beg;
                  if (MB_CUR_MAX == 1 || !is_mb_middle (&mb_start, match, buflim))
#endif
                    goto success;
                }
	      if (dfaexec (&dfa, beg, (char *) end, 0, NULL, &backref) == NULL)
		continue;
	    }
	  else
	    {
	      /* No good fixed strings; start with DFA. */
	      char const *next_beg = dfaexec (&dfa, beg, (char *) buflim,
					      0, NULL, &backref);
	      if (next_beg == NULL)
		break;
	      /* Narrow down to the line we've found. */
	      beg = next_beg;
	      if ((end = memchr(beg, eol, buflim - beg)) != NULL)
	        end++;
              else
                end = buflim;
	      while (beg > buf && beg[-1] != eol)
		--beg;
	    }
	  /* Successful, no backreferences encountered! */
	  if (!backref)
	    goto success;
	}
      else
	{
	  /* We are looking for the leftmost (then longest) exact match.
	     We will go through the outer loop only once.  */
	  beg = start_ptr;
	  end = buflim;
	}

      /* If we've made it to this point, this means DFA has seen
	 a probable match, and we need to run it through Regex. */
      best_match = end;
      best_len = 0;
      for (i = 0; i < pcount; i++)
	{
	  patterns[i].regexbuf.not_eol = 0;
	  if (0 <= (start = re_search (&(patterns[i].regexbuf),
				       buf, end - buf - 1,
				       beg - buf, end - beg - 1,
				       &(patterns[i].regs))))
	    {
	      len = patterns[i].regs.end[0] - start;
	      match = buf + start;
	      if (match > best_match)
		continue;
	      if (start_ptr && !match_words)
		goto assess_pattern_match;
	      if ((!match_lines && !match_words)
		  || (match_lines && len == end - beg - 1))
		{
		  match = beg;
		  len = end - beg;
		  goto assess_pattern_match;
		}
	      /* If -w, check if the match aligns with word boundaries.
		 We do this iteratively because:
		 (a) the line may contain more than one occurence of the
		 pattern, and
		 (b) Several alternatives in the pattern might be valid at a
		 given point, and we may need to consider a shorter one to
		 find a word boundary.  */
	      if (match_words)
		while (match <= best_match)
		  {
		    if ((match == buf || !WCHAR ((unsigned char) match[-1]))
			&& (len == end - beg - 1
			    || !WCHAR ((unsigned char) match[len])))
		      goto assess_pattern_match;
		    if (len > 0)
		      {
			/* Try a shorter length anchored at the same place. */
			--len;
			patterns[i].regexbuf.not_eol = 1;
			len = re_match (&(patterns[i].regexbuf),
					buf, match + len - beg, match - buf,
					&(patterns[i].regs));
		      }
		    if (len <= 0)
		      {
			/* Try looking further on. */
			if (match == end - 1)
			  break;
			match++;
			patterns[i].regexbuf.not_eol = 0;
			start = re_search (&(patterns[i].regexbuf),
					   buf, end - buf - 1,
					   match - buf, end - match - 1,
					   &(patterns[i].regs));
			if (start < 0)
			  break;
			len = patterns[i].regs.end[0] - start;
			match = buf + start;
		      }
		  } /* while (match <= best_match) */
	      continue;
	    assess_pattern_match:
	      if (!start_ptr)
		{
		  /* Good enough for a non-exact match.
		     No need to look at further patterns, if any.  */
		  beg = match;
		  goto success_in_len;
		}
	      if (match < best_match || (match == best_match && len > best_len))
		{
		  /* Best exact match:  leftmost, then longest.  */
		  best_match = match;
		  best_len = len;
		}
	    } /* if re_search >= 0 */
	} /* for Regex patterns.  */
	if (best_match < end)
	  {
	    /* We have found an exact match.  We were just
	       waiting for the best one (leftmost then longest).  */
	    beg = best_match;
	    len = best_len;
	    goto success_in_len;
	  }
    } /* for (beg = end ..) */

 failure:
  ret_val = -1;
  goto out;

 success:
  len = end - beg;
 success_in_len:
  *match_size = len;
  ret_val = beg - buf;
 out:
  return ret_val;
}
#endif /* defined(GREP_PROGRAM) || defined(EGREP_PROGRAM) */

#if defined(GREP_PROGRAM) || defined(FGREP_PROGRAM)
COMPILE_FCT(Fcompile)
{
  char const *beg, *end, *lim, *err, *pat;
  size_t psize;

  kwsinit ();
  psize = size;
  if (match_icase && MB_CUR_MAX > 1)
    pat = mbtolower (pattern, &psize);
  else
    pat = pattern;

  beg = pat;
  do
    {
      for (lim = beg;; ++lim)
	{
	  end = lim;
	  if (lim >= pat + psize)
	    break;
	 if (*lim == '\n')
	   {
	     lim++;
	     break;
	   }
#if HAVE_DOS_FILE_CONTENTS
	 if (*lim == '\r' && lim + 1 < pat + psize && lim[1] == '\n')
	   {
	     lim += 2;
	     break;
	   }
#endif
	}

      if ((err = kwsincr (kwset, beg, end - beg)) != NULL)
	error (EXIT_TROUBLE, 0, "%s", err);
      beg = lim;
    }
  while (beg < pat + psize);

  if ((err = kwsprep (kwset)) != NULL)
    error (EXIT_TROUBLE, 0, "%s", err);
}

EXECUTE_FCT(Fexecute)
{
  char const *beg, *try, *end, *mb_start;
  size_t len;
  char eol = eolbyte;
  struct kwsmatch kwsmatch;
  size_t ret_val;
#ifdef MBS_SUPPORT
  if (MB_CUR_MAX > 1)
    {
      if (match_icase)
        {
          char *case_buf = mbtolower (buf, &size);
	  if (start_ptr)
	    start_ptr = case_buf + (start_ptr - buf);
          buf = case_buf;
        }
    }
#endif /* MBS_SUPPORT */

  for (mb_start = beg = start_ptr ? start_ptr : buf; beg <= buf + size; beg++)
    {
      size_t offset = kwsexec (kwset, beg, buf + size - beg, &kwsmatch);
      if (offset == (size_t) -1)
	goto failure;
#ifdef MBS_SUPPORT
      if (MB_CUR_MAX > 1 && is_mb_middle (&mb_start, beg + offset, buf + size))
        {
          beg = mb_start - 1;
          continue; /* It is a part of multibyte character.  */
        }
#endif /* MBS_SUPPORT */
      beg += offset;
      len = kwsmatch.size[0];
      if (start_ptr && !match_words)
	goto success_in_beg_and_len;
      if (match_lines)
	{
	  if (beg > buf && beg[-1] != eol)
	    continue;
	  if (beg + len < buf + size && beg[len] != eol)
	    continue;
	  goto success;
	}
      else if (match_words)
	for (try = beg; len; )
	  {
	    if (try > buf && WCHAR((unsigned char) try[-1]))
	      break;
	    if (try + len < buf + size && WCHAR((unsigned char) try[len]))
	      {
		offset = kwsexec (kwset, beg, --len, &kwsmatch);
		if (offset == (size_t) -1)
		  break;
		try = beg + offset;
		len = kwsmatch.size[0];
	      }
	    else if (!start_ptr)
	      goto success;
	    else
	      goto success_in_beg_and_len;
	  } /* for (try) */
      else
	goto success;
    } /* for (beg in buf) */

 failure:
  ret_val = -1;
  goto out;

 success:
  if ((end = memchr (beg + len, eol, (buf + size) - (beg + len))) != NULL)
    end++;
  else
    end = buf + size;
  while (buf < beg && beg[-1] != eol)
    --beg;
  len = end - beg;
 success_in_beg_and_len:
  *match_size = len;
  ret_val = beg - buf;
 out:
  return ret_val;
}
#endif /* defined(GREP_PROGRAM) || defined(FGREP_PROGRAM) */

#ifdef GREP_PROGRAM
#if HAVE_LIBPCRE
/* Compiled internal form of a Perl regular expression.  */
static pcre *cre;

/* Additional information about the pattern.  */
static pcre_extra *extra;
#endif

COMPILE_FCT(Pcompile)
{
#if !HAVE_LIBPCRE
  error (EXIT_TROUBLE, 0, "%s",
	 _("support for the -P option is not compiled into "
	   "this --disable-perl-regexp binary"));
#else
  int e;
  char const *ep;
  char *re = xmalloc (4 * size + 7);
  int flags = PCRE_MULTILINE | (match_icase ? PCRE_CASELESS : 0);
  char const *patlim = pattern + size;
  char *n = re;
  char const *p;
  char const *pnul;

  /* FIXME: Remove these restrictions.  */
  if (memchr(pattern, '\n', size))
    error (EXIT_TROUBLE, 0, _("the -P option only supports a single pattern"));

  *n = '\0';
  if (match_lines)
    strcpy (n, "^(");
  if (match_words)
    strcpy (n, "\\b(");
  n += strlen (n);

  /* The PCRE interface doesn't allow NUL bytes in the pattern, so
     replace each NUL byte in the pattern with the four characters
     "\000", removing a preceding backslash if there are an odd
     number of backslashes before the NUL.

     FIXME: This method does not work with some multibyte character
     encodings, notably Shift-JIS, where a multibyte character can end
     in a backslash byte.  */
  for (p = pattern; (pnul = memchr (p, '\0', patlim - p)); p = pnul + 1)
    {
      memcpy (n, p, pnul - p);
      n += pnul - p;
      for (p = pnul; pattern < p && p[-1] == '\\'; p--)
	continue;
      n -= (pnul - p) & 1;
      strcpy (n, "\\000");
      n += 4;
    }

  memcpy (n, p, patlim - p);
  n += patlim - p;
  *n = '\0';
  if (match_words)
    strcpy (n, ")\\b");
  if (match_lines)
    strcpy (n, ")$");

  cre = pcre_compile (re, flags, &ep, &e, pcre_maketables ());
  if (!cre)
    error (EXIT_TROUBLE, 0, "%s", ep);

  extra = pcre_study (cre, 0, &ep);
  if (ep)
    error (EXIT_TROUBLE, 0, "%s", ep);

  free (re);
#endif
}

EXECUTE_FCT(Pexecute)
{
#if !HAVE_LIBPCRE
  abort ();
  return -1;
#else
  /* This array must have at least two elements; everything after that
     is just for performance improvement in pcre_exec.  */
  int sub[300];

  const char *line_buf, *line_end, *line_next;
  int e = PCRE_ERROR_NOMATCH;
  ptrdiff_t start_ofs = start_ptr ? start_ptr - buf : 0;

  /* PCRE can't limit the matching to single lines, therefore we have to
     match each line in the buffer separately.  */
  for (line_next = buf;
       e == PCRE_ERROR_NOMATCH && line_next < buf + size;
       start_ofs -= line_next - line_buf)
    {
      line_buf = line_next;
      line_end = memchr (line_buf, eolbyte, (buf + size) - line_buf);
      if (line_end == NULL)
        line_next = line_end = buf + size;
      else
        line_next = line_end + 1;

      if (start_ptr && start_ptr >= line_end)
        continue;

      e = pcre_exec (cre, extra, line_buf, line_end - line_buf,
                     start_ofs < 0 ? 0 : start_ofs, 0,
                     sub, sizeof sub / sizeof *sub);
    }

  if (e <= 0)
    {
      switch (e)
	{
	case PCRE_ERROR_NOMATCH:
	  return -1;

	case PCRE_ERROR_NOMEMORY:
	  error (EXIT_TROUBLE, 0, _("memory exhausted"));

	default:
	  abort ();
	}
    }
  else
    {
      /* Narrow down to the line we've found.  */
      char const *beg = line_buf + sub[0];
      char const *end = line_buf + sub[1];
      char const *buflim = buf + size;
      char eol = eolbyte;
      if (!start_ptr)
	{
	  /* FIXME: The case when '\n' is not found indicates a bug:
	     Since grep is line oriented, the match should never contain
	     a newline, so there _must_ be a newline following.
	   */
	  if (!(end = memchr (end, eol, buflim - end)))
	    end = buflim;
	  else
	    end++;
	  while (buf < beg && beg[-1] != eol)
	    --beg;
	}

      *match_size = end - beg;
      return beg - buf;
    }
#endif
}

struct matcher const matchers[] = {
  { "default", Gcompile, EGexecute },
  { "grep",    Gcompile, EGexecute },
  { "egrep",   Ecompile, EGexecute },
  { "awk",     Acompile, EGexecute },
  { "fgrep",   Fcompile, Fexecute },
  { "perl",    Pcompile, Pexecute },
  { "", 0, 0 },
};
#endif /* GREP_PROGRAM */

Testing negative cases!
Running test command:
/home/ubuntu/spr-fast/tools/grep-test.py /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-deccad69-db9d6340/tempworkdir2/src /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-deccad69-db9d6340/tempworkdir2/tests /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-deccad69-db9d6340/tempworkdir2 0  > __res
Building:src at:
/home/ubuntu/spr-fast/tests/corebench/grep/grep-case-deccad69-db9d6340/tempworkdir2/srcBasicTester, Testing instance id 4:
//src_file:src/search.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
/* search.c - searching subroutines using dfa, kwset and regex for grep.
   Copyright 1992, 1998, 2000, 2007, 2009-2010 Free Software Foundation, Inc.

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 3, or (at your option)
   any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program; if not, write to the Free Software
   Foundation, Inc., 51 Franklin Street - Fifth Floor, Boston, MA
   02110-1301, USA.  */

/* Written August 1992 by Mike Haertel. */

#include <config.h>

#include <sys/types.h>

#include "mbsupport.h"
#ifdef MBS_SUPPORT
/* We can handle multibyte strings. */
# include <wchar.h>
# include <wctype.h>
#endif

#include "system.h"
#include "grep.h"
#ifndef FGREP_PROGRAM
# include <regex.h>
# include "dfa.h"
#endif
#include "kwset.h"
#include "error.h"
#include "xalloc.h"
#ifdef HAVE_LIBPCRE
# include <pcre.h>
#endif

#define NCHAR (UCHAR_MAX + 1)

/* For -w, we also consider _ to be word constituent.  */
#define WCHAR(C) (ISALNUM(C) || (C) == '_')

/* KWset compiled pattern.  For Ecompile and Gcompile, we compile
   a list of strings, at least one of which is known to occur in
   any string matching the regexp. */
static kwset_t kwset;

static void
kwsinit (void)
{
  static char trans[NCHAR];
  int i;

  if (match_icase && MB_CUR_MAX == 1)
    {
      for (i = 0; i < NCHAR; ++i)
        trans[i] = TOLOWER (i);

      kwset = kwsalloc (trans);
    }
  else
    kwset = kwsalloc (NULL);

  if (!kwset)
    xalloc_die ();
}

#ifdef MBS_SUPPORT
/* Convert the *N-byte string, BEG, to lowercase, and write the
   NUL-terminated result into malloc'd storage.  Upon success, set *N
   to the length (in bytes) of the resulting string (not including the
   trailing NUL byte), and return a pointer to the lowercase string.
   Upon memory allocation failure, this function exits.

   Note that while this function returns a pointer to malloc'd storage,
   the caller must not free it, since this function retains a pointer
   to the buffer and reuses it on any subsequent call.  As a consequence,
   this function is not thread-safe.  */
static char *
mbtolower (const char *beg, size_t *n)
{
  static char *out;
  static size_t outalloc;
  size_t outlen, mb_cur_max;
  mbstate_t is, os;
  const char *end;
  char *p;

  if (*n > outalloc)
    {
      out = xrealloc (out, *n);
      outalloc = *n;
    }

  memset (&is, 0, sizeof (is));
  memset (&os, 0, sizeof (os));
  end = beg + *n;

  mb_cur_max = MB_CUR_MAX;
  p = out;
  outlen = 0;
  while (beg < end)
    {
      wchar_t wc;
      size_t mbclen = mbrtowc(&wc, beg, end - beg, &is);
      if (outlen + mb_cur_max >= outalloc)
        {
          out = x2nrealloc (out, &outalloc, 1);
          p = out + outlen;
        }

      if (mbclen == (size_t) -1 || mbclen == (size_t) -2 || mbclen == 0)
        {
          /* An invalid sequence, or a truncated multi-octet character.
             We treat it as a single-octet character.  */
          *p++ = *beg++;
          outlen++;
          memset (&is, 0, sizeof (is));
          memset (&os, 0, sizeof (os));
        }
      else
        {
          beg += mbclen;
          mbclen = wcrtomb (p, towlower ((wint_t) wc), &os);
          p += mbclen;
          outlen += mbclen;
        }
    }

  *n = p - out;
  *p++ = 0;
  return out;
}
#endif


#ifndef FGREP_PROGRAM
/* DFA compiled regexp. */
static struct dfa dfa;

/* The Regex compiled patterns.  */
static struct patterns
{
  /* Regex compiled regexp. */
  struct re_pattern_buffer regexbuf;
  struct re_registers regs; /* This is here on account of a BRAIN-DEAD
			       Q@#%!# library interface in regex.c.  */
} patterns0;

struct patterns *patterns;
size_t pcount;

void
dfaerror (char const *mesg)
{
  error (EXIT_TROUBLE, 0, "%s", mesg);
}

/* Number of compiled fixed strings known to exactly match the regexp.
   If kwsexec returns < kwset_exact_matches, then we don't need to
   call the regexp matcher at all. */
static int kwset_exact_matches;

static char const *
kwsincr_case (const char *must)
{
  const char *buf;
  size_t n;

  n = strlen (must);
#ifdef MBS_SUPPORT
  if (match_icase && MB_CUR_MAX > 1)
    buf = mbtolower (must, &n);
  else
#endif
    buf = must;
  return kwsincr (kwset, buf, n);
}

/* If the DFA turns out to have some set of fixed strings one of
   which must occur in the match, then we build a kwset matcher
   to find those strings, and thus quickly filter out impossible
   matches. */
static void
kwsmusts (void)
{
  struct dfamust const *dm;
  char const *err;

  if (dfa.musts)
    {
      kwsinit ();
      /* First, we compile in the substrings known to be exact
	 matches.  The kwset matcher will return the index
	 of the matching string that it chooses. */
      for (dm = dfa.musts; dm; dm = dm->next)
	{
	  if (!dm->exact)
	    continue;
	  ++kwset_exact_matches;
	  if ((err = kwsincr_case (dm->must)) != NULL)
	    error (EXIT_TROUBLE, 0, "%s", err);
	}
      /* Now, we compile the substrings that will require
	 the use of the regexp matcher.  */
      for (dm = dfa.musts; dm; dm = dm->next)
	{
	  if (dm->exact)
	    continue;
	  if ((err = kwsincr_case (dm->must)) != NULL)
	    error (EXIT_TROUBLE, 0, "%s", err);
	}
      if ((err = kwsprep (kwset)) != NULL)
	error (EXIT_TROUBLE, 0, "%s", err);
    }
}
#endif /* !FGREP_PROGRAM */

#ifdef MBS_SUPPORT

static bool
is_mb_middle(const char **good, const char *buf, const char *end)
{
  const char *p = *good;
  const char *prev = p;
  mbstate_t cur_state;

  /* TODO: can be optimized for UTF-8.  */
  
//Patch 0:
prev = p;
memset(&cur_state, 0, sizeof(mbstate_t));

//CodeSeg 1:
  while (p < buf)
    {
      size_t mbclen = mbrlen(p, end - p, &cur_state);

      /* Store the beginning of the previous complete multibyte character.  */
      if (mbclen != (size_t) -2)
        prev = p;

      if (mbclen == (size_t) -1 || mbclen == (size_t) -2 || mbclen == 0)
	{
	  /* An invalid sequence, or a truncated multibyte character.
	     We treat it as a single byte character.  */
	  mbclen = 1;
	}
      p += mbclen;
    }

  *good = prev;
  return p > buf;
}
#endif /* MBS_SUPPORT */

#if defined(GREP_PROGRAM) || defined(EGREP_PROGRAM)
#ifdef EGREP_PROGRAM
COMPILE_FCT(Ecompile)
{
  reg_syntax_t syntax_bits = RE_SYNTAX_POSIX_EGREP;
#else
/* No __VA_ARGS__ in C89.  So we have to do it this way.  */
static COMPILE_RET
GEAcompile (char const *pattern, size_t size, reg_syntax_t syntax_bits)
{
#endif /* EGREP_PROGRAM */
  const char *err;
  const char *p, *sep;
  size_t total = size;
  char *motif;

  if (match_icase)
    syntax_bits |= RE_ICASE;
  re_set_syntax (syntax_bits);
  dfasyntax (syntax_bits, match_icase, eolbyte);

  /* For GNU regex compiler we have to pass the patterns separately to detect
     errors like "[\nallo\n]\n".  The patterns here are "[", "allo" and "]"
     GNU regex should have raise a syntax error.  The same for backref, where
     the backref should have been local to each pattern.  */
  p = pattern;
  do
    {
      size_t len;
      sep = memchr (p, '\n', total);
      if (sep)
	{
	  len = sep - p;
	  sep++;
	  total -= (len + 1);
	}
      else
	{
	  len = total;
	  total = 0;
	}

      patterns = realloc (patterns, (pcount + 1) * sizeof (*patterns));
      if (patterns == NULL)
	error (EXIT_TROUBLE, errno, _("memory exhausted"));
      patterns[pcount] = patterns0;

      if ((err = re_compile_pattern (p, len,
				    &(patterns[pcount].regexbuf))) != NULL)
	error (EXIT_TROUBLE, 0, "%s", err);
      pcount++;

      p = sep;
    } while (sep && total != 0);

  /* In the match_words and match_lines cases, we use a different pattern
     for the DFA matcher that will quickly throw out cases that won't work.
     Then if DFA succeeds we do some hairy stuff using the regex matcher
     to decide whether the match should really count. */
  if (match_words || match_lines)
    {
      static char const line_beg_no_bk[] = "^(";
      static char const line_end_no_bk[] = ")$";
      static char const word_beg_no_bk[] = "(^|[^[:alnum:]_])(";
      static char const word_end_no_bk[] = ")([^[:alnum:]_]|$)";
#ifdef EGREP_PROGRAM
# define IF_BK(x, y) (y)
      char *n = xmalloc (sizeof word_beg_no_bk - 1 + size + sizeof word_end_no_bk);
#else
      static char const line_beg_bk[] = "^\\(";
      static char const line_end_bk[] = "\\)$";
      static char const word_beg_bk[] = "\\(^\\|[^[:alnum:]_]\\)\\(";
      static char const word_end_bk[] = "\\)\\([^[:alnum:]_]\\|$\\)";
      int bk = !(syntax_bits & RE_NO_BK_PARENS);
# define IF_BK(x, y) ((bk) ? (x) : (y))
      char *n = xmalloc (sizeof word_beg_bk - 1 + size + sizeof word_end_bk);
#endif /* EGREP_PROGRAM */

      strcpy (n, match_lines ? IF_BK(line_beg_bk, line_beg_no_bk)
			     : IF_BK(word_beg_bk, word_beg_no_bk));
      total = strlen(n);
      memcpy (n + total, pattern, size);
      total += size;
      strcpy (n + total, match_lines ? IF_BK(line_end_bk, line_end_no_bk)
				     : IF_BK(word_end_bk, word_end_no_bk));
      total += strlen (n + total);
      pattern = motif = n;
      size = total;
    }
  else
    motif = NULL;

  dfacomp (pattern, size, &dfa, 1);
  kwsmusts ();

  free(motif);
}

#ifndef EGREP_PROGRAM
COMPILE_FCT(Gcompile)
{
  return GEAcompile (pattern, size,
		     RE_SYNTAX_GREP | RE_HAT_LISTS_NOT_NEWLINE);
}

COMPILE_FCT(Acompile)
{
  return GEAcompile (pattern, size, RE_SYNTAX_AWK);
}

COMPILE_FCT(Ecompile)
{
  return GEAcompile (pattern, size, RE_SYNTAX_POSIX_EGREP);
}
#endif /* !EGREP_PROGRAM */

EXECUTE_FCT(EGexecute)
{
  char const *buflim, *beg, *end, *match, *best_match, *mb_start;
  char eol = eolbyte;
  int backref, start, len, best_len;
  struct kwsmatch kwsm;
  size_t i, ret_val;
#ifdef MBS_SUPPORT
  if (MB_CUR_MAX > 1)
    {
      if (match_icase)
        {
          /* mbtolower adds a NUL byte at the end.  That will provide
	     space for the sentinel byte dfaexec may add.  */
          char *case_buf = mbtolower (buf, &size);
	  if (start_ptr)
	    start_ptr = case_buf + (start_ptr - buf);
          buf = case_buf;
        }
    }
#endif /* MBS_SUPPORT */

  mb_start = buf;
  buflim = buf + size;

  for (beg = end = buf; end < buflim; beg = end)
    {
      if (!start_ptr)
	{
	  /* We don't care about an exact match.  */
	  if (kwset)
	    {
	      /* Find a possible match using the KWset matcher. */
	      size_t offset = kwsexec (kwset, beg, buflim - beg, &kwsm);
	      if (offset == (size_t) -1)
		goto failure;
	      beg += offset;
	      /* Narrow down to the line containing the candidate, and
		 run it through DFA. */
	      if ((end = memchr(beg, eol, buflim - beg)) != NULL)
	        end++;
              else
                end = buflim;
	      match = beg;
	      while (beg > buf && beg[-1] != eol)
		--beg;
	      if (kwsm.index < kwset_exact_matches)
                {
#ifdef MBS_SUPPORT
                  if (mb_start < beg)
                    mb_start = beg;
                  if (MB_CUR_MAX == 1 || !is_mb_middle (&mb_start, match, buflim))
#endif
                    goto success;
                }
	      if (dfaexec (&dfa, beg, (char *) end, 0, NULL, &backref) == NULL)
		continue;
	    }
	  else
	    {
	      /* No good fixed strings; start with DFA. */
	      char const *next_beg = dfaexec (&dfa, beg, (char *) buflim,
					      0, NULL, &backref);
	      if (next_beg == NULL)
		break;
	      /* Narrow down to the line we've found. */
	      beg = next_beg;
	      if ((end = memchr(beg, eol, buflim - beg)) != NULL)
	        end++;
              else
                end = buflim;
	      while (beg > buf && beg[-1] != eol)
		--beg;
	    }
	  /* Successful, no backreferences encountered! */
	  if (!backref)
	    goto success;
	}
      else
	{
	  /* We are looking for the leftmost (then longest) exact match.
	     We will go through the outer loop only once.  */
	  beg = start_ptr;
	  end = buflim;
	}

      /* If we've made it to this point, this means DFA has seen
	 a probable match, and we need to run it through Regex. */
      best_match = end;
      best_len = 0;
      for (i = 0; i < pcount; i++)
	{
	  patterns[i].regexbuf.not_eol = 0;
	  if (0 <= (start = re_search (&(patterns[i].regexbuf),
				       buf, end - buf - 1,
				       beg - buf, end - beg - 1,
				       &(patterns[i].regs))))
	    {
	      len = patterns[i].regs.end[0] - start;
	      match = buf + start;
	      if (match > best_match)
		continue;
	      if (start_ptr && !match_words)
		goto assess_pattern_match;
	      if ((!match_lines && !match_words)
		  || (match_lines && len == end - beg - 1))
		{
		  match = beg;
		  len = end - beg;
		  goto assess_pattern_match;
		}
	      /* If -w, check if the match aligns with word boundaries.
		 We do this iteratively because:
		 (a) the line may contain more than one occurence of the
		 pattern, and
		 (b) Several alternatives in the pattern might be valid at a
		 given point, and we may need to consider a shorter one to
		 find a word boundary.  */
	      if (match_words)
		while (match <= best_match)
		  {
		    if ((match == buf || !WCHAR ((unsigned char) match[-1]))
			&& (len == end - beg - 1
			    || !WCHAR ((unsigned char) match[len])))
		      goto assess_pattern_match;
		    if (len > 0)
		      {
			/* Try a shorter length anchored at the same place. */
			--len;
			patterns[i].regexbuf.not_eol = 1;
			len = re_match (&(patterns[i].regexbuf),
					buf, match + len - beg, match - buf,
					&(patterns[i].regs));
		      }
		    if (len <= 0)
		      {
			/* Try looking further on. */
			if (match == end - 1)
			  break;
			match++;
			patterns[i].regexbuf.not_eol = 0;
			start = re_search (&(patterns[i].regexbuf),
					   buf, end - buf - 1,
					   match - buf, end - match - 1,
					   &(patterns[i].regs));
			if (start < 0)
			  break;
			len = patterns[i].regs.end[0] - start;
			match = buf + start;
		      }
		  } /* while (match <= best_match) */
	      continue;
	    assess_pattern_match:
	      if (!start_ptr)
		{
		  /* Good enough for a non-exact match.
		     No need to look at further patterns, if any.  */
		  beg = match;
		  goto success_in_len;
		}
	      if (match < best_match || (match == best_match && len > best_len))
		{
		  /* Best exact match:  leftmost, then longest.  */
		  best_match = match;
		  best_len = len;
		}
	    } /* if re_search >= 0 */
	} /* for Regex patterns.  */
	if (best_match < end)
	  {
	    /* We have found an exact match.  We were just
	       waiting for the best one (leftmost then longest).  */
	    beg = best_match;
	    len = best_len;
	    goto success_in_len;
	  }
    } /* for (beg = end ..) */

 failure:
  ret_val = -1;
  goto out;

 success:
  len = end - beg;
 success_in_len:
  *match_size = len;
  ret_val = beg - buf;
 out:
  return ret_val;
}
#endif /* defined(GREP_PROGRAM) || defined(EGREP_PROGRAM) */

#if defined(GREP_PROGRAM) || defined(FGREP_PROGRAM)
COMPILE_FCT(Fcompile)
{
  char const *beg, *end, *lim, *err, *pat;
  size_t psize;

  kwsinit ();
  psize = size;
  if (match_icase && MB_CUR_MAX > 1)
    pat = mbtolower (pattern, &psize);
  else
    pat = pattern;

  beg = pat;
  do
    {
      for (lim = beg;; ++lim)
	{
	  end = lim;
	  if (lim >= pat + psize)
	    break;
	 if (*lim == '\n')
	   {
	     lim++;
	     break;
	   }
#if HAVE_DOS_FILE_CONTENTS
	 if (*lim == '\r' && lim + 1 < pat + psize && lim[1] == '\n')
	   {
	     lim += 2;
	     break;
	   }
#endif
	}

      if ((err = kwsincr (kwset, beg, end - beg)) != NULL)
	error (EXIT_TROUBLE, 0, "%s", err);
      beg = lim;
    }
  while (beg < pat + psize);

  if ((err = kwsprep (kwset)) != NULL)
    error (EXIT_TROUBLE, 0, "%s", err);
}

EXECUTE_FCT(Fexecute)
{
  char const *beg, *try, *end, *mb_start;
  size_t len;
  char eol = eolbyte;
  struct kwsmatch kwsmatch;
  size_t ret_val;
#ifdef MBS_SUPPORT
  if (MB_CUR_MAX > 1)
    {
      if (match_icase)
        {
          char *case_buf = mbtolower (buf, &size);
	  if (start_ptr)
	    start_ptr = case_buf + (start_ptr - buf);
          buf = case_buf;
        }
    }
#endif /* MBS_SUPPORT */

  for (mb_start = beg = start_ptr ? start_ptr : buf; beg <= buf + size; beg++)
    {
      size_t offset = kwsexec (kwset, beg, buf + size - beg, &kwsmatch);
      if (offset == (size_t) -1)
	goto failure;
#ifdef MBS_SUPPORT
      if (MB_CUR_MAX > 1 && is_mb_middle (&mb_start, beg + offset, buf + size))
        {
          beg = mb_start - 1;
          continue; /* It is a part of multibyte character.  */
        }
#endif /* MBS_SUPPORT */
      beg += offset;
      len = kwsmatch.size[0];
      if (start_ptr && !match_words)
	goto success_in_beg_and_len;
      if (match_lines)
	{
	  if (beg > buf && beg[-1] != eol)
	    continue;
	  if (beg + len < buf + size && beg[len] != eol)
	    continue;
	  goto success;
	}
      else if (match_words)
	for (try = beg; len; )
	  {
	    if (try > buf && WCHAR((unsigned char) try[-1]))
	      break;
	    if (try + len < buf + size && WCHAR((unsigned char) try[len]))
	      {
		offset = kwsexec (kwset, beg, --len, &kwsmatch);
		if (offset == (size_t) -1)
		  break;
		try = beg + offset;
		len = kwsmatch.size[0];
	      }
	    else if (!start_ptr)
	      goto success;
	    else
	      goto success_in_beg_and_len;
	  } /* for (try) */
      else
	goto success;
    } /* for (beg in buf) */

 failure:
  ret_val = -1;
  goto out;

 success:
  if ((end = memchr (beg + len, eol, (buf + size) - (beg + len))) != NULL)
    end++;
  else
    end = buf + size;
  while (buf < beg && beg[-1] != eol)
    --beg;
  len = end - beg;
 success_in_beg_and_len:
  *match_size = len;
  ret_val = beg - buf;
 out:
  return ret_val;
}
#endif /* defined(GREP_PROGRAM) || defined(FGREP_PROGRAM) */

#ifdef GREP_PROGRAM
#if HAVE_LIBPCRE
/* Compiled internal form of a Perl regular expression.  */
static pcre *cre;

/* Additional information about the pattern.  */
static pcre_extra *extra;
#endif

COMPILE_FCT(Pcompile)
{
#if !HAVE_LIBPCRE
  error (EXIT_TROUBLE, 0, "%s",
	 _("support for the -P option is not compiled into "
	   "this --disable-perl-regexp binary"));
#else
  int e;
  char const *ep;
  char *re = xmalloc (4 * size + 7);
  int flags = PCRE_MULTILINE | (match_icase ? PCRE_CASELESS : 0);
  char const *patlim = pattern + size;
  char *n = re;
  char const *p;
  char const *pnul;

  /* FIXME: Remove these restrictions.  */
  if (memchr(pattern, '\n', size))
    error (EXIT_TROUBLE, 0, _("the -P option only supports a single pattern"));

  *n = '\0';
  if (match_lines)
    strcpy (n, "^(");
  if (match_words)
    strcpy (n, "\\b(");
  n += strlen (n);

  /* The PCRE interface doesn't allow NUL bytes in the pattern, so
     replace each NUL byte in the pattern with the four characters
     "\000", removing a preceding backslash if there are an odd
     number of backslashes before the NUL.

     FIXME: This method does not work with some multibyte character
     encodings, notably Shift-JIS, where a multibyte character can end
     in a backslash byte.  */
  for (p = pattern; (pnul = memchr (p, '\0', patlim - p)); p = pnul + 1)
    {
      memcpy (n, p, pnul - p);
      n += pnul - p;
      for (p = pnul; pattern < p && p[-1] == '\\'; p--)
	continue;
      n -= (pnul - p) & 1;
      strcpy (n, "\\000");
      n += 4;
    }

  memcpy (n, p, patlim - p);
  n += patlim - p;
  *n = '\0';
  if (match_words)
    strcpy (n, ")\\b");
  if (match_lines)
    strcpy (n, ")$");

  cre = pcre_compile (re, flags, &ep, &e, pcre_maketables ());
  if (!cre)
    error (EXIT_TROUBLE, 0, "%s", ep);

  extra = pcre_study (cre, 0, &ep);
  if (ep)
    error (EXIT_TROUBLE, 0, "%s", ep);

  free (re);
#endif
}

EXECUTE_FCT(Pexecute)
{
#if !HAVE_LIBPCRE
  abort ();
  return -1;
#else
  /* This array must have at least two elements; everything after that
     is just for performance improvement in pcre_exec.  */
  int sub[300];

  const char *line_buf, *line_end, *line_next;
  int e = PCRE_ERROR_NOMATCH;
  ptrdiff_t start_ofs = start_ptr ? start_ptr - buf : 0;

  /* PCRE can't limit the matching to single lines, therefore we have to
     match each line in the buffer separately.  */
  for (line_next = buf;
       e == PCRE_ERROR_NOMATCH && line_next < buf + size;
       start_ofs -= line_next - line_buf)
    {
      line_buf = line_next;
      line_end = memchr (line_buf, eolbyte, (buf + size) - line_buf);
      if (line_end == NULL)
        line_next = line_end = buf + size;
      else
        line_next = line_end + 1;

      if (start_ptr && start_ptr >= line_end)
        continue;

      e = pcre_exec (cre, extra, line_buf, line_end - line_buf,
                     start_ofs < 0 ? 0 : start_ofs, 0,
                     sub, sizeof sub / sizeof *sub);
    }

  if (e <= 0)
    {
      switch (e)
	{
	case PCRE_ERROR_NOMATCH:
	  return -1;

	case PCRE_ERROR_NOMEMORY:
	  error (EXIT_TROUBLE, 0, _("memory exhausted"));

	default:
	  abort ();
	}
    }
  else
    {
      /* Narrow down to the line we've found.  */
      char const *beg = line_buf + sub[0];
      char const *end = line_buf + sub[1];
      char const *buflim = buf + size;
      char eol = eolbyte;
      if (!start_ptr)
	{
	  /* FIXME: The case when '\n' is not found indicates a bug:
	     Since grep is line oriented, the match should never contain
	     a newline, so there _must_ be a newline following.
	   */
	  if (!(end = memchr (end, eol, buflim - end)))
	    end = buflim;
	  else
	    end++;
	  while (buf < beg && beg[-1] != eol)
	    --beg;
	}

      *match_size = end - beg;
      return beg - buf;
    }
#endif
}

struct matcher const matchers[] = {
  { "default", Gcompile, EGexecute },
  { "grep",    Gcompile, EGexecute },
  { "egrep",   Ecompile, EGexecute },
  { "awk",     Acompile, EGexecute },
  { "fgrep",   Fcompile, Fexecute },
  { "perl",    Pcompile, Pexecute },
  { "", 0, 0 },
};
#endif /* GREP_PROGRAM */

Testing negative cases!
Running test command:
/home/ubuntu/spr-fast/tools/grep-test.py /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-deccad69-db9d6340/tempworkdir2/src /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-deccad69-db9d6340/tempworkdir2/tests /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-deccad69-db9d6340/tempworkdir2 0  > __res
Building:src at:
/home/ubuntu/spr-fast/tests/corebench/grep/grep-case-deccad69-db9d6340/tempworkdir2/srcBasicTester, Testing instance id 5:
//src_file:src/search.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
/* search.c - searching subroutines using dfa, kwset and regex for grep.
   Copyright 1992, 1998, 2000, 2007, 2009-2010 Free Software Foundation, Inc.

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 3, or (at your option)
   any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program; if not, write to the Free Software
   Foundation, Inc., 51 Franklin Street - Fifth Floor, Boston, MA
   02110-1301, USA.  */

/* Written August 1992 by Mike Haertel. */

#include <config.h>

#include <sys/types.h>

#include "mbsupport.h"
#ifdef MBS_SUPPORT
/* We can handle multibyte strings. */
# include <wchar.h>
# include <wctype.h>
#endif

#include "system.h"
#include "grep.h"
#ifndef FGREP_PROGRAM
# include <regex.h>
# include "dfa.h"
#endif
#include "kwset.h"
#include "error.h"
#include "xalloc.h"
#ifdef HAVE_LIBPCRE
# include <pcre.h>
#endif

#define NCHAR (UCHAR_MAX + 1)

/* For -w, we also consider _ to be word constituent.  */
#define WCHAR(C) (ISALNUM(C) || (C) == '_')

/* KWset compiled pattern.  For Ecompile and Gcompile, we compile
   a list of strings, at least one of which is known to occur in
   any string matching the regexp. */
static kwset_t kwset;

static void
kwsinit (void)
{
  static char trans[NCHAR];
  int i;

  if (match_icase && MB_CUR_MAX == 1)
    {
      for (i = 0; i < NCHAR; ++i)
        trans[i] = TOLOWER (i);

      kwset = kwsalloc (trans);
    }
  else
    kwset = kwsalloc (NULL);

  if (!kwset)
    xalloc_die ();
}

#ifdef MBS_SUPPORT
/* Convert the *N-byte string, BEG, to lowercase, and write the
   NUL-terminated result into malloc'd storage.  Upon success, set *N
   to the length (in bytes) of the resulting string (not including the
   trailing NUL byte), and return a pointer to the lowercase string.
   Upon memory allocation failure, this function exits.

   Note that while this function returns a pointer to malloc'd storage,
   the caller must not free it, since this function retains a pointer
   to the buffer and reuses it on any subsequent call.  As a consequence,
   this function is not thread-safe.  */
static char *
mbtolower (const char *beg, size_t *n)
{
  static char *out;
  static size_t outalloc;
  size_t outlen, mb_cur_max;
  mbstate_t is, os;
  const char *end;
  char *p;

  if (*n > outalloc)
    {
      out = xrealloc (out, *n);
      outalloc = *n;
    }

  memset (&is, 0, sizeof (is));
  memset (&os, 0, sizeof (os));
  end = beg + *n;

  mb_cur_max = MB_CUR_MAX;
  p = out;
  outlen = 0;
  while (beg < end)
    {
      wchar_t wc;
      size_t mbclen = mbrtowc(&wc, beg, end - beg, &is);
      if (outlen + mb_cur_max >= outalloc)
        {
          out = x2nrealloc (out, &outalloc, 1);
          p = out + outlen;
        }

      if (mbclen == (size_t) -1 || mbclen == (size_t) -2 || mbclen == 0)
        {
          /* An invalid sequence, or a truncated multi-octet character.
             We treat it as a single-octet character.  */
          *p++ = *beg++;
          outlen++;
          memset (&is, 0, sizeof (is));
          memset (&os, 0, sizeof (os));
        }
      else
        {
          beg += mbclen;
          mbclen = wcrtomb (p, towlower ((wint_t) wc), &os);
          p += mbclen;
          outlen += mbclen;
        }
    }

  *n = p - out;
  *p++ = 0;
  return out;
}
#endif


#ifndef FGREP_PROGRAM
/* DFA compiled regexp. */
static struct dfa dfa;

/* The Regex compiled patterns.  */
static struct patterns
{
  /* Regex compiled regexp. */
  struct re_pattern_buffer regexbuf;
  struct re_registers regs; /* This is here on account of a BRAIN-DEAD
			       Q@#%!# library interface in regex.c.  */
} patterns0;

struct patterns *patterns;
size_t pcount;

void
dfaerror (char const *mesg)
{
  error (EXIT_TROUBLE, 0, "%s", mesg);
}

/* Number of compiled fixed strings known to exactly match the regexp.
   If kwsexec returns < kwset_exact_matches, then we don't need to
   call the regexp matcher at all. */
static int kwset_exact_matches;

static char const *
kwsincr_case (const char *must)
{
  const char *buf;
  size_t n;

  n = strlen (must);
#ifdef MBS_SUPPORT
  if (match_icase && MB_CUR_MAX > 1)
    buf = mbtolower (must, &n);
  else
#endif
    buf = must;
  return kwsincr (kwset, buf, n);
}

/* If the DFA turns out to have some set of fixed strings one of
   which must occur in the match, then we build a kwset matcher
   to find those strings, and thus quickly filter out impossible
   matches. */
static void
kwsmusts (void)
{
  struct dfamust const *dm;
  char const *err;

  if (dfa.musts)
    {
      kwsinit ();
      /* First, we compile in the substrings known to be exact
	 matches.  The kwset matcher will return the index
	 of the matching string that it chooses. */
      for (dm = dfa.musts; dm; dm = dm->next)
	{
	  if (!dm->exact)
	    continue;
	  ++kwset_exact_matches;
	  if ((err = kwsincr_case (dm->must)) != NULL)
	    error (EXIT_TROUBLE, 0, "%s", err);
	}
      /* Now, we compile the substrings that will require
	 the use of the regexp matcher.  */
      for (dm = dfa.musts; dm; dm = dm->next)
	{
	  if (dm->exact)
	    continue;
	  if ((err = kwsincr_case (dm->must)) != NULL)
	    error (EXIT_TROUBLE, 0, "%s", err);
	}
      if ((err = kwsprep (kwset)) != NULL)
	error (EXIT_TROUBLE, 0, "%s", err);
    }
}
#endif /* !FGREP_PROGRAM */

#ifdef MBS_SUPPORT

static bool
is_mb_middle(const char **good, const char *buf, const char *end)
{
  const char *p = *good;
  const char *prev = p;
  mbstate_t cur_state;

  /* TODO: can be optimized for UTF-8.  */
  
//Patch 0:
kwset = kwsalloc(((void *)0));
memset(&cur_state, 0, sizeof(mbstate_t));

//CodeSeg 1:
  while (p < buf)
    {
      size_t mbclen = mbrlen(p, end - p, &cur_state);

      /* Store the beginning of the previous complete multibyte character.  */
      if (mbclen != (size_t) -2)
        prev = p;

      if (mbclen == (size_t) -1 || mbclen == (size_t) -2 || mbclen == 0)
	{
	  /* An invalid sequence, or a truncated multibyte character.
	     We treat it as a single byte character.  */
	  mbclen = 1;
	}
      p += mbclen;
    }

  *good = prev;
  return p > buf;
}
#endif /* MBS_SUPPORT */

#if defined(GREP_PROGRAM) || defined(EGREP_PROGRAM)
#ifdef EGREP_PROGRAM
COMPILE_FCT(Ecompile)
{
  reg_syntax_t syntax_bits = RE_SYNTAX_POSIX_EGREP;
#else
/* No __VA_ARGS__ in C89.  So we have to do it this way.  */
static COMPILE_RET
GEAcompile (char const *pattern, size_t size, reg_syntax_t syntax_bits)
{
#endif /* EGREP_PROGRAM */
  const char *err;
  const char *p, *sep;
  size_t total = size;
  char *motif;

  if (match_icase)
    syntax_bits |= RE_ICASE;
  re_set_syntax (syntax_bits);
  dfasyntax (syntax_bits, match_icase, eolbyte);

  /* For GNU regex compiler we have to pass the patterns separately to detect
     errors like "[\nallo\n]\n".  The patterns here are "[", "allo" and "]"
     GNU regex should have raise a syntax error.  The same for backref, where
     the backref should have been local to each pattern.  */
  p = pattern;
  do
    {
      size_t len;
      sep = memchr (p, '\n', total);
      if (sep)
	{
	  len = sep - p;
	  sep++;
	  total -= (len + 1);
	}
      else
	{
	  len = total;
	  total = 0;
	}

      patterns = realloc (patterns, (pcount + 1) * sizeof (*patterns));
      if (patterns == NULL)
	error (EXIT_TROUBLE, errno, _("memory exhausted"));
      patterns[pcount] = patterns0;

      if ((err = re_compile_pattern (p, len,
				    &(patterns[pcount].regexbuf))) != NULL)
	error (EXIT_TROUBLE, 0, "%s", err);
      pcount++;

      p = sep;
    } while (sep && total != 0);

  /* In the match_words and match_lines cases, we use a different pattern
     for the DFA matcher that will quickly throw out cases that won't work.
     Then if DFA succeeds we do some hairy stuff using the regex matcher
     to decide whether the match should really count. */
  if (match_words || match_lines)
    {
      static char const line_beg_no_bk[] = "^(";
      static char const line_end_no_bk[] = ")$";
      static char const word_beg_no_bk[] = "(^|[^[:alnum:]_])(";
      static char const word_end_no_bk[] = ")([^[:alnum:]_]|$)";
#ifdef EGREP_PROGRAM
# define IF_BK(x, y) (y)
      char *n = xmalloc (sizeof word_beg_no_bk - 1 + size + sizeof word_end_no_bk);
#else
      static char const line_beg_bk[] = "^\\(";
      static char const line_end_bk[] = "\\)$";
      static char const word_beg_bk[] = "\\(^\\|[^[:alnum:]_]\\)\\(";
      static char const word_end_bk[] = "\\)\\([^[:alnum:]_]\\|$\\)";
      int bk = !(syntax_bits & RE_NO_BK_PARENS);
# define IF_BK(x, y) ((bk) ? (x) : (y))
      char *n = xmalloc (sizeof word_beg_bk - 1 + size + sizeof word_end_bk);
#endif /* EGREP_PROGRAM */

      strcpy (n, match_lines ? IF_BK(line_beg_bk, line_beg_no_bk)
			     : IF_BK(word_beg_bk, word_beg_no_bk));
      total = strlen(n);
      memcpy (n + total, pattern, size);
      total += size;
      strcpy (n + total, match_lines ? IF_BK(line_end_bk, line_end_no_bk)
				     : IF_BK(word_end_bk, word_end_no_bk));
      total += strlen (n + total);
      pattern = motif = n;
      size = total;
    }
  else
    motif = NULL;

  dfacomp (pattern, size, &dfa, 1);
  kwsmusts ();

  free(motif);
}

#ifndef EGREP_PROGRAM
COMPILE_FCT(Gcompile)
{
  return GEAcompile (pattern, size,
		     RE_SYNTAX_GREP | RE_HAT_LISTS_NOT_NEWLINE);
}

COMPILE_FCT(Acompile)
{
  return GEAcompile (pattern, size, RE_SYNTAX_AWK);
}

COMPILE_FCT(Ecompile)
{
  return GEAcompile (pattern, size, RE_SYNTAX_POSIX_EGREP);
}
#endif /* !EGREP_PROGRAM */

EXECUTE_FCT(EGexecute)
{
  char const *buflim, *beg, *end, *match, *best_match, *mb_start;
  char eol = eolbyte;
  int backref, start, len, best_len;
  struct kwsmatch kwsm;
  size_t i, ret_val;
#ifdef MBS_SUPPORT
  if (MB_CUR_MAX > 1)
    {
      if (match_icase)
        {
          /* mbtolower adds a NUL byte at the end.  That will provide
	     space for the sentinel byte dfaexec may add.  */
          char *case_buf = mbtolower (buf, &size);
	  if (start_ptr)
	    start_ptr = case_buf + (start_ptr - buf);
          buf = case_buf;
        }
    }
#endif /* MBS_SUPPORT */

  mb_start = buf;
  buflim = buf + size;

  for (beg = end = buf; end < buflim; beg = end)
    {
      if (!start_ptr)
	{
	  /* We don't care about an exact match.  */
	  if (kwset)
	    {
	      /* Find a possible match using the KWset matcher. */
	      size_t offset = kwsexec (kwset, beg, buflim - beg, &kwsm);
	      if (offset == (size_t) -1)
		goto failure;
	      beg += offset;
	      /* Narrow down to the line containing the candidate, and
		 run it through DFA. */
	      if ((end = memchr(beg, eol, buflim - beg)) != NULL)
	        end++;
              else
                end = buflim;
	      match = beg;
	      while (beg > buf && beg[-1] != eol)
		--beg;
	      if (kwsm.index < kwset_exact_matches)
                {
#ifdef MBS_SUPPORT
                  if (mb_start < beg)
                    mb_start = beg;
                  if (MB_CUR_MAX == 1 || !is_mb_middle (&mb_start, match, buflim))
#endif
                    goto success;
                }
	      if (dfaexec (&dfa, beg, (char *) end, 0, NULL, &backref) == NULL)
		continue;
	    }
	  else
	    {
	      /* No good fixed strings; start with DFA. */
	      char const *next_beg = dfaexec (&dfa, beg, (char *) buflim,
					      0, NULL, &backref);
	      if (next_beg == NULL)
		break;
	      /* Narrow down to the line we've found. */
	      beg = next_beg;
	      if ((end = memchr(beg, eol, buflim - beg)) != NULL)
	        end++;
              else
                end = buflim;
	      while (beg > buf && beg[-1] != eol)
		--beg;
	    }
	  /* Successful, no backreferences encountered! */
	  if (!backref)
	    goto success;
	}
      else
	{
	  /* We are looking for the leftmost (then longest) exact match.
	     We will go through the outer loop only once.  */
	  beg = start_ptr;
	  end = buflim;
	}

      /* If we've made it to this point, this means DFA has seen
	 a probable match, and we need to run it through Regex. */
      best_match = end;
      best_len = 0;
      for (i = 0; i < pcount; i++)
	{
	  patterns[i].regexbuf.not_eol = 0;
	  if (0 <= (start = re_search (&(patterns[i].regexbuf),
				       buf, end - buf - 1,
				       beg - buf, end - beg - 1,
				       &(patterns[i].regs))))
	    {
	      len = patterns[i].regs.end[0] - start;
	      match = buf + start;
	      if (match > best_match)
		continue;
	      if (start_ptr && !match_words)
		goto assess_pattern_match;
	      if ((!match_lines && !match_words)
		  || (match_lines && len == end - beg - 1))
		{
		  match = beg;
		  len = end - beg;
		  goto assess_pattern_match;
		}
	      /* If -w, check if the match aligns with word boundaries.
		 We do this iteratively because:
		 (a) the line may contain more than one occurence of the
		 pattern, and
		 (b) Several alternatives in the pattern might be valid at a
		 given point, and we may need to consider a shorter one to
		 find a word boundary.  */
	      if (match_words)
		while (match <= best_match)
		  {
		    if ((match == buf || !WCHAR ((unsigned char) match[-1]))
			&& (len == end - beg - 1
			    || !WCHAR ((unsigned char) match[len])))
		      goto assess_pattern_match;
		    if (len > 0)
		      {
			/* Try a shorter length anchored at the same place. */
			--len;
			patterns[i].regexbuf.not_eol = 1;
			len = re_match (&(patterns[i].regexbuf),
					buf, match + len - beg, match - buf,
					&(patterns[i].regs));
		      }
		    if (len <= 0)
		      {
			/* Try looking further on. */
			if (match == end - 1)
			  break;
			match++;
			patterns[i].regexbuf.not_eol = 0;
			start = re_search (&(patterns[i].regexbuf),
					   buf, end - buf - 1,
					   match - buf, end - match - 1,
					   &(patterns[i].regs));
			if (start < 0)
			  break;
			len = patterns[i].regs.end[0] - start;
			match = buf + start;
		      }
		  } /* while (match <= best_match) */
	      continue;
	    assess_pattern_match:
	      if (!start_ptr)
		{
		  /* Good enough for a non-exact match.
		     No need to look at further patterns, if any.  */
		  beg = match;
		  goto success_in_len;
		}
	      if (match < best_match || (match == best_match && len > best_len))
		{
		  /* Best exact match:  leftmost, then longest.  */
		  best_match = match;
		  best_len = len;
		}
	    } /* if re_search >= 0 */
	} /* for Regex patterns.  */
	if (best_match < end)
	  {
	    /* We have found an exact match.  We were just
	       waiting for the best one (leftmost then longest).  */
	    beg = best_match;
	    len = best_len;
	    goto success_in_len;
	  }
    } /* for (beg = end ..) */

 failure:
  ret_val = -1;
  goto out;

 success:
  len = end - beg;
 success_in_len:
  *match_size = len;
  ret_val = beg - buf;
 out:
  return ret_val;
}
#endif /* defined(GREP_PROGRAM) || defined(EGREP_PROGRAM) */

#if defined(GREP_PROGRAM) || defined(FGREP_PROGRAM)
COMPILE_FCT(Fcompile)
{
  char const *beg, *end, *lim, *err, *pat;
  size_t psize;

  kwsinit ();
  psize = size;
  if (match_icase && MB_CUR_MAX > 1)
    pat = mbtolower (pattern, &psize);
  else
    pat = pattern;

  beg = pat;
  do
    {
      for (lim = beg;; ++lim)
	{
	  end = lim;
	  if (lim >= pat + psize)
	    break;
	 if (*lim == '\n')
	   {
	     lim++;
	     break;
	   }
#if HAVE_DOS_FILE_CONTENTS
	 if (*lim == '\r' && lim + 1 < pat + psize && lim[1] == '\n')
	   {
	     lim += 2;
	     break;
	   }
#endif
	}

      if ((err = kwsincr (kwset, beg, end - beg)) != NULL)
	error (EXIT_TROUBLE, 0, "%s", err);
      beg = lim;
    }
  while (beg < pat + psize);

  if ((err = kwsprep (kwset)) != NULL)
    error (EXIT_TROUBLE, 0, "%s", err);
}

EXECUTE_FCT(Fexecute)
{
  char const *beg, *try, *end, *mb_start;
  size_t len;
  char eol = eolbyte;
  struct kwsmatch kwsmatch;
  size_t ret_val;
#ifdef MBS_SUPPORT
  if (MB_CUR_MAX > 1)
    {
      if (match_icase)
        {
          char *case_buf = mbtolower (buf, &size);
	  if (start_ptr)
	    start_ptr = case_buf + (start_ptr - buf);
          buf = case_buf;
        }
    }
#endif /* MBS_SUPPORT */

  for (mb_start = beg = start_ptr ? start_ptr : buf; beg <= buf + size; beg++)
    {
      size_t offset = kwsexec (kwset, beg, buf + size - beg, &kwsmatch);
      if (offset == (size_t) -1)
	goto failure;
#ifdef MBS_SUPPORT
      if (MB_CUR_MAX > 1 && is_mb_middle (&mb_start, beg + offset, buf + size))
        {
          beg = mb_start - 1;
          continue; /* It is a part of multibyte character.  */
        }
#endif /* MBS_SUPPORT */
      beg += offset;
      len = kwsmatch.size[0];
      if (start_ptr && !match_words)
	goto success_in_beg_and_len;
      if (match_lines)
	{
	  if (beg > buf && beg[-1] != eol)
	    continue;
	  if (beg + len < buf + size && beg[len] != eol)
	    continue;
	  goto success;
	}
      else if (match_words)
	for (try = beg; len; )
	  {
	    if (try > buf && WCHAR((unsigned char) try[-1]))
	      break;
	    if (try + len < buf + size && WCHAR((unsigned char) try[len]))
	      {
		offset = kwsexec (kwset, beg, --len, &kwsmatch);
		if (offset == (size_t) -1)
		  break;
		try = beg + offset;
		len = kwsmatch.size[0];
	      }
	    else if (!start_ptr)
	      goto success;
	    else
	      goto success_in_beg_and_len;
	  } /* for (try) */
      else
	goto success;
    } /* for (beg in buf) */

 failure:
  ret_val = -1;
  goto out;

 success:
  if ((end = memchr (beg + len, eol, (buf + size) - (beg + len))) != NULL)
    end++;
  else
    end = buf + size;
  while (buf < beg && beg[-1] != eol)
    --beg;
  len = end - beg;
 success_in_beg_and_len:
  *match_size = len;
  ret_val = beg - buf;
 out:
  return ret_val;
}
#endif /* defined(GREP_PROGRAM) || defined(FGREP_PROGRAM) */

#ifdef GREP_PROGRAM
#if HAVE_LIBPCRE
/* Compiled internal form of a Perl regular expression.  */
static pcre *cre;

/* Additional information about the pattern.  */
static pcre_extra *extra;
#endif

COMPILE_FCT(Pcompile)
{
#if !HAVE_LIBPCRE
  error (EXIT_TROUBLE, 0, "%s",
	 _("support for the -P option is not compiled into "
	   "this --disable-perl-regexp binary"));
#else
  int e;
  char const *ep;
  char *re = xmalloc (4 * size + 7);
  int flags = PCRE_MULTILINE | (match_icase ? PCRE_CASELESS : 0);
  char const *patlim = pattern + size;
  char *n = re;
  char const *p;
  char const *pnul;

  /* FIXME: Remove these restrictions.  */
  if (memchr(pattern, '\n', size))
    error (EXIT_TROUBLE, 0, _("the -P option only supports a single pattern"));

  *n = '\0';
  if (match_lines)
    strcpy (n, "^(");
  if (match_words)
    strcpy (n, "\\b(");
  n += strlen (n);

  /* The PCRE interface doesn't allow NUL bytes in the pattern, so
     replace each NUL byte in the pattern with the four characters
     "\000", removing a preceding backslash if there are an odd
     number of backslashes before the NUL.

     FIXME: This method does not work with some multibyte character
     encodings, notably Shift-JIS, where a multibyte character can end
     in a backslash byte.  */
  for (p = pattern; (pnul = memchr (p, '\0', patlim - p)); p = pnul + 1)
    {
      memcpy (n, p, pnul - p);
      n += pnul - p;
      for (p = pnul; pattern < p && p[-1] == '\\'; p--)
	continue;
      n -= (pnul - p) & 1;
      strcpy (n, "\\000");
      n += 4;
    }

  memcpy (n, p, patlim - p);
  n += patlim - p;
  *n = '\0';
  if (match_words)
    strcpy (n, ")\\b");
  if (match_lines)
    strcpy (n, ")$");

  cre = pcre_compile (re, flags, &ep, &e, pcre_maketables ());
  if (!cre)
    error (EXIT_TROUBLE, 0, "%s", ep);

  extra = pcre_study (cre, 0, &ep);
  if (ep)
    error (EXIT_TROUBLE, 0, "%s", ep);

  free (re);
#endif
}

EXECUTE_FCT(Pexecute)
{
#if !HAVE_LIBPCRE
  abort ();
  return -1;
#else
  /* This array must have at least two elements; everything after that
     is just for performance improvement in pcre_exec.  */
  int sub[300];

  const char *line_buf, *line_end, *line_next;
  int e = PCRE_ERROR_NOMATCH;
  ptrdiff_t start_ofs = start_ptr ? start_ptr - buf : 0;

  /* PCRE can't limit the matching to single lines, therefore we have to
     match each line in the buffer separately.  */
  for (line_next = buf;
       e == PCRE_ERROR_NOMATCH && line_next < buf + size;
       start_ofs -= line_next - line_buf)
    {
      line_buf = line_next;
      line_end = memchr (line_buf, eolbyte, (buf + size) - line_buf);
      if (line_end == NULL)
        line_next = line_end = buf + size;
      else
        line_next = line_end + 1;

      if (start_ptr && start_ptr >= line_end)
        continue;

      e = pcre_exec (cre, extra, line_buf, line_end - line_buf,
                     start_ofs < 0 ? 0 : start_ofs, 0,
                     sub, sizeof sub / sizeof *sub);
    }

  if (e <= 0)
    {
      switch (e)
	{
	case PCRE_ERROR_NOMATCH:
	  return -1;

	case PCRE_ERROR_NOMEMORY:
	  error (EXIT_TROUBLE, 0, _("memory exhausted"));

	default:
	  abort ();
	}
    }
  else
    {
      /* Narrow down to the line we've found.  */
      char const *beg = line_buf + sub[0];
      char const *end = line_buf + sub[1];
      char const *buflim = buf + size;
      char eol = eolbyte;
      if (!start_ptr)
	{
	  /* FIXME: The case when '\n' is not found indicates a bug:
	     Since grep is line oriented, the match should never contain
	     a newline, so there _must_ be a newline following.
	   */
	  if (!(end = memchr (end, eol, buflim - end)))
	    end = buflim;
	  else
	    end++;
	  while (buf < beg && beg[-1] != eol)
	    --beg;
	}

      *match_size = end - beg;
      return beg - buf;
    }
#endif
}

struct matcher const matchers[] = {
  { "default", Gcompile, EGexecute },
  { "grep",    Gcompile, EGexecute },
  { "egrep",   Ecompile, EGexecute },
  { "awk",     Acompile, EGexecute },
  { "fgrep",   Fcompile, Fexecute },
  { "perl",    Pcompile, Pexecute },
  { "", 0, 0 },
};
#endif /* GREP_PROGRAM */

Testing negative cases!
Running test command:
/home/ubuntu/spr-fast/tools/grep-test.py /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-deccad69-db9d6340/tempworkdir2/src /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-deccad69-db9d6340/tempworkdir2/tests /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-deccad69-db9d6340/tempworkdir2 0  > __res
Passed Negative Cases with BasicTester
Testing positive cases!
Running test command:
/home/ubuntu/spr-fast/tools/grep-test.py /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-deccad69-db9d6340/tempworkdir2/src /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-deccad69-db9d6340/tempworkdir2/tests /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-deccad69-db9d6340/tempworkdir2 20  > __res
Running test command:
/home/ubuntu/spr-fast/tools/grep-test.py /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-deccad69-db9d6340/tempworkdir2/src /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-deccad69-db9d6340/tempworkdir2/tests /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-deccad69-db9d6340/tempworkdir2 3  > __res
Running test command:
/home/ubuntu/spr-fast/tools/grep-test.py /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-deccad69-db9d6340/tempworkdir2/src /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-deccad69-db9d6340/tempworkdir2/tests /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-deccad69-db9d6340/tempworkdir2 4  > __res
Running test command:
/home/ubuntu/spr-fast/tools/grep-test.py /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-deccad69-db9d6340/tempworkdir2/src /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-deccad69-db9d6340/tempworkdir2/tests /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-deccad69-db9d6340/tempworkdir2 5  > __res
Running test command:
/home/ubuntu/spr-fast/tools/grep-test.py /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-deccad69-db9d6340/tempworkdir2/src /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-deccad69-db9d6340/tempworkdir2/tests /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-deccad69-db9d6340/tempworkdir2 6  > __res
Running test command:
/home/ubuntu/spr-fast/tools/grep-test.py /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-deccad69-db9d6340/tempworkdir2/src /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-deccad69-db9d6340/tempworkdir2/tests /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-deccad69-db9d6340/tempworkdir2 9  > __res
Running test command:
/home/ubuntu/spr-fast/tools/grep-test.py /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-deccad69-db9d6340/tempworkdir2/src /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-deccad69-db9d6340/tempworkdir2/tests /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-deccad69-db9d6340/tempworkdir2 11  > __res
Running test command:
/home/ubuntu/spr-fast/tools/grep-test.py /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-deccad69-db9d6340/tempworkdir2/src /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-deccad69-db9d6340/tempworkdir2/tests /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-deccad69-db9d6340/tempworkdir2 12  > __res
Running test command:
/home/ubuntu/spr-fast/tools/grep-test.py /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-deccad69-db9d6340/tempworkdir2/src /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-deccad69-db9d6340/tempworkdir2/tests /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-deccad69-db9d6340/tempworkdir2 13  > __res
Running test command:
/home/ubuntu/spr-fast/tools/grep-test.py /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-deccad69-db9d6340/tempworkdir2/src /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-deccad69-db9d6340/tempworkdir2/tests /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-deccad69-db9d6340/tempworkdir2 14  > __res
Running test command:
/home/ubuntu/spr-fast/tools/grep-test.py /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-deccad69-db9d6340/tempworkdir2/src /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-deccad69-db9d6340/tempworkdir2/tests /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-deccad69-db9d6340/tempworkdir2 15  > __res
Running test command:
/home/ubuntu/spr-fast/tools/grep-test.py /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-deccad69-db9d6340/tempworkdir2/src /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-deccad69-db9d6340/tempworkdir2/tests /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-deccad69-db9d6340/tempworkdir2 17  > __res
Running test command:
/home/ubuntu/spr-fast/tools/grep-test.py /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-deccad69-db9d6340/tempworkdir2/src /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-deccad69-db9d6340/tempworkdir2/tests /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-deccad69-db9d6340/tempworkdir2 18  > __res
Running test command:
/home/ubuntu/spr-fast/tools/grep-test.py /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-deccad69-db9d6340/tempworkdir2/src /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-deccad69-db9d6340/tempworkdir2/tests /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-deccad69-db9d6340/tempworkdir2 22  > __res
Running test command:
/home/ubuntu/spr-fast/tools/grep-test.py /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-deccad69-db9d6340/tempworkdir2/src /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-deccad69-db9d6340/tempworkdir2/tests /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-deccad69-db9d6340/tempworkdir2 23  > __res
Running test command:
/home/ubuntu/spr-fast/tools/grep-test.py /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-deccad69-db9d6340/tempworkdir2/src /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-deccad69-db9d6340/tempworkdir2/tests /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-deccad69-db9d6340/tempworkdir2 25  > __res
Passed Positive Cases
Passed!
Update best score 7488995.000000
Building:src at:
/home/ubuntu/spr-fast/tests/corebench/grep/grep-case-deccad69-db9d6340/tempworkdir2/srcSingle building for Tester 0x214bb60 id 6 failed as well!
Building:src at:
/home/ubuntu/spr-fast/tests/corebench/grep/grep-case-deccad69-db9d6340/tempworkdir2/srcSingle building for Tester 0x214bb60 id 7 failed as well!
Building:src at:
/home/ubuntu/spr-fast/tests/corebench/grep/grep-case-deccad69-db9d6340/tempworkdir2/srcBasicTester, Testing instance id 8:
//src_file:src/search.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
/* search.c - searching subroutines using dfa, kwset and regex for grep.
   Copyright 1992, 1998, 2000, 2007, 2009-2010 Free Software Foundation, Inc.

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 3, or (at your option)
   any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program; if not, write to the Free Software
   Foundation, Inc., 51 Franklin Street - Fifth Floor, Boston, MA
   02110-1301, USA.  */

/* Written August 1992 by Mike Haertel. */

#include <config.h>

#include <sys/types.h>

#include "mbsupport.h"
#ifdef MBS_SUPPORT
/* We can handle multibyte strings. */
# include <wchar.h>
# include <wctype.h>
#endif

#include "system.h"
#include "grep.h"
#ifndef FGREP_PROGRAM
# include <regex.h>
# include "dfa.h"
#endif
#include "kwset.h"
#include "error.h"
#include "xalloc.h"
#ifdef HAVE_LIBPCRE
# include <pcre.h>
#endif

#define NCHAR (UCHAR_MAX + 1)

/* For -w, we also consider _ to be word constituent.  */
#define WCHAR(C) (ISALNUM(C) || (C) == '_')

/* KWset compiled pattern.  For Ecompile and Gcompile, we compile
   a list of strings, at least one of which is known to occur in
   any string matching the regexp. */
static kwset_t kwset;

static void
kwsinit (void)
{
  static char trans[NCHAR];
  int i;

  if (match_icase && MB_CUR_MAX == 1)
    {
      for (i = 0; i < NCHAR; ++i)
        trans[i] = TOLOWER (i);

      kwset = kwsalloc (trans);
    }
  else
    kwset = kwsalloc (NULL);

  if (!kwset)
    xalloc_die ();
}

#ifdef MBS_SUPPORT
/* Convert the *N-byte string, BEG, to lowercase, and write the
   NUL-terminated result into malloc'd storage.  Upon success, set *N
   to the length (in bytes) of the resulting string (not including the
   trailing NUL byte), and return a pointer to the lowercase string.
   Upon memory allocation failure, this function exits.

   Note that while this function returns a pointer to malloc'd storage,
   the caller must not free it, since this function retains a pointer
   to the buffer and reuses it on any subsequent call.  As a consequence,
   this function is not thread-safe.  */
static char *
mbtolower (const char *beg, size_t *n)
{
  static char *out;
  static size_t outalloc;
  size_t outlen, mb_cur_max;
  mbstate_t is, os;
  const char *end;
  char *p;

  if (*n > outalloc)
    {
      out = xrealloc (out, *n);
      outalloc = *n;
    }

  memset (&is, 0, sizeof (is));
  memset (&os, 0, sizeof (os));
  end = beg + *n;

  mb_cur_max = MB_CUR_MAX;
  p = out;
  outlen = 0;
  while (beg < end)
    {
      wchar_t wc;
      size_t mbclen = mbrtowc(&wc, beg, end - beg, &is);
      if (outlen + mb_cur_max >= outalloc)
        {
          out = x2nrealloc (out, &outalloc, 1);
          p = out + outlen;
        }

      if (mbclen == (size_t) -1 || mbclen == (size_t) -2 || mbclen == 0)
        {
          /* An invalid sequence, or a truncated multi-octet character.
             We treat it as a single-octet character.  */
          *p++ = *beg++;
          outlen++;
          memset (&is, 0, sizeof (is));
          memset (&os, 0, sizeof (os));
        }
      else
        {
          beg += mbclen;
          mbclen = wcrtomb (p, towlower ((wint_t) wc), &os);
          p += mbclen;
          outlen += mbclen;
        }
    }

  *n = p - out;
  *p++ = 0;
  return out;
}
#endif


#ifndef FGREP_PROGRAM
/* DFA compiled regexp. */
static struct dfa dfa;

/* The Regex compiled patterns.  */
static struct patterns
{
  /* Regex compiled regexp. */
  struct re_pattern_buffer regexbuf;
  struct re_registers regs; /* This is here on account of a BRAIN-DEAD
			       Q@#%!# library interface in regex.c.  */
} patterns0;

struct patterns *patterns;
size_t pcount;

void
dfaerror (char const *mesg)
{
  error (EXIT_TROUBLE, 0, "%s", mesg);
}

/* Number of compiled fixed strings known to exactly match the regexp.
   If kwsexec returns < kwset_exact_matches, then we don't need to
   call the regexp matcher at all. */
static int kwset_exact_matches;

static char const *
kwsincr_case (const char *must)
{
  const char *buf;
  size_t n;

  n = strlen (must);
#ifdef MBS_SUPPORT
  if (match_icase && MB_CUR_MAX > 1)
    buf = mbtolower (must, &n);
  else
#endif
    buf = must;
  return kwsincr (kwset, buf, n);
}

/* If the DFA turns out to have some set of fixed strings one of
   which must occur in the match, then we build a kwset matcher
   to find those strings, and thus quickly filter out impossible
   matches. */
static void
kwsmusts (void)
{
  struct dfamust const *dm;
  char const *err;

  if (dfa.musts)
    {
      kwsinit ();
      /* First, we compile in the substrings known to be exact
	 matches.  The kwset matcher will return the index
	 of the matching string that it chooses. */
      for (dm = dfa.musts; dm; dm = dm->next)
	{
	  if (!dm->exact)
	    continue;
	  ++kwset_exact_matches;
	  if ((err = kwsincr_case (dm->must)) != NULL)
	    error (EXIT_TROUBLE, 0, "%s", err);
	}
      /* Now, we compile the substrings that will require
	 the use of the regexp matcher.  */
      for (dm = dfa.musts; dm; dm = dm->next)
	{
	  if (dm->exact)
	    continue;
	  if ((err = kwsincr_case (dm->must)) != NULL)
	    error (EXIT_TROUBLE, 0, "%s", err);
	}
      if ((err = kwsprep (kwset)) != NULL)
	error (EXIT_TROUBLE, 0, "%s", err);
    }
}
#endif /* !FGREP_PROGRAM */

#ifdef MBS_SUPPORT

static bool
is_mb_middle(const char **good, const char *buf, const char *end)
{
  const char *p = *good;
  const char *prev = p;
  mbstate_t cur_state;

  /* TODO: can be optimized for UTF-8.  */
  
//Patch 0:
prev = (buf);
memset(&cur_state, 0, sizeof(mbstate_t));

//CodeSeg 1:
  while (p < buf)
    {
      size_t mbclen = mbrlen(p, end - p, &cur_state);

      /* Store the beginning of the previous complete multibyte character.  */
      if (mbclen != (size_t) -2)
        prev = p;

      if (mbclen == (size_t) -1 || mbclen == (size_t) -2 || mbclen == 0)
	{
	  /* An invalid sequence, or a truncated multibyte character.
	     We treat it as a single byte character.  */
	  mbclen = 1;
	}
      p += mbclen;
    }

  *good = prev;
  return p > buf;
}
#endif /* MBS_SUPPORT */

#if defined(GREP_PROGRAM) || defined(EGREP_PROGRAM)
#ifdef EGREP_PROGRAM
COMPILE_FCT(Ecompile)
{
  reg_syntax_t syntax_bits = RE_SYNTAX_POSIX_EGREP;
#else
/* No __VA_ARGS__ in C89.  So we have to do it this way.  */
static COMPILE_RET
GEAcompile (char const *pattern, size_t size, reg_syntax_t syntax_bits)
{
#endif /* EGREP_PROGRAM */
  const char *err;
  const char *p, *sep;
  size_t total = size;
  char *motif;

  if (match_icase)
    syntax_bits |= RE_ICASE;
  re_set_syntax (syntax_bits);
  dfasyntax (syntax_bits, match_icase, eolbyte);

  /* For GNU regex compiler we have to pass the patterns separately to detect
     errors like "[\nallo\n]\n".  The patterns here are "[", "allo" and "]"
     GNU regex should have raise a syntax error.  The same for backref, where
     the backref should have been local to each pattern.  */
  p = pattern;
  do
    {
      size_t len;
      sep = memchr (p, '\n', total);
      if (sep)
	{
	  len = sep - p;
	  sep++;
	  total -= (len + 1);
	}
      else
	{
	  len = total;
	  total = 0;
	}

      patterns = realloc (patterns, (pcount + 1) * sizeof (*patterns));
      if (patterns == NULL)
	error (EXIT_TROUBLE, errno, _("memory exhausted"));
      patterns[pcount] = patterns0;

      if ((err = re_compile_pattern (p, len,
				    &(patterns[pcount].regexbuf))) != NULL)
	error (EXIT_TROUBLE, 0, "%s", err);
      pcount++;

      p = sep;
    } while (sep && total != 0);

  /* In the match_words and match_lines cases, we use a different pattern
     for the DFA matcher that will quickly throw out cases that won't work.
     Then if DFA succeeds we do some hairy stuff using the regex matcher
     to decide whether the match should really count. */
  if (match_words || match_lines)
    {
      static char const line_beg_no_bk[] = "^(";
      static char const line_end_no_bk[] = ")$";
      static char const word_beg_no_bk[] = "(^|[^[:alnum:]_])(";
      static char const word_end_no_bk[] = ")([^[:alnum:]_]|$)";
#ifdef EGREP_PROGRAM
# define IF_BK(x, y) (y)
      char *n = xmalloc (sizeof word_beg_no_bk - 1 + size + sizeof word_end_no_bk);
#else
      static char const line_beg_bk[] = "^\\(";
      static char const line_end_bk[] = "\\)$";
      static char const word_beg_bk[] = "\\(^\\|[^[:alnum:]_]\\)\\(";
      static char const word_end_bk[] = "\\)\\([^[:alnum:]_]\\|$\\)";
      int bk = !(syntax_bits & RE_NO_BK_PARENS);
# define IF_BK(x, y) ((bk) ? (x) : (y))
      char *n = xmalloc (sizeof word_beg_bk - 1 + size + sizeof word_end_bk);
#endif /* EGREP_PROGRAM */

      strcpy (n, match_lines ? IF_BK(line_beg_bk, line_beg_no_bk)
			     : IF_BK(word_beg_bk, word_beg_no_bk));
      total = strlen(n);
      memcpy (n + total, pattern, size);
      total += size;
      strcpy (n + total, match_lines ? IF_BK(line_end_bk, line_end_no_bk)
				     : IF_BK(word_end_bk, word_end_no_bk));
      total += strlen (n + total);
      pattern = motif = n;
      size = total;
    }
  else
    motif = NULL;

  dfacomp (pattern, size, &dfa, 1);
  kwsmusts ();

  free(motif);
}

#ifndef EGREP_PROGRAM
COMPILE_FCT(Gcompile)
{
  return GEAcompile (pattern, size,
		     RE_SYNTAX_GREP | RE_HAT_LISTS_NOT_NEWLINE);
}

COMPILE_FCT(Acompile)
{
  return GEAcompile (pattern, size, RE_SYNTAX_AWK);
}

COMPILE_FCT(Ecompile)
{
  return GEAcompile (pattern, size, RE_SYNTAX_POSIX_EGREP);
}
#endif /* !EGREP_PROGRAM */

EXECUTE_FCT(EGexecute)
{
  char const *buflim, *beg, *end, *match, *best_match, *mb_start;
  char eol = eolbyte;
  int backref, start, len, best_len;
  struct kwsmatch kwsm;
  size_t i, ret_val;
#ifdef MBS_SUPPORT
  if (MB_CUR_MAX > 1)
    {
      if (match_icase)
        {
          /* mbtolower adds a NUL byte at the end.  That will provide
	     space for the sentinel byte dfaexec may add.  */
          char *case_buf = mbtolower (buf, &size);
	  if (start_ptr)
	    start_ptr = case_buf + (start_ptr - buf);
          buf = case_buf;
        }
    }
#endif /* MBS_SUPPORT */

  mb_start = buf;
  buflim = buf + size;

  for (beg = end = buf; end < buflim; beg = end)
    {
      if (!start_ptr)
	{
	  /* We don't care about an exact match.  */
	  if (kwset)
	    {
	      /* Find a possible match using the KWset matcher. */
	      size_t offset = kwsexec (kwset, beg, buflim - beg, &kwsm);
	      if (offset == (size_t) -1)
		goto failure;
	      beg += offset;
	      /* Narrow down to the line containing the candidate, and
		 run it through DFA. */
	      if ((end = memchr(beg, eol, buflim - beg)) != NULL)
	        end++;
              else
                end = buflim;
	      match = beg;
	      while (beg > buf && beg[-1] != eol)
		--beg;
	      if (kwsm.index < kwset_exact_matches)
                {
#ifdef MBS_SUPPORT
                  if (mb_start < beg)
                    mb_start = beg;
                  if (MB_CUR_MAX == 1 || !is_mb_middle (&mb_start, match, buflim))
#endif
                    goto success;
                }
	      if (dfaexec (&dfa, beg, (char *) end, 0, NULL, &backref) == NULL)
		continue;
	    }
	  else
	    {
	      /* No good fixed strings; start with DFA. */
	      char const *next_beg = dfaexec (&dfa, beg, (char *) buflim,
					      0, NULL, &backref);
	      if (next_beg == NULL)
		break;
	      /* Narrow down to the line we've found. */
	      beg = next_beg;
	      if ((end = memchr(beg, eol, buflim - beg)) != NULL)
	        end++;
              else
                end = buflim;
	      while (beg > buf && beg[-1] != eol)
		--beg;
	    }
	  /* Successful, no backreferences encountered! */
	  if (!backref)
	    goto success;
	}
      else
	{
	  /* We are looking for the leftmost (then longest) exact match.
	     We will go through the outer loop only once.  */
	  beg = start_ptr;
	  end = buflim;
	}

      /* If we've made it to this point, this means DFA has seen
	 a probable match, and we need to run it through Regex. */
      best_match = end;
      best_len = 0;
      for (i = 0; i < pcount; i++)
	{
	  patterns[i].regexbuf.not_eol = 0;
	  if (0 <= (start = re_search (&(patterns[i].regexbuf),
				       buf, end - buf - 1,
				       beg - buf, end - beg - 1,
				       &(patterns[i].regs))))
	    {
	      len = patterns[i].regs.end[0] - start;
	      match = buf + start;
	      if (match > best_match)
		continue;
	      if (start_ptr && !match_words)
		goto assess_pattern_match;
	      if ((!match_lines && !match_words)
		  || (match_lines && len == end - beg - 1))
		{
		  match = beg;
		  len = end - beg;
		  goto assess_pattern_match;
		}
	      /* If -w, check if the match aligns with word boundaries.
		 We do this iteratively because:
		 (a) the line may contain more than one occurence of the
		 pattern, and
		 (b) Several alternatives in the pattern might be valid at a
		 given point, and we may need to consider a shorter one to
		 find a word boundary.  */
	      if (match_words)
		while (match <= best_match)
		  {
		    if ((match == buf || !WCHAR ((unsigned char) match[-1]))
			&& (len == end - beg - 1
			    || !WCHAR ((unsigned char) match[len])))
		      goto assess_pattern_match;
		    if (len > 0)
		      {
			/* Try a shorter length anchored at the same place. */
			--len;
			patterns[i].regexbuf.not_eol = 1;
			len = re_match (&(patterns[i].regexbuf),
					buf, match + len - beg, match - buf,
					&(patterns[i].regs));
		      }
		    if (len <= 0)
		      {
			/* Try looking further on. */
			if (match == end - 1)
			  break;
			match++;
			patterns[i].regexbuf.not_eol = 0;
			start = re_search (&(patterns[i].regexbuf),
					   buf, end - buf - 1,
					   match - buf, end - match - 1,
					   &(patterns[i].regs));
			if (start < 0)
			  break;
			len = patterns[i].regs.end[0] - start;
			match = buf + start;
		      }
		  } /* while (match <= best_match) */
	      continue;
	    assess_pattern_match:
	      if (!start_ptr)
		{
		  /* Good enough for a non-exact match.
		     No need to look at further patterns, if any.  */
		  beg = match;
		  goto success_in_len;
		}
	      if (match < best_match || (match == best_match && len > best_len))
		{
		  /* Best exact match:  leftmost, then longest.  */
		  best_match = match;
		  best_len = len;
		}
	    } /* if re_search >= 0 */
	} /* for Regex patterns.  */
	if (best_match < end)
	  {
	    /* We have found an exact match.  We were just
	       waiting for the best one (leftmost then longest).  */
	    beg = best_match;
	    len = best_len;
	    goto success_in_len;
	  }
    } /* for (beg = end ..) */

 failure:
  ret_val = -1;
  goto out;

 success:
  len = end - beg;
 success_in_len:
  *match_size = len;
  ret_val = beg - buf;
 out:
  return ret_val;
}
#endif /* defined(GREP_PROGRAM) || defined(EGREP_PROGRAM) */

#if defined(GREP_PROGRAM) || defined(FGREP_PROGRAM)
COMPILE_FCT(Fcompile)
{
  char const *beg, *end, *lim, *err, *pat;
  size_t psize;

  kwsinit ();
  psize = size;
  if (match_icase && MB_CUR_MAX > 1)
    pat = mbtolower (pattern, &psize);
  else
    pat = pattern;

  beg = pat;
  do
    {
      for (lim = beg;; ++lim)
	{
	  end = lim;
	  if (lim >= pat + psize)
	    break;
	 if (*lim == '\n')
	   {
	     lim++;
	     break;
	   }
#if HAVE_DOS_FILE_CONTENTS
	 if (*lim == '\r' && lim + 1 < pat + psize && lim[1] == '\n')
	   {
	     lim += 2;
	     break;
	   }
#endif
	}

      if ((err = kwsincr (kwset, beg, end - beg)) != NULL)
	error (EXIT_TROUBLE, 0, "%s", err);
      beg = lim;
    }
  while (beg < pat + psize);

  if ((err = kwsprep (kwset)) != NULL)
    error (EXIT_TROUBLE, 0, "%s", err);
}

EXECUTE_FCT(Fexecute)
{
  char const *beg, *try, *end, *mb_start;
  size_t len;
  char eol = eolbyte;
  struct kwsmatch kwsmatch;
  size_t ret_val;
#ifdef MBS_SUPPORT
  if (MB_CUR_MAX > 1)
    {
      if (match_icase)
        {
          char *case_buf = mbtolower (buf, &size);
	  if (start_ptr)
	    start_ptr = case_buf + (start_ptr - buf);
          buf = case_buf;
        }
    }
#endif /* MBS_SUPPORT */

  for (mb_start = beg = start_ptr ? start_ptr : buf; beg <= buf + size; beg++)
    {
      size_t offset = kwsexec (kwset, beg, buf + size - beg, &kwsmatch);
      if (offset == (size_t) -1)
	goto failure;
#ifdef MBS_SUPPORT
      if (MB_CUR_MAX > 1 && is_mb_middle (&mb_start, beg + offset, buf + size))
        {
          beg = mb_start - 1;
          continue; /* It is a part of multibyte character.  */
        }
#endif /* MBS_SUPPORT */
      beg += offset;
      len = kwsmatch.size[0];
      if (start_ptr && !match_words)
	goto success_in_beg_and_len;
      if (match_lines)
	{
	  if (beg > buf && beg[-1] != eol)
	    continue;
	  if (beg + len < buf + size && beg[len] != eol)
	    continue;
	  goto success;
	}
      else if (match_words)
	for (try = beg; len; )
	  {
	    if (try > buf && WCHAR((unsigned char) try[-1]))
	      break;
	    if (try + len < buf + size && WCHAR((unsigned char) try[len]))
	      {
		offset = kwsexec (kwset, beg, --len, &kwsmatch);
		if (offset == (size_t) -1)
		  break;
		try = beg + offset;
		len = kwsmatch.size[0];
	      }
	    else if (!start_ptr)
	      goto success;
	    else
	      goto success_in_beg_and_len;
	  } /* for (try) */
      else
	goto success;
    } /* for (beg in buf) */

 failure:
  ret_val = -1;
  goto out;

 success:
  if ((end = memchr (beg + len, eol, (buf + size) - (beg + len))) != NULL)
    end++;
  else
    end = buf + size;
  while (buf < beg && beg[-1] != eol)
    --beg;
  len = end - beg;
 success_in_beg_and_len:
  *match_size = len;
  ret_val = beg - buf;
 out:
  return ret_val;
}
#endif /* defined(GREP_PROGRAM) || defined(FGREP_PROGRAM) */

#ifdef GREP_PROGRAM
#if HAVE_LIBPCRE
/* Compiled internal form of a Perl regular expression.  */
static pcre *cre;

/* Additional information about the pattern.  */
static pcre_extra *extra;
#endif

COMPILE_FCT(Pcompile)
{
#if !HAVE_LIBPCRE
  error (EXIT_TROUBLE, 0, "%s",
	 _("support for the -P option is not compiled into "
	   "this --disable-perl-regexp binary"));
#else
  int e;
  char const *ep;
  char *re = xmalloc (4 * size + 7);
  int flags = PCRE_MULTILINE | (match_icase ? PCRE_CASELESS : 0);
  char const *patlim = pattern + size;
  char *n = re;
  char const *p;
  char const *pnul;

  /* FIXME: Remove these restrictions.  */
  if (memchr(pattern, '\n', size))
    error (EXIT_TROUBLE, 0, _("the -P option only supports a single pattern"));

  *n = '\0';
  if (match_lines)
    strcpy (n, "^(");
  if (match_words)
    strcpy (n, "\\b(");
  n += strlen (n);

  /* The PCRE interface doesn't allow NUL bytes in the pattern, so
     replace each NUL byte in the pattern with the four characters
     "\000", removing a preceding backslash if there are an odd
     number of backslashes before the NUL.

     FIXME: This method does not work with some multibyte character
     encodings, notably Shift-JIS, where a multibyte character can end
     in a backslash byte.  */
  for (p = pattern; (pnul = memchr (p, '\0', patlim - p)); p = pnul + 1)
    {
      memcpy (n, p, pnul - p);
      n += pnul - p;
      for (p = pnul; pattern < p && p[-1] == '\\'; p--)
	continue;
      n -= (pnul - p) & 1;
      strcpy (n, "\\000");
      n += 4;
    }

  memcpy (n, p, patlim - p);
  n += patlim - p;
  *n = '\0';
  if (match_words)
    strcpy (n, ")\\b");
  if (match_lines)
    strcpy (n, ")$");

  cre = pcre_compile (re, flags, &ep, &e, pcre_maketables ());
  if (!cre)
    error (EXIT_TROUBLE, 0, "%s", ep);

  extra = pcre_study (cre, 0, &ep);
  if (ep)
    error (EXIT_TROUBLE, 0, "%s", ep);

  free (re);
#endif
}

EXECUTE_FCT(Pexecute)
{
#if !HAVE_LIBPCRE
  abort ();
  return -1;
#else
  /* This array must have at least two elements; everything after that
     is just for performance improvement in pcre_exec.  */
  int sub[300];

  const char *line_buf, *line_end, *line_next;
  int e = PCRE_ERROR_NOMATCH;
  ptrdiff_t start_ofs = start_ptr ? start_ptr - buf : 0;

  /* PCRE can't limit the matching to single lines, therefore we have to
     match each line in the buffer separately.  */
  for (line_next = buf;
       e == PCRE_ERROR_NOMATCH && line_next < buf + size;
       start_ofs -= line_next - line_buf)
    {
      line_buf = line_next;
      line_end = memchr (line_buf, eolbyte, (buf + size) - line_buf);
      if (line_end == NULL)
        line_next = line_end = buf + size;
      else
        line_next = line_end + 1;

      if (start_ptr && start_ptr >= line_end)
        continue;

      e = pcre_exec (cre, extra, line_buf, line_end - line_buf,
                     start_ofs < 0 ? 0 : start_ofs, 0,
                     sub, sizeof sub / sizeof *sub);
    }

  if (e <= 0)
    {
      switch (e)
	{
	case PCRE_ERROR_NOMATCH:
	  return -1;

	case PCRE_ERROR_NOMEMORY:
	  error (EXIT_TROUBLE, 0, _("memory exhausted"));

	default:
	  abort ();
	}
    }
  else
    {
      /* Narrow down to the line we've found.  */
      char const *beg = line_buf + sub[0];
      char const *end = line_buf + sub[1];
      char const *buflim = buf + size;
      char eol = eolbyte;
      if (!start_ptr)
	{
	  /* FIXME: The case when '\n' is not found indicates a bug:
	     Since grep is line oriented, the match should never contain
	     a newline, so there _must_ be a newline following.
	   */
	  if (!(end = memchr (end, eol, buflim - end)))
	    end = buflim;
	  else
	    end++;
	  while (buf < beg && beg[-1] != eol)
	    --beg;
	}

      *match_size = end - beg;
      return beg - buf;
    }
#endif
}

struct matcher const matchers[] = {
  { "default", Gcompile, EGexecute },
  { "grep",    Gcompile, EGexecute },
  { "egrep",   Ecompile, EGexecute },
  { "awk",     Acompile, EGexecute },
  { "fgrep",   Fcompile, Fexecute },
  { "perl",    Pcompile, Pexecute },
  { "", 0, 0 },
};
#endif /* GREP_PROGRAM */

Testing negative cases!
Running test command:
/home/ubuntu/spr-fast/tools/grep-test.py /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-deccad69-db9d6340/tempworkdir2/src /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-deccad69-db9d6340/tempworkdir2/tests /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-deccad69-db9d6340/tempworkdir2 0  > __res
Building:src at:
/home/ubuntu/spr-fast/tests/corebench/grep/grep-case-deccad69-db9d6340/tempworkdir2/srcSingle building for Tester 0x214bb60 id 9 failed as well!
a batched test job starts!
Building merged code:
src_file: src/search.c
full src: int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
/* search.c - searching subroutines using dfa, kwset and regex for grep.
   Copyright 1992, 1998, 2000, 2007, 2009-2010 Free Software Foundation, Inc.

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 3, or (at your option)
   any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program; if not, write to the Free Software
   Foundation, Inc., 51 Franklin Street - Fifth Floor, Boston, MA
   02110-1301, USA.  */

/* Written August 1992 by Mike Haertel. */

#include <config.h>

#include <sys/types.h>

#include "mbsupport.h"
#ifdef MBS_SUPPORT
/* We can handle multibyte strings. */
# include <wchar.h>
# include <wctype.h>
#endif

#include "system.h"
#include "grep.h"
#ifndef FGREP_PROGRAM
# include <regex.h>
# include "dfa.h"
#endif
#include "kwset.h"
#include "error.h"
#include "xalloc.h"
#ifdef HAVE_LIBPCRE
# include <pcre.h>
#endif

#define NCHAR (UCHAR_MAX + 1)

/* For -w, we also consider _ to be word constituent.  */
#define WCHAR(C) (ISALNUM(C) || (C) == '_')

/* KWset compiled pattern.  For Ecompile and Gcompile, we compile
   a list of strings, at least one of which is known to occur in
   any string matching the regexp. */
static kwset_t kwset;

static void
kwsinit (void)
{
  static char trans[NCHAR];
  int i;

  //prophet generated patch
  if (__get_mutant()==0) {
  if ((match_icase && (__ctype_get_mb_cur_max()) == 1) && !(__is_neg(3, &(match_icase), sizeof (match_icase), &(i), sizeof (i), &(kwset), sizeof (kwset)))) {
      for (i = 0; i < ((127 * 2 + 1) + 1); ++i) 
          trans[i] = ((1 && ((*__ctype_b_loc())[(int)((i))] & (unsigned short)_ISupper)) ? (__extension__ ({
              int __res;
              if (sizeof (i) > 1) {
                  if (__builtin_constant_p(i)) {
                      int __c = (i);
                      __res = __c < -128 || __c > 255 ? __c : (*__ctype_tolower_loc())[__c];
                  } else
                      __res = tolower(i);
              } else
                  __res = (*__ctype_tolower_loc())[(int)(i)];
              __res;
          })) : (i));
      kwset = kwsalloc(trans);
  } else
      kwset = kwsalloc(((void *)0));
  }
  else if (__get_mutant()==1) {
  if ((match_icase && (__ctype_get_mb_cur_max()) == 1) || (__is_neg(3, &(match_icase), sizeof (match_icase), &(i), sizeof (i), &(kwset), sizeof (kwset)))) {
      for (i = 0; i < ((127 * 2 + 1) + 1); ++i) 
          trans[i] = ((1 && ((*__ctype_b_loc())[(int)((i))] & (unsigned short)_ISupper)) ? (__extension__ ({
              int __res;
              if (sizeof (i) > 1) {
                  if (__builtin_constant_p(i)) {
                      int __c = (i);
                      __res = __c < -128 || __c > 255 ? __c : (*__ctype_tolower_loc())[__c];
                  } else
                      __res = tolower(i);
              } else
                  __res = (*__ctype_tolower_loc())[(int)(i)];
              __res;
          })) : (i));
      kwset = kwsalloc(trans);
  } else
      kwset = kwsalloc(((void *)0));
  }
  else if (__get_mutant()==2) {
  if (((match_icase) || (__is_neg(3, &(match_icase), sizeof (match_icase), &(i), sizeof (i), &(kwset), sizeof (kwset)))) && (__ctype_get_mb_cur_max()) == 1) {
      for (i = 0; i < ((127 * 2 + 1) + 1); ++i) 
          trans[i] = ((1 && ((*__ctype_b_loc())[(int)((i))] & (unsigned short)_ISupper)) ? (__extension__ ({
              int __res;
              if (sizeof (i) > 1) {
                  if (__builtin_constant_p(i)) {
                      int __c = (i);
                      __res = __c < -128 || __c > 255 ? __c : (*__ctype_tolower_loc())[__c];
                  } else
                      __res = tolower(i);
              } else
                  __res = (*__ctype_tolower_loc())[(int)(i)];
              __res;
          })) : (i));
      kwset = kwsalloc(trans);
  } else
      kwset = kwsalloc(((void *)0));
  }

  if (!kwset)
    xalloc_die ();
}

#ifdef MBS_SUPPORT
/* Convert the *N-byte string, BEG, to lowercase, and write the
   NUL-terminated result into malloc'd storage.  Upon success, set *N
   to the length (in bytes) of the resulting string (not including the
   trailing NUL byte), and return a pointer to the lowercase string.
   Upon memory allocation failure, this function exits.

   Note that while this function returns a pointer to malloc'd storage,
   the caller must not free it, since this function retains a pointer
   to the buffer and reuses it on any subsequent call.  As a consequence,
   this function is not thread-safe.  */
static char *
mbtolower (const char *beg, size_t *n)
{
  static char *out;
  static size_t outalloc;
  size_t outlen, mb_cur_max;
  mbstate_t is, os;
  const char *end;
  char *p;

  if (*n > outalloc)
    {
      out = xrealloc (out, *n);
      outalloc = *n;
    }

  memset (&is, 0, sizeof (is));
  memset (&os, 0, sizeof (os));
  end = beg + *n;

  mb_cur_max = MB_CUR_MAX;
  p = out;
  outlen = 0;
  while (beg < end)
    {
      wchar_t wc;
      size_t mbclen = mbrtowc(&wc, beg, end - beg, &is);
      if (outlen + mb_cur_max >= outalloc)
        {
          out = x2nrealloc (out, &outalloc, 1);
          p = out + outlen;
        }

      if (mbclen == (size_t) -1 || mbclen == (size_t) -2 || mbclen == 0)
        {
          /* An invalid sequence, or a truncated multi-octet character.
             We treat it as a single-octet character.  */
          *p++ = *beg++;
          outlen++;
          memset (&is, 0, sizeof (is));
          memset (&os, 0, sizeof (os));
        }
      else
        {
          beg += mbclen;
          mbclen = wcrtomb (p, towlower ((wint_t) wc), &os);
          p += mbclen;
          outlen += mbclen;
        }
    }

  *n = p - out;
  *p++ = 0;
  return out;
}
#endif


#ifndef FGREP_PROGRAM
/* DFA compiled regexp. */
static struct dfa dfa;

/* The Regex compiled patterns.  */
static struct patterns
{
  /* Regex compiled regexp. */
  struct re_pattern_buffer regexbuf;
  struct re_registers regs; /* This is here on account of a BRAIN-DEAD
			       Q@#%!# library interface in regex.c.  */
} patterns0;

struct patterns *patterns;
size_t pcount;

void
dfaerror (char const *mesg)
{
  error (EXIT_TROUBLE, 0, "%s", mesg);
}

/* Number of compiled fixed strings known to exactly match the regexp.
   If kwsexec returns < kwset_exact_matches, then we don't need to
   call the regexp matcher at all. */
static int kwset_exact_matches;

static char const *
kwsincr_case (const char *must)
{
  const char *buf;
  size_t n;

  n = strlen (must);
#ifdef MBS_SUPPORT
  if (match_icase && MB_CUR_MAX > 1)
    buf = mbtolower (must, &n);
  else
#endif
    buf = must;
  return kwsincr (kwset, buf, n);
}

/* If the DFA turns out to have some set of fixed strings one of
   which must occur in the match, then we build a kwset matcher
   to find those strings, and thus quickly filter out impossible
   matches. */
static void
kwsmusts (void)
{
  struct dfamust const *dm;
  char const *err;

  if (dfa.musts)
    {
      kwsinit ();
      /* First, we compile in the substrings known to be exact
	 matches.  The kwset matcher will return the index
	 of the matching string that it chooses. */
      for (dm = dfa.musts; dm; dm = dm->next)
	{
	  if (!dm->exact)
	    continue;
	  ++kwset_exact_matches;
	  if ((err = kwsincr_case (dm->must)) != NULL)
	    error (EXIT_TROUBLE, 0, "%s", err);
	}
      /* Now, we compile the substrings that will require
	 the use of the regexp matcher.  */
      for (dm = dfa.musts; dm; dm = dm->next)
	{
	  if (dm->exact)
	    continue;
	  if ((err = kwsincr_case (dm->must)) != NULL)
	    error (EXIT_TROUBLE, 0, "%s", err);
	}
      if ((err = kwsprep (kwset)) != NULL)
	error (EXIT_TROUBLE, 0, "%s", err);
    }
}
#endif /* !FGREP_PROGRAM */

#ifdef MBS_SUPPORT

static bool
is_mb_middle(const char **good, const char *buf, const char *end)
{
  const char *p = *good;
  const char *prev = p;
  mbstate_t cur_state;

  /* TODO: can be optimized for UTF-8.  */
  memset(&cur_state, 0, sizeof(mbstate_t));
  while (p < buf)
    {
      size_t mbclen = mbrlen(p, end - p, &cur_state);

      /* Store the beginning of the previous complete multibyte character.  */
      if (mbclen != (size_t) -2)
        prev = p;

      if (mbclen == (size_t) -1 || mbclen == (size_t) -2 || mbclen == 0)
	{
	  /* An invalid sequence, or a truncated multibyte character.
	     We treat it as a single byte character.  */
	  mbclen = 1;
	}
      p += mbclen;
    }

  *good = prev;
  return p > buf;
}
#endif /* MBS_SUPPORT */

#if defined(GREP_PROGRAM) || defined(EGREP_PROGRAM)
#ifdef EGREP_PROGRAM
COMPILE_FCT(Ecompile)
{
  reg_syntax_t syntax_bits = RE_SYNTAX_POSIX_EGREP;
#else
/* No __VA_ARGS__ in C89.  So we have to do it this way.  */
static COMPILE_RET
GEAcompile (char const *pattern, size_t size, reg_syntax_t syntax_bits)
{
#endif /* EGREP_PROGRAM */
  const char *err;
  const char *p, *sep;
  size_t total = size;
  char *motif;

  if (match_icase)
    syntax_bits |= RE_ICASE;
  re_set_syntax (syntax_bits);
  dfasyntax (syntax_bits, match_icase, eolbyte);

  /* For GNU regex compiler we have to pass the patterns separately to detect
     errors like "[\nallo\n]\n".  The patterns here are "[", "allo" and "]"
     GNU regex should have raise a syntax error.  The same for backref, where
     the backref should have been local to each pattern.  */
  p = pattern;
  do
    {
      size_t len;
      sep = memchr (p, '\n', total);
      if (sep)
	{
	  len = sep - p;
	  sep++;
	  total -= (len + 1);
	}
      else
	{
	  len = total;
	  total = 0;
	}

      patterns = realloc (patterns, (pcount + 1) * sizeof (*patterns));
      if (patterns == NULL)
	error (EXIT_TROUBLE, errno, _("memory exhausted"));
      patterns[pcount] = patterns0;

      if ((err = re_compile_pattern (p, len,
				    &(patterns[pcount].regexbuf))) != NULL)
	error (EXIT_TROUBLE, 0, "%s", err);
      pcount++;

      p = sep;
    } while (sep && total != 0);

  /* In the match_words and match_lines cases, we use a different pattern
     for the DFA matcher that will quickly throw out cases that won't work.
     Then if DFA succeeds we do some hairy stuff using the regex matcher
     to decide whether the match should really count. */
  if (match_words || match_lines)
    {
      static char const line_beg_no_bk[] = "^(";
      static char const line_end_no_bk[] = ")$";
      static char const word_beg_no_bk[] = "(^|[^[:alnum:]_])(";
      static char const word_end_no_bk[] = ")([^[:alnum:]_]|$)";
#ifdef EGREP_PROGRAM
# define IF_BK(x, y) (y)
      char *n = xmalloc (sizeof word_beg_no_bk - 1 + size + sizeof word_end_no_bk);
#else
      static char const line_beg_bk[] = "^\\(";
      static char const line_end_bk[] = "\\)$";
      static char const word_beg_bk[] = "\\(^\\|[^[:alnum:]_]\\)\\(";
      static char const word_end_bk[] = "\\)\\([^[:alnum:]_]\\|$\\)";
      int bk = !(syntax_bits & RE_NO_BK_PARENS);
# define IF_BK(x, y) ((bk) ? (x) : (y))
      char *n = xmalloc (sizeof word_beg_bk - 1 + size + sizeof word_end_bk);
#endif /* EGREP_PROGRAM */

      strcpy (n, match_lines ? IF_BK(line_beg_bk, line_beg_no_bk)
			     : IF_BK(word_beg_bk, word_beg_no_bk));
      total = strlen(n);
      memcpy (n + total, pattern, size);
      total += size;
      strcpy (n + total, match_lines ? IF_BK(line_end_bk, line_end_no_bk)
				     : IF_BK(word_end_bk, word_end_no_bk));
      total += strlen (n + total);
      pattern = motif = n;
      size = total;
    }
  else
    motif = NULL;

  dfacomp (pattern, size, &dfa, 1);
  kwsmusts ();

  free(motif);
}

#ifndef EGREP_PROGRAM
COMPILE_FCT(Gcompile)
{
  return GEAcompile (pattern, size,
		     RE_SYNTAX_GREP | RE_HAT_LISTS_NOT_NEWLINE);
}

COMPILE_FCT(Acompile)
{
  return GEAcompile (pattern, size, RE_SYNTAX_AWK);
}

COMPILE_FCT(Ecompile)
{
  return GEAcompile (pattern, size, RE_SYNTAX_POSIX_EGREP);
}
#endif /* !EGREP_PROGRAM */

EXECUTE_FCT(EGexecute)
{
  char const *buflim, *beg, *end, *match, *best_match, *mb_start;
  char eol = eolbyte;
  int backref, start, len, best_len;
  struct kwsmatch kwsm;
  size_t i, ret_val;
#ifdef MBS_SUPPORT
  if (MB_CUR_MAX > 1)
    {
      if (match_icase)
        {
          /* mbtolower adds a NUL byte at the end.  That will provide
	     space for the sentinel byte dfaexec may add.  */
          char *case_buf = mbtolower (buf, &size);
	  if (start_ptr)
	    start_ptr = case_buf + (start_ptr - buf);
          buf = case_buf;
        }
    }
#endif /* MBS_SUPPORT */

  mb_start = buf;
  buflim = buf + size;

  for (beg = end = buf; end < buflim; beg = end)
    {
      if (!start_ptr)
	{
	  /* We don't care about an exact match.  */
	  if (kwset)
	    {
	      /* Find a possible match using the KWset matcher. */
	      size_t offset = kwsexec (kwset, beg, buflim - beg, &kwsm);
	      if (offset == (size_t) -1)
		goto failure;
	      beg += offset;
	      /* Narrow down to the line containing the candidate, and
		 run it through DFA. */
	      if ((end = memchr(beg, eol, buflim - beg)) != NULL)
	        end++;
              else
                end = buflim;
	      match = beg;
	      while (beg > buf && beg[-1] != eol)
		--beg;
	      if (kwsm.index < kwset_exact_matches)
                {
#ifdef MBS_SUPPORT
                  if (mb_start < beg)
                    mb_start = beg;
                  if (MB_CUR_MAX == 1 || !is_mb_middle (&mb_start, match, buflim))
#endif
                    goto success;
                }
	      if (dfaexec (&dfa, beg, (char *) end, 0, NULL, &backref) == NULL)
		continue;
	    }
	  else
	    {
	      /* No good fixed strings; start with DFA. */
	      char const *next_beg = dfaexec (&dfa, beg, (char *) buflim,
					      0, NULL, &backref);
	      if (next_beg == NULL)
		break;
	      /* Narrow down to the line we've found. */
	      beg = next_beg;
	      if ((end = memchr(beg, eol, buflim - beg)) != NULL)
	        end++;
              else
                end = buflim;
	      while (beg > buf && beg[-1] != eol)
		--beg;
	    }
	  /* Successful, no backreferences encountered! */
	  if (!backref)
	    goto success;
	}
      else
	{
	  /* We are looking for the leftmost (then longest) exact match.
	     We will go through the outer loop only once.  */
	  beg = start_ptr;
	  end = buflim;
	}

      /* If we've made it to this point, this means DFA has seen
	 a probable match, and we need to run it through Regex. */
      best_match = end;
      best_len = 0;
      for (i = 0; i < pcount; i++)
	{
	  patterns[i].regexbuf.not_eol = 0;
	  if (0 <= (start = re_search (&(patterns[i].regexbuf),
				       buf, end - buf - 1,
				       beg - buf, end - beg - 1,
				       &(patterns[i].regs))))
	    {
	      len = patterns[i].regs.end[0] - start;
	      match = buf + start;
	      if (match > best_match)
		continue;
	      if (start_ptr && !match_words)
		goto assess_pattern_match;
	      if ((!match_lines && !match_words)
		  || (match_lines && len == end - beg - 1))
		{
		  match = beg;
		  len = end - beg;
		  goto assess_pattern_match;
		}
	      /* If -w, check if the match aligns with word boundaries.
		 We do this iteratively because:
		 (a) the line may contain more than one occurence of the
		 pattern, and
		 (b) Several alternatives in the pattern might be valid at a
		 given point, and we may need to consider a shorter one to
		 find a word boundary.  */
	      if (match_words)
		while (match <= best_match)
		  {
		    if ((match == buf || !WCHAR ((unsigned char) match[-1]))
			&& (len == end - beg - 1
			    || !WCHAR ((unsigned char) match[len])))
		      goto assess_pattern_match;
		    if (len > 0)
		      {
			/* Try a shorter length anchored at the same place. */
			--len;
			patterns[i].regexbuf.not_eol = 1;
			len = re_match (&(patterns[i].regexbuf),
					buf, match + len - beg, match - buf,
					&(patterns[i].regs));
		      }
		    if (len <= 0)
		      {
			/* Try looking further on. */
			if (match == end - 1)
			  break;
			match++;
			patterns[i].regexbuf.not_eol = 0;
			start = re_search (&(patterns[i].regexbuf),
					   buf, end - buf - 1,
					   match - buf, end - match - 1,
					   &(patterns[i].regs));
			if (start < 0)
			  break;
			len = patterns[i].regs.end[0] - start;
			match = buf + start;
		      }
		  } /* while (match <= best_match) */
	      continue;
	    assess_pattern_match:
	      if (!start_ptr)
		{
		  /* Good enough for a non-exact match.
		     No need to look at further patterns, if any.  */
		  beg = match;
		  goto success_in_len;
		}
	      if (match < best_match || (match == best_match && len > best_len))
		{
		  /* Best exact match:  leftmost, then longest.  */
		  best_match = match;
		  best_len = len;
		}
	    } /* if re_search >= 0 */
	} /* for Regex patterns.  */
	if (best_match < end)
	  {
	    /* We have found an exact match.  We were just
	       waiting for the best one (leftmost then longest).  */
	    beg = best_match;
	    len = best_len;
	    goto success_in_len;
	  }
    } /* for (beg = end ..) */

 failure:
  ret_val = -1;
  goto out;

 success:
  len = end - beg;
 success_in_len:
  *match_size = len;
  ret_val = beg - buf;
 out:
  return ret_val;
}
#endif /* defined(GREP_PROGRAM) || defined(EGREP_PROGRAM) */

#if defined(GREP_PROGRAM) || defined(FGREP_PROGRAM)
COMPILE_FCT(Fcompile)
{
  char const *beg, *end, *lim, *err, *pat;
  size_t psize;

  kwsinit ();
  psize = size;
  if (match_icase && MB_CUR_MAX > 1)
    pat = mbtolower (pattern, &psize);
  else
    pat = pattern;

  beg = pat;
  do
    {
      for (lim = beg;; ++lim)
	{
	  end = lim;
	  if (lim >= pat + psize)
	    break;
	 if (*lim == '\n')
	   {
	     lim++;
	     break;
	   }
#if HAVE_DOS_FILE_CONTENTS
	 if (*lim == '\r' && lim + 1 < pat + psize && lim[1] == '\n')
	   {
	     lim += 2;
	     break;
	   }
#endif
	}

      if ((err = kwsincr (kwset, beg, end - beg)) != NULL)
	error (EXIT_TROUBLE, 0, "%s", err);
      beg = lim;
    }
  while (beg < pat + psize);

  if ((err = kwsprep (kwset)) != NULL)
    error (EXIT_TROUBLE, 0, "%s", err);
}

EXECUTE_FCT(Fexecute)
{
  char const *beg, *try, *end, *mb_start;
  size_t len;
  char eol = eolbyte;
  struct kwsmatch kwsmatch;
  size_t ret_val;
#ifdef MBS_SUPPORT
  if (MB_CUR_MAX > 1)
    {
      if (match_icase)
        {
          char *case_buf = mbtolower (buf, &size);
	  if (start_ptr)
	    start_ptr = case_buf + (start_ptr - buf);
          buf = case_buf;
        }
    }
#endif /* MBS_SUPPORT */

  for (mb_start = beg = start_ptr ? start_ptr : buf; beg <= buf + size; beg++)
    {
      size_t offset = kwsexec (kwset, beg, buf + size - beg, &kwsmatch);
      if (offset == (size_t) -1)
	goto failure;
#ifdef MBS_SUPPORT
      if (MB_CUR_MAX > 1 && is_mb_middle (&mb_start, beg + offset, buf + size))
        {
          beg = mb_start - 1;
          continue; /* It is a part of multibyte character.  */
        }
#endif /* MBS_SUPPORT */
      beg += offset;
      len = kwsmatch.size[0];
      if (start_ptr && !match_words)
	goto success_in_beg_and_len;
      if (match_lines)
	{
	  if (beg > buf && beg[-1] != eol)
	    continue;
	  if (beg + len < buf + size && beg[len] != eol)
	    continue;
	  goto success;
	}
      else if (match_words)
	for (try = beg; len; )
	  {
	    if (try > buf && WCHAR((unsigned char) try[-1]))
	      break;
	    if (try + len < buf + size && WCHAR((unsigned char) try[len]))
	      {
		offset = kwsexec (kwset, beg, --len, &kwsmatch);
		if (offset == (size_t) -1)
		  break;
		try = beg + offset;
		len = kwsmatch.size[0];
	      }
	    else if (!start_ptr)
	      goto success;
	    else
	      goto success_in_beg_and_len;
	  } /* for (try) */
      else
	goto success;
    } /* for (beg in buf) */

 failure:
  ret_val = -1;
  goto out;

 success:
  if ((end = memchr (beg + len, eol, (buf + size) - (beg + len))) != NULL)
    end++;
  else
    end = buf + size;
  while (buf < beg && beg[-1] != eol)
    --beg;
  len = end - beg;
 success_in_beg_and_len:
  *match_size = len;
  ret_val = beg - buf;
 out:
  return ret_val;
}
#endif /* defined(GREP_PROGRAM) || defined(FGREP_PROGRAM) */

#ifdef GREP_PROGRAM
#if HAVE_LIBPCRE
/* Compiled internal form of a Perl regular expression.  */
static pcre *cre;

/* Additional information about the pattern.  */
static pcre_extra *extra;
#endif

COMPILE_FCT(Pcompile)
{
#if !HAVE_LIBPCRE
  error (EXIT_TROUBLE, 0, "%s",
	 _("support for the -P option is not compiled into "
	   "this --disable-perl-regexp binary"));
#else
  int e;
  char const *ep;
  char *re = xmalloc (4 * size + 7);
  int flags = PCRE_MULTILINE | (match_icase ? PCRE_CASELESS : 0);
  char const *patlim = pattern + size;
  char *n = re;
  char const *p;
  char const *pnul;

  /* FIXME: Remove these restrictions.  */
  if (memchr(pattern, '\n', size))
    error (EXIT_TROUBLE, 0, _("the -P option only supports a single pattern"));

  *n = '\0';
  if (match_lines)
    strcpy (n, "^(");
  if (match_words)
    strcpy (n, "\\b(");
  n += strlen (n);

  /* The PCRE interface doesn't allow NUL bytes in the pattern, so
     replace each NUL byte in the pattern with the four characters
     "\000", removing a preceding backslash if there are an odd
     number of backslashes before the NUL.

     FIXME: This method does not work with some multibyte character
     encodings, notably Shift-JIS, where a multibyte character can end
     in a backslash byte.  */
  for (p = pattern; (pnul = memchr (p, '\0', patlim - p)); p = pnul + 1)
    {
      memcpy (n, p, pnul - p);
      n += pnul - p;
      for (p = pnul; pattern < p && p[-1] == '\\'; p--)
	continue;
      n -= (pnul - p) & 1;
      strcpy (n, "\\000");
      n += 4;
    }

  memcpy (n, p, patlim - p);
  n += patlim - p;
  *n = '\0';
  if (match_words)
    strcpy (n, ")\\b");
  if (match_lines)
    strcpy (n, ")$");

  cre = pcre_compile (re, flags, &ep, &e, pcre_maketables ());
  if (!cre)
    error (EXIT_TROUBLE, 0, "%s", ep);

  extra = pcre_study (cre, 0, &ep);
  if (ep)
    error (EXIT_TROUBLE, 0, "%s", ep);

  free (re);
#endif
}

EXECUTE_FCT(Pexecute)
{
#if !HAVE_LIBPCRE
  abort ();
  return -1;
#else
  /* This array must have at least two elements; everything after that
     is just for performance improvement in pcre_exec.  */
  int sub[300];

  const char *line_buf, *line_end, *line_next;
  int e = PCRE_ERROR_NOMATCH;
  ptrdiff_t start_ofs = start_ptr ? start_ptr - buf : 0;

  /* PCRE can't limit the matching to single lines, therefore we have to
     match each line in the buffer separately.  */
  for (line_next = buf;
       e == PCRE_ERROR_NOMATCH && line_next < buf + size;
       start_ofs -= line_next - line_buf)
    {
      line_buf = line_next;
      line_end = memchr (line_buf, eolbyte, (buf + size) - line_buf);
      if (line_end == NULL)
        line_next = line_end = buf + size;
      else
        line_next = line_end + 1;

      if (start_ptr && start_ptr >= line_end)
        continue;

      e = pcre_exec (cre, extra, line_buf, line_end - line_buf,
                     start_ofs < 0 ? 0 : start_ofs, 0,
                     sub, sizeof sub / sizeof *sub);
    }

  if (e <= 0)
    {
      switch (e)
	{
	case PCRE_ERROR_NOMATCH:
	  return -1;

	case PCRE_ERROR_NOMEMORY:
	  error (EXIT_TROUBLE, 0, _("memory exhausted"));

	default:
	  abort ();
	}
    }
  else
    {
      /* Narrow down to the line we've found.  */
      char const *beg = line_buf + sub[0];
      char const *end = line_buf + sub[1];
      char const *buflim = buf + size;
      char eol = eolbyte;
      if (!start_ptr)
	{
	  /* FIXME: The case when '\n' is not found indicates a bug:
	     Since grep is line oriented, the match should never contain
	     a newline, so there _must_ be a newline following.
	   */
	  if (!(end = memchr (end, eol, buflim - end)))
	    end = buflim;
	  else
	    end++;
	  while (buf < beg && beg[-1] != eol)
	    --beg;
	}

      *match_size = end - beg;
      return beg - buf;
    }
#endif
}

struct matcher const matchers[] = {
  { "default", Gcompile, EGexecute },
  { "grep",    Gcompile, EGexecute },
  { "egrep",   Ecompile, EGexecute },
  { "awk",     Acompile, EGexecute },
  { "fgrep",   Fcompile, Fexecute },
  { "perl",    Pcompile, Pexecute },
  { "", 0, 0 },
};
#endif /* GREP_PROGRAM */

Building:src at:
/home/ubuntu/spr-fast/tests/corebench/grep/grep-case-deccad69-db9d6340/tempworkdir2/srcMerged code building succ, going to invoke tester!
CondTester, Testing instance id 0:
//src_file:src/search.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
/* search.c - searching subroutines using dfa, kwset and regex for grep.
   Copyright 1992, 1998, 2000, 2007, 2009-2010 Free Software Foundation, Inc.

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 3, or (at your option)
   any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program; if not, write to the Free Software
   Foundation, Inc., 51 Franklin Street - Fifth Floor, Boston, MA
   02110-1301, USA.  */

/* Written August 1992 by Mike Haertel. */

#include <config.h>

#include <sys/types.h>

#include "mbsupport.h"
#ifdef MBS_SUPPORT
/* We can handle multibyte strings. */
# include <wchar.h>
# include <wctype.h>
#endif

#include "system.h"
#include "grep.h"
#ifndef FGREP_PROGRAM
# include <regex.h>
# include "dfa.h"
#endif
#include "kwset.h"
#include "error.h"
#include "xalloc.h"
#ifdef HAVE_LIBPCRE
# include <pcre.h>
#endif

#define NCHAR (UCHAR_MAX + 1)

/* For -w, we also consider _ to be word constituent.  */
#define WCHAR(C) (ISALNUM(C) || (C) == '_')

/* KWset compiled pattern.  For Ecompile and Gcompile, we compile
   a list of strings, at least one of which is known to occur in
   any string matching the regexp. */
static kwset_t kwset;

static void
kwsinit (void)
{
  static char trans[NCHAR];
  int i;

  
//Patch 0:
if ((match_icase && (__ctype_get_mb_cur_max()) == 1) && !(__is_neg(3, &(match_icase), sizeof (match_icase), &(i), sizeof (i), &(kwset), sizeof (kwset)))) {
    for (i = 0; i < ((127 * 2 + 1) + 1); ++i) 
        trans[i] = ((1 && ((*__ctype_b_loc())[(int)((i))] & (unsigned short)_ISupper)) ? (__extension__ ({
            int __res;
            if (sizeof (i) > 1) {
                if (__builtin_constant_p(i)) {
                    int __c = (i);
                    __res = __c < -128 || __c > 255 ? __c : (*__ctype_tolower_loc())[__c];
                } else
                    __res = tolower(i);
            } else
                __res = (*__ctype_tolower_loc())[(int)(i)];
            __res;
        })) : (i));
    kwset = kwsalloc(trans);
} else
    kwset = kwsalloc(((void *)0));

//CodeSeg 1:

  if (!kwset)
    xalloc_die ();
}

#ifdef MBS_SUPPORT
/* Convert the *N-byte string, BEG, to lowercase, and write the
   NUL-terminated result into malloc'd storage.  Upon success, set *N
   to the length (in bytes) of the resulting string (not including the
   trailing NUL byte), and return a pointer to the lowercase string.
   Upon memory allocation failure, this function exits.

   Note that while this function returns a pointer to malloc'd storage,
   the caller must not free it, since this function retains a pointer
   to the buffer and reuses it on any subsequent call.  As a consequence,
   this function is not thread-safe.  */
static char *
mbtolower (const char *beg, size_t *n)
{
  static char *out;
  static size_t outalloc;
  size_t outlen, mb_cur_max;
  mbstate_t is, os;
  const char *end;
  char *p;

  if (*n > outalloc)
    {
      out = xrealloc (out, *n);
      outalloc = *n;
    }

  memset (&is, 0, sizeof (is));
  memset (&os, 0, sizeof (os));
  end = beg + *n;

  mb_cur_max = MB_CUR_MAX;
  p = out;
  outlen = 0;
  while (beg < end)
    {
      wchar_t wc;
      size_t mbclen = mbrtowc(&wc, beg, end - beg, &is);
      if (outlen + mb_cur_max >= outalloc)
        {
          out = x2nrealloc (out, &outalloc, 1);
          p = out + outlen;
        }

      if (mbclen == (size_t) -1 || mbclen == (size_t) -2 || mbclen == 0)
        {
          /* An invalid sequence, or a truncated multi-octet character.
             We treat it as a single-octet character.  */
          *p++ = *beg++;
          outlen++;
          memset (&is, 0, sizeof (is));
          memset (&os, 0, sizeof (os));
        }
      else
        {
          beg += mbclen;
          mbclen = wcrtomb (p, towlower ((wint_t) wc), &os);
          p += mbclen;
          outlen += mbclen;
        }
    }

  *n = p - out;
  *p++ = 0;
  return out;
}
#endif


#ifndef FGREP_PROGRAM
/* DFA compiled regexp. */
static struct dfa dfa;

/* The Regex compiled patterns.  */
static struct patterns
{
  /* Regex compiled regexp. */
  struct re_pattern_buffer regexbuf;
  struct re_registers regs; /* This is here on account of a BRAIN-DEAD
			       Q@#%!# library interface in regex.c.  */
} patterns0;

struct patterns *patterns;
size_t pcount;

void
dfaerror (char const *mesg)
{
  error (EXIT_TROUBLE, 0, "%s", mesg);
}

/* Number of compiled fixed strings known to exactly match the regexp.
   If kwsexec returns < kwset_exact_matches, then we don't need to
   call the regexp matcher at all. */
static int kwset_exact_matches;

static char const *
kwsincr_case (const char *must)
{
  const char *buf;
  size_t n;

  n = strlen (must);
#ifdef MBS_SUPPORT
  if (match_icase && MB_CUR_MAX > 1)
    buf = mbtolower (must, &n);
  else
#endif
    buf = must;
  return kwsincr (kwset, buf, n);
}

/* If the DFA turns out to have some set of fixed strings one of
   which must occur in the match, then we build a kwset matcher
   to find those strings, and thus quickly filter out impossible
   matches. */
static void
kwsmusts (void)
{
  struct dfamust const *dm;
  char const *err;

  if (dfa.musts)
    {
      kwsinit ();
      /* First, we compile in the substrings known to be exact
	 matches.  The kwset matcher will return the index
	 of the matching string that it chooses. */
      for (dm = dfa.musts; dm; dm = dm->next)
	{
	  if (!dm->exact)
	    continue;
	  ++kwset_exact_matches;
	  if ((err = kwsincr_case (dm->must)) != NULL)
	    error (EXIT_TROUBLE, 0, "%s", err);
	}
      /* Now, we compile the substrings that will require
	 the use of the regexp matcher.  */
      for (dm = dfa.musts; dm; dm = dm->next)
	{
	  if (dm->exact)
	    continue;
	  if ((err = kwsincr_case (dm->must)) != NULL)
	    error (EXIT_TROUBLE, 0, "%s", err);
	}
      if ((err = kwsprep (kwset)) != NULL)
	error (EXIT_TROUBLE, 0, "%s", err);
    }
}
#endif /* !FGREP_PROGRAM */

#ifdef MBS_SUPPORT

static bool
is_mb_middle(const char **good, const char *buf, const char *end)
{
  const char *p = *good;
  const char *prev = p;
  mbstate_t cur_state;

  /* TODO: can be optimized for UTF-8.  */
  memset(&cur_state, 0, sizeof(mbstate_t));
  while (p < buf)
    {
      size_t mbclen = mbrlen(p, end - p, &cur_state);

      /* Store the beginning of the previous complete multibyte character.  */
      if (mbclen != (size_t) -2)
        prev = p;

      if (mbclen == (size_t) -1 || mbclen == (size_t) -2 || mbclen == 0)
	{
	  /* An invalid sequence, or a truncated multibyte character.
	     We treat it as a single byte character.  */
	  mbclen = 1;
	}
      p += mbclen;
    }

  *good = prev;
  return p > buf;
}
#endif /* MBS_SUPPORT */

#if defined(GREP_PROGRAM) || defined(EGREP_PROGRAM)
#ifdef EGREP_PROGRAM
COMPILE_FCT(Ecompile)
{
  reg_syntax_t syntax_bits = RE_SYNTAX_POSIX_EGREP;
#else
/* No __VA_ARGS__ in C89.  So we have to do it this way.  */
static COMPILE_RET
GEAcompile (char const *pattern, size_t size, reg_syntax_t syntax_bits)
{
#endif /* EGREP_PROGRAM */
  const char *err;
  const char *p, *sep;
  size_t total = size;
  char *motif;

  if (match_icase)
    syntax_bits |= RE_ICASE;
  re_set_syntax (syntax_bits);
  dfasyntax (syntax_bits, match_icase, eolbyte);

  /* For GNU regex compiler we have to pass the patterns separately to detect
     errors like "[\nallo\n]\n".  The patterns here are "[", "allo" and "]"
     GNU regex should have raise a syntax error.  The same for backref, where
     the backref should have been local to each pattern.  */
  p = pattern;
  do
    {
      size_t len;
      sep = memchr (p, '\n', total);
      if (sep)
	{
	  len = sep - p;
	  sep++;
	  total -= (len + 1);
	}
      else
	{
	  len = total;
	  total = 0;
	}

      patterns = realloc (patterns, (pcount + 1) * sizeof (*patterns));
      if (patterns == NULL)
	error (EXIT_TROUBLE, errno, _("memory exhausted"));
      patterns[pcount] = patterns0;

      if ((err = re_compile_pattern (p, len,
				    &(patterns[pcount].regexbuf))) != NULL)
	error (EXIT_TROUBLE, 0, "%s", err);
      pcount++;

      p = sep;
    } while (sep && total != 0);

  /* In the match_words and match_lines cases, we use a different pattern
     for the DFA matcher that will quickly throw out cases that won't work.
     Then if DFA succeeds we do some hairy stuff using the regex matcher
     to decide whether the match should really count. */
  if (match_words || match_lines)
    {
      static char const line_beg_no_bk[] = "^(";
      static char const line_end_no_bk[] = ")$";
      static char const word_beg_no_bk[] = "(^|[^[:alnum:]_])(";
      static char const word_end_no_bk[] = ")([^[:alnum:]_]|$)";
#ifdef EGREP_PROGRAM
# define IF_BK(x, y) (y)
      char *n = xmalloc (sizeof word_beg_no_bk - 1 + size + sizeof word_end_no_bk);
#else
      static char const line_beg_bk[] = "^\\(";
      static char const line_end_bk[] = "\\)$";
      static char const word_beg_bk[] = "\\(^\\|[^[:alnum:]_]\\)\\(";
      static char const word_end_bk[] = "\\)\\([^[:alnum:]_]\\|$\\)";
      int bk = !(syntax_bits & RE_NO_BK_PARENS);
# define IF_BK(x, y) ((bk) ? (x) : (y))
      char *n = xmalloc (sizeof word_beg_bk - 1 + size + sizeof word_end_bk);
#endif /* EGREP_PROGRAM */

      strcpy (n, match_lines ? IF_BK(line_beg_bk, line_beg_no_bk)
			     : IF_BK(word_beg_bk, word_beg_no_bk));
      total = strlen(n);
      memcpy (n + total, pattern, size);
      total += size;
      strcpy (n + total, match_lines ? IF_BK(line_end_bk, line_end_no_bk)
				     : IF_BK(word_end_bk, word_end_no_bk));
      total += strlen (n + total);
      pattern = motif = n;
      size = total;
    }
  else
    motif = NULL;

  dfacomp (pattern, size, &dfa, 1);
  kwsmusts ();

  free(motif);
}

#ifndef EGREP_PROGRAM
COMPILE_FCT(Gcompile)
{
  return GEAcompile (pattern, size,
		     RE_SYNTAX_GREP | RE_HAT_LISTS_NOT_NEWLINE);
}

COMPILE_FCT(Acompile)
{
  return GEAcompile (pattern, size, RE_SYNTAX_AWK);
}

COMPILE_FCT(Ecompile)
{
  return GEAcompile (pattern, size, RE_SYNTAX_POSIX_EGREP);
}
#endif /* !EGREP_PROGRAM */

EXECUTE_FCT(EGexecute)
{
  char const *buflim, *beg, *end, *match, *best_match, *mb_start;
  char eol = eolbyte;
  int backref, start, len, best_len;
  struct kwsmatch kwsm;
  size_t i, ret_val;
#ifdef MBS_SUPPORT
  if (MB_CUR_MAX > 1)
    {
      if (match_icase)
        {
          /* mbtolower adds a NUL byte at the end.  That will provide
	     space for the sentinel byte dfaexec may add.  */
          char *case_buf = mbtolower (buf, &size);
	  if (start_ptr)
	    start_ptr = case_buf + (start_ptr - buf);
          buf = case_buf;
        }
    }
#endif /* MBS_SUPPORT */

  mb_start = buf;
  buflim = buf + size;

  for (beg = end = buf; end < buflim; beg = end)
    {
      if (!start_ptr)
	{
	  /* We don't care about an exact match.  */
	  if (kwset)
	    {
	      /* Find a possible match using the KWset matcher. */
	      size_t offset = kwsexec (kwset, beg, buflim - beg, &kwsm);
	      if (offset == (size_t) -1)
		goto failure;
	      beg += offset;
	      /* Narrow down to the line containing the candidate, and
		 run it through DFA. */
	      if ((end = memchr(beg, eol, buflim - beg)) != NULL)
	        end++;
              else
                end = buflim;
	      match = beg;
	      while (beg > buf && beg[-1] != eol)
		--beg;
	      if (kwsm.index < kwset_exact_matches)
                {
#ifdef MBS_SUPPORT
                  if (mb_start < beg)
                    mb_start = beg;
                  if (MB_CUR_MAX == 1 || !is_mb_middle (&mb_start, match, buflim))
#endif
                    goto success;
                }
	      if (dfaexec (&dfa, beg, (char *) end, 0, NULL, &backref) == NULL)
		continue;
	    }
	  else
	    {
	      /* No good fixed strings; start with DFA. */
	      char const *next_beg = dfaexec (&dfa, beg, (char *) buflim,
					      0, NULL, &backref);
	      if (next_beg == NULL)
		break;
	      /* Narrow down to the line we've found. */
	      beg = next_beg;
	      if ((end = memchr(beg, eol, buflim - beg)) != NULL)
	        end++;
              else
                end = buflim;
	      while (beg > buf && beg[-1] != eol)
		--beg;
	    }
	  /* Successful, no backreferences encountered! */
	  if (!backref)
	    goto success;
	}
      else
	{
	  /* We are looking for the leftmost (then longest) exact match.
	     We will go through the outer loop only once.  */
	  beg = start_ptr;
	  end = buflim;
	}

      /* If we've made it to this point, this means DFA has seen
	 a probable match, and we need to run it through Regex. */
      best_match = end;
      best_len = 0;
      for (i = 0; i < pcount; i++)
	{
	  patterns[i].regexbuf.not_eol = 0;
	  if (0 <= (start = re_search (&(patterns[i].regexbuf),
				       buf, end - buf - 1,
				       beg - buf, end - beg - 1,
				       &(patterns[i].regs))))
	    {
	      len = patterns[i].regs.end[0] - start;
	      match = buf + start;
	      if (match > best_match)
		continue;
	      if (start_ptr && !match_words)
		goto assess_pattern_match;
	      if ((!match_lines && !match_words)
		  || (match_lines && len == end - beg - 1))
		{
		  match = beg;
		  len = end - beg;
		  goto assess_pattern_match;
		}
	      /* If -w, check if the match aligns with word boundaries.
		 We do this iteratively because:
		 (a) the line may contain more than one occurence of the
		 pattern, and
		 (b) Several alternatives in the pattern might be valid at a
		 given point, and we may need to consider a shorter one to
		 find a word boundary.  */
	      if (match_words)
		while (match <= best_match)
		  {
		    if ((match == buf || !WCHAR ((unsigned char) match[-1]))
			&& (len == end - beg - 1
			    || !WCHAR ((unsigned char) match[len])))
		      goto assess_pattern_match;
		    if (len > 0)
		      {
			/* Try a shorter length anchored at the same place. */
			--len;
			patterns[i].regexbuf.not_eol = 1;
			len = re_match (&(patterns[i].regexbuf),
					buf, match + len - beg, match - buf,
					&(patterns[i].regs));
		      }
		    if (len <= 0)
		      {
			/* Try looking further on. */
			if (match == end - 1)
			  break;
			match++;
			patterns[i].regexbuf.not_eol = 0;
			start = re_search (&(patterns[i].regexbuf),
					   buf, end - buf - 1,
					   match - buf, end - match - 1,
					   &(patterns[i].regs));
			if (start < 0)
			  break;
			len = patterns[i].regs.end[0] - start;
			match = buf + start;
		      }
		  } /* while (match <= best_match) */
	      continue;
	    assess_pattern_match:
	      if (!start_ptr)
		{
		  /* Good enough for a non-exact match.
		     No need to look at further patterns, if any.  */
		  beg = match;
		  goto success_in_len;
		}
	      if (match < best_match || (match == best_match && len > best_len))
		{
		  /* Best exact match:  leftmost, then longest.  */
		  best_match = match;
		  best_len = len;
		}
	    } /* if re_search >= 0 */
	} /* for Regex patterns.  */
	if (best_match < end)
	  {
	    /* We have found an exact match.  We were just
	       waiting for the best one (leftmost then longest).  */
	    beg = best_match;
	    len = best_len;
	    goto success_in_len;
	  }
    } /* for (beg = end ..) */

 failure:
  ret_val = -1;
  goto out;

 success:
  len = end - beg;
 success_in_len:
  *match_size = len;
  ret_val = beg - buf;
 out:
  return ret_val;
}
#endif /* defined(GREP_PROGRAM) || defined(EGREP_PROGRAM) */

#if defined(GREP_PROGRAM) || defined(FGREP_PROGRAM)
COMPILE_FCT(Fcompile)
{
  char const *beg, *end, *lim, *err, *pat;
  size_t psize;

  kwsinit ();
  psize = size;
  if (match_icase && MB_CUR_MAX > 1)
    pat = mbtolower (pattern, &psize);
  else
    pat = pattern;

  beg = pat;
  do
    {
      for (lim = beg;; ++lim)
	{
	  end = lim;
	  if (lim >= pat + psize)
	    break;
	 if (*lim == '\n')
	   {
	     lim++;
	     break;
	   }
#if HAVE_DOS_FILE_CONTENTS
	 if (*lim == '\r' && lim + 1 < pat + psize && lim[1] == '\n')
	   {
	     lim += 2;
	     break;
	   }
#endif
	}

      if ((err = kwsincr (kwset, beg, end - beg)) != NULL)
	error (EXIT_TROUBLE, 0, "%s", err);
      beg = lim;
    }
  while (beg < pat + psize);

  if ((err = kwsprep (kwset)) != NULL)
    error (EXIT_TROUBLE, 0, "%s", err);
}

EXECUTE_FCT(Fexecute)
{
  char const *beg, *try, *end, *mb_start;
  size_t len;
  char eol = eolbyte;
  struct kwsmatch kwsmatch;
  size_t ret_val;
#ifdef MBS_SUPPORT
  if (MB_CUR_MAX > 1)
    {
      if (match_icase)
        {
          char *case_buf = mbtolower (buf, &size);
	  if (start_ptr)
	    start_ptr = case_buf + (start_ptr - buf);
          buf = case_buf;
        }
    }
#endif /* MBS_SUPPORT */

  for (mb_start = beg = start_ptr ? start_ptr : buf; beg <= buf + size; beg++)
    {
      size_t offset = kwsexec (kwset, beg, buf + size - beg, &kwsmatch);
      if (offset == (size_t) -1)
	goto failure;
#ifdef MBS_SUPPORT
      if (MB_CUR_MAX > 1 && is_mb_middle (&mb_start, beg + offset, buf + size))
        {
          beg = mb_start - 1;
          continue; /* It is a part of multibyte character.  */
        }
#endif /* MBS_SUPPORT */
      beg += offset;
      len = kwsmatch.size[0];
      if (start_ptr && !match_words)
	goto success_in_beg_and_len;
      if (match_lines)
	{
	  if (beg > buf && beg[-1] != eol)
	    continue;
	  if (beg + len < buf + size && beg[len] != eol)
	    continue;
	  goto success;
	}
      else if (match_words)
	for (try = beg; len; )
	  {
	    if (try > buf && WCHAR((unsigned char) try[-1]))
	      break;
	    if (try + len < buf + size && WCHAR((unsigned char) try[len]))
	      {
		offset = kwsexec (kwset, beg, --len, &kwsmatch);
		if (offset == (size_t) -1)
		  break;
		try = beg + offset;
		len = kwsmatch.size[0];
	      }
	    else if (!start_ptr)
	      goto success;
	    else
	      goto success_in_beg_and_len;
	  } /* for (try) */
      else
	goto success;
    } /* for (beg in buf) */

 failure:
  ret_val = -1;
  goto out;

 success:
  if ((end = memchr (beg + len, eol, (buf + size) - (beg + len))) != NULL)
    end++;
  else
    end = buf + size;
  while (buf < beg && beg[-1] != eol)
    --beg;
  len = end - beg;
 success_in_beg_and_len:
  *match_size = len;
  ret_val = beg - buf;
 out:
  return ret_val;
}
#endif /* defined(GREP_PROGRAM) || defined(FGREP_PROGRAM) */

#ifdef GREP_PROGRAM
#if HAVE_LIBPCRE
/* Compiled internal form of a Perl regular expression.  */
static pcre *cre;

/* Additional information about the pattern.  */
static pcre_extra *extra;
#endif

COMPILE_FCT(Pcompile)
{
#if !HAVE_LIBPCRE
  error (EXIT_TROUBLE, 0, "%s",
	 _("support for the -P option is not compiled into "
	   "this --disable-perl-regexp binary"));
#else
  int e;
  char const *ep;
  char *re = xmalloc (4 * size + 7);
  int flags = PCRE_MULTILINE | (match_icase ? PCRE_CASELESS : 0);
  char const *patlim = pattern + size;
  char *n = re;
  char const *p;
  char const *pnul;

  /* FIXME: Remove these restrictions.  */
  if (memchr(pattern, '\n', size))
    error (EXIT_TROUBLE, 0, _("the -P option only supports a single pattern"));

  *n = '\0';
  if (match_lines)
    strcpy (n, "^(");
  if (match_words)
    strcpy (n, "\\b(");
  n += strlen (n);

  /* The PCRE interface doesn't allow NUL bytes in the pattern, so
     replace each NUL byte in the pattern with the four characters
     "\000", removing a preceding backslash if there are an odd
     number of backslashes before the NUL.

     FIXME: This method does not work with some multibyte character
     encodings, notably Shift-JIS, where a multibyte character can end
     in a backslash byte.  */
  for (p = pattern; (pnul = memchr (p, '\0', patlim - p)); p = pnul + 1)
    {
      memcpy (n, p, pnul - p);
      n += pnul - p;
      for (p = pnul; pattern < p && p[-1] == '\\'; p--)
	continue;
      n -= (pnul - p) & 1;
      strcpy (n, "\\000");
      n += 4;
    }

  memcpy (n, p, patlim - p);
  n += patlim - p;
  *n = '\0';
  if (match_words)
    strcpy (n, ")\\b");
  if (match_lines)
    strcpy (n, ")$");

  cre = pcre_compile (re, flags, &ep, &e, pcre_maketables ());
  if (!cre)
    error (EXIT_TROUBLE, 0, "%s", ep);

  extra = pcre_study (cre, 0, &ep);
  if (ep)
    error (EXIT_TROUBLE, 0, "%s", ep);

  free (re);
#endif
}

EXECUTE_FCT(Pexecute)
{
#if !HAVE_LIBPCRE
  abort ();
  return -1;
#else
  /* This array must have at least two elements; everything after that
     is just for performance improvement in pcre_exec.  */
  int sub[300];

  const char *line_buf, *line_end, *line_next;
  int e = PCRE_ERROR_NOMATCH;
  ptrdiff_t start_ofs = start_ptr ? start_ptr - buf : 0;

  /* PCRE can't limit the matching to single lines, therefore we have to
     match each line in the buffer separately.  */
  for (line_next = buf;
       e == PCRE_ERROR_NOMATCH && line_next < buf + size;
       start_ofs -= line_next - line_buf)
    {
      line_buf = line_next;
      line_end = memchr (line_buf, eolbyte, (buf + size) - line_buf);
      if (line_end == NULL)
        line_next = line_end = buf + size;
      else
        line_next = line_end + 1;

      if (start_ptr && start_ptr >= line_end)
        continue;

      e = pcre_exec (cre, extra, line_buf, line_end - line_buf,
                     start_ofs < 0 ? 0 : start_ofs, 0,
                     sub, sizeof sub / sizeof *sub);
    }

  if (e <= 0)
    {
      switch (e)
	{
	case PCRE_ERROR_NOMATCH:
	  return -1;

	case PCRE_ERROR_NOMEMORY:
	  error (EXIT_TROUBLE, 0, _("memory exhausted"));

	default:
	  abort ();
	}
    }
  else
    {
      /* Narrow down to the line we've found.  */
      char const *beg = line_buf + sub[0];
      char const *end = line_buf + sub[1];
      char const *buflim = buf + size;
      char eol = eolbyte;
      if (!start_ptr)
	{
	  /* FIXME: The case when '\n' is not found indicates a bug:
	     Since grep is line oriented, the match should never contain
	     a newline, so there _must_ be a newline following.
	   */
	  if (!(end = memchr (end, eol, buflim - end)))
	    end = buflim;
	  else
	    end++;
	  while (buf < beg && beg[-1] != eol)
	    --beg;
	}

      *match_size = end - beg;
      return beg - buf;
    }
#endif
}

struct matcher const matchers[] = {
  { "default", Gcompile, EGexecute },
  { "grep",    Gcompile, EGexecute },
  { "egrep",   Ecompile, EGexecute },
  { "awk",     Acompile, EGexecute },
  { "fgrep",   Fcompile, Fexecute },
  { "perl",    Pcompile, Pexecute },
  { "", 0, 0 },
};
#endif /* GREP_PROGRAM */

Testing negative cases!
Testing 0 (with abstract condition) ENVIS_NEG
Iteration 0
Running test command:
/home/ubuntu/spr-fast/tools/grep-test.py /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-deccad69-db9d6340/tempworkdir2/src /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-deccad69-db9d6340/tempworkdir2/tests /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-deccad69-db9d6340/tempworkdir2 0  > __res
Opening:/home/ubuntu/spr-fast/tests/corebench/grep/grep-case-deccad69-db9d6340/tempworkdir2/neg.tmp!
NegativeBRANCH RECORD/home/ubuntu/spr-fast/tests/corebench/grep/grep-case-deccad69-db9d6340/tempworkdir2/neg.tmp!
Not caught by the negative case, give up!
APPENDING TO ISNEG:/home/ubuntu/spr-fast/tests/corebench/grep/grep-case-deccad69-db9d6340/tempworkdir2/neg.tmp!
Running test command:
/home/ubuntu/spr-fast/tools/grep-test.py /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-deccad69-db9d6340/tempworkdir2/src /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-deccad69-db9d6340/tempworkdir2/tests /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-deccad69-db9d6340/tempworkdir2 0  > __res
CondTester, Testing instance id 15:
//src_file:src/search.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
/* search.c - searching subroutines using dfa, kwset and regex for grep.
   Copyright 1992, 1998, 2000, 2007, 2009-2010 Free Software Foundation, Inc.

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 3, or (at your option)
   any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program; if not, write to the Free Software
   Foundation, Inc., 51 Franklin Street - Fifth Floor, Boston, MA
   02110-1301, USA.  */

/* Written August 1992 by Mike Haertel. */

#include <config.h>

#include <sys/types.h>

#include "mbsupport.h"
#ifdef MBS_SUPPORT
/* We can handle multibyte strings. */
# include <wchar.h>
# include <wctype.h>
#endif

#include "system.h"
#include "grep.h"
#ifndef FGREP_PROGRAM
# include <regex.h>
# include "dfa.h"
#endif
#include "kwset.h"
#include "error.h"
#include "xalloc.h"
#ifdef HAVE_LIBPCRE
# include <pcre.h>
#endif

#define NCHAR (UCHAR_MAX + 1)

/* For -w, we also consider _ to be word constituent.  */
#define WCHAR(C) (ISALNUM(C) || (C) == '_')

/* KWset compiled pattern.  For Ecompile and Gcompile, we compile
   a list of strings, at least one of which is known to occur in
   any string matching the regexp. */
static kwset_t kwset;

static void
kwsinit (void)
{
  static char trans[NCHAR];
  int i;

  
//Patch 0:
if ((match_icase && (__ctype_get_mb_cur_max()) == 1) || (__is_neg(3, &(match_icase), sizeof (match_icase), &(i), sizeof (i), &(kwset), sizeof (kwset)))) {
    for (i = 0; i < ((127 * 2 + 1) + 1); ++i) 
        trans[i] = ((1 && ((*__ctype_b_loc())[(int)((i))] & (unsigned short)_ISupper)) ? (__extension__ ({
            int __res;
            if (sizeof (i) > 1) {
                if (__builtin_constant_p(i)) {
                    int __c = (i);
                    __res = __c < -128 || __c > 255 ? __c : (*__ctype_tolower_loc())[__c];
                } else
                    __res = tolower(i);
            } else
                __res = (*__ctype_tolower_loc())[(int)(i)];
            __res;
        })) : (i));
    kwset = kwsalloc(trans);
} else
    kwset = kwsalloc(((void *)0));

//CodeSeg 1:

  if (!kwset)
    xalloc_die ();
}

#ifdef MBS_SUPPORT
/* Convert the *N-byte string, BEG, to lowercase, and write the
   NUL-terminated result into malloc'd storage.  Upon success, set *N
   to the length (in bytes) of the resulting string (not including the
   trailing NUL byte), and return a pointer to the lowercase string.
   Upon memory allocation failure, this function exits.

   Note that while this function returns a pointer to malloc'd storage,
   the caller must not free it, since this function retains a pointer
   to the buffer and reuses it on any subsequent call.  As a consequence,
   this function is not thread-safe.  */
static char *
mbtolower (const char *beg, size_t *n)
{
  static char *out;
  static size_t outalloc;
  size_t outlen, mb_cur_max;
  mbstate_t is, os;
  const char *end;
  char *p;

  if (*n > outalloc)
    {
      out = xrealloc (out, *n);
      outalloc = *n;
    }

  memset (&is, 0, sizeof (is));
  memset (&os, 0, sizeof (os));
  end = beg + *n;

  mb_cur_max = MB_CUR_MAX;
  p = out;
  outlen = 0;
  while (beg < end)
    {
      wchar_t wc;
      size_t mbclen = mbrtowc(&wc, beg, end - beg, &is);
      if (outlen + mb_cur_max >= outalloc)
        {
          out = x2nrealloc (out, &outalloc, 1);
          p = out + outlen;
        }

      if (mbclen == (size_t) -1 || mbclen == (size_t) -2 || mbclen == 0)
        {
          /* An invalid sequence, or a truncated multi-octet character.
             We treat it as a single-octet character.  */
          *p++ = *beg++;
          outlen++;
          memset (&is, 0, sizeof (is));
          memset (&os, 0, sizeof (os));
        }
      else
        {
          beg += mbclen;
          mbclen = wcrtomb (p, towlower ((wint_t) wc), &os);
          p += mbclen;
          outlen += mbclen;
        }
    }

  *n = p - out;
  *p++ = 0;
  return out;
}
#endif


#ifndef FGREP_PROGRAM
/* DFA compiled regexp. */
static struct dfa dfa;

/* The Regex compiled patterns.  */
static struct patterns
{
  /* Regex compiled regexp. */
  struct re_pattern_buffer regexbuf;
  struct re_registers regs; /* This is here on account of a BRAIN-DEAD
			       Q@#%!# library interface in regex.c.  */
} patterns0;

struct patterns *patterns;
size_t pcount;

void
dfaerror (char const *mesg)
{
  error (EXIT_TROUBLE, 0, "%s", mesg);
}

/* Number of compiled fixed strings known to exactly match the regexp.
   If kwsexec returns < kwset_exact_matches, then we don't need to
   call the regexp matcher at all. */
static int kwset_exact_matches;

static char const *
kwsincr_case (const char *must)
{
  const char *buf;
  size_t n;

  n = strlen (must);
#ifdef MBS_SUPPORT
  if (match_icase && MB_CUR_MAX > 1)
    buf = mbtolower (must, &n);
  else
#endif
    buf = must;
  return kwsincr (kwset, buf, n);
}

/* If the DFA turns out to have some set of fixed strings one of
   which must occur in the match, then we build a kwset matcher
   to find those strings, and thus quickly filter out impossible
   matches. */
static void
kwsmusts (void)
{
  struct dfamust const *dm;
  char const *err;

  if (dfa.musts)
    {
      kwsinit ();
      /* First, we compile in the substrings known to be exact
	 matches.  The kwset matcher will return the index
	 of the matching string that it chooses. */
      for (dm = dfa.musts; dm; dm = dm->next)
	{
	  if (!dm->exact)
	    continue;
	  ++kwset_exact_matches;
	  if ((err = kwsincr_case (dm->must)) != NULL)
	    error (EXIT_TROUBLE, 0, "%s", err);
	}
      /* Now, we compile the substrings that will require
	 the use of the regexp matcher.  */
      for (dm = dfa.musts; dm; dm = dm->next)
	{
	  if (dm->exact)
	    continue;
	  if ((err = kwsincr_case (dm->must)) != NULL)
	    error (EXIT_TROUBLE, 0, "%s", err);
	}
      if ((err = kwsprep (kwset)) != NULL)
	error (EXIT_TROUBLE, 0, "%s", err);
    }
}
#endif /* !FGREP_PROGRAM */

#ifdef MBS_SUPPORT

static bool
is_mb_middle(const char **good, const char *buf, const char *end)
{
  const char *p = *good;
  const char *prev = p;
  mbstate_t cur_state;

  /* TODO: can be optimized for UTF-8.  */
  memset(&cur_state, 0, sizeof(mbstate_t));
  while (p < buf)
    {
      size_t mbclen = mbrlen(p, end - p, &cur_state);

      /* Store the beginning of the previous complete multibyte character.  */
      if (mbclen != (size_t) -2)
        prev = p;

      if (mbclen == (size_t) -1 || mbclen == (size_t) -2 || mbclen == 0)
	{
	  /* An invalid sequence, or a truncated multibyte character.
	     We treat it as a single byte character.  */
	  mbclen = 1;
	}
      p += mbclen;
    }

  *good = prev;
  return p > buf;
}
#endif /* MBS_SUPPORT */

#if defined(GREP_PROGRAM) || defined(EGREP_PROGRAM)
#ifdef EGREP_PROGRAM
COMPILE_FCT(Ecompile)
{
  reg_syntax_t syntax_bits = RE_SYNTAX_POSIX_EGREP;
#else
/* No __VA_ARGS__ in C89.  So we have to do it this way.  */
static COMPILE_RET
GEAcompile (char const *pattern, size_t size, reg_syntax_t syntax_bits)
{
#endif /* EGREP_PROGRAM */
  const char *err;
  const char *p, *sep;
  size_t total = size;
  char *motif;

  if (match_icase)
    syntax_bits |= RE_ICASE;
  re_set_syntax (syntax_bits);
  dfasyntax (syntax_bits, match_icase, eolbyte);

  /* For GNU regex compiler we have to pass the patterns separately to detect
     errors like "[\nallo\n]\n".  The patterns here are "[", "allo" and "]"
     GNU regex should have raise a syntax error.  The same for backref, where
     the backref should have been local to each pattern.  */
  p = pattern;
  do
    {
      size_t len;
      sep = memchr (p, '\n', total);
      if (sep)
	{
	  len = sep - p;
	  sep++;
	  total -= (len + 1);
	}
      else
	{
	  len = total;
	  total = 0;
	}

      patterns = realloc (patterns, (pcount + 1) * sizeof (*patterns));
      if (patterns == NULL)
	error (EXIT_TROUBLE, errno, _("memory exhausted"));
      patterns[pcount] = patterns0;

      if ((err = re_compile_pattern (p, len,
				    &(patterns[pcount].regexbuf))) != NULL)
	error (EXIT_TROUBLE, 0, "%s", err);
      pcount++;

      p = sep;
    } while (sep && total != 0);

  /* In the match_words and match_lines cases, we use a different pattern
     for the DFA matcher that will quickly throw out cases that won't work.
     Then if DFA succeeds we do some hairy stuff using the regex matcher
     to decide whether the match should really count. */
  if (match_words || match_lines)
    {
      static char const line_beg_no_bk[] = "^(";
      static char const line_end_no_bk[] = ")$";
      static char const word_beg_no_bk[] = "(^|[^[:alnum:]_])(";
      static char const word_end_no_bk[] = ")([^[:alnum:]_]|$)";
#ifdef EGREP_PROGRAM
# define IF_BK(x, y) (y)
      char *n = xmalloc (sizeof word_beg_no_bk - 1 + size + sizeof word_end_no_bk);
#else
      static char const line_beg_bk[] = "^\\(";
      static char const line_end_bk[] = "\\)$";
      static char const word_beg_bk[] = "\\(^\\|[^[:alnum:]_]\\)\\(";
      static char const word_end_bk[] = "\\)\\([^[:alnum:]_]\\|$\\)";
      int bk = !(syntax_bits & RE_NO_BK_PARENS);
# define IF_BK(x, y) ((bk) ? (x) : (y))
      char *n = xmalloc (sizeof word_beg_bk - 1 + size + sizeof word_end_bk);
#endif /* EGREP_PROGRAM */

      strcpy (n, match_lines ? IF_BK(line_beg_bk, line_beg_no_bk)
			     : IF_BK(word_beg_bk, word_beg_no_bk));
      total = strlen(n);
      memcpy (n + total, pattern, size);
      total += size;
      strcpy (n + total, match_lines ? IF_BK(line_end_bk, line_end_no_bk)
				     : IF_BK(word_end_bk, word_end_no_bk));
      total += strlen (n + total);
      pattern = motif = n;
      size = total;
    }
  else
    motif = NULL;

  dfacomp (pattern, size, &dfa, 1);
  kwsmusts ();

  free(motif);
}

#ifndef EGREP_PROGRAM
COMPILE_FCT(Gcompile)
{
  return GEAcompile (pattern, size,
		     RE_SYNTAX_GREP | RE_HAT_LISTS_NOT_NEWLINE);
}

COMPILE_FCT(Acompile)
{
  return GEAcompile (pattern, size, RE_SYNTAX_AWK);
}

COMPILE_FCT(Ecompile)
{
  return GEAcompile (pattern, size, RE_SYNTAX_POSIX_EGREP);
}
#endif /* !EGREP_PROGRAM */

EXECUTE_FCT(EGexecute)
{
  char const *buflim, *beg, *end, *match, *best_match, *mb_start;
  char eol = eolbyte;
  int backref, start, len, best_len;
  struct kwsmatch kwsm;
  size_t i, ret_val;
#ifdef MBS_SUPPORT
  if (MB_CUR_MAX > 1)
    {
      if (match_icase)
        {
          /* mbtolower adds a NUL byte at the end.  That will provide
	     space for the sentinel byte dfaexec may add.  */
          char *case_buf = mbtolower (buf, &size);
	  if (start_ptr)
	    start_ptr = case_buf + (start_ptr - buf);
          buf = case_buf;
        }
    }
#endif /* MBS_SUPPORT */

  mb_start = buf;
  buflim = buf + size;

  for (beg = end = buf; end < buflim; beg = end)
    {
      if (!start_ptr)
	{
	  /* We don't care about an exact match.  */
	  if (kwset)
	    {
	      /* Find a possible match using the KWset matcher. */
	      size_t offset = kwsexec (kwset, beg, buflim - beg, &kwsm);
	      if (offset == (size_t) -1)
		goto failure;
	      beg += offset;
	      /* Narrow down to the line containing the candidate, and
		 run it through DFA. */
	      if ((end = memchr(beg, eol, buflim - beg)) != NULL)
	        end++;
              else
                end = buflim;
	      match = beg;
	      while (beg > buf && beg[-1] != eol)
		--beg;
	      if (kwsm.index < kwset_exact_matches)
                {
#ifdef MBS_SUPPORT
                  if (mb_start < beg)
                    mb_start = beg;
                  if (MB_CUR_MAX == 1 || !is_mb_middle (&mb_start, match, buflim))
#endif
                    goto success;
                }
	      if (dfaexec (&dfa, beg, (char *) end, 0, NULL, &backref) == NULL)
		continue;
	    }
	  else
	    {
	      /* No good fixed strings; start with DFA. */
	      char const *next_beg = dfaexec (&dfa, beg, (char *) buflim,
					      0, NULL, &backref);
	      if (next_beg == NULL)
		break;
	      /* Narrow down to the line we've found. */
	      beg = next_beg;
	      if ((end = memchr(beg, eol, buflim - beg)) != NULL)
	        end++;
              else
                end = buflim;
	      while (beg > buf && beg[-1] != eol)
		--beg;
	    }
	  /* Successful, no backreferences encountered! */
	  if (!backref)
	    goto success;
	}
      else
	{
	  /* We are looking for the leftmost (then longest) exact match.
	     We will go through the outer loop only once.  */
	  beg = start_ptr;
	  end = buflim;
	}

      /* If we've made it to this point, this means DFA has seen
	 a probable match, and we need to run it through Regex. */
      best_match = end;
      best_len = 0;
      for (i = 0; i < pcount; i++)
	{
	  patterns[i].regexbuf.not_eol = 0;
	  if (0 <= (start = re_search (&(patterns[i].regexbuf),
				       buf, end - buf - 1,
				       beg - buf, end - beg - 1,
				       &(patterns[i].regs))))
	    {
	      len = patterns[i].regs.end[0] - start;
	      match = buf + start;
	      if (match > best_match)
		continue;
	      if (start_ptr && !match_words)
		goto assess_pattern_match;
	      if ((!match_lines && !match_words)
		  || (match_lines && len == end - beg - 1))
		{
		  match = beg;
		  len = end - beg;
		  goto assess_pattern_match;
		}
	      /* If -w, check if the match aligns with word boundaries.
		 We do this iteratively because:
		 (a) the line may contain more than one occurence of the
		 pattern, and
		 (b) Several alternatives in the pattern might be valid at a
		 given point, and we may need to consider a shorter one to
		 find a word boundary.  */
	      if (match_words)
		while (match <= best_match)
		  {
		    if ((match == buf || !WCHAR ((unsigned char) match[-1]))
			&& (len == end - beg - 1
			    || !WCHAR ((unsigned char) match[len])))
		      goto assess_pattern_match;
		    if (len > 0)
		      {
			/* Try a shorter length anchored at the same place. */
			--len;
			patterns[i].regexbuf.not_eol = 1;
			len = re_match (&(patterns[i].regexbuf),
					buf, match + len - beg, match - buf,
					&(patterns[i].regs));
		      }
		    if (len <= 0)
		      {
			/* Try looking further on. */
			if (match == end - 1)
			  break;
			match++;
			patterns[i].regexbuf.not_eol = 0;
			start = re_search (&(patterns[i].regexbuf),
					   buf, end - buf - 1,
					   match - buf, end - match - 1,
					   &(patterns[i].regs));
			if (start < 0)
			  break;
			len = patterns[i].regs.end[0] - start;
			match = buf + start;
		      }
		  } /* while (match <= best_match) */
	      continue;
	    assess_pattern_match:
	      if (!start_ptr)
		{
		  /* Good enough for a non-exact match.
		     No need to look at further patterns, if any.  */
		  beg = match;
		  goto success_in_len;
		}
	      if (match < best_match || (match == best_match && len > best_len))
		{
		  /* Best exact match:  leftmost, then longest.  */
		  best_match = match;
		  best_len = len;
		}
	    } /* if re_search >= 0 */
	} /* for Regex patterns.  */
	if (best_match < end)
	  {
	    /* We have found an exact match.  We were just
	       waiting for the best one (leftmost then longest).  */
	    beg = best_match;
	    len = best_len;
	    goto success_in_len;
	  }
    } /* for (beg = end ..) */

 failure:
  ret_val = -1;
  goto out;

 success:
  len = end - beg;
 success_in_len:
  *match_size = len;
  ret_val = beg - buf;
 out:
  return ret_val;
}
#endif /* defined(GREP_PROGRAM) || defined(EGREP_PROGRAM) */

#if defined(GREP_PROGRAM) || defined(FGREP_PROGRAM)
COMPILE_FCT(Fcompile)
{
  char const *beg, *end, *lim, *err, *pat;
  size_t psize;

  kwsinit ();
  psize = size;
  if (match_icase && MB_CUR_MAX > 1)
    pat = mbtolower (pattern, &psize);
  else
    pat = pattern;

  beg = pat;
  do
    {
      for (lim = beg;; ++lim)
	{
	  end = lim;
	  if (lim >= pat + psize)
	    break;
	 if (*lim == '\n')
	   {
	     lim++;
	     break;
	   }
#if HAVE_DOS_FILE_CONTENTS
	 if (*lim == '\r' && lim + 1 < pat + psize && lim[1] == '\n')
	   {
	     lim += 2;
	     break;
	   }
#endif
	}

      if ((err = kwsincr (kwset, beg, end - beg)) != NULL)
	error (EXIT_TROUBLE, 0, "%s", err);
      beg = lim;
    }
  while (beg < pat + psize);

  if ((err = kwsprep (kwset)) != NULL)
    error (EXIT_TROUBLE, 0, "%s", err);
}

EXECUTE_FCT(Fexecute)
{
  char const *beg, *try, *end, *mb_start;
  size_t len;
  char eol = eolbyte;
  struct kwsmatch kwsmatch;
  size_t ret_val;
#ifdef MBS_SUPPORT
  if (MB_CUR_MAX > 1)
    {
      if (match_icase)
        {
          char *case_buf = mbtolower (buf, &size);
	  if (start_ptr)
	    start_ptr = case_buf + (start_ptr - buf);
          buf = case_buf;
        }
    }
#endif /* MBS_SUPPORT */

  for (mb_start = beg = start_ptr ? start_ptr : buf; beg <= buf + size; beg++)
    {
      size_t offset = kwsexec (kwset, beg, buf + size - beg, &kwsmatch);
      if (offset == (size_t) -1)
	goto failure;
#ifdef MBS_SUPPORT
      if (MB_CUR_MAX > 1 && is_mb_middle (&mb_start, beg + offset, buf + size))
        {
          beg = mb_start - 1;
          continue; /* It is a part of multibyte character.  */
        }
#endif /* MBS_SUPPORT */
      beg += offset;
      len = kwsmatch.size[0];
      if (start_ptr && !match_words)
	goto success_in_beg_and_len;
      if (match_lines)
	{
	  if (beg > buf && beg[-1] != eol)
	    continue;
	  if (beg + len < buf + size && beg[len] != eol)
	    continue;
	  goto success;
	}
      else if (match_words)
	for (try = beg; len; )
	  {
	    if (try > buf && WCHAR((unsigned char) try[-1]))
	      break;
	    if (try + len < buf + size && WCHAR((unsigned char) try[len]))
	      {
		offset = kwsexec (kwset, beg, --len, &kwsmatch);
		if (offset == (size_t) -1)
		  break;
		try = beg + offset;
		len = kwsmatch.size[0];
	      }
	    else if (!start_ptr)
	      goto success;
	    else
	      goto success_in_beg_and_len;
	  } /* for (try) */
      else
	goto success;
    } /* for (beg in buf) */

 failure:
  ret_val = -1;
  goto out;

 success:
  if ((end = memchr (beg + len, eol, (buf + size) - (beg + len))) != NULL)
    end++;
  else
    end = buf + size;
  while (buf < beg && beg[-1] != eol)
    --beg;
  len = end - beg;
 success_in_beg_and_len:
  *match_size = len;
  ret_val = beg - buf;
 out:
  return ret_val;
}
#endif /* defined(GREP_PROGRAM) || defined(FGREP_PROGRAM) */

#ifdef GREP_PROGRAM
#if HAVE_LIBPCRE
/* Compiled internal form of a Perl regular expression.  */
static pcre *cre;

/* Additional information about the pattern.  */
static pcre_extra *extra;
#endif

COMPILE_FCT(Pcompile)
{
#if !HAVE_LIBPCRE
  error (EXIT_TROUBLE, 0, "%s",
	 _("support for the -P option is not compiled into "
	   "this --disable-perl-regexp binary"));
#else
  int e;
  char const *ep;
  char *re = xmalloc (4 * size + 7);
  int flags = PCRE_MULTILINE | (match_icase ? PCRE_CASELESS : 0);
  char const *patlim = pattern + size;
  char *n = re;
  char const *p;
  char const *pnul;

  /* FIXME: Remove these restrictions.  */
  if (memchr(pattern, '\n', size))
    error (EXIT_TROUBLE, 0, _("the -P option only supports a single pattern"));

  *n = '\0';
  if (match_lines)
    strcpy (n, "^(");
  if (match_words)
    strcpy (n, "\\b(");
  n += strlen (n);

  /* The PCRE interface doesn't allow NUL bytes in the pattern, so
     replace each NUL byte in the pattern with the four characters
     "\000", removing a preceding backslash if there are an odd
     number of backslashes before the NUL.

     FIXME: This method does not work with some multibyte character
     encodings, notably Shift-JIS, where a multibyte character can end
     in a backslash byte.  */
  for (p = pattern; (pnul = memchr (p, '\0', patlim - p)); p = pnul + 1)
    {
      memcpy (n, p, pnul - p);
      n += pnul - p;
      for (p = pnul; pattern < p && p[-1] == '\\'; p--)
	continue;
      n -= (pnul - p) & 1;
      strcpy (n, "\\000");
      n += 4;
    }

  memcpy (n, p, patlim - p);
  n += patlim - p;
  *n = '\0';
  if (match_words)
    strcpy (n, ")\\b");
  if (match_lines)
    strcpy (n, ")$");

  cre = pcre_compile (re, flags, &ep, &e, pcre_maketables ());
  if (!cre)
    error (EXIT_TROUBLE, 0, "%s", ep);

  extra = pcre_study (cre, 0, &ep);
  if (ep)
    error (EXIT_TROUBLE, 0, "%s", ep);

  free (re);
#endif
}

EXECUTE_FCT(Pexecute)
{
#if !HAVE_LIBPCRE
  abort ();
  return -1;
#else
  /* This array must have at least two elements; everything after that
     is just for performance improvement in pcre_exec.  */
  int sub[300];

  const char *line_buf, *line_end, *line_next;
  int e = PCRE_ERROR_NOMATCH;
  ptrdiff_t start_ofs = start_ptr ? start_ptr - buf : 0;

  /* PCRE can't limit the matching to single lines, therefore we have to
     match each line in the buffer separately.  */
  for (line_next = buf;
       e == PCRE_ERROR_NOMATCH && line_next < buf + size;
       start_ofs -= line_next - line_buf)
    {
      line_buf = line_next;
      line_end = memchr (line_buf, eolbyte, (buf + size) - line_buf);
      if (line_end == NULL)
        line_next = line_end = buf + size;
      else
        line_next = line_end + 1;

      if (start_ptr && start_ptr >= line_end)
        continue;

      e = pcre_exec (cre, extra, line_buf, line_end - line_buf,
                     start_ofs < 0 ? 0 : start_ofs, 0,
                     sub, sizeof sub / sizeof *sub);
    }

  if (e <= 0)
    {
      switch (e)
	{
	case PCRE_ERROR_NOMATCH:
	  return -1;

	case PCRE_ERROR_NOMEMORY:
	  error (EXIT_TROUBLE, 0, _("memory exhausted"));

	default:
	  abort ();
	}
    }
  else
    {
      /* Narrow down to the line we've found.  */
      char const *beg = line_buf + sub[0];
      char const *end = line_buf + sub[1];
      char const *buflim = buf + size;
      char eol = eolbyte;
      if (!start_ptr)
	{
	  /* FIXME: The case when '\n' is not found indicates a bug:
	     Since grep is line oriented, the match should never contain
	     a newline, so there _must_ be a newline following.
	   */
	  if (!(end = memchr (end, eol, buflim - end)))
	    end = buflim;
	  else
	    end++;
	  while (buf < beg && beg[-1] != eol)
	    --beg;
	}

      *match_size = end - beg;
      return beg - buf;
    }
#endif
}

struct matcher const matchers[] = {
  { "default", Gcompile, EGexecute },
  { "grep",    Gcompile, EGexecute },
  { "egrep",   Ecompile, EGexecute },
  { "awk",     Acompile, EGexecute },
  { "fgrep",   Fcompile, Fexecute },
  { "perl",    Pcompile, Pexecute },
  { "", 0, 0 },
};
#endif /* GREP_PROGRAM */

Testing negative cases!
Testing 0 (with abstract condition) ENVIS_NEG
Iteration 0
Running test command:
/home/ubuntu/spr-fast/tools/grep-test.py /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-deccad69-db9d6340/tempworkdir2/src /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-deccad69-db9d6340/tempworkdir2/tests /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-deccad69-db9d6340/tempworkdir2 0  > __res
Opening:/home/ubuntu/spr-fast/tests/corebench/grep/grep-case-deccad69-db9d6340/tempworkdir2/neg.tmp!
NegativeBRANCH RECORD/home/ubuntu/spr-fast/tests/corebench/grep/grep-case-deccad69-db9d6340/tempworkdir2/neg.tmp!
APPENDING TO ISNEG:/home/ubuntu/spr-fast/tests/corebench/grep/grep-case-deccad69-db9d6340/tempworkdir2/neg.tmp!
Branch 0: 0
Iteration 1
Running test command:
/home/ubuntu/spr-fast/tools/grep-test.py /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-deccad69-db9d6340/tempworkdir2/src /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-deccad69-db9d6340/tempworkdir2/tests /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-deccad69-db9d6340/tempworkdir2 0  > __res
Opening:/home/ubuntu/spr-fast/tests/corebench/grep/grep-case-deccad69-db9d6340/tempworkdir2/neg.tmp!
NegativeBRANCH RECORD/home/ubuntu/spr-fast/tests/corebench/grep/grep-case-deccad69-db9d6340/tempworkdir2/neg.tmp!
APPENDING TO ISNEG:/home/ubuntu/spr-fast/tests/corebench/grep/grep-case-deccad69-db9d6340/tempworkdir2/neg.tmp!
Branch 0: 1
Running test command:
/home/ubuntu/spr-fast/tools/grep-test.py /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-deccad69-db9d6340/tempworkdir2/src /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-deccad69-db9d6340/tempworkdir2/tests /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-deccad69-db9d6340/tempworkdir2 0  > __res
CondTester, Testing instance id 16:
//src_file:src/search.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
/* search.c - searching subroutines using dfa, kwset and regex for grep.
   Copyright 1992, 1998, 2000, 2007, 2009-2010 Free Software Foundation, Inc.

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 3, or (at your option)
   any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program; if not, write to the Free Software
   Foundation, Inc., 51 Franklin Street - Fifth Floor, Boston, MA
   02110-1301, USA.  */

/* Written August 1992 by Mike Haertel. */

#include <config.h>

#include <sys/types.h>

#include "mbsupport.h"
#ifdef MBS_SUPPORT
/* We can handle multibyte strings. */
# include <wchar.h>
# include <wctype.h>
#endif

#include "system.h"
#include "grep.h"
#ifndef FGREP_PROGRAM
# include <regex.h>
# include "dfa.h"
#endif
#include "kwset.h"
#include "error.h"
#include "xalloc.h"
#ifdef HAVE_LIBPCRE
# include <pcre.h>
#endif

#define NCHAR (UCHAR_MAX + 1)

/* For -w, we also consider _ to be word constituent.  */
#define WCHAR(C) (ISALNUM(C) || (C) == '_')

/* KWset compiled pattern.  For Ecompile and Gcompile, we compile
   a list of strings, at least one of which is known to occur in
   any string matching the regexp. */
static kwset_t kwset;

static void
kwsinit (void)
{
  static char trans[NCHAR];
  int i;

  
//Patch 0:
if (((match_icase) || (__is_neg(3, &(match_icase), sizeof (match_icase), &(i), sizeof (i), &(kwset), sizeof (kwset)))) && (__ctype_get_mb_cur_max()) == 1) {
    for (i = 0; i < ((127 * 2 + 1) + 1); ++i) 
        trans[i] = ((1 && ((*__ctype_b_loc())[(int)((i))] & (unsigned short)_ISupper)) ? (__extension__ ({
            int __res;
            if (sizeof (i) > 1) {
                if (__builtin_constant_p(i)) {
                    int __c = (i);
                    __res = __c < -128 || __c > 255 ? __c : (*__ctype_tolower_loc())[__c];
                } else
                    __res = tolower(i);
            } else
                __res = (*__ctype_tolower_loc())[(int)(i)];
            __res;
        })) : (i));
    kwset = kwsalloc(trans);
} else
    kwset = kwsalloc(((void *)0));

//CodeSeg 1:

  if (!kwset)
    xalloc_die ();
}

#ifdef MBS_SUPPORT
/* Convert the *N-byte string, BEG, to lowercase, and write the
   NUL-terminated result into malloc'd storage.  Upon success, set *N
   to the length (in bytes) of the resulting string (not including the
   trailing NUL byte), and return a pointer to the lowercase string.
   Upon memory allocation failure, this function exits.

   Note that while this function returns a pointer to malloc'd storage,
   the caller must not free it, since this function retains a pointer
   to the buffer and reuses it on any subsequent call.  As a consequence,
   this function is not thread-safe.  */
static char *
mbtolower (const char *beg, size_t *n)
{
  static char *out;
  static size_t outalloc;
  size_t outlen, mb_cur_max;
  mbstate_t is, os;
  const char *end;
  char *p;

  if (*n > outalloc)
    {
      out = xrealloc (out, *n);
      outalloc = *n;
    }

  memset (&is, 0, sizeof (is));
  memset (&os, 0, sizeof (os));
  end = beg + *n;

  mb_cur_max = MB_CUR_MAX;
  p = out;
  outlen = 0;
  while (beg < end)
    {
      wchar_t wc;
      size_t mbclen = mbrtowc(&wc, beg, end - beg, &is);
      if (outlen + mb_cur_max >= outalloc)
        {
          out = x2nrealloc (out, &outalloc, 1);
          p = out + outlen;
        }

      if (mbclen == (size_t) -1 || mbclen == (size_t) -2 || mbclen == 0)
        {
          /* An invalid sequence, or a truncated multi-octet character.
             We treat it as a single-octet character.  */
          *p++ = *beg++;
          outlen++;
          memset (&is, 0, sizeof (is));
          memset (&os, 0, sizeof (os));
        }
      else
        {
          beg += mbclen;
          mbclen = wcrtomb (p, towlower ((wint_t) wc), &os);
          p += mbclen;
          outlen += mbclen;
        }
    }

  *n = p - out;
  *p++ = 0;
  return out;
}
#endif


#ifndef FGREP_PROGRAM
/* DFA compiled regexp. */
static struct dfa dfa;

/* The Regex compiled patterns.  */
static struct patterns
{
  /* Regex compiled regexp. */
  struct re_pattern_buffer regexbuf;
  struct re_registers regs; /* This is here on account of a BRAIN-DEAD
			       Q@#%!# library interface in regex.c.  */
} patterns0;

struct patterns *patterns;
size_t pcount;

void
dfaerror (char const *mesg)
{
  error (EXIT_TROUBLE, 0, "%s", mesg);
}

/* Number of compiled fixed strings known to exactly match the regexp.
   If kwsexec returns < kwset_exact_matches, then we don't need to
   call the regexp matcher at all. */
static int kwset_exact_matches;

static char const *
kwsincr_case (const char *must)
{
  const char *buf;
  size_t n;

  n = strlen (must);
#ifdef MBS_SUPPORT
  if (match_icase && MB_CUR_MAX > 1)
    buf = mbtolower (must, &n);
  else
#endif
    buf = must;
  return kwsincr (kwset, buf, n);
}

/* If the DFA turns out to have some set of fixed strings one of
   which must occur in the match, then we build a kwset matcher
   to find those strings, and thus quickly filter out impossible
   matches. */
static void
kwsmusts (void)
{
  struct dfamust const *dm;
  char const *err;

  if (dfa.musts)
    {
      kwsinit ();
      /* First, we compile in the substrings known to be exact
	 matches.  The kwset matcher will return the index
	 of the matching string that it chooses. */
      for (dm = dfa.musts; dm; dm = dm->next)
	{
	  if (!dm->exact)
	    continue;
	  ++kwset_exact_matches;
	  if ((err = kwsincr_case (dm->must)) != NULL)
	    error (EXIT_TROUBLE, 0, "%s", err);
	}
      /* Now, we compile the substrings that will require
	 the use of the regexp matcher.  */
      for (dm = dfa.musts; dm; dm = dm->next)
	{
	  if (dm->exact)
	    continue;
	  if ((err = kwsincr_case (dm->must)) != NULL)
	    error (EXIT_TROUBLE, 0, "%s", err);
	}
      if ((err = kwsprep (kwset)) != NULL)
	error (EXIT_TROUBLE, 0, "%s", err);
    }
}
#endif /* !FGREP_PROGRAM */

#ifdef MBS_SUPPORT

static bool
is_mb_middle(const char **good, const char *buf, const char *end)
{
  const char *p = *good;
  const char *prev = p;
  mbstate_t cur_state;

  /* TODO: can be optimized for UTF-8.  */
  memset(&cur_state, 0, sizeof(mbstate_t));
  while (p < buf)
    {
      size_t mbclen = mbrlen(p, end - p, &cur_state);

      /* Store the beginning of the previous complete multibyte character.  */
      if (mbclen != (size_t) -2)
        prev = p;

      if (mbclen == (size_t) -1 || mbclen == (size_t) -2 || mbclen == 0)
	{
	  /* An invalid sequence, or a truncated multibyte character.
	     We treat it as a single byte character.  */
	  mbclen = 1;
	}
      p += mbclen;
    }

  *good = prev;
  return p > buf;
}
#endif /* MBS_SUPPORT */

#if defined(GREP_PROGRAM) || defined(EGREP_PROGRAM)
#ifdef EGREP_PROGRAM
COMPILE_FCT(Ecompile)
{
  reg_syntax_t syntax_bits = RE_SYNTAX_POSIX_EGREP;
#else
/* No __VA_ARGS__ in C89.  So we have to do it this way.  */
static COMPILE_RET
GEAcompile (char const *pattern, size_t size, reg_syntax_t syntax_bits)
{
#endif /* EGREP_PROGRAM */
  const char *err;
  const char *p, *sep;
  size_t total = size;
  char *motif;

  if (match_icase)
    syntax_bits |= RE_ICASE;
  re_set_syntax (syntax_bits);
  dfasyntax (syntax_bits, match_icase, eolbyte);

  /* For GNU regex compiler we have to pass the patterns separately to detect
     errors like "[\nallo\n]\n".  The patterns here are "[", "allo" and "]"
     GNU regex should have raise a syntax error.  The same for backref, where
     the backref should have been local to each pattern.  */
  p = pattern;
  do
    {
      size_t len;
      sep = memchr (p, '\n', total);
      if (sep)
	{
	  len = sep - p;
	  sep++;
	  total -= (len + 1);
	}
      else
	{
	  len = total;
	  total = 0;
	}

      patterns = realloc (patterns, (pcount + 1) * sizeof (*patterns));
      if (patterns == NULL)
	error (EXIT_TROUBLE, errno, _("memory exhausted"));
      patterns[pcount] = patterns0;

      if ((err = re_compile_pattern (p, len,
				    &(patterns[pcount].regexbuf))) != NULL)
	error (EXIT_TROUBLE, 0, "%s", err);
      pcount++;

      p = sep;
    } while (sep && total != 0);

  /* In the match_words and match_lines cases, we use a different pattern
     for the DFA matcher that will quickly throw out cases that won't work.
     Then if DFA succeeds we do some hairy stuff using the regex matcher
     to decide whether the match should really count. */
  if (match_words || match_lines)
    {
      static char const line_beg_no_bk[] = "^(";
      static char const line_end_no_bk[] = ")$";
      static char const word_beg_no_bk[] = "(^|[^[:alnum:]_])(";
      static char const word_end_no_bk[] = ")([^[:alnum:]_]|$)";
#ifdef EGREP_PROGRAM
# define IF_BK(x, y) (y)
      char *n = xmalloc (sizeof word_beg_no_bk - 1 + size + sizeof word_end_no_bk);
#else
      static char const line_beg_bk[] = "^\\(";
      static char const line_end_bk[] = "\\)$";
      static char const word_beg_bk[] = "\\(^\\|[^[:alnum:]_]\\)\\(";
      static char const word_end_bk[] = "\\)\\([^[:alnum:]_]\\|$\\)";
      int bk = !(syntax_bits & RE_NO_BK_PARENS);
# define IF_BK(x, y) ((bk) ? (x) : (y))
      char *n = xmalloc (sizeof word_beg_bk - 1 + size + sizeof word_end_bk);
#endif /* EGREP_PROGRAM */

      strcpy (n, match_lines ? IF_BK(line_beg_bk, line_beg_no_bk)
			     : IF_BK(word_beg_bk, word_beg_no_bk));
      total = strlen(n);
      memcpy (n + total, pattern, size);
      total += size;
      strcpy (n + total, match_lines ? IF_BK(line_end_bk, line_end_no_bk)
				     : IF_BK(word_end_bk, word_end_no_bk));
      total += strlen (n + total);
      pattern = motif = n;
      size = total;
    }
  else
    motif = NULL;

  dfacomp (pattern, size, &dfa, 1);
  kwsmusts ();

  free(motif);
}

#ifndef EGREP_PROGRAM
COMPILE_FCT(Gcompile)
{
  return GEAcompile (pattern, size,
		     RE_SYNTAX_GREP | RE_HAT_LISTS_NOT_NEWLINE);
}

COMPILE_FCT(Acompile)
{
  return GEAcompile (pattern, size, RE_SYNTAX_AWK);
}

COMPILE_FCT(Ecompile)
{
  return GEAcompile (pattern, size, RE_SYNTAX_POSIX_EGREP);
}
#endif /* !EGREP_PROGRAM */

EXECUTE_FCT(EGexecute)
{
  char const *buflim, *beg, *end, *match, *best_match, *mb_start;
  char eol = eolbyte;
  int backref, start, len, best_len;
  struct kwsmatch kwsm;
  size_t i, ret_val;
#ifdef MBS_SUPPORT
  if (MB_CUR_MAX > 1)
    {
      if (match_icase)
        {
          /* mbtolower adds a NUL byte at the end.  That will provide
	     space for the sentinel byte dfaexec may add.  */
          char *case_buf = mbtolower (buf, &size);
	  if (start_ptr)
	    start_ptr = case_buf + (start_ptr - buf);
          buf = case_buf;
        }
    }
#endif /* MBS_SUPPORT */

  mb_start = buf;
  buflim = buf + size;

  for (beg = end = buf; end < buflim; beg = end)
    {
      if (!start_ptr)
	{
	  /* We don't care about an exact match.  */
	  if (kwset)
	    {
	      /* Find a possible match using the KWset matcher. */
	      size_t offset = kwsexec (kwset, beg, buflim - beg, &kwsm);
	      if (offset == (size_t) -1)
		goto failure;
	      beg += offset;
	      /* Narrow down to the line containing the candidate, and
		 run it through DFA. */
	      if ((end = memchr(beg, eol, buflim - beg)) != NULL)
	        end++;
              else
                end = buflim;
	      match = beg;
	      while (beg > buf && beg[-1] != eol)
		--beg;
	      if (kwsm.index < kwset_exact_matches)
                {
#ifdef MBS_SUPPORT
                  if (mb_start < beg)
                    mb_start = beg;
                  if (MB_CUR_MAX == 1 || !is_mb_middle (&mb_start, match, buflim))
#endif
                    goto success;
                }
	      if (dfaexec (&dfa, beg, (char *) end, 0, NULL, &backref) == NULL)
		continue;
	    }
	  else
	    {
	      /* No good fixed strings; start with DFA. */
	      char const *next_beg = dfaexec (&dfa, beg, (char *) buflim,
					      0, NULL, &backref);
	      if (next_beg == NULL)
		break;
	      /* Narrow down to the line we've found. */
	      beg = next_beg;
	      if ((end = memchr(beg, eol, buflim - beg)) != NULL)
	        end++;
              else
                end = buflim;
	      while (beg > buf && beg[-1] != eol)
		--beg;
	    }
	  /* Successful, no backreferences encountered! */
	  if (!backref)
	    goto success;
	}
      else
	{
	  /* We are looking for the leftmost (then longest) exact match.
	     We will go through the outer loop only once.  */
	  beg = start_ptr;
	  end = buflim;
	}

      /* If we've made it to this point, this means DFA has seen
	 a probable match, and we need to run it through Regex. */
      best_match = end;
      best_len = 0;
      for (i = 0; i < pcount; i++)
	{
	  patterns[i].regexbuf.not_eol = 0;
	  if (0 <= (start = re_search (&(patterns[i].regexbuf),
				       buf, end - buf - 1,
				       beg - buf, end - beg - 1,
				       &(patterns[i].regs))))
	    {
	      len = patterns[i].regs.end[0] - start;
	      match = buf + start;
	      if (match > best_match)
		continue;
	      if (start_ptr && !match_words)
		goto assess_pattern_match;
	      if ((!match_lines && !match_words)
		  || (match_lines && len == end - beg - 1))
		{
		  match = beg;
		  len = end - beg;
		  goto assess_pattern_match;
		}
	      /* If -w, check if the match aligns with word boundaries.
		 We do this iteratively because:
		 (a) the line may contain more than one occurence of the
		 pattern, and
		 (b) Several alternatives in the pattern might be valid at a
		 given point, and we may need to consider a shorter one to
		 find a word boundary.  */
	      if (match_words)
		while (match <= best_match)
		  {
		    if ((match == buf || !WCHAR ((unsigned char) match[-1]))
			&& (len == end - beg - 1
			    || !WCHAR ((unsigned char) match[len])))
		      goto assess_pattern_match;
		    if (len > 0)
		      {
			/* Try a shorter length anchored at the same place. */
			--len;
			patterns[i].regexbuf.not_eol = 1;
			len = re_match (&(patterns[i].regexbuf),
					buf, match + len - beg, match - buf,
					&(patterns[i].regs));
		      }
		    if (len <= 0)
		      {
			/* Try looking further on. */
			if (match == end - 1)
			  break;
			match++;
			patterns[i].regexbuf.not_eol = 0;
			start = re_search (&(patterns[i].regexbuf),
					   buf, end - buf - 1,
					   match - buf, end - match - 1,
					   &(patterns[i].regs));
			if (start < 0)
			  break;
			len = patterns[i].regs.end[0] - start;
			match = buf + start;
		      }
		  } /* while (match <= best_match) */
	      continue;
	    assess_pattern_match:
	      if (!start_ptr)
		{
		  /* Good enough for a non-exact match.
		     No need to look at further patterns, if any.  */
		  beg = match;
		  goto success_in_len;
		}
	      if (match < best_match || (match == best_match && len > best_len))
		{
		  /* Best exact match:  leftmost, then longest.  */
		  best_match = match;
		  best_len = len;
		}
	    } /* if re_search >= 0 */
	} /* for Regex patterns.  */
	if (best_match < end)
	  {
	    /* We have found an exact match.  We were just
	       waiting for the best one (leftmost then longest).  */
	    beg = best_match;
	    len = best_len;
	    goto success_in_len;
	  }
    } /* for (beg = end ..) */

 failure:
  ret_val = -1;
  goto out;

 success:
  len = end - beg;
 success_in_len:
  *match_size = len;
  ret_val = beg - buf;
 out:
  return ret_val;
}
#endif /* defined(GREP_PROGRAM) || defined(EGREP_PROGRAM) */

#if defined(GREP_PROGRAM) || defined(FGREP_PROGRAM)
COMPILE_FCT(Fcompile)
{
  char const *beg, *end, *lim, *err, *pat;
  size_t psize;

  kwsinit ();
  psize = size;
  if (match_icase && MB_CUR_MAX > 1)
    pat = mbtolower (pattern, &psize);
  else
    pat = pattern;

  beg = pat;
  do
    {
      for (lim = beg;; ++lim)
	{
	  end = lim;
	  if (lim >= pat + psize)
	    break;
	 if (*lim == '\n')
	   {
	     lim++;
	     break;
	   }
#if HAVE_DOS_FILE_CONTENTS
	 if (*lim == '\r' && lim + 1 < pat + psize && lim[1] == '\n')
	   {
	     lim += 2;
	     break;
	   }
#endif
	}

      if ((err = kwsincr (kwset, beg, end - beg)) != NULL)
	error (EXIT_TROUBLE, 0, "%s", err);
      beg = lim;
    }
  while (beg < pat + psize);

  if ((err = kwsprep (kwset)) != NULL)
    error (EXIT_TROUBLE, 0, "%s", err);
}

EXECUTE_FCT(Fexecute)
{
  char const *beg, *try, *end, *mb_start;
  size_t len;
  char eol = eolbyte;
  struct kwsmatch kwsmatch;
  size_t ret_val;
#ifdef MBS_SUPPORT
  if (MB_CUR_MAX > 1)
    {
      if (match_icase)
        {
          char *case_buf = mbtolower (buf, &size);
	  if (start_ptr)
	    start_ptr = case_buf + (start_ptr - buf);
          buf = case_buf;
        }
    }
#endif /* MBS_SUPPORT */

  for (mb_start = beg = start_ptr ? start_ptr : buf; beg <= buf + size; beg++)
    {
      size_t offset = kwsexec (kwset, beg, buf + size - beg, &kwsmatch);
      if (offset == (size_t) -1)
	goto failure;
#ifdef MBS_SUPPORT
      if (MB_CUR_MAX > 1 && is_mb_middle (&mb_start, beg + offset, buf + size))
        {
          beg = mb_start - 1;
          continue; /* It is a part of multibyte character.  */
        }
#endif /* MBS_SUPPORT */
      beg += offset;
      len = kwsmatch.size[0];
      if (start_ptr && !match_words)
	goto success_in_beg_and_len;
      if (match_lines)
	{
	  if (beg > buf && beg[-1] != eol)
	    continue;
	  if (beg + len < buf + size && beg[len] != eol)
	    continue;
	  goto success;
	}
      else if (match_words)
	for (try = beg; len; )
	  {
	    if (try > buf && WCHAR((unsigned char) try[-1]))
	      break;
	    if (try + len < buf + size && WCHAR((unsigned char) try[len]))
	      {
		offset = kwsexec (kwset, beg, --len, &kwsmatch);
		if (offset == (size_t) -1)
		  break;
		try = beg + offset;
		len = kwsmatch.size[0];
	      }
	    else if (!start_ptr)
	      goto success;
	    else
	      goto success_in_beg_and_len;
	  } /* for (try) */
      else
	goto success;
    } /* for (beg in buf) */

 failure:
  ret_val = -1;
  goto out;

 success:
  if ((end = memchr (beg + len, eol, (buf + size) - (beg + len))) != NULL)
    end++;
  else
    end = buf + size;
  while (buf < beg && beg[-1] != eol)
    --beg;
  len = end - beg;
 success_in_beg_and_len:
  *match_size = len;
  ret_val = beg - buf;
 out:
  return ret_val;
}
#endif /* defined(GREP_PROGRAM) || defined(FGREP_PROGRAM) */

#ifdef GREP_PROGRAM
#if HAVE_LIBPCRE
/* Compiled internal form of a Perl regular expression.  */
static pcre *cre;

/* Additional information about the pattern.  */
static pcre_extra *extra;
#endif

COMPILE_FCT(Pcompile)
{
#if !HAVE_LIBPCRE
  error (EXIT_TROUBLE, 0, "%s",
	 _("support for the -P option is not compiled into "
	   "this --disable-perl-regexp binary"));
#else
  int e;
  char const *ep;
  char *re = xmalloc (4 * size + 7);
  int flags = PCRE_MULTILINE | (match_icase ? PCRE_CASELESS : 0);
  char const *patlim = pattern + size;
  char *n = re;
  char const *p;
  char const *pnul;

  /* FIXME: Remove these restrictions.  */
  if (memchr(pattern, '\n', size))
    error (EXIT_TROUBLE, 0, _("the -P option only supports a single pattern"));

  *n = '\0';
  if (match_lines)
    strcpy (n, "^(");
  if (match_words)
    strcpy (n, "\\b(");
  n += strlen (n);

  /* The PCRE interface doesn't allow NUL bytes in the pattern, so
     replace each NUL byte in the pattern with the four characters
     "\000", removing a preceding backslash if there are an odd
     number of backslashes before the NUL.

     FIXME: This method does not work with some multibyte character
     encodings, notably Shift-JIS, where a multibyte character can end
     in a backslash byte.  */
  for (p = pattern; (pnul = memchr (p, '\0', patlim - p)); p = pnul + 1)
    {
      memcpy (n, p, pnul - p);
      n += pnul - p;
      for (p = pnul; pattern < p && p[-1] == '\\'; p--)
	continue;
      n -= (pnul - p) & 1;
      strcpy (n, "\\000");
      n += 4;
    }

  memcpy (n, p, patlim - p);
  n += patlim - p;
  *n = '\0';
  if (match_words)
    strcpy (n, ")\\b");
  if (match_lines)
    strcpy (n, ")$");

  cre = pcre_compile (re, flags, &ep, &e, pcre_maketables ());
  if (!cre)
    error (EXIT_TROUBLE, 0, "%s", ep);

  extra = pcre_study (cre, 0, &ep);
  if (ep)
    error (EXIT_TROUBLE, 0, "%s", ep);

  free (re);
#endif
}

EXECUTE_FCT(Pexecute)
{
#if !HAVE_LIBPCRE
  abort ();
  return -1;
#else
  /* This array must have at least two elements; everything after that
     is just for performance improvement in pcre_exec.  */
  int sub[300];

  const char *line_buf, *line_end, *line_next;
  int e = PCRE_ERROR_NOMATCH;
  ptrdiff_t start_ofs = start_ptr ? start_ptr - buf : 0;

  /* PCRE can't limit the matching to single lines, therefore we have to
     match each line in the buffer separately.  */
  for (line_next = buf;
       e == PCRE_ERROR_NOMATCH && line_next < buf + size;
       start_ofs -= line_next - line_buf)
    {
      line_buf = line_next;
      line_end = memchr (line_buf, eolbyte, (buf + size) - line_buf);
      if (line_end == NULL)
        line_next = line_end = buf + size;
      else
        line_next = line_end + 1;

      if (start_ptr && start_ptr >= line_end)
        continue;

      e = pcre_exec (cre, extra, line_buf, line_end - line_buf,
                     start_ofs < 0 ? 0 : start_ofs, 0,
                     sub, sizeof sub / sizeof *sub);
    }

  if (e <= 0)
    {
      switch (e)
	{
	case PCRE_ERROR_NOMATCH:
	  return -1;

	case PCRE_ERROR_NOMEMORY:
	  error (EXIT_TROUBLE, 0, _("memory exhausted"));

	default:
	  abort ();
	}
    }
  else
    {
      /* Narrow down to the line we've found.  */
      char const *beg = line_buf + sub[0];
      char const *end = line_buf + sub[1];
      char const *buflim = buf + size;
      char eol = eolbyte;
      if (!start_ptr)
	{
	  /* FIXME: The case when '\n' is not found indicates a bug:
	     Since grep is line oriented, the match should never contain
	     a newline, so there _must_ be a newline following.
	   */
	  if (!(end = memchr (end, eol, buflim - end)))
	    end = buflim;
	  else
	    end++;
	  while (buf < beg && beg[-1] != eol)
	    --beg;
	}

      *match_size = end - beg;
      return beg - buf;
    }
#endif
}

struct matcher const matchers[] = {
  { "default", Gcompile, EGexecute },
  { "grep",    Gcompile, EGexecute },
  { "egrep",   Ecompile, EGexecute },
  { "awk",     Acompile, EGexecute },
  { "fgrep",   Fcompile, Fexecute },
  { "perl",    Pcompile, Pexecute },
  { "", 0, 0 },
};
#endif /* GREP_PROGRAM */

Testing negative cases!
Testing 0 (with abstract condition) ENVIS_NEG
Iteration 0
Running test command:
/home/ubuntu/spr-fast/tools/grep-test.py /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-deccad69-db9d6340/tempworkdir2/src /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-deccad69-db9d6340/tempworkdir2/tests /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-deccad69-db9d6340/tempworkdir2 0  > __res
Opening:/home/ubuntu/spr-fast/tests/corebench/grep/grep-case-deccad69-db9d6340/tempworkdir2/neg.tmp!
NegativeBRANCH RECORD/home/ubuntu/spr-fast/tests/corebench/grep/grep-case-deccad69-db9d6340/tempworkdir2/neg.tmp!
APPENDING TO ISNEG:/home/ubuntu/spr-fast/tests/corebench/grep/grep-case-deccad69-db9d6340/tempworkdir2/neg.tmp!
Branch 0: 0
Iteration 1
Running test command:
/home/ubuntu/spr-fast/tools/grep-test.py /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-deccad69-db9d6340/tempworkdir2/src /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-deccad69-db9d6340/tempworkdir2/tests /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-deccad69-db9d6340/tempworkdir2 0  > __res
Opening:/home/ubuntu/spr-fast/tests/corebench/grep/grep-case-deccad69-db9d6340/tempworkdir2/neg.tmp!
NegativeBRANCH RECORD/home/ubuntu/spr-fast/tests/corebench/grep/grep-case-deccad69-db9d6340/tempworkdir2/neg.tmp!
APPENDING TO ISNEG:/home/ubuntu/spr-fast/tests/corebench/grep/grep-case-deccad69-db9d6340/tempworkdir2/neg.tmp!
Branch 0: 1
Running test command:
/home/ubuntu/spr-fast/tools/grep-test.py /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-deccad69-db9d6340/tempworkdir2/src /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-deccad69-db9d6340/tempworkdir2/tests /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-deccad69-db9d6340/tempworkdir2 0  > __res
a batched test job starts!
Building merged code:
src_file: src/search.c
full src: int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
/* search.c - searching subroutines using dfa, kwset and regex for grep.
   Copyright 1992, 1998, 2000, 2007, 2009-2010 Free Software Foundation, Inc.

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 3, or (at your option)
   any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program; if not, write to the Free Software
   Foundation, Inc., 51 Franklin Street - Fifth Floor, Boston, MA
   02110-1301, USA.  */

/* Written August 1992 by Mike Haertel. */

#include <config.h>

#include <sys/types.h>

#include "mbsupport.h"
#ifdef MBS_SUPPORT
/* We can handle multibyte strings. */
# include <wchar.h>
# include <wctype.h>
#endif

#include "system.h"
#include "grep.h"
#ifndef FGREP_PROGRAM
# include <regex.h>
# include "dfa.h"
#endif
#include "kwset.h"
#include "error.h"
#include "xalloc.h"
#ifdef HAVE_LIBPCRE
# include <pcre.h>
#endif

#define NCHAR (UCHAR_MAX + 1)

/* For -w, we also consider _ to be word constituent.  */
#define WCHAR(C) (ISALNUM(C) || (C) == '_')

/* KWset compiled pattern.  For Ecompile and Gcompile, we compile
   a list of strings, at least one of which is known to occur in
   any string matching the regexp. */
static kwset_t kwset;

static void
kwsinit (void)
{
  static char trans[NCHAR];
  int i;

  if (match_icase && MB_CUR_MAX == 1)
    {
      for (i = 0; i < NCHAR; ++i)
        trans[i] = TOLOWER (i);

      kwset = kwsalloc (trans);
    }
  else
    kwset = kwsalloc (NULL);

  //prophet generated patch
  if (__get_mutant()==0) {
  if ((!kwset) && !(__is_neg(3, &(kwset), sizeof (kwset), &(i), sizeof (i), &(match_icase), sizeof (match_icase))))
      xalloc_die();
  }
  else if (__get_mutant()==1) {
  if ((!kwset) || (__is_neg(3, &(kwset), sizeof (kwset), &(i), sizeof (i), &(match_icase), sizeof (match_icase))))
      xalloc_die();
  }
}

#ifdef MBS_SUPPORT
/* Convert the *N-byte string, BEG, to lowercase, and write the
   NUL-terminated result into malloc'd storage.  Upon success, set *N
   to the length (in bytes) of the resulting string (not including the
   trailing NUL byte), and return a pointer to the lowercase string.
   Upon memory allocation failure, this function exits.

   Note that while this function returns a pointer to malloc'd storage,
   the caller must not free it, since this function retains a pointer
   to the buffer and reuses it on any subsequent call.  As a consequence,
   this function is not thread-safe.  */
static char *
mbtolower (const char *beg, size_t *n)
{
  static char *out;
  static size_t outalloc;
  size_t outlen, mb_cur_max;
  mbstate_t is, os;
  const char *end;
  char *p;

  if (*n > outalloc)
    {
      out = xrealloc (out, *n);
      outalloc = *n;
    }

  memset (&is, 0, sizeof (is));
  memset (&os, 0, sizeof (os));
  end = beg + *n;

  mb_cur_max = MB_CUR_MAX;
  p = out;
  outlen = 0;
  while (beg < end)
    {
      wchar_t wc;
      size_t mbclen = mbrtowc(&wc, beg, end - beg, &is);
      if (outlen + mb_cur_max >= outalloc)
        {
          out = x2nrealloc (out, &outalloc, 1);
          p = out + outlen;
        }

      if (mbclen == (size_t) -1 || mbclen == (size_t) -2 || mbclen == 0)
        {
          /* An invalid sequence, or a truncated multi-octet character.
             We treat it as a single-octet character.  */
          *p++ = *beg++;
          outlen++;
          memset (&is, 0, sizeof (is));
          memset (&os, 0, sizeof (os));
        }
      else
        {
          beg += mbclen;
          mbclen = wcrtomb (p, towlower ((wint_t) wc), &os);
          p += mbclen;
          outlen += mbclen;
        }
    }

  *n = p - out;
  *p++ = 0;
  return out;
}
#endif


#ifndef FGREP_PROGRAM
/* DFA compiled regexp. */
static struct dfa dfa;

/* The Regex compiled patterns.  */
static struct patterns
{
  /* Regex compiled regexp. */
  struct re_pattern_buffer regexbuf;
  struct re_registers regs; /* This is here on account of a BRAIN-DEAD
			       Q@#%!# library interface in regex.c.  */
} patterns0;

struct patterns *patterns;
size_t pcount;

void
dfaerror (char const *mesg)
{
  error (EXIT_TROUBLE, 0, "%s", mesg);
}

/* Number of compiled fixed strings known to exactly match the regexp.
   If kwsexec returns < kwset_exact_matches, then we don't need to
   call the regexp matcher at all. */
static int kwset_exact_matches;

static char const *
kwsincr_case (const char *must)
{
  const char *buf;
  size_t n;

  n = strlen (must);
#ifdef MBS_SUPPORT
  if (match_icase && MB_CUR_MAX > 1)
    buf = mbtolower (must, &n);
  else
#endif
    buf = must;
  return kwsincr (kwset, buf, n);
}

/* If the DFA turns out to have some set of fixed strings one of
   which must occur in the match, then we build a kwset matcher
   to find those strings, and thus quickly filter out impossible
   matches. */
static void
kwsmusts (void)
{
  struct dfamust const *dm;
  char const *err;

  if (dfa.musts)
    {
      kwsinit ();
      /* First, we compile in the substrings known to be exact
	 matches.  The kwset matcher will return the index
	 of the matching string that it chooses. */
      for (dm = dfa.musts; dm; dm = dm->next)
	{
	  if (!dm->exact)
	    continue;
	  ++kwset_exact_matches;
	  if ((err = kwsincr_case (dm->must)) != NULL)
	    error (EXIT_TROUBLE, 0, "%s", err);
	}
      /* Now, we compile the substrings that will require
	 the use of the regexp matcher.  */
      for (dm = dfa.musts; dm; dm = dm->next)
	{
	  if (dm->exact)
	    continue;
	  if ((err = kwsincr_case (dm->must)) != NULL)
	    error (EXIT_TROUBLE, 0, "%s", err);
	}
      if ((err = kwsprep (kwset)) != NULL)
	error (EXIT_TROUBLE, 0, "%s", err);
    }
}
#endif /* !FGREP_PROGRAM */

#ifdef MBS_SUPPORT

static bool
is_mb_middle(const char **good, const char *buf, const char *end)
{
  const char *p = *good;
  const char *prev = p;
  mbstate_t cur_state;

  /* TODO: can be optimized for UTF-8.  */
  memset(&cur_state, 0, sizeof(mbstate_t));
  while (p < buf)
    {
      size_t mbclen = mbrlen(p, end - p, &cur_state);

      /* Store the beginning of the previous complete multibyte character.  */
      if (mbclen != (size_t) -2)
        prev = p;

      if (mbclen == (size_t) -1 || mbclen == (size_t) -2 || mbclen == 0)
	{
	  /* An invalid sequence, or a truncated multibyte character.
	     We treat it as a single byte character.  */
	  mbclen = 1;
	}
      p += mbclen;
    }

  *good = prev;
  return p > buf;
}
#endif /* MBS_SUPPORT */

#if defined(GREP_PROGRAM) || defined(EGREP_PROGRAM)
#ifdef EGREP_PROGRAM
COMPILE_FCT(Ecompile)
{
  reg_syntax_t syntax_bits = RE_SYNTAX_POSIX_EGREP;
#else
/* No __VA_ARGS__ in C89.  So we have to do it this way.  */
static COMPILE_RET
GEAcompile (char const *pattern, size_t size, reg_syntax_t syntax_bits)
{
#endif /* EGREP_PROGRAM */
  const char *err;
  const char *p, *sep;
  size_t total = size;
  char *motif;

  if (match_icase)
    syntax_bits |= RE_ICASE;
  re_set_syntax (syntax_bits);
  dfasyntax (syntax_bits, match_icase, eolbyte);

  /* For GNU regex compiler we have to pass the patterns separately to detect
     errors like "[\nallo\n]\n".  The patterns here are "[", "allo" and "]"
     GNU regex should have raise a syntax error.  The same for backref, where
     the backref should have been local to each pattern.  */
  p = pattern;
  do
    {
      size_t len;
      sep = memchr (p, '\n', total);
      if (sep)
	{
	  len = sep - p;
	  sep++;
	  total -= (len + 1);
	}
      else
	{
	  len = total;
	  total = 0;
	}

      patterns = realloc (patterns, (pcount + 1) * sizeof (*patterns));
      if (patterns == NULL)
	error (EXIT_TROUBLE, errno, _("memory exhausted"));
      patterns[pcount] = patterns0;

      if ((err = re_compile_pattern (p, len,
				    &(patterns[pcount].regexbuf))) != NULL)
	error (EXIT_TROUBLE, 0, "%s", err);
      pcount++;

      p = sep;
    } while (sep && total != 0);

  /* In the match_words and match_lines cases, we use a different pattern
     for the DFA matcher that will quickly throw out cases that won't work.
     Then if DFA succeeds we do some hairy stuff using the regex matcher
     to decide whether the match should really count. */
  if (match_words || match_lines)
    {
      static char const line_beg_no_bk[] = "^(";
      static char const line_end_no_bk[] = ")$";
      static char const word_beg_no_bk[] = "(^|[^[:alnum:]_])(";
      static char const word_end_no_bk[] = ")([^[:alnum:]_]|$)";
#ifdef EGREP_PROGRAM
# define IF_BK(x, y) (y)
      char *n = xmalloc (sizeof word_beg_no_bk - 1 + size + sizeof word_end_no_bk);
#else
      static char const line_beg_bk[] = "^\\(";
      static char const line_end_bk[] = "\\)$";
      static char const word_beg_bk[] = "\\(^\\|[^[:alnum:]_]\\)\\(";
      static char const word_end_bk[] = "\\)\\([^[:alnum:]_]\\|$\\)";
      int bk = !(syntax_bits & RE_NO_BK_PARENS);
# define IF_BK(x, y) ((bk) ? (x) : (y))
      char *n = xmalloc (sizeof word_beg_bk - 1 + size + sizeof word_end_bk);
#endif /* EGREP_PROGRAM */

      strcpy (n, match_lines ? IF_BK(line_beg_bk, line_beg_no_bk)
			     : IF_BK(word_beg_bk, word_beg_no_bk));
      total = strlen(n);
      memcpy (n + total, pattern, size);
      total += size;
      strcpy (n + total, match_lines ? IF_BK(line_end_bk, line_end_no_bk)
				     : IF_BK(word_end_bk, word_end_no_bk));
      total += strlen (n + total);
      pattern = motif = n;
      size = total;
    }
  else
    motif = NULL;

  dfacomp (pattern, size, &dfa, 1);
  kwsmusts ();

  free(motif);
}

#ifndef EGREP_PROGRAM
COMPILE_FCT(Gcompile)
{
  return GEAcompile (pattern, size,
		     RE_SYNTAX_GREP | RE_HAT_LISTS_NOT_NEWLINE);
}

COMPILE_FCT(Acompile)
{
  return GEAcompile (pattern, size, RE_SYNTAX_AWK);
}

COMPILE_FCT(Ecompile)
{
  return GEAcompile (pattern, size, RE_SYNTAX_POSIX_EGREP);
}
#endif /* !EGREP_PROGRAM */

EXECUTE_FCT(EGexecute)
{
  char const *buflim, *beg, *end, *match, *best_match, *mb_start;
  char eol = eolbyte;
  int backref, start, len, best_len;
  struct kwsmatch kwsm;
  size_t i, ret_val;
#ifdef MBS_SUPPORT
  if (MB_CUR_MAX > 1)
    {
      if (match_icase)
        {
          /* mbtolower adds a NUL byte at the end.  That will provide
	     space for the sentinel byte dfaexec may add.  */
          char *case_buf = mbtolower (buf, &size);
	  if (start_ptr)
	    start_ptr = case_buf + (start_ptr - buf);
          buf = case_buf;
        }
    }
#endif /* MBS_SUPPORT */

  mb_start = buf;
  buflim = buf + size;

  for (beg = end = buf; end < buflim; beg = end)
    {
      if (!start_ptr)
	{
	  /* We don't care about an exact match.  */
	  if (kwset)
	    {
	      /* Find a possible match using the KWset matcher. */
	      size_t offset = kwsexec (kwset, beg, buflim - beg, &kwsm);
	      if (offset == (size_t) -1)
		goto failure;
	      beg += offset;
	      /* Narrow down to the line containing the candidate, and
		 run it through DFA. */
	      if ((end = memchr(beg, eol, buflim - beg)) != NULL)
	        end++;
              else
                end = buflim;
	      match = beg;
	      while (beg > buf && beg[-1] != eol)
		--beg;
	      if (kwsm.index < kwset_exact_matches)
                {
#ifdef MBS_SUPPORT
                  if (mb_start < beg)
                    mb_start = beg;
                  if (MB_CUR_MAX == 1 || !is_mb_middle (&mb_start, match, buflim))
#endif
                    goto success;
                }
	      if (dfaexec (&dfa, beg, (char *) end, 0, NULL, &backref) == NULL)
		continue;
	    }
	  else
	    {
	      /* No good fixed strings; start with DFA. */
	      char const *next_beg = dfaexec (&dfa, beg, (char *) buflim,
					      0, NULL, &backref);
	      if (next_beg == NULL)
		break;
	      /* Narrow down to the line we've found. */
	      beg = next_beg;
	      if ((end = memchr(beg, eol, buflim - beg)) != NULL)
	        end++;
              else
                end = buflim;
	      while (beg > buf && beg[-1] != eol)
		--beg;
	    }
	  /* Successful, no backreferences encountered! */
	  if (!backref)
	    goto success;
	}
      else
	{
	  /* We are looking for the leftmost (then longest) exact match.
	     We will go through the outer loop only once.  */
	  beg = start_ptr;
	  end = buflim;
	}

      /* If we've made it to this point, this means DFA has seen
	 a probable match, and we need to run it through Regex. */
      best_match = end;
      best_len = 0;
      for (i = 0; i < pcount; i++)
	{
	  patterns[i].regexbuf.not_eol = 0;
	  if (0 <= (start = re_search (&(patterns[i].regexbuf),
				       buf, end - buf - 1,
				       beg - buf, end - beg - 1,
				       &(patterns[i].regs))))
	    {
	      len = patterns[i].regs.end[0] - start;
	      match = buf + start;
	      if (match > best_match)
		continue;
	      if (start_ptr && !match_words)
		goto assess_pattern_match;
	      if ((!match_lines && !match_words)
		  || (match_lines && len == end - beg - 1))
		{
		  match = beg;
		  len = end - beg;
		  goto assess_pattern_match;
		}
	      /* If -w, check if the match aligns with word boundaries.
		 We do this iteratively because:
		 (a) the line may contain more than one occurence of the
		 pattern, and
		 (b) Several alternatives in the pattern might be valid at a
		 given point, and we may need to consider a shorter one to
		 find a word boundary.  */
	      if (match_words)
		while (match <= best_match)
		  {
		    if ((match == buf || !WCHAR ((unsigned char) match[-1]))
			&& (len == end - beg - 1
			    || !WCHAR ((unsigned char) match[len])))
		      goto assess_pattern_match;
		    if (len > 0)
		      {
			/* Try a shorter length anchored at the same place. */
			--len;
			patterns[i].regexbuf.not_eol = 1;
			len = re_match (&(patterns[i].regexbuf),
					buf, match + len - beg, match - buf,
					&(patterns[i].regs));
		      }
		    if (len <= 0)
		      {
			/* Try looking further on. */
			if (match == end - 1)
			  break;
			match++;
			patterns[i].regexbuf.not_eol = 0;
			start = re_search (&(patterns[i].regexbuf),
					   buf, end - buf - 1,
					   match - buf, end - match - 1,
					   &(patterns[i].regs));
			if (start < 0)
			  break;
			len = patterns[i].regs.end[0] - start;
			match = buf + start;
		      }
		  } /* while (match <= best_match) */
	      continue;
	    assess_pattern_match:
	      if (!start_ptr)
		{
		  /* Good enough for a non-exact match.
		     No need to look at further patterns, if any.  */
		  beg = match;
		  goto success_in_len;
		}
	      if (match < best_match || (match == best_match && len > best_len))
		{
		  /* Best exact match:  leftmost, then longest.  */
		  best_match = match;
		  best_len = len;
		}
	    } /* if re_search >= 0 */
	} /* for Regex patterns.  */
	if (best_match < end)
	  {
	    /* We have found an exact match.  We were just
	       waiting for the best one (leftmost then longest).  */
	    beg = best_match;
	    len = best_len;
	    goto success_in_len;
	  }
    } /* for (beg = end ..) */

 failure:
  ret_val = -1;
  goto out;

 success:
  len = end - beg;
 success_in_len:
  *match_size = len;
  ret_val = beg - buf;
 out:
  return ret_val;
}
#endif /* defined(GREP_PROGRAM) || defined(EGREP_PROGRAM) */

#if defined(GREP_PROGRAM) || defined(FGREP_PROGRAM)
COMPILE_FCT(Fcompile)
{
  char const *beg, *end, *lim, *err, *pat;
  size_t psize;

  kwsinit ();
  psize = size;
  if (match_icase && MB_CUR_MAX > 1)
    pat = mbtolower (pattern, &psize);
  else
    pat = pattern;

  beg = pat;
  do
    {
      for (lim = beg;; ++lim)
	{
	  end = lim;
	  if (lim >= pat + psize)
	    break;
	 if (*lim == '\n')
	   {
	     lim++;
	     break;
	   }
#if HAVE_DOS_FILE_CONTENTS
	 if (*lim == '\r' && lim + 1 < pat + psize && lim[1] == '\n')
	   {
	     lim += 2;
	     break;
	   }
#endif
	}

      if ((err = kwsincr (kwset, beg, end - beg)) != NULL)
	error (EXIT_TROUBLE, 0, "%s", err);
      beg = lim;
    }
  while (beg < pat + psize);

  if ((err = kwsprep (kwset)) != NULL)
    error (EXIT_TROUBLE, 0, "%s", err);
}

EXECUTE_FCT(Fexecute)
{
  char const *beg, *try, *end, *mb_start;
  size_t len;
  char eol = eolbyte;
  struct kwsmatch kwsmatch;
  size_t ret_val;
#ifdef MBS_SUPPORT
  if (MB_CUR_MAX > 1)
    {
      if (match_icase)
        {
          char *case_buf = mbtolower (buf, &size);
	  if (start_ptr)
	    start_ptr = case_buf + (start_ptr - buf);
          buf = case_buf;
        }
    }
#endif /* MBS_SUPPORT */

  for (mb_start = beg = start_ptr ? start_ptr : buf; beg <= buf + size; beg++)
    {
      size_t offset = kwsexec (kwset, beg, buf + size - beg, &kwsmatch);
      if (offset == (size_t) -1)
	goto failure;
#ifdef MBS_SUPPORT
      if (MB_CUR_MAX > 1 && is_mb_middle (&mb_start, beg + offset, buf + size))
        {
          beg = mb_start - 1;
          continue; /* It is a part of multibyte character.  */
        }
#endif /* MBS_SUPPORT */
      beg += offset;
      len = kwsmatch.size[0];
      if (start_ptr && !match_words)
	goto success_in_beg_and_len;
      if (match_lines)
	{
	  if (beg > buf && beg[-1] != eol)
	    continue;
	  if (beg + len < buf + size && beg[len] != eol)
	    continue;
	  goto success;
	}
      else if (match_words)
	for (try = beg; len; )
	  {
	    if (try > buf && WCHAR((unsigned char) try[-1]))
	      break;
	    if (try + len < buf + size && WCHAR((unsigned char) try[len]))
	      {
		offset = kwsexec (kwset, beg, --len, &kwsmatch);
		if (offset == (size_t) -1)
		  break;
		try = beg + offset;
		len = kwsmatch.size[0];
	      }
	    else if (!start_ptr)
	      goto success;
	    else
	      goto success_in_beg_and_len;
	  } /* for (try) */
      else
	goto success;
    } /* for (beg in buf) */

 failure:
  ret_val = -1;
  goto out;

 success:
  if ((end = memchr (beg + len, eol, (buf + size) - (beg + len))) != NULL)
    end++;
  else
    end = buf + size;
  while (buf < beg && beg[-1] != eol)
    --beg;
  len = end - beg;
 success_in_beg_and_len:
  *match_size = len;
  ret_val = beg - buf;
 out:
  return ret_val;
}
#endif /* defined(GREP_PROGRAM) || defined(FGREP_PROGRAM) */

#ifdef GREP_PROGRAM
#if HAVE_LIBPCRE
/* Compiled internal form of a Perl regular expression.  */
static pcre *cre;

/* Additional information about the pattern.  */
static pcre_extra *extra;
#endif

COMPILE_FCT(Pcompile)
{
#if !HAVE_LIBPCRE
  error (EXIT_TROUBLE, 0, "%s",
	 _("support for the -P option is not compiled into "
	   "this --disable-perl-regexp binary"));
#else
  int e;
  char const *ep;
  char *re = xmalloc (4 * size + 7);
  int flags = PCRE_MULTILINE | (match_icase ? PCRE_CASELESS : 0);
  char const *patlim = pattern + size;
  char *n = re;
  char const *p;
  char const *pnul;

  /* FIXME: Remove these restrictions.  */
  if (memchr(pattern, '\n', size))
    error (EXIT_TROUBLE, 0, _("the -P option only supports a single pattern"));

  *n = '\0';
  if (match_lines)
    strcpy (n, "^(");
  if (match_words)
    strcpy (n, "\\b(");
  n += strlen (n);

  /* The PCRE interface doesn't allow NUL bytes in the pattern, so
     replace each NUL byte in the pattern with the four characters
     "\000", removing a preceding backslash if there are an odd
     number of backslashes before the NUL.

     FIXME: This method does not work with some multibyte character
     encodings, notably Shift-JIS, where a multibyte character can end
     in a backslash byte.  */
  for (p = pattern; (pnul = memchr (p, '\0', patlim - p)); p = pnul + 1)
    {
      memcpy (n, p, pnul - p);
      n += pnul - p;
      for (p = pnul; pattern < p && p[-1] == '\\'; p--)
	continue;
      n -= (pnul - p) & 1;
      strcpy (n, "\\000");
      n += 4;
    }

  memcpy (n, p, patlim - p);
  n += patlim - p;
  *n = '\0';
  if (match_words)
    strcpy (n, ")\\b");
  if (match_lines)
    strcpy (n, ")$");

  cre = pcre_compile (re, flags, &ep, &e, pcre_maketables ());
  if (!cre)
    error (EXIT_TROUBLE, 0, "%s", ep);

  extra = pcre_study (cre, 0, &ep);
  if (ep)
    error (EXIT_TROUBLE, 0, "%s", ep);

  free (re);
#endif
}

EXECUTE_FCT(Pexecute)
{
#if !HAVE_LIBPCRE
  abort ();
  return -1;
#else
  /* This array must have at least two elements; everything after that
     is just for performance improvement in pcre_exec.  */
  int sub[300];

  const char *line_buf, *line_end, *line_next;
  int e = PCRE_ERROR_NOMATCH;
  ptrdiff_t start_ofs = start_ptr ? start_ptr - buf : 0;

  /* PCRE can't limit the matching to single lines, therefore we have to
     match each line in the buffer separately.  */
  for (line_next = buf;
       e == PCRE_ERROR_NOMATCH && line_next < buf + size;
       start_ofs -= line_next - line_buf)
    {
      line_buf = line_next;
      line_end = memchr (line_buf, eolbyte, (buf + size) - line_buf);
      if (line_end == NULL)
        line_next = line_end = buf + size;
      else
        line_next = line_end + 1;

      if (start_ptr && start_ptr >= line_end)
        continue;

      e = pcre_exec (cre, extra, line_buf, line_end - line_buf,
                     start_ofs < 0 ? 0 : start_ofs, 0,
                     sub, sizeof sub / sizeof *sub);
    }

  if (e <= 0)
    {
      switch (e)
	{
	case PCRE_ERROR_NOMATCH:
	  return -1;

	case PCRE_ERROR_NOMEMORY:
	  error (EXIT_TROUBLE, 0, _("memory exhausted"));

	default:
	  abort ();
	}
    }
  else
    {
      /* Narrow down to the line we've found.  */
      char const *beg = line_buf + sub[0];
      char const *end = line_buf + sub[1];
      char const *buflim = buf + size;
      char eol = eolbyte;
      if (!start_ptr)
	{
	  /* FIXME: The case when '\n' is not found indicates a bug:
	     Since grep is line oriented, the match should never contain
	     a newline, so there _must_ be a newline following.
	   */
	  if (!(end = memchr (end, eol, buflim - end)))
	    end = buflim;
	  else
	    end++;
	  while (buf < beg && beg[-1] != eol)
	    --beg;
	}

      *match_size = end - beg;
      return beg - buf;
    }
#endif
}

struct matcher const matchers[] = {
  { "default", Gcompile, EGexecute },
  { "grep",    Gcompile, EGexecute },
  { "egrep",   Ecompile, EGexecute },
  { "awk",     Acompile, EGexecute },
  { "fgrep",   Fcompile, Fexecute },
  { "perl",    Pcompile, Pexecute },
  { "", 0, 0 },
};
#endif /* GREP_PROGRAM */

Building:src at:
/home/ubuntu/spr-fast/tests/corebench/grep/grep-case-deccad69-db9d6340/tempworkdir2/srcMerged code building succ, going to invoke tester!
CondTester, Testing instance id 1:
//src_file:src/search.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
/* search.c - searching subroutines using dfa, kwset and regex for grep.
   Copyright 1992, 1998, 2000, 2007, 2009-2010 Free Software Foundation, Inc.

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 3, or (at your option)
   any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program; if not, write to the Free Software
   Foundation, Inc., 51 Franklin Street - Fifth Floor, Boston, MA
   02110-1301, USA.  */

/* Written August 1992 by Mike Haertel. */

#include <config.h>

#include <sys/types.h>

#include "mbsupport.h"
#ifdef MBS_SUPPORT
/* We can handle multibyte strings. */
# include <wchar.h>
# include <wctype.h>
#endif

#include "system.h"
#include "grep.h"
#ifndef FGREP_PROGRAM
# include <regex.h>
# include "dfa.h"
#endif
#include "kwset.h"
#include "error.h"
#include "xalloc.h"
#ifdef HAVE_LIBPCRE
# include <pcre.h>
#endif

#define NCHAR (UCHAR_MAX + 1)

/* For -w, we also consider _ to be word constituent.  */
#define WCHAR(C) (ISALNUM(C) || (C) == '_')

/* KWset compiled pattern.  For Ecompile and Gcompile, we compile
   a list of strings, at least one of which is known to occur in
   any string matching the regexp. */
static kwset_t kwset;

static void
kwsinit (void)
{
  static char trans[NCHAR];
  int i;

  if (match_icase && MB_CUR_MAX == 1)
    {
      for (i = 0; i < NCHAR; ++i)
        trans[i] = TOLOWER (i);

      kwset = kwsalloc (trans);
    }
  else
    kwset = kwsalloc (NULL);

  
//Patch 0:
if ((!kwset) && !(__is_neg(3, &(kwset), sizeof (kwset), &(i), sizeof (i), &(match_icase), sizeof (match_icase))))
    xalloc_die();

//CodeSeg 1:
}

#ifdef MBS_SUPPORT
/* Convert the *N-byte string, BEG, to lowercase, and write the
   NUL-terminated result into malloc'd storage.  Upon success, set *N
   to the length (in bytes) of the resulting string (not including the
   trailing NUL byte), and return a pointer to the lowercase string.
   Upon memory allocation failure, this function exits.

   Note that while this function returns a pointer to malloc'd storage,
   the caller must not free it, since this function retains a pointer
   to the buffer and reuses it on any subsequent call.  As a consequence,
   this function is not thread-safe.  */
static char *
mbtolower (const char *beg, size_t *n)
{
  static char *out;
  static size_t outalloc;
  size_t outlen, mb_cur_max;
  mbstate_t is, os;
  const char *end;
  char *p;

  if (*n > outalloc)
    {
      out = xrealloc (out, *n);
      outalloc = *n;
    }

  memset (&is, 0, sizeof (is));
  memset (&os, 0, sizeof (os));
  end = beg + *n;

  mb_cur_max = MB_CUR_MAX;
  p = out;
  outlen = 0;
  while (beg < end)
    {
      wchar_t wc;
      size_t mbclen = mbrtowc(&wc, beg, end - beg, &is);
      if (outlen + mb_cur_max >= outalloc)
        {
          out = x2nrealloc (out, &outalloc, 1);
          p = out + outlen;
        }

      if (mbclen == (size_t) -1 || mbclen == (size_t) -2 || mbclen == 0)
        {
          /* An invalid sequence, or a truncated multi-octet character.
             We treat it as a single-octet character.  */
          *p++ = *beg++;
          outlen++;
          memset (&is, 0, sizeof (is));
          memset (&os, 0, sizeof (os));
        }
      else
        {
          beg += mbclen;
          mbclen = wcrtomb (p, towlower ((wint_t) wc), &os);
          p += mbclen;
          outlen += mbclen;
        }
    }

  *n = p - out;
  *p++ = 0;
  return out;
}
#endif


#ifndef FGREP_PROGRAM
/* DFA compiled regexp. */
static struct dfa dfa;

/* The Regex compiled patterns.  */
static struct patterns
{
  /* Regex compiled regexp. */
  struct re_pattern_buffer regexbuf;
  struct re_registers regs; /* This is here on account of a BRAIN-DEAD
			       Q@#%!# library interface in regex.c.  */
} patterns0;

struct patterns *patterns;
size_t pcount;

void
dfaerror (char const *mesg)
{
  error (EXIT_TROUBLE, 0, "%s", mesg);
}

/* Number of compiled fixed strings known to exactly match the regexp.
   If kwsexec returns < kwset_exact_matches, then we don't need to
   call the regexp matcher at all. */
static int kwset_exact_matches;

static char const *
kwsincr_case (const char *must)
{
  const char *buf;
  size_t n;

  n = strlen (must);
#ifdef MBS_SUPPORT
  if (match_icase && MB_CUR_MAX > 1)
    buf = mbtolower (must, &n);
  else
#endif
    buf = must;
  return kwsincr (kwset, buf, n);
}

/* If the DFA turns out to have some set of fixed strings one of
   which must occur in the match, then we build a kwset matcher
   to find those strings, and thus quickly filter out impossible
   matches. */
static void
kwsmusts (void)
{
  struct dfamust const *dm;
  char const *err;

  if (dfa.musts)
    {
      kwsinit ();
      /* First, we compile in the substrings known to be exact
	 matches.  The kwset matcher will return the index
	 of the matching string that it chooses. */
      for (dm = dfa.musts; dm; dm = dm->next)
	{
	  if (!dm->exact)
	    continue;
	  ++kwset_exact_matches;
	  if ((err = kwsincr_case (dm->must)) != NULL)
	    error (EXIT_TROUBLE, 0, "%s", err);
	}
      /* Now, we compile the substrings that will require
	 the use of the regexp matcher.  */
      for (dm = dfa.musts; dm; dm = dm->next)
	{
	  if (dm->exact)
	    continue;
	  if ((err = kwsincr_case (dm->must)) != NULL)
	    error (EXIT_TROUBLE, 0, "%s", err);
	}
      if ((err = kwsprep (kwset)) != NULL)
	error (EXIT_TROUBLE, 0, "%s", err);
    }
}
#endif /* !FGREP_PROGRAM */

#ifdef MBS_SUPPORT

static bool
is_mb_middle(const char **good, const char *buf, const char *end)
{
  const char *p = *good;
  const char *prev = p;
  mbstate_t cur_state;

  /* TODO: can be optimized for UTF-8.  */
  memset(&cur_state, 0, sizeof(mbstate_t));
  while (p < buf)
    {
      size_t mbclen = mbrlen(p, end - p, &cur_state);

      /* Store the beginning of the previous complete multibyte character.  */
      if (mbclen != (size_t) -2)
        prev = p;

      if (mbclen == (size_t) -1 || mbclen == (size_t) -2 || mbclen == 0)
	{
	  /* An invalid sequence, or a truncated multibyte character.
	     We treat it as a single byte character.  */
	  mbclen = 1;
	}
      p += mbclen;
    }

  *good = prev;
  return p > buf;
}
#endif /* MBS_SUPPORT */

#if defined(GREP_PROGRAM) || defined(EGREP_PROGRAM)
#ifdef EGREP_PROGRAM
COMPILE_FCT(Ecompile)
{
  reg_syntax_t syntax_bits = RE_SYNTAX_POSIX_EGREP;
#else
/* No __VA_ARGS__ in C89.  So we have to do it this way.  */
static COMPILE_RET
GEAcompile (char const *pattern, size_t size, reg_syntax_t syntax_bits)
{
#endif /* EGREP_PROGRAM */
  const char *err;
  const char *p, *sep;
  size_t total = size;
  char *motif;

  if (match_icase)
    syntax_bits |= RE_ICASE;
  re_set_syntax (syntax_bits);
  dfasyntax (syntax_bits, match_icase, eolbyte);

  /* For GNU regex compiler we have to pass the patterns separately to detect
     errors like "[\nallo\n]\n".  The patterns here are "[", "allo" and "]"
     GNU regex should have raise a syntax error.  The same for backref, where
     the backref should have been local to each pattern.  */
  p = pattern;
  do
    {
      size_t len;
      sep = memchr (p, '\n', total);
      if (sep)
	{
	  len = sep - p;
	  sep++;
	  total -= (len + 1);
	}
      else
	{
	  len = total;
	  total = 0;
	}

      patterns = realloc (patterns, (pcount + 1) * sizeof (*patterns));
      if (patterns == NULL)
	error (EXIT_TROUBLE, errno, _("memory exhausted"));
      patterns[pcount] = patterns0;

      if ((err = re_compile_pattern (p, len,
				    &(patterns[pcount].regexbuf))) != NULL)
	error (EXIT_TROUBLE, 0, "%s", err);
      pcount++;

      p = sep;
    } while (sep && total != 0);

  /* In the match_words and match_lines cases, we use a different pattern
     for the DFA matcher that will quickly throw out cases that won't work.
     Then if DFA succeeds we do some hairy stuff using the regex matcher
     to decide whether the match should really count. */
  if (match_words || match_lines)
    {
      static char const line_beg_no_bk[] = "^(";
      static char const line_end_no_bk[] = ")$";
      static char const word_beg_no_bk[] = "(^|[^[:alnum:]_])(";
      static char const word_end_no_bk[] = ")([^[:alnum:]_]|$)";
#ifdef EGREP_PROGRAM
# define IF_BK(x, y) (y)
      char *n = xmalloc (sizeof word_beg_no_bk - 1 + size + sizeof word_end_no_bk);
#else
      static char const line_beg_bk[] = "^\\(";
      static char const line_end_bk[] = "\\)$";
      static char const word_beg_bk[] = "\\(^\\|[^[:alnum:]_]\\)\\(";
      static char const word_end_bk[] = "\\)\\([^[:alnum:]_]\\|$\\)";
      int bk = !(syntax_bits & RE_NO_BK_PARENS);
# define IF_BK(x, y) ((bk) ? (x) : (y))
      char *n = xmalloc (sizeof word_beg_bk - 1 + size + sizeof word_end_bk);
#endif /* EGREP_PROGRAM */

      strcpy (n, match_lines ? IF_BK(line_beg_bk, line_beg_no_bk)
			     : IF_BK(word_beg_bk, word_beg_no_bk));
      total = strlen(n);
      memcpy (n + total, pattern, size);
      total += size;
      strcpy (n + total, match_lines ? IF_BK(line_end_bk, line_end_no_bk)
				     : IF_BK(word_end_bk, word_end_no_bk));
      total += strlen (n + total);
      pattern = motif = n;
      size = total;
    }
  else
    motif = NULL;

  dfacomp (pattern, size, &dfa, 1);
  kwsmusts ();

  free(motif);
}

#ifndef EGREP_PROGRAM
COMPILE_FCT(Gcompile)
{
  return GEAcompile (pattern, size,
		     RE_SYNTAX_GREP | RE_HAT_LISTS_NOT_NEWLINE);
}

COMPILE_FCT(Acompile)
{
  return GEAcompile (pattern, size, RE_SYNTAX_AWK);
}

COMPILE_FCT(Ecompile)
{
  return GEAcompile (pattern, size, RE_SYNTAX_POSIX_EGREP);
}
#endif /* !EGREP_PROGRAM */

EXECUTE_FCT(EGexecute)
{
  char const *buflim, *beg, *end, *match, *best_match, *mb_start;
  char eol = eolbyte;
  int backref, start, len, best_len;
  struct kwsmatch kwsm;
  size_t i, ret_val;
#ifdef MBS_SUPPORT
  if (MB_CUR_MAX > 1)
    {
      if (match_icase)
        {
          /* mbtolower adds a NUL byte at the end.  That will provide
	     space for the sentinel byte dfaexec may add.  */
          char *case_buf = mbtolower (buf, &size);
	  if (start_ptr)
	    start_ptr = case_buf + (start_ptr - buf);
          buf = case_buf;
        }
    }
#endif /* MBS_SUPPORT */

  mb_start = buf;
  buflim = buf + size;

  for (beg = end = buf; end < buflim; beg = end)
    {
      if (!start_ptr)
	{
	  /* We don't care about an exact match.  */
	  if (kwset)
	    {
	      /* Find a possible match using the KWset matcher. */
	      size_t offset = kwsexec (kwset, beg, buflim - beg, &kwsm);
	      if (offset == (size_t) -1)
		goto failure;
	      beg += offset;
	      /* Narrow down to the line containing the candidate, and
		 run it through DFA. */
	      if ((end = memchr(beg, eol, buflim - beg)) != NULL)
	        end++;
              else
                end = buflim;
	      match = beg;
	      while (beg > buf && beg[-1] != eol)
		--beg;
	      if (kwsm.index < kwset_exact_matches)
                {
#ifdef MBS_SUPPORT
                  if (mb_start < beg)
                    mb_start = beg;
                  if (MB_CUR_MAX == 1 || !is_mb_middle (&mb_start, match, buflim))
#endif
                    goto success;
                }
	      if (dfaexec (&dfa, beg, (char *) end, 0, NULL, &backref) == NULL)
		continue;
	    }
	  else
	    {
	      /* No good fixed strings; start with DFA. */
	      char const *next_beg = dfaexec (&dfa, beg, (char *) buflim,
					      0, NULL, &backref);
	      if (next_beg == NULL)
		break;
	      /* Narrow down to the line we've found. */
	      beg = next_beg;
	      if ((end = memchr(beg, eol, buflim - beg)) != NULL)
	        end++;
              else
                end = buflim;
	      while (beg > buf && beg[-1] != eol)
		--beg;
	    }
	  /* Successful, no backreferences encountered! */
	  if (!backref)
	    goto success;
	}
      else
	{
	  /* We are looking for the leftmost (then longest) exact match.
	     We will go through the outer loop only once.  */
	  beg = start_ptr;
	  end = buflim;
	}

      /* If we've made it to this point, this means DFA has seen
	 a probable match, and we need to run it through Regex. */
      best_match = end;
      best_len = 0;
      for (i = 0; i < pcount; i++)
	{
	  patterns[i].regexbuf.not_eol = 0;
	  if (0 <= (start = re_search (&(patterns[i].regexbuf),
				       buf, end - buf - 1,
				       beg - buf, end - beg - 1,
				       &(patterns[i].regs))))
	    {
	      len = patterns[i].regs.end[0] - start;
	      match = buf + start;
	      if (match > best_match)
		continue;
	      if (start_ptr && !match_words)
		goto assess_pattern_match;
	      if ((!match_lines && !match_words)
		  || (match_lines && len == end - beg - 1))
		{
		  match = beg;
		  len = end - beg;
		  goto assess_pattern_match;
		}
	      /* If -w, check if the match aligns with word boundaries.
		 We do this iteratively because:
		 (a) the line may contain more than one occurence of the
		 pattern, and
		 (b) Several alternatives in the pattern might be valid at a
		 given point, and we may need to consider a shorter one to
		 find a word boundary.  */
	      if (match_words)
		while (match <= best_match)
		  {
		    if ((match == buf || !WCHAR ((unsigned char) match[-1]))
			&& (len == end - beg - 1
			    || !WCHAR ((unsigned char) match[len])))
		      goto assess_pattern_match;
		    if (len > 0)
		      {
			/* Try a shorter length anchored at the same place. */
			--len;
			patterns[i].regexbuf.not_eol = 1;
			len = re_match (&(patterns[i].regexbuf),
					buf, match + len - beg, match - buf,
					&(patterns[i].regs));
		      }
		    if (len <= 0)
		      {
			/* Try looking further on. */
			if (match == end - 1)
			  break;
			match++;
			patterns[i].regexbuf.not_eol = 0;
			start = re_search (&(patterns[i].regexbuf),
					   buf, end - buf - 1,
					   match - buf, end - match - 1,
					   &(patterns[i].regs));
			if (start < 0)
			  break;
			len = patterns[i].regs.end[0] - start;
			match = buf + start;
		      }
		  } /* while (match <= best_match) */
	      continue;
	    assess_pattern_match:
	      if (!start_ptr)
		{
		  /* Good enough for a non-exact match.
		     No need to look at further patterns, if any.  */
		  beg = match;
		  goto success_in_len;
		}
	      if (match < best_match || (match == best_match && len > best_len))
		{
		  /* Best exact match:  leftmost, then longest.  */
		  best_match = match;
		  best_len = len;
		}
	    } /* if re_search >= 0 */
	} /* for Regex patterns.  */
	if (best_match < end)
	  {
	    /* We have found an exact match.  We were just
	       waiting for the best one (leftmost then longest).  */
	    beg = best_match;
	    len = best_len;
	    goto success_in_len;
	  }
    } /* for (beg = end ..) */

 failure:
  ret_val = -1;
  goto out;

 success:
  len = end - beg;
 success_in_len:
  *match_size = len;
  ret_val = beg - buf;
 out:
  return ret_val;
}
#endif /* defined(GREP_PROGRAM) || defined(EGREP_PROGRAM) */

#if defined(GREP_PROGRAM) || defined(FGREP_PROGRAM)
COMPILE_FCT(Fcompile)
{
  char const *beg, *end, *lim, *err, *pat;
  size_t psize;

  kwsinit ();
  psize = size;
  if (match_icase && MB_CUR_MAX > 1)
    pat = mbtolower (pattern, &psize);
  else
    pat = pattern;

  beg = pat;
  do
    {
      for (lim = beg;; ++lim)
	{
	  end = lim;
	  if (lim >= pat + psize)
	    break;
	 if (*lim == '\n')
	   {
	     lim++;
	     break;
	   }
#if HAVE_DOS_FILE_CONTENTS
	 if (*lim == '\r' && lim + 1 < pat + psize && lim[1] == '\n')
	   {
	     lim += 2;
	     break;
	   }
#endif
	}

      if ((err = kwsincr (kwset, beg, end - beg)) != NULL)
	error (EXIT_TROUBLE, 0, "%s", err);
      beg = lim;
    }
  while (beg < pat + psize);

  if ((err = kwsprep (kwset)) != NULL)
    error (EXIT_TROUBLE, 0, "%s", err);
}

EXECUTE_FCT(Fexecute)
{
  char const *beg, *try, *end, *mb_start;
  size_t len;
  char eol = eolbyte;
  struct kwsmatch kwsmatch;
  size_t ret_val;
#ifdef MBS_SUPPORT
  if (MB_CUR_MAX > 1)
    {
      if (match_icase)
        {
          char *case_buf = mbtolower (buf, &size);
	  if (start_ptr)
	    start_ptr = case_buf + (start_ptr - buf);
          buf = case_buf;
        }
    }
#endif /* MBS_SUPPORT */

  for (mb_start = beg = start_ptr ? start_ptr : buf; beg <= buf + size; beg++)
    {
      size_t offset = kwsexec (kwset, beg, buf + size - beg, &kwsmatch);
      if (offset == (size_t) -1)
	goto failure;
#ifdef MBS_SUPPORT
      if (MB_CUR_MAX > 1 && is_mb_middle (&mb_start, beg + offset, buf + size))
        {
          beg = mb_start - 1;
          continue; /* It is a part of multibyte character.  */
        }
#endif /* MBS_SUPPORT */
      beg += offset;
      len = kwsmatch.size[0];
      if (start_ptr && !match_words)
	goto success_in_beg_and_len;
      if (match_lines)
	{
	  if (beg > buf && beg[-1] != eol)
	    continue;
	  if (beg + len < buf + size && beg[len] != eol)
	    continue;
	  goto success;
	}
      else if (match_words)
	for (try = beg; len; )
	  {
	    if (try > buf && WCHAR((unsigned char) try[-1]))
	      break;
	    if (try + len < buf + size && WCHAR((unsigned char) try[len]))
	      {
		offset = kwsexec (kwset, beg, --len, &kwsmatch);
		if (offset == (size_t) -1)
		  break;
		try = beg + offset;
		len = kwsmatch.size[0];
	      }
	    else if (!start_ptr)
	      goto success;
	    else
	      goto success_in_beg_and_len;
	  } /* for (try) */
      else
	goto success;
    } /* for (beg in buf) */

 failure:
  ret_val = -1;
  goto out;

 success:
  if ((end = memchr (beg + len, eol, (buf + size) - (beg + len))) != NULL)
    end++;
  else
    end = buf + size;
  while (buf < beg && beg[-1] != eol)
    --beg;
  len = end - beg;
 success_in_beg_and_len:
  *match_size = len;
  ret_val = beg - buf;
 out:
  return ret_val;
}
#endif /* defined(GREP_PROGRAM) || defined(FGREP_PROGRAM) */

#ifdef GREP_PROGRAM
#if HAVE_LIBPCRE
/* Compiled internal form of a Perl regular expression.  */
static pcre *cre;

/* Additional information about the pattern.  */
static pcre_extra *extra;
#endif

COMPILE_FCT(Pcompile)
{
#if !HAVE_LIBPCRE
  error (EXIT_TROUBLE, 0, "%s",
	 _("support for the -P option is not compiled into "
	   "this --disable-perl-regexp binary"));
#else
  int e;
  char const *ep;
  char *re = xmalloc (4 * size + 7);
  int flags = PCRE_MULTILINE | (match_icase ? PCRE_CASELESS : 0);
  char const *patlim = pattern + size;
  char *n = re;
  char const *p;
  char const *pnul;

  /* FIXME: Remove these restrictions.  */
  if (memchr(pattern, '\n', size))
    error (EXIT_TROUBLE, 0, _("the -P option only supports a single pattern"));

  *n = '\0';
  if (match_lines)
    strcpy (n, "^(");
  if (match_words)
    strcpy (n, "\\b(");
  n += strlen (n);

  /* The PCRE interface doesn't allow NUL bytes in the pattern, so
     replace each NUL byte in the pattern with the four characters
     "\000", removing a preceding backslash if there are an odd
     number of backslashes before the NUL.

     FIXME: This method does not work with some multibyte character
     encodings, notably Shift-JIS, where a multibyte character can end
     in a backslash byte.  */
  for (p = pattern; (pnul = memchr (p, '\0', patlim - p)); p = pnul + 1)
    {
      memcpy (n, p, pnul - p);
      n += pnul - p;
      for (p = pnul; pattern < p && p[-1] == '\\'; p--)
	continue;
      n -= (pnul - p) & 1;
      strcpy (n, "\\000");
      n += 4;
    }

  memcpy (n, p, patlim - p);
  n += patlim - p;
  *n = '\0';
  if (match_words)
    strcpy (n, ")\\b");
  if (match_lines)
    strcpy (n, ")$");

  cre = pcre_compile (re, flags, &ep, &e, pcre_maketables ());
  if (!cre)
    error (EXIT_TROUBLE, 0, "%s", ep);

  extra = pcre_study (cre, 0, &ep);
  if (ep)
    error (EXIT_TROUBLE, 0, "%s", ep);

  free (re);
#endif
}

EXECUTE_FCT(Pexecute)
{
#if !HAVE_LIBPCRE
  abort ();
  return -1;
#else
  /* This array must have at least two elements; everything after that
     is just for performance improvement in pcre_exec.  */
  int sub[300];

  const char *line_buf, *line_end, *line_next;
  int e = PCRE_ERROR_NOMATCH;
  ptrdiff_t start_ofs = start_ptr ? start_ptr - buf : 0;

  /* PCRE can't limit the matching to single lines, therefore we have to
     match each line in the buffer separately.  */
  for (line_next = buf;
       e == PCRE_ERROR_NOMATCH && line_next < buf + size;
       start_ofs -= line_next - line_buf)
    {
      line_buf = line_next;
      line_end = memchr (line_buf, eolbyte, (buf + size) - line_buf);
      if (line_end == NULL)
        line_next = line_end = buf + size;
      else
        line_next = line_end + 1;

      if (start_ptr && start_ptr >= line_end)
        continue;

      e = pcre_exec (cre, extra, line_buf, line_end - line_buf,
                     start_ofs < 0 ? 0 : start_ofs, 0,
                     sub, sizeof sub / sizeof *sub);
    }

  if (e <= 0)
    {
      switch (e)
	{
	case PCRE_ERROR_NOMATCH:
	  return -1;

	case PCRE_ERROR_NOMEMORY:
	  error (EXIT_TROUBLE, 0, _("memory exhausted"));

	default:
	  abort ();
	}
    }
  else
    {
      /* Narrow down to the line we've found.  */
      char const *beg = line_buf + sub[0];
      char const *end = line_buf + sub[1];
      char const *buflim = buf + size;
      char eol = eolbyte;
      if (!start_ptr)
	{
	  /* FIXME: The case when '\n' is not found indicates a bug:
	     Since grep is line oriented, the match should never contain
	     a newline, so there _must_ be a newline following.
	   */
	  if (!(end = memchr (end, eol, buflim - end)))
	    end = buflim;
	  else
	    end++;
	  while (buf < beg && beg[-1] != eol)
	    --beg;
	}

      *match_size = end - beg;
      return beg - buf;
    }
#endif
}

struct matcher const matchers[] = {
  { "default", Gcompile, EGexecute },
  { "grep",    Gcompile, EGexecute },
  { "egrep",   Ecompile, EGexecute },
  { "awk",     Acompile, EGexecute },
  { "fgrep",   Fcompile, Fexecute },
  { "perl",    Pcompile, Pexecute },
  { "", 0, 0 },
};
#endif /* GREP_PROGRAM */

Testing negative cases!
Testing 0 (with abstract condition) ENVIS_NEG
Iteration 0
Running test command:
/home/ubuntu/spr-fast/tools/grep-test.py /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-deccad69-db9d6340/tempworkdir2/src /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-deccad69-db9d6340/tempworkdir2/tests /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-deccad69-db9d6340/tempworkdir2 0  > __res
Opening:/home/ubuntu/spr-fast/tests/corebench/grep/grep-case-deccad69-db9d6340/tempworkdir2/neg.tmp!
NegativeBRANCH RECORD/home/ubuntu/spr-fast/tests/corebench/grep/grep-case-deccad69-db9d6340/tempworkdir2/neg.tmp!
Not caught by the negative case, give up!
APPENDING TO ISNEG:/home/ubuntu/spr-fast/tests/corebench/grep/grep-case-deccad69-db9d6340/tempworkdir2/neg.tmp!
Running test command:
/home/ubuntu/spr-fast/tools/grep-test.py /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-deccad69-db9d6340/tempworkdir2/src /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-deccad69-db9d6340/tempworkdir2/tests /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-deccad69-db9d6340/tempworkdir2 0  > __res
CondTester, Testing instance id 2:
//src_file:src/search.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
/* search.c - searching subroutines using dfa, kwset and regex for grep.
   Copyright 1992, 1998, 2000, 2007, 2009-2010 Free Software Foundation, Inc.

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 3, or (at your option)
   any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program; if not, write to the Free Software
   Foundation, Inc., 51 Franklin Street - Fifth Floor, Boston, MA
   02110-1301, USA.  */

/* Written August 1992 by Mike Haertel. */

#include <config.h>

#include <sys/types.h>

#include "mbsupport.h"
#ifdef MBS_SUPPORT
/* We can handle multibyte strings. */
# include <wchar.h>
# include <wctype.h>
#endif

#include "system.h"
#include "grep.h"
#ifndef FGREP_PROGRAM
# include <regex.h>
# include "dfa.h"
#endif
#include "kwset.h"
#include "error.h"
#include "xalloc.h"
#ifdef HAVE_LIBPCRE
# include <pcre.h>
#endif

#define NCHAR (UCHAR_MAX + 1)

/* For -w, we also consider _ to be word constituent.  */
#define WCHAR(C) (ISALNUM(C) || (C) == '_')

/* KWset compiled pattern.  For Ecompile and Gcompile, we compile
   a list of strings, at least one of which is known to occur in
   any string matching the regexp. */
static kwset_t kwset;

static void
kwsinit (void)
{
  static char trans[NCHAR];
  int i;

  if (match_icase && MB_CUR_MAX == 1)
    {
      for (i = 0; i < NCHAR; ++i)
        trans[i] = TOLOWER (i);

      kwset = kwsalloc (trans);
    }
  else
    kwset = kwsalloc (NULL);

  
//Patch 0:
if ((!kwset) || (__is_neg(3, &(kwset), sizeof (kwset), &(i), sizeof (i), &(match_icase), sizeof (match_icase))))
    xalloc_die();

//CodeSeg 1:
}

#ifdef MBS_SUPPORT
/* Convert the *N-byte string, BEG, to lowercase, and write the
   NUL-terminated result into malloc'd storage.  Upon success, set *N
   to the length (in bytes) of the resulting string (not including the
   trailing NUL byte), and return a pointer to the lowercase string.
   Upon memory allocation failure, this function exits.

   Note that while this function returns a pointer to malloc'd storage,
   the caller must not free it, since this function retains a pointer
   to the buffer and reuses it on any subsequent call.  As a consequence,
   this function is not thread-safe.  */
static char *
mbtolower (const char *beg, size_t *n)
{
  static char *out;
  static size_t outalloc;
  size_t outlen, mb_cur_max;
  mbstate_t is, os;
  const char *end;
  char *p;

  if (*n > outalloc)
    {
      out = xrealloc (out, *n);
      outalloc = *n;
    }

  memset (&is, 0, sizeof (is));
  memset (&os, 0, sizeof (os));
  end = beg + *n;

  mb_cur_max = MB_CUR_MAX;
  p = out;
  outlen = 0;
  while (beg < end)
    {
      wchar_t wc;
      size_t mbclen = mbrtowc(&wc, beg, end - beg, &is);
      if (outlen + mb_cur_max >= outalloc)
        {
          out = x2nrealloc (out, &outalloc, 1);
          p = out + outlen;
        }

      if (mbclen == (size_t) -1 || mbclen == (size_t) -2 || mbclen == 0)
        {
          /* An invalid sequence, or a truncated multi-octet character.
             We treat it as a single-octet character.  */
          *p++ = *beg++;
          outlen++;
          memset (&is, 0, sizeof (is));
          memset (&os, 0, sizeof (os));
        }
      else
        {
          beg += mbclen;
          mbclen = wcrtomb (p, towlower ((wint_t) wc), &os);
          p += mbclen;
          outlen += mbclen;
        }
    }

  *n = p - out;
  *p++ = 0;
  return out;
}
#endif


#ifndef FGREP_PROGRAM
/* DFA compiled regexp. */
static struct dfa dfa;

/* The Regex compiled patterns.  */
static struct patterns
{
  /* Regex compiled regexp. */
  struct re_pattern_buffer regexbuf;
  struct re_registers regs; /* This is here on account of a BRAIN-DEAD
			       Q@#%!# library interface in regex.c.  */
} patterns0;

struct patterns *patterns;
size_t pcount;

void
dfaerror (char const *mesg)
{
  error (EXIT_TROUBLE, 0, "%s", mesg);
}

/* Number of compiled fixed strings known to exactly match the regexp.
   If kwsexec returns < kwset_exact_matches, then we don't need to
   call the regexp matcher at all. */
static int kwset_exact_matches;

static char const *
kwsincr_case (const char *must)
{
  const char *buf;
  size_t n;

  n = strlen (must);
#ifdef MBS_SUPPORT
  if (match_icase && MB_CUR_MAX > 1)
    buf = mbtolower (must, &n);
  else
#endif
    buf = must;
  return kwsincr (kwset, buf, n);
}

/* If the DFA turns out to have some set of fixed strings one of
   which must occur in the match, then we build a kwset matcher
   to find those strings, and thus quickly filter out impossible
   matches. */
static void
kwsmusts (void)
{
  struct dfamust const *dm;
  char const *err;

  if (dfa.musts)
    {
      kwsinit ();
      /* First, we compile in the substrings known to be exact
	 matches.  The kwset matcher will return the index
	 of the matching string that it chooses. */
      for (dm = dfa.musts; dm; dm = dm->next)
	{
	  if (!dm->exact)
	    continue;
	  ++kwset_exact_matches;
	  if ((err = kwsincr_case (dm->must)) != NULL)
	    error (EXIT_TROUBLE, 0, "%s", err);
	}
      /* Now, we compile the substrings that will require
	 the use of the regexp matcher.  */
      for (dm = dfa.musts; dm; dm = dm->next)
	{
	  if (dm->exact)
	    continue;
	  if ((err = kwsincr_case (dm->must)) != NULL)
	    error (EXIT_TROUBLE, 0, "%s", err);
	}
      if ((err = kwsprep (kwset)) != NULL)
	error (EXIT_TROUBLE, 0, "%s", err);
    }
}
#endif /* !FGREP_PROGRAM */

#ifdef MBS_SUPPORT

static bool
is_mb_middle(const char **good, const char *buf, const char *end)
{
  const char *p = *good;
  const char *prev = p;
  mbstate_t cur_state;

  /* TODO: can be optimized for UTF-8.  */
  memset(&cur_state, 0, sizeof(mbstate_t));
  while (p < buf)
    {
      size_t mbclen = mbrlen(p, end - p, &cur_state);

      /* Store the beginning of the previous complete multibyte character.  */
      if (mbclen != (size_t) -2)
        prev = p;

      if (mbclen == (size_t) -1 || mbclen == (size_t) -2 || mbclen == 0)
	{
	  /* An invalid sequence, or a truncated multibyte character.
	     We treat it as a single byte character.  */
	  mbclen = 1;
	}
      p += mbclen;
    }

  *good = prev;
  return p > buf;
}
#endif /* MBS_SUPPORT */

#if defined(GREP_PROGRAM) || defined(EGREP_PROGRAM)
#ifdef EGREP_PROGRAM
COMPILE_FCT(Ecompile)
{
  reg_syntax_t syntax_bits = RE_SYNTAX_POSIX_EGREP;
#else
/* No __VA_ARGS__ in C89.  So we have to do it this way.  */
static COMPILE_RET
GEAcompile (char const *pattern, size_t size, reg_syntax_t syntax_bits)
{
#endif /* EGREP_PROGRAM */
  const char *err;
  const char *p, *sep;
  size_t total = size;
  char *motif;

  if (match_icase)
    syntax_bits |= RE_ICASE;
  re_set_syntax (syntax_bits);
  dfasyntax (syntax_bits, match_icase, eolbyte);

  /* For GNU regex compiler we have to pass the patterns separately to detect
     errors like "[\nallo\n]\n".  The patterns here are "[", "allo" and "]"
     GNU regex should have raise a syntax error.  The same for backref, where
     the backref should have been local to each pattern.  */
  p = pattern;
  do
    {
      size_t len;
      sep = memchr (p, '\n', total);
      if (sep)
	{
	  len = sep - p;
	  sep++;
	  total -= (len + 1);
	}
      else
	{
	  len = total;
	  total = 0;
	}

      patterns = realloc (patterns, (pcount + 1) * sizeof (*patterns));
      if (patterns == NULL)
	error (EXIT_TROUBLE, errno, _("memory exhausted"));
      patterns[pcount] = patterns0;

      if ((err = re_compile_pattern (p, len,
				    &(patterns[pcount].regexbuf))) != NULL)
	error (EXIT_TROUBLE, 0, "%s", err);
      pcount++;

      p = sep;
    } while (sep && total != 0);

  /* In the match_words and match_lines cases, we use a different pattern
     for the DFA matcher that will quickly throw out cases that won't work.
     Then if DFA succeeds we do some hairy stuff using the regex matcher
     to decide whether the match should really count. */
  if (match_words || match_lines)
    {
      static char const line_beg_no_bk[] = "^(";
      static char const line_end_no_bk[] = ")$";
      static char const word_beg_no_bk[] = "(^|[^[:alnum:]_])(";
      static char const word_end_no_bk[] = ")([^[:alnum:]_]|$)";
#ifdef EGREP_PROGRAM
# define IF_BK(x, y) (y)
      char *n = xmalloc (sizeof word_beg_no_bk - 1 + size + sizeof word_end_no_bk);
#else
      static char const line_beg_bk[] = "^\\(";
      static char const line_end_bk[] = "\\)$";
      static char const word_beg_bk[] = "\\(^\\|[^[:alnum:]_]\\)\\(";
      static char const word_end_bk[] = "\\)\\([^[:alnum:]_]\\|$\\)";
      int bk = !(syntax_bits & RE_NO_BK_PARENS);
# define IF_BK(x, y) ((bk) ? (x) : (y))
      char *n = xmalloc (sizeof word_beg_bk - 1 + size + sizeof word_end_bk);
#endif /* EGREP_PROGRAM */

      strcpy (n, match_lines ? IF_BK(line_beg_bk, line_beg_no_bk)
			     : IF_BK(word_beg_bk, word_beg_no_bk));
      total = strlen(n);
      memcpy (n + total, pattern, size);
      total += size;
      strcpy (n + total, match_lines ? IF_BK(line_end_bk, line_end_no_bk)
				     : IF_BK(word_end_bk, word_end_no_bk));
      total += strlen (n + total);
      pattern = motif = n;
      size = total;
    }
  else
    motif = NULL;

  dfacomp (pattern, size, &dfa, 1);
  kwsmusts ();

  free(motif);
}

#ifndef EGREP_PROGRAM
COMPILE_FCT(Gcompile)
{
  return GEAcompile (pattern, size,
		     RE_SYNTAX_GREP | RE_HAT_LISTS_NOT_NEWLINE);
}

COMPILE_FCT(Acompile)
{
  return GEAcompile (pattern, size, RE_SYNTAX_AWK);
}

COMPILE_FCT(Ecompile)
{
  return GEAcompile (pattern, size, RE_SYNTAX_POSIX_EGREP);
}
#endif /* !EGREP_PROGRAM */

EXECUTE_FCT(EGexecute)
{
  char const *buflim, *beg, *end, *match, *best_match, *mb_start;
  char eol = eolbyte;
  int backref, start, len, best_len;
  struct kwsmatch kwsm;
  size_t i, ret_val;
#ifdef MBS_SUPPORT
  if (MB_CUR_MAX > 1)
    {
      if (match_icase)
        {
          /* mbtolower adds a NUL byte at the end.  That will provide
	     space for the sentinel byte dfaexec may add.  */
          char *case_buf = mbtolower (buf, &size);
	  if (start_ptr)
	    start_ptr = case_buf + (start_ptr - buf);
          buf = case_buf;
        }
    }
#endif /* MBS_SUPPORT */

  mb_start = buf;
  buflim = buf + size;

  for (beg = end = buf; end < buflim; beg = end)
    {
      if (!start_ptr)
	{
	  /* We don't care about an exact match.  */
	  if (kwset)
	    {
	      /* Find a possible match using the KWset matcher. */
	      size_t offset = kwsexec (kwset, beg, buflim - beg, &kwsm);
	      if (offset == (size_t) -1)
		goto failure;
	      beg += offset;
	      /* Narrow down to the line containing the candidate, and
		 run it through DFA. */
	      if ((end = memchr(beg, eol, buflim - beg)) != NULL)
	        end++;
              else
                end = buflim;
	      match = beg;
	      while (beg > buf && beg[-1] != eol)
		--beg;
	      if (kwsm.index < kwset_exact_matches)
                {
#ifdef MBS_SUPPORT
                  if (mb_start < beg)
                    mb_start = beg;
                  if (MB_CUR_MAX == 1 || !is_mb_middle (&mb_start, match, buflim))
#endif
                    goto success;
                }
	      if (dfaexec (&dfa, beg, (char *) end, 0, NULL, &backref) == NULL)
		continue;
	    }
	  else
	    {
	      /* No good fixed strings; start with DFA. */
	      char const *next_beg = dfaexec (&dfa, beg, (char *) buflim,
					      0, NULL, &backref);
	      if (next_beg == NULL)
		break;
	      /* Narrow down to the line we've found. */
	      beg = next_beg;
	      if ((end = memchr(beg, eol, buflim - beg)) != NULL)
	        end++;
              else
                end = buflim;
	      while (beg > buf && beg[-1] != eol)
		--beg;
	    }
	  /* Successful, no backreferences encountered! */
	  if (!backref)
	    goto success;
	}
      else
	{
	  /* We are looking for the leftmost (then longest) exact match.
	     We will go through the outer loop only once.  */
	  beg = start_ptr;
	  end = buflim;
	}

      /* If we've made it to this point, this means DFA has seen
	 a probable match, and we need to run it through Regex. */
      best_match = end;
      best_len = 0;
      for (i = 0; i < pcount; i++)
	{
	  patterns[i].regexbuf.not_eol = 0;
	  if (0 <= (start = re_search (&(patterns[i].regexbuf),
				       buf, end - buf - 1,
				       beg - buf, end - beg - 1,
				       &(patterns[i].regs))))
	    {
	      len = patterns[i].regs.end[0] - start;
	      match = buf + start;
	      if (match > best_match)
		continue;
	      if (start_ptr && !match_words)
		goto assess_pattern_match;
	      if ((!match_lines && !match_words)
		  || (match_lines && len == end - beg - 1))
		{
		  match = beg;
		  len = end - beg;
		  goto assess_pattern_match;
		}
	      /* If -w, check if the match aligns with word boundaries.
		 We do this iteratively because:
		 (a) the line may contain more than one occurence of the
		 pattern, and
		 (b) Several alternatives in the pattern might be valid at a
		 given point, and we may need to consider a shorter one to
		 find a word boundary.  */
	      if (match_words)
		while (match <= best_match)
		  {
		    if ((match == buf || !WCHAR ((unsigned char) match[-1]))
			&& (len == end - beg - 1
			    || !WCHAR ((unsigned char) match[len])))
		      goto assess_pattern_match;
		    if (len > 0)
		      {
			/* Try a shorter length anchored at the same place. */
			--len;
			patterns[i].regexbuf.not_eol = 1;
			len = re_match (&(patterns[i].regexbuf),
					buf, match + len - beg, match - buf,
					&(patterns[i].regs));
		      }
		    if (len <= 0)
		      {
			/* Try looking further on. */
			if (match == end - 1)
			  break;
			match++;
			patterns[i].regexbuf.not_eol = 0;
			start = re_search (&(patterns[i].regexbuf),
					   buf, end - buf - 1,
					   match - buf, end - match - 1,
					   &(patterns[i].regs));
			if (start < 0)
			  break;
			len = patterns[i].regs.end[0] - start;
			match = buf + start;
		      }
		  } /* while (match <= best_match) */
	      continue;
	    assess_pattern_match:
	      if (!start_ptr)
		{
		  /* Good enough for a non-exact match.
		     No need to look at further patterns, if any.  */
		  beg = match;
		  goto success_in_len;
		}
	      if (match < best_match || (match == best_match && len > best_len))
		{
		  /* Best exact match:  leftmost, then longest.  */
		  best_match = match;
		  best_len = len;
		}
	    } /* if re_search >= 0 */
	} /* for Regex patterns.  */
	if (best_match < end)
	  {
	    /* We have found an exact match.  We were just
	       waiting for the best one (leftmost then longest).  */
	    beg = best_match;
	    len = best_len;
	    goto success_in_len;
	  }
    } /* for (beg = end ..) */

 failure:
  ret_val = -1;
  goto out;

 success:
  len = end - beg;
 success_in_len:
  *match_size = len;
  ret_val = beg - buf;
 out:
  return ret_val;
}
#endif /* defined(GREP_PROGRAM) || defined(EGREP_PROGRAM) */

#if defined(GREP_PROGRAM) || defined(FGREP_PROGRAM)
COMPILE_FCT(Fcompile)
{
  char const *beg, *end, *lim, *err, *pat;
  size_t psize;

  kwsinit ();
  psize = size;
  if (match_icase && MB_CUR_MAX > 1)
    pat = mbtolower (pattern, &psize);
  else
    pat = pattern;

  beg = pat;
  do
    {
      for (lim = beg;; ++lim)
	{
	  end = lim;
	  if (lim >= pat + psize)
	    break;
	 if (*lim == '\n')
	   {
	     lim++;
	     break;
	   }
#if HAVE_DOS_FILE_CONTENTS
	 if (*lim == '\r' && lim + 1 < pat + psize && lim[1] == '\n')
	   {
	     lim += 2;
	     break;
	   }
#endif
	}

      if ((err = kwsincr (kwset, beg, end - beg)) != NULL)
	error (EXIT_TROUBLE, 0, "%s", err);
      beg = lim;
    }
  while (beg < pat + psize);

  if ((err = kwsprep (kwset)) != NULL)
    error (EXIT_TROUBLE, 0, "%s", err);
}

EXECUTE_FCT(Fexecute)
{
  char const *beg, *try, *end, *mb_start;
  size_t len;
  char eol = eolbyte;
  struct kwsmatch kwsmatch;
  size_t ret_val;
#ifdef MBS_SUPPORT
  if (MB_CUR_MAX > 1)
    {
      if (match_icase)
        {
          char *case_buf = mbtolower (buf, &size);
	  if (start_ptr)
	    start_ptr = case_buf + (start_ptr - buf);
          buf = case_buf;
        }
    }
#endif /* MBS_SUPPORT */

  for (mb_start = beg = start_ptr ? start_ptr : buf; beg <= buf + size; beg++)
    {
      size_t offset = kwsexec (kwset, beg, buf + size - beg, &kwsmatch);
      if (offset == (size_t) -1)
	goto failure;
#ifdef MBS_SUPPORT
      if (MB_CUR_MAX > 1 && is_mb_middle (&mb_start, beg + offset, buf + size))
        {
          beg = mb_start - 1;
          continue; /* It is a part of multibyte character.  */
        }
#endif /* MBS_SUPPORT */
      beg += offset;
      len = kwsmatch.size[0];
      if (start_ptr && !match_words)
	goto success_in_beg_and_len;
      if (match_lines)
	{
	  if (beg > buf && beg[-1] != eol)
	    continue;
	  if (beg + len < buf + size && beg[len] != eol)
	    continue;
	  goto success;
	}
      else if (match_words)
	for (try = beg; len; )
	  {
	    if (try > buf && WCHAR((unsigned char) try[-1]))
	      break;
	    if (try + len < buf + size && WCHAR((unsigned char) try[len]))
	      {
		offset = kwsexec (kwset, beg, --len, &kwsmatch);
		if (offset == (size_t) -1)
		  break;
		try = beg + offset;
		len = kwsmatch.size[0];
	      }
	    else if (!start_ptr)
	      goto success;
	    else
	      goto success_in_beg_and_len;
	  } /* for (try) */
      else
	goto success;
    } /* for (beg in buf) */

 failure:
  ret_val = -1;
  goto out;

 success:
  if ((end = memchr (beg + len, eol, (buf + size) - (beg + len))) != NULL)
    end++;
  else
    end = buf + size;
  while (buf < beg && beg[-1] != eol)
    --beg;
  len = end - beg;
 success_in_beg_and_len:
  *match_size = len;
  ret_val = beg - buf;
 out:
  return ret_val;
}
#endif /* defined(GREP_PROGRAM) || defined(FGREP_PROGRAM) */

#ifdef GREP_PROGRAM
#if HAVE_LIBPCRE
/* Compiled internal form of a Perl regular expression.  */
static pcre *cre;

/* Additional information about the pattern.  */
static pcre_extra *extra;
#endif

COMPILE_FCT(Pcompile)
{
#if !HAVE_LIBPCRE
  error (EXIT_TROUBLE, 0, "%s",
	 _("support for the -P option is not compiled into "
	   "this --disable-perl-regexp binary"));
#else
  int e;
  char const *ep;
  char *re = xmalloc (4 * size + 7);
  int flags = PCRE_MULTILINE | (match_icase ? PCRE_CASELESS : 0);
  char const *patlim = pattern + size;
  char *n = re;
  char const *p;
  char const *pnul;

  /* FIXME: Remove these restrictions.  */
  if (memchr(pattern, '\n', size))
    error (EXIT_TROUBLE, 0, _("the -P option only supports a single pattern"));

  *n = '\0';
  if (match_lines)
    strcpy (n, "^(");
  if (match_words)
    strcpy (n, "\\b(");
  n += strlen (n);

  /* The PCRE interface doesn't allow NUL bytes in the pattern, so
     replace each NUL byte in the pattern with the four characters
     "\000", removing a preceding backslash if there are an odd
     number of backslashes before the NUL.

     FIXME: This method does not work with some multibyte character
     encodings, notably Shift-JIS, where a multibyte character can end
     in a backslash byte.  */
  for (p = pattern; (pnul = memchr (p, '\0', patlim - p)); p = pnul + 1)
    {
      memcpy (n, p, pnul - p);
      n += pnul - p;
      for (p = pnul; pattern < p && p[-1] == '\\'; p--)
	continue;
      n -= (pnul - p) & 1;
      strcpy (n, "\\000");
      n += 4;
    }

  memcpy (n, p, patlim - p);
  n += patlim - p;
  *n = '\0';
  if (match_words)
    strcpy (n, ")\\b");
  if (match_lines)
    strcpy (n, ")$");

  cre = pcre_compile (re, flags, &ep, &e, pcre_maketables ());
  if (!cre)
    error (EXIT_TROUBLE, 0, "%s", ep);

  extra = pcre_study (cre, 0, &ep);
  if (ep)
    error (EXIT_TROUBLE, 0, "%s", ep);

  free (re);
#endif
}

EXECUTE_FCT(Pexecute)
{
#if !HAVE_LIBPCRE
  abort ();
  return -1;
#else
  /* This array must have at least two elements; everything after that
     is just for performance improvement in pcre_exec.  */
  int sub[300];

  const char *line_buf, *line_end, *line_next;
  int e = PCRE_ERROR_NOMATCH;
  ptrdiff_t start_ofs = start_ptr ? start_ptr - buf : 0;

  /* PCRE can't limit the matching to single lines, therefore we have to
     match each line in the buffer separately.  */
  for (line_next = buf;
       e == PCRE_ERROR_NOMATCH && line_next < buf + size;
       start_ofs -= line_next - line_buf)
    {
      line_buf = line_next;
      line_end = memchr (line_buf, eolbyte, (buf + size) - line_buf);
      if (line_end == NULL)
        line_next = line_end = buf + size;
      else
        line_next = line_end + 1;

      if (start_ptr && start_ptr >= line_end)
        continue;

      e = pcre_exec (cre, extra, line_buf, line_end - line_buf,
                     start_ofs < 0 ? 0 : start_ofs, 0,
                     sub, sizeof sub / sizeof *sub);
    }

  if (e <= 0)
    {
      switch (e)
	{
	case PCRE_ERROR_NOMATCH:
	  return -1;

	case PCRE_ERROR_NOMEMORY:
	  error (EXIT_TROUBLE, 0, _("memory exhausted"));

	default:
	  abort ();
	}
    }
  else
    {
      /* Narrow down to the line we've found.  */
      char const *beg = line_buf + sub[0];
      char const *end = line_buf + sub[1];
      char const *buflim = buf + size;
      char eol = eolbyte;
      if (!start_ptr)
	{
	  /* FIXME: The case when '\n' is not found indicates a bug:
	     Since grep is line oriented, the match should never contain
	     a newline, so there _must_ be a newline following.
	   */
	  if (!(end = memchr (end, eol, buflim - end)))
	    end = buflim;
	  else
	    end++;
	  while (buf < beg && beg[-1] != eol)
	    --beg;
	}

      *match_size = end - beg;
      return beg - buf;
    }
#endif
}

struct matcher const matchers[] = {
  { "default", Gcompile, EGexecute },
  { "grep",    Gcompile, EGexecute },
  { "egrep",   Ecompile, EGexecute },
  { "awk",     Acompile, EGexecute },
  { "fgrep",   Fcompile, Fexecute },
  { "perl",    Pcompile, Pexecute },
  { "", 0, 0 },
};
#endif /* GREP_PROGRAM */

Testing negative cases!
Testing 0 (with abstract condition) ENVIS_NEG
Iteration 0
Running test command:
/home/ubuntu/spr-fast/tools/grep-test.py /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-deccad69-db9d6340/tempworkdir2/src /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-deccad69-db9d6340/tempworkdir2/tests /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-deccad69-db9d6340/tempworkdir2 0  > __res
Opening:/home/ubuntu/spr-fast/tests/corebench/grep/grep-case-deccad69-db9d6340/tempworkdir2/neg.tmp!
NegativeBRANCH RECORD/home/ubuntu/spr-fast/tests/corebench/grep/grep-case-deccad69-db9d6340/tempworkdir2/neg.tmp!
APPENDING TO ISNEG:/home/ubuntu/spr-fast/tests/corebench/grep/grep-case-deccad69-db9d6340/tempworkdir2/neg.tmp!
Branch 0: 0
Iteration 1
Running test command:
/home/ubuntu/spr-fast/tools/grep-test.py /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-deccad69-db9d6340/tempworkdir2/src /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-deccad69-db9d6340/tempworkdir2/tests /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-deccad69-db9d6340/tempworkdir2 0  > __res
Opening:/home/ubuntu/spr-fast/tests/corebench/grep/grep-case-deccad69-db9d6340/tempworkdir2/neg.tmp!
NegativeBRANCH RECORD/home/ubuntu/spr-fast/tests/corebench/grep/grep-case-deccad69-db9d6340/tempworkdir2/neg.tmp!
APPENDING TO ISNEG:/home/ubuntu/spr-fast/tests/corebench/grep/grep-case-deccad69-db9d6340/tempworkdir2/neg.tmp!
Branch 0: 1
Passed in iteration!
Passed Negative Cases wiht CondTestder!
Testing positive cases!
Running test command:
/home/ubuntu/spr-fast/tools/grep-test.py /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-deccad69-db9d6340/tempworkdir2/src /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-deccad69-db9d6340/tempworkdir2/tests /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-deccad69-db9d6340/tempworkdir2 3  > __res
Running test command:
/home/ubuntu/spr-fast/tools/grep-test.py /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-deccad69-db9d6340/tempworkdir2/src /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-deccad69-db9d6340/tempworkdir2/tests /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-deccad69-db9d6340/tempworkdir2 4  > __res
Running test command:
/home/ubuntu/spr-fast/tools/grep-test.py /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-deccad69-db9d6340/tempworkdir2/src /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-deccad69-db9d6340/tempworkdir2/tests /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-deccad69-db9d6340/tempworkdir2 5  > __res
Running test command:
/home/ubuntu/spr-fast/tools/grep-test.py /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-deccad69-db9d6340/tempworkdir2/src /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-deccad69-db9d6340/tempworkdir2/tests /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-deccad69-db9d6340/tempworkdir2 6  > __res
Running test command:
/home/ubuntu/spr-fast/tools/grep-test.py /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-deccad69-db9d6340/tempworkdir2/src /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-deccad69-db9d6340/tempworkdir2/tests /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-deccad69-db9d6340/tempworkdir2 9  > __res
Running test command:
/home/ubuntu/spr-fast/tools/grep-test.py /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-deccad69-db9d6340/tempworkdir2/src /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-deccad69-db9d6340/tempworkdir2/tests /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-deccad69-db9d6340/tempworkdir2 11  > __res
Running test command:
/home/ubuntu/spr-fast/tools/grep-test.py /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-deccad69-db9d6340/tempworkdir2/src /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-deccad69-db9d6340/tempworkdir2/tests /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-deccad69-db9d6340/tempworkdir2 12  > __res
Running test command:
/home/ubuntu/spr-fast/tools/grep-test.py /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-deccad69-db9d6340/tempworkdir2/src /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-deccad69-db9d6340/tempworkdir2/tests /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-deccad69-db9d6340/tempworkdir2 13  > __res
Running test command:
/home/ubuntu/spr-fast/tools/grep-test.py /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-deccad69-db9d6340/tempworkdir2/src /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-deccad69-db9d6340/tempworkdir2/tests /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-deccad69-db9d6340/tempworkdir2 14  > __res
Running test command:
/home/ubuntu/spr-fast/tools/grep-test.py /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-deccad69-db9d6340/tempworkdir2/src /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-deccad69-db9d6340/tempworkdir2/tests /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-deccad69-db9d6340/tempworkdir2 15  > __res
Running test command:
/home/ubuntu/spr-fast/tools/grep-test.py /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-deccad69-db9d6340/tempworkdir2/src /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-deccad69-db9d6340/tempworkdir2/tests /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-deccad69-db9d6340/tempworkdir2 17  > __res
Running test command:
/home/ubuntu/spr-fast/tools/grep-test.py /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-deccad69-db9d6340/tempworkdir2/src /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-deccad69-db9d6340/tempworkdir2/tests /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-deccad69-db9d6340/tempworkdir2 18  > __res
Running test command:
/home/ubuntu/spr-fast/tools/grep-test.py /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-deccad69-db9d6340/tempworkdir2/src /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-deccad69-db9d6340/tempworkdir2/tests /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-deccad69-db9d6340/tempworkdir2 20  > __res
Running test command:
/home/ubuntu/spr-fast/tools/grep-test.py /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-deccad69-db9d6340/tempworkdir2/src /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-deccad69-db9d6340/tempworkdir2/tests /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-deccad69-db9d6340/tempworkdir2 22  > __res
Running test command:
/home/ubuntu/spr-fast/tools/grep-test.py /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-deccad69-db9d6340/tempworkdir2/src /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-deccad69-db9d6340/tempworkdir2/tests /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-deccad69-db9d6340/tempworkdir2 23  > __res
Running test command:
/home/ubuntu/spr-fast/tools/grep-test.py /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-deccad69-db9d6340/tempworkdir2/src /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-deccad69-db9d6340/tempworkdir2/tests /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-deccad69-db9d6340/tempworkdir2 25  > __res
Passed Positive Cases
Collect values for post processing!
WRITING TO ISNEG:/home/ubuntu/spr-fast/tests/corebench/grep/grep-case-deccad69-db9d6340/tempworkdir2/neg.tmp!
Running test command:
/home/ubuntu/spr-fast/tools/grep-test.py /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-deccad69-db9d6340/tempworkdir2/src /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-deccad69-db9d6340/tempworkdir2/tests /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-deccad69-db9d6340/tempworkdir2 0  > __res
Running test command:
/home/ubuntu/spr-fast/tools/grep-test.py /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-deccad69-db9d6340/tempworkdir2/src /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-deccad69-db9d6340/tempworkdir2/tests /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-deccad69-db9d6340/tempworkdir2 3  > __res
Running test command:
/home/ubuntu/spr-fast/tools/grep-test.py /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-deccad69-db9d6340/tempworkdir2/src /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-deccad69-db9d6340/tempworkdir2/tests /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-deccad69-db9d6340/tempworkdir2 4  > __res
Running test command:
/home/ubuntu/spr-fast/tools/grep-test.py /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-deccad69-db9d6340/tempworkdir2/src /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-deccad69-db9d6340/tempworkdir2/tests /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-deccad69-db9d6340/tempworkdir2 5  > __res
Running test command:
/home/ubuntu/spr-fast/tools/grep-test.py /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-deccad69-db9d6340/tempworkdir2/src /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-deccad69-db9d6340/tempworkdir2/tests /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-deccad69-db9d6340/tempworkdir2 6  > __res
Running test command:
/home/ubuntu/spr-fast/tools/grep-test.py /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-deccad69-db9d6340/tempworkdir2/src /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-deccad69-db9d6340/tempworkdir2/tests /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-deccad69-db9d6340/tempworkdir2 9  > __res
Running test command:
/home/ubuntu/spr-fast/tools/grep-test.py /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-deccad69-db9d6340/tempworkdir2/src /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-deccad69-db9d6340/tempworkdir2/tests /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-deccad69-db9d6340/tempworkdir2 11  > __res
Running test command:
/home/ubuntu/spr-fast/tools/grep-test.py /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-deccad69-db9d6340/tempworkdir2/src /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-deccad69-db9d6340/tempworkdir2/tests /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-deccad69-db9d6340/tempworkdir2 12  > __res
Running test command:
/home/ubuntu/spr-fast/tools/grep-test.py /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-deccad69-db9d6340/tempworkdir2/src /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-deccad69-db9d6340/tempworkdir2/tests /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-deccad69-db9d6340/tempworkdir2 13  > __res
Running test command:
/home/ubuntu/spr-fast/tools/grep-test.py /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-deccad69-db9d6340/tempworkdir2/src /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-deccad69-db9d6340/tempworkdir2/tests /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-deccad69-db9d6340/tempworkdir2 14  > __res
Running test command:
/home/ubuntu/spr-fast/tools/grep-test.py /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-deccad69-db9d6340/tempworkdir2/src /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-deccad69-db9d6340/tempworkdir2/tests /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-deccad69-db9d6340/tempworkdir2 15  > __res
Running test command:
/home/ubuntu/spr-fast/tools/grep-test.py /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-deccad69-db9d6340/tempworkdir2/src /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-deccad69-db9d6340/tempworkdir2/tests /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-deccad69-db9d6340/tempworkdir2 17  > __res
Running test command:
/home/ubuntu/spr-fast/tools/grep-test.py /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-deccad69-db9d6340/tempworkdir2/src /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-deccad69-db9d6340/tempworkdir2/tests /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-deccad69-db9d6340/tempworkdir2 18  > __res
Running test command:
/home/ubuntu/spr-fast/tools/grep-test.py /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-deccad69-db9d6340/tempworkdir2/src /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-deccad69-db9d6340/tempworkdir2/tests /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-deccad69-db9d6340/tempworkdir2 20  > __res
Running test command:
/home/ubuntu/spr-fast/tools/grep-test.py /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-deccad69-db9d6340/tempworkdir2/src /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-deccad69-db9d6340/tempworkdir2/tests /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-deccad69-db9d6340/tempworkdir2 22  > __res
Running test command:
/home/ubuntu/spr-fast/tools/grep-test.py /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-deccad69-db9d6340/tempworkdir2/src /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-deccad69-db9d6340/tempworkdir2/tests /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-deccad69-db9d6340/tempworkdir2 23  > __res
Running test command:
/home/ubuntu/spr-fast/tools/grep-test.py /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-deccad69-db9d6340/tempworkdir2/src /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-deccad69-db9d6340/tempworkdir2/tests /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-deccad69-db9d6340/tempworkdir2 25  > __res
Passed!
CondTester, Postprocessing instance id 2:
//src_file:src/search.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
/* search.c - searching subroutines using dfa, kwset and regex for grep.
   Copyright 1992, 1998, 2000, 2007, 2009-2010 Free Software Foundation, Inc.

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 3, or (at your option)
   any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program; if not, write to the Free Software
   Foundation, Inc., 51 Franklin Street - Fifth Floor, Boston, MA
   02110-1301, USA.  */

/* Written August 1992 by Mike Haertel. */

#include <config.h>

#include <sys/types.h>

#include "mbsupport.h"
#ifdef MBS_SUPPORT
/* We can handle multibyte strings. */
# include <wchar.h>
# include <wctype.h>
#endif

#include "system.h"
#include "grep.h"
#ifndef FGREP_PROGRAM
# include <regex.h>
# include "dfa.h"
#endif
#include "kwset.h"
#include "error.h"
#include "xalloc.h"
#ifdef HAVE_LIBPCRE
# include <pcre.h>
#endif

#define NCHAR (UCHAR_MAX + 1)

/* For -w, we also consider _ to be word constituent.  */
#define WCHAR(C) (ISALNUM(C) || (C) == '_')

/* KWset compiled pattern.  For Ecompile and Gcompile, we compile
   a list of strings, at least one of which is known to occur in
   any string matching the regexp. */
static kwset_t kwset;

static void
kwsinit (void)
{
  static char trans[NCHAR];
  int i;

  if (match_icase && MB_CUR_MAX == 1)
    {
      for (i = 0; i < NCHAR; ++i)
        trans[i] = TOLOWER (i);

      kwset = kwsalloc (trans);
    }
  else
    kwset = kwsalloc (NULL);

  
//Patch 0:
if ((!kwset) || (__is_neg(3, &(kwset), sizeof (kwset), &(i), sizeof (i), &(match_icase), sizeof (match_icase))))
    xalloc_die();

//CodeSeg 1:
}

#ifdef MBS_SUPPORT
/* Convert the *N-byte string, BEG, to lowercase, and write the
   NUL-terminated result into malloc'd storage.  Upon success, set *N
   to the length (in bytes) of the resulting string (not including the
   trailing NUL byte), and return a pointer to the lowercase string.
   Upon memory allocation failure, this function exits.

   Note that while this function returns a pointer to malloc'd storage,
   the caller must not free it, since this function retains a pointer
   to the buffer and reuses it on any subsequent call.  As a consequence,
   this function is not thread-safe.  */
static char *
mbtolower (const char *beg, size_t *n)
{
  static char *out;
  static size_t outalloc;
  size_t outlen, mb_cur_max;
  mbstate_t is, os;
  const char *end;
  char *p;

  if (*n > outalloc)
    {
      out = xrealloc (out, *n);
      outalloc = *n;
    }

  memset (&is, 0, sizeof (is));
  memset (&os, 0, sizeof (os));
  end = beg + *n;

  mb_cur_max = MB_CUR_MAX;
  p = out;
  outlen = 0;
  while (beg < end)
    {
      wchar_t wc;
      size_t mbclen = mbrtowc(&wc, beg, end - beg, &is);
      if (outlen + mb_cur_max >= outalloc)
        {
          out = x2nrealloc (out, &outalloc, 1);
          p = out + outlen;
        }

      if (mbclen == (size_t) -1 || mbclen == (size_t) -2 || mbclen == 0)
        {
          /* An invalid sequence, or a truncated multi-octet character.
             We treat it as a single-octet character.  */
          *p++ = *beg++;
          outlen++;
          memset (&is, 0, sizeof (is));
          memset (&os, 0, sizeof (os));
        }
      else
        {
          beg += mbclen;
          mbclen = wcrtomb (p, towlower ((wint_t) wc), &os);
          p += mbclen;
          outlen += mbclen;
        }
    }

  *n = p - out;
  *p++ = 0;
  return out;
}
#endif


#ifndef FGREP_PROGRAM
/* DFA compiled regexp. */
static struct dfa dfa;

/* The Regex compiled patterns.  */
static struct patterns
{
  /* Regex compiled regexp. */
  struct re_pattern_buffer regexbuf;
  struct re_registers regs; /* This is here on account of a BRAIN-DEAD
			       Q@#%!# library interface in regex.c.  */
} patterns0;

struct patterns *patterns;
size_t pcount;

void
dfaerror (char const *mesg)
{
  error (EXIT_TROUBLE, 0, "%s", mesg);
}

/* Number of compiled fixed strings known to exactly match the regexp.
   If kwsexec returns < kwset_exact_matches, then we don't need to
   call the regexp matcher at all. */
static int kwset_exact_matches;

static char const *
kwsincr_case (const char *must)
{
  const char *buf;
  size_t n;

  n = strlen (must);
#ifdef MBS_SUPPORT
  if (match_icase && MB_CUR_MAX > 1)
    buf = mbtolower (must, &n);
  else
#endif
    buf = must;
  return kwsincr (kwset, buf, n);
}

/* If the DFA turns out to have some set of fixed strings one of
   which must occur in the match, then we build a kwset matcher
   to find those strings, and thus quickly filter out impossible
   matches. */
static void
kwsmusts (void)
{
  struct dfamust const *dm;
  char const *err;

  if (dfa.musts)
    {
      kwsinit ();
      /* First, we compile in the substrings known to be exact
	 matches.  The kwset matcher will return the index
	 of the matching string that it chooses. */
      for (dm = dfa.musts; dm; dm = dm->next)
	{
	  if (!dm->exact)
	    continue;
	  ++kwset_exact_matches;
	  if ((err = kwsincr_case (dm->must)) != NULL)
	    error (EXIT_TROUBLE, 0, "%s", err);
	}
      /* Now, we compile the substrings that will require
	 the use of the regexp matcher.  */
      for (dm = dfa.musts; dm; dm = dm->next)
	{
	  if (dm->exact)
	    continue;
	  if ((err = kwsincr_case (dm->must)) != NULL)
	    error (EXIT_TROUBLE, 0, "%s", err);
	}
      if ((err = kwsprep (kwset)) != NULL)
	error (EXIT_TROUBLE, 0, "%s", err);
    }
}
#endif /* !FGREP_PROGRAM */

#ifdef MBS_SUPPORT

static bool
is_mb_middle(const char **good, const char *buf, const char *end)
{
  const char *p = *good;
  const char *prev = p;
  mbstate_t cur_state;

  /* TODO: can be optimized for UTF-8.  */
  memset(&cur_state, 0, sizeof(mbstate_t));
  while (p < buf)
    {
      size_t mbclen = mbrlen(p, end - p, &cur_state);

      /* Store the beginning of the previous complete multibyte character.  */
      if (mbclen != (size_t) -2)
        prev = p;

      if (mbclen == (size_t) -1 || mbclen == (size_t) -2 || mbclen == 0)
	{
	  /* An invalid sequence, or a truncated multibyte character.
	     We treat it as a single byte character.  */
	  mbclen = 1;
	}
      p += mbclen;
    }

  *good = prev;
  return p > buf;
}
#endif /* MBS_SUPPORT */

#if defined(GREP_PROGRAM) || defined(EGREP_PROGRAM)
#ifdef EGREP_PROGRAM
COMPILE_FCT(Ecompile)
{
  reg_syntax_t syntax_bits = RE_SYNTAX_POSIX_EGREP;
#else
/* No __VA_ARGS__ in C89.  So we have to do it this way.  */
static COMPILE_RET
GEAcompile (char const *pattern, size_t size, reg_syntax_t syntax_bits)
{
#endif /* EGREP_PROGRAM */
  const char *err;
  const char *p, *sep;
  size_t total = size;
  char *motif;

  if (match_icase)
    syntax_bits |= RE_ICASE;
  re_set_syntax (syntax_bits);
  dfasyntax (syntax_bits, match_icase, eolbyte);

  /* For GNU regex compiler we have to pass the patterns separately to detect
     errors like "[\nallo\n]\n".  The patterns here are "[", "allo" and "]"
     GNU regex should have raise a syntax error.  The same for backref, where
     the backref should have been local to each pattern.  */
  p = pattern;
  do
    {
      size_t len;
      sep = memchr (p, '\n', total);
      if (sep)
	{
	  len = sep - p;
	  sep++;
	  total -= (len + 1);
	}
      else
	{
	  len = total;
	  total = 0;
	}

      patterns = realloc (patterns, (pcount + 1) * sizeof (*patterns));
      if (patterns == NULL)
	error (EXIT_TROUBLE, errno, _("memory exhausted"));
      patterns[pcount] = patterns0;

      if ((err = re_compile_pattern (p, len,
				    &(patterns[pcount].regexbuf))) != NULL)
	error (EXIT_TROUBLE, 0, "%s", err);
      pcount++;

      p = sep;
    } while (sep && total != 0);

  /* In the match_words and match_lines cases, we use a different pattern
     for the DFA matcher that will quickly throw out cases that won't work.
     Then if DFA succeeds we do some hairy stuff using the regex matcher
     to decide whether the match should really count. */
  if (match_words || match_lines)
    {
      static char const line_beg_no_bk[] = "^(";
      static char const line_end_no_bk[] = ")$";
      static char const word_beg_no_bk[] = "(^|[^[:alnum:]_])(";
      static char const word_end_no_bk[] = ")([^[:alnum:]_]|$)";
#ifdef EGREP_PROGRAM
# define IF_BK(x, y) (y)
      char *n = xmalloc (sizeof word_beg_no_bk - 1 + size + sizeof word_end_no_bk);
#else
      static char const line_beg_bk[] = "^\\(";
      static char const line_end_bk[] = "\\)$";
      static char const word_beg_bk[] = "\\(^\\|[^[:alnum:]_]\\)\\(";
      static char const word_end_bk[] = "\\)\\([^[:alnum:]_]\\|$\\)";
      int bk = !(syntax_bits & RE_NO_BK_PARENS);
# define IF_BK(x, y) ((bk) ? (x) : (y))
      char *n = xmalloc (sizeof word_beg_bk - 1 + size + sizeof word_end_bk);
#endif /* EGREP_PROGRAM */

      strcpy (n, match_lines ? IF_BK(line_beg_bk, line_beg_no_bk)
			     : IF_BK(word_beg_bk, word_beg_no_bk));
      total = strlen(n);
      memcpy (n + total, pattern, size);
      total += size;
      strcpy (n + total, match_lines ? IF_BK(line_end_bk, line_end_no_bk)
				     : IF_BK(word_end_bk, word_end_no_bk));
      total += strlen (n + total);
      pattern = motif = n;
      size = total;
    }
  else
    motif = NULL;

  dfacomp (pattern, size, &dfa, 1);
  kwsmusts ();

  free(motif);
}

#ifndef EGREP_PROGRAM
COMPILE_FCT(Gcompile)
{
  return GEAcompile (pattern, size,
		     RE_SYNTAX_GREP | RE_HAT_LISTS_NOT_NEWLINE);
}

COMPILE_FCT(Acompile)
{
  return GEAcompile (pattern, size, RE_SYNTAX_AWK);
}

COMPILE_FCT(Ecompile)
{
  return GEAcompile (pattern, size, RE_SYNTAX_POSIX_EGREP);
}
#endif /* !EGREP_PROGRAM */

EXECUTE_FCT(EGexecute)
{
  char const *buflim, *beg, *end, *match, *best_match, *mb_start;
  char eol = eolbyte;
  int backref, start, len, best_len;
  struct kwsmatch kwsm;
  size_t i, ret_val;
#ifdef MBS_SUPPORT
  if (MB_CUR_MAX > 1)
    {
      if (match_icase)
        {
          /* mbtolower adds a NUL byte at the end.  That will provide
	     space for the sentinel byte dfaexec may add.  */
          char *case_buf = mbtolower (buf, &size);
	  if (start_ptr)
	    start_ptr = case_buf + (start_ptr - buf);
          buf = case_buf;
        }
    }
#endif /* MBS_SUPPORT */

  mb_start = buf;
  buflim = buf + size;

  for (beg = end = buf; end < buflim; beg = end)
    {
      if (!start_ptr)
	{
	  /* We don't care about an exact match.  */
	  if (kwset)
	    {
	      /* Find a possible match using the KWset matcher. */
	      size_t offset = kwsexec (kwset, beg, buflim - beg, &kwsm);
	      if (offset == (size_t) -1)
		goto failure;
	      beg += offset;
	      /* Narrow down to the line containing the candidate, and
		 run it through DFA. */
	      if ((end = memchr(beg, eol, buflim - beg)) != NULL)
	        end++;
              else
                end = buflim;
	      match = beg;
	      while (beg > buf && beg[-1] != eol)
		--beg;
	      if (kwsm.index < kwset_exact_matches)
                {
#ifdef MBS_SUPPORT
                  if (mb_start < beg)
                    mb_start = beg;
                  if (MB_CUR_MAX == 1 || !is_mb_middle (&mb_start, match, buflim))
#endif
                    goto success;
                }
	      if (dfaexec (&dfa, beg, (char *) end, 0, NULL, &backref) == NULL)
		continue;
	    }
	  else
	    {
	      /* No good fixed strings; start with DFA. */
	      char const *next_beg = dfaexec (&dfa, beg, (char *) buflim,
					      0, NULL, &backref);
	      if (next_beg == NULL)
		break;
	      /* Narrow down to the line we've found. */
	      beg = next_beg;
	      if ((end = memchr(beg, eol, buflim - beg)) != NULL)
	        end++;
              else
                end = buflim;
	      while (beg > buf && beg[-1] != eol)
		--beg;
	    }
	  /* Successful, no backreferences encountered! */
	  if (!backref)
	    goto success;
	}
      else
	{
	  /* We are looking for the leftmost (then longest) exact match.
	     We will go through the outer loop only once.  */
	  beg = start_ptr;
	  end = buflim;
	}

      /* If we've made it to this point, this means DFA has seen
	 a probable match, and we need to run it through Regex. */
      best_match = end;
      best_len = 0;
      for (i = 0; i < pcount; i++)
	{
	  patterns[i].regexbuf.not_eol = 0;
	  if (0 <= (start = re_search (&(patterns[i].regexbuf),
				       buf, end - buf - 1,
				       beg - buf, end - beg - 1,
				       &(patterns[i].regs))))
	    {
	      len = patterns[i].regs.end[0] - start;
	      match = buf + start;
	      if (match > best_match)
		continue;
	      if (start_ptr && !match_words)
		goto assess_pattern_match;
	      if ((!match_lines && !match_words)
		  || (match_lines && len == end - beg - 1))
		{
		  match = beg;
		  len = end - beg;
		  goto assess_pattern_match;
		}
	      /* If -w, check if the match aligns with word boundaries.
		 We do this iteratively because:
		 (a) the line may contain more than one occurence of the
		 pattern, and
		 (b) Several alternatives in the pattern might be valid at a
		 given point, and we may need to consider a shorter one to
		 find a word boundary.  */
	      if (match_words)
		while (match <= best_match)
		  {
		    if ((match == buf || !WCHAR ((unsigned char) match[-1]))
			&& (len == end - beg - 1
			    || !WCHAR ((unsigned char) match[len])))
		      goto assess_pattern_match;
		    if (len > 0)
		      {
			/* Try a shorter length anchored at the same place. */
			--len;
			patterns[i].regexbuf.not_eol = 1;
			len = re_match (&(patterns[i].regexbuf),
					buf, match + len - beg, match - buf,
					&(patterns[i].regs));
		      }
		    if (len <= 0)
		      {
			/* Try looking further on. */
			if (match == end - 1)
			  break;
			match++;
			patterns[i].regexbuf.not_eol = 0;
			start = re_search (&(patterns[i].regexbuf),
					   buf, end - buf - 1,
					   match - buf, end - match - 1,
					   &(patterns[i].regs));
			if (start < 0)
			  break;
			len = patterns[i].regs.end[0] - start;
			match = buf + start;
		      }
		  } /* while (match <= best_match) */
	      continue;
	    assess_pattern_match:
	      if (!start_ptr)
		{
		  /* Good enough for a non-exact match.
		     No need to look at further patterns, if any.  */
		  beg = match;
		  goto success_in_len;
		}
	      if (match < best_match || (match == best_match && len > best_len))
		{
		  /* Best exact match:  leftmost, then longest.  */
		  best_match = match;
		  best_len = len;
		}
	    } /* if re_search >= 0 */
	} /* for Regex patterns.  */
	if (best_match < end)
	  {
	    /* We have found an exact match.  We were just
	       waiting for the best one (leftmost then longest).  */
	    beg = best_match;
	    len = best_len;
	    goto success_in_len;
	  }
    } /* for (beg = end ..) */

 failure:
  ret_val = -1;
  goto out;

 success:
  len = end - beg;
 success_in_len:
  *match_size = len;
  ret_val = beg - buf;
 out:
  return ret_val;
}
#endif /* defined(GREP_PROGRAM) || defined(EGREP_PROGRAM) */

#if defined(GREP_PROGRAM) || defined(FGREP_PROGRAM)
COMPILE_FCT(Fcompile)
{
  char const *beg, *end, *lim, *err, *pat;
  size_t psize;

  kwsinit ();
  psize = size;
  if (match_icase && MB_CUR_MAX > 1)
    pat = mbtolower (pattern, &psize);
  else
    pat = pattern;

  beg = pat;
  do
    {
      for (lim = beg;; ++lim)
	{
	  end = lim;
	  if (lim >= pat + psize)
	    break;
	 if (*lim == '\n')
	   {
	     lim++;
	     break;
	   }
#if HAVE_DOS_FILE_CONTENTS
	 if (*lim == '\r' && lim + 1 < pat + psize && lim[1] == '\n')
	   {
	     lim += 2;
	     break;
	   }
#endif
	}

      if ((err = kwsincr (kwset, beg, end - beg)) != NULL)
	error (EXIT_TROUBLE, 0, "%s", err);
      beg = lim;
    }
  while (beg < pat + psize);

  if ((err = kwsprep (kwset)) != NULL)
    error (EXIT_TROUBLE, 0, "%s", err);
}

EXECUTE_FCT(Fexecute)
{
  char const *beg, *try, *end, *mb_start;
  size_t len;
  char eol = eolbyte;
  struct kwsmatch kwsmatch;
  size_t ret_val;
#ifdef MBS_SUPPORT
  if (MB_CUR_MAX > 1)
    {
      if (match_icase)
        {
          char *case_buf = mbtolower (buf, &size);
	  if (start_ptr)
	    start_ptr = case_buf + (start_ptr - buf);
          buf = case_buf;
        }
    }
#endif /* MBS_SUPPORT */

  for (mb_start = beg = start_ptr ? start_ptr : buf; beg <= buf + size; beg++)
    {
      size_t offset = kwsexec (kwset, beg, buf + size - beg, &kwsmatch);
      if (offset == (size_t) -1)
	goto failure;
#ifdef MBS_SUPPORT
      if (MB_CUR_MAX > 1 && is_mb_middle (&mb_start, beg + offset, buf + size))
        {
          beg = mb_start - 1;
          continue; /* It is a part of multibyte character.  */
        }
#endif /* MBS_SUPPORT */
      beg += offset;
      len = kwsmatch.size[0];
      if (start_ptr && !match_words)
	goto success_in_beg_and_len;
      if (match_lines)
	{
	  if (beg > buf && beg[-1] != eol)
	    continue;
	  if (beg + len < buf + size && beg[len] != eol)
	    continue;
	  goto success;
	}
      else if (match_words)
	for (try = beg; len; )
	  {
	    if (try > buf && WCHAR((unsigned char) try[-1]))
	      break;
	    if (try + len < buf + size && WCHAR((unsigned char) try[len]))
	      {
		offset = kwsexec (kwset, beg, --len, &kwsmatch);
		if (offset == (size_t) -1)
		  break;
		try = beg + offset;
		len = kwsmatch.size[0];
	      }
	    else if (!start_ptr)
	      goto success;
	    else
	      goto success_in_beg_and_len;
	  } /* for (try) */
      else
	goto success;
    } /* for (beg in buf) */

 failure:
  ret_val = -1;
  goto out;

 success:
  if ((end = memchr (beg + len, eol, (buf + size) - (beg + len))) != NULL)
    end++;
  else
    end = buf + size;
  while (buf < beg && beg[-1] != eol)
    --beg;
  len = end - beg;
 success_in_beg_and_len:
  *match_size = len;
  ret_val = beg - buf;
 out:
  return ret_val;
}
#endif /* defined(GREP_PROGRAM) || defined(FGREP_PROGRAM) */

#ifdef GREP_PROGRAM
#if HAVE_LIBPCRE
/* Compiled internal form of a Perl regular expression.  */
static pcre *cre;

/* Additional information about the pattern.  */
static pcre_extra *extra;
#endif

COMPILE_FCT(Pcompile)
{
#if !HAVE_LIBPCRE
  error (EXIT_TROUBLE, 0, "%s",
	 _("support for the -P option is not compiled into "
	   "this --disable-perl-regexp binary"));
#else
  int e;
  char const *ep;
  char *re = xmalloc (4 * size + 7);
  int flags = PCRE_MULTILINE | (match_icase ? PCRE_CASELESS : 0);
  char const *patlim = pattern + size;
  char *n = re;
  char const *p;
  char const *pnul;

  /* FIXME: Remove these restrictions.  */
  if (memchr(pattern, '\n', size))
    error (EXIT_TROUBLE, 0, _("the -P option only supports a single pattern"));

  *n = '\0';
  if (match_lines)
    strcpy (n, "^(");
  if (match_words)
    strcpy (n, "\\b(");
  n += strlen (n);

  /* The PCRE interface doesn't allow NUL bytes in the pattern, so
     replace each NUL byte in the pattern with the four characters
     "\000", removing a preceding backslash if there are an odd
     number of backslashes before the NUL.

     FIXME: This method does not work with some multibyte character
     encodings, notably Shift-JIS, where a multibyte character can end
     in a backslash byte.  */
  for (p = pattern; (pnul = memchr (p, '\0', patlim - p)); p = pnul + 1)
    {
      memcpy (n, p, pnul - p);
      n += pnul - p;
      for (p = pnul; pattern < p && p[-1] == '\\'; p--)
	continue;
      n -= (pnul - p) & 1;
      strcpy (n, "\\000");
      n += 4;
    }

  memcpy (n, p, patlim - p);
  n += patlim - p;
  *n = '\0';
  if (match_words)
    strcpy (n, ")\\b");
  if (match_lines)
    strcpy (n, ")$");

  cre = pcre_compile (re, flags, &ep, &e, pcre_maketables ());
  if (!cre)
    error (EXIT_TROUBLE, 0, "%s", ep);

  extra = pcre_study (cre, 0, &ep);
  if (ep)
    error (EXIT_TROUBLE, 0, "%s", ep);

  free (re);
#endif
}

EXECUTE_FCT(Pexecute)
{
#if !HAVE_LIBPCRE
  abort ();
  return -1;
#else
  /* This array must have at least two elements; everything after that
     is just for performance improvement in pcre_exec.  */
  int sub[300];

  const char *line_buf, *line_end, *line_next;
  int e = PCRE_ERROR_NOMATCH;
  ptrdiff_t start_ofs = start_ptr ? start_ptr - buf : 0;

  /* PCRE can't limit the matching to single lines, therefore we have to
     match each line in the buffer separately.  */
  for (line_next = buf;
       e == PCRE_ERROR_NOMATCH && line_next < buf + size;
       start_ofs -= line_next - line_buf)
    {
      line_buf = line_next;
      line_end = memchr (line_buf, eolbyte, (buf + size) - line_buf);
      if (line_end == NULL)
        line_next = line_end = buf + size;
      else
        line_next = line_end + 1;

      if (start_ptr && start_ptr >= line_end)
        continue;

      e = pcre_exec (cre, extra, line_buf, line_end - line_buf,
                     start_ofs < 0 ? 0 : start_ofs, 0,
                     sub, sizeof sub / sizeof *sub);
    }

  if (e <= 0)
    {
      switch (e)
	{
	case PCRE_ERROR_NOMATCH:
	  return -1;

	case PCRE_ERROR_NOMEMORY:
	  error (EXIT_TROUBLE, 0, _("memory exhausted"));

	default:
	  abort ();
	}
    }
  else
    {
      /* Narrow down to the line we've found.  */
      char const *beg = line_buf + sub[0];
      char const *end = line_buf + sub[1];
      char const *buflim = buf + size;
      char eol = eolbyte;
      if (!start_ptr)
	{
	  /* FIXME: The case when '\n' is not found indicates a bug:
	     Since grep is line oriented, the match should never contain
	     a newline, so there _must_ be a newline following.
	   */
	  if (!(end = memchr (end, eol, buflim - end)))
	    end = buflim;
	  else
	    end++;
	  while (buf < beg && beg[-1] != eol)
	    --beg;
	}

      *match_size = end - beg;
      return beg - buf;
    }
#endif
}

struct matcher const matchers[] = {
  { "default", Gcompile, EGexecute },
  { "grep",    Gcompile, EGexecute },
  { "egrep",   Ecompile, EGexecute },
  { "awk",     Acompile, EGexecute },
  { "fgrep",   Fcompile, Fexecute },
  { "perl",    Pcompile, Pexecute },
  { "", 0, 0 },
};
#endif /* GREP_PROGRAM */

Trying a synthesis expr 1
Skipping a synthesis:1
Trying a synthesis expr i == 0
Building:src at:
/home/ubuntu/spr-fast/tests/corebench/grep/grep-case-deccad69-db9d6340/tempworkdir2/srcVerifing Negative cases!
Running test command:
/home/ubuntu/spr-fast/tools/grep-test.py /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-deccad69-db9d6340/tempworkdir2/src /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-deccad69-db9d6340/tempworkdir2/tests /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-deccad69-db9d6340/tempworkdir2 0  > __res
Not passed!
Trying a synthesis expr match_icase == 0
Building:src at:
/home/ubuntu/spr-fast/tests/corebench/grep/grep-case-deccad69-db9d6340/tempworkdir2/srcVerifing Negative cases!
Running test command:
/home/ubuntu/spr-fast/tools/grep-test.py /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-deccad69-db9d6340/tempworkdir2/src /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-deccad69-db9d6340/tempworkdir2/tests /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-deccad69-db9d6340/tempworkdir2 0  > __res
Verifying positive cases
Running test command:
/home/ubuntu/spr-fast/tools/grep-test.py /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-deccad69-db9d6340/tempworkdir2/src /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-deccad69-db9d6340/tempworkdir2/tests /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-deccad69-db9d6340/tempworkdir2 3  > __res
Running test command:
/home/ubuntu/spr-fast/tools/grep-test.py /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-deccad69-db9d6340/tempworkdir2/src /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-deccad69-db9d6340/tempworkdir2/tests /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-deccad69-db9d6340/tempworkdir2 4  > __res
Running test command:
/home/ubuntu/spr-fast/tools/grep-test.py /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-deccad69-db9d6340/tempworkdir2/src /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-deccad69-db9d6340/tempworkdir2/tests /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-deccad69-db9d6340/tempworkdir2 5  > __res
Running test command:
/home/ubuntu/spr-fast/tools/grep-test.py /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-deccad69-db9d6340/tempworkdir2/src /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-deccad69-db9d6340/tempworkdir2/tests /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-deccad69-db9d6340/tempworkdir2 6  > __res
Running test command:
/home/ubuntu/spr-fast/tools/grep-test.py /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-deccad69-db9d6340/tempworkdir2/src /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-deccad69-db9d6340/tempworkdir2/tests /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-deccad69-db9d6340/tempworkdir2 9  > __res
Failed positive case 9
Not passed!
Trying a synthesis expr i != 256
Building:src at:
/home/ubuntu/spr-fast/tests/corebench/grep/grep-case-deccad69-db9d6340/tempworkdir2/srcVerifing Negative cases!
Running test command:
/home/ubuntu/spr-fast/tools/grep-test.py /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-deccad69-db9d6340/tempworkdir2/src /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-deccad69-db9d6340/tempworkdir2/tests /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-deccad69-db9d6340/tempworkdir2 0  > __res
Not passed!
Trying a synthesis expr match_icase != 1
Building:src at:
/home/ubuntu/spr-fast/tests/corebench/grep/grep-case-deccad69-db9d6340/tempworkdir2/srcVerifing Negative cases!
Running test command:
/home/ubuntu/spr-fast/tools/grep-test.py /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-deccad69-db9d6340/tempworkdir2/src /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-deccad69-db9d6340/tempworkdir2/tests /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-deccad69-db9d6340/tempworkdir2 0  > __res
Verifying positive cases
Running test command:
/home/ubuntu/spr-fast/tools/grep-test.py /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-deccad69-db9d6340/tempworkdir2/src /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-deccad69-db9d6340/tempworkdir2/tests /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-deccad69-db9d6340/tempworkdir2 9  > __res
Failed positive case 9
Not passed!
Initial synthesize failed, final attempt
Skipping two clauses!(1) &&(0)
Found a clause! (!kwset) 
Skipping a clause! (!kwset) 
Postprocessing failed!
a batched test job starts!
Building merged code:
src_file: src/search.c
full src: int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
/* search.c - searching subroutines using dfa, kwset and regex for grep.
   Copyright 1992, 1998, 2000, 2007, 2009-2010 Free Software Foundation, Inc.

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 3, or (at your option)
   any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program; if not, write to the Free Software
   Foundation, Inc., 51 Franklin Street - Fifth Floor, Boston, MA
   02110-1301, USA.  */

/* Written August 1992 by Mike Haertel. */

#include <config.h>

#include <sys/types.h>

#include "mbsupport.h"
#ifdef MBS_SUPPORT
/* We can handle multibyte strings. */
# include <wchar.h>
# include <wctype.h>
#endif

#include "system.h"
#include "grep.h"
#ifndef FGREP_PROGRAM
# include <regex.h>
# include "dfa.h"
#endif
#include "kwset.h"
#include "error.h"
#include "xalloc.h"
#ifdef HAVE_LIBPCRE
# include <pcre.h>
#endif

#define NCHAR (UCHAR_MAX + 1)

/* For -w, we also consider _ to be word constituent.  */
#define WCHAR(C) (ISALNUM(C) || (C) == '_')

/* KWset compiled pattern.  For Ecompile and Gcompile, we compile
   a list of strings, at least one of which is known to occur in
   any string matching the regexp. */
static kwset_t kwset;

static void
kwsinit (void)
{
  static char trans[NCHAR];
  int i;

  if (match_icase && MB_CUR_MAX == 1)
    {
      for (i = 0; i < NCHAR; ++i)
        trans[i] = TOLOWER (i);

      kwset = kwsalloc (trans);
    }
  else
    kwset = kwsalloc (NULL);

  if (!kwset)
    xalloc_die ();
}

#ifdef MBS_SUPPORT
/* Convert the *N-byte string, BEG, to lowercase, and write the
   NUL-terminated result into malloc'd storage.  Upon success, set *N
   to the length (in bytes) of the resulting string (not including the
   trailing NUL byte), and return a pointer to the lowercase string.
   Upon memory allocation failure, this function exits.

   Note that while this function returns a pointer to malloc'd storage,
   the caller must not free it, since this function retains a pointer
   to the buffer and reuses it on any subsequent call.  As a consequence,
   this function is not thread-safe.  */
static char *
mbtolower (const char *beg, size_t *n)
{
  static char *out;
  static size_t outalloc;
  size_t outlen, mb_cur_max;
  mbstate_t is, os;
  const char *end;
  char *p;

  if (*n > outalloc)
    {
      out = xrealloc (out, *n);
      outalloc = *n;
    }

  memset (&is, 0, sizeof (is));
  memset (&os, 0, sizeof (os));
  end = beg + *n;

  mb_cur_max = MB_CUR_MAX;
  p = out;
  outlen = 0;
  while (beg < end)
    {
      wchar_t wc;
      size_t mbclen = mbrtowc(&wc, beg, end - beg, &is);
      if (outlen + mb_cur_max >= outalloc)
        {
          out = x2nrealloc (out, &outalloc, 1);
          p = out + outlen;
        }

      if (mbclen == (size_t) -1 || mbclen == (size_t) -2 || mbclen == 0)
        {
          /* An invalid sequence, or a truncated multi-octet character.
             We treat it as a single-octet character.  */
          *p++ = *beg++;
          outlen++;
          memset (&is, 0, sizeof (is));
          memset (&os, 0, sizeof (os));
        }
      else
        {
          beg += mbclen;
          mbclen = wcrtomb (p, towlower ((wint_t) wc), &os);
          p += mbclen;
          outlen += mbclen;
        }
    }

  *n = p - out;
  *p++ = 0;
  return out;
}
#endif


#ifndef FGREP_PROGRAM
/* DFA compiled regexp. */
static struct dfa dfa;

/* The Regex compiled patterns.  */
static struct patterns
{
  /* Regex compiled regexp. */
  struct re_pattern_buffer regexbuf;
  struct re_registers regs; /* This is here on account of a BRAIN-DEAD
			       Q@#%!# library interface in regex.c.  */
} patterns0;

struct patterns *patterns;
size_t pcount;

void
dfaerror (char const *mesg)
{
  error (EXIT_TROUBLE, 0, "%s", mesg);
}

/* Number of compiled fixed strings known to exactly match the regexp.
   If kwsexec returns < kwset_exact_matches, then we don't need to
   call the regexp matcher at all. */
static int kwset_exact_matches;

static char const *
kwsincr_case (const char *must)
{
  const char *buf;
  size_t n;

  n = strlen (must);
#ifdef MBS_SUPPORT
  if (match_icase && MB_CUR_MAX > 1)
    buf = mbtolower (must, &n);
  else
#endif
    buf = must;
  return kwsincr (kwset, buf, n);
}

/* If the DFA turns out to have some set of fixed strings one of
   which must occur in the match, then we build a kwset matcher
   to find those strings, and thus quickly filter out impossible
   matches. */
static void
kwsmusts (void)
{
  struct dfamust const *dm;
  char const *err;

  if (dfa.musts)
    {
      kwsinit ();
      /* First, we compile in the substrings known to be exact
	 matches.  The kwset matcher will return the index
	 of the matching string that it chooses. */
      for (dm = dfa.musts; dm; dm = dm->next)
	{
	  if (!dm->exact)
	    continue;
	  ++kwset_exact_matches;
	  if ((err = kwsincr_case (dm->must)) != NULL)
	    error (EXIT_TROUBLE, 0, "%s", err);
	}
      /* Now, we compile the substrings that will require
	 the use of the regexp matcher.  */
      for (dm = dfa.musts; dm; dm = dm->next)
	{
	  if (dm->exact)
	    continue;
	  if ((err = kwsincr_case (dm->must)) != NULL)
	    error (EXIT_TROUBLE, 0, "%s", err);
	}
      if ((err = kwsprep (kwset)) != NULL)
	error (EXIT_TROUBLE, 0, "%s", err);
    }
}
#endif /* !FGREP_PROGRAM */

#ifdef MBS_SUPPORT

static bool
is_mb_middle(const char **good, const char *buf, const char *end)
{
  const char *p = *good;
  const char *prev = p;
  mbstate_t cur_state;

  /* TODO: can be optimized for UTF-8.  */
  memset(&cur_state, 0, sizeof(mbstate_t));
  while (p < buf)
    {
      size_t mbclen = mbrlen(p, end - p, &cur_state);

      /* Store the beginning of the previous complete multibyte character.  */
      //prophet generated patch
      if (__get_mutant()==0) {
      if ((mbclen != (size_t)-2) && !(__is_neg(6, &(mbclen), sizeof (mbclen), &(p), sizeof (p), &(prev), sizeof (prev), &(end), sizeof (end), &(buf), sizeof (buf), &(good), sizeof (good))))
          prev = p;
      }
      else if (__get_mutant()==1) {
      if ((mbclen != (size_t)-2) || (__is_neg(6, &(mbclen), sizeof (mbclen), &(p), sizeof (p), &(prev), sizeof (prev), &(end), sizeof (end), &(buf), sizeof (buf), &(good), sizeof (good))))
          prev = p;
      }

      if (mbclen == (size_t) -1 || mbclen == (size_t) -2 || mbclen == 0)
	{
	  /* An invalid sequence, or a truncated multibyte character.
	     We treat it as a single byte character.  */
	  mbclen = 1;
	}
      p += mbclen;
    }

  *good = prev;
  return p > buf;
}
#endif /* MBS_SUPPORT */

#if defined(GREP_PROGRAM) || defined(EGREP_PROGRAM)
#ifdef EGREP_PROGRAM
COMPILE_FCT(Ecompile)
{
  reg_syntax_t syntax_bits = RE_SYNTAX_POSIX_EGREP;
#else
/* No __VA_ARGS__ in C89.  So we have to do it this way.  */
static COMPILE_RET
GEAcompile (char const *pattern, size_t size, reg_syntax_t syntax_bits)
{
#endif /* EGREP_PROGRAM */
  const char *err;
  const char *p, *sep;
  size_t total = size;
  char *motif;

  if (match_icase)
    syntax_bits |= RE_ICASE;
  re_set_syntax (syntax_bits);
  dfasyntax (syntax_bits, match_icase, eolbyte);

  /* For GNU regex compiler we have to pass the patterns separately to detect
     errors like "[\nallo\n]\n".  The patterns here are "[", "allo" and "]"
     GNU regex should have raise a syntax error.  The same for backref, where
     the backref should have been local to each pattern.  */
  p = pattern;
  do
    {
      size_t len;
      sep = memchr (p, '\n', total);
      if (sep)
	{
	  len = sep - p;
	  sep++;
	  total -= (len + 1);
	}
      else
	{
	  len = total;
	  total = 0;
	}

      patterns = realloc (patterns, (pcount + 1) * sizeof (*patterns));
      if (patterns == NULL)
	error (EXIT_TROUBLE, errno, _("memory exhausted"));
      patterns[pcount] = patterns0;

      if ((err = re_compile_pattern (p, len,
				    &(patterns[pcount].regexbuf))) != NULL)
	error (EXIT_TROUBLE, 0, "%s", err);
      pcount++;

      p = sep;
    } while (sep && total != 0);

  /* In the match_words and match_lines cases, we use a different pattern
     for the DFA matcher that will quickly throw out cases that won't work.
     Then if DFA succeeds we do some hairy stuff using the regex matcher
     to decide whether the match should really count. */
  if (match_words || match_lines)
    {
      static char const line_beg_no_bk[] = "^(";
      static char const line_end_no_bk[] = ")$";
      static char const word_beg_no_bk[] = "(^|[^[:alnum:]_])(";
      static char const word_end_no_bk[] = ")([^[:alnum:]_]|$)";
#ifdef EGREP_PROGRAM
# define IF_BK(x, y) (y)
      char *n = xmalloc (sizeof word_beg_no_bk - 1 + size + sizeof word_end_no_bk);
#else
      static char const line_beg_bk[] = "^\\(";
      static char const line_end_bk[] = "\\)$";
      static char const word_beg_bk[] = "\\(^\\|[^[:alnum:]_]\\)\\(";
      static char const word_end_bk[] = "\\)\\([^[:alnum:]_]\\|$\\)";
      int bk = !(syntax_bits & RE_NO_BK_PARENS);
# define IF_BK(x, y) ((bk) ? (x) : (y))
      char *n = xmalloc (sizeof word_beg_bk - 1 + size + sizeof word_end_bk);
#endif /* EGREP_PROGRAM */

      strcpy (n, match_lines ? IF_BK(line_beg_bk, line_beg_no_bk)
			     : IF_BK(word_beg_bk, word_beg_no_bk));
      total = strlen(n);
      memcpy (n + total, pattern, size);
      total += size;
      strcpy (n + total, match_lines ? IF_BK(line_end_bk, line_end_no_bk)
				     : IF_BK(word_end_bk, word_end_no_bk));
      total += strlen (n + total);
      pattern = motif = n;
      size = total;
    }
  else
    motif = NULL;

  dfacomp (pattern, size, &dfa, 1);
  kwsmusts ();

  free(motif);
}

#ifndef EGREP_PROGRAM
COMPILE_FCT(Gcompile)
{
  return GEAcompile (pattern, size,
		     RE_SYNTAX_GREP | RE_HAT_LISTS_NOT_NEWLINE);
}

COMPILE_FCT(Acompile)
{
  return GEAcompile (pattern, size, RE_SYNTAX_AWK);
}

COMPILE_FCT(Ecompile)
{
  return GEAcompile (pattern, size, RE_SYNTAX_POSIX_EGREP);
}
#endif /* !EGREP_PROGRAM */

EXECUTE_FCT(EGexecute)
{
  char const *buflim, *beg, *end, *match, *best_match, *mb_start;
  char eol = eolbyte;
  int backref, start, len, best_len;
  struct kwsmatch kwsm;
  size_t i, ret_val;
#ifdef MBS_SUPPORT
  if (MB_CUR_MAX > 1)
    {
      if (match_icase)
        {
          /* mbtolower adds a NUL byte at the end.  That will provide
	     space for the sentinel byte dfaexec may add.  */
          char *case_buf = mbtolower (buf, &size);
	  if (start_ptr)
	    start_ptr = case_buf + (start_ptr - buf);
          buf = case_buf;
        }
    }
#endif /* MBS_SUPPORT */

  mb_start = buf;
  buflim = buf + size;

  for (beg = end = buf; end < buflim; beg = end)
    {
      if (!start_ptr)
	{
	  /* We don't care about an exact match.  */
	  if (kwset)
	    {
	      /* Find a possible match using the KWset matcher. */
	      size_t offset = kwsexec (kwset, beg, buflim - beg, &kwsm);
	      if (offset == (size_t) -1)
		goto failure;
	      beg += offset;
	      /* Narrow down to the line containing the candidate, and
		 run it through DFA. */
	      if ((end = memchr(beg, eol, buflim - beg)) != NULL)
	        end++;
              else
                end = buflim;
	      match = beg;
	      while (beg > buf && beg[-1] != eol)
		--beg;
	      if (kwsm.index < kwset_exact_matches)
                {
#ifdef MBS_SUPPORT
                  if (mb_start < beg)
                    mb_start = beg;
                  if (MB_CUR_MAX == 1 || !is_mb_middle (&mb_start, match, buflim))
#endif
                    goto success;
                }
	      if (dfaexec (&dfa, beg, (char *) end, 0, NULL, &backref) == NULL)
		continue;
	    }
	  else
	    {
	      /* No good fixed strings; start with DFA. */
	      char const *next_beg = dfaexec (&dfa, beg, (char *) buflim,
					      0, NULL, &backref);
	      if (next_beg == NULL)
		break;
	      /* Narrow down to the line we've found. */
	      beg = next_beg;
	      if ((end = memchr(beg, eol, buflim - beg)) != NULL)
	        end++;
              else
                end = buflim;
	      while (beg > buf && beg[-1] != eol)
		--beg;
	    }
	  /* Successful, no backreferences encountered! */
	  if (!backref)
	    goto success;
	}
      else
	{
	  /* We are looking for the leftmost (then longest) exact match.
	     We will go through the outer loop only once.  */
	  beg = start_ptr;
	  end = buflim;
	}

      /* If we've made it to this point, this means DFA has seen
	 a probable match, and we need to run it through Regex. */
      best_match = end;
      best_len = 0;
      for (i = 0; i < pcount; i++)
	{
	  patterns[i].regexbuf.not_eol = 0;
	  if (0 <= (start = re_search (&(patterns[i].regexbuf),
				       buf, end - buf - 1,
				       beg - buf, end - beg - 1,
				       &(patterns[i].regs))))
	    {
	      len = patterns[i].regs.end[0] - start;
	      match = buf + start;
	      if (match > best_match)
		continue;
	      if (start_ptr && !match_words)
		goto assess_pattern_match;
	      if ((!match_lines && !match_words)
		  || (match_lines && len == end - beg - 1))
		{
		  match = beg;
		  len = end - beg;
		  goto assess_pattern_match;
		}
	      /* If -w, check if the match aligns with word boundaries.
		 We do this iteratively because:
		 (a) the line may contain more than one occurence of the
		 pattern, and
		 (b) Several alternatives in the pattern might be valid at a
		 given point, and we may need to consider a shorter one to
		 find a word boundary.  */
	      if (match_words)
		while (match <= best_match)
		  {
		    if ((match == buf || !WCHAR ((unsigned char) match[-1]))
			&& (len == end - beg - 1
			    || !WCHAR ((unsigned char) match[len])))
		      goto assess_pattern_match;
		    if (len > 0)
		      {
			/* Try a shorter length anchored at the same place. */
			--len;
			patterns[i].regexbuf.not_eol = 1;
			len = re_match (&(patterns[i].regexbuf),
					buf, match + len - beg, match - buf,
					&(patterns[i].regs));
		      }
		    if (len <= 0)
		      {
			/* Try looking further on. */
			if (match == end - 1)
			  break;
			match++;
			patterns[i].regexbuf.not_eol = 0;
			start = re_search (&(patterns[i].regexbuf),
					   buf, end - buf - 1,
					   match - buf, end - match - 1,
					   &(patterns[i].regs));
			if (start < 0)
			  break;
			len = patterns[i].regs.end[0] - start;
			match = buf + start;
		      }
		  } /* while (match <= best_match) */
	      continue;
	    assess_pattern_match:
	      if (!start_ptr)
		{
		  /* Good enough for a non-exact match.
		     No need to look at further patterns, if any.  */
		  beg = match;
		  goto success_in_len;
		}
	      if (match < best_match || (match == best_match && len > best_len))
		{
		  /* Best exact match:  leftmost, then longest.  */
		  best_match = match;
		  best_len = len;
		}
	    } /* if re_search >= 0 */
	} /* for Regex patterns.  */
	if (best_match < end)
	  {
	    /* We have found an exact match.  We were just
	       waiting for the best one (leftmost then longest).  */
	    beg = best_match;
	    len = best_len;
	    goto success_in_len;
	  }
    } /* for (beg = end ..) */

 failure:
  ret_val = -1;
  goto out;

 success:
  len = end - beg;
 success_in_len:
  *match_size = len;
  ret_val = beg - buf;
 out:
  return ret_val;
}
#endif /* defined(GREP_PROGRAM) || defined(EGREP_PROGRAM) */

#if defined(GREP_PROGRAM) || defined(FGREP_PROGRAM)
COMPILE_FCT(Fcompile)
{
  char const *beg, *end, *lim, *err, *pat;
  size_t psize;

  kwsinit ();
  psize = size;
  if (match_icase && MB_CUR_MAX > 1)
    pat = mbtolower (pattern, &psize);
  else
    pat = pattern;

  beg = pat;
  do
    {
      for (lim = beg;; ++lim)
	{
	  end = lim;
	  if (lim >= pat + psize)
	    break;
	 if (*lim == '\n')
	   {
	     lim++;
	     break;
	   }
#if HAVE_DOS_FILE_CONTENTS
	 if (*lim == '\r' && lim + 1 < pat + psize && lim[1] == '\n')
	   {
	     lim += 2;
	     break;
	   }
#endif
	}

      if ((err = kwsincr (kwset, beg, end - beg)) != NULL)
	error (EXIT_TROUBLE, 0, "%s", err);
      beg = lim;
    }
  while (beg < pat + psize);

  if ((err = kwsprep (kwset)) != NULL)
    error (EXIT_TROUBLE, 0, "%s", err);
}

EXECUTE_FCT(Fexecute)
{
  char const *beg, *try, *end, *mb_start;
  size_t len;
  char eol = eolbyte;
  struct kwsmatch kwsmatch;
  size_t ret_val;
#ifdef MBS_SUPPORT
  if (MB_CUR_MAX > 1)
    {
      if (match_icase)
        {
          char *case_buf = mbtolower (buf, &size);
	  if (start_ptr)
	    start_ptr = case_buf + (start_ptr - buf);
          buf = case_buf;
        }
    }
#endif /* MBS_SUPPORT */

  for (mb_start = beg = start_ptr ? start_ptr : buf; beg <= buf + size; beg++)
    {
      size_t offset = kwsexec (kwset, beg, buf + size - beg, &kwsmatch);
      if (offset == (size_t) -1)
	goto failure;
#ifdef MBS_SUPPORT
      if (MB_CUR_MAX > 1 && is_mb_middle (&mb_start, beg + offset, buf + size))
        {
          beg = mb_start - 1;
          continue; /* It is a part of multibyte character.  */
        }
#endif /* MBS_SUPPORT */
      beg += offset;
      len = kwsmatch.size[0];
      if (start_ptr && !match_words)
	goto success_in_beg_and_len;
      if (match_lines)
	{
	  if (beg > buf && beg[-1] != eol)
	    continue;
	  if (beg + len < buf + size && beg[len] != eol)
	    continue;
	  goto success;
	}
      else if (match_words)
	for (try = beg; len; )
	  {
	    if (try > buf && WCHAR((unsigned char) try[-1]))
	      break;
	    if (try + len < buf + size && WCHAR((unsigned char) try[len]))
	      {
		offset = kwsexec (kwset, beg, --len, &kwsmatch);
		if (offset == (size_t) -1)
		  break;
		try = beg + offset;
		len = kwsmatch.size[0];
	      }
	    else if (!start_ptr)
	      goto success;
	    else
	      goto success_in_beg_and_len;
	  } /* for (try) */
      else
	goto success;
    } /* for (beg in buf) */

 failure:
  ret_val = -1;
  goto out;

 success:
  if ((end = memchr (beg + len, eol, (buf + size) - (beg + len))) != NULL)
    end++;
  else
    end = buf + size;
  while (buf < beg && beg[-1] != eol)
    --beg;
  len = end - beg;
 success_in_beg_and_len:
  *match_size = len;
  ret_val = beg - buf;
 out:
  return ret_val;
}
#endif /* defined(GREP_PROGRAM) || defined(FGREP_PROGRAM) */

#ifdef GREP_PROGRAM
#if HAVE_LIBPCRE
/* Compiled internal form of a Perl regular expression.  */
static pcre *cre;

/* Additional information about the pattern.  */
static pcre_extra *extra;
#endif

COMPILE_FCT(Pcompile)
{
#if !HAVE_LIBPCRE
  error (EXIT_TROUBLE, 0, "%s",
	 _("support for the -P option is not compiled into "
	   "this --disable-perl-regexp binary"));
#else
  int e;
  char const *ep;
  char *re = xmalloc (4 * size + 7);
  int flags = PCRE_MULTILINE | (match_icase ? PCRE_CASELESS : 0);
  char const *patlim = pattern + size;
  char *n = re;
  char const *p;
  char const *pnul;

  /* FIXME: Remove these restrictions.  */
  if (memchr(pattern, '\n', size))
    error (EXIT_TROUBLE, 0, _("the -P option only supports a single pattern"));

  *n = '\0';
  if (match_lines)
    strcpy (n, "^(");
  if (match_words)
    strcpy (n, "\\b(");
  n += strlen (n);

  /* The PCRE interface doesn't allow NUL bytes in the pattern, so
     replace each NUL byte in the pattern with the four characters
     "\000", removing a preceding backslash if there are an odd
     number of backslashes before the NUL.

     FIXME: This method does not work with some multibyte character
     encodings, notably Shift-JIS, where a multibyte character can end
     in a backslash byte.  */
  for (p = pattern; (pnul = memchr (p, '\0', patlim - p)); p = pnul + 1)
    {
      memcpy (n, p, pnul - p);
      n += pnul - p;
      for (p = pnul; pattern < p && p[-1] == '\\'; p--)
	continue;
      n -= (pnul - p) & 1;
      strcpy (n, "\\000");
      n += 4;
    }

  memcpy (n, p, patlim - p);
  n += patlim - p;
  *n = '\0';
  if (match_words)
    strcpy (n, ")\\b");
  if (match_lines)
    strcpy (n, ")$");

  cre = pcre_compile (re, flags, &ep, &e, pcre_maketables ());
  if (!cre)
    error (EXIT_TROUBLE, 0, "%s", ep);

  extra = pcre_study (cre, 0, &ep);
  if (ep)
    error (EXIT_TROUBLE, 0, "%s", ep);

  free (re);
#endif
}

EXECUTE_FCT(Pexecute)
{
#if !HAVE_LIBPCRE
  abort ();
  return -1;
#else
  /* This array must have at least two elements; everything after that
     is just for performance improvement in pcre_exec.  */
  int sub[300];

  const char *line_buf, *line_end, *line_next;
  int e = PCRE_ERROR_NOMATCH;
  ptrdiff_t start_ofs = start_ptr ? start_ptr - buf : 0;

  /* PCRE can't limit the matching to single lines, therefore we have to
     match each line in the buffer separately.  */
  for (line_next = buf;
       e == PCRE_ERROR_NOMATCH && line_next < buf + size;
       start_ofs -= line_next - line_buf)
    {
      line_buf = line_next;
      line_end = memchr (line_buf, eolbyte, (buf + size) - line_buf);
      if (line_end == NULL)
        line_next = line_end = buf + size;
      else
        line_next = line_end + 1;

      if (start_ptr && start_ptr >= line_end)
        continue;

      e = pcre_exec (cre, extra, line_buf, line_end - line_buf,
                     start_ofs < 0 ? 0 : start_ofs, 0,
                     sub, sizeof sub / sizeof *sub);
    }

  if (e <= 0)
    {
      switch (e)
	{
	case PCRE_ERROR_NOMATCH:
	  return -1;

	case PCRE_ERROR_NOMEMORY:
	  error (EXIT_TROUBLE, 0, _("memory exhausted"));

	default:
	  abort ();
	}
    }
  else
    {
      /* Narrow down to the line we've found.  */
      char const *beg = line_buf + sub[0];
      char const *end = line_buf + sub[1];
      char const *buflim = buf + size;
      char eol = eolbyte;
      if (!start_ptr)
	{
	  /* FIXME: The case when '\n' is not found indicates a bug:
	     Since grep is line oriented, the match should never contain
	     a newline, so there _must_ be a newline following.
	   */
	  if (!(end = memchr (end, eol, buflim - end)))
	    end = buflim;
	  else
	    end++;
	  while (buf < beg && beg[-1] != eol)
	    --beg;
	}

      *match_size = end - beg;
      return beg - buf;
    }
#endif
}

struct matcher const matchers[] = {
  { "default", Gcompile, EGexecute },
  { "grep",    Gcompile, EGexecute },
  { "egrep",   Ecompile, EGexecute },
  { "awk",     Acompile, EGexecute },
  { "fgrep",   Fcompile, Fexecute },
  { "perl",    Pcompile, Pexecute },
  { "", 0, 0 },
};
#endif /* GREP_PROGRAM */

Building:src at:
/home/ubuntu/spr-fast/tests/corebench/grep/grep-case-deccad69-db9d6340/tempworkdir2/srcMerged code building succ, going to invoke tester!
CondTester, Testing instance id 6:
//src_file:src/search.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
/* search.c - searching subroutines using dfa, kwset and regex for grep.
   Copyright 1992, 1998, 2000, 2007, 2009-2010 Free Software Foundation, Inc.

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 3, or (at your option)
   any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program; if not, write to the Free Software
   Foundation, Inc., 51 Franklin Street - Fifth Floor, Boston, MA
   02110-1301, USA.  */

/* Written August 1992 by Mike Haertel. */

#include <config.h>

#include <sys/types.h>

#include "mbsupport.h"
#ifdef MBS_SUPPORT
/* We can handle multibyte strings. */
# include <wchar.h>
# include <wctype.h>
#endif

#include "system.h"
#include "grep.h"
#ifndef FGREP_PROGRAM
# include <regex.h>
# include "dfa.h"
#endif
#include "kwset.h"
#include "error.h"
#include "xalloc.h"
#ifdef HAVE_LIBPCRE
# include <pcre.h>
#endif

#define NCHAR (UCHAR_MAX + 1)

/* For -w, we also consider _ to be word constituent.  */
#define WCHAR(C) (ISALNUM(C) || (C) == '_')

/* KWset compiled pattern.  For Ecompile and Gcompile, we compile
   a list of strings, at least one of which is known to occur in
   any string matching the regexp. */
static kwset_t kwset;

static void
kwsinit (void)
{
  static char trans[NCHAR];
  int i;

  if (match_icase && MB_CUR_MAX == 1)
    {
      for (i = 0; i < NCHAR; ++i)
        trans[i] = TOLOWER (i);

      kwset = kwsalloc (trans);
    }
  else
    kwset = kwsalloc (NULL);

  if (!kwset)
    xalloc_die ();
}

#ifdef MBS_SUPPORT
/* Convert the *N-byte string, BEG, to lowercase, and write the
   NUL-terminated result into malloc'd storage.  Upon success, set *N
   to the length (in bytes) of the resulting string (not including the
   trailing NUL byte), and return a pointer to the lowercase string.
   Upon memory allocation failure, this function exits.

   Note that while this function returns a pointer to malloc'd storage,
   the caller must not free it, since this function retains a pointer
   to the buffer and reuses it on any subsequent call.  As a consequence,
   this function is not thread-safe.  */
static char *
mbtolower (const char *beg, size_t *n)
{
  static char *out;
  static size_t outalloc;
  size_t outlen, mb_cur_max;
  mbstate_t is, os;
  const char *end;
  char *p;

  if (*n > outalloc)
    {
      out = xrealloc (out, *n);
      outalloc = *n;
    }

  memset (&is, 0, sizeof (is));
  memset (&os, 0, sizeof (os));
  end = beg + *n;

  mb_cur_max = MB_CUR_MAX;
  p = out;
  outlen = 0;
  while (beg < end)
    {
      wchar_t wc;
      size_t mbclen = mbrtowc(&wc, beg, end - beg, &is);
      if (outlen + mb_cur_max >= outalloc)
        {
          out = x2nrealloc (out, &outalloc, 1);
          p = out + outlen;
        }

      if (mbclen == (size_t) -1 || mbclen == (size_t) -2 || mbclen == 0)
        {
          /* An invalid sequence, or a truncated multi-octet character.
             We treat it as a single-octet character.  */
          *p++ = *beg++;
          outlen++;
          memset (&is, 0, sizeof (is));
          memset (&os, 0, sizeof (os));
        }
      else
        {
          beg += mbclen;
          mbclen = wcrtomb (p, towlower ((wint_t) wc), &os);
          p += mbclen;
          outlen += mbclen;
        }
    }

  *n = p - out;
  *p++ = 0;
  return out;
}
#endif


#ifndef FGREP_PROGRAM
/* DFA compiled regexp. */
static struct dfa dfa;

/* The Regex compiled patterns.  */
static struct patterns
{
  /* Regex compiled regexp. */
  struct re_pattern_buffer regexbuf;
  struct re_registers regs; /* This is here on account of a BRAIN-DEAD
			       Q@#%!# library interface in regex.c.  */
} patterns0;

struct patterns *patterns;
size_t pcount;

void
dfaerror (char const *mesg)
{
  error (EXIT_TROUBLE, 0, "%s", mesg);
}

/* Number of compiled fixed strings known to exactly match the regexp.
   If kwsexec returns < kwset_exact_matches, then we don't need to
   call the regexp matcher at all. */
static int kwset_exact_matches;

static char const *
kwsincr_case (const char *must)
{
  const char *buf;
  size_t n;

  n = strlen (must);
#ifdef MBS_SUPPORT
  if (match_icase && MB_CUR_MAX > 1)
    buf = mbtolower (must, &n);
  else
#endif
    buf = must;
  return kwsincr (kwset, buf, n);
}

/* If the DFA turns out to have some set of fixed strings one of
   which must occur in the match, then we build a kwset matcher
   to find those strings, and thus quickly filter out impossible
   matches. */
static void
kwsmusts (void)
{
  struct dfamust const *dm;
  char const *err;

  if (dfa.musts)
    {
      kwsinit ();
      /* First, we compile in the substrings known to be exact
	 matches.  The kwset matcher will return the index
	 of the matching string that it chooses. */
      for (dm = dfa.musts; dm; dm = dm->next)
	{
	  if (!dm->exact)
	    continue;
	  ++kwset_exact_matches;
	  if ((err = kwsincr_case (dm->must)) != NULL)
	    error (EXIT_TROUBLE, 0, "%s", err);
	}
      /* Now, we compile the substrings that will require
	 the use of the regexp matcher.  */
      for (dm = dfa.musts; dm; dm = dm->next)
	{
	  if (dm->exact)
	    continue;
	  if ((err = kwsincr_case (dm->must)) != NULL)
	    error (EXIT_TROUBLE, 0, "%s", err);
	}
      if ((err = kwsprep (kwset)) != NULL)
	error (EXIT_TROUBLE, 0, "%s", err);
    }
}
#endif /* !FGREP_PROGRAM */

#ifdef MBS_SUPPORT

static bool
is_mb_middle(const char **good, const char *buf, const char *end)
{
  const char *p = *good;
  const char *prev = p;
  mbstate_t cur_state;

  /* TODO: can be optimized for UTF-8.  */
  memset(&cur_state, 0, sizeof(mbstate_t));
  while (p < buf)
    {
      size_t mbclen = mbrlen(p, end - p, &cur_state);

      /* Store the beginning of the previous complete multibyte character.  */
      
//Patch 0:
if ((mbclen != (size_t)-2) && !(__is_neg(6, &(mbclen), sizeof (mbclen), &(p), sizeof (p), &(prev), sizeof (prev), &(end), sizeof (end), &(buf), sizeof (buf), &(good), sizeof (good))))
    prev = p;

//CodeSeg 1:

      if (mbclen == (size_t) -1 || mbclen == (size_t) -2 || mbclen == 0)
	{
	  /* An invalid sequence, or a truncated multibyte character.
	     We treat it as a single byte character.  */
	  mbclen = 1;
	}
      p += mbclen;
    }

  *good = prev;
  return p > buf;
}
#endif /* MBS_SUPPORT */

#if defined(GREP_PROGRAM) || defined(EGREP_PROGRAM)
#ifdef EGREP_PROGRAM
COMPILE_FCT(Ecompile)
{
  reg_syntax_t syntax_bits = RE_SYNTAX_POSIX_EGREP;
#else
/* No __VA_ARGS__ in C89.  So we have to do it this way.  */
static COMPILE_RET
GEAcompile (char const *pattern, size_t size, reg_syntax_t syntax_bits)
{
#endif /* EGREP_PROGRAM */
  const char *err;
  const char *p, *sep;
  size_t total = size;
  char *motif;

  if (match_icase)
    syntax_bits |= RE_ICASE;
  re_set_syntax (syntax_bits);
  dfasyntax (syntax_bits, match_icase, eolbyte);

  /* For GNU regex compiler we have to pass the patterns separately to detect
     errors like "[\nallo\n]\n".  The patterns here are "[", "allo" and "]"
     GNU regex should have raise a syntax error.  The same for backref, where
     the backref should have been local to each pattern.  */
  p = pattern;
  do
    {
      size_t len;
      sep = memchr (p, '\n', total);
      if (sep)
	{
	  len = sep - p;
	  sep++;
	  total -= (len + 1);
	}
      else
	{
	  len = total;
	  total = 0;
	}

      patterns = realloc (patterns, (pcount + 1) * sizeof (*patterns));
      if (patterns == NULL)
	error (EXIT_TROUBLE, errno, _("memory exhausted"));
      patterns[pcount] = patterns0;

      if ((err = re_compile_pattern (p, len,
				    &(patterns[pcount].regexbuf))) != NULL)
	error (EXIT_TROUBLE, 0, "%s", err);
      pcount++;

      p = sep;
    } while (sep && total != 0);

  /* In the match_words and match_lines cases, we use a different pattern
     for the DFA matcher that will quickly throw out cases that won't work.
     Then if DFA succeeds we do some hairy stuff using the regex matcher
     to decide whether the match should really count. */
  if (match_words || match_lines)
    {
      static char const line_beg_no_bk[] = "^(";
      static char const line_end_no_bk[] = ")$";
      static char const word_beg_no_bk[] = "(^|[^[:alnum:]_])(";
      static char const word_end_no_bk[] = ")([^[:alnum:]_]|$)";
#ifdef EGREP_PROGRAM
# define IF_BK(x, y) (y)
      char *n = xmalloc (sizeof word_beg_no_bk - 1 + size + sizeof word_end_no_bk);
#else
      static char const line_beg_bk[] = "^\\(";
      static char const line_end_bk[] = "\\)$";
      static char const word_beg_bk[] = "\\(^\\|[^[:alnum:]_]\\)\\(";
      static char const word_end_bk[] = "\\)\\([^[:alnum:]_]\\|$\\)";
      int bk = !(syntax_bits & RE_NO_BK_PARENS);
# define IF_BK(x, y) ((bk) ? (x) : (y))
      char *n = xmalloc (sizeof word_beg_bk - 1 + size + sizeof word_end_bk);
#endif /* EGREP_PROGRAM */

      strcpy (n, match_lines ? IF_BK(line_beg_bk, line_beg_no_bk)
			     : IF_BK(word_beg_bk, word_beg_no_bk));
      total = strlen(n);
      memcpy (n + total, pattern, size);
      total += size;
      strcpy (n + total, match_lines ? IF_BK(line_end_bk, line_end_no_bk)
				     : IF_BK(word_end_bk, word_end_no_bk));
      total += strlen (n + total);
      pattern = motif = n;
      size = total;
    }
  else
    motif = NULL;

  dfacomp (pattern, size, &dfa, 1);
  kwsmusts ();

  free(motif);
}

#ifndef EGREP_PROGRAM
COMPILE_FCT(Gcompile)
{
  return GEAcompile (pattern, size,
		     RE_SYNTAX_GREP | RE_HAT_LISTS_NOT_NEWLINE);
}

COMPILE_FCT(Acompile)
{
  return GEAcompile (pattern, size, RE_SYNTAX_AWK);
}

COMPILE_FCT(Ecompile)
{
  return GEAcompile (pattern, size, RE_SYNTAX_POSIX_EGREP);
}
#endif /* !EGREP_PROGRAM */

EXECUTE_FCT(EGexecute)
{
  char const *buflim, *beg, *end, *match, *best_match, *mb_start;
  char eol = eolbyte;
  int backref, start, len, best_len;
  struct kwsmatch kwsm;
  size_t i, ret_val;
#ifdef MBS_SUPPORT
  if (MB_CUR_MAX > 1)
    {
      if (match_icase)
        {
          /* mbtolower adds a NUL byte at the end.  That will provide
	     space for the sentinel byte dfaexec may add.  */
          char *case_buf = mbtolower (buf, &size);
	  if (start_ptr)
	    start_ptr = case_buf + (start_ptr - buf);
          buf = case_buf;
        }
    }
#endif /* MBS_SUPPORT */

  mb_start = buf;
  buflim = buf + size;

  for (beg = end = buf; end < buflim; beg = end)
    {
      if (!start_ptr)
	{
	  /* We don't care about an exact match.  */
	  if (kwset)
	    {
	      /* Find a possible match using the KWset matcher. */
	      size_t offset = kwsexec (kwset, beg, buflim - beg, &kwsm);
	      if (offset == (size_t) -1)
		goto failure;
	      beg += offset;
	      /* Narrow down to the line containing the candidate, and
		 run it through DFA. */
	      if ((end = memchr(beg, eol, buflim - beg)) != NULL)
	        end++;
              else
                end = buflim;
	      match = beg;
	      while (beg > buf && beg[-1] != eol)
		--beg;
	      if (kwsm.index < kwset_exact_matches)
                {
#ifdef MBS_SUPPORT
                  if (mb_start < beg)
                    mb_start = beg;
                  if (MB_CUR_MAX == 1 || !is_mb_middle (&mb_start, match, buflim))
#endif
                    goto success;
                }
	      if (dfaexec (&dfa, beg, (char *) end, 0, NULL, &backref) == NULL)
		continue;
	    }
	  else
	    {
	      /* No good fixed strings; start with DFA. */
	      char const *next_beg = dfaexec (&dfa, beg, (char *) buflim,
					      0, NULL, &backref);
	      if (next_beg == NULL)
		break;
	      /* Narrow down to the line we've found. */
	      beg = next_beg;
	      if ((end = memchr(beg, eol, buflim - beg)) != NULL)
	        end++;
              else
                end = buflim;
	      while (beg > buf && beg[-1] != eol)
		--beg;
	    }
	  /* Successful, no backreferences encountered! */
	  if (!backref)
	    goto success;
	}
      else
	{
	  /* We are looking for the leftmost (then longest) exact match.
	     We will go through the outer loop only once.  */
	  beg = start_ptr;
	  end = buflim;
	}

      /* If we've made it to this point, this means DFA has seen
	 a probable match, and we need to run it through Regex. */
      best_match = end;
      best_len = 0;
      for (i = 0; i < pcount; i++)
	{
	  patterns[i].regexbuf.not_eol = 0;
	  if (0 <= (start = re_search (&(patterns[i].regexbuf),
				       buf, end - buf - 1,
				       beg - buf, end - beg - 1,
				       &(patterns[i].regs))))
	    {
	      len = patterns[i].regs.end[0] - start;
	      match = buf + start;
	      if (match > best_match)
		continue;
	      if (start_ptr && !match_words)
		goto assess_pattern_match;
	      if ((!match_lines && !match_words)
		  || (match_lines && len == end - beg - 1))
		{
		  match = beg;
		  len = end - beg;
		  goto assess_pattern_match;
		}
	      /* If -w, check if the match aligns with word boundaries.
		 We do this iteratively because:
		 (a) the line may contain more than one occurence of the
		 pattern, and
		 (b) Several alternatives in the pattern might be valid at a
		 given point, and we may need to consider a shorter one to
		 find a word boundary.  */
	      if (match_words)
		while (match <= best_match)
		  {
		    if ((match == buf || !WCHAR ((unsigned char) match[-1]))
			&& (len == end - beg - 1
			    || !WCHAR ((unsigned char) match[len])))
		      goto assess_pattern_match;
		    if (len > 0)
		      {
			/* Try a shorter length anchored at the same place. */
			--len;
			patterns[i].regexbuf.not_eol = 1;
			len = re_match (&(patterns[i].regexbuf),
					buf, match + len - beg, match - buf,
					&(patterns[i].regs));
		      }
		    if (len <= 0)
		      {
			/* Try looking further on. */
			if (match == end - 1)
			  break;
			match++;
			patterns[i].regexbuf.not_eol = 0;
			start = re_search (&(patterns[i].regexbuf),
					   buf, end - buf - 1,
					   match - buf, end - match - 1,
					   &(patterns[i].regs));
			if (start < 0)
			  break;
			len = patterns[i].regs.end[0] - start;
			match = buf + start;
		      }
		  } /* while (match <= best_match) */
	      continue;
	    assess_pattern_match:
	      if (!start_ptr)
		{
		  /* Good enough for a non-exact match.
		     No need to look at further patterns, if any.  */
		  beg = match;
		  goto success_in_len;
		}
	      if (match < best_match || (match == best_match && len > best_len))
		{
		  /* Best exact match:  leftmost, then longest.  */
		  best_match = match;
		  best_len = len;
		}
	    } /* if re_search >= 0 */
	} /* for Regex patterns.  */
	if (best_match < end)
	  {
	    /* We have found an exact match.  We were just
	       waiting for the best one (leftmost then longest).  */
	    beg = best_match;
	    len = best_len;
	    goto success_in_len;
	  }
    } /* for (beg = end ..) */

 failure:
  ret_val = -1;
  goto out;

 success:
  len = end - beg;
 success_in_len:
  *match_size = len;
  ret_val = beg - buf;
 out:
  return ret_val;
}
#endif /* defined(GREP_PROGRAM) || defined(EGREP_PROGRAM) */

#if defined(GREP_PROGRAM) || defined(FGREP_PROGRAM)
COMPILE_FCT(Fcompile)
{
  char const *beg, *end, *lim, *err, *pat;
  size_t psize;

  kwsinit ();
  psize = size;
  if (match_icase && MB_CUR_MAX > 1)
    pat = mbtolower (pattern, &psize);
  else
    pat = pattern;

  beg = pat;
  do
    {
      for (lim = beg;; ++lim)
	{
	  end = lim;
	  if (lim >= pat + psize)
	    break;
	 if (*lim == '\n')
	   {
	     lim++;
	     break;
	   }
#if HAVE_DOS_FILE_CONTENTS
	 if (*lim == '\r' && lim + 1 < pat + psize && lim[1] == '\n')
	   {
	     lim += 2;
	     break;
	   }
#endif
	}

      if ((err = kwsincr (kwset, beg, end - beg)) != NULL)
	error (EXIT_TROUBLE, 0, "%s", err);
      beg = lim;
    }
  while (beg < pat + psize);

  if ((err = kwsprep (kwset)) != NULL)
    error (EXIT_TROUBLE, 0, "%s", err);
}

EXECUTE_FCT(Fexecute)
{
  char const *beg, *try, *end, *mb_start;
  size_t len;
  char eol = eolbyte;
  struct kwsmatch kwsmatch;
  size_t ret_val;
#ifdef MBS_SUPPORT
  if (MB_CUR_MAX > 1)
    {
      if (match_icase)
        {
          char *case_buf = mbtolower (buf, &size);
	  if (start_ptr)
	    start_ptr = case_buf + (start_ptr - buf);
          buf = case_buf;
        }
    }
#endif /* MBS_SUPPORT */

  for (mb_start = beg = start_ptr ? start_ptr : buf; beg <= buf + size; beg++)
    {
      size_t offset = kwsexec (kwset, beg, buf + size - beg, &kwsmatch);
      if (offset == (size_t) -1)
	goto failure;
#ifdef MBS_SUPPORT
      if (MB_CUR_MAX > 1 && is_mb_middle (&mb_start, beg + offset, buf + size))
        {
          beg = mb_start - 1;
          continue; /* It is a part of multibyte character.  */
        }
#endif /* MBS_SUPPORT */
      beg += offset;
      len = kwsmatch.size[0];
      if (start_ptr && !match_words)
	goto success_in_beg_and_len;
      if (match_lines)
	{
	  if (beg > buf && beg[-1] != eol)
	    continue;
	  if (beg + len < buf + size && beg[len] != eol)
	    continue;
	  goto success;
	}
      else if (match_words)
	for (try = beg; len; )
	  {
	    if (try > buf && WCHAR((unsigned char) try[-1]))
	      break;
	    if (try + len < buf + size && WCHAR((unsigned char) try[len]))
	      {
		offset = kwsexec (kwset, beg, --len, &kwsmatch);
		if (offset == (size_t) -1)
		  break;
		try = beg + offset;
		len = kwsmatch.size[0];
	      }
	    else if (!start_ptr)
	      goto success;
	    else
	      goto success_in_beg_and_len;
	  } /* for (try) */
      else
	goto success;
    } /* for (beg in buf) */

 failure:
  ret_val = -1;
  goto out;

 success:
  if ((end = memchr (beg + len, eol, (buf + size) - (beg + len))) != NULL)
    end++;
  else
    end = buf + size;
  while (buf < beg && beg[-1] != eol)
    --beg;
  len = end - beg;
 success_in_beg_and_len:
  *match_size = len;
  ret_val = beg - buf;
 out:
  return ret_val;
}
#endif /* defined(GREP_PROGRAM) || defined(FGREP_PROGRAM) */

#ifdef GREP_PROGRAM
#if HAVE_LIBPCRE
/* Compiled internal form of a Perl regular expression.  */
static pcre *cre;

/* Additional information about the pattern.  */
static pcre_extra *extra;
#endif

COMPILE_FCT(Pcompile)
{
#if !HAVE_LIBPCRE
  error (EXIT_TROUBLE, 0, "%s",
	 _("support for the -P option is not compiled into "
	   "this --disable-perl-regexp binary"));
#else
  int e;
  char const *ep;
  char *re = xmalloc (4 * size + 7);
  int flags = PCRE_MULTILINE | (match_icase ? PCRE_CASELESS : 0);
  char const *patlim = pattern + size;
  char *n = re;
  char const *p;
  char const *pnul;

  /* FIXME: Remove these restrictions.  */
  if (memchr(pattern, '\n', size))
    error (EXIT_TROUBLE, 0, _("the -P option only supports a single pattern"));

  *n = '\0';
  if (match_lines)
    strcpy (n, "^(");
  if (match_words)
    strcpy (n, "\\b(");
  n += strlen (n);

  /* The PCRE interface doesn't allow NUL bytes in the pattern, so
     replace each NUL byte in the pattern with the four characters
     "\000", removing a preceding backslash if there are an odd
     number of backslashes before the NUL.

     FIXME: This method does not work with some multibyte character
     encodings, notably Shift-JIS, where a multibyte character can end
     in a backslash byte.  */
  for (p = pattern; (pnul = memchr (p, '\0', patlim - p)); p = pnul + 1)
    {
      memcpy (n, p, pnul - p);
      n += pnul - p;
      for (p = pnul; pattern < p && p[-1] == '\\'; p--)
	continue;
      n -= (pnul - p) & 1;
      strcpy (n, "\\000");
      n += 4;
    }

  memcpy (n, p, patlim - p);
  n += patlim - p;
  *n = '\0';
  if (match_words)
    strcpy (n, ")\\b");
  if (match_lines)
    strcpy (n, ")$");

  cre = pcre_compile (re, flags, &ep, &e, pcre_maketables ());
  if (!cre)
    error (EXIT_TROUBLE, 0, "%s", ep);

  extra = pcre_study (cre, 0, &ep);
  if (ep)
    error (EXIT_TROUBLE, 0, "%s", ep);

  free (re);
#endif
}

EXECUTE_FCT(Pexecute)
{
#if !HAVE_LIBPCRE
  abort ();
  return -1;
#else
  /* This array must have at least two elements; everything after that
     is just for performance improvement in pcre_exec.  */
  int sub[300];

  const char *line_buf, *line_end, *line_next;
  int e = PCRE_ERROR_NOMATCH;
  ptrdiff_t start_ofs = start_ptr ? start_ptr - buf : 0;

  /* PCRE can't limit the matching to single lines, therefore we have to
     match each line in the buffer separately.  */
  for (line_next = buf;
       e == PCRE_ERROR_NOMATCH && line_next < buf + size;
       start_ofs -= line_next - line_buf)
    {
      line_buf = line_next;
      line_end = memchr (line_buf, eolbyte, (buf + size) - line_buf);
      if (line_end == NULL)
        line_next = line_end = buf + size;
      else
        line_next = line_end + 1;

      if (start_ptr && start_ptr >= line_end)
        continue;

      e = pcre_exec (cre, extra, line_buf, line_end - line_buf,
                     start_ofs < 0 ? 0 : start_ofs, 0,
                     sub, sizeof sub / sizeof *sub);
    }

  if (e <= 0)
    {
      switch (e)
	{
	case PCRE_ERROR_NOMATCH:
	  return -1;

	case PCRE_ERROR_NOMEMORY:
	  error (EXIT_TROUBLE, 0, _("memory exhausted"));

	default:
	  abort ();
	}
    }
  else
    {
      /* Narrow down to the line we've found.  */
      char const *beg = line_buf + sub[0];
      char const *end = line_buf + sub[1];
      char const *buflim = buf + size;
      char eol = eolbyte;
      if (!start_ptr)
	{
	  /* FIXME: The case when '\n' is not found indicates a bug:
	     Since grep is line oriented, the match should never contain
	     a newline, so there _must_ be a newline following.
	   */
	  if (!(end = memchr (end, eol, buflim - end)))
	    end = buflim;
	  else
	    end++;
	  while (buf < beg && beg[-1] != eol)
	    --beg;
	}

      *match_size = end - beg;
      return beg - buf;
    }
#endif
}

struct matcher const matchers[] = {
  { "default", Gcompile, EGexecute },
  { "grep",    Gcompile, EGexecute },
  { "egrep",   Ecompile, EGexecute },
  { "awk",     Acompile, EGexecute },
  { "fgrep",   Fcompile, Fexecute },
  { "perl",    Pcompile, Pexecute },
  { "", 0, 0 },
};
#endif /* GREP_PROGRAM */

Testing negative cases!
Testing 0 (with abstract condition) ENVIS_NEG
Iteration 0
Running test command:
/home/ubuntu/spr-fast/tools/grep-test.py /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-deccad69-db9d6340/tempworkdir2/src /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-deccad69-db9d6340/tempworkdir2/tests /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-deccad69-db9d6340/tempworkdir2 0  > __res
Opening:/home/ubuntu/spr-fast/tests/corebench/grep/grep-case-deccad69-db9d6340/tempworkdir2/neg.tmp!
NegativeBRANCH RECORD/home/ubuntu/spr-fast/tests/corebench/grep/grep-case-deccad69-db9d6340/tempworkdir2/neg.tmp!
APPENDING TO ISNEG:/home/ubuntu/spr-fast/tests/corebench/grep/grep-case-deccad69-db9d6340/tempworkdir2/neg.tmp!
Running test command:
/home/ubuntu/spr-fast/tools/grep-test.py /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-deccad69-db9d6340/tempworkdir2/src /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-deccad69-db9d6340/tempworkdir2/tests /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-deccad69-db9d6340/tempworkdir2 0  > __res
CondTester, Testing instance id 7:
//src_file:src/search.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
/* search.c - searching subroutines using dfa, kwset and regex for grep.
   Copyright 1992, 1998, 2000, 2007, 2009-2010 Free Software Foundation, Inc.

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 3, or (at your option)
   any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program; if not, write to the Free Software
   Foundation, Inc., 51 Franklin Street - Fifth Floor, Boston, MA
   02110-1301, USA.  */

/* Written August 1992 by Mike Haertel. */

#include <config.h>

#include <sys/types.h>

#include "mbsupport.h"
#ifdef MBS_SUPPORT
/* We can handle multibyte strings. */
# include <wchar.h>
# include <wctype.h>
#endif

#include "system.h"
#include "grep.h"
#ifndef FGREP_PROGRAM
# include <regex.h>
# include "dfa.h"
#endif
#include "kwset.h"
#include "error.h"
#include "xalloc.h"
#ifdef HAVE_LIBPCRE
# include <pcre.h>
#endif

#define NCHAR (UCHAR_MAX + 1)

/* For -w, we also consider _ to be word constituent.  */
#define WCHAR(C) (ISALNUM(C) || (C) == '_')

/* KWset compiled pattern.  For Ecompile and Gcompile, we compile
   a list of strings, at least one of which is known to occur in
   any string matching the regexp. */
static kwset_t kwset;

static void
kwsinit (void)
{
  static char trans[NCHAR];
  int i;

  if (match_icase && MB_CUR_MAX == 1)
    {
      for (i = 0; i < NCHAR; ++i)
        trans[i] = TOLOWER (i);

      kwset = kwsalloc (trans);
    }
  else
    kwset = kwsalloc (NULL);

  if (!kwset)
    xalloc_die ();
}

#ifdef MBS_SUPPORT
/* Convert the *N-byte string, BEG, to lowercase, and write the
   NUL-terminated result into malloc'd storage.  Upon success, set *N
   to the length (in bytes) of the resulting string (not including the
   trailing NUL byte), and return a pointer to the lowercase string.
   Upon memory allocation failure, this function exits.

   Note that while this function returns a pointer to malloc'd storage,
   the caller must not free it, since this function retains a pointer
   to the buffer and reuses it on any subsequent call.  As a consequence,
   this function is not thread-safe.  */
static char *
mbtolower (const char *beg, size_t *n)
{
  static char *out;
  static size_t outalloc;
  size_t outlen, mb_cur_max;
  mbstate_t is, os;
  const char *end;
  char *p;

  if (*n > outalloc)
    {
      out = xrealloc (out, *n);
      outalloc = *n;
    }

  memset (&is, 0, sizeof (is));
  memset (&os, 0, sizeof (os));
  end = beg + *n;

  mb_cur_max = MB_CUR_MAX;
  p = out;
  outlen = 0;
  while (beg < end)
    {
      wchar_t wc;
      size_t mbclen = mbrtowc(&wc, beg, end - beg, &is);
      if (outlen + mb_cur_max >= outalloc)
        {
          out = x2nrealloc (out, &outalloc, 1);
          p = out + outlen;
        }

      if (mbclen == (size_t) -1 || mbclen == (size_t) -2 || mbclen == 0)
        {
          /* An invalid sequence, or a truncated multi-octet character.
             We treat it as a single-octet character.  */
          *p++ = *beg++;
          outlen++;
          memset (&is, 0, sizeof (is));
          memset (&os, 0, sizeof (os));
        }
      else
        {
          beg += mbclen;
          mbclen = wcrtomb (p, towlower ((wint_t) wc), &os);
          p += mbclen;
          outlen += mbclen;
        }
    }

  *n = p - out;
  *p++ = 0;
  return out;
}
#endif


#ifndef FGREP_PROGRAM
/* DFA compiled regexp. */
static struct dfa dfa;

/* The Regex compiled patterns.  */
static struct patterns
{
  /* Regex compiled regexp. */
  struct re_pattern_buffer regexbuf;
  struct re_registers regs; /* This is here on account of a BRAIN-DEAD
			       Q@#%!# library interface in regex.c.  */
} patterns0;

struct patterns *patterns;
size_t pcount;

void
dfaerror (char const *mesg)
{
  error (EXIT_TROUBLE, 0, "%s", mesg);
}

/* Number of compiled fixed strings known to exactly match the regexp.
   If kwsexec returns < kwset_exact_matches, then we don't need to
   call the regexp matcher at all. */
static int kwset_exact_matches;

static char const *
kwsincr_case (const char *must)
{
  const char *buf;
  size_t n;

  n = strlen (must);
#ifdef MBS_SUPPORT
  if (match_icase && MB_CUR_MAX > 1)
    buf = mbtolower (must, &n);
  else
#endif
    buf = must;
  return kwsincr (kwset, buf, n);
}

/* If the DFA turns out to have some set of fixed strings one of
   which must occur in the match, then we build a kwset matcher
   to find those strings, and thus quickly filter out impossible
   matches. */
static void
kwsmusts (void)
{
  struct dfamust const *dm;
  char const *err;

  if (dfa.musts)
    {
      kwsinit ();
      /* First, we compile in the substrings known to be exact
	 matches.  The kwset matcher will return the index
	 of the matching string that it chooses. */
      for (dm = dfa.musts; dm; dm = dm->next)
	{
	  if (!dm->exact)
	    continue;
	  ++kwset_exact_matches;
	  if ((err = kwsincr_case (dm->must)) != NULL)
	    error (EXIT_TROUBLE, 0, "%s", err);
	}
      /* Now, we compile the substrings that will require
	 the use of the regexp matcher.  */
      for (dm = dfa.musts; dm; dm = dm->next)
	{
	  if (dm->exact)
	    continue;
	  if ((err = kwsincr_case (dm->must)) != NULL)
	    error (EXIT_TROUBLE, 0, "%s", err);
	}
      if ((err = kwsprep (kwset)) != NULL)
	error (EXIT_TROUBLE, 0, "%s", err);
    }
}
#endif /* !FGREP_PROGRAM */

#ifdef MBS_SUPPORT

static bool
is_mb_middle(const char **good, const char *buf, const char *end)
{
  const char *p = *good;
  const char *prev = p;
  mbstate_t cur_state;

  /* TODO: can be optimized for UTF-8.  */
  memset(&cur_state, 0, sizeof(mbstate_t));
  while (p < buf)
    {
      size_t mbclen = mbrlen(p, end - p, &cur_state);

      /* Store the beginning of the previous complete multibyte character.  */
      
//Patch 0:
if ((mbclen != (size_t)-2) || (__is_neg(6, &(mbclen), sizeof (mbclen), &(p), sizeof (p), &(prev), sizeof (prev), &(end), sizeof (end), &(buf), sizeof (buf), &(good), sizeof (good))))
    prev = p;

//CodeSeg 1:

      if (mbclen == (size_t) -1 || mbclen == (size_t) -2 || mbclen == 0)
	{
	  /* An invalid sequence, or a truncated multibyte character.
	     We treat it as a single byte character.  */
	  mbclen = 1;
	}
      p += mbclen;
    }

  *good = prev;
  return p > buf;
}
#endif /* MBS_SUPPORT */

#if defined(GREP_PROGRAM) || defined(EGREP_PROGRAM)
#ifdef EGREP_PROGRAM
COMPILE_FCT(Ecompile)
{
  reg_syntax_t syntax_bits = RE_SYNTAX_POSIX_EGREP;
#else
/* No __VA_ARGS__ in C89.  So we have to do it this way.  */
static COMPILE_RET
GEAcompile (char const *pattern, size_t size, reg_syntax_t syntax_bits)
{
#endif /* EGREP_PROGRAM */
  const char *err;
  const char *p, *sep;
  size_t total = size;
  char *motif;

  if (match_icase)
    syntax_bits |= RE_ICASE;
  re_set_syntax (syntax_bits);
  dfasyntax (syntax_bits, match_icase, eolbyte);

  /* For GNU regex compiler we have to pass the patterns separately to detect
     errors like "[\nallo\n]\n".  The patterns here are "[", "allo" and "]"
     GNU regex should have raise a syntax error.  The same for backref, where
     the backref should have been local to each pattern.  */
  p = pattern;
  do
    {
      size_t len;
      sep = memchr (p, '\n', total);
      if (sep)
	{
	  len = sep - p;
	  sep++;
	  total -= (len + 1);
	}
      else
	{
	  len = total;
	  total = 0;
	}

      patterns = realloc (patterns, (pcount + 1) * sizeof (*patterns));
      if (patterns == NULL)
	error (EXIT_TROUBLE, errno, _("memory exhausted"));
      patterns[pcount] = patterns0;

      if ((err = re_compile_pattern (p, len,
				    &(patterns[pcount].regexbuf))) != NULL)
	error (EXIT_TROUBLE, 0, "%s", err);
      pcount++;

      p = sep;
    } while (sep && total != 0);

  /* In the match_words and match_lines cases, we use a different pattern
     for the DFA matcher that will quickly throw out cases that won't work.
     Then if DFA succeeds we do some hairy stuff using the regex matcher
     to decide whether the match should really count. */
  if (match_words || match_lines)
    {
      static char const line_beg_no_bk[] = "^(";
      static char const line_end_no_bk[] = ")$";
      static char const word_beg_no_bk[] = "(^|[^[:alnum:]_])(";
      static char const word_end_no_bk[] = ")([^[:alnum:]_]|$)";
#ifdef EGREP_PROGRAM
# define IF_BK(x, y) (y)
      char *n = xmalloc (sizeof word_beg_no_bk - 1 + size + sizeof word_end_no_bk);
#else
      static char const line_beg_bk[] = "^\\(";
      static char const line_end_bk[] = "\\)$";
      static char const word_beg_bk[] = "\\(^\\|[^[:alnum:]_]\\)\\(";
      static char const word_end_bk[] = "\\)\\([^[:alnum:]_]\\|$\\)";
      int bk = !(syntax_bits & RE_NO_BK_PARENS);
# define IF_BK(x, y) ((bk) ? (x) : (y))
      char *n = xmalloc (sizeof word_beg_bk - 1 + size + sizeof word_end_bk);
#endif /* EGREP_PROGRAM */

      strcpy (n, match_lines ? IF_BK(line_beg_bk, line_beg_no_bk)
			     : IF_BK(word_beg_bk, word_beg_no_bk));
      total = strlen(n);
      memcpy (n + total, pattern, size);
      total += size;
      strcpy (n + total, match_lines ? IF_BK(line_end_bk, line_end_no_bk)
				     : IF_BK(word_end_bk, word_end_no_bk));
      total += strlen (n + total);
      pattern = motif = n;
      size = total;
    }
  else
    motif = NULL;

  dfacomp (pattern, size, &dfa, 1);
  kwsmusts ();

  free(motif);
}

#ifndef EGREP_PROGRAM
COMPILE_FCT(Gcompile)
{
  return GEAcompile (pattern, size,
		     RE_SYNTAX_GREP | RE_HAT_LISTS_NOT_NEWLINE);
}

COMPILE_FCT(Acompile)
{
  return GEAcompile (pattern, size, RE_SYNTAX_AWK);
}

COMPILE_FCT(Ecompile)
{
  return GEAcompile (pattern, size, RE_SYNTAX_POSIX_EGREP);
}
#endif /* !EGREP_PROGRAM */

EXECUTE_FCT(EGexecute)
{
  char const *buflim, *beg, *end, *match, *best_match, *mb_start;
  char eol = eolbyte;
  int backref, start, len, best_len;
  struct kwsmatch kwsm;
  size_t i, ret_val;
#ifdef MBS_SUPPORT
  if (MB_CUR_MAX > 1)
    {
      if (match_icase)
        {
          /* mbtolower adds a NUL byte at the end.  That will provide
	     space for the sentinel byte dfaexec may add.  */
          char *case_buf = mbtolower (buf, &size);
	  if (start_ptr)
	    start_ptr = case_buf + (start_ptr - buf);
          buf = case_buf;
        }
    }
#endif /* MBS_SUPPORT */

  mb_start = buf;
  buflim = buf + size;

  for (beg = end = buf; end < buflim; beg = end)
    {
      if (!start_ptr)
	{
	  /* We don't care about an exact match.  */
	  if (kwset)
	    {
	      /* Find a possible match using the KWset matcher. */
	      size_t offset = kwsexec (kwset, beg, buflim - beg, &kwsm);
	      if (offset == (size_t) -1)
		goto failure;
	      beg += offset;
	      /* Narrow down to the line containing the candidate, and
		 run it through DFA. */
	      if ((end = memchr(beg, eol, buflim - beg)) != NULL)
	        end++;
              else
                end = buflim;
	      match = beg;
	      while (beg > buf && beg[-1] != eol)
		--beg;
	      if (kwsm.index < kwset_exact_matches)
                {
#ifdef MBS_SUPPORT
                  if (mb_start < beg)
                    mb_start = beg;
                  if (MB_CUR_MAX == 1 || !is_mb_middle (&mb_start, match, buflim))
#endif
                    goto success;
                }
	      if (dfaexec (&dfa, beg, (char *) end, 0, NULL, &backref) == NULL)
		continue;
	    }
	  else
	    {
	      /* No good fixed strings; start with DFA. */
	      char const *next_beg = dfaexec (&dfa, beg, (char *) buflim,
					      0, NULL, &backref);
	      if (next_beg == NULL)
		break;
	      /* Narrow down to the line we've found. */
	      beg = next_beg;
	      if ((end = memchr(beg, eol, buflim - beg)) != NULL)
	        end++;
              else
                end = buflim;
	      while (beg > buf && beg[-1] != eol)
		--beg;
	    }
	  /* Successful, no backreferences encountered! */
	  if (!backref)
	    goto success;
	}
      else
	{
	  /* We are looking for the leftmost (then longest) exact match.
	     We will go through the outer loop only once.  */
	  beg = start_ptr;
	  end = buflim;
	}

      /* If we've made it to this point, this means DFA has seen
	 a probable match, and we need to run it through Regex. */
      best_match = end;
      best_len = 0;
      for (i = 0; i < pcount; i++)
	{
	  patterns[i].regexbuf.not_eol = 0;
	  if (0 <= (start = re_search (&(patterns[i].regexbuf),
				       buf, end - buf - 1,
				       beg - buf, end - beg - 1,
				       &(patterns[i].regs))))
	    {
	      len = patterns[i].regs.end[0] - start;
	      match = buf + start;
	      if (match > best_match)
		continue;
	      if (start_ptr && !match_words)
		goto assess_pattern_match;
	      if ((!match_lines && !match_words)
		  || (match_lines && len == end - beg - 1))
		{
		  match = beg;
		  len = end - beg;
		  goto assess_pattern_match;
		}
	      /* If -w, check if the match aligns with word boundaries.
		 We do this iteratively because:
		 (a) the line may contain more than one occurence of the
		 pattern, and
		 (b) Several alternatives in the pattern might be valid at a
		 given point, and we may need to consider a shorter one to
		 find a word boundary.  */
	      if (match_words)
		while (match <= best_match)
		  {
		    if ((match == buf || !WCHAR ((unsigned char) match[-1]))
			&& (len == end - beg - 1
			    || !WCHAR ((unsigned char) match[len])))
		      goto assess_pattern_match;
		    if (len > 0)
		      {
			/* Try a shorter length anchored at the same place. */
			--len;
			patterns[i].regexbuf.not_eol = 1;
			len = re_match (&(patterns[i].regexbuf),
					buf, match + len - beg, match - buf,
					&(patterns[i].regs));
		      }
		    if (len <= 0)
		      {
			/* Try looking further on. */
			if (match == end - 1)
			  break;
			match++;
			patterns[i].regexbuf.not_eol = 0;
			start = re_search (&(patterns[i].regexbuf),
					   buf, end - buf - 1,
					   match - buf, end - match - 1,
					   &(patterns[i].regs));
			if (start < 0)
			  break;
			len = patterns[i].regs.end[0] - start;
			match = buf + start;
		      }
		  } /* while (match <= best_match) */
	      continue;
	    assess_pattern_match:
	      if (!start_ptr)
		{
		  /* Good enough for a non-exact match.
		     No need to look at further patterns, if any.  */
		  beg = match;
		  goto success_in_len;
		}
	      if (match < best_match || (match == best_match && len > best_len))
		{
		  /* Best exact match:  leftmost, then longest.  */
		  best_match = match;
		  best_len = len;
		}
	    } /* if re_search >= 0 */
	} /* for Regex patterns.  */
	if (best_match < end)
	  {
	    /* We have found an exact match.  We were just
	       waiting for the best one (leftmost then longest).  */
	    beg = best_match;
	    len = best_len;
	    goto success_in_len;
	  }
    } /* for (beg = end ..) */

 failure:
  ret_val = -1;
  goto out;

 success:
  len = end - beg;
 success_in_len:
  *match_size = len;
  ret_val = beg - buf;
 out:
  return ret_val;
}
#endif /* defined(GREP_PROGRAM) || defined(EGREP_PROGRAM) */

#if defined(GREP_PROGRAM) || defined(FGREP_PROGRAM)
COMPILE_FCT(Fcompile)
{
  char const *beg, *end, *lim, *err, *pat;
  size_t psize;

  kwsinit ();
  psize = size;
  if (match_icase && MB_CUR_MAX > 1)
    pat = mbtolower (pattern, &psize);
  else
    pat = pattern;

  beg = pat;
  do
    {
      for (lim = beg;; ++lim)
	{
	  end = lim;
	  if (lim >= pat + psize)
	    break;
	 if (*lim == '\n')
	   {
	     lim++;
	     break;
	   }
#if HAVE_DOS_FILE_CONTENTS
	 if (*lim == '\r' && lim + 1 < pat + psize && lim[1] == '\n')
	   {
	     lim += 2;
	     break;
	   }
#endif
	}

      if ((err = kwsincr (kwset, beg, end - beg)) != NULL)
	error (EXIT_TROUBLE, 0, "%s", err);
      beg = lim;
    }
  while (beg < pat + psize);

  if ((err = kwsprep (kwset)) != NULL)
    error (EXIT_TROUBLE, 0, "%s", err);
}

EXECUTE_FCT(Fexecute)
{
  char const *beg, *try, *end, *mb_start;
  size_t len;
  char eol = eolbyte;
  struct kwsmatch kwsmatch;
  size_t ret_val;
#ifdef MBS_SUPPORT
  if (MB_CUR_MAX > 1)
    {
      if (match_icase)
        {
          char *case_buf = mbtolower (buf, &size);
	  if (start_ptr)
	    start_ptr = case_buf + (start_ptr - buf);
          buf = case_buf;
        }
    }
#endif /* MBS_SUPPORT */

  for (mb_start = beg = start_ptr ? start_ptr : buf; beg <= buf + size; beg++)
    {
      size_t offset = kwsexec (kwset, beg, buf + size - beg, &kwsmatch);
      if (offset == (size_t) -1)
	goto failure;
#ifdef MBS_SUPPORT
      if (MB_CUR_MAX > 1 && is_mb_middle (&mb_start, beg + offset, buf + size))
        {
          beg = mb_start - 1;
          continue; /* It is a part of multibyte character.  */
        }
#endif /* MBS_SUPPORT */
      beg += offset;
      len = kwsmatch.size[0];
      if (start_ptr && !match_words)
	goto success_in_beg_and_len;
      if (match_lines)
	{
	  if (beg > buf && beg[-1] != eol)
	    continue;
	  if (beg + len < buf + size && beg[len] != eol)
	    continue;
	  goto success;
	}
      else if (match_words)
	for (try = beg; len; )
	  {
	    if (try > buf && WCHAR((unsigned char) try[-1]))
	      break;
	    if (try + len < buf + size && WCHAR((unsigned char) try[len]))
	      {
		offset = kwsexec (kwset, beg, --len, &kwsmatch);
		if (offset == (size_t) -1)
		  break;
		try = beg + offset;
		len = kwsmatch.size[0];
	      }
	    else if (!start_ptr)
	      goto success;
	    else
	      goto success_in_beg_and_len;
	  } /* for (try) */
      else
	goto success;
    } /* for (beg in buf) */

 failure:
  ret_val = -1;
  goto out;

 success:
  if ((end = memchr (beg + len, eol, (buf + size) - (beg + len))) != NULL)
    end++;
  else
    end = buf + size;
  while (buf < beg && beg[-1] != eol)
    --beg;
  len = end - beg;
 success_in_beg_and_len:
  *match_size = len;
  ret_val = beg - buf;
 out:
  return ret_val;
}
#endif /* defined(GREP_PROGRAM) || defined(FGREP_PROGRAM) */

#ifdef GREP_PROGRAM
#if HAVE_LIBPCRE
/* Compiled internal form of a Perl regular expression.  */
static pcre *cre;

/* Additional information about the pattern.  */
static pcre_extra *extra;
#endif

COMPILE_FCT(Pcompile)
{
#if !HAVE_LIBPCRE
  error (EXIT_TROUBLE, 0, "%s",
	 _("support for the -P option is not compiled into "
	   "this --disable-perl-regexp binary"));
#else
  int e;
  char const *ep;
  char *re = xmalloc (4 * size + 7);
  int flags = PCRE_MULTILINE | (match_icase ? PCRE_CASELESS : 0);
  char const *patlim = pattern + size;
  char *n = re;
  char const *p;
  char const *pnul;

  /* FIXME: Remove these restrictions.  */
  if (memchr(pattern, '\n', size))
    error (EXIT_TROUBLE, 0, _("the -P option only supports a single pattern"));

  *n = '\0';
  if (match_lines)
    strcpy (n, "^(");
  if (match_words)
    strcpy (n, "\\b(");
  n += strlen (n);

  /* The PCRE interface doesn't allow NUL bytes in the pattern, so
     replace each NUL byte in the pattern with the four characters
     "\000", removing a preceding backslash if there are an odd
     number of backslashes before the NUL.

     FIXME: This method does not work with some multibyte character
     encodings, notably Shift-JIS, where a multibyte character can end
     in a backslash byte.  */
  for (p = pattern; (pnul = memchr (p, '\0', patlim - p)); p = pnul + 1)
    {
      memcpy (n, p, pnul - p);
      n += pnul - p;
      for (p = pnul; pattern < p && p[-1] == '\\'; p--)
	continue;
      n -= (pnul - p) & 1;
      strcpy (n, "\\000");
      n += 4;
    }

  memcpy (n, p, patlim - p);
  n += patlim - p;
  *n = '\0';
  if (match_words)
    strcpy (n, ")\\b");
  if (match_lines)
    strcpy (n, ")$");

  cre = pcre_compile (re, flags, &ep, &e, pcre_maketables ());
  if (!cre)
    error (EXIT_TROUBLE, 0, "%s", ep);

  extra = pcre_study (cre, 0, &ep);
  if (ep)
    error (EXIT_TROUBLE, 0, "%s", ep);

  free (re);
#endif
}

EXECUTE_FCT(Pexecute)
{
#if !HAVE_LIBPCRE
  abort ();
  return -1;
#else
  /* This array must have at least two elements; everything after that
     is just for performance improvement in pcre_exec.  */
  int sub[300];

  const char *line_buf, *line_end, *line_next;
  int e = PCRE_ERROR_NOMATCH;
  ptrdiff_t start_ofs = start_ptr ? start_ptr - buf : 0;

  /* PCRE can't limit the matching to single lines, therefore we have to
     match each line in the buffer separately.  */
  for (line_next = buf;
       e == PCRE_ERROR_NOMATCH && line_next < buf + size;
       start_ofs -= line_next - line_buf)
    {
      line_buf = line_next;
      line_end = memchr (line_buf, eolbyte, (buf + size) - line_buf);
      if (line_end == NULL)
        line_next = line_end = buf + size;
      else
        line_next = line_end + 1;

      if (start_ptr && start_ptr >= line_end)
        continue;

      e = pcre_exec (cre, extra, line_buf, line_end - line_buf,
                     start_ofs < 0 ? 0 : start_ofs, 0,
                     sub, sizeof sub / sizeof *sub);
    }

  if (e <= 0)
    {
      switch (e)
	{
	case PCRE_ERROR_NOMATCH:
	  return -1;

	case PCRE_ERROR_NOMEMORY:
	  error (EXIT_TROUBLE, 0, _("memory exhausted"));

	default:
	  abort ();
	}
    }
  else
    {
      /* Narrow down to the line we've found.  */
      char const *beg = line_buf + sub[0];
      char const *end = line_buf + sub[1];
      char const *buflim = buf + size;
      char eol = eolbyte;
      if (!start_ptr)
	{
	  /* FIXME: The case when '\n' is not found indicates a bug:
	     Since grep is line oriented, the match should never contain
	     a newline, so there _must_ be a newline following.
	   */
	  if (!(end = memchr (end, eol, buflim - end)))
	    end = buflim;
	  else
	    end++;
	  while (buf < beg && beg[-1] != eol)
	    --beg;
	}

      *match_size = end - beg;
      return beg - buf;
    }
#endif
}

struct matcher const matchers[] = {
  { "default", Gcompile, EGexecute },
  { "grep",    Gcompile, EGexecute },
  { "egrep",   Ecompile, EGexecute },
  { "awk",     Acompile, EGexecute },
  { "fgrep",   Fcompile, Fexecute },
  { "perl",    Pcompile, Pexecute },
  { "", 0, 0 },
};
#endif /* GREP_PROGRAM */

Testing negative cases!
Testing 0 (with abstract condition) ENVIS_NEG
Iteration 0
Running test command:
/home/ubuntu/spr-fast/tools/grep-test.py /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-deccad69-db9d6340/tempworkdir2/src /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-deccad69-db9d6340/tempworkdir2/tests /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-deccad69-db9d6340/tempworkdir2 0  > __res
Opening:/home/ubuntu/spr-fast/tests/corebench/grep/grep-case-deccad69-db9d6340/tempworkdir2/neg.tmp!
NegativeBRANCH RECORD/home/ubuntu/spr-fast/tests/corebench/grep/grep-case-deccad69-db9d6340/tempworkdir2/neg.tmp!
Not caught by the negative case, give up!
APPENDING TO ISNEG:/home/ubuntu/spr-fast/tests/corebench/grep/grep-case-deccad69-db9d6340/tempworkdir2/neg.tmp!
Running test command:
/home/ubuntu/spr-fast/tools/grep-test.py /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-deccad69-db9d6340/tempworkdir2/src /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-deccad69-db9d6340/tempworkdir2/tests /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-deccad69-db9d6340/tempworkdir2 0  > __res
a batched test job starts!
Building merged code:
src_file: src/search.c
full src: int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
/* search.c - searching subroutines using dfa, kwset and regex for grep.
   Copyright 1992, 1998, 2000, 2007, 2009-2010 Free Software Foundation, Inc.

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 3, or (at your option)
   any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program; if not, write to the Free Software
   Foundation, Inc., 51 Franklin Street - Fifth Floor, Boston, MA
   02110-1301, USA.  */

/* Written August 1992 by Mike Haertel. */

#include <config.h>

#include <sys/types.h>

#include "mbsupport.h"
#ifdef MBS_SUPPORT
/* We can handle multibyte strings. */
# include <wchar.h>
# include <wctype.h>
#endif

#include "system.h"
#include "grep.h"
#ifndef FGREP_PROGRAM
# include <regex.h>
# include "dfa.h"
#endif
#include "kwset.h"
#include "error.h"
#include "xalloc.h"
#ifdef HAVE_LIBPCRE
# include <pcre.h>
#endif

#define NCHAR (UCHAR_MAX + 1)

/* For -w, we also consider _ to be word constituent.  */
#define WCHAR(C) (ISALNUM(C) || (C) == '_')

/* KWset compiled pattern.  For Ecompile and Gcompile, we compile
   a list of strings, at least one of which is known to occur in
   any string matching the regexp. */
static kwset_t kwset;

static void
kwsinit (void)
{
  static char trans[NCHAR];
  int i;

  if (match_icase && MB_CUR_MAX == 1)
    {
      for (i = 0; i < NCHAR; ++i)
        trans[i] = TOLOWER (i);

      kwset = kwsalloc (trans);
    }
  else
    kwset = kwsalloc (NULL);

  if (!kwset)
    xalloc_die ();
}

#ifdef MBS_SUPPORT
/* Convert the *N-byte string, BEG, to lowercase, and write the
   NUL-terminated result into malloc'd storage.  Upon success, set *N
   to the length (in bytes) of the resulting string (not including the
   trailing NUL byte), and return a pointer to the lowercase string.
   Upon memory allocation failure, this function exits.

   Note that while this function returns a pointer to malloc'd storage,
   the caller must not free it, since this function retains a pointer
   to the buffer and reuses it on any subsequent call.  As a consequence,
   this function is not thread-safe.  */
static char *
mbtolower (const char *beg, size_t *n)
{
  static char *out;
  static size_t outalloc;
  size_t outlen, mb_cur_max;
  mbstate_t is, os;
  const char *end;
  char *p;

  if (*n > outalloc)
    {
      out = xrealloc (out, *n);
      outalloc = *n;
    }

  memset (&is, 0, sizeof (is));
  memset (&os, 0, sizeof (os));
  end = beg + *n;

  mb_cur_max = MB_CUR_MAX;
  p = out;
  outlen = 0;
  while (beg < end)
    {
      wchar_t wc;
      size_t mbclen = mbrtowc(&wc, beg, end - beg, &is);
      if (outlen + mb_cur_max >= outalloc)
        {
          out = x2nrealloc (out, &outalloc, 1);
          p = out + outlen;
        }

      if (mbclen == (size_t) -1 || mbclen == (size_t) -2 || mbclen == 0)
        {
          /* An invalid sequence, or a truncated multi-octet character.
             We treat it as a single-octet character.  */
          *p++ = *beg++;
          outlen++;
          memset (&is, 0, sizeof (is));
          memset (&os, 0, sizeof (os));
        }
      else
        {
          beg += mbclen;
          mbclen = wcrtomb (p, towlower ((wint_t) wc), &os);
          p += mbclen;
          outlen += mbclen;
        }
    }

  *n = p - out;
  *p++ = 0;
  return out;
}
#endif


#ifndef FGREP_PROGRAM
/* DFA compiled regexp. */
static struct dfa dfa;

/* The Regex compiled patterns.  */
static struct patterns
{
  /* Regex compiled regexp. */
  struct re_pattern_buffer regexbuf;
  struct re_registers regs; /* This is here on account of a BRAIN-DEAD
			       Q@#%!# library interface in regex.c.  */
} patterns0;

struct patterns *patterns;
size_t pcount;

void
dfaerror (char const *mesg)
{
  error (EXIT_TROUBLE, 0, "%s", mesg);
}

/* Number of compiled fixed strings known to exactly match the regexp.
   If kwsexec returns < kwset_exact_matches, then we don't need to
   call the regexp matcher at all. */
static int kwset_exact_matches;

static char const *
kwsincr_case (const char *must)
{
  const char *buf;
  size_t n;

  n = strlen (must);
#ifdef MBS_SUPPORT
  if (match_icase && MB_CUR_MAX > 1)
    buf = mbtolower (must, &n);
  else
#endif
    buf = must;
  return kwsincr (kwset, buf, n);
}

/* If the DFA turns out to have some set of fixed strings one of
   which must occur in the match, then we build a kwset matcher
   to find those strings, and thus quickly filter out impossible
   matches. */
static void
kwsmusts (void)
{
  struct dfamust const *dm;
  char const *err;

  if (dfa.musts)
    {
      kwsinit ();
      /* First, we compile in the substrings known to be exact
	 matches.  The kwset matcher will return the index
	 of the matching string that it chooses. */
      for (dm = dfa.musts; dm; dm = dm->next)
	{
	  if (!dm->exact)
	    continue;
	  ++kwset_exact_matches;
	  if ((err = kwsincr_case (dm->must)) != NULL)
	    error (EXIT_TROUBLE, 0, "%s", err);
	}
      /* Now, we compile the substrings that will require
	 the use of the regexp matcher.  */
      for (dm = dfa.musts; dm; dm = dm->next)
	{
	  if (dm->exact)
	    continue;
	  if ((err = kwsincr_case (dm->must)) != NULL)
	    error (EXIT_TROUBLE, 0, "%s", err);
	}
      if ((err = kwsprep (kwset)) != NULL)
	error (EXIT_TROUBLE, 0, "%s", err);
    }
}
#endif /* !FGREP_PROGRAM */

#ifdef MBS_SUPPORT

static bool
is_mb_middle(const char **good, const char *buf, const char *end)
{
  const char *p = *good;
  const char *prev = p;
  mbstate_t cur_state;

  /* TODO: can be optimized for UTF-8.  */
  memset(&cur_state, 0, sizeof(mbstate_t));
  while (p < buf)
    {
      size_t mbclen = mbrlen(p, end - p, &cur_state);

      /* Store the beginning of the previous complete multibyte character.  */
      if (mbclen != (size_t) -2)
        prev = p;

      //prophet generated patch
      if (__get_mutant()==0) {
      if ((mbclen == (size_t)-1 || mbclen == (size_t)-2 || mbclen == 0) && !(__is_neg(6, &(mbclen), sizeof (mbclen), &(p), sizeof (p), &(prev), sizeof (prev), &(end), sizeof (end), &(buf), sizeof (buf), &(good), sizeof (good)))) {
          mbclen = 1;
      }
      }
      else if (__get_mutant()==1) {
      if ((mbclen == (size_t)-1 || mbclen == (size_t)-2 || mbclen == 0) || (__is_neg(6, &(mbclen), sizeof (mbclen), &(p), sizeof (p), &(prev), sizeof (prev), &(end), sizeof (end), &(buf), sizeof (buf), &(good), sizeof (good)))) {
          mbclen = 1;
      }
      }
      p += mbclen;
    }

  *good = prev;
  return p > buf;
}
#endif /* MBS_SUPPORT */

#if defined(GREP_PROGRAM) || defined(EGREP_PROGRAM)
#ifdef EGREP_PROGRAM
COMPILE_FCT(Ecompile)
{
  reg_syntax_t syntax_bits = RE_SYNTAX_POSIX_EGREP;
#else
/* No __VA_ARGS__ in C89.  So we have to do it this way.  */
static COMPILE_RET
GEAcompile (char const *pattern, size_t size, reg_syntax_t syntax_bits)
{
#endif /* EGREP_PROGRAM */
  const char *err;
  const char *p, *sep;
  size_t total = size;
  char *motif;

  if (match_icase)
    syntax_bits |= RE_ICASE;
  re_set_syntax (syntax_bits);
  dfasyntax (syntax_bits, match_icase, eolbyte);

  /* For GNU regex compiler we have to pass the patterns separately to detect
     errors like "[\nallo\n]\n".  The patterns here are "[", "allo" and "]"
     GNU regex should have raise a syntax error.  The same for backref, where
     the backref should have been local to each pattern.  */
  p = pattern;
  do
    {
      size_t len;
      sep = memchr (p, '\n', total);
      if (sep)
	{
	  len = sep - p;
	  sep++;
	  total -= (len + 1);
	}
      else
	{
	  len = total;
	  total = 0;
	}

      patterns = realloc (patterns, (pcount + 1) * sizeof (*patterns));
      if (patterns == NULL)
	error (EXIT_TROUBLE, errno, _("memory exhausted"));
      patterns[pcount] = patterns0;

      if ((err = re_compile_pattern (p, len,
				    &(patterns[pcount].regexbuf))) != NULL)
	error (EXIT_TROUBLE, 0, "%s", err);
      pcount++;

      p = sep;
    } while (sep && total != 0);

  /* In the match_words and match_lines cases, we use a different pattern
     for the DFA matcher that will quickly throw out cases that won't work.
     Then if DFA succeeds we do some hairy stuff using the regex matcher
     to decide whether the match should really count. */
  if (match_words || match_lines)
    {
      static char const line_beg_no_bk[] = "^(";
      static char const line_end_no_bk[] = ")$";
      static char const word_beg_no_bk[] = "(^|[^[:alnum:]_])(";
      static char const word_end_no_bk[] = ")([^[:alnum:]_]|$)";
#ifdef EGREP_PROGRAM
# define IF_BK(x, y) (y)
      char *n = xmalloc (sizeof word_beg_no_bk - 1 + size + sizeof word_end_no_bk);
#else
      static char const line_beg_bk[] = "^\\(";
      static char const line_end_bk[] = "\\)$";
      static char const word_beg_bk[] = "\\(^\\|[^[:alnum:]_]\\)\\(";
      static char const word_end_bk[] = "\\)\\([^[:alnum:]_]\\|$\\)";
      int bk = !(syntax_bits & RE_NO_BK_PARENS);
# define IF_BK(x, y) ((bk) ? (x) : (y))
      char *n = xmalloc (sizeof word_beg_bk - 1 + size + sizeof word_end_bk);
#endif /* EGREP_PROGRAM */

      strcpy (n, match_lines ? IF_BK(line_beg_bk, line_beg_no_bk)
			     : IF_BK(word_beg_bk, word_beg_no_bk));
      total = strlen(n);
      memcpy (n + total, pattern, size);
      total += size;
      strcpy (n + total, match_lines ? IF_BK(line_end_bk, line_end_no_bk)
				     : IF_BK(word_end_bk, word_end_no_bk));
      total += strlen (n + total);
      pattern = motif = n;
      size = total;
    }
  else
    motif = NULL;

  dfacomp (pattern, size, &dfa, 1);
  kwsmusts ();

  free(motif);
}

#ifndef EGREP_PROGRAM
COMPILE_FCT(Gcompile)
{
  return GEAcompile (pattern, size,
		     RE_SYNTAX_GREP | RE_HAT_LISTS_NOT_NEWLINE);
}

COMPILE_FCT(Acompile)
{
  return GEAcompile (pattern, size, RE_SYNTAX_AWK);
}

COMPILE_FCT(Ecompile)
{
  return GEAcompile (pattern, size, RE_SYNTAX_POSIX_EGREP);
}
#endif /* !EGREP_PROGRAM */

EXECUTE_FCT(EGexecute)
{
  char const *buflim, *beg, *end, *match, *best_match, *mb_start;
  char eol = eolbyte;
  int backref, start, len, best_len;
  struct kwsmatch kwsm;
  size_t i, ret_val;
#ifdef MBS_SUPPORT
  if (MB_CUR_MAX > 1)
    {
      if (match_icase)
        {
          /* mbtolower adds a NUL byte at the end.  That will provide
	     space for the sentinel byte dfaexec may add.  */
          char *case_buf = mbtolower (buf, &size);
	  if (start_ptr)
	    start_ptr = case_buf + (start_ptr - buf);
          buf = case_buf;
        }
    }
#endif /* MBS_SUPPORT */

  mb_start = buf;
  buflim = buf + size;

  for (beg = end = buf; end < buflim; beg = end)
    {
      if (!start_ptr)
	{
	  /* We don't care about an exact match.  */
	  if (kwset)
	    {
	      /* Find a possible match using the KWset matcher. */
	      size_t offset = kwsexec (kwset, beg, buflim - beg, &kwsm);
	      if (offset == (size_t) -1)
		goto failure;
	      beg += offset;
	      /* Narrow down to the line containing the candidate, and
		 run it through DFA. */
	      if ((end = memchr(beg, eol, buflim - beg)) != NULL)
	        end++;
              else
                end = buflim;
	      match = beg;
	      while (beg > buf && beg[-1] != eol)
		--beg;
	      if (kwsm.index < kwset_exact_matches)
                {
#ifdef MBS_SUPPORT
                  if (mb_start < beg)
                    mb_start = beg;
                  if (MB_CUR_MAX == 1 || !is_mb_middle (&mb_start, match, buflim))
#endif
                    goto success;
                }
	      if (dfaexec (&dfa, beg, (char *) end, 0, NULL, &backref) == NULL)
		continue;
	    }
	  else
	    {
	      /* No good fixed strings; start with DFA. */
	      char const *next_beg = dfaexec (&dfa, beg, (char *) buflim,
					      0, NULL, &backref);
	      if (next_beg == NULL)
		break;
	      /* Narrow down to the line we've found. */
	      beg = next_beg;
	      if ((end = memchr(beg, eol, buflim - beg)) != NULL)
	        end++;
              else
                end = buflim;
	      while (beg > buf && beg[-1] != eol)
		--beg;
	    }
	  /* Successful, no backreferences encountered! */
	  if (!backref)
	    goto success;
	}
      else
	{
	  /* We are looking for the leftmost (then longest) exact match.
	     We will go through the outer loop only once.  */
	  beg = start_ptr;
	  end = buflim;
	}

      /* If we've made it to this point, this means DFA has seen
	 a probable match, and we need to run it through Regex. */
      best_match = end;
      best_len = 0;
      for (i = 0; i < pcount; i++)
	{
	  patterns[i].regexbuf.not_eol = 0;
	  if (0 <= (start = re_search (&(patterns[i].regexbuf),
				       buf, end - buf - 1,
				       beg - buf, end - beg - 1,
				       &(patterns[i].regs))))
	    {
	      len = patterns[i].regs.end[0] - start;
	      match = buf + start;
	      if (match > best_match)
		continue;
	      if (start_ptr && !match_words)
		goto assess_pattern_match;
	      if ((!match_lines && !match_words)
		  || (match_lines && len == end - beg - 1))
		{
		  match = beg;
		  len = end - beg;
		  goto assess_pattern_match;
		}
	      /* If -w, check if the match aligns with word boundaries.
		 We do this iteratively because:
		 (a) the line may contain more than one occurence of the
		 pattern, and
		 (b) Several alternatives in the pattern might be valid at a
		 given point, and we may need to consider a shorter one to
		 find a word boundary.  */
	      if (match_words)
		while (match <= best_match)
		  {
		    if ((match == buf || !WCHAR ((unsigned char) match[-1]))
			&& (len == end - beg - 1
			    || !WCHAR ((unsigned char) match[len])))
		      goto assess_pattern_match;
		    if (len > 0)
		      {
			/* Try a shorter length anchored at the same place. */
			--len;
			patterns[i].regexbuf.not_eol = 1;
			len = re_match (&(patterns[i].regexbuf),
					buf, match + len - beg, match - buf,
					&(patterns[i].regs));
		      }
		    if (len <= 0)
		      {
			/* Try looking further on. */
			if (match == end - 1)
			  break;
			match++;
			patterns[i].regexbuf.not_eol = 0;
			start = re_search (&(patterns[i].regexbuf),
					   buf, end - buf - 1,
					   match - buf, end - match - 1,
					   &(patterns[i].regs));
			if (start < 0)
			  break;
			len = patterns[i].regs.end[0] - start;
			match = buf + start;
		      }
		  } /* while (match <= best_match) */
	      continue;
	    assess_pattern_match:
	      if (!start_ptr)
		{
		  /* Good enough for a non-exact match.
		     No need to look at further patterns, if any.  */
		  beg = match;
		  goto success_in_len;
		}
	      if (match < best_match || (match == best_match && len > best_len))
		{
		  /* Best exact match:  leftmost, then longest.  */
		  best_match = match;
		  best_len = len;
		}
	    } /* if re_search >= 0 */
	} /* for Regex patterns.  */
	if (best_match < end)
	  {
	    /* We have found an exact match.  We were just
	       waiting for the best one (leftmost then longest).  */
	    beg = best_match;
	    len = best_len;
	    goto success_in_len;
	  }
    } /* for (beg = end ..) */

 failure:
  ret_val = -1;
  goto out;

 success:
  len = end - beg;
 success_in_len:
  *match_size = len;
  ret_val = beg - buf;
 out:
  return ret_val;
}
#endif /* defined(GREP_PROGRAM) || defined(EGREP_PROGRAM) */

#if defined(GREP_PROGRAM) || defined(FGREP_PROGRAM)
COMPILE_FCT(Fcompile)
{
  char const *beg, *end, *lim, *err, *pat;
  size_t psize;

  kwsinit ();
  psize = size;
  if (match_icase && MB_CUR_MAX > 1)
    pat = mbtolower (pattern, &psize);
  else
    pat = pattern;

  beg = pat;
  do
    {
      for (lim = beg;; ++lim)
	{
	  end = lim;
	  if (lim >= pat + psize)
	    break;
	 if (*lim == '\n')
	   {
	     lim++;
	     break;
	   }
#if HAVE_DOS_FILE_CONTENTS
	 if (*lim == '\r' && lim + 1 < pat + psize && lim[1] == '\n')
	   {
	     lim += 2;
	     break;
	   }
#endif
	}

      if ((err = kwsincr (kwset, beg, end - beg)) != NULL)
	error (EXIT_TROUBLE, 0, "%s", err);
      beg = lim;
    }
  while (beg < pat + psize);

  if ((err = kwsprep (kwset)) != NULL)
    error (EXIT_TROUBLE, 0, "%s", err);
}

EXECUTE_FCT(Fexecute)
{
  char const *beg, *try, *end, *mb_start;
  size_t len;
  char eol = eolbyte;
  struct kwsmatch kwsmatch;
  size_t ret_val;
#ifdef MBS_SUPPORT
  if (MB_CUR_MAX > 1)
    {
      if (match_icase)
        {
          char *case_buf = mbtolower (buf, &size);
	  if (start_ptr)
	    start_ptr = case_buf + (start_ptr - buf);
          buf = case_buf;
        }
    }
#endif /* MBS_SUPPORT */

  for (mb_start = beg = start_ptr ? start_ptr : buf; beg <= buf + size; beg++)
    {
      size_t offset = kwsexec (kwset, beg, buf + size - beg, &kwsmatch);
      if (offset == (size_t) -1)
	goto failure;
#ifdef MBS_SUPPORT
      if (MB_CUR_MAX > 1 && is_mb_middle (&mb_start, beg + offset, buf + size))
        {
          beg = mb_start - 1;
          continue; /* It is a part of multibyte character.  */
        }
#endif /* MBS_SUPPORT */
      beg += offset;
      len = kwsmatch.size[0];
      if (start_ptr && !match_words)
	goto success_in_beg_and_len;
      if (match_lines)
	{
	  if (beg > buf && beg[-1] != eol)
	    continue;
	  if (beg + len < buf + size && beg[len] != eol)
	    continue;
	  goto success;
	}
      else if (match_words)
	for (try = beg; len; )
	  {
	    if (try > buf && WCHAR((unsigned char) try[-1]))
	      break;
	    if (try + len < buf + size && WCHAR((unsigned char) try[len]))
	      {
		offset = kwsexec (kwset, beg, --len, &kwsmatch);
		if (offset == (size_t) -1)
		  break;
		try = beg + offset;
		len = kwsmatch.size[0];
	      }
	    else if (!start_ptr)
	      goto success;
	    else
	      goto success_in_beg_and_len;
	  } /* for (try) */
      else
	goto success;
    } /* for (beg in buf) */

 failure:
  ret_val = -1;
  goto out;

 success:
  if ((end = memchr (beg + len, eol, (buf + size) - (beg + len))) != NULL)
    end++;
  else
    end = buf + size;
  while (buf < beg && beg[-1] != eol)
    --beg;
  len = end - beg;
 success_in_beg_and_len:
  *match_size = len;
  ret_val = beg - buf;
 out:
  return ret_val;
}
#endif /* defined(GREP_PROGRAM) || defined(FGREP_PROGRAM) */

#ifdef GREP_PROGRAM
#if HAVE_LIBPCRE
/* Compiled internal form of a Perl regular expression.  */
static pcre *cre;

/* Additional information about the pattern.  */
static pcre_extra *extra;
#endif

COMPILE_FCT(Pcompile)
{
#if !HAVE_LIBPCRE
  error (EXIT_TROUBLE, 0, "%s",
	 _("support for the -P option is not compiled into "
	   "this --disable-perl-regexp binary"));
#else
  int e;
  char const *ep;
  char *re = xmalloc (4 * size + 7);
  int flags = PCRE_MULTILINE | (match_icase ? PCRE_CASELESS : 0);
  char const *patlim = pattern + size;
  char *n = re;
  char const *p;
  char const *pnul;

  /* FIXME: Remove these restrictions.  */
  if (memchr(pattern, '\n', size))
    error (EXIT_TROUBLE, 0, _("the -P option only supports a single pattern"));

  *n = '\0';
  if (match_lines)
    strcpy (n, "^(");
  if (match_words)
    strcpy (n, "\\b(");
  n += strlen (n);

  /* The PCRE interface doesn't allow NUL bytes in the pattern, so
     replace each NUL byte in the pattern with the four characters
     "\000", removing a preceding backslash if there are an odd
     number of backslashes before the NUL.

     FIXME: This method does not work with some multibyte character
     encodings, notably Shift-JIS, where a multibyte character can end
     in a backslash byte.  */
  for (p = pattern; (pnul = memchr (p, '\0', patlim - p)); p = pnul + 1)
    {
      memcpy (n, p, pnul - p);
      n += pnul - p;
      for (p = pnul; pattern < p && p[-1] == '\\'; p--)
	continue;
      n -= (pnul - p) & 1;
      strcpy (n, "\\000");
      n += 4;
    }

  memcpy (n, p, patlim - p);
  n += patlim - p;
  *n = '\0';
  if (match_words)
    strcpy (n, ")\\b");
  if (match_lines)
    strcpy (n, ")$");

  cre = pcre_compile (re, flags, &ep, &e, pcre_maketables ());
  if (!cre)
    error (EXIT_TROUBLE, 0, "%s", ep);

  extra = pcre_study (cre, 0, &ep);
  if (ep)
    error (EXIT_TROUBLE, 0, "%s", ep);

  free (re);
#endif
}

EXECUTE_FCT(Pexecute)
{
#if !HAVE_LIBPCRE
  abort ();
  return -1;
#else
  /* This array must have at least two elements; everything after that
     is just for performance improvement in pcre_exec.  */
  int sub[300];

  const char *line_buf, *line_end, *line_next;
  int e = PCRE_ERROR_NOMATCH;
  ptrdiff_t start_ofs = start_ptr ? start_ptr - buf : 0;

  /* PCRE can't limit the matching to single lines, therefore we have to
     match each line in the buffer separately.  */
  for (line_next = buf;
       e == PCRE_ERROR_NOMATCH && line_next < buf + size;
       start_ofs -= line_next - line_buf)
    {
      line_buf = line_next;
      line_end = memchr (line_buf, eolbyte, (buf + size) - line_buf);
      if (line_end == NULL)
        line_next = line_end = buf + size;
      else
        line_next = line_end + 1;

      if (start_ptr && start_ptr >= line_end)
        continue;

      e = pcre_exec (cre, extra, line_buf, line_end - line_buf,
                     start_ofs < 0 ? 0 : start_ofs, 0,
                     sub, sizeof sub / sizeof *sub);
    }

  if (e <= 0)
    {
      switch (e)
	{
	case PCRE_ERROR_NOMATCH:
	  return -1;

	case PCRE_ERROR_NOMEMORY:
	  error (EXIT_TROUBLE, 0, _("memory exhausted"));

	default:
	  abort ();
	}
    }
  else
    {
      /* Narrow down to the line we've found.  */
      char const *beg = line_buf + sub[0];
      char const *end = line_buf + sub[1];
      char const *buflim = buf + size;
      char eol = eolbyte;
      if (!start_ptr)
	{
	  /* FIXME: The case when '\n' is not found indicates a bug:
	     Since grep is line oriented, the match should never contain
	     a newline, so there _must_ be a newline following.
	   */
	  if (!(end = memchr (end, eol, buflim - end)))
	    end = buflim;
	  else
	    end++;
	  while (buf < beg && beg[-1] != eol)
	    --beg;
	}

      *match_size = end - beg;
      return beg - buf;
    }
#endif
}

struct matcher const matchers[] = {
  { "default", Gcompile, EGexecute },
  { "grep",    Gcompile, EGexecute },
  { "egrep",   Ecompile, EGexecute },
  { "awk",     Acompile, EGexecute },
  { "fgrep",   Fcompile, Fexecute },
  { "perl",    Pcompile, Pexecute },
  { "", 0, 0 },
};
#endif /* GREP_PROGRAM */

Building:src at:
/home/ubuntu/spr-fast/tests/corebench/grep/grep-case-deccad69-db9d6340/tempworkdir2/srcMerged code building succ, going to invoke tester!
CondTester, Testing instance id 23:
//src_file:src/search.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
/* search.c - searching subroutines using dfa, kwset and regex for grep.
   Copyright 1992, 1998, 2000, 2007, 2009-2010 Free Software Foundation, Inc.

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 3, or (at your option)
   any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program; if not, write to the Free Software
   Foundation, Inc., 51 Franklin Street - Fifth Floor, Boston, MA
   02110-1301, USA.  */

/* Written August 1992 by Mike Haertel. */

#include <config.h>

#include <sys/types.h>

#include "mbsupport.h"
#ifdef MBS_SUPPORT
/* We can handle multibyte strings. */
# include <wchar.h>
# include <wctype.h>
#endif

#include "system.h"
#include "grep.h"
#ifndef FGREP_PROGRAM
# include <regex.h>
# include "dfa.h"
#endif
#include "kwset.h"
#include "error.h"
#include "xalloc.h"
#ifdef HAVE_LIBPCRE
# include <pcre.h>
#endif

#define NCHAR (UCHAR_MAX + 1)

/* For -w, we also consider _ to be word constituent.  */
#define WCHAR(C) (ISALNUM(C) || (C) == '_')

/* KWset compiled pattern.  For Ecompile and Gcompile, we compile
   a list of strings, at least one of which is known to occur in
   any string matching the regexp. */
static kwset_t kwset;

static void
kwsinit (void)
{
  static char trans[NCHAR];
  int i;

  if (match_icase && MB_CUR_MAX == 1)
    {
      for (i = 0; i < NCHAR; ++i)
        trans[i] = TOLOWER (i);

      kwset = kwsalloc (trans);
    }
  else
    kwset = kwsalloc (NULL);

  if (!kwset)
    xalloc_die ();
}

#ifdef MBS_SUPPORT
/* Convert the *N-byte string, BEG, to lowercase, and write the
   NUL-terminated result into malloc'd storage.  Upon success, set *N
   to the length (in bytes) of the resulting string (not including the
   trailing NUL byte), and return a pointer to the lowercase string.
   Upon memory allocation failure, this function exits.

   Note that while this function returns a pointer to malloc'd storage,
   the caller must not free it, since this function retains a pointer
   to the buffer and reuses it on any subsequent call.  As a consequence,
   this function is not thread-safe.  */
static char *
mbtolower (const char *beg, size_t *n)
{
  static char *out;
  static size_t outalloc;
  size_t outlen, mb_cur_max;
  mbstate_t is, os;
  const char *end;
  char *p;

  if (*n > outalloc)
    {
      out = xrealloc (out, *n);
      outalloc = *n;
    }

  memset (&is, 0, sizeof (is));
  memset (&os, 0, sizeof (os));
  end = beg + *n;

  mb_cur_max = MB_CUR_MAX;
  p = out;
  outlen = 0;
  while (beg < end)
    {
      wchar_t wc;
      size_t mbclen = mbrtowc(&wc, beg, end - beg, &is);
      if (outlen + mb_cur_max >= outalloc)
        {
          out = x2nrealloc (out, &outalloc, 1);
          p = out + outlen;
        }

      if (mbclen == (size_t) -1 || mbclen == (size_t) -2 || mbclen == 0)
        {
          /* An invalid sequence, or a truncated multi-octet character.
             We treat it as a single-octet character.  */
          *p++ = *beg++;
          outlen++;
          memset (&is, 0, sizeof (is));
          memset (&os, 0, sizeof (os));
        }
      else
        {
          beg += mbclen;
          mbclen = wcrtomb (p, towlower ((wint_t) wc), &os);
          p += mbclen;
          outlen += mbclen;
        }
    }

  *n = p - out;
  *p++ = 0;
  return out;
}
#endif


#ifndef FGREP_PROGRAM
/* DFA compiled regexp. */
static struct dfa dfa;

/* The Regex compiled patterns.  */
static struct patterns
{
  /* Regex compiled regexp. */
  struct re_pattern_buffer regexbuf;
  struct re_registers regs; /* This is here on account of a BRAIN-DEAD
			       Q@#%!# library interface in regex.c.  */
} patterns0;

struct patterns *patterns;
size_t pcount;

void
dfaerror (char const *mesg)
{
  error (EXIT_TROUBLE, 0, "%s", mesg);
}

/* Number of compiled fixed strings known to exactly match the regexp.
   If kwsexec returns < kwset_exact_matches, then we don't need to
   call the regexp matcher at all. */
static int kwset_exact_matches;

static char const *
kwsincr_case (const char *must)
{
  const char *buf;
  size_t n;

  n = strlen (must);
#ifdef MBS_SUPPORT
  if (match_icase && MB_CUR_MAX > 1)
    buf = mbtolower (must, &n);
  else
#endif
    buf = must;
  return kwsincr (kwset, buf, n);
}

/* If the DFA turns out to have some set of fixed strings one of
   which must occur in the match, then we build a kwset matcher
   to find those strings, and thus quickly filter out impossible
   matches. */
static void
kwsmusts (void)
{
  struct dfamust const *dm;
  char const *err;

  if (dfa.musts)
    {
      kwsinit ();
      /* First, we compile in the substrings known to be exact
	 matches.  The kwset matcher will return the index
	 of the matching string that it chooses. */
      for (dm = dfa.musts; dm; dm = dm->next)
	{
	  if (!dm->exact)
	    continue;
	  ++kwset_exact_matches;
	  if ((err = kwsincr_case (dm->must)) != NULL)
	    error (EXIT_TROUBLE, 0, "%s", err);
	}
      /* Now, we compile the substrings that will require
	 the use of the regexp matcher.  */
      for (dm = dfa.musts; dm; dm = dm->next)
	{
	  if (dm->exact)
	    continue;
	  if ((err = kwsincr_case (dm->must)) != NULL)
	    error (EXIT_TROUBLE, 0, "%s", err);
	}
      if ((err = kwsprep (kwset)) != NULL)
	error (EXIT_TROUBLE, 0, "%s", err);
    }
}
#endif /* !FGREP_PROGRAM */

#ifdef MBS_SUPPORT

static bool
is_mb_middle(const char **good, const char *buf, const char *end)
{
  const char *p = *good;
  const char *prev = p;
  mbstate_t cur_state;

  /* TODO: can be optimized for UTF-8.  */
  memset(&cur_state, 0, sizeof(mbstate_t));
  while (p < buf)
    {
      size_t mbclen = mbrlen(p, end - p, &cur_state);

      /* Store the beginning of the previous complete multibyte character.  */
      if (mbclen != (size_t) -2)
        prev = p;

      
//Patch 0:
if ((mbclen == (size_t)-1 || mbclen == (size_t)-2 || mbclen == 0) && !(__is_neg(6, &(mbclen), sizeof (mbclen), &(p), sizeof (p), &(prev), sizeof (prev), &(end), sizeof (end), &(buf), sizeof (buf), &(good), sizeof (good)))) {
    mbclen = 1;
}

//CodeSeg 1:
      p += mbclen;
    }

  *good = prev;
  return p > buf;
}
#endif /* MBS_SUPPORT */

#if defined(GREP_PROGRAM) || defined(EGREP_PROGRAM)
#ifdef EGREP_PROGRAM
COMPILE_FCT(Ecompile)
{
  reg_syntax_t syntax_bits = RE_SYNTAX_POSIX_EGREP;
#else
/* No __VA_ARGS__ in C89.  So we have to do it this way.  */
static COMPILE_RET
GEAcompile (char const *pattern, size_t size, reg_syntax_t syntax_bits)
{
#endif /* EGREP_PROGRAM */
  const char *err;
  const char *p, *sep;
  size_t total = size;
  char *motif;

  if (match_icase)
    syntax_bits |= RE_ICASE;
  re_set_syntax (syntax_bits);
  dfasyntax (syntax_bits, match_icase, eolbyte);

  /* For GNU regex compiler we have to pass the patterns separately to detect
     errors like "[\nallo\n]\n".  The patterns here are "[", "allo" and "]"
     GNU regex should have raise a syntax error.  The same for backref, where
     the backref should have been local to each pattern.  */
  p = pattern;
  do
    {
      size_t len;
      sep = memchr (p, '\n', total);
      if (sep)
	{
	  len = sep - p;
	  sep++;
	  total -= (len + 1);
	}
      else
	{
	  len = total;
	  total = 0;
	}

      patterns = realloc (patterns, (pcount + 1) * sizeof (*patterns));
      if (patterns == NULL)
	error (EXIT_TROUBLE, errno, _("memory exhausted"));
      patterns[pcount] = patterns0;

      if ((err = re_compile_pattern (p, len,
				    &(patterns[pcount].regexbuf))) != NULL)
	error (EXIT_TROUBLE, 0, "%s", err);
      pcount++;

      p = sep;
    } while (sep && total != 0);

  /* In the match_words and match_lines cases, we use a different pattern
     for the DFA matcher that will quickly throw out cases that won't work.
     Then if DFA succeeds we do some hairy stuff using the regex matcher
     to decide whether the match should really count. */
  if (match_words || match_lines)
    {
      static char const line_beg_no_bk[] = "^(";
      static char const line_end_no_bk[] = ")$";
      static char const word_beg_no_bk[] = "(^|[^[:alnum:]_])(";
      static char const word_end_no_bk[] = ")([^[:alnum:]_]|$)";
#ifdef EGREP_PROGRAM
# define IF_BK(x, y) (y)
      char *n = xmalloc (sizeof word_beg_no_bk - 1 + size + sizeof word_end_no_bk);
#else
      static char const line_beg_bk[] = "^\\(";
      static char const line_end_bk[] = "\\)$";
      static char const word_beg_bk[] = "\\(^\\|[^[:alnum:]_]\\)\\(";
      static char const word_end_bk[] = "\\)\\([^[:alnum:]_]\\|$\\)";
      int bk = !(syntax_bits & RE_NO_BK_PARENS);
# define IF_BK(x, y) ((bk) ? (x) : (y))
      char *n = xmalloc (sizeof word_beg_bk - 1 + size + sizeof word_end_bk);
#endif /* EGREP_PROGRAM */

      strcpy (n, match_lines ? IF_BK(line_beg_bk, line_beg_no_bk)
			     : IF_BK(word_beg_bk, word_beg_no_bk));
      total = strlen(n);
      memcpy (n + total, pattern, size);
      total += size;
      strcpy (n + total, match_lines ? IF_BK(line_end_bk, line_end_no_bk)
				     : IF_BK(word_end_bk, word_end_no_bk));
      total += strlen (n + total);
      pattern = motif = n;
      size = total;
    }
  else
    motif = NULL;

  dfacomp (pattern, size, &dfa, 1);
  kwsmusts ();

  free(motif);
}

#ifndef EGREP_PROGRAM
COMPILE_FCT(Gcompile)
{
  return GEAcompile (pattern, size,
		     RE_SYNTAX_GREP | RE_HAT_LISTS_NOT_NEWLINE);
}

COMPILE_FCT(Acompile)
{
  return GEAcompile (pattern, size, RE_SYNTAX_AWK);
}

COMPILE_FCT(Ecompile)
{
  return GEAcompile (pattern, size, RE_SYNTAX_POSIX_EGREP);
}
#endif /* !EGREP_PROGRAM */

EXECUTE_FCT(EGexecute)
{
  char const *buflim, *beg, *end, *match, *best_match, *mb_start;
  char eol = eolbyte;
  int backref, start, len, best_len;
  struct kwsmatch kwsm;
  size_t i, ret_val;
#ifdef MBS_SUPPORT
  if (MB_CUR_MAX > 1)
    {
      if (match_icase)
        {
          /* mbtolower adds a NUL byte at the end.  That will provide
	     space for the sentinel byte dfaexec may add.  */
          char *case_buf = mbtolower (buf, &size);
	  if (start_ptr)
	    start_ptr = case_buf + (start_ptr - buf);
          buf = case_buf;
        }
    }
#endif /* MBS_SUPPORT */

  mb_start = buf;
  buflim = buf + size;

  for (beg = end = buf; end < buflim; beg = end)
    {
      if (!start_ptr)
	{
	  /* We don't care about an exact match.  */
	  if (kwset)
	    {
	      /* Find a possible match using the KWset matcher. */
	      size_t offset = kwsexec (kwset, beg, buflim - beg, &kwsm);
	      if (offset == (size_t) -1)
		goto failure;
	      beg += offset;
	      /* Narrow down to the line containing the candidate, and
		 run it through DFA. */
	      if ((end = memchr(beg, eol, buflim - beg)) != NULL)
	        end++;
              else
                end = buflim;
	      match = beg;
	      while (beg > buf && beg[-1] != eol)
		--beg;
	      if (kwsm.index < kwset_exact_matches)
                {
#ifdef MBS_SUPPORT
                  if (mb_start < beg)
                    mb_start = beg;
                  if (MB_CUR_MAX == 1 || !is_mb_middle (&mb_start, match, buflim))
#endif
                    goto success;
                }
	      if (dfaexec (&dfa, beg, (char *) end, 0, NULL, &backref) == NULL)
		continue;
	    }
	  else
	    {
	      /* No good fixed strings; start with DFA. */
	      char const *next_beg = dfaexec (&dfa, beg, (char *) buflim,
					      0, NULL, &backref);
	      if (next_beg == NULL)
		break;
	      /* Narrow down to the line we've found. */
	      beg = next_beg;
	      if ((end = memchr(beg, eol, buflim - beg)) != NULL)
	        end++;
              else
                end = buflim;
	      while (beg > buf && beg[-1] != eol)
		--beg;
	    }
	  /* Successful, no backreferences encountered! */
	  if (!backref)
	    goto success;
	}
      else
	{
	  /* We are looking for the leftmost (then longest) exact match.
	     We will go through the outer loop only once.  */
	  beg = start_ptr;
	  end = buflim;
	}

      /* If we've made it to this point, this means DFA has seen
	 a probable match, and we need to run it through Regex. */
      best_match = end;
      best_len = 0;
      for (i = 0; i < pcount; i++)
	{
	  patterns[i].regexbuf.not_eol = 0;
	  if (0 <= (start = re_search (&(patterns[i].regexbuf),
				       buf, end - buf - 1,
				       beg - buf, end - beg - 1,
				       &(patterns[i].regs))))
	    {
	      len = patterns[i].regs.end[0] - start;
	      match = buf + start;
	      if (match > best_match)
		continue;
	      if (start_ptr && !match_words)
		goto assess_pattern_match;
	      if ((!match_lines && !match_words)
		  || (match_lines && len == end - beg - 1))
		{
		  match = beg;
		  len = end - beg;
		  goto assess_pattern_match;
		}
	      /* If -w, check if the match aligns with word boundaries.
		 We do this iteratively because:
		 (a) the line may contain more than one occurence of the
		 pattern, and
		 (b) Several alternatives in the pattern might be valid at a
		 given point, and we may need to consider a shorter one to
		 find a word boundary.  */
	      if (match_words)
		while (match <= best_match)
		  {
		    if ((match == buf || !WCHAR ((unsigned char) match[-1]))
			&& (len == end - beg - 1
			    || !WCHAR ((unsigned char) match[len])))
		      goto assess_pattern_match;
		    if (len > 0)
		      {
			/* Try a shorter length anchored at the same place. */
			--len;
			patterns[i].regexbuf.not_eol = 1;
			len = re_match (&(patterns[i].regexbuf),
					buf, match + len - beg, match - buf,
					&(patterns[i].regs));
		      }
		    if (len <= 0)
		      {
			/* Try looking further on. */
			if (match == end - 1)
			  break;
			match++;
			patterns[i].regexbuf.not_eol = 0;
			start = re_search (&(patterns[i].regexbuf),
					   buf, end - buf - 1,
					   match - buf, end - match - 1,
					   &(patterns[i].regs));
			if (start < 0)
			  break;
			len = patterns[i].regs.end[0] - start;
			match = buf + start;
		      }
		  } /* while (match <= best_match) */
	      continue;
	    assess_pattern_match:
	      if (!start_ptr)
		{
		  /* Good enough for a non-exact match.
		     No need to look at further patterns, if any.  */
		  beg = match;
		  goto success_in_len;
		}
	      if (match < best_match || (match == best_match && len > best_len))
		{
		  /* Best exact match:  leftmost, then longest.  */
		  best_match = match;
		  best_len = len;
		}
	    } /* if re_search >= 0 */
	} /* for Regex patterns.  */
	if (best_match < end)
	  {
	    /* We have found an exact match.  We were just
	       waiting for the best one (leftmost then longest).  */
	    beg = best_match;
	    len = best_len;
	    goto success_in_len;
	  }
    } /* for (beg = end ..) */

 failure:
  ret_val = -1;
  goto out;

 success:
  len = end - beg;
 success_in_len:
  *match_size = len;
  ret_val = beg - buf;
 out:
  return ret_val;
}
#endif /* defined(GREP_PROGRAM) || defined(EGREP_PROGRAM) */

#if defined(GREP_PROGRAM) || defined(FGREP_PROGRAM)
COMPILE_FCT(Fcompile)
{
  char const *beg, *end, *lim, *err, *pat;
  size_t psize;

  kwsinit ();
  psize = size;
  if (match_icase && MB_CUR_MAX > 1)
    pat = mbtolower (pattern, &psize);
  else
    pat = pattern;

  beg = pat;
  do
    {
      for (lim = beg;; ++lim)
	{
	  end = lim;
	  if (lim >= pat + psize)
	    break;
	 if (*lim == '\n')
	   {
	     lim++;
	     break;
	   }
#if HAVE_DOS_FILE_CONTENTS
	 if (*lim == '\r' && lim + 1 < pat + psize && lim[1] == '\n')
	   {
	     lim += 2;
	     break;
	   }
#endif
	}

      if ((err = kwsincr (kwset, beg, end - beg)) != NULL)
	error (EXIT_TROUBLE, 0, "%s", err);
      beg = lim;
    }
  while (beg < pat + psize);

  if ((err = kwsprep (kwset)) != NULL)
    error (EXIT_TROUBLE, 0, "%s", err);
}

EXECUTE_FCT(Fexecute)
{
  char const *beg, *try, *end, *mb_start;
  size_t len;
  char eol = eolbyte;
  struct kwsmatch kwsmatch;
  size_t ret_val;
#ifdef MBS_SUPPORT
  if (MB_CUR_MAX > 1)
    {
      if (match_icase)
        {
          char *case_buf = mbtolower (buf, &size);
	  if (start_ptr)
	    start_ptr = case_buf + (start_ptr - buf);
          buf = case_buf;
        }
    }
#endif /* MBS_SUPPORT */

  for (mb_start = beg = start_ptr ? start_ptr : buf; beg <= buf + size; beg++)
    {
      size_t offset = kwsexec (kwset, beg, buf + size - beg, &kwsmatch);
      if (offset == (size_t) -1)
	goto failure;
#ifdef MBS_SUPPORT
      if (MB_CUR_MAX > 1 && is_mb_middle (&mb_start, beg + offset, buf + size))
        {
          beg = mb_start - 1;
          continue; /* It is a part of multibyte character.  */
        }
#endif /* MBS_SUPPORT */
      beg += offset;
      len = kwsmatch.size[0];
      if (start_ptr && !match_words)
	goto success_in_beg_and_len;
      if (match_lines)
	{
	  if (beg > buf && beg[-1] != eol)
	    continue;
	  if (beg + len < buf + size && beg[len] != eol)
	    continue;
	  goto success;
	}
      else if (match_words)
	for (try = beg; len; )
	  {
	    if (try > buf && WCHAR((unsigned char) try[-1]))
	      break;
	    if (try + len < buf + size && WCHAR((unsigned char) try[len]))
	      {
		offset = kwsexec (kwset, beg, --len, &kwsmatch);
		if (offset == (size_t) -1)
		  break;
		try = beg + offset;
		len = kwsmatch.size[0];
	      }
	    else if (!start_ptr)
	      goto success;
	    else
	      goto success_in_beg_and_len;
	  } /* for (try) */
      else
	goto success;
    } /* for (beg in buf) */

 failure:
  ret_val = -1;
  goto out;

 success:
  if ((end = memchr (beg + len, eol, (buf + size) - (beg + len))) != NULL)
    end++;
  else
    end = buf + size;
  while (buf < beg && beg[-1] != eol)
    --beg;
  len = end - beg;
 success_in_beg_and_len:
  *match_size = len;
  ret_val = beg - buf;
 out:
  return ret_val;
}
#endif /* defined(GREP_PROGRAM) || defined(FGREP_PROGRAM) */

#ifdef GREP_PROGRAM
#if HAVE_LIBPCRE
/* Compiled internal form of a Perl regular expression.  */
static pcre *cre;

/* Additional information about the pattern.  */
static pcre_extra *extra;
#endif

COMPILE_FCT(Pcompile)
{
#if !HAVE_LIBPCRE
  error (EXIT_TROUBLE, 0, "%s",
	 _("support for the -P option is not compiled into "
	   "this --disable-perl-regexp binary"));
#else
  int e;
  char const *ep;
  char *re = xmalloc (4 * size + 7);
  int flags = PCRE_MULTILINE | (match_icase ? PCRE_CASELESS : 0);
  char const *patlim = pattern + size;
  char *n = re;
  char const *p;
  char const *pnul;

  /* FIXME: Remove these restrictions.  */
  if (memchr(pattern, '\n', size))
    error (EXIT_TROUBLE, 0, _("the -P option only supports a single pattern"));

  *n = '\0';
  if (match_lines)
    strcpy (n, "^(");
  if (match_words)
    strcpy (n, "\\b(");
  n += strlen (n);

  /* The PCRE interface doesn't allow NUL bytes in the pattern, so
     replace each NUL byte in the pattern with the four characters
     "\000", removing a preceding backslash if there are an odd
     number of backslashes before the NUL.

     FIXME: This method does not work with some multibyte character
     encodings, notably Shift-JIS, where a multibyte character can end
     in a backslash byte.  */
  for (p = pattern; (pnul = memchr (p, '\0', patlim - p)); p = pnul + 1)
    {
      memcpy (n, p, pnul - p);
      n += pnul - p;
      for (p = pnul; pattern < p && p[-1] == '\\'; p--)
	continue;
      n -= (pnul - p) & 1;
      strcpy (n, "\\000");
      n += 4;
    }

  memcpy (n, p, patlim - p);
  n += patlim - p;
  *n = '\0';
  if (match_words)
    strcpy (n, ")\\b");
  if (match_lines)
    strcpy (n, ")$");

  cre = pcre_compile (re, flags, &ep, &e, pcre_maketables ());
  if (!cre)
    error (EXIT_TROUBLE, 0, "%s", ep);

  extra = pcre_study (cre, 0, &ep);
  if (ep)
    error (EXIT_TROUBLE, 0, "%s", ep);

  free (re);
#endif
}

EXECUTE_FCT(Pexecute)
{
#if !HAVE_LIBPCRE
  abort ();
  return -1;
#else
  /* This array must have at least two elements; everything after that
     is just for performance improvement in pcre_exec.  */
  int sub[300];

  const char *line_buf, *line_end, *line_next;
  int e = PCRE_ERROR_NOMATCH;
  ptrdiff_t start_ofs = start_ptr ? start_ptr - buf : 0;

  /* PCRE can't limit the matching to single lines, therefore we have to
     match each line in the buffer separately.  */
  for (line_next = buf;
       e == PCRE_ERROR_NOMATCH && line_next < buf + size;
       start_ofs -= line_next - line_buf)
    {
      line_buf = line_next;
      line_end = memchr (line_buf, eolbyte, (buf + size) - line_buf);
      if (line_end == NULL)
        line_next = line_end = buf + size;
      else
        line_next = line_end + 1;

      if (start_ptr && start_ptr >= line_end)
        continue;

      e = pcre_exec (cre, extra, line_buf, line_end - line_buf,
                     start_ofs < 0 ? 0 : start_ofs, 0,
                     sub, sizeof sub / sizeof *sub);
    }

  if (e <= 0)
    {
      switch (e)
	{
	case PCRE_ERROR_NOMATCH:
	  return -1;

	case PCRE_ERROR_NOMEMORY:
	  error (EXIT_TROUBLE, 0, _("memory exhausted"));

	default:
	  abort ();
	}
    }
  else
    {
      /* Narrow down to the line we've found.  */
      char const *beg = line_buf + sub[0];
      char const *end = line_buf + sub[1];
      char const *buflim = buf + size;
      char eol = eolbyte;
      if (!start_ptr)
	{
	  /* FIXME: The case when '\n' is not found indicates a bug:
	     Since grep is line oriented, the match should never contain
	     a newline, so there _must_ be a newline following.
	   */
	  if (!(end = memchr (end, eol, buflim - end)))
	    end = buflim;
	  else
	    end++;
	  while (buf < beg && beg[-1] != eol)
	    --beg;
	}

      *match_size = end - beg;
      return beg - buf;
    }
#endif
}

struct matcher const matchers[] = {
  { "default", Gcompile, EGexecute },
  { "grep",    Gcompile, EGexecute },
  { "egrep",   Ecompile, EGexecute },
  { "awk",     Acompile, EGexecute },
  { "fgrep",   Fcompile, Fexecute },
  { "perl",    Pcompile, Pexecute },
  { "", 0, 0 },
};
#endif /* GREP_PROGRAM */

Testing negative cases!
Testing 0 (with abstract condition) ENVIS_NEG
Iteration 0
Running test command:
/home/ubuntu/spr-fast/tools/grep-test.py /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-deccad69-db9d6340/tempworkdir2/src /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-deccad69-db9d6340/tempworkdir2/tests /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-deccad69-db9d6340/tempworkdir2 0  > __res
Opening:/home/ubuntu/spr-fast/tests/corebench/grep/grep-case-deccad69-db9d6340/tempworkdir2/neg.tmp!
NegativeBRANCH RECORD/home/ubuntu/spr-fast/tests/corebench/grep/grep-case-deccad69-db9d6340/tempworkdir2/neg.tmp!
Not caught by the negative case, give up!
APPENDING TO ISNEG:/home/ubuntu/spr-fast/tests/corebench/grep/grep-case-deccad69-db9d6340/tempworkdir2/neg.tmp!
Running test command:
/home/ubuntu/spr-fast/tools/grep-test.py /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-deccad69-db9d6340/tempworkdir2/src /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-deccad69-db9d6340/tempworkdir2/tests /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-deccad69-db9d6340/tempworkdir2 0  > __res
CondTester, Testing instance id 28:
//src_file:src/search.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
/* search.c - searching subroutines using dfa, kwset and regex for grep.
   Copyright 1992, 1998, 2000, 2007, 2009-2010 Free Software Foundation, Inc.

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 3, or (at your option)
   any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program; if not, write to the Free Software
   Foundation, Inc., 51 Franklin Street - Fifth Floor, Boston, MA
   02110-1301, USA.  */

/* Written August 1992 by Mike Haertel. */

#include <config.h>

#include <sys/types.h>

#include "mbsupport.h"
#ifdef MBS_SUPPORT
/* We can handle multibyte strings. */
# include <wchar.h>
# include <wctype.h>
#endif

#include "system.h"
#include "grep.h"
#ifndef FGREP_PROGRAM
# include <regex.h>
# include "dfa.h"
#endif
#include "kwset.h"
#include "error.h"
#include "xalloc.h"
#ifdef HAVE_LIBPCRE
# include <pcre.h>
#endif

#define NCHAR (UCHAR_MAX + 1)

/* For -w, we also consider _ to be word constituent.  */
#define WCHAR(C) (ISALNUM(C) || (C) == '_')

/* KWset compiled pattern.  For Ecompile and Gcompile, we compile
   a list of strings, at least one of which is known to occur in
   any string matching the regexp. */
static kwset_t kwset;

static void
kwsinit (void)
{
  static char trans[NCHAR];
  int i;

  if (match_icase && MB_CUR_MAX == 1)
    {
      for (i = 0; i < NCHAR; ++i)
        trans[i] = TOLOWER (i);

      kwset = kwsalloc (trans);
    }
  else
    kwset = kwsalloc (NULL);

  if (!kwset)
    xalloc_die ();
}

#ifdef MBS_SUPPORT
/* Convert the *N-byte string, BEG, to lowercase, and write the
   NUL-terminated result into malloc'd storage.  Upon success, set *N
   to the length (in bytes) of the resulting string (not including the
   trailing NUL byte), and return a pointer to the lowercase string.
   Upon memory allocation failure, this function exits.

   Note that while this function returns a pointer to malloc'd storage,
   the caller must not free it, since this function retains a pointer
   to the buffer and reuses it on any subsequent call.  As a consequence,
   this function is not thread-safe.  */
static char *
mbtolower (const char *beg, size_t *n)
{
  static char *out;
  static size_t outalloc;
  size_t outlen, mb_cur_max;
  mbstate_t is, os;
  const char *end;
  char *p;

  if (*n > outalloc)
    {
      out = xrealloc (out, *n);
      outalloc = *n;
    }

  memset (&is, 0, sizeof (is));
  memset (&os, 0, sizeof (os));
  end = beg + *n;

  mb_cur_max = MB_CUR_MAX;
  p = out;
  outlen = 0;
  while (beg < end)
    {
      wchar_t wc;
      size_t mbclen = mbrtowc(&wc, beg, end - beg, &is);
      if (outlen + mb_cur_max >= outalloc)
        {
          out = x2nrealloc (out, &outalloc, 1);
          p = out + outlen;
        }

      if (mbclen == (size_t) -1 || mbclen == (size_t) -2 || mbclen == 0)
        {
          /* An invalid sequence, or a truncated multi-octet character.
             We treat it as a single-octet character.  */
          *p++ = *beg++;
          outlen++;
          memset (&is, 0, sizeof (is));
          memset (&os, 0, sizeof (os));
        }
      else
        {
          beg += mbclen;
          mbclen = wcrtomb (p, towlower ((wint_t) wc), &os);
          p += mbclen;
          outlen += mbclen;
        }
    }

  *n = p - out;
  *p++ = 0;
  return out;
}
#endif


#ifndef FGREP_PROGRAM
/* DFA compiled regexp. */
static struct dfa dfa;

/* The Regex compiled patterns.  */
static struct patterns
{
  /* Regex compiled regexp. */
  struct re_pattern_buffer regexbuf;
  struct re_registers regs; /* This is here on account of a BRAIN-DEAD
			       Q@#%!# library interface in regex.c.  */
} patterns0;

struct patterns *patterns;
size_t pcount;

void
dfaerror (char const *mesg)
{
  error (EXIT_TROUBLE, 0, "%s", mesg);
}

/* Number of compiled fixed strings known to exactly match the regexp.
   If kwsexec returns < kwset_exact_matches, then we don't need to
   call the regexp matcher at all. */
static int kwset_exact_matches;

static char const *
kwsincr_case (const char *must)
{
  const char *buf;
  size_t n;

  n = strlen (must);
#ifdef MBS_SUPPORT
  if (match_icase && MB_CUR_MAX > 1)
    buf = mbtolower (must, &n);
  else
#endif
    buf = must;
  return kwsincr (kwset, buf, n);
}

/* If the DFA turns out to have some set of fixed strings one of
   which must occur in the match, then we build a kwset matcher
   to find those strings, and thus quickly filter out impossible
   matches. */
static void
kwsmusts (void)
{
  struct dfamust const *dm;
  char const *err;

  if (dfa.musts)
    {
      kwsinit ();
      /* First, we compile in the substrings known to be exact
	 matches.  The kwset matcher will return the index
	 of the matching string that it chooses. */
      for (dm = dfa.musts; dm; dm = dm->next)
	{
	  if (!dm->exact)
	    continue;
	  ++kwset_exact_matches;
	  if ((err = kwsincr_case (dm->must)) != NULL)
	    error (EXIT_TROUBLE, 0, "%s", err);
	}
      /* Now, we compile the substrings that will require
	 the use of the regexp matcher.  */
      for (dm = dfa.musts; dm; dm = dm->next)
	{
	  if (dm->exact)
	    continue;
	  if ((err = kwsincr_case (dm->must)) != NULL)
	    error (EXIT_TROUBLE, 0, "%s", err);
	}
      if ((err = kwsprep (kwset)) != NULL)
	error (EXIT_TROUBLE, 0, "%s", err);
    }
}
#endif /* !FGREP_PROGRAM */

#ifdef MBS_SUPPORT

static bool
is_mb_middle(const char **good, const char *buf, const char *end)
{
  const char *p = *good;
  const char *prev = p;
  mbstate_t cur_state;

  /* TODO: can be optimized for UTF-8.  */
  memset(&cur_state, 0, sizeof(mbstate_t));
  while (p < buf)
    {
      size_t mbclen = mbrlen(p, end - p, &cur_state);

      /* Store the beginning of the previous complete multibyte character.  */
      if (mbclen != (size_t) -2)
        prev = p;

      
//Patch 0:
if ((mbclen == (size_t)-1 || mbclen == (size_t)-2 || mbclen == 0) || (__is_neg(6, &(mbclen), sizeof (mbclen), &(p), sizeof (p), &(prev), sizeof (prev), &(end), sizeof (end), &(buf), sizeof (buf), &(good), sizeof (good)))) {
    mbclen = 1;
}

//CodeSeg 1:
      p += mbclen;
    }

  *good = prev;
  return p > buf;
}
#endif /* MBS_SUPPORT */

#if defined(GREP_PROGRAM) || defined(EGREP_PROGRAM)
#ifdef EGREP_PROGRAM
COMPILE_FCT(Ecompile)
{
  reg_syntax_t syntax_bits = RE_SYNTAX_POSIX_EGREP;
#else
/* No __VA_ARGS__ in C89.  So we have to do it this way.  */
static COMPILE_RET
GEAcompile (char const *pattern, size_t size, reg_syntax_t syntax_bits)
{
#endif /* EGREP_PROGRAM */
  const char *err;
  const char *p, *sep;
  size_t total = size;
  char *motif;

  if (match_icase)
    syntax_bits |= RE_ICASE;
  re_set_syntax (syntax_bits);
  dfasyntax (syntax_bits, match_icase, eolbyte);

  /* For GNU regex compiler we have to pass the patterns separately to detect
     errors like "[\nallo\n]\n".  The patterns here are "[", "allo" and "]"
     GNU regex should have raise a syntax error.  The same for backref, where
     the backref should have been local to each pattern.  */
  p = pattern;
  do
    {
      size_t len;
      sep = memchr (p, '\n', total);
      if (sep)
	{
	  len = sep - p;
	  sep++;
	  total -= (len + 1);
	}
      else
	{
	  len = total;
	  total = 0;
	}

      patterns = realloc (patterns, (pcount + 1) * sizeof (*patterns));
      if (patterns == NULL)
	error (EXIT_TROUBLE, errno, _("memory exhausted"));
      patterns[pcount] = patterns0;

      if ((err = re_compile_pattern (p, len,
				    &(patterns[pcount].regexbuf))) != NULL)
	error (EXIT_TROUBLE, 0, "%s", err);
      pcount++;

      p = sep;
    } while (sep && total != 0);

  /* In the match_words and match_lines cases, we use a different pattern
     for the DFA matcher that will quickly throw out cases that won't work.
     Then if DFA succeeds we do some hairy stuff using the regex matcher
     to decide whether the match should really count. */
  if (match_words || match_lines)
    {
      static char const line_beg_no_bk[] = "^(";
      static char const line_end_no_bk[] = ")$";
      static char const word_beg_no_bk[] = "(^|[^[:alnum:]_])(";
      static char const word_end_no_bk[] = ")([^[:alnum:]_]|$)";
#ifdef EGREP_PROGRAM
# define IF_BK(x, y) (y)
      char *n = xmalloc (sizeof word_beg_no_bk - 1 + size + sizeof word_end_no_bk);
#else
      static char const line_beg_bk[] = "^\\(";
      static char const line_end_bk[] = "\\)$";
      static char const word_beg_bk[] = "\\(^\\|[^[:alnum:]_]\\)\\(";
      static char const word_end_bk[] = "\\)\\([^[:alnum:]_]\\|$\\)";
      int bk = !(syntax_bits & RE_NO_BK_PARENS);
# define IF_BK(x, y) ((bk) ? (x) : (y))
      char *n = xmalloc (sizeof word_beg_bk - 1 + size + sizeof word_end_bk);
#endif /* EGREP_PROGRAM */

      strcpy (n, match_lines ? IF_BK(line_beg_bk, line_beg_no_bk)
			     : IF_BK(word_beg_bk, word_beg_no_bk));
      total = strlen(n);
      memcpy (n + total, pattern, size);
      total += size;
      strcpy (n + total, match_lines ? IF_BK(line_end_bk, line_end_no_bk)
				     : IF_BK(word_end_bk, word_end_no_bk));
      total += strlen (n + total);
      pattern = motif = n;
      size = total;
    }
  else
    motif = NULL;

  dfacomp (pattern, size, &dfa, 1);
  kwsmusts ();

  free(motif);
}

#ifndef EGREP_PROGRAM
COMPILE_FCT(Gcompile)
{
  return GEAcompile (pattern, size,
		     RE_SYNTAX_GREP | RE_HAT_LISTS_NOT_NEWLINE);
}

COMPILE_FCT(Acompile)
{
  return GEAcompile (pattern, size, RE_SYNTAX_AWK);
}

COMPILE_FCT(Ecompile)
{
  return GEAcompile (pattern, size, RE_SYNTAX_POSIX_EGREP);
}
#endif /* !EGREP_PROGRAM */

EXECUTE_FCT(EGexecute)
{
  char const *buflim, *beg, *end, *match, *best_match, *mb_start;
  char eol = eolbyte;
  int backref, start, len, best_len;
  struct kwsmatch kwsm;
  size_t i, ret_val;
#ifdef MBS_SUPPORT
  if (MB_CUR_MAX > 1)
    {
      if (match_icase)
        {
          /* mbtolower adds a NUL byte at the end.  That will provide
	     space for the sentinel byte dfaexec may add.  */
          char *case_buf = mbtolower (buf, &size);
	  if (start_ptr)
	    start_ptr = case_buf + (start_ptr - buf);
          buf = case_buf;
        }
    }
#endif /* MBS_SUPPORT */

  mb_start = buf;
  buflim = buf + size;

  for (beg = end = buf; end < buflim; beg = end)
    {
      if (!start_ptr)
	{
	  /* We don't care about an exact match.  */
	  if (kwset)
	    {
	      /* Find a possible match using the KWset matcher. */
	      size_t offset = kwsexec (kwset, beg, buflim - beg, &kwsm);
	      if (offset == (size_t) -1)
		goto failure;
	      beg += offset;
	      /* Narrow down to the line containing the candidate, and
		 run it through DFA. */
	      if ((end = memchr(beg, eol, buflim - beg)) != NULL)
	        end++;
              else
                end = buflim;
	      match = beg;
	      while (beg > buf && beg[-1] != eol)
		--beg;
	      if (kwsm.index < kwset_exact_matches)
                {
#ifdef MBS_SUPPORT
                  if (mb_start < beg)
                    mb_start = beg;
                  if (MB_CUR_MAX == 1 || !is_mb_middle (&mb_start, match, buflim))
#endif
                    goto success;
                }
	      if (dfaexec (&dfa, beg, (char *) end, 0, NULL, &backref) == NULL)
		continue;
	    }
	  else
	    {
	      /* No good fixed strings; start with DFA. */
	      char const *next_beg = dfaexec (&dfa, beg, (char *) buflim,
					      0, NULL, &backref);
	      if (next_beg == NULL)
		break;
	      /* Narrow down to the line we've found. */
	      beg = next_beg;
	      if ((end = memchr(beg, eol, buflim - beg)) != NULL)
	        end++;
              else
                end = buflim;
	      while (beg > buf && beg[-1] != eol)
		--beg;
	    }
	  /* Successful, no backreferences encountered! */
	  if (!backref)
	    goto success;
	}
      else
	{
	  /* We are looking for the leftmost (then longest) exact match.
	     We will go through the outer loop only once.  */
	  beg = start_ptr;
	  end = buflim;
	}

      /* If we've made it to this point, this means DFA has seen
	 a probable match, and we need to run it through Regex. */
      best_match = end;
      best_len = 0;
      for (i = 0; i < pcount; i++)
	{
	  patterns[i].regexbuf.not_eol = 0;
	  if (0 <= (start = re_search (&(patterns[i].regexbuf),
				       buf, end - buf - 1,
				       beg - buf, end - beg - 1,
				       &(patterns[i].regs))))
	    {
	      len = patterns[i].regs.end[0] - start;
	      match = buf + start;
	      if (match > best_match)
		continue;
	      if (start_ptr && !match_words)
		goto assess_pattern_match;
	      if ((!match_lines && !match_words)
		  || (match_lines && len == end - beg - 1))
		{
		  match = beg;
		  len = end - beg;
		  goto assess_pattern_match;
		}
	      /* If -w, check if the match aligns with word boundaries.
		 We do this iteratively because:
		 (a) the line may contain more than one occurence of the
		 pattern, and
		 (b) Several alternatives in the pattern might be valid at a
		 given point, and we may need to consider a shorter one to
		 find a word boundary.  */
	      if (match_words)
		while (match <= best_match)
		  {
		    if ((match == buf || !WCHAR ((unsigned char) match[-1]))
			&& (len == end - beg - 1
			    || !WCHAR ((unsigned char) match[len])))
		      goto assess_pattern_match;
		    if (len > 0)
		      {
			/* Try a shorter length anchored at the same place. */
			--len;
			patterns[i].regexbuf.not_eol = 1;
			len = re_match (&(patterns[i].regexbuf),
					buf, match + len - beg, match - buf,
					&(patterns[i].regs));
		      }
		    if (len <= 0)
		      {
			/* Try looking further on. */
			if (match == end - 1)
			  break;
			match++;
			patterns[i].regexbuf.not_eol = 0;
			start = re_search (&(patterns[i].regexbuf),
					   buf, end - buf - 1,
					   match - buf, end - match - 1,
					   &(patterns[i].regs));
			if (start < 0)
			  break;
			len = patterns[i].regs.end[0] - start;
			match = buf + start;
		      }
		  } /* while (match <= best_match) */
	      continue;
	    assess_pattern_match:
	      if (!start_ptr)
		{
		  /* Good enough for a non-exact match.
		     No need to look at further patterns, if any.  */
		  beg = match;
		  goto success_in_len;
		}
	      if (match < best_match || (match == best_match && len > best_len))
		{
		  /* Best exact match:  leftmost, then longest.  */
		  best_match = match;
		  best_len = len;
		}
	    } /* if re_search >= 0 */
	} /* for Regex patterns.  */
	if (best_match < end)
	  {
	    /* We have found an exact match.  We were just
	       waiting for the best one (leftmost then longest).  */
	    beg = best_match;
	    len = best_len;
	    goto success_in_len;
	  }
    } /* for (beg = end ..) */

 failure:
  ret_val = -1;
  goto out;

 success:
  len = end - beg;
 success_in_len:
  *match_size = len;
  ret_val = beg - buf;
 out:
  return ret_val;
}
#endif /* defined(GREP_PROGRAM) || defined(EGREP_PROGRAM) */

#if defined(GREP_PROGRAM) || defined(FGREP_PROGRAM)
COMPILE_FCT(Fcompile)
{
  char const *beg, *end, *lim, *err, *pat;
  size_t psize;

  kwsinit ();
  psize = size;
  if (match_icase && MB_CUR_MAX > 1)
    pat = mbtolower (pattern, &psize);
  else
    pat = pattern;

  beg = pat;
  do
    {
      for (lim = beg;; ++lim)
	{
	  end = lim;
	  if (lim >= pat + psize)
	    break;
	 if (*lim == '\n')
	   {
	     lim++;
	     break;
	   }
#if HAVE_DOS_FILE_CONTENTS
	 if (*lim == '\r' && lim + 1 < pat + psize && lim[1] == '\n')
	   {
	     lim += 2;
	     break;
	   }
#endif
	}

      if ((err = kwsincr (kwset, beg, end - beg)) != NULL)
	error (EXIT_TROUBLE, 0, "%s", err);
      beg = lim;
    }
  while (beg < pat + psize);

  if ((err = kwsprep (kwset)) != NULL)
    error (EXIT_TROUBLE, 0, "%s", err);
}

EXECUTE_FCT(Fexecute)
{
  char const *beg, *try, *end, *mb_start;
  size_t len;
  char eol = eolbyte;
  struct kwsmatch kwsmatch;
  size_t ret_val;
#ifdef MBS_SUPPORT
  if (MB_CUR_MAX > 1)
    {
      if (match_icase)
        {
          char *case_buf = mbtolower (buf, &size);
	  if (start_ptr)
	    start_ptr = case_buf + (start_ptr - buf);
          buf = case_buf;
        }
    }
#endif /* MBS_SUPPORT */

  for (mb_start = beg = start_ptr ? start_ptr : buf; beg <= buf + size; beg++)
    {
      size_t offset = kwsexec (kwset, beg, buf + size - beg, &kwsmatch);
      if (offset == (size_t) -1)
	goto failure;
#ifdef MBS_SUPPORT
      if (MB_CUR_MAX > 1 && is_mb_middle (&mb_start, beg + offset, buf + size))
        {
          beg = mb_start - 1;
          continue; /* It is a part of multibyte character.  */
        }
#endif /* MBS_SUPPORT */
      beg += offset;
      len = kwsmatch.size[0];
      if (start_ptr && !match_words)
	goto success_in_beg_and_len;
      if (match_lines)
	{
	  if (beg > buf && beg[-1] != eol)
	    continue;
	  if (beg + len < buf + size && beg[len] != eol)
	    continue;
	  goto success;
	}
      else if (match_words)
	for (try = beg; len; )
	  {
	    if (try > buf && WCHAR((unsigned char) try[-1]))
	      break;
	    if (try + len < buf + size && WCHAR((unsigned char) try[len]))
	      {
		offset = kwsexec (kwset, beg, --len, &kwsmatch);
		if (offset == (size_t) -1)
		  break;
		try = beg + offset;
		len = kwsmatch.size[0];
	      }
	    else if (!start_ptr)
	      goto success;
	    else
	      goto success_in_beg_and_len;
	  } /* for (try) */
      else
	goto success;
    } /* for (beg in buf) */

 failure:
  ret_val = -1;
  goto out;

 success:
  if ((end = memchr (beg + len, eol, (buf + size) - (beg + len))) != NULL)
    end++;
  else
    end = buf + size;
  while (buf < beg && beg[-1] != eol)
    --beg;
  len = end - beg;
 success_in_beg_and_len:
  *match_size = len;
  ret_val = beg - buf;
 out:
  return ret_val;
}
#endif /* defined(GREP_PROGRAM) || defined(FGREP_PROGRAM) */

#ifdef GREP_PROGRAM
#if HAVE_LIBPCRE
/* Compiled internal form of a Perl regular expression.  */
static pcre *cre;

/* Additional information about the pattern.  */
static pcre_extra *extra;
#endif

COMPILE_FCT(Pcompile)
{
#if !HAVE_LIBPCRE
  error (EXIT_TROUBLE, 0, "%s",
	 _("support for the -P option is not compiled into "
	   "this --disable-perl-regexp binary"));
#else
  int e;
  char const *ep;
  char *re = xmalloc (4 * size + 7);
  int flags = PCRE_MULTILINE | (match_icase ? PCRE_CASELESS : 0);
  char const *patlim = pattern + size;
  char *n = re;
  char const *p;
  char const *pnul;

  /* FIXME: Remove these restrictions.  */
  if (memchr(pattern, '\n', size))
    error (EXIT_TROUBLE, 0, _("the -P option only supports a single pattern"));

  *n = '\0';
  if (match_lines)
    strcpy (n, "^(");
  if (match_words)
    strcpy (n, "\\b(");
  n += strlen (n);

  /* The PCRE interface doesn't allow NUL bytes in the pattern, so
     replace each NUL byte in the pattern with the four characters
     "\000", removing a preceding backslash if there are an odd
     number of backslashes before the NUL.

     FIXME: This method does not work with some multibyte character
     encodings, notably Shift-JIS, where a multibyte character can end
     in a backslash byte.  */
  for (p = pattern; (pnul = memchr (p, '\0', patlim - p)); p = pnul + 1)
    {
      memcpy (n, p, pnul - p);
      n += pnul - p;
      for (p = pnul; pattern < p && p[-1] == '\\'; p--)
	continue;
      n -= (pnul - p) & 1;
      strcpy (n, "\\000");
      n += 4;
    }

  memcpy (n, p, patlim - p);
  n += patlim - p;
  *n = '\0';
  if (match_words)
    strcpy (n, ")\\b");
  if (match_lines)
    strcpy (n, ")$");

  cre = pcre_compile (re, flags, &ep, &e, pcre_maketables ());
  if (!cre)
    error (EXIT_TROUBLE, 0, "%s", ep);

  extra = pcre_study (cre, 0, &ep);
  if (ep)
    error (EXIT_TROUBLE, 0, "%s", ep);

  free (re);
#endif
}

EXECUTE_FCT(Pexecute)
{
#if !HAVE_LIBPCRE
  abort ();
  return -1;
#else
  /* This array must have at least two elements; everything after that
     is just for performance improvement in pcre_exec.  */
  int sub[300];

  const char *line_buf, *line_end, *line_next;
  int e = PCRE_ERROR_NOMATCH;
  ptrdiff_t start_ofs = start_ptr ? start_ptr - buf : 0;

  /* PCRE can't limit the matching to single lines, therefore we have to
     match each line in the buffer separately.  */
  for (line_next = buf;
       e == PCRE_ERROR_NOMATCH && line_next < buf + size;
       start_ofs -= line_next - line_buf)
    {
      line_buf = line_next;
      line_end = memchr (line_buf, eolbyte, (buf + size) - line_buf);
      if (line_end == NULL)
        line_next = line_end = buf + size;
      else
        line_next = line_end + 1;

      if (start_ptr && start_ptr >= line_end)
        continue;

      e = pcre_exec (cre, extra, line_buf, line_end - line_buf,
                     start_ofs < 0 ? 0 : start_ofs, 0,
                     sub, sizeof sub / sizeof *sub);
    }

  if (e <= 0)
    {
      switch (e)
	{
	case PCRE_ERROR_NOMATCH:
	  return -1;

	case PCRE_ERROR_NOMEMORY:
	  error (EXIT_TROUBLE, 0, _("memory exhausted"));

	default:
	  abort ();
	}
    }
  else
    {
      /* Narrow down to the line we've found.  */
      char const *beg = line_buf + sub[0];
      char const *end = line_buf + sub[1];
      char const *buflim = buf + size;
      char eol = eolbyte;
      if (!start_ptr)
	{
	  /* FIXME: The case when '\n' is not found indicates a bug:
	     Since grep is line oriented, the match should never contain
	     a newline, so there _must_ be a newline following.
	   */
	  if (!(end = memchr (end, eol, buflim - end)))
	    end = buflim;
	  else
	    end++;
	  while (buf < beg && beg[-1] != eol)
	    --beg;
	}

      *match_size = end - beg;
      return beg - buf;
    }
#endif
}

struct matcher const matchers[] = {
  { "default", Gcompile, EGexecute },
  { "grep",    Gcompile, EGexecute },
  { "egrep",   Ecompile, EGexecute },
  { "awk",     Acompile, EGexecute },
  { "fgrep",   Fcompile, Fexecute },
  { "perl",    Pcompile, Pexecute },
  { "", 0, 0 },
};
#endif /* GREP_PROGRAM */

Testing negative cases!
Testing 0 (with abstract condition) ENVIS_NEG
Iteration 0
Running test command:
/home/ubuntu/spr-fast/tools/grep-test.py /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-deccad69-db9d6340/tempworkdir2/src /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-deccad69-db9d6340/tempworkdir2/tests /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-deccad69-db9d6340/tempworkdir2 0  > __res
Opening:/home/ubuntu/spr-fast/tests/corebench/grep/grep-case-deccad69-db9d6340/tempworkdir2/neg.tmp!
NegativeBRANCH RECORD/home/ubuntu/spr-fast/tests/corebench/grep/grep-case-deccad69-db9d6340/tempworkdir2/neg.tmp!
APPENDING TO ISNEG:/home/ubuntu/spr-fast/tests/corebench/grep/grep-case-deccad69-db9d6340/tempworkdir2/neg.tmp!
Branch 0: 0
Branch 1: 0
Branch 2: 0
Branch 3: 0
Branch 4: 0
Branch 5: 0
Branch 6: 0
Branch 7: 0
Branch 8: 0
Branch 9: 0
Branch 10: 0
Branch 11: 0
Branch 12: 0
Branch 13: 0
Branch 14: 0
Branch 15: 0
Branch 16: 0
Branch 17: 0
Branch 18: 0
Branch 19: 0
Branch 20: 0
Branch 21: 0
Branch 22: 0
Branch 23: 0
Branch 24: 0
Branch 25: 0
Branch 26: 0
Branch 27: 0
Branch 28: 0
Branch 29: 0
Branch 30: 0
Branch 31: 0
Branch 32: 0
Branch 33: 0
Branch 34: 0
Branch 35: 0
Branch 36: 0
Branch 37: 0
Branch 38: 0
Branch 39: 0
Branch 40: 0
Branch 41: 0
Branch 42: 0
Branch 43: 0
Branch 44: 0
Branch 45: 0
Branch 46: 0
Branch 47: 0
Branch 48: 0
Branch 49: 0
Branch 50: 0
Branch 51: 0
Branch 52: 0
Branch 53: 0
Branch 54: 0
Branch 55: 0
Branch 56: 0
Branch 57: 0
Branch 58: 0
Branch 59: 0
Branch 60: 0
Branch 61: 0
Branch 62: 0
Branch 63: 0
Branch 64: 0
Branch 65: 0
Branch 66: 0
Branch 67: 0
Branch 68: 0
Branch 69: 0
Branch 70: 0
Branch 71: 0
Branch 72: 0
Branch 73: 0
Branch 74: 0
Branch 75: 0
Branch 76: 0
Branch 77: 0
Branch 78: 0
Branch 79: 0
Branch 80: 0
Branch 81: 0
Branch 82: 0
Branch 83: 0
Branch 84: 0
Branch 85: 0
Branch 86: 0
Branch 87: 0
Branch 88: 0
Branch 89: 0
Branch 90: 0
Branch 91: 0
Branch 92: 0
Branch 93: 0
Branch 94: 0
Branch 95: 0
Branch 96: 0
Branch 97: 0
Branch 98: 0
Branch 99: 0
Branch 100: 0
Branch 101: 0
Branch 102: 0
Branch 103: 0
Branch 104: 0
Branch 105: 0
Branch 106: 0
Branch 107: 0
Branch 108: 0
Branch 109: 0
Branch 110: 0
Branch 111: 0
Branch 112: 0
Branch 113: 0
Branch 114: 0
Branch 115: 0
Branch 116: 0
Branch 117: 0
Branch 118: 0
Branch 119: 0
Branch 120: 0
Branch 121: 0
Branch 122: 0
Branch 123: 0
Branch 124: 0
Branch 125: 0
Branch 126: 0
Branch 127: 0
Branch 128: 0
Branch 129: 0
Branch 130: 0
Branch 131: 0
Branch 132: 0
Branch 133: 0
Branch 134: 0
Branch 135: 0
Branch 136: 0
Branch 137: 0
Branch 138: 0
Branch 139: 0
Branch 140: 0
Branch 141: 0
Branch 142: 0
Branch 143: 0
Branch 144: 0
Branch 145: 0
Branch 146: 0
Branch 147: 0
Branch 148: 0
Branch 149: 0
Branch 150: 0
Branch 151: 0
Branch 152: 0
Branch 153: 0
Branch 154: 0
Branch 155: 0
Branch 156: 0
Branch 157: 0
Branch 158: 0
Branch 159: 0
Branch 160: 0
Branch 161: 0
Branch 162: 0
Branch 163: 0
Branch 164: 0
Branch 165: 0
Branch 166: 0
Branch 167: 0
Branch 168: 0
Branch 169: 0
Branch 170: 0
Branch 171: 0
Branch 172: 0
Branch 173: 0
Branch 174: 0
Branch 175: 0
Branch 176: 0
Branch 177: 0
Branch 178: 0
Branch 179: 0
Branch 180: 0
Branch 181: 0
Branch 182: 0
Branch 183: 0
Branch 184: 0
Branch 185: 0
Branch 186: 0
Branch 187: 0
Branch 188: 0
Branch 189: 0
Branch 190: 0
Branch 191: 0
Branch 192: 0
Branch 193: 0
Branch 194: 0
Branch 195: 0
Branch 196: 0
Branch 197: 0
Branch 198: 0
Branch 199: 0
Branch 200: 0
Branch 201: 0
Branch 202: 0
Branch 203: 0
Branch 204: 0
Branch 205: 0
Branch 206: 0
Branch 207: 0
Branch 208: 0
Branch 209: 0
Branch 210: 0
Branch 211: 0
Branch 212: 0
Branch 213: 0
Branch 214: 0
Branch 215: 0
Branch 216: 0
Branch 217: 0
Branch 218: 0
Branch 219: 0
Branch 220: 0
Branch 221: 0
Branch 222: 0
Branch 223: 0
Branch 224: 0
Branch 225: 0
Branch 226: 0
Branch 227: 0
Branch 228: 0
Branch 229: 0
Branch 230: 0
Branch 231: 0
Branch 232: 0
Branch 233: 0
Branch 234: 0
Branch 235: 0
Branch 236: 0
Branch 237: 0
Branch 238: 0
Branch 239: 0
Branch 240: 0
Branch 241: 0
Branch 242: 0
Branch 243: 0
Branch 244: 0
Branch 245: 0
Branch 246: 0
Branch 247: 0
Branch 248: 0
Branch 249: 0
Branch 250: 0
Branch 251: 0
Branch 252: 0
Branch 253: 0
Branch 254: 0
Branch 255: 0
Branch 256: 0
Branch 257: 0
Branch 258: 0
Branch 259: 0
Branch 260: 0
Branch 261: 0
Branch 262: 0
Branch 263: 0
Branch 264: 0
Branch 265: 0
Branch 266: 0
Branch 267: 0
Branch 268: 0
Branch 269: 0
Branch 270: 0
Branch 271: 0
Branch 272: 0
Branch 273: 0
Branch 274: 0
Branch 275: 0
Branch 276: 0
Branch 277: 0
Branch 278: 0
Branch 279: 0
Branch 280: 0
Branch 281: 0
Branch 282: 0
Branch 283: 0
Branch 284: 0
Branch 285: 0
Branch 286: 0
Branch 287: 0
Branch 288: 0
Branch 289: 0
Branch 290: 0
Branch 291: 0
Branch 292: 0
Branch 293: 0
Branch 294: 0
Branch 295: 0
Branch 296: 0
Branch 297: 0
Branch 298: 0
Branch 299: 0
Branch 300: 0
Branch 301: 0
Branch 302: 0
Branch 303: 0
Branch 304: 0
Branch 305: 0
Branch 306: 0
Branch 307: 0
Branch 308: 0
Branch 309: 0
Branch 310: 0
Branch 311: 0
Branch 312: 0
Branch 313: 0
Branch 314: 0
Branch 315: 0
Branch 316: 0
Branch 317: 0
Branch 318: 0
Branch 319: 0
Branch 320: 0
Branch 321: 0
Branch 322: 0
Branch 323: 0
Branch 324: 0
Branch 325: 0
Branch 326: 0
Branch 327: 0
Branch 328: 0
Branch 329: 0
Branch 330: 0
Branch 331: 0
Branch 332: 0
Branch 333: 0
Branch 334: 0
Branch 335: 0
Branch 336: 0
Branch 337: 0
Branch 338: 0
Branch 339: 0
Branch 340: 0
Branch 341: 0
Branch 342: 0
Branch 343: 0
Branch 344: 0
Branch 345: 0
Branch 346: 0
Branch 347: 0
Branch 348: 0
Branch 349: 0
Branch 350: 0
Branch 351: 0
Branch 352: 0
Branch 353: 0
Branch 354: 0
Branch 355: 0
Branch 356: 0
Branch 357: 0
Branch 358: 0
Branch 359: 0
Branch 360: 0
Branch 361: 0
Branch 362: 0
Branch 363: 0
Branch 364: 0
Branch 365: 0
Branch 366: 0
Branch 367: 0
Branch 368: 0
Branch 369: 0
Branch 370: 0
Branch 371: 0
Branch 372: 0
Branch 373: 0
Branch 374: 0
Branch 375: 0
Branch 376: 0
Branch 377: 0
Branch 378: 0
Branch 379: 0
Branch 380: 0
Branch 381: 0
Branch 382: 0
Branch 383: 0
Branch 384: 0
Branch 385: 0
Branch 386: 0
Branch 387: 0
Branch 388: 0
Branch 389: 0
Branch 390: 0
Branch 391: 0
Branch 392: 0
Branch 393: 0
Branch 394: 0
Branch 395: 0
Branch 396: 0
Branch 397: 0
Branch 398: 0
Branch 399: 0
Branch 400: 0
Branch 401: 0
Branch 402: 0
Branch 403: 0
Branch 404: 0
Branch 405: 0
Branch 406: 0
Branch 407: 0
Branch 408: 0
Branch 409: 0
Branch 410: 0
Branch 411: 0
Branch 412: 0
Branch 413: 0
Branch 414: 0
Branch 415: 0
Branch 416: 0
Branch 417: 0
Branch 418: 0
Branch 419: 0
Branch 420: 0
Branch 421: 0
Branch 422: 0
Branch 423: 0
Branch 424: 0
Branch 425: 0
Branch 426: 0
Branch 427: 0
Branch 428: 0
Branch 429: 0
Branch 430: 0
Branch 431: 0
Branch 432: 0
Branch 433: 0
Branch 434: 0
Branch 435: 0
Branch 436: 0
Branch 437: 0
Branch 438: 0
Branch 439: 0
Branch 440: 0
Branch 441: 0
Branch 442: 0
Branch 443: 0
Branch 444: 0
Branch 445: 0
Branch 446: 0
Branch 447: 0
Branch 448: 0
Branch 449: 0
Branch 450: 0
Branch 451: 0
Branch 452: 0
Branch 453: 0
Branch 454: 0
Branch 455: 0
Branch 456: 0
Branch 457: 0
Branch 458: 0
Branch 459: 0
Branch 460: 0
Branch 461: 0
Branch 462: 0
Branch 463: 0
Branch 464: 0
Branch 465: 0
Branch 466: 0
Branch 467: 0
Branch 468: 0
Branch 469: 0
Branch 470: 0
Branch 471: 0
Branch 472: 0
Branch 473: 0
Branch 474: 0
Branch 475: 0
Branch 476: 0
Branch 477: 0
Branch 478: 0
Branch 479: 0
Branch 480: 0
Branch 481: 0
Branch 482: 0
Branch 483: 0
Branch 484: 0
Branch 485: 0
Branch 486: 0
Branch 487: 0
Branch 488: 0
Branch 489: 0
Branch 490: 0
Branch 491: 0
Branch 492: 0
Branch 493: 0
Branch 494: 0
Branch 495: 0
Branch 496: 0
Branch 497: 0
Branch 498: 0
Branch 499: 0
Branch 500: 0
Branch 501: 0
Branch 502: 0
Branch 503: 0
Branch 504: 0
Branch 505: 0
Branch 506: 0
Branch 507: 0
Branch 508: 0
Branch 509: 0
Branch 510: 0
Branch 511: 0
Branch 512: 0
Branch 513: 0
Branch 514: 0
Branch 515: 0
Branch 516: 0
Branch 517: 0
Branch 518: 0
Branch 519: 0
Branch 520: 0
Branch 521: 0
Branch 522: 0
Branch 523: 0
Branch 524: 0
Branch 525: 0
Branch 526: 0
Branch 527: 0
Branch 528: 0
Branch 529: 0
Branch 530: 0
Branch 531: 0
Branch 532: 0
Branch 533: 0
Branch 534: 0
Branch 535: 0
Branch 536: 0
Branch 537: 0
Branch 538: 0
Branch 539: 0
Branch 540: 0
Branch 541: 0
Branch 542: 0
Branch 543: 0
Branch 544: 0
Branch 545: 0
Branch 546: 0
Branch 547: 0
Branch 548: 0
Branch 549: 0
Branch 550: 0
Branch 551: 0
Branch 552: 0
Branch 553: 0
Branch 554: 0
Branch 555: 0
Branch 556: 0
Branch 557: 0
Branch 558: 0
Branch 559: 0
Branch 560: 0
Branch 561: 0
Branch 562: 0
Branch 563: 0
Branch 564: 0
Branch 565: 0
Branch 566: 0
Branch 567: 0
Branch 568: 0
Branch 569: 0
Branch 570: 0
Branch 571: 0
Branch 572: 0
Branch 573: 0
Branch 574: 0
Branch 575: 0
Branch 576: 0
Branch 577: 0
Branch 578: 0
Branch 579: 0
Branch 580: 0
Branch 581: 0
Branch 582: 0
Branch 583: 0
Branch 584: 0
Branch 585: 0
Branch 586: 0
Branch 587: 0
Branch 588: 0
Branch 589: 0
Branch 590: 0
Branch 591: 0
Branch 592: 0
Branch 593: 0
Branch 594: 0
Branch 595: 0
Branch 596: 0
Branch 597: 0
Branch 598: 0
Branch 599: 0
Branch 600: 0
Branch 601: 0
Branch 602: 0
Branch 603: 0
Branch 604: 0
Branch 605: 0
Branch 606: 0
Branch 607: 0
Branch 608: 0
Branch 609: 0
Branch 610: 0
Branch 611: 0
Branch 612: 0
Branch 613: 0
Branch 614: 0
Branch 615: 0
Branch 616: 0
Branch 617: 0
Branch 618: 0
Branch 619: 0
Branch 620: 0
Branch 621: 0
Branch 622: 0
Branch 623: 0
Branch 624: 0
Branch 625: 0
Branch 626: 0
Branch 627: 0
Branch 628: 0
Branch 629: 0
Branch 630: 0
Branch 631: 0
Branch 632: 0
Branch 633: 0
Branch 634: 0
Branch 635: 0
Branch 636: 0
Branch 637: 0
Branch 638: 0
Branch 639: 0
Branch 640: 0
Branch 641: 0
Branch 642: 0
Branch 643: 0
Branch 644: 0
Branch 645: 0
Branch 646: 0
Branch 647: 0
Branch 648: 0
Branch 649: 0
Branch 650: 0
Branch 651: 0
Branch 652: 0
Branch 653: 0
Branch 654: 0
Branch 655: 0
Branch 656: 0
Branch 657: 0
Branch 658: 0
Branch 659: 0
Branch 660: 0
Branch 661: 0
Branch 662: 0
Branch 663: 0
Branch 664: 0
Branch 665: 0
Branch 666: 0
Branch 667: 0
Branch 668: 0
Branch 669: 0
Branch 670: 0
Branch 671: 0
Branch 672: 0
Branch 673: 0
Branch 674: 0
Branch 675: 0
Branch 676: 0
Branch 677: 0
Branch 678: 0
Branch 679: 0
Branch 680: 0
Branch 681: 0
Branch 682: 0
Branch 683: 0
Branch 684: 0
Branch 685: 0
Branch 686: 0
Branch 687: 0
Branch 688: 0
Branch 689: 0
Branch 690: 0
Branch 691: 0
Branch 692: 0
Branch 693: 0
Branch 694: 0
Branch 695: 0
Branch 696: 0
Branch 697: 0
Branch 698: 0
Branch 699: 0
Branch 700: 0
Branch 701: 0
Branch 702: 0
Branch 703: 0
Branch 704: 0
Branch 705: 0
Branch 706: 0
Branch 707: 0
Branch 708: 0
Branch 709: 0
Branch 710: 0
Branch 711: 0
Branch 712: 0
Branch 713: 0
Branch 714: 0
Branch 715: 0
Branch 716: 0
Branch 717: 0
Branch 718: 0
Branch 719: 0
Branch 720: 0
Branch 721: 0
Branch 722: 0
Branch 723: 0
Branch 724: 0
Branch 725: 0
Branch 726: 0
Branch 727: 0
Branch 728: 0
Branch 729: 0
Branch 730: 0
Branch 731: 0
Branch 732: 0
Branch 733: 0
Branch 734: 0
Branch 735: 0
Branch 736: 0
Branch 737: 0
Branch 738: 0
Branch 739: 0
Branch 740: 0
Branch 741: 0
Branch 742: 0
Branch 743: 0
Branch 744: 0
Branch 745: 0
Branch 746: 0
Branch 747: 0
Branch 748: 0
Branch 749: 0
Branch 750: 0
Branch 751: 0
Branch 752: 0
Branch 753: 0
Branch 754: 0
Branch 755: 0
Branch 756: 0
Branch 757: 0
Branch 758: 0
Branch 759: 0
Branch 760: 0
Branch 761: 0
Branch 762: 0
Branch 763: 0
Branch 764: 0
Branch 765: 0
Branch 766: 0
Branch 767: 0
Branch 768: 0
Branch 769: 0
Branch 770: 0
Branch 771: 0
Branch 772: 0
Branch 773: 0
Branch 774: 0
Branch 775: 0
Branch 776: 0
Branch 777: 0
Branch 778: 0
Branch 779: 0
Branch 780: 0
Branch 781: 0
Branch 782: 0
Branch 783: 0
Branch 784: 0
Branch 785: 0
Branch 786: 0
Branch 787: 0
Branch 788: 0
Branch 789: 0
Branch 790: 0
Branch 791: 0
Branch 792: 0
Branch 793: 0
Branch 794: 0
Branch 795: 0
Branch 796: 0
Branch 797: 0
Branch 798: 0
Branch 799: 0
Branch 800: 0
Branch 801: 0
Branch 802: 0
Branch 803: 0
Branch 804: 0
Branch 805: 0
Branch 806: 0
Branch 807: 0
Branch 808: 0
Branch 809: 0
Branch 810: 0
Branch 811: 0
Branch 812: 0
Branch 813: 0
Branch 814: 0
Branch 815: 0
Branch 816: 0
Branch 817: 0
Branch 818: 0
Branch 819: 0
Branch 820: 0
Branch 821: 0
Branch 822: 0
Branch 823: 0
Branch 824: 0
Branch 825: 0
Branch 826: 0
Branch 827: 0
Branch 828: 0
Branch 829: 0
Branch 830: 0
Branch 831: 0
Branch 832: 0
Branch 833: 0
Branch 834: 0
Branch 835: 0
Branch 836: 0
Branch 837: 0
Branch 838: 0
Branch 839: 0
Branch 840: 0
Branch 841: 0
Branch 842: 0
Branch 843: 0
Branch 844: 0
Branch 845: 0
Branch 846: 0
Branch 847: 0
Branch 848: 0
Branch 849: 0
Branch 850: 0
Branch 851: 0
Branch 852: 0
Branch 853: 0
Branch 854: 0
Branch 855: 0
Branch 856: 0
Branch 857: 0
Branch 858: 0
Branch 859: 0
Branch 860: 0
Branch 861: 0
Branch 862: 0
Branch 863: 0
Branch 864: 0
Branch 865: 0
Branch 866: 0
Branch 867: 0
Branch 868: 0
Branch 869: 0
Branch 870: 0
Branch 871: 0
Branch 872: 0
Branch 873: 0
Branch 874: 0
Branch 875: 0
Branch 876: 0
Branch 877: 0
Branch 878: 0
Branch 879: 0
Branch 880: 0
Branch 881: 0
Branch 882: 0
Branch 883: 0
Branch 884: 0
Branch 885: 0
Branch 886: 0
Branch 887: 0
Branch 888: 0
Branch 889: 0
Branch 890: 0
Branch 891: 0
Branch 892: 0
Branch 893: 0
Branch 894: 0
Branch 895: 0
Branch 896: 0
Branch 897: 0
Branch 898: 0
Branch 899: 0
Branch 900: 0
Branch 901: 0
Branch 902: 0
Branch 903: 0
Branch 904: 0
Branch 905: 0
Branch 906: 0
Branch 907: 0
Branch 908: 0
Branch 909: 0
Branch 910: 0
Branch 911: 0
Branch 912: 0
Branch 913: 0
Branch 914: 0
Branch 915: 0
Branch 916: 0
Branch 917: 0
Branch 918: 0
Branch 919: 0
Branch 920: 0
Branch 921: 0
Branch 922: 0
Branch 923: 0
Branch 924: 0
Branch 925: 0
Branch 926: 0
Branch 927: 0
Branch 928: 0
Branch 929: 0
Branch 930: 0
Branch 931: 0
Branch 932: 0
Branch 933: 0
Branch 934: 0
Branch 935: 0
Branch 936: 0
Branch 937: 0
Branch 938: 0
Branch 939: 0
Branch 940: 0
Branch 941: 0
Branch 942: 0
Branch 943: 0
Branch 944: 0
Branch 945: 0
Branch 946: 0
Branch 947: 0
Branch 948: 0
Branch 949: 0
Branch 950: 0
Branch 951: 0
Branch 952: 0
Branch 953: 0
Branch 954: 0
Branch 955: 0
Branch 956: 0
Branch 957: 0
Branch 958: 0
Branch 959: 0
Branch 960: 0
Branch 961: 0
Branch 962: 0
Branch 963: 0
Branch 964: 0
Branch 965: 0
Branch 966: 0
Branch 967: 0
Branch 968: 0
Branch 969: 0
Branch 970: 0
Branch 971: 0
Branch 972: 0
Branch 973: 0
Branch 974: 0
Branch 975: 0
Branch 976: 0
Branch 977: 0
Branch 978: 0
Branch 979: 0
Branch 980: 0
Branch 981: 0
Branch 982: 0
Branch 983: 0
Branch 984: 0
Branch 985: 0
Branch 986: 0
Branch 987: 0
Branch 988: 0
Branch 989: 0
Branch 990: 0
Branch 991: 0
Branch 992: 0
Branch 993: 0
Branch 994: 0
Branch 995: 0
Branch 996: 0
Branch 997: 0
Branch 998: 0
Branch 999: 0
Branch 1000: 0
Branch 1001: 0
Branch 1002: 0
Branch 1003: 0
Branch 1004: 0
Branch 1005: 0
Branch 1006: 0
Branch 1007: 0
Branch 1008: 0
Branch 1009: 0
Branch 1010: 0
Branch 1011: 0
Branch 1012: 0
Branch 1013: 0
Branch 1014: 0
Branch 1015: 0
Branch 1016: 0
Branch 1017: 0
Branch 1018: 0
Branch 1019: 0
Branch 1020: 0
Branch 1021: 0
Branch 1022: 0
Branch 1023: 0
Branch 1024: 0
Branch 1025: 0
Branch 1026: 0
Branch 1027: 0
Branch 1028: 0
Branch 1029: 0
Branch 1030: 0
Branch 1031: 0
Branch 1032: 0
Branch 1033: 0
Branch 1034: 0
Branch 1035: 0
Branch 1036: 0
Branch 1037: 0
Branch 1038: 0
Branch 1039: 0
Branch 1040: 0
Branch 1041: 0
Branch 1042: 0
Branch 1043: 0
Branch 1044: 0
Branch 1045: 0
Branch 1046: 0
Branch 1047: 0
Branch 1048: 0
Branch 1049: 0
Branch 1050: 0
Branch 1051: 0
Branch 1052: 0
Branch 1053: 0
Branch 1054: 0
Branch 1055: 0
Branch 1056: 0
Branch 1057: 0
Branch 1058: 0
Branch 1059: 0
Branch 1060: 0
Branch 1061: 0
Branch 1062: 0
Branch 1063: 0
Branch 1064: 0
Branch 1065: 0
Branch 1066: 0
Branch 1067: 0
Branch 1068: 0
Branch 1069: 0
Branch 1070: 0
Branch 1071: 0
Branch 1072: 0
Branch 1073: 0
Branch 1074: 0
Branch 1075: 0
Branch 1076: 0
Branch 1077: 0
Branch 1078: 0
Branch 1079: 0
Branch 1080: 0
Branch 1081: 0
Branch 1082: 0
Branch 1083: 0
Branch 1084: 0
Branch 1085: 0
Branch 1086: 0
Branch 1087: 0
Branch 1088: 0
Branch 1089: 0
Branch 1090: 0
Branch 1091: 0
Branch 1092: 0
Branch 1093: 0
Branch 1094: 0
Branch 1095: 0
Branch 1096: 0
Branch 1097: 0
Branch 1098: 0
Branch 1099: 0
Branch 1100: 0
Branch 1101: 0
Branch 1102: 0
Branch 1103: 0
Branch 1104: 0
Branch 1105: 0
Branch 1106: 0
Branch 1107: 0
Branch 1108: 0
Branch 1109: 0
Branch 1110: 0
Branch 1111: 0
Branch 1112: 0
Branch 1113: 0
Branch 1114: 0
Branch 1115: 0
Branch 1116: 0
Branch 1117: 0
Branch 1118: 0
Branch 1119: 0
Branch 1120: 0
Branch 1121: 0
Branch 1122: 0
Branch 1123: 0
Branch 1124: 0
Branch 1125: 0
Branch 1126: 0
Branch 1127: 0
Branch 1128: 0
Branch 1129: 0
Branch 1130: 0
Branch 1131: 0
Branch 1132: 0
Branch 1133: 0
Branch 1134: 0
Branch 1135: 0
Branch 1136: 0
Branch 1137: 0
Branch 1138: 0
Branch 1139: 0
Branch 1140: 0
Branch 1141: 0
Branch 1142: 0
Branch 1143: 0
Branch 1144: 0
Branch 1145: 0
Branch 1146: 0
Branch 1147: 0
Branch 1148: 0
Branch 1149: 0
Branch 1150: 0
Branch 1151: 0
Branch 1152: 0
Branch 1153: 0
Branch 1154: 0
Branch 1155: 0
Branch 1156: 0
Branch 1157: 0
Branch 1158: 0
Branch 1159: 0
Branch 1160: 0
Branch 1161: 0
Branch 1162: 0
Branch 1163: 0
Branch 1164: 0
Branch 1165: 0
Branch 1166: 0
Branch 1167: 0
Branch 1168: 0
Branch 1169: 0
Branch 1170: 0
Branch 1171: 0
Branch 1172: 0
Branch 1173: 0
Branch 1174: 0
Branch 1175: 0
Branch 1176: 0
Branch 1177: 0
Branch 1178: 0
Branch 1179: 0
Branch 1180: 0
Branch 1181: 0
Branch 1182: 0
Branch 1183: 0
Branch 1184: 0
Branch 1185: 0
Branch 1186: 0
Branch 1187: 0
Branch 1188: 0
Branch 1189: 0
Branch 1190: 0
Branch 1191: 0
Branch 1192: 0
Branch 1193: 0
Branch 1194: 0
Branch 1195: 0
Branch 1196: 0
Branch 1197: 0
Branch 1198: 0
Branch 1199: 0
Branch 1200: 0
Branch 1201: 0
Branch 1202: 0
Branch 1203: 0
Branch 1204: 0
Branch 1205: 0
Branch 1206: 0
Branch 1207: 0
Branch 1208: 0
Branch 1209: 0
Branch 1210: 0
Branch 1211: 0
Branch 1212: 0
Branch 1213: 0
Branch 1214: 0
Branch 1215: 0
Branch 1216: 0
Branch 1217: 0
Branch 1218: 0
Branch 1219: 0
Branch 1220: 0
Branch 1221: 0
Branch 1222: 0
Branch 1223: 0
Branch 1224: 0
Branch 1225: 0
Branch 1226: 0
Branch 1227: 0
Branch 1228: 0
Branch 1229: 0
Branch 1230: 0
Branch 1231: 0
Branch 1232: 0
Branch 1233: 0
Branch 1234: 0
Branch 1235: 0
Branch 1236: 0
Branch 1237: 0
Branch 1238: 0
Branch 1239: 0
Branch 1240: 0
Branch 1241: 0
Branch 1242: 0
Branch 1243: 0
Branch 1244: 0
Branch 1245: 0
Branch 1246: 0
Branch 1247: 0
Branch 1248: 0
Branch 1249: 0
Branch 1250: 0
Branch 1251: 0
Branch 1252: 0
Branch 1253: 0
Branch 1254: 0
Branch 1255: 0
Branch 1256: 0
Branch 1257: 0
Branch 1258: 0
Branch 1259: 0
Branch 1260: 0
Branch 1261: 0
Branch 1262: 0
Branch 1263: 0
Branch 1264: 0
Branch 1265: 0
Branch 1266: 0
Branch 1267: 0
Branch 1268: 0
Branch 1269: 0
Branch 1270: 0
Branch 1271: 0
Branch 1272: 0
Branch 1273: 0
Branch 1274: 0
Branch 1275: 0
Branch 1276: 0
Branch 1277: 0
Branch 1278: 0
Branch 1279: 0
Branch 1280: 0
Branch 1281: 0
Branch 1282: 0
Branch 1283: 0
Branch 1284: 0
Branch 1285: 0
Branch 1286: 0
Branch 1287: 0
Branch 1288: 0
Branch 1289: 0
Branch 1290: 0
Branch 1291: 0
Branch 1292: 0
Branch 1293: 0
Branch 1294: 0
Branch 1295: 0
Branch 1296: 0
Branch 1297: 0
Branch 1298: 0
Branch 1299: 0
Branch 1300: 0
Branch 1301: 0
Branch 1302: 0
Branch 1303: 0
Branch 1304: 0
Branch 1305: 0
Branch 1306: 0
Branch 1307: 0
Branch 1308: 0
Branch 1309: 0
Branch 1310: 0
Branch 1311: 0
Branch 1312: 0
Branch 1313: 0
Branch 1314: 0
Branch 1315: 0
Branch 1316: 0
Branch 1317: 0
Branch 1318: 0
Branch 1319: 0
Branch 1320: 0
Branch 1321: 0
Branch 1322: 0
Branch 1323: 0
Branch 1324: 0
Branch 1325: 0
Branch 1326: 0
Branch 1327: 0
Branch 1328: 0
Branch 1329: 0
Branch 1330: 0
Branch 1331: 0
Branch 1332: 0
Branch 1333: 0
Branch 1334: 0
Branch 1335: 0
Branch 1336: 0
Branch 1337: 0
Branch 1338: 0
Branch 1339: 0
Branch 1340: 0
Branch 1341: 0
Branch 1342: 0
Branch 1343: 0
Branch 1344: 0
Branch 1345: 0
Branch 1346: 0
Branch 1347: 0
Branch 1348: 0
Branch 1349: 0
Branch 1350: 0
Branch 1351: 0
Branch 1352: 0
Branch 1353: 0
Branch 1354: 0
Branch 1355: 0
Branch 1356: 0
Branch 1357: 0
Branch 1358: 0
Branch 1359: 0
Branch 1360: 0
Branch 1361: 0
Branch 1362: 0
Branch 1363: 0
Branch 1364: 0
Branch 1365: 0
Branch 1366: 0
Branch 1367: 0
Branch 1368: 0
Branch 1369: 0
Branch 1370: 0
Branch 1371: 0
Branch 1372: 0
Branch 1373: 0
Branch 1374: 0
Branch 1375: 0
Branch 1376: 0
Branch 1377: 0
Branch 1378: 0
Branch 1379: 0
Branch 1380: 0
Branch 1381: 0
Branch 1382: 0
Branch 1383: 0
Branch 1384: 0
Branch 1385: 0
Branch 1386: 0
Branch 1387: 0
Branch 1388: 0
Branch 1389: 0
Branch 1390: 0
Branch 1391: 0
Branch 1392: 0
Branch 1393: 0
Branch 1394: 0
Branch 1395: 0
Branch 1396: 0
Branch 1397: 0
Branch 1398: 0
Branch 1399: 0
Branch 1400: 0
Branch 1401: 0
Branch 1402: 0
Branch 1403: 0
Branch 1404: 0
Branch 1405: 0
Branch 1406: 0
Branch 1407: 0
Branch 1408: 0
Branch 1409: 0
Branch 1410: 0
Branch 1411: 0
Branch 1412: 0
Branch 1413: 0
Branch 1414: 0
Branch 1415: 0
Branch 1416: 0
Branch 1417: 0
Branch 1418: 0
Branch 1419: 0
Branch 1420: 0
Branch 1421: 0
Branch 1422: 0
Branch 1423: 0
Branch 1424: 0
Branch 1425: 0
Branch 1426: 0
Branch 1427: 0
Branch 1428: 0
Branch 1429: 0
Branch 1430: 0
Branch 1431: 0
Branch 1432: 0
Branch 1433: 0
Branch 1434: 0
Branch 1435: 0
Branch 1436: 0
Branch 1437: 0
Branch 1438: 0
Branch 1439: 0
Branch 1440: 0
Branch 1441: 0
Branch 1442: 0
Branch 1443: 0
Branch 1444: 0
Branch 1445: 0
Branch 1446: 0
Branch 1447: 0
Branch 1448: 0
Branch 1449: 0
Branch 1450: 0
Branch 1451: 0
Branch 1452: 0
Branch 1453: 0
Branch 1454: 0
Branch 1455: 0
Branch 1456: 0
Branch 1457: 0
Branch 1458: 0
Branch 1459: 0
Branch 1460: 0
Branch 1461: 0
Branch 1462: 0
Branch 1463: 0
Branch 1464: 0
Branch 1465: 0
Branch 1466: 0
Branch 1467: 0
Branch 1468: 0
Branch 1469: 0
Branch 1470: 0
Branch 1471: 0
Branch 1472: 0
Branch 1473: 0
Branch 1474: 0
Branch 1475: 0
Branch 1476: 0
Branch 1477: 0
Branch 1478: 0
Branch 1479: 0
Branch 1480: 0
Branch 1481: 0
Branch 1482: 0
Branch 1483: 0
Branch 1484: 0
Branch 1485: 0
Branch 1486: 0
Branch 1487: 0
Branch 1488: 0
Branch 1489: 0
Branch 1490: 0
Branch 1491: 0
Branch 1492: 0
Branch 1493: 0
Branch 1494: 0
Branch 1495: 0
Branch 1496: 0
Branch 1497: 0
Branch 1498: 0
Branch 1499: 0
Branch 1500: 0
Branch 1501: 0
Branch 1502: 0
Branch 1503: 0
Branch 1504: 0
Branch 1505: 0
Branch 1506: 0
Branch 1507: 0
Branch 1508: 0
Branch 1509: 0
Branch 1510: 0
Branch 1511: 0
Branch 1512: 0
Branch 1513: 0
Branch 1514: 0
Branch 1515: 0
Branch 1516: 0
Branch 1517: 0
Branch 1518: 0
Branch 1519: 0
Branch 1520: 0
Branch 1521: 0
Branch 1522: 0
Branch 1523: 0
Branch 1524: 0
Branch 1525: 0
Branch 1526: 0
Branch 1527: 0
Branch 1528: 0
Branch 1529: 0
Branch 1530: 0
Branch 1531: 0
Branch 1532: 0
Branch 1533: 0
Branch 1534: 0
Branch 1535: 0
Branch 1536: 0
Branch 1537: 0
Branch 1538: 0
Branch 1539: 0
Branch 1540: 0
Branch 1541: 0
Branch 1542: 0
Branch 1543: 0
Branch 1544: 0
Branch 1545: 0
Branch 1546: 0
Branch 1547: 0
Branch 1548: 0
Branch 1549: 0
Branch 1550: 0
Branch 1551: 0
Branch 1552: 0
Branch 1553: 0
Branch 1554: 0
Branch 1555: 0
Branch 1556: 0
Branch 1557: 0
Branch 1558: 0
Branch 1559: 0
Branch 1560: 0
Branch 1561: 0
Branch 1562: 0
Branch 1563: 0
Branch 1564: 0
Branch 1565: 0
Branch 1566: 0
Branch 1567: 0
Branch 1568: 0
Branch 1569: 0
Branch 1570: 0
Branch 1571: 0
Branch 1572: 0
Branch 1573: 0
Branch 1574: 0
Branch 1575: 0
Branch 1576: 0
Branch 1577: 0
Branch 1578: 0
Branch 1579: 0
Branch 1580: 0
Branch 1581: 0
Branch 1582: 0
Branch 1583: 0
Branch 1584: 0
Branch 1585: 0
Branch 1586: 0
Branch 1587: 0
Branch 1588: 0
Branch 1589: 0
Branch 1590: 0
Branch 1591: 0
Branch 1592: 0
Branch 1593: 0
Branch 1594: 0
Branch 1595: 0
Branch 1596: 0
Branch 1597: 0
Branch 1598: 0
Branch 1599: 0
Branch 1600: 0
Branch 1601: 0
Branch 1602: 0
Branch 1603: 0
Branch 1604: 0
Branch 1605: 0
Branch 1606: 0
Branch 1607: 0
Branch 1608: 0
Branch 1609: 0
Branch 1610: 0
Branch 1611: 0
Branch 1612: 0
Branch 1613: 0
Branch 1614: 0
Branch 1615: 0
Branch 1616: 0
Branch 1617: 0
Branch 1618: 0
Branch 1619: 0
Branch 1620: 0
Branch 1621: 0
Branch 1622: 0
Branch 1623: 0
Branch 1624: 0
Branch 1625: 0
Branch 1626: 0
Branch 1627: 0
Branch 1628: 0
Branch 1629: 0
Branch 1630: 0
Branch 1631: 0
Branch 1632: 0
Branch 1633: 0
Branch 1634: 0
Branch 1635: 0
Branch 1636: 0
Branch 1637: 0
Branch 1638: 0
Branch 1639: 0
Branch 1640: 0
Branch 1641: 0
Branch 1642: 0
Branch 1643: 0
Branch 1644: 0
Branch 1645: 0
Branch 1646: 0
Branch 1647: 0
Branch 1648: 0
Branch 1649: 0
Branch 1650: 0
Branch 1651: 0
Branch 1652: 0
Branch 1653: 0
Branch 1654: 0
Branch 1655: 0
Branch 1656: 0
Branch 1657: 0
Branch 1658: 0
Branch 1659: 0
Branch 1660: 0
Branch 1661: 0
Branch 1662: 0
Branch 1663: 0
Branch 1664: 0
Branch 1665: 0
Branch 1666: 0
Branch 1667: 0
Branch 1668: 0
Branch 1669: 0
Branch 1670: 0
Branch 1671: 0
Branch 1672: 0
Branch 1673: 0
Branch 1674: 0
Branch 1675: 0
Branch 1676: 0
Branch 1677: 0
Branch 1678: 0
Branch 1679: 0
Branch 1680: 0
Branch 1681: 0
Branch 1682: 0
Branch 1683: 0
Branch 1684: 0
Branch 1685: 0
Branch 1686: 0
Branch 1687: 0
Branch 1688: 0
Branch 1689: 0
Branch 1690: 0
Branch 1691: 0
Branch 1692: 0
Branch 1693: 0
Branch 1694: 0
Branch 1695: 0
Branch 1696: 0
Branch 1697: 0
Branch 1698: 0
Branch 1699: 0
Branch 1700: 0
Branch 1701: 0
Branch 1702: 0
Branch 1703: 0
Branch 1704: 0
Branch 1705: 0
Branch 1706: 0
Branch 1707: 0
Branch 1708: 0
Branch 1709: 0
Branch 1710: 0
Branch 1711: 0
Branch 1712: 0
Branch 1713: 0
Branch 1714: 0
Branch 1715: 0
Branch 1716: 0
Branch 1717: 0
Branch 1718: 0
Branch 1719: 0
Branch 1720: 0
Branch 1721: 0
Branch 1722: 0
Branch 1723: 0
Branch 1724: 0
Branch 1725: 0
Branch 1726: 0
Branch 1727: 0
Branch 1728: 0
Branch 1729: 0
Branch 1730: 0
Branch 1731: 0
Branch 1732: 0
Branch 1733: 0
Branch 1734: 0
Branch 1735: 0
Branch 1736: 0
Branch 1737: 0
Branch 1738: 0
Branch 1739: 0
Branch 1740: 0
Branch 1741: 0
Branch 1742: 0
Branch 1743: 0
Branch 1744: 0
Branch 1745: 0
Branch 1746: 0
Branch 1747: 0
Branch 1748: 0
Branch 1749: 0
Branch 1750: 0
Branch 1751: 0
Branch 1752: 0
Branch 1753: 0
Branch 1754: 0
Branch 1755: 0
Branch 1756: 0
Branch 1757: 0
Branch 1758: 0
Branch 1759: 0
Branch 1760: 0
Branch 1761: 0
Branch 1762: 0
Branch 1763: 0
Branch 1764: 0
Branch 1765: 0
Branch 1766: 0
Branch 1767: 0
Branch 1768: 0
Branch 1769: 0
Branch 1770: 0
Branch 1771: 0
Branch 1772: 0
Branch 1773: 0
Branch 1774: 0
Branch 1775: 0
Branch 1776: 0
Branch 1777: 0
Branch 1778: 0
Branch 1779: 0
Branch 1780: 0
Branch 1781: 0
Branch 1782: 0
Branch 1783: 0
Branch 1784: 0
Branch 1785: 0
Branch 1786: 0
Branch 1787: 0
Branch 1788: 0
Branch 1789: 0
Branch 1790: 0
Branch 1791: 0
Branch 1792: 0
Branch 1793: 0
Branch 1794: 0
Branch 1795: 0
Branch 1796: 0
Branch 1797: 0
Branch 1798: 0
Branch 1799: 0
Branch 1800: 0
Branch 1801: 0
Branch 1802: 0
Branch 1803: 0
Branch 1804: 0
Branch 1805: 0
Branch 1806: 0
Branch 1807: 0
Branch 1808: 0
Branch 1809: 0
Branch 1810: 0
Branch 1811: 0
Branch 1812: 0
Branch 1813: 0
Branch 1814: 0
Branch 1815: 0
Branch 1816: 0
Branch 1817: 0
Branch 1818: 0
Branch 1819: 0
Branch 1820: 0
Branch 1821: 0
Branch 1822: 0
Branch 1823: 0
Branch 1824: 0
Branch 1825: 0
Branch 1826: 0
Branch 1827: 0
Branch 1828: 0
Branch 1829: 0
Branch 1830: 0
Branch 1831: 0
Branch 1832: 0
Branch 1833: 0
Branch 1834: 0
Branch 1835: 0
Branch 1836: 0
Branch 1837: 0
Branch 1838: 0
Branch 1839: 0
Branch 1840: 0
Branch 1841: 0
Branch 1842: 0
Branch 1843: 0
Branch 1844: 0
Branch 1845: 0
Branch 1846: 0
Branch 1847: 0
Branch 1848: 0
Branch 1849: 0
Branch 1850: 0
Branch 1851: 0
Branch 1852: 0
Branch 1853: 0
Branch 1854: 0
Branch 1855: 0
Branch 1856: 0
Branch 1857: 0
Branch 1858: 0
Branch 1859: 0
Branch 1860: 0
Branch 1861: 0
Branch 1862: 0
Branch 1863: 0
Branch 1864: 0
Branch 1865: 0
Branch 1866: 0
Branch 1867: 0
Branch 1868: 0
Branch 1869: 0
Branch 1870: 0
Branch 1871: 0
Branch 1872: 0
Branch 1873: 0
Branch 1874: 0
Branch 1875: 0
Branch 1876: 0
Branch 1877: 0
Branch 1878: 0
Branch 1879: 0
Branch 1880: 0
Branch 1881: 0
Branch 1882: 0
Branch 1883: 0
Branch 1884: 0
Branch 1885: 0
Branch 1886: 0
Branch 1887: 0
Branch 1888: 0
Branch 1889: 0
Branch 1890: 0
Branch 1891: 0
Branch 1892: 0
Branch 1893: 0
Branch 1894: 0
Branch 1895: 0
Branch 1896: 0
Branch 1897: 0
Branch 1898: 0
Branch 1899: 0
Branch 1900: 0
Branch 1901: 0
Branch 1902: 0
Branch 1903: 0
Branch 1904: 0
Branch 1905: 0
Branch 1906: 0
Branch 1907: 0
Branch 1908: 0
Branch 1909: 0
Branch 1910: 0
Branch 1911: 0
Branch 1912: 0
Branch 1913: 0
Branch 1914: 0
Branch 1915: 0
Branch 1916: 0
Branch 1917: 0
Branch 1918: 0
Branch 1919: 0
Branch 1920: 0
Branch 1921: 0
Branch 1922: 0
Branch 1923: 0
Branch 1924: 0
Branch 1925: 0
Branch 1926: 0
Branch 1927: 0
Branch 1928: 0
Branch 1929: 0
Branch 1930: 0
Branch 1931: 0
Branch 1932: 0
Branch 1933: 0
Branch 1934: 0
Branch 1935: 0
Branch 1936: 0
Branch 1937: 0
Branch 1938: 0
Branch 1939: 0
Branch 1940: 0
Branch 1941: 0
Branch 1942: 0
Branch 1943: 0
Branch 1944: 0
Branch 1945: 0
Branch 1946: 0
Branch 1947: 0
Branch 1948: 0
Branch 1949: 0
Branch 1950: 0
Branch 1951: 0
Branch 1952: 0
Branch 1953: 0
Branch 1954: 0
Branch 1955: 0
Branch 1956: 0
Branch 1957: 0
Branch 1958: 0
Branch 1959: 0
Branch 1960: 0
Branch 1961: 0
Branch 1962: 0
Branch 1963: 0
Branch 1964: 0
Branch 1965: 0
Branch 1966: 0
Branch 1967: 0
Branch 1968: 0
Branch 1969: 0
Branch 1970: 0
Branch 1971: 0
Branch 1972: 0
Branch 1973: 0
Branch 1974: 0
Branch 1975: 0
Branch 1976: 0
Branch 1977: 0
Branch 1978: 0
Branch 1979: 0
Branch 1980: 0
Branch 1981: 0
Branch 1982: 0
Branch 1983: 0
Branch 1984: 0
Branch 1985: 0
Branch 1986: 0
Branch 1987: 0
Branch 1988: 0
Branch 1989: 0
Branch 1990: 0
Branch 1991: 0
Branch 1992: 0
Branch 1993: 0
Branch 1994: 0
Branch 1995: 0
Branch 1996: 0
Branch 1997: 0
Branch 1998: 0
Branch 1999: 0
Branch 2000: 0
Branch 2001: 0
Branch 2002: 0
Branch 2003: 0
Branch 2004: 0
Branch 2005: 0
Branch 2006: 0
Branch 2007: 0
Branch 2008: 0
Branch 2009: 0
Branch 2010: 0
Branch 2011: 0
Branch 2012: 0
Branch 2013: 0
Branch 2014: 0
Branch 2015: 0
Branch 2016: 0
Branch 2017: 0
Branch 2018: 0
Branch 2019: 0
Branch 2020: 0
Branch 2021: 0
Branch 2022: 0
Branch 2023: 0
Branch 2024: 0
Branch 2025: 0
Branch 2026: 0
Branch 2027: 0
Branch 2028: 0
Branch 2029: 0
Branch 2030: 0
Branch 2031: 0
Branch 2032: 0
Branch 2033: 0
Branch 2034: 0
Branch 2035: 0
Branch 2036: 0
Branch 2037: 0
Branch 2038: 0
Branch 2039: 0
Branch 2040: 0
Branch 2041: 0
Branch 2042: 0
Branch 2043: 0
Branch 2044: 0
Branch 2045: 0
Branch 2046: 0
Branch 2047: 0
Branch 2048: 0
Branch 2049: 0
Branch 2050: 0
Branch 2051: 0
Branch 2052: 0
Branch 2053: 0
Branch 2054: 0
Branch 2055: 0
Branch 2056: 0
Branch 2057: 0
Branch 2058: 0
Branch 2059: 0
Branch 2060: 0
Branch 2061: 0
Branch 2062: 0
Branch 2063: 0
Branch 2064: 0
Branch 2065: 0
Branch 2066: 0
Branch 2067: 0
Branch 2068: 0
Branch 2069: 0
Branch 2070: 0
Branch 2071: 0
Branch 2072: 0
Branch 2073: 0
Branch 2074: 0
Branch 2075: 0
Branch 2076: 0
Branch 2077: 0
Branch 2078: 0
Branch 2079: 0
Branch 2080: 0
Branch 2081: 0
Branch 2082: 0
Branch 2083: 0
Branch 2084: 0
Branch 2085: 0
Branch 2086: 0
Branch 2087: 0
Branch 2088: 0
Branch 2089: 0
Branch 2090: 0
Branch 2091: 0
Branch 2092: 0
Branch 2093: 0
Branch 2094: 0
Branch 2095: 0
Branch 2096: 0
Branch 2097: 0
Branch 2098: 0
Branch 2099: 0
Branch 2100: 0
Branch 2101: 0
Branch 2102: 0
Branch 2103: 0
Branch 2104: 0
Branch 2105: 0
Branch 2106: 0
Branch 2107: 0
Branch 2108: 0
Branch 2109: 0
Branch 2110: 0
Branch 2111: 0
Branch 2112: 0
Branch 2113: 0
Branch 2114: 0
Branch 2115: 0
Branch 2116: 0
Branch 2117: 0
Branch 2118: 0
Branch 2119: 0
Branch 2120: 0
Branch 2121: 0
Branch 2122: 0
Branch 2123: 0
Branch 2124: 0
Branch 2125: 0
Branch 2126: 0
Branch 2127: 0
Branch 2128: 0
Branch 2129: 0
Branch 2130: 0
Branch 2131: 0
Branch 2132: 0
Branch 2133: 0
Branch 2134: 0
Branch 2135: 0
Branch 2136: 0
Branch 2137: 0
Branch 2138: 0
Branch 2139: 0
Branch 2140: 0
Branch 2141: 0
Branch 2142: 0
Branch 2143: 0
Branch 2144: 0
Branch 2145: 0
Branch 2146: 0
Branch 2147: 0
Branch 2148: 0
Branch 2149: 0
Branch 2150: 0
Branch 2151: 0
Branch 2152: 0
Branch 2153: 0
Branch 2154: 0
Branch 2155: 0
Branch 2156: 0
Branch 2157: 0
Branch 2158: 0
Branch 2159: 0
Branch 2160: 0
Branch 2161: 0
Branch 2162: 0
Branch 2163: 0
Branch 2164: 0
Branch 2165: 0
Branch 2166: 0
Branch 2167: 0
Branch 2168: 0
Branch 2169: 0
Branch 2170: 0
Branch 2171: 0
Branch 2172: 0
Branch 2173: 0
Branch 2174: 0
Branch 2175: 0
Branch 2176: 0
Branch 2177: 0
Branch 2178: 0
Branch 2179: 0
Branch 2180: 0
Branch 2181: 0
Branch 2182: 0
Branch 2183: 0
Branch 2184: 0
Branch 2185: 0
Branch 2186: 0
Branch 2187: 0
Branch 2188: 0
Branch 2189: 0
Branch 2190: 0
Branch 2191: 0
Branch 2192: 0
Branch 2193: 0
Branch 2194: 0
Branch 2195: 0
Branch 2196: 0
Branch 2197: 0
Branch 2198: 0
Branch 2199: 0
Branch 2200: 0
Branch 2201: 0
Branch 2202: 0
Branch 2203: 0
Branch 2204: 0
Branch 2205: 0
Branch 2206: 0
Branch 2207: 0
Branch 2208: 0
Branch 2209: 0
Branch 2210: 0
Branch 2211: 0
Branch 2212: 0
Branch 2213: 0
Branch 2214: 0
Branch 2215: 0
Branch 2216: 0
Branch 2217: 0
Branch 2218: 0
Branch 2219: 0
Branch 2220: 0
Branch 2221: 0
Branch 2222: 0
Branch 2223: 0
Branch 2224: 0
Branch 2225: 0
Branch 2226: 0
Branch 2227: 0
Branch 2228: 0
Branch 2229: 0
Branch 2230: 0
Branch 2231: 0
Branch 2232: 0
Branch 2233: 0
Branch 2234: 0
Branch 2235: 0
Branch 2236: 0
Branch 2237: 0
Branch 2238: 0
Branch 2239: 0
Branch 2240: 0
Branch 2241: 0
Branch 2242: 0
Branch 2243: 0
Branch 2244: 0
Branch 2245: 0
Branch 2246: 0
Branch 2247: 0
Branch 2248: 0
Branch 2249: 0
Branch 2250: 0
Branch 2251: 0
Branch 2252: 0
Branch 2253: 0
Branch 2254: 0
Branch 2255: 0
Branch 2256: 0
Branch 2257: 0
Branch 2258: 0
Branch 2259: 0
Branch 2260: 0
Branch 2261: 0
Branch 2262: 0
Branch 2263: 0
Branch 2264: 0
Branch 2265: 0
Branch 2266: 0
Branch 2267: 0
Branch 2268: 0
Branch 2269: 0
Branch 2270: 0
Branch 2271: 0
Branch 2272: 0
Branch 2273: 0
Branch 2274: 0
Branch 2275: 0
Branch 2276: 0
Branch 2277: 0
Branch 2278: 0
Branch 2279: 0
Branch 2280: 0
Branch 2281: 0
Branch 2282: 0
Branch 2283: 0
Branch 2284: 0
Branch 2285: 0
Branch 2286: 0
Branch 2287: 0
Branch 2288: 0
Branch 2289: 0
Branch 2290: 0
Branch 2291: 0
Branch 2292: 0
Branch 2293: 0
Branch 2294: 0
Branch 2295: 0
Branch 2296: 0
Branch 2297: 0
Branch 2298: 0
Branch 2299: 0
Branch 2300: 0
Branch 2301: 0
Branch 2302: 0
Branch 2303: 0
Branch 2304: 0
Branch 2305: 0
Branch 2306: 0
Branch 2307: 0
Branch 2308: 0
Branch 2309: 0
Branch 2310: 0
Branch 2311: 0
Branch 2312: 0
Branch 2313: 0
Branch 2314: 0
Branch 2315: 0
Branch 2316: 0
Branch 2317: 0
Branch 2318: 0
Branch 2319: 0
Branch 2320: 0
Branch 2321: 0
Branch 2322: 0
Branch 2323: 0
Branch 2324: 0
Branch 2325: 0
Branch 2326: 0
Branch 2327: 0
Branch 2328: 0
Branch 2329: 0
Branch 2330: 0
Branch 2331: 0
Branch 2332: 0
Branch 2333: 0
Branch 2334: 0
Branch 2335: 0
Branch 2336: 0
Branch 2337: 0
Branch 2338: 0
Branch 2339: 0
Branch 2340: 0
Branch 2341: 0
Branch 2342: 0
Branch 2343: 0
Branch 2344: 0
Branch 2345: 0
Branch 2346: 0
Branch 2347: 0
Branch 2348: 0
Branch 2349: 0
Branch 2350: 0
Branch 2351: 0
Branch 2352: 0
Branch 2353: 0
Branch 2354: 0
Branch 2355: 0
Branch 2356: 0
Branch 2357: 0
Branch 2358: 0
Branch 2359: 0
Branch 2360: 0
Branch 2361: 0
Branch 2362: 0
Branch 2363: 0
Branch 2364: 0
Branch 2365: 0
Branch 2366: 0
Branch 2367: 0
Branch 2368: 0
Branch 2369: 0
Branch 2370: 0
Branch 2371: 0
Branch 2372: 0
Branch 2373: 0
Branch 2374: 0
Branch 2375: 0
Branch 2376: 0
Branch 2377: 0
Branch 2378: 0
Branch 2379: 0
Branch 2380: 0
Branch 2381: 0
Branch 2382: 0
Branch 2383: 0
Branch 2384: 0
Branch 2385: 0
Branch 2386: 0
Branch 2387: 0
Branch 2388: 0
Branch 2389: 0
Branch 2390: 0
Branch 2391: 0
Branch 2392: 0
Branch 2393: 0
Branch 2394: 0
Branch 2395: 0
Branch 2396: 0
Branch 2397: 0
Branch 2398: 0
Branch 2399: 0
Branch 2400: 0
Branch 2401: 0
Branch 2402: 0
Branch 2403: 0
Branch 2404: 0
Branch 2405: 0
Branch 2406: 0
Branch 2407: 0
Branch 2408: 0
Branch 2409: 0
Branch 2410: 0
Branch 2411: 0
Branch 2412: 0
Branch 2413: 0
Branch 2414: 0
Branch 2415: 0
Branch 2416: 0
Branch 2417: 0
Branch 2418: 0
Branch 2419: 0
Branch 2420: 0
Branch 2421: 0
Branch 2422: 0
Branch 2423: 0
Branch 2424: 0
Branch 2425: 0
Branch 2426: 0
Branch 2427: 0
Branch 2428: 0
Branch 2429: 0
Branch 2430: 0
Branch 2431: 0
Branch 2432: 0
Branch 2433: 0
Branch 2434: 0
Branch 2435: 0
Branch 2436: 0
Branch 2437: 0
Branch 2438: 0
Branch 2439: 0
Branch 2440: 0
Branch 2441: 0
Branch 2442: 0
Branch 2443: 0
Branch 2444: 0
Branch 2445: 0
Branch 2446: 0
Branch 2447: 0
Branch 2448: 0
Branch 2449: 0
Branch 2450: 0
Branch 2451: 0
Branch 2452: 0
Branch 2453: 0
Branch 2454: 0
Branch 2455: 0
Branch 2456: 0
Branch 2457: 0
Branch 2458: 0
Branch 2459: 0
Branch 2460: 0
Branch 2461: 0
Branch 2462: 0
Branch 2463: 0
Branch 2464: 0
Branch 2465: 0
Branch 2466: 0
Branch 2467: 0
Branch 2468: 0
Branch 2469: 0
Branch 2470: 0
Branch 2471: 0
Branch 2472: 0
Branch 2473: 0
Branch 2474: 0
Branch 2475: 0
Branch 2476: 0
Branch 2477: 0
Branch 2478: 0
Branch 2479: 0
Branch 2480: 0
Branch 2481: 0
Branch 2482: 0
Branch 2483: 0
Branch 2484: 0
Branch 2485: 0
Branch 2486: 0
Branch 2487: 0
Branch 2488: 0
Branch 2489: 0
Branch 2490: 0
Branch 2491: 0
Branch 2492: 0
Branch 2493: 0
Branch 2494: 0
Branch 2495: 0
Branch 2496: 0
Branch 2497: 0
Branch 2498: 0
Branch 2499: 0
Branch 2500: 0
Branch 2501: 0
Branch 2502: 0
Branch 2503: 0
Branch 2504: 0
Branch 2505: 0
Branch 2506: 0
Branch 2507: 0
Branch 2508: 0
Branch 2509: 0
Branch 2510: 0
Branch 2511: 0
Branch 2512: 0
Branch 2513: 0
Branch 2514: 0
Branch 2515: 0
Branch 2516: 0
Branch 2517: 0
Branch 2518: 0
Branch 2519: 0
Branch 2520: 0
Branch 2521: 0
Branch 2522: 0
Branch 2523: 0
Branch 2524: 0
Branch 2525: 0
Branch 2526: 0
Branch 2527: 0
Branch 2528: 0
Branch 2529: 0
Branch 2530: 0
Branch 2531: 0
Branch 2532: 0
Branch 2533: 0
Branch 2534: 0
Branch 2535: 0
Branch 2536: 0
Branch 2537: 0
Branch 2538: 0
Branch 2539: 0
Branch 2540: 0
Branch 2541: 0
Branch 2542: 0
Branch 2543: 0
Branch 2544: 0
Branch 2545: 0
Branch 2546: 0
Branch 2547: 0
Branch 2548: 0
Branch 2549: 0
Branch 2550: 0
Branch 2551: 0
Branch 2552: 0
Branch 2553: 0
Branch 2554: 0
Branch 2555: 0
Branch 2556: 0
Branch 2557: 0
Branch 2558: 0
Branch 2559: 0
Branch 2560: 0
Branch 2561: 0
Branch 2562: 0
Branch 2563: 0
Branch 2564: 0
Branch 2565: 0
Branch 2566: 0
Branch 2567: 0
Branch 2568: 0
Branch 2569: 0
Branch 2570: 0
Branch 2571: 0
Branch 2572: 0
Branch 2573: 0
Branch 2574: 0
Branch 2575: 0
Branch 2576: 0
Branch 2577: 0
Branch 2578: 0
Branch 2579: 0
Branch 2580: 0
Branch 2581: 0
Branch 2582: 0
Branch 2583: 0
Branch 2584: 0
Branch 2585: 0
Branch 2586: 0
Branch 2587: 0
Branch 2588: 0
Branch 2589: 0
Branch 2590: 0
Branch 2591: 0
Branch 2592: 0
Branch 2593: 0
Branch 2594: 0
Branch 2595: 0
Branch 2596: 0
Branch 2597: 0
Branch 2598: 0
Branch 2599: 0
Branch 2600: 0
Branch 2601: 0
Branch 2602: 0
Branch 2603: 0
Branch 2604: 0
Branch 2605: 0
Branch 2606: 0
Branch 2607: 0
Branch 2608: 0
Branch 2609: 0
Branch 2610: 0
Branch 2611: 0
Branch 2612: 0
Branch 2613: 0
Branch 2614: 0
Branch 2615: 0
Branch 2616: 0
Branch 2617: 0
Branch 2618: 0
Branch 2619: 0
Branch 2620: 0
Branch 2621: 0
Branch 2622: 0
Branch 2623: 0
Branch 2624: 0
Branch 2625: 0
Branch 2626: 0
Branch 2627: 0
Branch 2628: 0
Branch 2629: 0
Branch 2630: 0
Branch 2631: 0
Branch 2632: 0
Branch 2633: 0
Branch 2634: 0
Branch 2635: 0
Branch 2636: 0
Branch 2637: 0
Branch 2638: 0
Branch 2639: 0
Branch 2640: 0
Branch 2641: 0
Branch 2642: 0
Branch 2643: 0
Branch 2644: 0
Branch 2645: 0
Branch 2646: 0
Branch 2647: 0
Branch 2648: 0
Branch 2649: 0
Branch 2650: 0
Branch 2651: 0
Branch 2652: 0
Branch 2653: 0
Branch 2654: 0
Branch 2655: 0
Branch 2656: 0
Branch 2657: 0
Branch 2658: 0
Branch 2659: 0
Branch 2660: 0
Branch 2661: 0
Branch 2662: 0
Branch 2663: 0
Branch 2664: 0
Branch 2665: 0
Branch 2666: 0
Branch 2667: 0
Branch 2668: 0
Branch 2669: 0
Branch 2670: 0
Branch 2671: 0
Branch 2672: 0
Branch 2673: 0
Branch 2674: 0
Branch 2675: 0
Branch 2676: 0
Branch 2677: 0
Branch 2678: 0
Branch 2679: 0
Branch 2680: 0
Branch 2681: 0
Branch 2682: 0
Branch 2683: 0
Branch 2684: 0
Branch 2685: 0
Branch 2686: 0
Branch 2687: 0
Branch 2688: 0
Branch 2689: 0
Branch 2690: 0
Branch 2691: 0
Branch 2692: 0
Branch 2693: 0
Branch 2694: 0
Branch 2695: 0
Branch 2696: 0
Branch 2697: 0
Branch 2698: 0
Branch 2699: 0
Branch 2700: 0
Branch 2701: 0
Branch 2702: 0
Branch 2703: 0
Branch 2704: 0
Branch 2705: 0
Branch 2706: 0
Branch 2707: 0
Branch 2708: 0
Branch 2709: 0
Branch 2710: 0
Branch 2711: 0
Branch 2712: 0
Branch 2713: 0
Branch 2714: 0
Branch 2715: 0
Branch 2716: 0
Branch 2717: 0
Branch 2718: 0
Branch 2719: 0
Branch 2720: 0
Branch 2721: 0
Branch 2722: 0
Branch 2723: 0
Branch 2724: 0
Branch 2725: 0
Branch 2726: 0
Branch 2727: 0
Branch 2728: 0
Branch 2729: 0
Branch 2730: 0
Branch 2731: 0
Branch 2732: 0
Branch 2733: 0
Branch 2734: 0
Branch 2735: 0
Branch 2736: 0
Branch 2737: 0
Branch 2738: 0
Branch 2739: 0
Branch 2740: 0
Branch 2741: 0
Branch 2742: 0
Branch 2743: 0
Branch 2744: 0
Branch 2745: 0
Branch 2746: 0
Branch 2747: 0
Branch 2748: 0
Branch 2749: 0
Branch 2750: 0
Branch 2751: 0
Branch 2752: 0
Branch 2753: 0
Branch 2754: 0
Branch 2755: 0
Branch 2756: 0
Branch 2757: 0
Branch 2758: 0
Branch 2759: 0
Branch 2760: 0
Branch 2761: 0
Branch 2762: 0
Branch 2763: 0
Branch 2764: 0
Branch 2765: 0
Branch 2766: 0
Branch 2767: 0
Branch 2768: 0
Branch 2769: 0
Branch 2770: 0
Branch 2771: 0
Branch 2772: 0
Branch 2773: 0
Branch 2774: 0
Branch 2775: 0
Branch 2776: 0
Branch 2777: 0
Branch 2778: 0
Branch 2779: 0
Branch 2780: 0
Branch 2781: 0
Branch 2782: 0
Branch 2783: 0
Branch 2784: 0
Branch 2785: 0
Branch 2786: 0
Branch 2787: 0
Branch 2788: 0
Branch 2789: 0
Branch 2790: 0
Branch 2791: 0
Branch 2792: 0
Branch 2793: 0
Branch 2794: 0
Branch 2795: 0
Branch 2796: 0
Branch 2797: 0
Branch 2798: 0
Branch 2799: 0
Branch 2800: 0
Branch 2801: 0
Branch 2802: 0
Branch 2803: 0
Branch 2804: 0
Branch 2805: 0
Branch 2806: 0
Branch 2807: 0
Branch 2808: 0
Branch 2809: 0
Branch 2810: 0
Branch 2811: 0
Branch 2812: 0
Branch 2813: 0
Branch 2814: 0
Branch 2815: 0
Branch 2816: 0
Branch 2817: 0
Branch 2818: 0
Branch 2819: 0
Branch 2820: 0
Branch 2821: 0
Branch 2822: 0
Branch 2823: 0
Branch 2824: 0
Branch 2825: 0
Branch 2826: 0
Branch 2827: 0
Branch 2828: 0
Branch 2829: 0
Branch 2830: 0
Branch 2831: 0
Branch 2832: 0
Branch 2833: 0
Branch 2834: 0
Branch 2835: 0
Branch 2836: 0
Branch 2837: 0
Branch 2838: 0
Branch 2839: 0
Branch 2840: 0
Branch 2841: 0
Branch 2842: 0
Branch 2843: 0
Branch 2844: 0
Branch 2845: 0
Branch 2846: 0
Branch 2847: 0
Branch 2848: 0
Branch 2849: 0
Branch 2850: 0
Branch 2851: 0
Branch 2852: 0
Branch 2853: 0
Branch 2854: 0
Branch 2855: 0
Branch 2856: 0
Branch 2857: 0
Branch 2858: 0
Branch 2859: 0
Branch 2860: 0
Branch 2861: 0
Branch 2862: 0
Branch 2863: 0
Branch 2864: 0
Branch 2865: 0
Branch 2866: 0
Branch 2867: 0
Branch 2868: 0
Branch 2869: 0
Branch 2870: 0
Branch 2871: 0
Branch 2872: 0
Branch 2873: 0
Branch 2874: 0
Branch 2875: 0
Branch 2876: 0
Branch 2877: 0
Branch 2878: 0
Branch 2879: 0
Branch 2880: 0
Branch 2881: 0
Branch 2882: 0
Branch 2883: 0
Branch 2884: 0
Branch 2885: 0
Branch 2886: 0
Branch 2887: 0
Branch 2888: 0
Branch 2889: 0
Branch 2890: 0
Branch 2891: 0
Branch 2892: 0
Branch 2893: 0
Branch 2894: 0
Branch 2895: 0
Branch 2896: 0
Branch 2897: 0
Branch 2898: 0
Branch 2899: 0
Branch 2900: 0
Branch 2901: 0
Branch 2902: 0
Branch 2903: 0
Branch 2904: 0
Branch 2905: 0
Branch 2906: 0
Branch 2907: 0
Branch 2908: 0
Branch 2909: 0
Branch 2910: 0
Branch 2911: 0
Branch 2912: 0
Branch 2913: 0
Branch 2914: 0
Branch 2915: 0
Branch 2916: 0
Branch 2917: 0
Branch 2918: 0
Branch 2919: 0
Branch 2920: 0
Branch 2921: 0
Branch 2922: 0
Branch 2923: 0
Branch 2924: 0
Branch 2925: 0
Branch 2926: 0
Branch 2927: 0
Branch 2928: 0
Branch 2929: 0
Branch 2930: 0
Branch 2931: 0
Branch 2932: 0
Branch 2933: 0
Branch 2934: 0
Branch 2935: 0
Branch 2936: 0
Branch 2937: 0
Branch 2938: 0
Branch 2939: 0
Branch 2940: 0
Branch 2941: 0
Branch 2942: 0
Branch 2943: 0
Branch 2944: 0
Branch 2945: 0
Branch 2946: 0
Branch 2947: 0
Branch 2948: 0
Branch 2949: 0
Branch 2950: 0
Branch 2951: 0
Branch 2952: 0
Branch 2953: 0
Branch 2954: 0
Branch 2955: 0
Branch 2956: 0
Branch 2957: 0
Branch 2958: 0
Branch 2959: 0
Branch 2960: 0
Branch 2961: 0
Branch 2962: 0
Branch 2963: 0
Branch 2964: 0
Branch 2965: 0
Branch 2966: 0
Branch 2967: 0
Branch 2968: 0
Branch 2969: 0
Branch 2970: 0
Branch 2971: 0
Branch 2972: 0
Branch 2973: 0
Branch 2974: 0
Branch 2975: 0
Branch 2976: 0
Branch 2977: 0
Branch 2978: 0
Branch 2979: 0
Branch 2980: 0
Branch 2981: 0
Branch 2982: 0
Branch 2983: 0
Branch 2984: 0
Branch 2985: 0
Branch 2986: 0
Branch 2987: 0
Branch 2988: 0
Branch 2989: 0
Branch 2990: 0
Branch 2991: 0
Branch 2992: 0
Branch 2993: 0
Branch 2994: 0
Branch 2995: 0
Branch 2996: 0
Branch 2997: 0
Branch 2998: 0
Branch 2999: 0
Branch 3000: 0
Branch 3001: 0
Branch 3002: 0
Branch 3003: 0
Branch 3004: 0
Branch 3005: 0
Branch 3006: 0
Branch 3007: 0
Branch 3008: 0
Branch 3009: 0
Branch 3010: 0
Branch 3011: 0
Branch 3012: 0
Branch 3013: 0
Branch 3014: 0
Branch 3015: 0
Branch 3016: 0
Branch 3017: 0
Branch 3018: 0
Branch 3019: 0
Branch 3020: 0
Branch 3021: 0
Branch 3022: 0
Branch 3023: 0
Branch 3024: 0
Branch 3025: 0
Branch 3026: 0
Branch 3027: 0
Branch 3028: 0
Branch 3029: 0
Branch 3030: 0
Branch 3031: 0
Branch 3032: 0
Branch 3033: 0
Branch 3034: 0
Branch 3035: 0
Branch 3036: 0
Branch 3037: 0
Branch 3038: 0
Branch 3039: 0
Branch 3040: 0
Branch 3041: 0
Branch 3042: 0
Branch 3043: 0
Branch 3044: 0
Branch 3045: 0
Branch 3046: 0
Branch 3047: 0
Branch 3048: 0
Branch 3049: 0
Branch 3050: 0
Branch 3051: 0
Branch 3052: 0
Branch 3053: 0
Branch 3054: 0
Branch 3055: 0
Branch 3056: 0
Branch 3057: 0
Branch 3058: 0
Branch 3059: 0
Branch 3060: 0
Branch 3061: 0
Branch 3062: 0
Branch 3063: 0
Branch 3064: 0
Branch 3065: 0
Branch 3066: 0
Branch 3067: 0
Branch 3068: 0
Branch 3069: 0
Branch 3070: 0
Branch 3071: 0
Branch 3072: 0
Branch 3073: 0
Branch 3074: 0
Branch 3075: 0
Branch 3076: 0
Branch 3077: 0
Branch 3078: 0
Branch 3079: 0
Branch 3080: 0
Branch 3081: 0
Branch 3082: 0
Branch 3083: 0
Branch 3084: 0
Branch 3085: 0
Branch 3086: 0
Branch 3087: 0
Branch 3088: 0
Branch 3089: 0
Branch 3090: 0
Branch 3091: 0
Branch 3092: 0
Branch 3093: 0
Branch 3094: 0
Branch 3095: 0
Branch 3096: 0
Branch 3097: 0
Branch 3098: 0
Branch 3099: 0
Branch 3100: 0
Branch 3101: 0
Branch 3102: 0
Branch 3103: 0
Branch 3104: 0
Branch 3105: 0
Branch 3106: 0
Branch 3107: 0
Branch 3108: 0
Branch 3109: 0
Branch 3110: 0
Branch 3111: 0
Branch 3112: 0
Branch 3113: 0
Branch 3114: 0
Branch 3115: 0
Branch 3116: 0
Branch 3117: 0
Branch 3118: 0
Branch 3119: 0
Branch 3120: 0
Branch 3121: 0
Branch 3122: 0
Branch 3123: 0
Branch 3124: 0
Branch 3125: 0
Branch 3126: 0
Branch 3127: 0
Branch 3128: 0
Branch 3129: 0
Branch 3130: 0
Branch 3131: 0
Branch 3132: 0
Branch 3133: 0
Branch 3134: 0
Branch 3135: 0
Branch 3136: 0
Branch 3137: 0
Branch 3138: 0
Branch 3139: 0
Branch 3140: 0
Branch 3141: 0
Branch 3142: 0
Branch 3143: 0
Branch 3144: 0
Branch 3145: 0
Branch 3146: 0
Branch 3147: 0
Branch 3148: 0
Branch 3149: 0
Branch 3150: 0
Branch 3151: 0
Branch 3152: 0
Branch 3153: 0
Branch 3154: 0
Branch 3155: 0
Branch 3156: 0
Branch 3157: 0
Branch 3158: 0
Branch 3159: 0
Branch 3160: 0
Branch 3161: 0
Branch 3162: 0
Branch 3163: 0
Branch 3164: 0
Branch 3165: 0
Branch 3166: 0
Branch 3167: 0
Branch 3168: 0
Branch 3169: 0
Branch 3170: 0
Branch 3171: 0
Branch 3172: 0
Branch 3173: 0
Branch 3174: 0
Branch 3175: 0
Branch 3176: 0
Branch 3177: 0
Branch 3178: 0
Branch 3179: 0
Branch 3180: 0
Branch 3181: 0
Branch 3182: 0
Branch 3183: 0
Branch 3184: 0
Branch 3185: 0
Branch 3186: 0
Branch 3187: 0
Branch 3188: 0
Branch 3189: 0
Branch 3190: 0
Branch 3191: 0
Branch 3192: 0
Branch 3193: 0
Branch 3194: 0
Branch 3195: 0
Branch 3196: 0
Branch 3197: 0
Branch 3198: 0
Branch 3199: 0
Branch 3200: 0
Branch 3201: 0
Branch 3202: 0
Branch 3203: 0
Branch 3204: 0
Branch 3205: 0
Branch 3206: 0
Branch 3207: 0
Branch 3208: 0
Branch 3209: 0
Branch 3210: 0
Branch 3211: 0
Branch 3212: 0
Branch 3213: 0
Branch 3214: 0
Branch 3215: 0
Branch 3216: 0
Branch 3217: 0
Branch 3218: 0
Branch 3219: 0
Branch 3220: 0
Branch 3221: 0
Branch 3222: 0
Branch 3223: 0
Branch 3224: 0
Branch 3225: 0
Branch 3226: 0
Branch 3227: 0
Branch 3228: 0
Branch 3229: 0
Branch 3230: 0
Branch 3231: 0
Branch 3232: 0
Branch 3233: 0
Branch 3234: 0
Branch 3235: 0
Branch 3236: 0
Branch 3237: 0
Branch 3238: 0
Branch 3239: 0
Branch 3240: 0
Branch 3241: 0
Branch 3242: 0
Branch 3243: 0
Branch 3244: 0
Branch 3245: 0
Branch 3246: 0
Branch 3247: 0
Branch 3248: 0
Branch 3249: 0
Branch 3250: 0
Branch 3251: 0
Branch 3252: 0
Branch 3253: 0
Branch 3254: 0
Branch 3255: 0
Branch 3256: 0
Branch 3257: 0
Branch 3258: 0
Branch 3259: 0
Branch 3260: 0
Branch 3261: 0
Branch 3262: 0
Branch 3263: 0
Branch 3264: 0
Branch 3265: 0
Branch 3266: 0
Branch 3267: 0
Branch 3268: 0
Branch 3269: 0
Branch 3270: 0
Branch 3271: 0
Branch 3272: 0
Branch 3273: 0
Branch 3274: 0
Branch 3275: 0
Branch 3276: 0
Branch 3277: 0
Branch 3278: 0
Branch 3279: 0
Branch 3280: 0
Branch 3281: 0
Branch 3282: 0
Branch 3283: 0
Branch 3284: 0
Branch 3285: 0
Branch 3286: 0
Branch 3287: 0
Branch 3288: 0
Branch 3289: 0
Branch 3290: 0
Branch 3291: 0
Branch 3292: 0
Branch 3293: 0
Branch 3294: 0
Branch 3295: 0
Branch 3296: 0
Branch 3297: 0
Branch 3298: 0
Branch 3299: 0
Branch 3300: 0
Branch 3301: 0
Branch 3302: 0
Branch 3303: 0
Branch 3304: 0
Branch 3305: 0
Branch 3306: 0
Branch 3307: 0
Branch 3308: 0
Branch 3309: 0
Branch 3310: 0
Branch 3311: 0
Branch 3312: 0
Branch 3313: 0
Branch 3314: 0
Branch 3315: 0
Branch 3316: 0
Branch 3317: 0
Branch 3318: 0
Branch 3319: 0
Branch 3320: 0
Branch 3321: 0
Branch 3322: 0
Branch 3323: 0
Branch 3324: 0
Branch 3325: 0
Branch 3326: 0
Branch 3327: 0
Branch 3328: 0
Branch 3329: 0
Branch 3330: 0
Branch 3331: 0
Branch 3332: 0
Branch 3333: 0
Branch 3334: 0
Branch 3335: 0
Branch 3336: 0
Branch 3337: 0
Branch 3338: 0
Branch 3339: 0
Branch 3340: 0
Branch 3341: 0
Branch 3342: 0
Branch 3343: 0
Branch 3344: 0
Branch 3345: 0
Branch 3346: 0
Branch 3347: 0
Branch 3348: 0
Branch 3349: 0
Branch 3350: 0
Branch 3351: 0
Branch 3352: 0
Branch 3353: 0
Branch 3354: 0
Branch 3355: 0
Branch 3356: 0
Branch 3357: 0
Branch 3358: 0
Branch 3359: 0
Branch 3360: 0
Branch 3361: 0
Branch 3362: 0
Branch 3363: 0
Branch 3364: 0
Branch 3365: 0
Branch 3366: 0
Branch 3367: 0
Branch 3368: 0
Branch 3369: 0
Branch 3370: 0
Branch 3371: 0
Branch 3372: 0
Branch 3373: 0
Branch 3374: 0
Branch 3375: 0
Branch 3376: 0
Branch 3377: 0
Branch 3378: 0
Branch 3379: 0
Branch 3380: 0
Branch 3381: 0
Branch 3382: 0
Branch 3383: 0
Branch 3384: 0
Branch 3385: 0
Branch 3386: 0
Branch 3387: 0
Branch 3388: 0
Branch 3389: 0
Branch 3390: 0
Branch 3391: 0
Branch 3392: 0
Branch 3393: 0
Branch 3394: 0
Branch 3395: 0
Branch 3396: 0
Branch 3397: 0
Branch 3398: 0
Branch 3399: 0
Branch 3400: 0
Branch 3401: 0
Branch 3402: 0
Branch 3403: 0
Branch 3404: 0
Branch 3405: 0
Branch 3406: 0
Branch 3407: 0
Branch 3408: 0
Branch 3409: 0
Branch 3410: 0
Branch 3411: 0
Branch 3412: 0
Branch 3413: 0
Branch 3414: 0
Branch 3415: 0
Branch 3416: 0
Branch 3417: 0
Branch 3418: 0
Branch 3419: 0
Branch 3420: 0
Branch 3421: 0
Branch 3422: 0
Branch 3423: 0
Branch 3424: 0
Branch 3425: 0
Branch 3426: 0
Branch 3427: 0
Branch 3428: 0
Branch 3429: 0
Branch 3430: 0
Branch 3431: 0
Branch 3432: 0
Branch 3433: 0
Branch 3434: 0
Branch 3435: 0
Branch 3436: 0
Branch 3437: 0
Branch 3438: 0
Branch 3439: 0
Branch 3440: 0
Branch 3441: 0
Branch 3442: 0
Branch 3443: 0
Branch 3444: 0
Branch 3445: 0
Branch 3446: 0
Branch 3447: 0
Branch 3448: 0
Branch 3449: 0
Branch 3450: 0
Branch 3451: 0
Branch 3452: 0
Branch 3453: 0
Branch 3454: 0
Branch 3455: 0
Branch 3456: 0
Branch 3457: 0
Branch 3458: 0
Branch 3459: 0
Branch 3460: 0
Branch 3461: 0
Branch 3462: 0
Branch 3463: 0
Branch 3464: 0
Branch 3465: 0
Branch 3466: 0
Branch 3467: 0
Branch 3468: 0
Branch 3469: 0
Branch 3470: 0
Branch 3471: 0
Branch 3472: 0
Branch 3473: 0
Branch 3474: 0
Branch 3475: 0
Branch 3476: 0
Branch 3477: 0
Branch 3478: 0
Branch 3479: 0
Branch 3480: 0
Branch 3481: 0
Branch 3482: 0
Branch 3483: 0
Branch 3484: 0
Branch 3485: 0
Branch 3486: 0
Branch 3487: 0
Branch 3488: 0
Branch 3489: 0
Branch 3490: 0
Branch 3491: 0
Branch 3492: 0
Branch 3493: 0
Branch 3494: 0
Branch 3495: 0
Branch 3496: 0
Branch 3497: 0
Branch 3498: 0
Branch 3499: 0
Branch 3500: 0
Branch 3501: 0
Branch 3502: 0
Branch 3503: 0
Branch 3504: 0
Branch 3505: 0
Branch 3506: 0
Branch 3507: 0
Branch 3508: 0
Branch 3509: 0
Branch 3510: 0
Branch 3511: 0
Branch 3512: 0
Branch 3513: 0
Branch 3514: 0
Branch 3515: 0
Branch 3516: 0
Branch 3517: 0
Branch 3518: 0
Branch 3519: 0
Branch 3520: 0
Branch 3521: 0
Branch 3522: 0
Branch 3523: 0
Branch 3524: 0
Branch 3525: 0
Branch 3526: 0
Branch 3527: 0
Branch 3528: 0
Branch 3529: 0
Branch 3530: 0
Branch 3531: 0
Branch 3532: 0
Branch 3533: 0
Branch 3534: 0
Branch 3535: 0
Branch 3536: 0
Branch 3537: 0
Branch 3538: 0
Branch 3539: 0
Branch 3540: 0
Branch 3541: 0
Branch 3542: 0
Branch 3543: 0
Branch 3544: 0
Branch 3545: 0
Branch 3546: 0
Branch 3547: 0
Branch 3548: 0
Branch 3549: 0
Branch 3550: 0
Branch 3551: 0
Branch 3552: 0
Branch 3553: 0
Branch 3554: 0
Branch 3555: 0
Branch 3556: 0
Branch 3557: 0
Branch 3558: 0
Branch 3559: 0
Branch 3560: 0
Branch 3561: 0
Branch 3562: 0
Branch 3563: 0
Branch 3564: 0
Branch 3565: 0
Branch 3566: 0
Branch 3567: 0
Branch 3568: 0
Branch 3569: 0
Branch 3570: 0
Branch 3571: 0
Branch 3572: 0
Branch 3573: 0
Branch 3574: 0
Branch 3575: 0
Branch 3576: 0
Branch 3577: 0
Branch 3578: 0
Branch 3579: 0
Branch 3580: 0
Branch 3581: 0
Branch 3582: 0
Branch 3583: 0
Branch 3584: 0
Branch 3585: 0
Branch 3586: 0
Branch 3587: 0
Branch 3588: 0
Branch 3589: 0
Branch 3590: 0
Branch 3591: 0
Branch 3592: 0
Branch 3593: 0
Branch 3594: 0
Branch 3595: 0
Branch 3596: 0
Branch 3597: 0
Branch 3598: 0
Branch 3599: 0
Branch 3600: 0
Branch 3601: 0
Branch 3602: 0
Branch 3603: 0
Branch 3604: 0
Branch 3605: 0
Branch 3606: 0
Branch 3607: 0
Branch 3608: 0
Branch 3609: 0
Branch 3610: 0
Branch 3611: 0
Branch 3612: 0
Branch 3613: 0
Branch 3614: 0
Branch 3615: 0
Branch 3616: 0
Branch 3617: 0
Branch 3618: 0
Branch 3619: 0
Branch 3620: 0
Branch 3621: 0
Branch 3622: 0
Branch 3623: 0
Branch 3624: 0
Branch 3625: 0
Branch 3626: 0
Branch 3627: 0
Branch 3628: 0
Branch 3629: 0
Branch 3630: 0
Branch 3631: 0
Branch 3632: 0
Branch 3633: 0
Branch 3634: 0
Branch 3635: 0
Branch 3636: 0
Branch 3637: 0
Branch 3638: 0
Branch 3639: 0
Branch 3640: 0
Branch 3641: 0
Branch 3642: 0
Branch 3643: 0
Branch 3644: 0
Branch 3645: 0
Branch 3646: 0
Branch 3647: 0
Branch 3648: 0
Branch 3649: 0
Branch 3650: 0
Branch 3651: 0
Branch 3652: 0
Branch 3653: 0
Branch 3654: 0
Branch 3655: 0
Branch 3656: 0
Branch 3657: 0
Branch 3658: 0
Branch 3659: 0
Branch 3660: 0
Branch 3661: 0
Branch 3662: 0
Branch 3663: 0
Branch 3664: 0
Branch 3665: 0
Branch 3666: 0
Branch 3667: 0
Branch 3668: 0
Branch 3669: 0
Branch 3670: 0
Branch 3671: 0
Branch 3672: 0
Branch 3673: 0
Branch 3674: 0
Branch 3675: 0
Branch 3676: 0
Branch 3677: 0
Branch 3678: 0
Branch 3679: 0
Branch 3680: 0
Branch 3681: 0
Branch 3682: 0
Branch 3683: 0
Branch 3684: 0
Branch 3685: 0
Branch 3686: 0
Branch 3687: 0
Branch 3688: 0
Branch 3689: 0
Branch 3690: 0
Branch 3691: 0
Branch 3692: 0
Branch 3693: 0
Branch 3694: 0
Branch 3695: 0
Branch 3696: 0
Branch 3697: 0
Branch 3698: 0
Branch 3699: 0
Branch 3700: 0
Branch 3701: 0
Branch 3702: 0
Branch 3703: 0
Branch 3704: 0
Branch 3705: 0
Branch 3706: 0
Branch 3707: 0
Branch 3708: 0
Branch 3709: 0
Branch 3710: 0
Branch 3711: 0
Branch 3712: 0
Branch 3713: 0
Branch 3714: 0
Branch 3715: 0
Branch 3716: 0
Branch 3717: 0
Branch 3718: 0
Branch 3719: 0
Branch 3720: 0
Branch 3721: 0
Branch 3722: 0
Branch 3723: 0
Branch 3724: 0
Branch 3725: 0
Branch 3726: 0
Branch 3727: 0
Branch 3728: 0
Branch 3729: 0
Branch 3730: 0
Branch 3731: 0
Branch 3732: 0
Branch 3733: 0
Branch 3734: 0
Branch 3735: 0
Branch 3736: 0
Branch 3737: 0
Branch 3738: 0
Branch 3739: 0
Branch 3740: 0
Branch 3741: 0
Branch 3742: 0
Branch 3743: 0
Branch 3744: 0
Branch 3745: 0
Branch 3746: 0
Branch 3747: 0
Branch 3748: 0
Branch 3749: 0
Branch 3750: 0
Branch 3751: 0
Branch 3752: 0
Branch 3753: 0
Branch 3754: 0
Branch 3755: 0
Branch 3756: 0
Branch 3757: 0
Branch 3758: 0
Branch 3759: 0
Branch 3760: 0
Branch 3761: 0
Branch 3762: 0
Branch 3763: 0
Branch 3764: 0
Branch 3765: 0
Branch 3766: 0
Branch 3767: 0
Branch 3768: 0
Branch 3769: 0
Branch 3770: 0
Branch 3771: 0
Branch 3772: 0
Branch 3773: 0
Branch 3774: 0
Branch 3775: 0
Branch 3776: 0
Branch 3777: 0
Branch 3778: 0
Branch 3779: 0
Branch 3780: 0
Branch 3781: 0
Branch 3782: 0
Branch 3783: 0
Branch 3784: 0
Branch 3785: 0
Branch 3786: 0
Branch 3787: 0
Branch 3788: 0
Branch 3789: 0
Branch 3790: 0
Branch 3791: 0
Branch 3792: 0
Branch 3793: 0
Branch 3794: 0
Branch 3795: 0
Branch 3796: 0
Branch 3797: 0
Branch 3798: 0
Branch 3799: 0
Branch 3800: 0
Branch 3801: 0
Branch 3802: 0
Branch 3803: 0
Branch 3804: 0
Branch 3805: 0
Branch 3806: 0
Branch 3807: 0
Branch 3808: 0
Branch 3809: 0
Branch 3810: 0
Branch 3811: 0
Branch 3812: 0
Branch 3813: 0
Branch 3814: 0
Branch 3815: 0
Branch 3816: 0
Branch 3817: 0
Branch 3818: 0
Branch 3819: 0
Branch 3820: 0
Branch 3821: 0
Branch 3822: 0
Branch 3823: 0
Branch 3824: 0
Branch 3825: 0
Branch 3826: 0
Branch 3827: 0
Branch 3828: 0
Branch 3829: 0
Branch 3830: 0
Branch 3831: 0
Branch 3832: 0
Branch 3833: 0
Branch 3834: 0
Branch 3835: 0
Branch 3836: 0
Branch 3837: 0
Branch 3838: 0
Branch 3839: 0
Branch 3840: 0
Branch 3841: 0
Branch 3842: 0
Branch 3843: 0
Branch 3844: 0
Branch 3845: 0
Branch 3846: 0
Branch 3847: 0
Branch 3848: 0
Branch 3849: 0
Branch 3850: 0
Branch 3851: 0
Branch 3852: 0
Branch 3853: 0
Branch 3854: 0
Branch 3855: 0
Branch 3856: 0
Branch 3857: 0
Branch 3858: 0
Branch 3859: 0
Branch 3860: 0
Branch 3861: 0
Branch 3862: 0
Branch 3863: 0
Branch 3864: 0
Branch 3865: 0
Branch 3866: 0
Branch 3867: 0
Branch 3868: 0
Branch 3869: 0
Branch 3870: 0
Branch 3871: 0
Branch 3872: 0
Branch 3873: 0
Branch 3874: 0
Branch 3875: 0
Branch 3876: 0
Branch 3877: 0
Branch 3878: 0
Branch 3879: 0
Branch 3880: 0
Branch 3881: 0
Branch 3882: 0
Branch 3883: 0
Branch 3884: 0
Branch 3885: 0
Branch 3886: 0
Branch 3887: 0
Branch 3888: 0
Branch 3889: 0
Branch 3890: 0
Branch 3891: 0
Branch 3892: 0
Branch 3893: 0
Branch 3894: 0
Branch 3895: 0
Branch 3896: 0
Branch 3897: 0
Branch 3898: 0
Branch 3899: 0
Branch 3900: 0
Branch 3901: 0
Branch 3902: 0
Branch 3903: 0
Branch 3904: 0
Branch 3905: 0
Branch 3906: 0
Branch 3907: 0
Branch 3908: 0
Branch 3909: 0
Branch 3910: 0
Branch 3911: 0
Branch 3912: 0
Branch 3913: 0
Branch 3914: 0
Branch 3915: 0
Branch 3916: 0
Branch 3917: 0
Branch 3918: 0
Branch 3919: 0
Branch 3920: 0
Branch 3921: 0
Branch 3922: 0
Branch 3923: 0
Branch 3924: 0
Branch 3925: 0
Branch 3926: 0
Branch 3927: 0
Branch 3928: 0
Branch 3929: 0
Branch 3930: 0
Branch 3931: 0
Branch 3932: 0
Branch 3933: 0
Branch 3934: 0
Branch 3935: 0
Branch 3936: 0
Branch 3937: 0
Branch 3938: 0
Branch 3939: 0
Branch 3940: 0
Branch 3941: 0
Branch 3942: 0
Branch 3943: 0
Branch 3944: 0
Branch 3945: 0
Branch 3946: 0
Branch 3947: 0
Branch 3948: 0
Branch 3949: 0
Branch 3950: 0
Branch 3951: 0
Branch 3952: 0
Branch 3953: 0
Branch 3954: 0
Branch 3955: 0
Branch 3956: 0
Branch 3957: 0
Branch 3958: 0
Branch 3959: 0
Branch 3960: 0
Branch 3961: 0
Branch 3962: 0
Branch 3963: 0
Branch 3964: 0
Branch 3965: 0
Branch 3966: 0
Branch 3967: 0
Branch 3968: 0
Branch 3969: 0
Branch 3970: 0
Branch 3971: 0
Branch 3972: 0
Branch 3973: 0
Branch 3974: 0
Branch 3975: 0
Branch 3976: 0
Branch 3977: 0
Branch 3978: 0
Branch 3979: 0
Branch 3980: 0
Branch 3981: 0
Branch 3982: 0
Branch 3983: 0
Branch 3984: 0
Branch 3985: 0
Branch 3986: 0
Branch 3987: 0
Branch 3988: 0
Branch 3989: 0
Branch 3990: 0
Branch 3991: 0
Branch 3992: 0
Branch 3993: 0
Branch 3994: 0
Branch 3995: 0
Branch 3996: 0
Branch 3997: 0
Branch 3998: 0
Branch 3999: 0
Branch 4000: 0
Branch 4001: 0
Branch 4002: 0
Branch 4003: 0
Branch 4004: 0
Branch 4005: 0
Branch 4006: 0
Branch 4007: 0
Branch 4008: 0
Branch 4009: 0
Branch 4010: 0
Branch 4011: 0
Branch 4012: 0
Branch 4013: 0
Branch 4014: 0
Branch 4015: 0
Branch 4016: 0
Branch 4017: 0
Branch 4018: 0
Branch 4019: 0
Branch 4020: 0
Branch 4021: 0
Branch 4022: 0
Branch 4023: 0
Branch 4024: 0
Branch 4025: 0
Branch 4026: 0
Branch 4027: 0
Branch 4028: 0
Branch 4029: 0
Branch 4030: 0
Branch 4031: 0
Branch 4032: 0
Branch 4033: 0
Branch 4034: 0
Branch 4035: 0
Branch 4036: 0
Branch 4037: 0
Branch 4038: 0
Branch 4039: 0
Branch 4040: 0
Branch 4041: 0
Branch 4042: 0
Branch 4043: 0
Branch 4044: 0
Branch 4045: 0
Branch 4046: 0
Branch 4047: 0
Branch 4048: 0
Branch 4049: 0
Branch 4050: 0
Branch 4051: 0
Branch 4052: 0
Branch 4053: 0
Branch 4054: 0
Branch 4055: 0
Branch 4056: 0
Branch 4057: 0
Branch 4058: 0
Branch 4059: 0
Branch 4060: 0
Branch 4061: 0
Branch 4062: 0
Branch 4063: 0
Branch 4064: 0
Branch 4065: 0
Branch 4066: 0
Branch 4067: 0
Branch 4068: 0
Branch 4069: 0
Branch 4070: 0
Branch 4071: 0
Branch 4072: 0
Branch 4073: 0
Branch 4074: 0
Branch 4075: 0
Branch 4076: 0
Branch 4077: 0
Branch 4078: 0
Branch 4079: 0
Branch 4080: 0
Branch 4081: 0
Branch 4082: 0
Branch 4083: 0
Branch 4084: 0
Branch 4085: 0
Branch 4086: 0
Branch 4087: 0
Branch 4088: 0
Branch 4089: 0
Branch 4090: 0
Branch 4091: 0
Branch 4092: 0
Branch 4093: 0
Branch 4094: 0
Branch 4095: 0
Branch 4096: 0
Branch 4097: 0
Branch 4098: 0
Branch 4099: 0
Branch 4100: 0
Branch 4101: 0
Branch 4102: 0
Branch 4103: 0
Branch 4104: 0
Branch 4105: 0
Branch 4106: 0
Branch 4107: 0
Branch 4108: 0
Branch 4109: 0
Branch 4110: 0
Branch 4111: 0
Branch 4112: 0
Branch 4113: 0
Branch 4114: 0
Branch 4115: 0
Branch 4116: 0
Branch 4117: 0
Branch 4118: 0
Branch 4119: 0
Branch 4120: 0
Branch 4121: 0
Branch 4122: 0
Branch 4123: 0
Branch 4124: 0
Branch 4125: 0
Branch 4126: 0
Branch 4127: 0
Branch 4128: 0
Branch 4129: 0
Branch 4130: 0
Branch 4131: 0
Branch 4132: 0
Branch 4133: 0
Branch 4134: 0
Branch 4135: 0
Branch 4136: 0
Branch 4137: 0
Branch 4138: 0
Branch 4139: 0
Branch 4140: 0
Branch 4141: 0
Branch 4142: 0
Branch 4143: 0
Branch 4144: 0
Branch 4145: 0
Branch 4146: 0
Branch 4147: 0
Branch 4148: 0
Branch 4149: 0
Branch 4150: 0
Branch 4151: 0
Branch 4152: 0
Branch 4153: 0
Branch 4154: 0
Branch 4155: 0
Branch 4156: 0
Branch 4157: 0
Branch 4158: 0
Branch 4159: 0
Branch 4160: 0
Branch 4161: 0
Branch 4162: 0
Branch 4163: 0
Branch 4164: 0
Branch 4165: 0
Branch 4166: 0
Branch 4167: 0
Branch 4168: 0
Branch 4169: 0
Branch 4170: 0
Branch 4171: 0
Branch 4172: 0
Branch 4173: 0
Branch 4174: 0
Branch 4175: 0
Branch 4176: 0
Branch 4177: 0
Branch 4178: 0
Branch 4179: 0
Branch 4180: 0
Branch 4181: 0
Branch 4182: 0
Branch 4183: 0
Branch 4184: 0
Branch 4185: 0
Branch 4186: 0
Branch 4187: 0
Branch 4188: 0
Branch 4189: 0
Branch 4190: 0
Branch 4191: 0
Branch 4192: 0
Branch 4193: 0
Branch 4194: 0
Branch 4195: 0
Branch 4196: 0
Branch 4197: 0
Branch 4198: 0
Branch 4199: 0
Branch 4200: 0
Branch 4201: 0
Branch 4202: 0
Branch 4203: 0
Branch 4204: 0
Branch 4205: 0
Branch 4206: 0
Branch 4207: 0
Branch 4208: 0
Branch 4209: 0
Branch 4210: 0
Branch 4211: 0
Branch 4212: 0
Branch 4213: 0
Branch 4214: 0
Branch 4215: 0
Branch 4216: 0
Branch 4217: 0
Branch 4218: 0
Branch 4219: 0
Branch 4220: 0
Branch 4221: 0
Branch 4222: 0
Branch 4223: 0
Branch 4224: 0
Branch 4225: 0
Branch 4226: 0
Branch 4227: 0
Branch 4228: 0
Branch 4229: 0
Branch 4230: 0
Branch 4231: 0
Branch 4232: 0
Branch 4233: 0
Branch 4234: 0
Branch 4235: 0
Branch 4236: 0
Branch 4237: 0
Branch 4238: 0
Branch 4239: 0
Branch 4240: 0
Branch 4241: 0
Branch 4242: 0
Branch 4243: 0
Branch 4244: 0
Branch 4245: 0
Branch 4246: 0
Branch 4247: 0
Branch 4248: 0
Branch 4249: 0
Branch 4250: 0
Branch 4251: 0
Branch 4252: 0
Branch 4253: 0
Branch 4254: 0
Branch 4255: 0
Branch 4256: 0
Branch 4257: 0
Branch 4258: 0
Branch 4259: 0
Branch 4260: 0
Branch 4261: 0
Branch 4262: 0
Branch 4263: 0
Branch 4264: 0
Branch 4265: 0
Branch 4266: 0
Branch 4267: 0
Branch 4268: 0
Branch 4269: 0
Branch 4270: 0
Branch 4271: 0
Branch 4272: 0
Branch 4273: 0
Branch 4274: 0
Branch 4275: 0
Branch 4276: 0
Branch 4277: 0
Branch 4278: 0
Branch 4279: 0
Branch 4280: 0
Branch 4281: 0
Branch 4282: 0
Branch 4283: 0
Branch 4284: 0
Branch 4285: 0
Branch 4286: 0
Branch 4287: 0
Branch 4288: 0
Branch 4289: 0
Branch 4290: 0
Branch 4291: 0
Branch 4292: 0
Branch 4293: 0
Branch 4294: 0
Branch 4295: 0
Branch 4296: 0
Branch 4297: 0
Branch 4298: 0
Branch 4299: 0
Branch 4300: 0
Branch 4301: 0
Branch 4302: 0
Branch 4303: 0
Branch 4304: 0
Branch 4305: 0
Branch 4306: 0
Branch 4307: 0
Branch 4308: 0
Branch 4309: 0
Branch 4310: 0
Branch 4311: 0
Branch 4312: 0
Branch 4313: 0
Branch 4314: 0
Branch 4315: 0
Branch 4316: 0
Branch 4317: 0
Branch 4318: 0
Branch 4319: 0
Branch 4320: 0
Branch 4321: 0
Branch 4322: 0
Branch 4323: 0
Branch 4324: 0
Branch 4325: 0
Branch 4326: 0
Branch 4327: 0
Branch 4328: 0
Branch 4329: 0
Branch 4330: 0
Branch 4331: 0
Branch 4332: 0
Branch 4333: 0
Branch 4334: 0
Branch 4335: 0
Branch 4336: 0
Branch 4337: 0
Branch 4338: 0
Branch 4339: 0
Branch 4340: 0
Branch 4341: 0
Branch 4342: 0
Branch 4343: 0
Branch 4344: 0
Branch 4345: 0
Branch 4346: 0
Branch 4347: 0
Branch 4348: 0
Branch 4349: 0
Branch 4350: 0
Branch 4351: 0
Branch 4352: 0
Branch 4353: 0
Branch 4354: 0
Branch 4355: 0
Branch 4356: 0
Branch 4357: 0
Branch 4358: 0
Branch 4359: 0
Branch 4360: 0
Branch 4361: 0
Branch 4362: 0
Branch 4363: 0
Branch 4364: 0
Branch 4365: 0
Branch 4366: 0
Branch 4367: 0
Branch 4368: 0
Branch 4369: 0
Branch 4370: 0
Branch 4371: 0
Branch 4372: 0
Branch 4373: 0
Branch 4374: 0
Branch 4375: 0
Branch 4376: 0
Branch 4377: 0
Branch 4378: 0
Branch 4379: 0
Branch 4380: 0
Branch 4381: 0
Branch 4382: 0
Branch 4383: 0
Branch 4384: 0
Branch 4385: 0
Branch 4386: 0
Branch 4387: 0
Branch 4388: 0
Branch 4389: 0
Branch 4390: 0
Branch 4391: 0
Branch 4392: 0
Branch 4393: 0
Branch 4394: 0
Branch 4395: 0
Branch 4396: 0
Branch 4397: 0
Branch 4398: 0
Branch 4399: 0
Branch 4400: 0
Branch 4401: 0
Branch 4402: 0
Branch 4403: 0
Branch 4404: 0
Branch 4405: 0
Branch 4406: 0
Branch 4407: 0
Branch 4408: 0
Branch 4409: 0
Branch 4410: 0
Branch 4411: 0
Branch 4412: 0
Branch 4413: 0
Branch 4414: 0
Branch 4415: 0
Branch 4416: 0
Branch 4417: 0
Branch 4418: 0
Branch 4419: 0
Branch 4420: 0
Branch 4421: 0
Branch 4422: 0
Branch 4423: 0
Branch 4424: 0
Branch 4425: 0
Branch 4426: 0
Branch 4427: 0
Branch 4428: 0
Branch 4429: 0
Branch 4430: 0
Branch 4431: 0
Branch 4432: 0
Branch 4433: 0
Branch 4434: 0
Branch 4435: 0
Branch 4436: 0
Branch 4437: 0
Branch 4438: 0
Branch 4439: 0
Branch 4440: 0
Branch 4441: 0
Branch 4442: 0
Branch 4443: 0
Branch 4444: 0
Branch 4445: 0
Branch 4446: 0
Branch 4447: 0
Branch 4448: 0
Branch 4449: 0
Branch 4450: 0
Branch 4451: 0
Branch 4452: 0
Branch 4453: 0
Branch 4454: 0
Branch 4455: 0
Branch 4456: 0
Branch 4457: 0
Branch 4458: 0
Branch 4459: 0
Branch 4460: 0
Branch 4461: 0
Branch 4462: 0
Branch 4463: 0
Branch 4464: 0
Branch 4465: 0
Branch 4466: 0
Branch 4467: 0
Branch 4468: 0
Branch 4469: 0
Branch 4470: 0
Branch 4471: 0
Branch 4472: 0
Branch 4473: 0
Branch 4474: 0
Branch 4475: 0
Branch 4476: 0
Branch 4477: 0
Branch 4478: 0
Branch 4479: 0
Branch 4480: 0
Branch 4481: 0
Branch 4482: 0
Branch 4483: 0
Branch 4484: 0
Branch 4485: 0
Branch 4486: 0
Branch 4487: 0
Branch 4488: 0
Branch 4489: 0
Branch 4490: 0
Branch 4491: 0
Branch 4492: 0
Branch 4493: 0
Branch 4494: 0
Branch 4495: 0
Branch 4496: 0
Branch 4497: 0
Branch 4498: 0
Branch 4499: 0
Branch 4500: 0
Branch 4501: 0
Branch 4502: 0
Branch 4503: 0
Branch 4504: 0
Branch 4505: 0
Branch 4506: 0
Branch 4507: 0
Branch 4508: 0
Branch 4509: 0
Branch 4510: 0
Branch 4511: 0
Branch 4512: 0
Branch 4513: 0
Branch 4514: 0
Branch 4515: 0
Branch 4516: 0
Branch 4517: 0
Branch 4518: 0
Branch 4519: 0
Branch 4520: 0
Branch 4521: 0
Branch 4522: 0
Branch 4523: 0
Branch 4524: 0
Branch 4525: 0
Branch 4526: 0
Branch 4527: 0
Branch 4528: 0
Branch 4529: 0
Branch 4530: 0
Branch 4531: 0
Branch 4532: 0
Branch 4533: 0
Branch 4534: 0
Branch 4535: 0
Branch 4536: 0
Branch 4537: 0
Branch 4538: 0
Branch 4539: 0
Branch 4540: 0
Branch 4541: 0
Branch 4542: 0
Branch 4543: 0
Branch 4544: 0
Branch 4545: 0
Branch 4546: 0
Branch 4547: 0
Branch 4548: 0
Branch 4549: 0
Branch 4550: 0
Branch 4551: 0
Branch 4552: 0
Branch 4553: 0
Branch 4554: 0
Branch 4555: 0
Branch 4556: 0
Branch 4557: 0
Branch 4558: 0
Branch 4559: 0
Branch 4560: 0
Branch 4561: 0
Branch 4562: 0
Branch 4563: 0
Branch 4564: 0
Branch 4565: 0
Branch 4566: 0
Branch 4567: 0
Branch 4568: 0
Branch 4569: 0
Branch 4570: 0
Branch 4571: 0
Branch 4572: 0
Branch 4573: 0
Branch 4574: 0
Branch 4575: 0
Branch 4576: 0
Branch 4577: 0
Branch 4578: 0
Branch 4579: 0
Branch 4580: 0
Branch 4581: 0
Branch 4582: 0
Branch 4583: 0
Branch 4584: 0
Branch 4585: 0
Branch 4586: 0
Branch 4587: 0
Branch 4588: 0
Branch 4589: 0
Branch 4590: 0
Branch 4591: 0
Branch 4592: 0
Branch 4593: 0
Branch 4594: 0
Branch 4595: 0
Branch 4596: 0
Branch 4597: 0
Branch 4598: 0
Branch 4599: 0
Branch 4600: 0
Branch 4601: 0
Branch 4602: 0
Branch 4603: 0
Branch 4604: 0
Branch 4605: 0
Branch 4606: 0
Branch 4607: 0
Branch 4608: 0
Branch 4609: 0
Branch 4610: 0
Branch 4611: 0
Branch 4612: 0
Branch 4613: 0
Branch 4614: 0
Branch 4615: 0
Branch 4616: 0
Branch 4617: 0
Branch 4618: 0
Branch 4619: 0
Branch 4620: 0
Branch 4621: 0
Branch 4622: 0
Branch 4623: 0
Branch 4624: 0
Branch 4625: 0
Branch 4626: 0
Branch 4627: 0
Branch 4628: 0
Branch 4629: 0
Branch 4630: 0
Branch 4631: 0
Branch 4632: 0
Branch 4633: 0
Branch 4634: 0
Branch 4635: 0
Branch 4636: 0
Branch 4637: 0
Branch 4638: 0
Branch 4639: 0
Branch 4640: 0
Branch 4641: 0
Branch 4642: 0
Branch 4643: 0
Branch 4644: 0
Branch 4645: 0
Branch 4646: 0
Branch 4647: 0
Branch 4648: 0
Branch 4649: 0
Branch 4650: 0
Branch 4651: 0
Branch 4652: 0
Branch 4653: 0
Branch 4654: 0
Branch 4655: 0
Branch 4656: 0
Branch 4657: 0
Branch 4658: 0
Branch 4659: 0
Branch 4660: 0
Branch 4661: 0
Branch 4662: 0
Branch 4663: 0
Branch 4664: 0
Branch 4665: 0
Branch 4666: 0
Branch 4667: 0
Branch 4668: 0
Branch 4669: 0
Branch 4670: 0
Branch 4671: 0
Branch 4672: 0
Branch 4673: 0
Branch 4674: 0
Branch 4675: 0
Branch 4676: 0
Branch 4677: 0
Branch 4678: 0
Branch 4679: 0
Branch 4680: 0
Branch 4681: 0
Branch 4682: 0
Branch 4683: 0
Branch 4684: 0
Branch 4685: 0
Branch 4686: 0
Branch 4687: 0
Branch 4688: 0
Branch 4689: 0
Branch 4690: 0
Branch 4691: 0
Branch 4692: 0
Branch 4693: 0
Branch 4694: 0
Branch 4695: 0
Branch 4696: 0
Branch 4697: 0
Branch 4698: 0
Branch 4699: 0
Branch 4700: 0
Branch 4701: 0
Branch 4702: 0
Branch 4703: 0
Branch 4704: 0
Branch 4705: 0
Branch 4706: 0
Branch 4707: 0
Branch 4708: 0
Branch 4709: 0
Branch 4710: 0
Branch 4711: 0
Branch 4712: 0
Branch 4713: 0
Branch 4714: 0
Branch 4715: 0
Branch 4716: 0
Branch 4717: 0
Branch 4718: 0
Branch 4719: 0
Branch 4720: 0
Branch 4721: 0
Branch 4722: 0
Branch 4723: 0
Branch 4724: 0
Branch 4725: 0
Branch 4726: 0
Branch 4727: 0
Branch 4728: 0
Branch 4729: 0
Branch 4730: 0
Branch 4731: 0
Branch 4732: 0
Branch 4733: 0
Branch 4734: 0
Branch 4735: 0
Branch 4736: 0
Branch 4737: 0
Branch 4738: 0
Branch 4739: 0
Branch 4740: 0
Branch 4741: 0
Branch 4742: 0
Branch 4743: 0
Branch 4744: 0
Branch 4745: 0
Branch 4746: 0
Branch 4747: 0
Branch 4748: 0
Branch 4749: 0
Branch 4750: 0
Branch 4751: 0
Branch 4752: 0
Branch 4753: 0
Branch 4754: 0
Branch 4755: 0
Branch 4756: 0
Branch 4757: 0
Branch 4758: 0
Branch 4759: 0
Branch 4760: 0
Branch 4761: 0
Branch 4762: 0
Branch 4763: 0
Branch 4764: 0
Branch 4765: 0
Branch 4766: 0
Branch 4767: 0
Branch 4768: 0
Branch 4769: 0
Branch 4770: 0
Branch 4771: 0
Branch 4772: 0
Branch 4773: 0
Branch 4774: 0
Branch 4775: 0
Branch 4776: 0
Branch 4777: 0
Branch 4778: 0
Branch 4779: 0
Branch 4780: 0
Branch 4781: 0
Branch 4782: 0
Branch 4783: 0
Branch 4784: 0
Branch 4785: 0
Branch 4786: 0
Branch 4787: 0
Branch 4788: 0
Branch 4789: 0
Branch 4790: 0
Branch 4791: 0
Branch 4792: 0
Branch 4793: 0
Branch 4794: 0
Branch 4795: 0
Branch 4796: 0
Branch 4797: 0
Branch 4798: 0
Branch 4799: 0
Branch 4800: 0
Branch 4801: 0
Branch 4802: 0
Branch 4803: 0
Branch 4804: 0
Branch 4805: 0
Branch 4806: 0
Branch 4807: 0
Branch 4808: 0
Branch 4809: 0
Branch 4810: 0
Branch 4811: 0
Branch 4812: 0
Branch 4813: 0
Branch 4814: 0
Branch 4815: 0
Branch 4816: 0
Branch 4817: 0
Branch 4818: 0
Branch 4819: 0
Branch 4820: 0
Branch 4821: 0
Branch 4822: 0
Branch 4823: 0
Branch 4824: 0
Branch 4825: 0
Branch 4826: 0
Branch 4827: 0
Branch 4828: 0
Branch 4829: 0
Branch 4830: 0
Branch 4831: 0
Branch 4832: 0
Branch 4833: 0
Branch 4834: 0
Branch 4835: 0
Branch 4836: 0
Branch 4837: 0
Branch 4838: 0
Branch 4839: 0
Branch 4840: 0
Branch 4841: 0
Branch 4842: 0
Branch 4843: 0
Branch 4844: 0
Branch 4845: 0
Branch 4846: 0
Branch 4847: 0
Branch 4848: 0
Branch 4849: 0
Branch 4850: 0
Branch 4851: 0
Branch 4852: 0
Branch 4853: 0
Branch 4854: 0
Branch 4855: 0
Branch 4856: 0
Branch 4857: 0
Branch 4858: 0
Branch 4859: 0
Branch 4860: 0
Branch 4861: 0
Branch 4862: 0
Branch 4863: 0
Branch 4864: 0
Branch 4865: 0
Branch 4866: 0
Branch 4867: 0
Branch 4868: 0
Branch 4869: 0
Branch 4870: 0
Branch 4871: 0
Branch 4872: 0
Branch 4873: 0
Branch 4874: 0
Branch 4875: 0
Branch 4876: 0
Branch 4877: 0
Branch 4878: 0
Branch 4879: 0
Branch 4880: 0
Branch 4881: 0
Branch 4882: 0
Branch 4883: 0
Branch 4884: 0
Branch 4885: 0
Branch 4886: 0
Branch 4887: 0
Branch 4888: 0
Branch 4889: 0
Branch 4890: 0
Branch 4891: 0
Branch 4892: 0
Branch 4893: 0
Branch 4894: 0
Branch 4895: 0
Branch 4896: 0
Branch 4897: 0
Branch 4898: 0
Branch 4899: 0
Branch 4900: 0
Branch 4901: 0
Branch 4902: 0
Branch 4903: 0
Branch 4904: 0
Branch 4905: 0
Branch 4906: 0
Branch 4907: 0
Branch 4908: 0
Branch 4909: 0
Branch 4910: 0
Branch 4911: 0
Branch 4912: 0
Branch 4913: 0
Branch 4914: 0
Branch 4915: 0
Branch 4916: 0
Branch 4917: 0
Branch 4918: 0
Branch 4919: 0
Branch 4920: 0
Branch 4921: 0
Branch 4922: 0
Branch 4923: 0
Branch 4924: 0
Branch 4925: 0
Branch 4926: 0
Branch 4927: 0
Branch 4928: 0
Branch 4929: 0
Branch 4930: 0
Branch 4931: 0
Branch 4932: 0
Branch 4933: 0
Branch 4934: 0
Branch 4935: 0
Branch 4936: 0
Branch 4937: 0
Branch 4938: 0
Branch 4939: 0
Branch 4940: 0
Branch 4941: 0
Branch 4942: 0
Branch 4943: 0
Branch 4944: 0
Branch 4945: 0
Branch 4946: 0
Branch 4947: 0
Branch 4948: 0
Branch 4949: 0
Branch 4950: 0
Branch 4951: 0
Branch 4952: 0
Branch 4953: 0
Branch 4954: 0
Branch 4955: 0
Branch 4956: 0
Branch 4957: 0
Branch 4958: 0
Branch 4959: 0
Branch 4960: 0
Branch 4961: 0
Branch 4962: 0
Branch 4963: 0
Branch 4964: 0
Branch 4965: 0
Branch 4966: 0
Branch 4967: 0
Branch 4968: 0
Branch 4969: 0
Branch 4970: 0
Branch 4971: 0
Branch 4972: 0
Branch 4973: 0
Branch 4974: 0
Branch 4975: 0
Branch 4976: 0
Branch 4977: 0
Branch 4978: 0
Branch 4979: 0
Branch 4980: 0
Branch 4981: 0
Branch 4982: 0
Branch 4983: 0
Branch 4984: 0
Branch 4985: 0
Branch 4986: 0
Branch 4987: 0
Branch 4988: 0
Branch 4989: 0
Branch 4990: 0
Branch 4991: 0
Branch 4992: 0
Branch 4993: 0
Branch 4994: 0
Branch 4995: 0
Branch 4996: 0
Branch 4997: 0
Branch 4998: 0
Branch 4999: 0
Branch 5000: 0
Branch 5001: 0
Branch 5002: 0
Branch 5003: 0
Branch 5004: 0
Branch 5005: 0
Branch 5006: 0
Branch 5007: 0
Branch 5008: 0
Branch 5009: 0
Branch 5010: 0
Branch 5011: 0
Branch 5012: 0
Branch 5013: 0
Branch 5014: 0
Branch 5015: 0
Branch 5016: 0
Branch 5017: 0
Branch 5018: 0
Branch 5019: 0
Branch 5020: 0
Branch 5021: 0
Branch 5022: 0
Branch 5023: 0
Branch 5024: 0
Branch 5025: 0
Branch 5026: 0
Branch 5027: 0
Branch 5028: 0
Branch 5029: 0
Branch 5030: 0
Branch 5031: 0
Branch 5032: 0
Branch 5033: 0
Branch 5034: 0
Branch 5035: 0
Branch 5036: 0
Branch 5037: 0
Branch 5038: 0
Branch 5039: 0
Branch 5040: 0
Branch 5041: 0
Branch 5042: 0
Branch 5043: 0
Branch 5044: 0
Branch 5045: 0
Branch 5046: 0
Branch 5047: 0
Branch 5048: 0
Branch 5049: 0
Branch 5050: 0
Branch 5051: 0
Branch 5052: 0
Branch 5053: 0
Branch 5054: 0
Branch 5055: 0
Branch 5056: 0
Branch 5057: 0
Branch 5058: 0
Branch 5059: 0
Branch 5060: 0
Branch 5061: 0
Branch 5062: 0
Branch 5063: 0
Branch 5064: 0
Branch 5065: 0
Branch 5066: 0
Branch 5067: 0
Branch 5068: 0
Branch 5069: 0
Branch 5070: 0
Branch 5071: 0
Branch 5072: 0
Branch 5073: 0
Branch 5074: 0
Branch 5075: 0
Branch 5076: 0
Branch 5077: 0
Branch 5078: 0
Branch 5079: 0
Branch 5080: 0
Branch 5081: 0
Branch 5082: 0
Branch 5083: 0
Branch 5084: 0
Branch 5085: 0
Branch 5086: 0
Branch 5087: 0
Branch 5088: 0
Branch 5089: 0
Branch 5090: 0
Branch 5091: 0
Branch 5092: 0
Branch 5093: 0
Branch 5094: 0
Branch 5095: 0
Branch 5096: 0
Branch 5097: 0
Branch 5098: 0
Branch 5099: 0
Branch 5100: 0
Branch 5101: 0
Branch 5102: 0
Branch 5103: 0
Branch 5104: 0
Branch 5105: 0
Branch 5106: 0
Branch 5107: 0
Branch 5108: 0
Branch 5109: 0
Branch 5110: 0
Branch 5111: 0
Branch 5112: 0
Branch 5113: 0
Branch 5114: 0
Branch 5115: 0
Branch 5116: 0
Branch 5117: 0
Branch 5118: 0
Branch 5119: 0
Branch 5120: 0
Branch 5121: 0
Branch 5122: 0
Branch 5123: 0
Branch 5124: 0
Branch 5125: 0
Branch 5126: 0
Branch 5127: 0
Branch 5128: 0
Branch 5129: 0
Branch 5130: 0
Branch 5131: 0
Branch 5132: 0
Branch 5133: 0
Branch 5134: 0
Branch 5135: 0
Branch 5136: 0
Branch 5137: 0
Branch 5138: 0
Branch 5139: 0
Branch 5140: 0
Branch 5141: 0
Branch 5142: 0
Branch 5143: 0
Branch 5144: 0
Branch 5145: 0
Branch 5146: 0
Branch 5147: 0
Branch 5148: 0
Branch 5149: 0
Branch 5150: 0
Branch 5151: 0
Branch 5152: 0
Branch 5153: 0
Branch 5154: 0
Branch 5155: 0
Branch 5156: 0
Branch 5157: 0
Branch 5158: 0
Branch 5159: 0
Branch 5160: 0
Branch 5161: 0
Branch 5162: 0
Branch 5163: 0
Branch 5164: 0
Branch 5165: 0
Branch 5166: 0
Branch 5167: 0
Branch 5168: 0
Branch 5169: 0
Branch 5170: 0
Branch 5171: 0
Branch 5172: 0
Branch 5173: 0
Branch 5174: 0
Branch 5175: 0
Branch 5176: 0
Branch 5177: 0
Branch 5178: 0
Branch 5179: 0
Branch 5180: 0
Branch 5181: 0
Branch 5182: 0
Branch 5183: 0
Branch 5184: 0
Branch 5185: 0
Branch 5186: 0
Branch 5187: 0
Branch 5188: 0
Branch 5189: 0
Branch 5190: 0
Branch 5191: 0
Branch 5192: 0
Branch 5193: 0
Branch 5194: 0
Branch 5195: 0
Branch 5196: 0
Branch 5197: 0
Branch 5198: 0
Branch 5199: 0
Branch 5200: 0
Branch 5201: 0
Branch 5202: 0
Branch 5203: 0
Branch 5204: 0
Branch 5205: 0
Branch 5206: 0
Branch 5207: 0
Branch 5208: 0
Branch 5209: 0
Branch 5210: 0
Branch 5211: 0
Branch 5212: 0
Branch 5213: 0
Branch 5214: 0
Branch 5215: 0
Branch 5216: 0
Branch 5217: 0
Branch 5218: 0
Branch 5219: 0
Branch 5220: 0
Branch 5221: 0
Branch 5222: 0
Branch 5223: 0
Branch 5224: 0
Branch 5225: 0
Branch 5226: 0
Branch 5227: 0
Branch 5228: 0
Branch 5229: 0
Branch 5230: 0
Branch 5231: 0
Branch 5232: 0
Branch 5233: 0
Branch 5234: 0
Branch 5235: 0
Branch 5236: 0
Branch 5237: 0
Branch 5238: 0
Branch 5239: 0
Branch 5240: 0
Branch 5241: 0
Branch 5242: 0
Branch 5243: 0
Branch 5244: 0
Branch 5245: 0
Branch 5246: 0
Branch 5247: 0
Branch 5248: 0
Branch 5249: 0
Branch 5250: 0
Branch 5251: 0
Branch 5252: 0
Branch 5253: 0
Branch 5254: 0
Branch 5255: 0
Branch 5256: 0
Branch 5257: 0
Branch 5258: 0
Branch 5259: 0
Branch 5260: 0
Branch 5261: 0
Branch 5262: 0
Branch 5263: 0
Branch 5264: 0
Branch 5265: 0
Branch 5266: 0
Branch 5267: 0
Branch 5268: 0
Branch 5269: 0
Branch 5270: 0
Branch 5271: 0
Branch 5272: 0
Branch 5273: 0
Branch 5274: 0
Branch 5275: 0
Branch 5276: 0
Branch 5277: 0
Branch 5278: 0
Branch 5279: 0
Branch 5280: 0
Branch 5281: 0
Branch 5282: 0
Branch 5283: 0
Branch 5284: 0
Branch 5285: 0
Branch 5286: 0
Branch 5287: 0
Branch 5288: 0
Branch 5289: 0
Branch 5290: 0
Branch 5291: 0
Branch 5292: 0
Branch 5293: 0
Branch 5294: 0
Branch 5295: 0
Branch 5296: 0
Branch 5297: 0
Branch 5298: 0
Branch 5299: 0
Branch 5300: 0
Branch 5301: 0
Branch 5302: 0
Branch 5303: 0
Branch 5304: 0
Branch 5305: 0
Branch 5306: 0
Branch 5307: 0
Branch 5308: 0
Branch 5309: 0
Branch 5310: 0
Branch 5311: 0
Branch 5312: 0
Branch 5313: 0
Branch 5314: 0
Branch 5315: 0
Branch 5316: 0
Branch 5317: 0
Branch 5318: 0
Branch 5319: 0
Branch 5320: 0
Branch 5321: 0
Branch 5322: 0
Branch 5323: 0
Branch 5324: 0
Branch 5325: 0
Branch 5326: 0
Branch 5327: 0
Branch 5328: 0
Branch 5329: 0
Branch 5330: 0
Branch 5331: 0
Branch 5332: 0
Branch 5333: 0
Branch 5334: 0
Branch 5335: 0
Branch 5336: 0
Branch 5337: 0
Branch 5338: 0
Branch 5339: 0
Branch 5340: 0
Branch 5341: 0
Branch 5342: 0
Branch 5343: 0
Branch 5344: 0
Branch 5345: 0
Branch 5346: 0
Branch 5347: 0
Branch 5348: 0
Branch 5349: 0
Branch 5350: 0
Branch 5351: 0
Branch 5352: 0
Branch 5353: 0
Branch 5354: 0
Branch 5355: 0
Branch 5356: 0
Branch 5357: 0
Branch 5358: 0
Branch 5359: 0
Branch 5360: 0
Branch 5361: 0
Branch 5362: 0
Branch 5363: 0
Branch 5364: 0
Branch 5365: 0
Branch 5366: 0
Branch 5367: 0
Branch 5368: 0
Branch 5369: 0
Branch 5370: 0
Branch 5371: 0
Branch 5372: 0
Branch 5373: 0
Branch 5374: 0
Branch 5375: 0
Branch 5376: 0
Branch 5377: 0
Branch 5378: 0
Branch 5379: 0
Branch 5380: 0
Branch 5381: 0
Branch 5382: 0
Branch 5383: 0
Branch 5384: 0
Branch 5385: 0
Branch 5386: 0
Branch 5387: 0
Branch 5388: 0
Branch 5389: 0
Branch 5390: 0
Branch 5391: 0
Branch 5392: 0
Branch 5393: 0
Branch 5394: 0
Branch 5395: 0
Branch 5396: 0
Branch 5397: 0
Branch 5398: 0
Branch 5399: 0
Branch 5400: 0
Branch 5401: 0
Branch 5402: 0
Branch 5403: 0
Branch 5404: 0
Branch 5405: 0
Branch 5406: 0
Branch 5407: 0
Branch 5408: 0
Branch 5409: 0
Branch 5410: 0
Branch 5411: 0
Branch 5412: 0
Branch 5413: 0
Branch 5414: 0
Branch 5415: 0
Branch 5416: 0
Branch 5417: 0
Branch 5418: 0
Branch 5419: 0
Branch 5420: 0
Branch 5421: 0
Branch 5422: 0
Branch 5423: 0
Branch 5424: 0
Branch 5425: 0
Branch 5426: 0
Branch 5427: 0
Branch 5428: 0
Branch 5429: 0
Branch 5430: 0
Branch 5431: 0
Branch 5432: 0
Branch 5433: 0
Branch 5434: 0
Branch 5435: 0
Branch 5436: 0
Branch 5437: 0
Branch 5438: 0
Branch 5439: 0
Branch 5440: 0
Branch 5441: 0
Branch 5442: 0
Branch 5443: 0
Branch 5444: 0
Branch 5445: 0
Branch 5446: 0
Branch 5447: 0
Branch 5448: 0
Branch 5449: 0
Branch 5450: 0
Branch 5451: 0
Branch 5452: 0
Branch 5453: 0
Branch 5454: 0
Branch 5455: 0
Branch 5456: 0
Branch 5457: 0
Branch 5458: 0
Branch 5459: 0
Branch 5460: 0
Branch 5461: 0
Branch 5462: 0
Branch 5463: 0
Branch 5464: 0
Branch 5465: 0
Branch 5466: 0
Branch 5467: 0
Branch 5468: 0
Branch 5469: 0
Branch 5470: 0
Branch 5471: 0
Branch 5472: 0
Branch 5473: 0
Branch 5474: 0
Branch 5475: 0
Branch 5476: 0
Branch 5477: 0
Branch 5478: 0
Branch 5479: 0
Branch 5480: 0
Branch 5481: 0
Branch 5482: 0
Branch 5483: 0
Branch 5484: 0
Branch 5485: 0
Branch 5486: 0
Branch 5487: 0
Branch 5488: 0
Branch 5489: 0
Branch 5490: 0
Branch 5491: 0
Branch 5492: 0
Branch 5493: 0
Branch 5494: 0
Branch 5495: 0
Branch 5496: 0
Branch 5497: 0
Branch 5498: 0
Branch 5499: 0
Branch 5500: 0
Branch 5501: 0
Branch 5502: 0
Branch 5503: 0
Branch 5504: 0
Branch 5505: 0
Branch 5506: 0
Branch 5507: 0
Branch 5508: 0
Branch 5509: 0
Branch 5510: 0
Branch 5511: 0
Branch 5512: 0
Branch 5513: 0
Branch 5514: 0
Branch 5515: 0
Branch 5516: 0
Branch 5517: 0
Branch 5518: 0
Branch 5519: 0
Branch 5520: 0
Branch 5521: 0
Branch 5522: 0
Branch 5523: 0
Branch 5524: 0
Branch 5525: 0
Branch 5526: 0
Branch 5527: 0
Branch 5528: 0
Branch 5529: 0
Branch 5530: 0
Branch 5531: 0
Branch 5532: 0
Branch 5533: 0
Branch 5534: 0
Branch 5535: 0
Branch 5536: 0
Branch 5537: 0
Branch 5538: 0
Branch 5539: 0
Branch 5540: 0
Branch 5541: 0
Branch 5542: 0
Branch 5543: 0
Branch 5544: 0
Branch 5545: 0
Branch 5546: 0
Branch 5547: 0
Branch 5548: 0
Branch 5549: 0
Branch 5550: 0
Branch 5551: 0
Branch 5552: 0
Branch 5553: 0
Branch 5554: 0
Branch 5555: 0
Branch 5556: 0
Branch 5557: 0
Branch 5558: 0
Branch 5559: 0
Branch 5560: 0
Branch 5561: 0
Branch 5562: 0
Branch 5563: 0
Branch 5564: 0
Branch 5565: 0
Branch 5566: 0
Branch 5567: 0
Branch 5568: 0
Branch 5569: 0
Branch 5570: 0
Branch 5571: 0
Branch 5572: 0
Branch 5573: 0
Branch 5574: 0
Branch 5575: 0
Branch 5576: 0
Branch 5577: 0
Branch 5578: 0
Branch 5579: 0
Branch 5580: 0
Branch 5581: 0
Branch 5582: 0
Branch 5583: 0
Branch 5584: 0
Branch 5585: 0
Branch 5586: 0
Branch 5587: 0
Branch 5588: 0
Branch 5589: 0
Branch 5590: 0
Branch 5591: 0
Branch 5592: 0
Branch 5593: 0
Branch 5594: 0
Branch 5595: 0
Branch 5596: 0
Branch 5597: 0
Branch 5598: 0
Branch 5599: 0
Branch 5600: 0
Branch 5601: 0
Branch 5602: 0
Branch 5603: 0
Branch 5604: 0
Branch 5605: 0
Branch 5606: 0
Branch 5607: 0
Branch 5608: 0
Branch 5609: 0
Branch 5610: 0
Branch 5611: 0
Branch 5612: 0
Branch 5613: 0
Branch 5614: 0
Branch 5615: 0
Branch 5616: 0
Branch 5617: 0
Branch 5618: 0
Branch 5619: 0
Branch 5620: 0
Branch 5621: 0
Branch 5622: 0
Branch 5623: 0
Branch 5624: 0
Branch 5625: 0
Branch 5626: 0
Branch 5627: 0
Branch 5628: 0
Branch 5629: 0
Branch 5630: 0
Branch 5631: 0
Branch 5632: 0
Branch 5633: 0
Branch 5634: 0
Branch 5635: 0
Branch 5636: 0
Branch 5637: 0
Branch 5638: 0
Branch 5639: 0
Branch 5640: 0
Branch 5641: 0
Branch 5642: 0
Branch 5643: 0
Branch 5644: 0
Branch 5645: 0
Branch 5646: 0
Branch 5647: 0
Branch 5648: 0
Branch 5649: 0
Branch 5650: 0
Branch 5651: 0
Branch 5652: 0
Branch 5653: 0
Branch 5654: 0
Branch 5655: 0
Branch 5656: 0
Branch 5657: 0
Branch 5658: 0
Branch 5659: 0
Branch 5660: 0
Branch 5661: 0
Branch 5662: 0
Branch 5663: 0
Branch 5664: 0
Branch 5665: 0
Branch 5666: 0
Branch 5667: 0
Branch 5668: 0
Branch 5669: 0
Branch 5670: 0
Branch 5671: 0
Branch 5672: 0
Branch 5673: 0
Branch 5674: 0
Branch 5675: 0
Branch 5676: 0
Branch 5677: 0
Branch 5678: 0
Branch 5679: 0
Branch 5680: 0
Branch 5681: 0
Branch 5682: 0
Branch 5683: 0
Branch 5684: 0
Branch 5685: 0
Branch 5686: 0
Branch 5687: 0
Branch 5688: 0
Branch 5689: 0
Branch 5690: 0
Branch 5691: 0
Branch 5692: 0
Branch 5693: 0
Branch 5694: 0
Branch 5695: 0
Branch 5696: 0
Branch 5697: 0
Branch 5698: 0
Branch 5699: 0
Branch 5700: 0
Branch 5701: 0
Branch 5702: 0
Branch 5703: 0
Branch 5704: 0
Branch 5705: 0
Branch 5706: 0
Branch 5707: 0
Branch 5708: 0
Branch 5709: 0
Branch 5710: 0
Branch 5711: 0
Branch 5712: 0
Branch 5713: 0
Branch 5714: 0
Branch 5715: 0
Branch 5716: 0
Branch 5717: 0
Branch 5718: 0
Branch 5719: 0
Branch 5720: 0
Branch 5721: 0
Branch 5722: 0
Branch 5723: 0
Branch 5724: 0
Branch 5725: 0
Branch 5726: 0
Branch 5727: 0
Branch 5728: 0
Branch 5729: 0
Branch 5730: 0
Branch 5731: 0
Branch 5732: 0
Branch 5733: 0
Branch 5734: 0
Branch 5735: 0
Branch 5736: 0
Branch 5737: 0
Branch 5738: 0
Branch 5739: 0
Branch 5740: 0
Branch 5741: 0
Branch 5742: 0
Branch 5743: 0
Branch 5744: 0
Branch 5745: 0
Branch 5746: 0
Branch 5747: 0
Branch 5748: 0
Branch 5749: 0
Branch 5750: 0
Branch 5751: 0
Branch 5752: 0
Branch 5753: 0
Branch 5754: 0
Branch 5755: 0
Branch 5756: 0
Branch 5757: 0
Branch 5758: 0
Branch 5759: 0
Branch 5760: 0
Branch 5761: 0
Branch 5762: 0
Branch 5763: 0
Branch 5764: 0
Branch 5765: 0
Branch 5766: 0
Branch 5767: 0
Branch 5768: 0
Branch 5769: 0
Branch 5770: 0
Branch 5771: 0
Branch 5772: 0
Branch 5773: 0
Branch 5774: 0
Branch 5775: 0
Branch 5776: 0
Branch 5777: 0
Branch 5778: 0
Branch 5779: 0
Branch 5780: 0
Branch 5781: 0
Branch 5782: 0
Branch 5783: 0
Branch 5784: 0
Branch 5785: 0
Branch 5786: 0
Branch 5787: 0
Branch 5788: 0
Branch 5789: 0
Branch 5790: 0
Branch 5791: 0
Branch 5792: 0
Branch 5793: 0
Branch 5794: 0
Branch 5795: 0
Branch 5796: 0
Branch 5797: 0
Branch 5798: 0
Branch 5799: 0
Branch 5800: 0
Branch 5801: 0
Branch 5802: 0
Branch 5803: 0
Branch 5804: 0
Branch 5805: 0
Branch 5806: 0
Branch 5807: 0
Branch 5808: 0
Branch 5809: 0
Branch 5810: 0
Branch 5811: 0
Branch 5812: 0
Branch 5813: 0
Branch 5814: 0
Branch 5815: 0
Branch 5816: 0
Branch 5817: 0
Branch 5818: 0
Branch 5819: 0
Branch 5820: 0
Branch 5821: 0
Branch 5822: 0
Branch 5823: 0
Branch 5824: 0
Branch 5825: 0
Branch 5826: 0
Branch 5827: 0
Branch 5828: 0
Branch 5829: 0
Branch 5830: 0
Branch 5831: 0
Branch 5832: 0
Branch 5833: 0
Branch 5834: 0
Branch 5835: 0
Branch 5836: 0
Branch 5837: 0
Branch 5838: 0
Branch 5839: 0
Branch 5840: 0
Branch 5841: 0
Branch 5842: 0
Branch 5843: 0
Branch 5844: 0
Branch 5845: 0
Branch 5846: 0
Branch 5847: 0
Branch 5848: 0
Branch 5849: 0
Branch 5850: 0
Branch 5851: 0
Branch 5852: 0
Branch 5853: 0
Branch 5854: 0
Branch 5855: 0
Branch 5856: 0
Branch 5857: 0
Branch 5858: 0
Branch 5859: 0
Branch 5860: 0
Branch 5861: 0
Branch 5862: 0
Branch 5863: 0
Branch 5864: 0
Branch 5865: 0
Branch 5866: 0
Branch 5867: 0
Branch 5868: 0
Branch 5869: 0
Branch 5870: 0
Branch 5871: 0
Branch 5872: 0
Branch 5873: 0
Branch 5874: 0
Branch 5875: 0
Branch 5876: 0
Branch 5877: 0
Branch 5878: 0
Branch 5879: 0
Branch 5880: 0
Branch 5881: 0
Branch 5882: 0
Branch 5883: 0
Branch 5884: 0
Branch 5885: 0
Branch 5886: 0
Branch 5887: 0
Branch 5888: 0
Branch 5889: 0
Branch 5890: 0
Branch 5891: 0
Branch 5892: 0
Branch 5893: 0
Branch 5894: 0
Branch 5895: 0
Branch 5896: 0
Branch 5897: 0
Branch 5898: 0
Branch 5899: 0
Branch 5900: 0
Branch 5901: 0
Branch 5902: 0
Branch 5903: 0
Branch 5904: 0
Branch 5905: 0
Branch 5906: 0
Branch 5907: 0
Branch 5908: 0
Branch 5909: 0
Branch 5910: 0
Branch 5911: 0
Branch 5912: 0
Branch 5913: 0
Branch 5914: 0
Branch 5915: 0
Branch 5916: 0
Branch 5917: 0
Branch 5918: 0
Branch 5919: 0
Branch 5920: 0
Branch 5921: 0
Branch 5922: 0
Branch 5923: 0
Branch 5924: 0
Branch 5925: 0
Branch 5926: 0
Branch 5927: 0
Branch 5928: 0
Branch 5929: 0
Branch 5930: 0
Branch 5931: 0
Branch 5932: 0
Branch 5933: 0
Branch 5934: 0
Branch 5935: 0
Branch 5936: 0
Branch 5937: 0
Branch 5938: 0
Branch 5939: 0
Branch 5940: 0
Branch 5941: 0
Branch 5942: 0
Branch 5943: 0
Branch 5944: 0
Branch 5945: 0
Branch 5946: 0
Branch 5947: 0
Branch 5948: 0
Branch 5949: 0
Branch 5950: 0
Branch 5951: 0
Branch 5952: 0
Branch 5953: 0
Branch 5954: 0
Branch 5955: 0
Branch 5956: 0
Branch 5957: 0
Branch 5958: 0
Branch 5959: 0
Branch 5960: 0
Branch 5961: 0
Branch 5962: 0
Branch 5963: 0
Branch 5964: 0
Branch 5965: 0
Branch 5966: 0
Branch 5967: 0
Branch 5968: 0
Branch 5969: 0
Branch 5970: 0
Branch 5971: 0
Branch 5972: 0
Branch 5973: 0
Branch 5974: 0
Branch 5975: 0
Branch 5976: 0
Branch 5977: 0
Branch 5978: 0
Branch 5979: 0
Branch 5980: 0
Branch 5981: 0
Branch 5982: 0
Branch 5983: 0
Branch 5984: 0
Branch 5985: 0
Branch 5986: 0
Branch 5987: 0
Branch 5988: 0
Branch 5989: 0
Branch 5990: 0
Branch 5991: 0
Branch 5992: 0
Branch 5993: 0
Branch 5994: 0
Branch 5995: 0
Branch 5996: 0
Branch 5997: 0
Branch 5998: 0
Branch 5999: 0
Branch 6000: 0
Branch 6001: 0
Branch 6002: 0
Branch 6003: 0
Branch 6004: 0
Branch 6005: 0
Branch 6006: 0
Branch 6007: 0
Branch 6008: 0
Branch 6009: 0
Branch 6010: 0
Branch 6011: 0
Branch 6012: 0
Branch 6013: 0
Branch 6014: 0
Branch 6015: 0
Branch 6016: 0
Branch 6017: 0
Branch 6018: 0
Branch 6019: 0
Branch 6020: 0
Branch 6021: 0
Branch 6022: 0
Branch 6023: 0
Branch 6024: 0
Branch 6025: 0
Branch 6026: 0
Branch 6027: 0
Branch 6028: 0
Branch 6029: 0
Branch 6030: 0
Branch 6031: 0
Branch 6032: 0
Branch 6033: 0
Branch 6034: 0
Branch 6035: 0
Branch 6036: 0
Branch 6037: 0
Branch 6038: 0
Branch 6039: 0
Branch 6040: 0
Branch 6041: 0
Branch 6042: 0
Branch 6043: 0
Branch 6044: 0
Branch 6045: 0
Branch 6046: 0
Branch 6047: 0
Branch 6048: 0
Branch 6049: 0
Branch 6050: 0
Branch 6051: 0
Branch 6052: 0
Branch 6053: 0
Branch 6054: 0
Branch 6055: 0
Branch 6056: 0
Branch 6057: 0
Branch 6058: 0
Branch 6059: 0
Branch 6060: 0
Branch 6061: 0
Branch 6062: 0
Branch 6063: 0
Branch 6064: 0
Branch 6065: 0
Branch 6066: 0
Branch 6067: 0
Branch 6068: 0
Branch 6069: 0
Branch 6070: 0
Branch 6071: 0
Branch 6072: 0
Branch 6073: 0
Branch 6074: 0
Branch 6075: 0
Branch 6076: 0
Branch 6077: 0
Branch 6078: 0
Branch 6079: 0
Branch 6080: 0
Branch 6081: 0
Branch 6082: 0
Branch 6083: 0
Branch 6084: 0
Branch 6085: 0
Branch 6086: 0
Branch 6087: 0
Branch 6088: 0
Branch 6089: 0
Branch 6090: 0
Branch 6091: 0
Branch 6092: 0
Branch 6093: 0
Branch 6094: 0
Branch 6095: 0
Branch 6096: 0
Branch 6097: 0
Branch 6098: 0
Branch 6099: 0
Branch 6100: 0
Branch 6101: 0
Branch 6102: 0
Branch 6103: 0
Branch 6104: 0
Branch 6105: 0
Branch 6106: 0
Branch 6107: 0
Branch 6108: 0
Branch 6109: 0
Branch 6110: 0
Branch 6111: 0
Branch 6112: 0
Branch 6113: 0
Branch 6114: 0
Branch 6115: 0
Branch 6116: 0
Branch 6117: 0
Branch 6118: 0
Branch 6119: 0
Branch 6120: 0
Branch 6121: 0
Branch 6122: 0
Branch 6123: 0
Branch 6124: 0
Branch 6125: 0
Branch 6126: 0
Branch 6127: 0
Branch 6128: 0
Branch 6129: 0
Branch 6130: 0
Branch 6131: 0
Branch 6132: 0
Branch 6133: 0
Branch 6134: 0
Branch 6135: 0
Branch 6136: 0
Branch 6137: 0
Branch 6138: 0
Branch 6139: 0
Branch 6140: 0
Branch 6141: 0
Branch 6142: 0
Branch 6143: 0
Branch 6144: 0
Branch 6145: 0
Branch 6146: 0
Branch 6147: 0
Branch 6148: 0
Branch 6149: 0
Branch 6150: 0
Branch 6151: 0
Branch 6152: 0
Branch 6153: 0
Branch 6154: 0
Branch 6155: 0
Branch 6156: 0
Branch 6157: 0
Branch 6158: 0
Branch 6159: 0
Branch 6160: 0
Branch 6161: 0
Branch 6162: 0
Branch 6163: 0
Branch 6164: 0
Branch 6165: 0
Branch 6166: 0
Branch 6167: 0
Branch 6168: 0
Branch 6169: 0
Branch 6170: 0
Branch 6171: 0
Branch 6172: 0
Branch 6173: 0
Branch 6174: 0
Branch 6175: 0
Branch 6176: 0
Branch 6177: 0
Branch 6178: 0
Branch 6179: 0
Branch 6180: 0
Branch 6181: 0
Branch 6182: 0
Branch 6183: 0
Branch 6184: 0
Branch 6185: 0
Branch 6186: 0
Branch 6187: 0
Branch 6188: 0
Branch 6189: 0
Branch 6190: 0
Branch 6191: 0
Branch 6192: 0
Branch 6193: 0
Branch 6194: 0
Branch 6195: 0
Branch 6196: 0
Branch 6197: 0
Branch 6198: 0
Branch 6199: 0
Branch 6200: 0
Branch 6201: 0
Branch 6202: 0
Branch 6203: 0
Branch 6204: 0
Branch 6205: 0
Branch 6206: 0
Branch 6207: 0
Branch 6208: 0
Branch 6209: 0
Branch 6210: 0
Branch 6211: 0
Branch 6212: 0
Branch 6213: 0
Branch 6214: 0
Branch 6215: 0
Branch 6216: 0
Branch 6217: 0
Branch 6218: 0
Branch 6219: 0
Branch 6220: 0
Branch 6221: 0
Branch 6222: 0
Branch 6223: 0
Branch 6224: 0
Branch 6225: 0
Branch 6226: 0
Branch 6227: 0
Branch 6228: 0
Branch 6229: 0
Branch 6230: 0
Branch 6231: 0
Branch 6232: 0
Branch 6233: 0
Branch 6234: 0
Branch 6235: 0
Branch 6236: 0
Branch 6237: 0
Branch 6238: 0
Branch 6239: 0
Branch 6240: 0
Branch 6241: 0
Branch 6242: 0
Branch 6243: 0
Branch 6244: 0
Branch 6245: 0
Branch 6246: 0
Branch 6247: 0
Branch 6248: 0
Branch 6249: 0
Branch 6250: 0
Branch 6251: 0
Branch 6252: 0
Branch 6253: 0
Branch 6254: 0
Branch 6255: 0
Branch 6256: 0
Branch 6257: 0
Branch 6258: 0
Branch 6259: 0
Branch 6260: 0
Branch 6261: 0
Branch 6262: 0
Branch 6263: 0
Branch 6264: 0
Branch 6265: 0
Branch 6266: 0
Branch 6267: 0
Branch 6268: 0
Branch 6269: 0
Branch 6270: 0
Branch 6271: 0
Branch 6272: 0
Branch 6273: 0
Branch 6274: 0
Branch 6275: 0
Branch 6276: 0
Branch 6277: 0
Branch 6278: 0
Branch 6279: 0
Branch 6280: 0
Branch 6281: 0
Branch 6282: 0
Branch 6283: 0
Branch 6284: 0
Branch 6285: 0
Branch 6286: 0
Branch 6287: 0
Branch 6288: 0
Branch 6289: 0
Branch 6290: 0
Branch 6291: 0
Branch 6292: 0
Branch 6293: 0
Branch 6294: 0
Branch 6295: 0
Branch 6296: 0
Branch 6297: 0
Branch 6298: 0
Branch 6299: 0
Branch 6300: 0
Branch 6301: 0
Branch 6302: 0
Branch 6303: 0
Branch 6304: 0
Branch 6305: 0
Branch 6306: 0
Branch 6307: 0
Branch 6308: 0
Branch 6309: 0
Branch 6310: 0
Branch 6311: 0
Branch 6312: 0
Branch 6313: 0
Branch 6314: 0
Branch 6315: 0
Branch 6316: 0
Branch 6317: 0
Branch 6318: 0
Branch 6319: 0
Branch 6320: 0
Branch 6321: 0
Branch 6322: 0
Branch 6323: 0
Branch 6324: 0
Branch 6325: 0
Branch 6326: 0
Branch 6327: 0
Branch 6328: 0
Branch 6329: 0
Branch 6330: 0
Branch 6331: 0
Branch 6332: 0
Branch 6333: 0
Branch 6334: 0
Branch 6335: 0
Branch 6336: 0
Branch 6337: 0
Branch 6338: 0
Branch 6339: 0
Branch 6340: 0
Branch 6341: 0
Branch 6342: 0
Branch 6343: 0
Branch 6344: 0
Branch 6345: 0
Branch 6346: 0
Branch 6347: 0
Branch 6348: 0
Branch 6349: 0
Branch 6350: 0
Branch 6351: 0
Branch 6352: 0
Branch 6353: 0
Branch 6354: 0
Branch 6355: 0
Branch 6356: 0
Branch 6357: 0
Branch 6358: 0
Branch 6359: 0
Branch 6360: 0
Branch 6361: 0
Branch 6362: 0
Branch 6363: 0
Branch 6364: 0
Branch 6365: 0
Branch 6366: 0
Branch 6367: 0
Branch 6368: 0
Branch 6369: 0
Branch 6370: 0
Branch 6371: 0
Branch 6372: 0
Branch 6373: 0
Branch 6374: 0
Branch 6375: 0
Branch 6376: 0
Branch 6377: 0
Branch 6378: 0
Branch 6379: 0
Branch 6380: 0
Branch 6381: 0
Branch 6382: 0
Branch 6383: 0
Branch 6384: 0
Branch 6385: 0
Branch 6386: 0
Branch 6387: 0
Branch 6388: 0
Branch 6389: 0
Branch 6390: 0
Branch 6391: 0
Branch 6392: 0
Branch 6393: 0
Branch 6394: 0
Branch 6395: 0
Branch 6396: 0
Branch 6397: 0
Branch 6398: 0
Branch 6399: 0
Branch 6400: 0
Branch 6401: 0
Branch 6402: 0
Branch 6403: 0
Branch 6404: 0
Branch 6405: 0
Branch 6406: 0
Branch 6407: 0
Branch 6408: 0
Branch 6409: 0
Branch 6410: 0
Branch 6411: 0
Branch 6412: 0
Branch 6413: 0
Branch 6414: 0
Branch 6415: 0
Branch 6416: 0
Branch 6417: 0
Branch 6418: 0
Branch 6419: 0
Branch 6420: 0
Branch 6421: 0
Branch 6422: 0
Branch 6423: 0
Branch 6424: 0
Branch 6425: 0
Branch 6426: 0
Branch 6427: 0
Branch 6428: 0
Branch 6429: 0
Branch 6430: 0
Branch 6431: 0
Branch 6432: 0
Branch 6433: 0
Branch 6434: 0
Branch 6435: 0
Branch 6436: 0
Branch 6437: 0
Branch 6438: 0
Branch 6439: 0
Branch 6440: 0
Branch 6441: 0
Branch 6442: 0
Branch 6443: 0
Branch 6444: 0
Branch 6445: 0
Branch 6446: 0
Branch 6447: 0
Branch 6448: 0
Branch 6449: 0
Branch 6450: 0
Branch 6451: 0
Branch 6452: 0
Branch 6453: 0
Branch 6454: 0
Branch 6455: 0
Branch 6456: 0
Branch 6457: 0
Branch 6458: 0
Branch 6459: 0
Branch 6460: 0
Branch 6461: 0
Branch 6462: 0
Branch 6463: 0
Branch 6464: 0
Branch 6465: 0
Branch 6466: 0
Branch 6467: 0
Branch 6468: 0
Branch 6469: 0
Branch 6470: 0
Branch 6471: 0
Branch 6472: 0
Branch 6473: 0
Branch 6474: 0
Branch 6475: 0
Branch 6476: 0
Branch 6477: 0
Branch 6478: 0
Branch 6479: 0
Branch 6480: 0
Branch 6481: 0
Branch 6482: 0
Branch 6483: 0
Branch 6484: 0
Branch 6485: 0
Branch 6486: 0
Branch 6487: 0
Branch 6488: 0
Branch 6489: 0
Branch 6490: 0
Branch 6491: 0
Branch 6492: 0
Branch 6493: 0
Branch 6494: 0
Branch 6495: 0
Branch 6496: 0
Branch 6497: 0
Branch 6498: 0
Branch 6499: 0
Branch 6500: 0
Branch 6501: 0
Branch 6502: 0
Branch 6503: 0
Branch 6504: 0
Branch 6505: 0
Branch 6506: 0
Branch 6507: 0
Branch 6508: 0
Branch 6509: 0
Branch 6510: 0
Branch 6511: 0
Branch 6512: 0
Branch 6513: 0
Branch 6514: 0
Branch 6515: 0
Branch 6516: 0
Branch 6517: 0
Branch 6518: 0
Branch 6519: 0
Branch 6520: 0
Branch 6521: 0
Branch 6522: 0
Branch 6523: 0
Branch 6524: 0
Branch 6525: 0
Branch 6526: 0
Branch 6527: 0
Branch 6528: 0
Branch 6529: 0
Branch 6530: 0
Branch 6531: 0
Branch 6532: 0
Branch 6533: 0
Branch 6534: 0
Branch 6535: 0
Branch 6536: 0
Branch 6537: 0
Branch 6538: 0
Branch 6539: 0
Branch 6540: 0
Branch 6541: 0
Branch 6542: 0
Branch 6543: 0
Branch 6544: 0
Branch 6545: 0
Branch 6546: 0
Branch 6547: 0
Branch 6548: 0
Branch 6549: 0
Branch 6550: 0
Branch 6551: 0
Branch 6552: 0
Branch 6553: 0
Branch 6554: 0
Branch 6555: 0
Branch 6556: 0
Branch 6557: 0
Branch 6558: 0
Branch 6559: 0
Branch 6560: 0
Branch 6561: 0
Branch 6562: 0
Branch 6563: 0
Branch 6564: 0
Branch 6565: 0
Branch 6566: 0
Branch 6567: 0
Iteration 1
Running test command:
/home/ubuntu/spr-fast/tools/grep-test.py /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-deccad69-db9d6340/tempworkdir2/src /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-deccad69-db9d6340/tempworkdir2/tests /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-deccad69-db9d6340/tempworkdir2 0  > __res
Opening:/home/ubuntu/spr-fast/tests/corebench/grep/grep-case-deccad69-db9d6340/tempworkdir2/neg.tmp!
NegativeBRANCH RECORD/home/ubuntu/spr-fast/tests/corebench/grep/grep-case-deccad69-db9d6340/tempworkdir2/neg.tmp!
APPENDING TO ISNEG:/home/ubuntu/spr-fast/tests/corebench/grep/grep-case-deccad69-db9d6340/tempworkdir2/neg.tmp!
Running test command:
/home/ubuntu/spr-fast/tools/grep-test.py /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-deccad69-db9d6340/tempworkdir2/src /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-deccad69-db9d6340/tempworkdir2/tests /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-deccad69-db9d6340/tempworkdir2 0  > __res
a batched test job starts!
Building merged code:
src_file: src/search.c
full src: int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
/* search.c - searching subroutines using dfa, kwset and regex for grep.
   Copyright 1992, 1998, 2000, 2007, 2009-2010 Free Software Foundation, Inc.

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 3, or (at your option)
   any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program; if not, write to the Free Software
   Foundation, Inc., 51 Franklin Street - Fifth Floor, Boston, MA
   02110-1301, USA.  */

/* Written August 1992 by Mike Haertel. */

#include <config.h>

#include <sys/types.h>

#include "mbsupport.h"
#ifdef MBS_SUPPORT
/* We can handle multibyte strings. */
# include <wchar.h>
# include <wctype.h>
#endif

#include "system.h"
#include "grep.h"
#ifndef FGREP_PROGRAM
# include <regex.h>
# include "dfa.h"
#endif
#include "kwset.h"
#include "error.h"
#include "xalloc.h"
#ifdef HAVE_LIBPCRE
# include <pcre.h>
#endif

#define NCHAR (UCHAR_MAX + 1)

/* For -w, we also consider _ to be word constituent.  */
#define WCHAR(C) (ISALNUM(C) || (C) == '_')

/* KWset compiled pattern.  For Ecompile and Gcompile, we compile
   a list of strings, at least one of which is known to occur in
   any string matching the regexp. */
static kwset_t kwset;

static void
kwsinit (void)
{
  static char trans[NCHAR];
  int i;

  if (match_icase && MB_CUR_MAX == 1)
    {
      for (i = 0; i < NCHAR; ++i)
        trans[i] = TOLOWER (i);

      kwset = kwsalloc (trans);
    }
  else
    kwset = kwsalloc (NULL);

  if (!kwset)
    xalloc_die ();
}

#ifdef MBS_SUPPORT
/* Convert the *N-byte string, BEG, to lowercase, and write the
   NUL-terminated result into malloc'd storage.  Upon success, set *N
   to the length (in bytes) of the resulting string (not including the
   trailing NUL byte), and return a pointer to the lowercase string.
   Upon memory allocation failure, this function exits.

   Note that while this function returns a pointer to malloc'd storage,
   the caller must not free it, since this function retains a pointer
   to the buffer and reuses it on any subsequent call.  As a consequence,
   this function is not thread-safe.  */
static char *
mbtolower (const char *beg, size_t *n)
{
  static char *out;
  static size_t outalloc;
  size_t outlen, mb_cur_max;
  mbstate_t is, os;
  const char *end;
  char *p;

  if (*n > outalloc)
    {
      out = xrealloc (out, *n);
      outalloc = *n;
    }

  memset (&is, 0, sizeof (is));
  memset (&os, 0, sizeof (os));
  end = beg + *n;

  mb_cur_max = MB_CUR_MAX;
  p = out;
  outlen = 0;
  while (beg < end)
    {
      wchar_t wc;
      size_t mbclen = mbrtowc(&wc, beg, end - beg, &is);
      if (outlen + mb_cur_max >= outalloc)
        {
          out = x2nrealloc (out, &outalloc, 1);
          p = out + outlen;
        }

      if (mbclen == (size_t) -1 || mbclen == (size_t) -2 || mbclen == 0)
        {
          /* An invalid sequence, or a truncated multi-octet character.
             We treat it as a single-octet character.  */
          *p++ = *beg++;
          outlen++;
          memset (&is, 0, sizeof (is));
          memset (&os, 0, sizeof (os));
        }
      else
        {
          beg += mbclen;
          mbclen = wcrtomb (p, towlower ((wint_t) wc), &os);
          p += mbclen;
          outlen += mbclen;
        }
    }

  *n = p - out;
  *p++ = 0;
  return out;
}
#endif


#ifndef FGREP_PROGRAM
/* DFA compiled regexp. */
static struct dfa dfa;

/* The Regex compiled patterns.  */
static struct patterns
{
  /* Regex compiled regexp. */
  struct re_pattern_buffer regexbuf;
  struct re_registers regs; /* This is here on account of a BRAIN-DEAD
			       Q@#%!# library interface in regex.c.  */
} patterns0;

struct patterns *patterns;
size_t pcount;

void
dfaerror (char const *mesg)
{
  error (EXIT_TROUBLE, 0, "%s", mesg);
}

/* Number of compiled fixed strings known to exactly match the regexp.
   If kwsexec returns < kwset_exact_matches, then we don't need to
   call the regexp matcher at all. */
static int kwset_exact_matches;

static char const *
kwsincr_case (const char *must)
{
  const char *buf;
  size_t n;

  n = strlen (must);
#ifdef MBS_SUPPORT
  if (match_icase && MB_CUR_MAX > 1)
    buf = mbtolower (must, &n);
  else
#endif
    buf = must;
  return kwsincr (kwset, buf, n);
}

/* If the DFA turns out to have some set of fixed strings one of
   which must occur in the match, then we build a kwset matcher
   to find those strings, and thus quickly filter out impossible
   matches. */
static void
kwsmusts (void)
{
  struct dfamust const *dm;
  char const *err;

  if (dfa.musts)
    {
      kwsinit ();
      /* First, we compile in the substrings known to be exact
	 matches.  The kwset matcher will return the index
	 of the matching string that it chooses. */
      for (dm = dfa.musts; dm; dm = dm->next)
	{
	  if (!dm->exact)
	    continue;
	  ++kwset_exact_matches;
	  if ((err = kwsincr_case (dm->must)) != NULL)
	    error (EXIT_TROUBLE, 0, "%s", err);
	}
      /* Now, we compile the substrings that will require
	 the use of the regexp matcher.  */
      for (dm = dfa.musts; dm; dm = dm->next)
	{
	  if (dm->exact)
	    continue;
	  if ((err = kwsincr_case (dm->must)) != NULL)
	    error (EXIT_TROUBLE, 0, "%s", err);
	}
      if ((err = kwsprep (kwset)) != NULL)
	error (EXIT_TROUBLE, 0, "%s", err);
    }
}
#endif /* !FGREP_PROGRAM */

#ifdef MBS_SUPPORT

static bool
is_mb_middle(const char **good, const char *buf, const char *end)
{
  const char *p = *good;
  const char *prev = p;
  mbstate_t cur_state;

  /* TODO: can be optimized for UTF-8.  */
  memset(&cur_state, 0, sizeof(mbstate_t));
  while (p < buf)
    {
      size_t mbclen = mbrlen(p, end - p, &cur_state);

      /* Store the beginning of the previous complete multibyte character.  */
      if (mbclen != (size_t) -2)
        prev = p;

      if (mbclen == (size_t) -1 || mbclen == (size_t) -2 || mbclen == 0)
	{
	  /* An invalid sequence, or a truncated multibyte character.
	     We treat it as a single byte character.  */
	  mbclen = 1;
	}
      p += mbclen;
    }

  *good = prev;
  return p > buf;
}
#endif /* MBS_SUPPORT */

#if defined(GREP_PROGRAM) || defined(EGREP_PROGRAM)
#ifdef EGREP_PROGRAM
COMPILE_FCT(Ecompile)
{
  reg_syntax_t syntax_bits = RE_SYNTAX_POSIX_EGREP;
#else
/* No __VA_ARGS__ in C89.  So we have to do it this way.  */
static COMPILE_RET
GEAcompile (char const *pattern, size_t size, reg_syntax_t syntax_bits)
{
#endif /* EGREP_PROGRAM */
  const char *err;
  const char *p, *sep;
  size_t total = size;
  char *motif;

  if (match_icase)
    syntax_bits |= RE_ICASE;
  re_set_syntax (syntax_bits);
  dfasyntax (syntax_bits, match_icase, eolbyte);

  /* For GNU regex compiler we have to pass the patterns separately to detect
     errors like "[\nallo\n]\n".  The patterns here are "[", "allo" and "]"
     GNU regex should have raise a syntax error.  The same for backref, where
     the backref should have been local to each pattern.  */
  p = pattern;
  do
    {
      size_t len;
      sep = memchr (p, '\n', total);
      if (sep)
	{
	  len = sep - p;
	  sep++;
	  total -= (len + 1);
	}
      else
	{
	  len = total;
	  total = 0;
	}

      patterns = realloc (patterns, (pcount + 1) * sizeof (*patterns));
      if (patterns == NULL)
	error (EXIT_TROUBLE, errno, _("memory exhausted"));
      patterns[pcount] = patterns0;

      if ((err = re_compile_pattern (p, len,
				    &(patterns[pcount].regexbuf))) != NULL)
	error (EXIT_TROUBLE, 0, "%s", err);
      pcount++;

      p = sep;
    } while (sep && total != 0);

  /* In the match_words and match_lines cases, we use a different pattern
     for the DFA matcher that will quickly throw out cases that won't work.
     Then if DFA succeeds we do some hairy stuff using the regex matcher
     to decide whether the match should really count. */
  if (match_words || match_lines)
    {
      static char const line_beg_no_bk[] = "^(";
      static char const line_end_no_bk[] = ")$";
      static char const word_beg_no_bk[] = "(^|[^[:alnum:]_])(";
      static char const word_end_no_bk[] = ")([^[:alnum:]_]|$)";
#ifdef EGREP_PROGRAM
# define IF_BK(x, y) (y)
      char *n = xmalloc (sizeof word_beg_no_bk - 1 + size + sizeof word_end_no_bk);
#else
      static char const line_beg_bk[] = "^\\(";
      static char const line_end_bk[] = "\\)$";
      static char const word_beg_bk[] = "\\(^\\|[^[:alnum:]_]\\)\\(";
      static char const word_end_bk[] = "\\)\\([^[:alnum:]_]\\|$\\)";
      int bk = !(syntax_bits & RE_NO_BK_PARENS);
# define IF_BK(x, y) ((bk) ? (x) : (y))
      char *n = xmalloc (sizeof word_beg_bk - 1 + size + sizeof word_end_bk);
#endif /* EGREP_PROGRAM */

      strcpy (n, match_lines ? IF_BK(line_beg_bk, line_beg_no_bk)
			     : IF_BK(word_beg_bk, word_beg_no_bk));
      total = strlen(n);
      memcpy (n + total, pattern, size);
      total += size;
      strcpy (n + total, match_lines ? IF_BK(line_end_bk, line_end_no_bk)
				     : IF_BK(word_end_bk, word_end_no_bk));
      total += strlen (n + total);
      pattern = motif = n;
      size = total;
    }
  else
    motif = NULL;

  dfacomp (pattern, size, &dfa, 1);
  kwsmusts ();

  free(motif);
}

#ifndef EGREP_PROGRAM
COMPILE_FCT(Gcompile)
{
  return GEAcompile (pattern, size,
		     RE_SYNTAX_GREP | RE_HAT_LISTS_NOT_NEWLINE);
}

COMPILE_FCT(Acompile)
{
  return GEAcompile (pattern, size, RE_SYNTAX_AWK);
}

COMPILE_FCT(Ecompile)
{
  return GEAcompile (pattern, size, RE_SYNTAX_POSIX_EGREP);
}
#endif /* !EGREP_PROGRAM */

EXECUTE_FCT(EGexecute)
{
  char const *buflim, *beg, *end, *match, *best_match, *mb_start;
  char eol = eolbyte;
  int backref, start, len, best_len;
  struct kwsmatch kwsm;
  size_t i, ret_val;
#ifdef MBS_SUPPORT
  if (MB_CUR_MAX > 1)
    {
      if (match_icase)
        {
          /* mbtolower adds a NUL byte at the end.  That will provide
	     space for the sentinel byte dfaexec may add.  */
          char *case_buf = mbtolower (buf, &size);
	  if (start_ptr)
	    start_ptr = case_buf + (start_ptr - buf);
          buf = case_buf;
        }
    }
#endif /* MBS_SUPPORT */

  mb_start = buf;
  buflim = buf + size;

  for (beg = end = buf; end < buflim; beg = end)
    {
      if (!start_ptr)
	{
	  /* We don't care about an exact match.  */
	  if (kwset)
	    {
	      /* Find a possible match using the KWset matcher. */
	      size_t offset = kwsexec (kwset, beg, buflim - beg, &kwsm);
	      if (offset == (size_t) -1)
		goto failure;
	      beg += offset;
	      /* Narrow down to the line containing the candidate, and
		 run it through DFA. */
	      if ((end = memchr(beg, eol, buflim - beg)) != NULL)
	        end++;
              else
                end = buflim;
	      match = beg;
	      while (beg > buf && beg[-1] != eol)
		--beg;
	      if (kwsm.index < kwset_exact_matches)
                {
#ifdef MBS_SUPPORT
                  if (mb_start < beg)
                    mb_start = beg;
                  if (MB_CUR_MAX == 1 || !is_mb_middle (&mb_start, match, buflim))
#endif
                    goto success;
                }
	      if (dfaexec (&dfa, beg, (char *) end, 0, NULL, &backref) == NULL)
		continue;
	    }
	  else
	    {
	      /* No good fixed strings; start with DFA. */
	      char const *next_beg = dfaexec (&dfa, beg, (char *) buflim,
					      0, NULL, &backref);
	      if (next_beg == NULL)
		break;
	      /* Narrow down to the line we've found. */
	      beg = next_beg;
	      if ((end = memchr(beg, eol, buflim - beg)) != NULL)
	        end++;
              else
                end = buflim;
	      while (beg > buf && beg[-1] != eol)
		--beg;
	    }
	  /* Successful, no backreferences encountered! */
	  if (!backref)
	    goto success;
	}
      else
	{
	  /* We are looking for the leftmost (then longest) exact match.
	     We will go through the outer loop only once.  */
	  beg = start_ptr;
	  end = buflim;
	}

      /* If we've made it to this point, this means DFA has seen
	 a probable match, and we need to run it through Regex. */
      best_match = end;
      best_len = 0;
      for (i = 0; i < pcount; i++)
	{
	  patterns[i].regexbuf.not_eol = 0;
	  if (0 <= (start = re_search (&(patterns[i].regexbuf),
				       buf, end - buf - 1,
				       beg - buf, end - beg - 1,
				       &(patterns[i].regs))))
	    {
	      len = patterns[i].regs.end[0] - start;
	      match = buf + start;
	      if (match > best_match)
		continue;
	      if (start_ptr && !match_words)
		goto assess_pattern_match;
	      if ((!match_lines && !match_words)
		  || (match_lines && len == end - beg - 1))
		{
		  match = beg;
		  len = end - beg;
		  goto assess_pattern_match;
		}
	      /* If -w, check if the match aligns with word boundaries.
		 We do this iteratively because:
		 (a) the line may contain more than one occurence of the
		 pattern, and
		 (b) Several alternatives in the pattern might be valid at a
		 given point, and we may need to consider a shorter one to
		 find a word boundary.  */
	      if (match_words)
		while (match <= best_match)
		  {
		    if ((match == buf || !WCHAR ((unsigned char) match[-1]))
			&& (len == end - beg - 1
			    || !WCHAR ((unsigned char) match[len])))
		      goto assess_pattern_match;
		    if (len > 0)
		      {
			/* Try a shorter length anchored at the same place. */
			--len;
			patterns[i].regexbuf.not_eol = 1;
			len = re_match (&(patterns[i].regexbuf),
					buf, match + len - beg, match - buf,
					&(patterns[i].regs));
		      }
		    if (len <= 0)
		      {
			/* Try looking further on. */
			if (match == end - 1)
			  break;
			match++;
			patterns[i].regexbuf.not_eol = 0;
			start = re_search (&(patterns[i].regexbuf),
					   buf, end - buf - 1,
					   match - buf, end - match - 1,
					   &(patterns[i].regs));
			if (start < 0)
			  break;
			len = patterns[i].regs.end[0] - start;
			match = buf + start;
		      }
		  } /* while (match <= best_match) */
	      continue;
	    assess_pattern_match:
	      if (!start_ptr)
		{
		  /* Good enough for a non-exact match.
		     No need to look at further patterns, if any.  */
		  beg = match;
		  goto success_in_len;
		}
	      if (match < best_match || (match == best_match && len > best_len))
		{
		  /* Best exact match:  leftmost, then longest.  */
		  best_match = match;
		  best_len = len;
		}
	    } /* if re_search >= 0 */
	} /* for Regex patterns.  */
	if (best_match < end)
	  {
	    /* We have found an exact match.  We were just
	       waiting for the best one (leftmost then longest).  */
	    beg = best_match;
	    len = best_len;
	    goto success_in_len;
	  }
    } /* for (beg = end ..) */

 failure:
  ret_val = -1;
  goto out;

 success:
  len = end - beg;
 success_in_len:
  *match_size = len;
  ret_val = beg - buf;
 out:
  return ret_val;
}
#endif /* defined(GREP_PROGRAM) || defined(EGREP_PROGRAM) */

#if defined(GREP_PROGRAM) || defined(FGREP_PROGRAM)
COMPILE_FCT(Fcompile)
{
  char const *beg, *end, *lim, *err, *pat;
  size_t psize;

  kwsinit ();
  psize = size;
  //prophet generated patch
  if (__get_mutant()==0) {
  if ((match_icase && (__ctype_get_mb_cur_max()) > 1) && !(__is_neg(10, &(match_icase), sizeof (match_icase), &(pattern), sizeof (pattern), &(size), sizeof (size), &(pat), sizeof (pat), &(psize), sizeof (psize), &(beg), sizeof (beg), &(lim), sizeof (lim), &(end), sizeof (end), &(err), sizeof (err), &(kwset), sizeof (kwset))))
      pat = mbtolower(pattern, &psize);
  else
      pat = pattern;
  }
  else if (__get_mutant()==1) {
  if ((match_icase && (__ctype_get_mb_cur_max()) > 1) || (__is_neg(10, &(match_icase), sizeof (match_icase), &(pattern), sizeof (pattern), &(size), sizeof (size), &(pat), sizeof (pat), &(psize), sizeof (psize), &(beg), sizeof (beg), &(lim), sizeof (lim), &(end), sizeof (end), &(err), sizeof (err), &(kwset), sizeof (kwset))))
      pat = mbtolower(pattern, &psize);
  else
      pat = pattern;
  }
  else if (__get_mutant()==2) {
  if (((match_icase) || (__is_neg(10, &(match_icase), sizeof (match_icase), &(pattern), sizeof (pattern), &(size), sizeof (size), &(pat), sizeof (pat), &(psize), sizeof (psize), &(beg), sizeof (beg), &(lim), sizeof (lim), &(end), sizeof (end), &(err), sizeof (err), &(kwset), sizeof (kwset)))) && (__ctype_get_mb_cur_max()) > 1)
      pat = mbtolower(pattern, &psize);
  else
      pat = pattern;
  }

  beg = pat;
  do
    {
      for (lim = beg;; ++lim)
	{
	  end = lim;
	  if (lim >= pat + psize)
	    break;
	 if (*lim == '\n')
	   {
	     lim++;
	     break;
	   }
#if HAVE_DOS_FILE_CONTENTS
	 if (*lim == '\r' && lim + 1 < pat + psize && lim[1] == '\n')
	   {
	     lim += 2;
	     break;
	   }
#endif
	}

      if ((err = kwsincr (kwset, beg, end - beg)) != NULL)
	error (EXIT_TROUBLE, 0, "%s", err);
      beg = lim;
    }
  while (beg < pat + psize);

  if ((err = kwsprep (kwset)) != NULL)
    error (EXIT_TROUBLE, 0, "%s", err);
}

EXECUTE_FCT(Fexecute)
{
  char const *beg, *try, *end, *mb_start;
  size_t len;
  char eol = eolbyte;
  struct kwsmatch kwsmatch;
  size_t ret_val;
#ifdef MBS_SUPPORT
  if (MB_CUR_MAX > 1)
    {
      if (match_icase)
        {
          char *case_buf = mbtolower (buf, &size);
	  if (start_ptr)
	    start_ptr = case_buf + (start_ptr - buf);
          buf = case_buf;
        }
    }
#endif /* MBS_SUPPORT */

  for (mb_start = beg = start_ptr ? start_ptr : buf; beg <= buf + size; beg++)
    {
      size_t offset = kwsexec (kwset, beg, buf + size - beg, &kwsmatch);
      if (offset == (size_t) -1)
	goto failure;
#ifdef MBS_SUPPORT
      if (MB_CUR_MAX > 1 && is_mb_middle (&mb_start, beg + offset, buf + size))
        {
          beg = mb_start - 1;
          continue; /* It is a part of multibyte character.  */
        }
#endif /* MBS_SUPPORT */
      beg += offset;
      len = kwsmatch.size[0];
      if (start_ptr && !match_words)
	goto success_in_beg_and_len;
      if (match_lines)
	{
	  if (beg > buf && beg[-1] != eol)
	    continue;
	  if (beg + len < buf + size && beg[len] != eol)
	    continue;
	  goto success;
	}
      else if (match_words)
	for (try = beg; len; )
	  {
	    if (try > buf && WCHAR((unsigned char) try[-1]))
	      break;
	    if (try + len < buf + size && WCHAR((unsigned char) try[len]))
	      {
		offset = kwsexec (kwset, beg, --len, &kwsmatch);
		if (offset == (size_t) -1)
		  break;
		try = beg + offset;
		len = kwsmatch.size[0];
	      }
	    else if (!start_ptr)
	      goto success;
	    else
	      goto success_in_beg_and_len;
	  } /* for (try) */
      else
	goto success;
    } /* for (beg in buf) */

 failure:
  ret_val = -1;
  goto out;

 success:
  if ((end = memchr (beg + len, eol, (buf + size) - (beg + len))) != NULL)
    end++;
  else
    end = buf + size;
  while (buf < beg && beg[-1] != eol)
    --beg;
  len = end - beg;
 success_in_beg_and_len:
  *match_size = len;
  ret_val = beg - buf;
 out:
  return ret_val;
}
#endif /* defined(GREP_PROGRAM) || defined(FGREP_PROGRAM) */

#ifdef GREP_PROGRAM
#if HAVE_LIBPCRE
/* Compiled internal form of a Perl regular expression.  */
static pcre *cre;

/* Additional information about the pattern.  */
static pcre_extra *extra;
#endif

COMPILE_FCT(Pcompile)
{
#if !HAVE_LIBPCRE
  error (EXIT_TROUBLE, 0, "%s",
	 _("support for the -P option is not compiled into "
	   "this --disable-perl-regexp binary"));
#else
  int e;
  char const *ep;
  char *re = xmalloc (4 * size + 7);
  int flags = PCRE_MULTILINE | (match_icase ? PCRE_CASELESS : 0);
  char const *patlim = pattern + size;
  char *n = re;
  char const *p;
  char const *pnul;

  /* FIXME: Remove these restrictions.  */
  if (memchr(pattern, '\n', size))
    error (EXIT_TROUBLE, 0, _("the -P option only supports a single pattern"));

  *n = '\0';
  if (match_lines)
    strcpy (n, "^(");
  if (match_words)
    strcpy (n, "\\b(");
  n += strlen (n);

  /* The PCRE interface doesn't allow NUL bytes in the pattern, so
     replace each NUL byte in the pattern with the four characters
     "\000", removing a preceding backslash if there are an odd
     number of backslashes before the NUL.

     FIXME: This method does not work with some multibyte character
     encodings, notably Shift-JIS, where a multibyte character can end
     in a backslash byte.  */
  for (p = pattern; (pnul = memchr (p, '\0', patlim - p)); p = pnul + 1)
    {
      memcpy (n, p, pnul - p);
      n += pnul - p;
      for (p = pnul; pattern < p && p[-1] == '\\'; p--)
	continue;
      n -= (pnul - p) & 1;
      strcpy (n, "\\000");
      n += 4;
    }

  memcpy (n, p, patlim - p);
  n += patlim - p;
  *n = '\0';
  if (match_words)
    strcpy (n, ")\\b");
  if (match_lines)
    strcpy (n, ")$");

  cre = pcre_compile (re, flags, &ep, &e, pcre_maketables ());
  if (!cre)
    error (EXIT_TROUBLE, 0, "%s", ep);

  extra = pcre_study (cre, 0, &ep);
  if (ep)
    error (EXIT_TROUBLE, 0, "%s", ep);

  free (re);
#endif
}

EXECUTE_FCT(Pexecute)
{
#if !HAVE_LIBPCRE
  abort ();
  return -1;
#else
  /* This array must have at least two elements; everything after that
     is just for performance improvement in pcre_exec.  */
  int sub[300];

  const char *line_buf, *line_end, *line_next;
  int e = PCRE_ERROR_NOMATCH;
  ptrdiff_t start_ofs = start_ptr ? start_ptr - buf : 0;

  /* PCRE can't limit the matching to single lines, therefore we have to
     match each line in the buffer separately.  */
  for (line_next = buf;
       e == PCRE_ERROR_NOMATCH && line_next < buf + size;
       start_ofs -= line_next - line_buf)
    {
      line_buf = line_next;
      line_end = memchr (line_buf, eolbyte, (buf + size) - line_buf);
      if (line_end == NULL)
        line_next = line_end = buf + size;
      else
        line_next = line_end + 1;

      if (start_ptr && start_ptr >= line_end)
        continue;

      e = pcre_exec (cre, extra, line_buf, line_end - line_buf,
                     start_ofs < 0 ? 0 : start_ofs, 0,
                     sub, sizeof sub / sizeof *sub);
    }

  if (e <= 0)
    {
      switch (e)
	{
	case PCRE_ERROR_NOMATCH:
	  return -1;

	case PCRE_ERROR_NOMEMORY:
	  error (EXIT_TROUBLE, 0, _("memory exhausted"));

	default:
	  abort ();
	}
    }
  else
    {
      /* Narrow down to the line we've found.  */
      char const *beg = line_buf + sub[0];
      char const *end = line_buf + sub[1];
      char const *buflim = buf + size;
      char eol = eolbyte;
      if (!start_ptr)
	{
	  /* FIXME: The case when '\n' is not found indicates a bug:
	     Since grep is line oriented, the match should never contain
	     a newline, so there _must_ be a newline following.
	   */
	  if (!(end = memchr (end, eol, buflim - end)))
	    end = buflim;
	  else
	    end++;
	  while (buf < beg && beg[-1] != eol)
	    --beg;
	}

      *match_size = end - beg;
      return beg - buf;
    }
#endif
}

struct matcher const matchers[] = {
  { "default", Gcompile, EGexecute },
  { "grep",    Gcompile, EGexecute },
  { "egrep",   Ecompile, EGexecute },
  { "awk",     Acompile, EGexecute },
  { "fgrep",   Fcompile, Fexecute },
  { "perl",    Pcompile, Pexecute },
  { "", 0, 0 },
};
#endif /* GREP_PROGRAM */

Building:src at:
/home/ubuntu/spr-fast/tests/corebench/grep/grep-case-deccad69-db9d6340/tempworkdir2/srcMerged code building succ, going to invoke tester!
CondTester, Testing instance id 3:
//src_file:src/search.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
/* search.c - searching subroutines using dfa, kwset and regex for grep.
   Copyright 1992, 1998, 2000, 2007, 2009-2010 Free Software Foundation, Inc.

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 3, or (at your option)
   any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program; if not, write to the Free Software
   Foundation, Inc., 51 Franklin Street - Fifth Floor, Boston, MA
   02110-1301, USA.  */

/* Written August 1992 by Mike Haertel. */

#include <config.h>

#include <sys/types.h>

#include "mbsupport.h"
#ifdef MBS_SUPPORT
/* We can handle multibyte strings. */
# include <wchar.h>
# include <wctype.h>
#endif

#include "system.h"
#include "grep.h"
#ifndef FGREP_PROGRAM
# include <regex.h>
# include "dfa.h"
#endif
#include "kwset.h"
#include "error.h"
#include "xalloc.h"
#ifdef HAVE_LIBPCRE
# include <pcre.h>
#endif

#define NCHAR (UCHAR_MAX + 1)

/* For -w, we also consider _ to be word constituent.  */
#define WCHAR(C) (ISALNUM(C) || (C) == '_')

/* KWset compiled pattern.  For Ecompile and Gcompile, we compile
   a list of strings, at least one of which is known to occur in
   any string matching the regexp. */
static kwset_t kwset;

static void
kwsinit (void)
{
  static char trans[NCHAR];
  int i;

  if (match_icase && MB_CUR_MAX == 1)
    {
      for (i = 0; i < NCHAR; ++i)
        trans[i] = TOLOWER (i);

      kwset = kwsalloc (trans);
    }
  else
    kwset = kwsalloc (NULL);

  if (!kwset)
    xalloc_die ();
}

#ifdef MBS_SUPPORT
/* Convert the *N-byte string, BEG, to lowercase, and write the
   NUL-terminated result into malloc'd storage.  Upon success, set *N
   to the length (in bytes) of the resulting string (not including the
   trailing NUL byte), and return a pointer to the lowercase string.
   Upon memory allocation failure, this function exits.

   Note that while this function returns a pointer to malloc'd storage,
   the caller must not free it, since this function retains a pointer
   to the buffer and reuses it on any subsequent call.  As a consequence,
   this function is not thread-safe.  */
static char *
mbtolower (const char *beg, size_t *n)
{
  static char *out;
  static size_t outalloc;
  size_t outlen, mb_cur_max;
  mbstate_t is, os;
  const char *end;
  char *p;

  if (*n > outalloc)
    {
      out = xrealloc (out, *n);
      outalloc = *n;
    }

  memset (&is, 0, sizeof (is));
  memset (&os, 0, sizeof (os));
  end = beg + *n;

  mb_cur_max = MB_CUR_MAX;
  p = out;
  outlen = 0;
  while (beg < end)
    {
      wchar_t wc;
      size_t mbclen = mbrtowc(&wc, beg, end - beg, &is);
      if (outlen + mb_cur_max >= outalloc)
        {
          out = x2nrealloc (out, &outalloc, 1);
          p = out + outlen;
        }

      if (mbclen == (size_t) -1 || mbclen == (size_t) -2 || mbclen == 0)
        {
          /* An invalid sequence, or a truncated multi-octet character.
             We treat it as a single-octet character.  */
          *p++ = *beg++;
          outlen++;
          memset (&is, 0, sizeof (is));
          memset (&os, 0, sizeof (os));
        }
      else
        {
          beg += mbclen;
          mbclen = wcrtomb (p, towlower ((wint_t) wc), &os);
          p += mbclen;
          outlen += mbclen;
        }
    }

  *n = p - out;
  *p++ = 0;
  return out;
}
#endif


#ifndef FGREP_PROGRAM
/* DFA compiled regexp. */
static struct dfa dfa;

/* The Regex compiled patterns.  */
static struct patterns
{
  /* Regex compiled regexp. */
  struct re_pattern_buffer regexbuf;
  struct re_registers regs; /* This is here on account of a BRAIN-DEAD
			       Q@#%!# library interface in regex.c.  */
} patterns0;

struct patterns *patterns;
size_t pcount;

void
dfaerror (char const *mesg)
{
  error (EXIT_TROUBLE, 0, "%s", mesg);
}

/* Number of compiled fixed strings known to exactly match the regexp.
   If kwsexec returns < kwset_exact_matches, then we don't need to
   call the regexp matcher at all. */
static int kwset_exact_matches;

static char const *
kwsincr_case (const char *must)
{
  const char *buf;
  size_t n;

  n = strlen (must);
#ifdef MBS_SUPPORT
  if (match_icase && MB_CUR_MAX > 1)
    buf = mbtolower (must, &n);
  else
#endif
    buf = must;
  return kwsincr (kwset, buf, n);
}

/* If the DFA turns out to have some set of fixed strings one of
   which must occur in the match, then we build a kwset matcher
   to find those strings, and thus quickly filter out impossible
   matches. */
static void
kwsmusts (void)
{
  struct dfamust const *dm;
  char const *err;

  if (dfa.musts)
    {
      kwsinit ();
      /* First, we compile in the substrings known to be exact
	 matches.  The kwset matcher will return the index
	 of the matching string that it chooses. */
      for (dm = dfa.musts; dm; dm = dm->next)
	{
	  if (!dm->exact)
	    continue;
	  ++kwset_exact_matches;
	  if ((err = kwsincr_case (dm->must)) != NULL)
	    error (EXIT_TROUBLE, 0, "%s", err);
	}
      /* Now, we compile the substrings that will require
	 the use of the regexp matcher.  */
      for (dm = dfa.musts; dm; dm = dm->next)
	{
	  if (dm->exact)
	    continue;
	  if ((err = kwsincr_case (dm->must)) != NULL)
	    error (EXIT_TROUBLE, 0, "%s", err);
	}
      if ((err = kwsprep (kwset)) != NULL)
	error (EXIT_TROUBLE, 0, "%s", err);
    }
}
#endif /* !FGREP_PROGRAM */

#ifdef MBS_SUPPORT

static bool
is_mb_middle(const char **good, const char *buf, const char *end)
{
  const char *p = *good;
  const char *prev = p;
  mbstate_t cur_state;

  /* TODO: can be optimized for UTF-8.  */
  memset(&cur_state, 0, sizeof(mbstate_t));
  while (p < buf)
    {
      size_t mbclen = mbrlen(p, end - p, &cur_state);

      /* Store the beginning of the previous complete multibyte character.  */
      if (mbclen != (size_t) -2)
        prev = p;

      if (mbclen == (size_t) -1 || mbclen == (size_t) -2 || mbclen == 0)
	{
	  /* An invalid sequence, or a truncated multibyte character.
	     We treat it as a single byte character.  */
	  mbclen = 1;
	}
      p += mbclen;
    }

  *good = prev;
  return p > buf;
}
#endif /* MBS_SUPPORT */

#if defined(GREP_PROGRAM) || defined(EGREP_PROGRAM)
#ifdef EGREP_PROGRAM
COMPILE_FCT(Ecompile)
{
  reg_syntax_t syntax_bits = RE_SYNTAX_POSIX_EGREP;
#else
/* No __VA_ARGS__ in C89.  So we have to do it this way.  */
static COMPILE_RET
GEAcompile (char const *pattern, size_t size, reg_syntax_t syntax_bits)
{
#endif /* EGREP_PROGRAM */
  const char *err;
  const char *p, *sep;
  size_t total = size;
  char *motif;

  if (match_icase)
    syntax_bits |= RE_ICASE;
  re_set_syntax (syntax_bits);
  dfasyntax (syntax_bits, match_icase, eolbyte);

  /* For GNU regex compiler we have to pass the patterns separately to detect
     errors like "[\nallo\n]\n".  The patterns here are "[", "allo" and "]"
     GNU regex should have raise a syntax error.  The same for backref, where
     the backref should have been local to each pattern.  */
  p = pattern;
  do
    {
      size_t len;
      sep = memchr (p, '\n', total);
      if (sep)
	{
	  len = sep - p;
	  sep++;
	  total -= (len + 1);
	}
      else
	{
	  len = total;
	  total = 0;
	}

      patterns = realloc (patterns, (pcount + 1) * sizeof (*patterns));
      if (patterns == NULL)
	error (EXIT_TROUBLE, errno, _("memory exhausted"));
      patterns[pcount] = patterns0;

      if ((err = re_compile_pattern (p, len,
				    &(patterns[pcount].regexbuf))) != NULL)
	error (EXIT_TROUBLE, 0, "%s", err);
      pcount++;

      p = sep;
    } while (sep && total != 0);

  /* In the match_words and match_lines cases, we use a different pattern
     for the DFA matcher that will quickly throw out cases that won't work.
     Then if DFA succeeds we do some hairy stuff using the regex matcher
     to decide whether the match should really count. */
  if (match_words || match_lines)
    {
      static char const line_beg_no_bk[] = "^(";
      static char const line_end_no_bk[] = ")$";
      static char const word_beg_no_bk[] = "(^|[^[:alnum:]_])(";
      static char const word_end_no_bk[] = ")([^[:alnum:]_]|$)";
#ifdef EGREP_PROGRAM
# define IF_BK(x, y) (y)
      char *n = xmalloc (sizeof word_beg_no_bk - 1 + size + sizeof word_end_no_bk);
#else
      static char const line_beg_bk[] = "^\\(";
      static char const line_end_bk[] = "\\)$";
      static char const word_beg_bk[] = "\\(^\\|[^[:alnum:]_]\\)\\(";
      static char const word_end_bk[] = "\\)\\([^[:alnum:]_]\\|$\\)";
      int bk = !(syntax_bits & RE_NO_BK_PARENS);
# define IF_BK(x, y) ((bk) ? (x) : (y))
      char *n = xmalloc (sizeof word_beg_bk - 1 + size + sizeof word_end_bk);
#endif /* EGREP_PROGRAM */

      strcpy (n, match_lines ? IF_BK(line_beg_bk, line_beg_no_bk)
			     : IF_BK(word_beg_bk, word_beg_no_bk));
      total = strlen(n);
      memcpy (n + total, pattern, size);
      total += size;
      strcpy (n + total, match_lines ? IF_BK(line_end_bk, line_end_no_bk)
				     : IF_BK(word_end_bk, word_end_no_bk));
      total += strlen (n + total);
      pattern = motif = n;
      size = total;
    }
  else
    motif = NULL;

  dfacomp (pattern, size, &dfa, 1);
  kwsmusts ();

  free(motif);
}

#ifndef EGREP_PROGRAM
COMPILE_FCT(Gcompile)
{
  return GEAcompile (pattern, size,
		     RE_SYNTAX_GREP | RE_HAT_LISTS_NOT_NEWLINE);
}

COMPILE_FCT(Acompile)
{
  return GEAcompile (pattern, size, RE_SYNTAX_AWK);
}

COMPILE_FCT(Ecompile)
{
  return GEAcompile (pattern, size, RE_SYNTAX_POSIX_EGREP);
}
#endif /* !EGREP_PROGRAM */

EXECUTE_FCT(EGexecute)
{
  char const *buflim, *beg, *end, *match, *best_match, *mb_start;
  char eol = eolbyte;
  int backref, start, len, best_len;
  struct kwsmatch kwsm;
  size_t i, ret_val;
#ifdef MBS_SUPPORT
  if (MB_CUR_MAX > 1)
    {
      if (match_icase)
        {
          /* mbtolower adds a NUL byte at the end.  That will provide
	     space for the sentinel byte dfaexec may add.  */
          char *case_buf = mbtolower (buf, &size);
	  if (start_ptr)
	    start_ptr = case_buf + (start_ptr - buf);
          buf = case_buf;
        }
    }
#endif /* MBS_SUPPORT */

  mb_start = buf;
  buflim = buf + size;

  for (beg = end = buf; end < buflim; beg = end)
    {
      if (!start_ptr)
	{
	  /* We don't care about an exact match.  */
	  if (kwset)
	    {
	      /* Find a possible match using the KWset matcher. */
	      size_t offset = kwsexec (kwset, beg, buflim - beg, &kwsm);
	      if (offset == (size_t) -1)
		goto failure;
	      beg += offset;
	      /* Narrow down to the line containing the candidate, and
		 run it through DFA. */
	      if ((end = memchr(beg, eol, buflim - beg)) != NULL)
	        end++;
              else
                end = buflim;
	      match = beg;
	      while (beg > buf && beg[-1] != eol)
		--beg;
	      if (kwsm.index < kwset_exact_matches)
                {
#ifdef MBS_SUPPORT
                  if (mb_start < beg)
                    mb_start = beg;
                  if (MB_CUR_MAX == 1 || !is_mb_middle (&mb_start, match, buflim))
#endif
                    goto success;
                }
	      if (dfaexec (&dfa, beg, (char *) end, 0, NULL, &backref) == NULL)
		continue;
	    }
	  else
	    {
	      /* No good fixed strings; start with DFA. */
	      char const *next_beg = dfaexec (&dfa, beg, (char *) buflim,
					      0, NULL, &backref);
	      if (next_beg == NULL)
		break;
	      /* Narrow down to the line we've found. */
	      beg = next_beg;
	      if ((end = memchr(beg, eol, buflim - beg)) != NULL)
	        end++;
              else
                end = buflim;
	      while (beg > buf && beg[-1] != eol)
		--beg;
	    }
	  /* Successful, no backreferences encountered! */
	  if (!backref)
	    goto success;
	}
      else
	{
	  /* We are looking for the leftmost (then longest) exact match.
	     We will go through the outer loop only once.  */
	  beg = start_ptr;
	  end = buflim;
	}

      /* If we've made it to this point, this means DFA has seen
	 a probable match, and we need to run it through Regex. */
      best_match = end;
      best_len = 0;
      for (i = 0; i < pcount; i++)
	{
	  patterns[i].regexbuf.not_eol = 0;
	  if (0 <= (start = re_search (&(patterns[i].regexbuf),
				       buf, end - buf - 1,
				       beg - buf, end - beg - 1,
				       &(patterns[i].regs))))
	    {
	      len = patterns[i].regs.end[0] - start;
	      match = buf + start;
	      if (match > best_match)
		continue;
	      if (start_ptr && !match_words)
		goto assess_pattern_match;
	      if ((!match_lines && !match_words)
		  || (match_lines && len == end - beg - 1))
		{
		  match = beg;
		  len = end - beg;
		  goto assess_pattern_match;
		}
	      /* If -w, check if the match aligns with word boundaries.
		 We do this iteratively because:
		 (a) the line may contain more than one occurence of the
		 pattern, and
		 (b) Several alternatives in the pattern might be valid at a
		 given point, and we may need to consider a shorter one to
		 find a word boundary.  */
	      if (match_words)
		while (match <= best_match)
		  {
		    if ((match == buf || !WCHAR ((unsigned char) match[-1]))
			&& (len == end - beg - 1
			    || !WCHAR ((unsigned char) match[len])))
		      goto assess_pattern_match;
		    if (len > 0)
		      {
			/* Try a shorter length anchored at the same place. */
			--len;
			patterns[i].regexbuf.not_eol = 1;
			len = re_match (&(patterns[i].regexbuf),
					buf, match + len - beg, match - buf,
					&(patterns[i].regs));
		      }
		    if (len <= 0)
		      {
			/* Try looking further on. */
			if (match == end - 1)
			  break;
			match++;
			patterns[i].regexbuf.not_eol = 0;
			start = re_search (&(patterns[i].regexbuf),
					   buf, end - buf - 1,
					   match - buf, end - match - 1,
					   &(patterns[i].regs));
			if (start < 0)
			  break;
			len = patterns[i].regs.end[0] - start;
			match = buf + start;
		      }
		  } /* while (match <= best_match) */
	      continue;
	    assess_pattern_match:
	      if (!start_ptr)
		{
		  /* Good enough for a non-exact match.
		     No need to look at further patterns, if any.  */
		  beg = match;
		  goto success_in_len;
		}
	      if (match < best_match || (match == best_match && len > best_len))
		{
		  /* Best exact match:  leftmost, then longest.  */
		  best_match = match;
		  best_len = len;
		}
	    } /* if re_search >= 0 */
	} /* for Regex patterns.  */
	if (best_match < end)
	  {
	    /* We have found an exact match.  We were just
	       waiting for the best one (leftmost then longest).  */
	    beg = best_match;
	    len = best_len;
	    goto success_in_len;
	  }
    } /* for (beg = end ..) */

 failure:
  ret_val = -1;
  goto out;

 success:
  len = end - beg;
 success_in_len:
  *match_size = len;
  ret_val = beg - buf;
 out:
  return ret_val;
}
#endif /* defined(GREP_PROGRAM) || defined(EGREP_PROGRAM) */

#if defined(GREP_PROGRAM) || defined(FGREP_PROGRAM)
COMPILE_FCT(Fcompile)
{
  char const *beg, *end, *lim, *err, *pat;
  size_t psize;

  kwsinit ();
  psize = size;
  
//Patch 0:
if ((match_icase && (__ctype_get_mb_cur_max()) > 1) && !(__is_neg(10, &(match_icase), sizeof (match_icase), &(pattern), sizeof (pattern), &(size), sizeof (size), &(pat), sizeof (pat), &(psize), sizeof (psize), &(beg), sizeof (beg), &(lim), sizeof (lim), &(end), sizeof (end), &(err), sizeof (err), &(kwset), sizeof (kwset))))
    pat = mbtolower(pattern, &psize);
else
    pat = pattern;

//CodeSeg 1:

  beg = pat;
  do
    {
      for (lim = beg;; ++lim)
	{
	  end = lim;
	  if (lim >= pat + psize)
	    break;
	 if (*lim == '\n')
	   {
	     lim++;
	     break;
	   }
#if HAVE_DOS_FILE_CONTENTS
	 if (*lim == '\r' && lim + 1 < pat + psize && lim[1] == '\n')
	   {
	     lim += 2;
	     break;
	   }
#endif
	}

      if ((err = kwsincr (kwset, beg, end - beg)) != NULL)
	error (EXIT_TROUBLE, 0, "%s", err);
      beg = lim;
    }
  while (beg < pat + psize);

  if ((err = kwsprep (kwset)) != NULL)
    error (EXIT_TROUBLE, 0, "%s", err);
}

EXECUTE_FCT(Fexecute)
{
  char const *beg, *try, *end, *mb_start;
  size_t len;
  char eol = eolbyte;
  struct kwsmatch kwsmatch;
  size_t ret_val;
#ifdef MBS_SUPPORT
  if (MB_CUR_MAX > 1)
    {
      if (match_icase)
        {
          char *case_buf = mbtolower (buf, &size);
	  if (start_ptr)
	    start_ptr = case_buf + (start_ptr - buf);
          buf = case_buf;
        }
    }
#endif /* MBS_SUPPORT */

  for (mb_start = beg = start_ptr ? start_ptr : buf; beg <= buf + size; beg++)
    {
      size_t offset = kwsexec (kwset, beg, buf + size - beg, &kwsmatch);
      if (offset == (size_t) -1)
	goto failure;
#ifdef MBS_SUPPORT
      if (MB_CUR_MAX > 1 && is_mb_middle (&mb_start, beg + offset, buf + size))
        {
          beg = mb_start - 1;
          continue; /* It is a part of multibyte character.  */
        }
#endif /* MBS_SUPPORT */
      beg += offset;
      len = kwsmatch.size[0];
      if (start_ptr && !match_words)
	goto success_in_beg_and_len;
      if (match_lines)
	{
	  if (beg > buf && beg[-1] != eol)
	    continue;
	  if (beg + len < buf + size && beg[len] != eol)
	    continue;
	  goto success;
	}
      else if (match_words)
	for (try = beg; len; )
	  {
	    if (try > buf && WCHAR((unsigned char) try[-1]))
	      break;
	    if (try + len < buf + size && WCHAR((unsigned char) try[len]))
	      {
		offset = kwsexec (kwset, beg, --len, &kwsmatch);
		if (offset == (size_t) -1)
		  break;
		try = beg + offset;
		len = kwsmatch.size[0];
	      }
	    else if (!start_ptr)
	      goto success;
	    else
	      goto success_in_beg_and_len;
	  } /* for (try) */
      else
	goto success;
    } /* for (beg in buf) */

 failure:
  ret_val = -1;
  goto out;

 success:
  if ((end = memchr (beg + len, eol, (buf + size) - (beg + len))) != NULL)
    end++;
  else
    end = buf + size;
  while (buf < beg && beg[-1] != eol)
    --beg;
  len = end - beg;
 success_in_beg_and_len:
  *match_size = len;
  ret_val = beg - buf;
 out:
  return ret_val;
}
#endif /* defined(GREP_PROGRAM) || defined(FGREP_PROGRAM) */

#ifdef GREP_PROGRAM
#if HAVE_LIBPCRE
/* Compiled internal form of a Perl regular expression.  */
static pcre *cre;

/* Additional information about the pattern.  */
static pcre_extra *extra;
#endif

COMPILE_FCT(Pcompile)
{
#if !HAVE_LIBPCRE
  error (EXIT_TROUBLE, 0, "%s",
	 _("support for the -P option is not compiled into "
	   "this --disable-perl-regexp binary"));
#else
  int e;
  char const *ep;
  char *re = xmalloc (4 * size + 7);
  int flags = PCRE_MULTILINE | (match_icase ? PCRE_CASELESS : 0);
  char const *patlim = pattern + size;
  char *n = re;
  char const *p;
  char const *pnul;

  /* FIXME: Remove these restrictions.  */
  if (memchr(pattern, '\n', size))
    error (EXIT_TROUBLE, 0, _("the -P option only supports a single pattern"));

  *n = '\0';
  if (match_lines)
    strcpy (n, "^(");
  if (match_words)
    strcpy (n, "\\b(");
  n += strlen (n);

  /* The PCRE interface doesn't allow NUL bytes in the pattern, so
     replace each NUL byte in the pattern with the four characters
     "\000", removing a preceding backslash if there are an odd
     number of backslashes before the NUL.

     FIXME: This method does not work with some multibyte character
     encodings, notably Shift-JIS, where a multibyte character can end
     in a backslash byte.  */
  for (p = pattern; (pnul = memchr (p, '\0', patlim - p)); p = pnul + 1)
    {
      memcpy (n, p, pnul - p);
      n += pnul - p;
      for (p = pnul; pattern < p && p[-1] == '\\'; p--)
	continue;
      n -= (pnul - p) & 1;
      strcpy (n, "\\000");
      n += 4;
    }

  memcpy (n, p, patlim - p);
  n += patlim - p;
  *n = '\0';
  if (match_words)
    strcpy (n, ")\\b");
  if (match_lines)
    strcpy (n, ")$");

  cre = pcre_compile (re, flags, &ep, &e, pcre_maketables ());
  if (!cre)
    error (EXIT_TROUBLE, 0, "%s", ep);

  extra = pcre_study (cre, 0, &ep);
  if (ep)
    error (EXIT_TROUBLE, 0, "%s", ep);

  free (re);
#endif
}

EXECUTE_FCT(Pexecute)
{
#if !HAVE_LIBPCRE
  abort ();
  return -1;
#else
  /* This array must have at least two elements; everything after that
     is just for performance improvement in pcre_exec.  */
  int sub[300];

  const char *line_buf, *line_end, *line_next;
  int e = PCRE_ERROR_NOMATCH;
  ptrdiff_t start_ofs = start_ptr ? start_ptr - buf : 0;

  /* PCRE can't limit the matching to single lines, therefore we have to
     match each line in the buffer separately.  */
  for (line_next = buf;
       e == PCRE_ERROR_NOMATCH && line_next < buf + size;
       start_ofs -= line_next - line_buf)
    {
      line_buf = line_next;
      line_end = memchr (line_buf, eolbyte, (buf + size) - line_buf);
      if (line_end == NULL)
        line_next = line_end = buf + size;
      else
        line_next = line_end + 1;

      if (start_ptr && start_ptr >= line_end)
        continue;

      e = pcre_exec (cre, extra, line_buf, line_end - line_buf,
                     start_ofs < 0 ? 0 : start_ofs, 0,
                     sub, sizeof sub / sizeof *sub);
    }

  if (e <= 0)
    {
      switch (e)
	{
	case PCRE_ERROR_NOMATCH:
	  return -1;

	case PCRE_ERROR_NOMEMORY:
	  error (EXIT_TROUBLE, 0, _("memory exhausted"));

	default:
	  abort ();
	}
    }
  else
    {
      /* Narrow down to the line we've found.  */
      char const *beg = line_buf + sub[0];
      char const *end = line_buf + sub[1];
      char const *buflim = buf + size;
      char eol = eolbyte;
      if (!start_ptr)
	{
	  /* FIXME: The case when '\n' is not found indicates a bug:
	     Since grep is line oriented, the match should never contain
	     a newline, so there _must_ be a newline following.
	   */
	  if (!(end = memchr (end, eol, buflim - end)))
	    end = buflim;
	  else
	    end++;
	  while (buf < beg && beg[-1] != eol)
	    --beg;
	}

      *match_size = end - beg;
      return beg - buf;
    }
#endif
}

struct matcher const matchers[] = {
  { "default", Gcompile, EGexecute },
  { "grep",    Gcompile, EGexecute },
  { "egrep",   Ecompile, EGexecute },
  { "awk",     Acompile, EGexecute },
  { "fgrep",   Fcompile, Fexecute },
  { "perl",    Pcompile, Pexecute },
  { "", 0, 0 },
};
#endif /* GREP_PROGRAM */

Testing negative cases!
Testing 0 (with abstract condition) ENVIS_NEG
Iteration 0
Running test command:
/home/ubuntu/spr-fast/tools/grep-test.py /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-deccad69-db9d6340/tempworkdir2/src /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-deccad69-db9d6340/tempworkdir2/tests /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-deccad69-db9d6340/tempworkdir2 0  > __res
Opening:/home/ubuntu/spr-fast/tests/corebench/grep/grep-case-deccad69-db9d6340/tempworkdir2/neg.tmp!
NegativeBRANCH RECORD/home/ubuntu/spr-fast/tests/corebench/grep/grep-case-deccad69-db9d6340/tempworkdir2/neg.tmp!
Not caught by the negative case, give up!
APPENDING TO ISNEG:/home/ubuntu/spr-fast/tests/corebench/grep/grep-case-deccad69-db9d6340/tempworkdir2/neg.tmp!
Running test command:
/home/ubuntu/spr-fast/tools/grep-test.py /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-deccad69-db9d6340/tempworkdir2/src /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-deccad69-db9d6340/tempworkdir2/tests /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-deccad69-db9d6340/tempworkdir2 0  > __res
CondTester, Testing instance id 4:
//src_file:src/search.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
/* search.c - searching subroutines using dfa, kwset and regex for grep.
   Copyright 1992, 1998, 2000, 2007, 2009-2010 Free Software Foundation, Inc.

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 3, or (at your option)
   any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program; if not, write to the Free Software
   Foundation, Inc., 51 Franklin Street - Fifth Floor, Boston, MA
   02110-1301, USA.  */

/* Written August 1992 by Mike Haertel. */

#include <config.h>

#include <sys/types.h>

#include "mbsupport.h"
#ifdef MBS_SUPPORT
/* We can handle multibyte strings. */
# include <wchar.h>
# include <wctype.h>
#endif

#include "system.h"
#include "grep.h"
#ifndef FGREP_PROGRAM
# include <regex.h>
# include "dfa.h"
#endif
#include "kwset.h"
#include "error.h"
#include "xalloc.h"
#ifdef HAVE_LIBPCRE
# include <pcre.h>
#endif

#define NCHAR (UCHAR_MAX + 1)

/* For -w, we also consider _ to be word constituent.  */
#define WCHAR(C) (ISALNUM(C) || (C) == '_')

/* KWset compiled pattern.  For Ecompile and Gcompile, we compile
   a list of strings, at least one of which is known to occur in
   any string matching the regexp. */
static kwset_t kwset;

static void
kwsinit (void)
{
  static char trans[NCHAR];
  int i;

  if (match_icase && MB_CUR_MAX == 1)
    {
      for (i = 0; i < NCHAR; ++i)
        trans[i] = TOLOWER (i);

      kwset = kwsalloc (trans);
    }
  else
    kwset = kwsalloc (NULL);

  if (!kwset)
    xalloc_die ();
}

#ifdef MBS_SUPPORT
/* Convert the *N-byte string, BEG, to lowercase, and write the
   NUL-terminated result into malloc'd storage.  Upon success, set *N
   to the length (in bytes) of the resulting string (not including the
   trailing NUL byte), and return a pointer to the lowercase string.
   Upon memory allocation failure, this function exits.

   Note that while this function returns a pointer to malloc'd storage,
   the caller must not free it, since this function retains a pointer
   to the buffer and reuses it on any subsequent call.  As a consequence,
   this function is not thread-safe.  */
static char *
mbtolower (const char *beg, size_t *n)
{
  static char *out;
  static size_t outalloc;
  size_t outlen, mb_cur_max;
  mbstate_t is, os;
  const char *end;
  char *p;

  if (*n > outalloc)
    {
      out = xrealloc (out, *n);
      outalloc = *n;
    }

  memset (&is, 0, sizeof (is));
  memset (&os, 0, sizeof (os));
  end = beg + *n;

  mb_cur_max = MB_CUR_MAX;
  p = out;
  outlen = 0;
  while (beg < end)
    {
      wchar_t wc;
      size_t mbclen = mbrtowc(&wc, beg, end - beg, &is);
      if (outlen + mb_cur_max >= outalloc)
        {
          out = x2nrealloc (out, &outalloc, 1);
          p = out + outlen;
        }

      if (mbclen == (size_t) -1 || mbclen == (size_t) -2 || mbclen == 0)
        {
          /* An invalid sequence, or a truncated multi-octet character.
             We treat it as a single-octet character.  */
          *p++ = *beg++;
          outlen++;
          memset (&is, 0, sizeof (is));
          memset (&os, 0, sizeof (os));
        }
      else
        {
          beg += mbclen;
          mbclen = wcrtomb (p, towlower ((wint_t) wc), &os);
          p += mbclen;
          outlen += mbclen;
        }
    }

  *n = p - out;
  *p++ = 0;
  return out;
}
#endif


#ifndef FGREP_PROGRAM
/* DFA compiled regexp. */
static struct dfa dfa;

/* The Regex compiled patterns.  */
static struct patterns
{
  /* Regex compiled regexp. */
  struct re_pattern_buffer regexbuf;
  struct re_registers regs; /* This is here on account of a BRAIN-DEAD
			       Q@#%!# library interface in regex.c.  */
} patterns0;

struct patterns *patterns;
size_t pcount;

void
dfaerror (char const *mesg)
{
  error (EXIT_TROUBLE, 0, "%s", mesg);
}

/* Number of compiled fixed strings known to exactly match the regexp.
   If kwsexec returns < kwset_exact_matches, then we don't need to
   call the regexp matcher at all. */
static int kwset_exact_matches;

static char const *
kwsincr_case (const char *must)
{
  const char *buf;
  size_t n;

  n = strlen (must);
#ifdef MBS_SUPPORT
  if (match_icase && MB_CUR_MAX > 1)
    buf = mbtolower (must, &n);
  else
#endif
    buf = must;
  return kwsincr (kwset, buf, n);
}

/* If the DFA turns out to have some set of fixed strings one of
   which must occur in the match, then we build a kwset matcher
   to find those strings, and thus quickly filter out impossible
   matches. */
static void
kwsmusts (void)
{
  struct dfamust const *dm;
  char const *err;

  if (dfa.musts)
    {
      kwsinit ();
      /* First, we compile in the substrings known to be exact
	 matches.  The kwset matcher will return the index
	 of the matching string that it chooses. */
      for (dm = dfa.musts; dm; dm = dm->next)
	{
	  if (!dm->exact)
	    continue;
	  ++kwset_exact_matches;
	  if ((err = kwsincr_case (dm->must)) != NULL)
	    error (EXIT_TROUBLE, 0, "%s", err);
	}
      /* Now, we compile the substrings that will require
	 the use of the regexp matcher.  */
      for (dm = dfa.musts; dm; dm = dm->next)
	{
	  if (dm->exact)
	    continue;
	  if ((err = kwsincr_case (dm->must)) != NULL)
	    error (EXIT_TROUBLE, 0, "%s", err);
	}
      if ((err = kwsprep (kwset)) != NULL)
	error (EXIT_TROUBLE, 0, "%s", err);
    }
}
#endif /* !FGREP_PROGRAM */

#ifdef MBS_SUPPORT

static bool
is_mb_middle(const char **good, const char *buf, const char *end)
{
  const char *p = *good;
  const char *prev = p;
  mbstate_t cur_state;

  /* TODO: can be optimized for UTF-8.  */
  memset(&cur_state, 0, sizeof(mbstate_t));
  while (p < buf)
    {
      size_t mbclen = mbrlen(p, end - p, &cur_state);

      /* Store the beginning of the previous complete multibyte character.  */
      if (mbclen != (size_t) -2)
        prev = p;

      if (mbclen == (size_t) -1 || mbclen == (size_t) -2 || mbclen == 0)
	{
	  /* An invalid sequence, or a truncated multibyte character.
	     We treat it as a single byte character.  */
	  mbclen = 1;
	}
      p += mbclen;
    }

  *good = prev;
  return p > buf;
}
#endif /* MBS_SUPPORT */

#if defined(GREP_PROGRAM) || defined(EGREP_PROGRAM)
#ifdef EGREP_PROGRAM
COMPILE_FCT(Ecompile)
{
  reg_syntax_t syntax_bits = RE_SYNTAX_POSIX_EGREP;
#else
/* No __VA_ARGS__ in C89.  So we have to do it this way.  */
static COMPILE_RET
GEAcompile (char const *pattern, size_t size, reg_syntax_t syntax_bits)
{
#endif /* EGREP_PROGRAM */
  const char *err;
  const char *p, *sep;
  size_t total = size;
  char *motif;

  if (match_icase)
    syntax_bits |= RE_ICASE;
  re_set_syntax (syntax_bits);
  dfasyntax (syntax_bits, match_icase, eolbyte);

  /* For GNU regex compiler we have to pass the patterns separately to detect
     errors like "[\nallo\n]\n".  The patterns here are "[", "allo" and "]"
     GNU regex should have raise a syntax error.  The same for backref, where
     the backref should have been local to each pattern.  */
  p = pattern;
  do
    {
      size_t len;
      sep = memchr (p, '\n', total);
      if (sep)
	{
	  len = sep - p;
	  sep++;
	  total -= (len + 1);
	}
      else
	{
	  len = total;
	  total = 0;
	}

      patterns = realloc (patterns, (pcount + 1) * sizeof (*patterns));
      if (patterns == NULL)
	error (EXIT_TROUBLE, errno, _("memory exhausted"));
      patterns[pcount] = patterns0;

      if ((err = re_compile_pattern (p, len,
				    &(patterns[pcount].regexbuf))) != NULL)
	error (EXIT_TROUBLE, 0, "%s", err);
      pcount++;

      p = sep;
    } while (sep && total != 0);

  /* In the match_words and match_lines cases, we use a different pattern
     for the DFA matcher that will quickly throw out cases that won't work.
     Then if DFA succeeds we do some hairy stuff using the regex matcher
     to decide whether the match should really count. */
  if (match_words || match_lines)
    {
      static char const line_beg_no_bk[] = "^(";
      static char const line_end_no_bk[] = ")$";
      static char const word_beg_no_bk[] = "(^|[^[:alnum:]_])(";
      static char const word_end_no_bk[] = ")([^[:alnum:]_]|$)";
#ifdef EGREP_PROGRAM
# define IF_BK(x, y) (y)
      char *n = xmalloc (sizeof word_beg_no_bk - 1 + size + sizeof word_end_no_bk);
#else
      static char const line_beg_bk[] = "^\\(";
      static char const line_end_bk[] = "\\)$";
      static char const word_beg_bk[] = "\\(^\\|[^[:alnum:]_]\\)\\(";
      static char const word_end_bk[] = "\\)\\([^[:alnum:]_]\\|$\\)";
      int bk = !(syntax_bits & RE_NO_BK_PARENS);
# define IF_BK(x, y) ((bk) ? (x) : (y))
      char *n = xmalloc (sizeof word_beg_bk - 1 + size + sizeof word_end_bk);
#endif /* EGREP_PROGRAM */

      strcpy (n, match_lines ? IF_BK(line_beg_bk, line_beg_no_bk)
			     : IF_BK(word_beg_bk, word_beg_no_bk));
      total = strlen(n);
      memcpy (n + total, pattern, size);
      total += size;
      strcpy (n + total, match_lines ? IF_BK(line_end_bk, line_end_no_bk)
				     : IF_BK(word_end_bk, word_end_no_bk));
      total += strlen (n + total);
      pattern = motif = n;
      size = total;
    }
  else
    motif = NULL;

  dfacomp (pattern, size, &dfa, 1);
  kwsmusts ();

  free(motif);
}

#ifndef EGREP_PROGRAM
COMPILE_FCT(Gcompile)
{
  return GEAcompile (pattern, size,
		     RE_SYNTAX_GREP | RE_HAT_LISTS_NOT_NEWLINE);
}

COMPILE_FCT(Acompile)
{
  return GEAcompile (pattern, size, RE_SYNTAX_AWK);
}

COMPILE_FCT(Ecompile)
{
  return GEAcompile (pattern, size, RE_SYNTAX_POSIX_EGREP);
}
#endif /* !EGREP_PROGRAM */

EXECUTE_FCT(EGexecute)
{
  char const *buflim, *beg, *end, *match, *best_match, *mb_start;
  char eol = eolbyte;
  int backref, start, len, best_len;
  struct kwsmatch kwsm;
  size_t i, ret_val;
#ifdef MBS_SUPPORT
  if (MB_CUR_MAX > 1)
    {
      if (match_icase)
        {
          /* mbtolower adds a NUL byte at the end.  That will provide
	     space for the sentinel byte dfaexec may add.  */
          char *case_buf = mbtolower (buf, &size);
	  if (start_ptr)
	    start_ptr = case_buf + (start_ptr - buf);
          buf = case_buf;
        }
    }
#endif /* MBS_SUPPORT */

  mb_start = buf;
  buflim = buf + size;

  for (beg = end = buf; end < buflim; beg = end)
    {
      if (!start_ptr)
	{
	  /* We don't care about an exact match.  */
	  if (kwset)
	    {
	      /* Find a possible match using the KWset matcher. */
	      size_t offset = kwsexec (kwset, beg, buflim - beg, &kwsm);
	      if (offset == (size_t) -1)
		goto failure;
	      beg += offset;
	      /* Narrow down to the line containing the candidate, and
		 run it through DFA. */
	      if ((end = memchr(beg, eol, buflim - beg)) != NULL)
	        end++;
              else
                end = buflim;
	      match = beg;
	      while (beg > buf && beg[-1] != eol)
		--beg;
	      if (kwsm.index < kwset_exact_matches)
                {
#ifdef MBS_SUPPORT
                  if (mb_start < beg)
                    mb_start = beg;
                  if (MB_CUR_MAX == 1 || !is_mb_middle (&mb_start, match, buflim))
#endif
                    goto success;
                }
	      if (dfaexec (&dfa, beg, (char *) end, 0, NULL, &backref) == NULL)
		continue;
	    }
	  else
	    {
	      /* No good fixed strings; start with DFA. */
	      char const *next_beg = dfaexec (&dfa, beg, (char *) buflim,
					      0, NULL, &backref);
	      if (next_beg == NULL)
		break;
	      /* Narrow down to the line we've found. */
	      beg = next_beg;
	      if ((end = memchr(beg, eol, buflim - beg)) != NULL)
	        end++;
              else
                end = buflim;
	      while (beg > buf && beg[-1] != eol)
		--beg;
	    }
	  /* Successful, no backreferences encountered! */
	  if (!backref)
	    goto success;
	}
      else
	{
	  /* We are looking for the leftmost (then longest) exact match.
	     We will go through the outer loop only once.  */
	  beg = start_ptr;
	  end = buflim;
	}

      /* If we've made it to this point, this means DFA has seen
	 a probable match, and we need to run it through Regex. */
      best_match = end;
      best_len = 0;
      for (i = 0; i < pcount; i++)
	{
	  patterns[i].regexbuf.not_eol = 0;
	  if (0 <= (start = re_search (&(patterns[i].regexbuf),
				       buf, end - buf - 1,
				       beg - buf, end - beg - 1,
				       &(patterns[i].regs))))
	    {
	      len = patterns[i].regs.end[0] - start;
	      match = buf + start;
	      if (match > best_match)
		continue;
	      if (start_ptr && !match_words)
		goto assess_pattern_match;
	      if ((!match_lines && !match_words)
		  || (match_lines && len == end - beg - 1))
		{
		  match = beg;
		  len = end - beg;
		  goto assess_pattern_match;
		}
	      /* If -w, check if the match aligns with word boundaries.
		 We do this iteratively because:
		 (a) the line may contain more than one occurence of the
		 pattern, and
		 (b) Several alternatives in the pattern might be valid at a
		 given point, and we may need to consider a shorter one to
		 find a word boundary.  */
	      if (match_words)
		while (match <= best_match)
		  {
		    if ((match == buf || !WCHAR ((unsigned char) match[-1]))
			&& (len == end - beg - 1
			    || !WCHAR ((unsigned char) match[len])))
		      goto assess_pattern_match;
		    if (len > 0)
		      {
			/* Try a shorter length anchored at the same place. */
			--len;
			patterns[i].regexbuf.not_eol = 1;
			len = re_match (&(patterns[i].regexbuf),
					buf, match + len - beg, match - buf,
					&(patterns[i].regs));
		      }
		    if (len <= 0)
		      {
			/* Try looking further on. */
			if (match == end - 1)
			  break;
			match++;
			patterns[i].regexbuf.not_eol = 0;
			start = re_search (&(patterns[i].regexbuf),
					   buf, end - buf - 1,
					   match - buf, end - match - 1,
					   &(patterns[i].regs));
			if (start < 0)
			  break;
			len = patterns[i].regs.end[0] - start;
			match = buf + start;
		      }
		  } /* while (match <= best_match) */
	      continue;
	    assess_pattern_match:
	      if (!start_ptr)
		{
		  /* Good enough for a non-exact match.
		     No need to look at further patterns, if any.  */
		  beg = match;
		  goto success_in_len;
		}
	      if (match < best_match || (match == best_match && len > best_len))
		{
		  /* Best exact match:  leftmost, then longest.  */
		  best_match = match;
		  best_len = len;
		}
	    } /* if re_search >= 0 */
	} /* for Regex patterns.  */
	if (best_match < end)
	  {
	    /* We have found an exact match.  We were just
	       waiting for the best one (leftmost then longest).  */
	    beg = best_match;
	    len = best_len;
	    goto success_in_len;
	  }
    } /* for (beg = end ..) */

 failure:
  ret_val = -1;
  goto out;

 success:
  len = end - beg;
 success_in_len:
  *match_size = len;
  ret_val = beg - buf;
 out:
  return ret_val;
}
#endif /* defined(GREP_PROGRAM) || defined(EGREP_PROGRAM) */

#if defined(GREP_PROGRAM) || defined(FGREP_PROGRAM)
COMPILE_FCT(Fcompile)
{
  char const *beg, *end, *lim, *err, *pat;
  size_t psize;

  kwsinit ();
  psize = size;
  
//Patch 0:
if ((match_icase && (__ctype_get_mb_cur_max()) > 1) || (__is_neg(10, &(match_icase), sizeof (match_icase), &(pattern), sizeof (pattern), &(size), sizeof (size), &(pat), sizeof (pat), &(psize), sizeof (psize), &(beg), sizeof (beg), &(lim), sizeof (lim), &(end), sizeof (end), &(err), sizeof (err), &(kwset), sizeof (kwset))))
    pat = mbtolower(pattern, &psize);
else
    pat = pattern;

//CodeSeg 1:

  beg = pat;
  do
    {
      for (lim = beg;; ++lim)
	{
	  end = lim;
	  if (lim >= pat + psize)
	    break;
	 if (*lim == '\n')
	   {
	     lim++;
	     break;
	   }
#if HAVE_DOS_FILE_CONTENTS
	 if (*lim == '\r' && lim + 1 < pat + psize && lim[1] == '\n')
	   {
	     lim += 2;
	     break;
	   }
#endif
	}

      if ((err = kwsincr (kwset, beg, end - beg)) != NULL)
	error (EXIT_TROUBLE, 0, "%s", err);
      beg = lim;
    }
  while (beg < pat + psize);

  if ((err = kwsprep (kwset)) != NULL)
    error (EXIT_TROUBLE, 0, "%s", err);
}

EXECUTE_FCT(Fexecute)
{
  char const *beg, *try, *end, *mb_start;
  size_t len;
  char eol = eolbyte;
  struct kwsmatch kwsmatch;
  size_t ret_val;
#ifdef MBS_SUPPORT
  if (MB_CUR_MAX > 1)
    {
      if (match_icase)
        {
          char *case_buf = mbtolower (buf, &size);
	  if (start_ptr)
	    start_ptr = case_buf + (start_ptr - buf);
          buf = case_buf;
        }
    }
#endif /* MBS_SUPPORT */

  for (mb_start = beg = start_ptr ? start_ptr : buf; beg <= buf + size; beg++)
    {
      size_t offset = kwsexec (kwset, beg, buf + size - beg, &kwsmatch);
      if (offset == (size_t) -1)
	goto failure;
#ifdef MBS_SUPPORT
      if (MB_CUR_MAX > 1 && is_mb_middle (&mb_start, beg + offset, buf + size))
        {
          beg = mb_start - 1;
          continue; /* It is a part of multibyte character.  */
        }
#endif /* MBS_SUPPORT */
      beg += offset;
      len = kwsmatch.size[0];
      if (start_ptr && !match_words)
	goto success_in_beg_and_len;
      if (match_lines)
	{
	  if (beg > buf && beg[-1] != eol)
	    continue;
	  if (beg + len < buf + size && beg[len] != eol)
	    continue;
	  goto success;
	}
      else if (match_words)
	for (try = beg; len; )
	  {
	    if (try > buf && WCHAR((unsigned char) try[-1]))
	      break;
	    if (try + len < buf + size && WCHAR((unsigned char) try[len]))
	      {
		offset = kwsexec (kwset, beg, --len, &kwsmatch);
		if (offset == (size_t) -1)
		  break;
		try = beg + offset;
		len = kwsmatch.size[0];
	      }
	    else if (!start_ptr)
	      goto success;
	    else
	      goto success_in_beg_and_len;
	  } /* for (try) */
      else
	goto success;
    } /* for (beg in buf) */

 failure:
  ret_val = -1;
  goto out;

 success:
  if ((end = memchr (beg + len, eol, (buf + size) - (beg + len))) != NULL)
    end++;
  else
    end = buf + size;
  while (buf < beg && beg[-1] != eol)
    --beg;
  len = end - beg;
 success_in_beg_and_len:
  *match_size = len;
  ret_val = beg - buf;
 out:
  return ret_val;
}
#endif /* defined(GREP_PROGRAM) || defined(FGREP_PROGRAM) */

#ifdef GREP_PROGRAM
#if HAVE_LIBPCRE
/* Compiled internal form of a Perl regular expression.  */
static pcre *cre;

/* Additional information about the pattern.  */
static pcre_extra *extra;
#endif

COMPILE_FCT(Pcompile)
{
#if !HAVE_LIBPCRE
  error (EXIT_TROUBLE, 0, "%s",
	 _("support for the -P option is not compiled into "
	   "this --disable-perl-regexp binary"));
#else
  int e;
  char const *ep;
  char *re = xmalloc (4 * size + 7);
  int flags = PCRE_MULTILINE | (match_icase ? PCRE_CASELESS : 0);
  char const *patlim = pattern + size;
  char *n = re;
  char const *p;
  char const *pnul;

  /* FIXME: Remove these restrictions.  */
  if (memchr(pattern, '\n', size))
    error (EXIT_TROUBLE, 0, _("the -P option only supports a single pattern"));

  *n = '\0';
  if (match_lines)
    strcpy (n, "^(");
  if (match_words)
    strcpy (n, "\\b(");
  n += strlen (n);

  /* The PCRE interface doesn't allow NUL bytes in the pattern, so
     replace each NUL byte in the pattern with the four characters
     "\000", removing a preceding backslash if there are an odd
     number of backslashes before the NUL.

     FIXME: This method does not work with some multibyte character
     encodings, notably Shift-JIS, where a multibyte character can end
     in a backslash byte.  */
  for (p = pattern; (pnul = memchr (p, '\0', patlim - p)); p = pnul + 1)
    {
      memcpy (n, p, pnul - p);
      n += pnul - p;
      for (p = pnul; pattern < p && p[-1] == '\\'; p--)
	continue;
      n -= (pnul - p) & 1;
      strcpy (n, "\\000");
      n += 4;
    }

  memcpy (n, p, patlim - p);
  n += patlim - p;
  *n = '\0';
  if (match_words)
    strcpy (n, ")\\b");
  if (match_lines)
    strcpy (n, ")$");

  cre = pcre_compile (re, flags, &ep, &e, pcre_maketables ());
  if (!cre)
    error (EXIT_TROUBLE, 0, "%s", ep);

  extra = pcre_study (cre, 0, &ep);
  if (ep)
    error (EXIT_TROUBLE, 0, "%s", ep);

  free (re);
#endif
}

EXECUTE_FCT(Pexecute)
{
#if !HAVE_LIBPCRE
  abort ();
  return -1;
#else
  /* This array must have at least two elements; everything after that
     is just for performance improvement in pcre_exec.  */
  int sub[300];

  const char *line_buf, *line_end, *line_next;
  int e = PCRE_ERROR_NOMATCH;
  ptrdiff_t start_ofs = start_ptr ? start_ptr - buf : 0;

  /* PCRE can't limit the matching to single lines, therefore we have to
     match each line in the buffer separately.  */
  for (line_next = buf;
       e == PCRE_ERROR_NOMATCH && line_next < buf + size;
       start_ofs -= line_next - line_buf)
    {
      line_buf = line_next;
      line_end = memchr (line_buf, eolbyte, (buf + size) - line_buf);
      if (line_end == NULL)
        line_next = line_end = buf + size;
      else
        line_next = line_end + 1;

      if (start_ptr && start_ptr >= line_end)
        continue;

      e = pcre_exec (cre, extra, line_buf, line_end - line_buf,
                     start_ofs < 0 ? 0 : start_ofs, 0,
                     sub, sizeof sub / sizeof *sub);
    }

  if (e <= 0)
    {
      switch (e)
	{
	case PCRE_ERROR_NOMATCH:
	  return -1;

	case PCRE_ERROR_NOMEMORY:
	  error (EXIT_TROUBLE, 0, _("memory exhausted"));

	default:
	  abort ();
	}
    }
  else
    {
      /* Narrow down to the line we've found.  */
      char const *beg = line_buf + sub[0];
      char const *end = line_buf + sub[1];
      char const *buflim = buf + size;
      char eol = eolbyte;
      if (!start_ptr)
	{
	  /* FIXME: The case when '\n' is not found indicates a bug:
	     Since grep is line oriented, the match should never contain
	     a newline, so there _must_ be a newline following.
	   */
	  if (!(end = memchr (end, eol, buflim - end)))
	    end = buflim;
	  else
	    end++;
	  while (buf < beg && beg[-1] != eol)
	    --beg;
	}

      *match_size = end - beg;
      return beg - buf;
    }
#endif
}

struct matcher const matchers[] = {
  { "default", Gcompile, EGexecute },
  { "grep",    Gcompile, EGexecute },
  { "egrep",   Ecompile, EGexecute },
  { "awk",     Acompile, EGexecute },
  { "fgrep",   Fcompile, Fexecute },
  { "perl",    Pcompile, Pexecute },
  { "", 0, 0 },
};
#endif /* GREP_PROGRAM */

Testing negative cases!
Testing 0 (with abstract condition) ENVIS_NEG
Iteration 0
Running test command:
/home/ubuntu/spr-fast/tools/grep-test.py /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-deccad69-db9d6340/tempworkdir2/src /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-deccad69-db9d6340/tempworkdir2/tests /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-deccad69-db9d6340/tempworkdir2 0  > __res
Opening:/home/ubuntu/spr-fast/tests/corebench/grep/grep-case-deccad69-db9d6340/tempworkdir2/neg.tmp!
NegativeBRANCH RECORD/home/ubuntu/spr-fast/tests/corebench/grep/grep-case-deccad69-db9d6340/tempworkdir2/neg.tmp!
APPENDING TO ISNEG:/home/ubuntu/spr-fast/tests/corebench/grep/grep-case-deccad69-db9d6340/tempworkdir2/neg.tmp!
Branch 0: 0
Iteration 1
Running test command:
/home/ubuntu/spr-fast/tools/grep-test.py /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-deccad69-db9d6340/tempworkdir2/src /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-deccad69-db9d6340/tempworkdir2/tests /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-deccad69-db9d6340/tempworkdir2 0  > __res
Opening:/home/ubuntu/spr-fast/tests/corebench/grep/grep-case-deccad69-db9d6340/tempworkdir2/neg.tmp!
NegativeBRANCH RECORD/home/ubuntu/spr-fast/tests/corebench/grep/grep-case-deccad69-db9d6340/tempworkdir2/neg.tmp!
APPENDING TO ISNEG:/home/ubuntu/spr-fast/tests/corebench/grep/grep-case-deccad69-db9d6340/tempworkdir2/neg.tmp!
Branch 0: 1
Running test command:
/home/ubuntu/spr-fast/tools/grep-test.py /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-deccad69-db9d6340/tempworkdir2/src /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-deccad69-db9d6340/tempworkdir2/tests /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-deccad69-db9d6340/tempworkdir2 0  > __res
CondTester, Testing instance id 5:
//src_file:src/search.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
/* search.c - searching subroutines using dfa, kwset and regex for grep.
   Copyright 1992, 1998, 2000, 2007, 2009-2010 Free Software Foundation, Inc.

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 3, or (at your option)
   any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program; if not, write to the Free Software
   Foundation, Inc., 51 Franklin Street - Fifth Floor, Boston, MA
   02110-1301, USA.  */

/* Written August 1992 by Mike Haertel. */

#include <config.h>

#include <sys/types.h>

#include "mbsupport.h"
#ifdef MBS_SUPPORT
/* We can handle multibyte strings. */
# include <wchar.h>
# include <wctype.h>
#endif

#include "system.h"
#include "grep.h"
#ifndef FGREP_PROGRAM
# include <regex.h>
# include "dfa.h"
#endif
#include "kwset.h"
#include "error.h"
#include "xalloc.h"
#ifdef HAVE_LIBPCRE
# include <pcre.h>
#endif

#define NCHAR (UCHAR_MAX + 1)

/* For -w, we also consider _ to be word constituent.  */
#define WCHAR(C) (ISALNUM(C) || (C) == '_')

/* KWset compiled pattern.  For Ecompile and Gcompile, we compile
   a list of strings, at least one of which is known to occur in
   any string matching the regexp. */
static kwset_t kwset;

static void
kwsinit (void)
{
  static char trans[NCHAR];
  int i;

  if (match_icase && MB_CUR_MAX == 1)
    {
      for (i = 0; i < NCHAR; ++i)
        trans[i] = TOLOWER (i);

      kwset = kwsalloc (trans);
    }
  else
    kwset = kwsalloc (NULL);

  if (!kwset)
    xalloc_die ();
}

#ifdef MBS_SUPPORT
/* Convert the *N-byte string, BEG, to lowercase, and write the
   NUL-terminated result into malloc'd storage.  Upon success, set *N
   to the length (in bytes) of the resulting string (not including the
   trailing NUL byte), and return a pointer to the lowercase string.
   Upon memory allocation failure, this function exits.

   Note that while this function returns a pointer to malloc'd storage,
   the caller must not free it, since this function retains a pointer
   to the buffer and reuses it on any subsequent call.  As a consequence,
   this function is not thread-safe.  */
static char *
mbtolower (const char *beg, size_t *n)
{
  static char *out;
  static size_t outalloc;
  size_t outlen, mb_cur_max;
  mbstate_t is, os;
  const char *end;
  char *p;

  if (*n > outalloc)
    {
      out = xrealloc (out, *n);
      outalloc = *n;
    }

  memset (&is, 0, sizeof (is));
  memset (&os, 0, sizeof (os));
  end = beg + *n;

  mb_cur_max = MB_CUR_MAX;
  p = out;
  outlen = 0;
  while (beg < end)
    {
      wchar_t wc;
      size_t mbclen = mbrtowc(&wc, beg, end - beg, &is);
      if (outlen + mb_cur_max >= outalloc)
        {
          out = x2nrealloc (out, &outalloc, 1);
          p = out + outlen;
        }

      if (mbclen == (size_t) -1 || mbclen == (size_t) -2 || mbclen == 0)
        {
          /* An invalid sequence, or a truncated multi-octet character.
             We treat it as a single-octet character.  */
          *p++ = *beg++;
          outlen++;
          memset (&is, 0, sizeof (is));
          memset (&os, 0, sizeof (os));
        }
      else
        {
          beg += mbclen;
          mbclen = wcrtomb (p, towlower ((wint_t) wc), &os);
          p += mbclen;
          outlen += mbclen;
        }
    }

  *n = p - out;
  *p++ = 0;
  return out;
}
#endif


#ifndef FGREP_PROGRAM
/* DFA compiled regexp. */
static struct dfa dfa;

/* The Regex compiled patterns.  */
static struct patterns
{
  /* Regex compiled regexp. */
  struct re_pattern_buffer regexbuf;
  struct re_registers regs; /* This is here on account of a BRAIN-DEAD
			       Q@#%!# library interface in regex.c.  */
} patterns0;

struct patterns *patterns;
size_t pcount;

void
dfaerror (char const *mesg)
{
  error (EXIT_TROUBLE, 0, "%s", mesg);
}

/* Number of compiled fixed strings known to exactly match the regexp.
   If kwsexec returns < kwset_exact_matches, then we don't need to
   call the regexp matcher at all. */
static int kwset_exact_matches;

static char const *
kwsincr_case (const char *must)
{
  const char *buf;
  size_t n;

  n = strlen (must);
#ifdef MBS_SUPPORT
  if (match_icase && MB_CUR_MAX > 1)
    buf = mbtolower (must, &n);
  else
#endif
    buf = must;
  return kwsincr (kwset, buf, n);
}

/* If the DFA turns out to have some set of fixed strings one of
   which must occur in the match, then we build a kwset matcher
   to find those strings, and thus quickly filter out impossible
   matches. */
static void
kwsmusts (void)
{
  struct dfamust const *dm;
  char const *err;

  if (dfa.musts)
    {
      kwsinit ();
      /* First, we compile in the substrings known to be exact
	 matches.  The kwset matcher will return the index
	 of the matching string that it chooses. */
      for (dm = dfa.musts; dm; dm = dm->next)
	{
	  if (!dm->exact)
	    continue;
	  ++kwset_exact_matches;
	  if ((err = kwsincr_case (dm->must)) != NULL)
	    error (EXIT_TROUBLE, 0, "%s", err);
	}
      /* Now, we compile the substrings that will require
	 the use of the regexp matcher.  */
      for (dm = dfa.musts; dm; dm = dm->next)
	{
	  if (dm->exact)
	    continue;
	  if ((err = kwsincr_case (dm->must)) != NULL)
	    error (EXIT_TROUBLE, 0, "%s", err);
	}
      if ((err = kwsprep (kwset)) != NULL)
	error (EXIT_TROUBLE, 0, "%s", err);
    }
}
#endif /* !FGREP_PROGRAM */

#ifdef MBS_SUPPORT

static bool
is_mb_middle(const char **good, const char *buf, const char *end)
{
  const char *p = *good;
  const char *prev = p;
  mbstate_t cur_state;

  /* TODO: can be optimized for UTF-8.  */
  memset(&cur_state, 0, sizeof(mbstate_t));
  while (p < buf)
    {
      size_t mbclen = mbrlen(p, end - p, &cur_state);

      /* Store the beginning of the previous complete multibyte character.  */
      if (mbclen != (size_t) -2)
        prev = p;

      if (mbclen == (size_t) -1 || mbclen == (size_t) -2 || mbclen == 0)
	{
	  /* An invalid sequence, or a truncated multibyte character.
	     We treat it as a single byte character.  */
	  mbclen = 1;
	}
      p += mbclen;
    }

  *good = prev;
  return p > buf;
}
#endif /* MBS_SUPPORT */

#if defined(GREP_PROGRAM) || defined(EGREP_PROGRAM)
#ifdef EGREP_PROGRAM
COMPILE_FCT(Ecompile)
{
  reg_syntax_t syntax_bits = RE_SYNTAX_POSIX_EGREP;
#else
/* No __VA_ARGS__ in C89.  So we have to do it this way.  */
static COMPILE_RET
GEAcompile (char const *pattern, size_t size, reg_syntax_t syntax_bits)
{
#endif /* EGREP_PROGRAM */
  const char *err;
  const char *p, *sep;
  size_t total = size;
  char *motif;

  if (match_icase)
    syntax_bits |= RE_ICASE;
  re_set_syntax (syntax_bits);
  dfasyntax (syntax_bits, match_icase, eolbyte);

  /* For GNU regex compiler we have to pass the patterns separately to detect
     errors like "[\nallo\n]\n".  The patterns here are "[", "allo" and "]"
     GNU regex should have raise a syntax error.  The same for backref, where
     the backref should have been local to each pattern.  */
  p = pattern;
  do
    {
      size_t len;
      sep = memchr (p, '\n', total);
      if (sep)
	{
	  len = sep - p;
	  sep++;
	  total -= (len + 1);
	}
      else
	{
	  len = total;
	  total = 0;
	}

      patterns = realloc (patterns, (pcount + 1) * sizeof (*patterns));
      if (patterns == NULL)
	error (EXIT_TROUBLE, errno, _("memory exhausted"));
      patterns[pcount] = patterns0;

      if ((err = re_compile_pattern (p, len,
				    &(patterns[pcount].regexbuf))) != NULL)
	error (EXIT_TROUBLE, 0, "%s", err);
      pcount++;

      p = sep;
    } while (sep && total != 0);

  /* In the match_words and match_lines cases, we use a different pattern
     for the DFA matcher that will quickly throw out cases that won't work.
     Then if DFA succeeds we do some hairy stuff using the regex matcher
     to decide whether the match should really count. */
  if (match_words || match_lines)
    {
      static char const line_beg_no_bk[] = "^(";
      static char const line_end_no_bk[] = ")$";
      static char const word_beg_no_bk[] = "(^|[^[:alnum:]_])(";
      static char const word_end_no_bk[] = ")([^[:alnum:]_]|$)";
#ifdef EGREP_PROGRAM
# define IF_BK(x, y) (y)
      char *n = xmalloc (sizeof word_beg_no_bk - 1 + size + sizeof word_end_no_bk);
#else
      static char const line_beg_bk[] = "^\\(";
      static char const line_end_bk[] = "\\)$";
      static char const word_beg_bk[] = "\\(^\\|[^[:alnum:]_]\\)\\(";
      static char const word_end_bk[] = "\\)\\([^[:alnum:]_]\\|$\\)";
      int bk = !(syntax_bits & RE_NO_BK_PARENS);
# define IF_BK(x, y) ((bk) ? (x) : (y))
      char *n = xmalloc (sizeof word_beg_bk - 1 + size + sizeof word_end_bk);
#endif /* EGREP_PROGRAM */

      strcpy (n, match_lines ? IF_BK(line_beg_bk, line_beg_no_bk)
			     : IF_BK(word_beg_bk, word_beg_no_bk));
      total = strlen(n);
      memcpy (n + total, pattern, size);
      total += size;
      strcpy (n + total, match_lines ? IF_BK(line_end_bk, line_end_no_bk)
				     : IF_BK(word_end_bk, word_end_no_bk));
      total += strlen (n + total);
      pattern = motif = n;
      size = total;
    }
  else
    motif = NULL;

  dfacomp (pattern, size, &dfa, 1);
  kwsmusts ();

  free(motif);
}

#ifndef EGREP_PROGRAM
COMPILE_FCT(Gcompile)
{
  return GEAcompile (pattern, size,
		     RE_SYNTAX_GREP | RE_HAT_LISTS_NOT_NEWLINE);
}

COMPILE_FCT(Acompile)
{
  return GEAcompile (pattern, size, RE_SYNTAX_AWK);
}

COMPILE_FCT(Ecompile)
{
  return GEAcompile (pattern, size, RE_SYNTAX_POSIX_EGREP);
}
#endif /* !EGREP_PROGRAM */

EXECUTE_FCT(EGexecute)
{
  char const *buflim, *beg, *end, *match, *best_match, *mb_start;
  char eol = eolbyte;
  int backref, start, len, best_len;
  struct kwsmatch kwsm;
  size_t i, ret_val;
#ifdef MBS_SUPPORT
  if (MB_CUR_MAX > 1)
    {
      if (match_icase)
        {
          /* mbtolower adds a NUL byte at the end.  That will provide
	     space for the sentinel byte dfaexec may add.  */
          char *case_buf = mbtolower (buf, &size);
	  if (start_ptr)
	    start_ptr = case_buf + (start_ptr - buf);
          buf = case_buf;
        }
    }
#endif /* MBS_SUPPORT */

  mb_start = buf;
  buflim = buf + size;

  for (beg = end = buf; end < buflim; beg = end)
    {
      if (!start_ptr)
	{
	  /* We don't care about an exact match.  */
	  if (kwset)
	    {
	      /* Find a possible match using the KWset matcher. */
	      size_t offset = kwsexec (kwset, beg, buflim - beg, &kwsm);
	      if (offset == (size_t) -1)
		goto failure;
	      beg += offset;
	      /* Narrow down to the line containing the candidate, and
		 run it through DFA. */
	      if ((end = memchr(beg, eol, buflim - beg)) != NULL)
	        end++;
              else
                end = buflim;
	      match = beg;
	      while (beg > buf && beg[-1] != eol)
		--beg;
	      if (kwsm.index < kwset_exact_matches)
                {
#ifdef MBS_SUPPORT
                  if (mb_start < beg)
                    mb_start = beg;
                  if (MB_CUR_MAX == 1 || !is_mb_middle (&mb_start, match, buflim))
#endif
                    goto success;
                }
	      if (dfaexec (&dfa, beg, (char *) end, 0, NULL, &backref) == NULL)
		continue;
	    }
	  else
	    {
	      /* No good fixed strings; start with DFA. */
	      char const *next_beg = dfaexec (&dfa, beg, (char *) buflim,
					      0, NULL, &backref);
	      if (next_beg == NULL)
		break;
	      /* Narrow down to the line we've found. */
	      beg = next_beg;
	      if ((end = memchr(beg, eol, buflim - beg)) != NULL)
	        end++;
              else
                end = buflim;
	      while (beg > buf && beg[-1] != eol)
		--beg;
	    }
	  /* Successful, no backreferences encountered! */
	  if (!backref)
	    goto success;
	}
      else
	{
	  /* We are looking for the leftmost (then longest) exact match.
	     We will go through the outer loop only once.  */
	  beg = start_ptr;
	  end = buflim;
	}

      /* If we've made it to this point, this means DFA has seen
	 a probable match, and we need to run it through Regex. */
      best_match = end;
      best_len = 0;
      for (i = 0; i < pcount; i++)
	{
	  patterns[i].regexbuf.not_eol = 0;
	  if (0 <= (start = re_search (&(patterns[i].regexbuf),
				       buf, end - buf - 1,
				       beg - buf, end - beg - 1,
				       &(patterns[i].regs))))
	    {
	      len = patterns[i].regs.end[0] - start;
	      match = buf + start;
	      if (match > best_match)
		continue;
	      if (start_ptr && !match_words)
		goto assess_pattern_match;
	      if ((!match_lines && !match_words)
		  || (match_lines && len == end - beg - 1))
		{
		  match = beg;
		  len = end - beg;
		  goto assess_pattern_match;
		}
	      /* If -w, check if the match aligns with word boundaries.
		 We do this iteratively because:
		 (a) the line may contain more than one occurence of the
		 pattern, and
		 (b) Several alternatives in the pattern might be valid at a
		 given point, and we may need to consider a shorter one to
		 find a word boundary.  */
	      if (match_words)
		while (match <= best_match)
		  {
		    if ((match == buf || !WCHAR ((unsigned char) match[-1]))
			&& (len == end - beg - 1
			    || !WCHAR ((unsigned char) match[len])))
		      goto assess_pattern_match;
		    if (len > 0)
		      {
			/* Try a shorter length anchored at the same place. */
			--len;
			patterns[i].regexbuf.not_eol = 1;
			len = re_match (&(patterns[i].regexbuf),
					buf, match + len - beg, match - buf,
					&(patterns[i].regs));
		      }
		    if (len <= 0)
		      {
			/* Try looking further on. */
			if (match == end - 1)
			  break;
			match++;
			patterns[i].regexbuf.not_eol = 0;
			start = re_search (&(patterns[i].regexbuf),
					   buf, end - buf - 1,
					   match - buf, end - match - 1,
					   &(patterns[i].regs));
			if (start < 0)
			  break;
			len = patterns[i].regs.end[0] - start;
			match = buf + start;
		      }
		  } /* while (match <= best_match) */
	      continue;
	    assess_pattern_match:
	      if (!start_ptr)
		{
		  /* Good enough for a non-exact match.
		     No need to look at further patterns, if any.  */
		  beg = match;
		  goto success_in_len;
		}
	      if (match < best_match || (match == best_match && len > best_len))
		{
		  /* Best exact match:  leftmost, then longest.  */
		  best_match = match;
		  best_len = len;
		}
	    } /* if re_search >= 0 */
	} /* for Regex patterns.  */
	if (best_match < end)
	  {
	    /* We have found an exact match.  We were just
	       waiting for the best one (leftmost then longest).  */
	    beg = best_match;
	    len = best_len;
	    goto success_in_len;
	  }
    } /* for (beg = end ..) */

 failure:
  ret_val = -1;
  goto out;

 success:
  len = end - beg;
 success_in_len:
  *match_size = len;
  ret_val = beg - buf;
 out:
  return ret_val;
}
#endif /* defined(GREP_PROGRAM) || defined(EGREP_PROGRAM) */

#if defined(GREP_PROGRAM) || defined(FGREP_PROGRAM)
COMPILE_FCT(Fcompile)
{
  char const *beg, *end, *lim, *err, *pat;
  size_t psize;

  kwsinit ();
  psize = size;
  
//Patch 0:
if (((match_icase) || (__is_neg(10, &(match_icase), sizeof (match_icase), &(pattern), sizeof (pattern), &(size), sizeof (size), &(pat), sizeof (pat), &(psize), sizeof (psize), &(beg), sizeof (beg), &(lim), sizeof (lim), &(end), sizeof (end), &(err), sizeof (err), &(kwset), sizeof (kwset)))) && (__ctype_get_mb_cur_max()) > 1)
    pat = mbtolower(pattern, &psize);
else
    pat = pattern;

//CodeSeg 1:

  beg = pat;
  do
    {
      for (lim = beg;; ++lim)
	{
	  end = lim;
	  if (lim >= pat + psize)
	    break;
	 if (*lim == '\n')
	   {
	     lim++;
	     break;
	   }
#if HAVE_DOS_FILE_CONTENTS
	 if (*lim == '\r' && lim + 1 < pat + psize && lim[1] == '\n')
	   {
	     lim += 2;
	     break;
	   }
#endif
	}

      if ((err = kwsincr (kwset, beg, end - beg)) != NULL)
	error (EXIT_TROUBLE, 0, "%s", err);
      beg = lim;
    }
  while (beg < pat + psize);

  if ((err = kwsprep (kwset)) != NULL)
    error (EXIT_TROUBLE, 0, "%s", err);
}

EXECUTE_FCT(Fexecute)
{
  char const *beg, *try, *end, *mb_start;
  size_t len;
  char eol = eolbyte;
  struct kwsmatch kwsmatch;
  size_t ret_val;
#ifdef MBS_SUPPORT
  if (MB_CUR_MAX > 1)
    {
      if (match_icase)
        {
          char *case_buf = mbtolower (buf, &size);
	  if (start_ptr)
	    start_ptr = case_buf + (start_ptr - buf);
          buf = case_buf;
        }
    }
#endif /* MBS_SUPPORT */

  for (mb_start = beg = start_ptr ? start_ptr : buf; beg <= buf + size; beg++)
    {
      size_t offset = kwsexec (kwset, beg, buf + size - beg, &kwsmatch);
      if (offset == (size_t) -1)
	goto failure;
#ifdef MBS_SUPPORT
      if (MB_CUR_MAX > 1 && is_mb_middle (&mb_start, beg + offset, buf + size))
        {
          beg = mb_start - 1;
          continue; /* It is a part of multibyte character.  */
        }
#endif /* MBS_SUPPORT */
      beg += offset;
      len = kwsmatch.size[0];
      if (start_ptr && !match_words)
	goto success_in_beg_and_len;
      if (match_lines)
	{
	  if (beg > buf && beg[-1] != eol)
	    continue;
	  if (beg + len < buf + size && beg[len] != eol)
	    continue;
	  goto success;
	}
      else if (match_words)
	for (try = beg; len; )
	  {
	    if (try > buf && WCHAR((unsigned char) try[-1]))
	      break;
	    if (try + len < buf + size && WCHAR((unsigned char) try[len]))
	      {
		offset = kwsexec (kwset, beg, --len, &kwsmatch);
		if (offset == (size_t) -1)
		  break;
		try = beg + offset;
		len = kwsmatch.size[0];
	      }
	    else if (!start_ptr)
	      goto success;
	    else
	      goto success_in_beg_and_len;
	  } /* for (try) */
      else
	goto success;
    } /* for (beg in buf) */

 failure:
  ret_val = -1;
  goto out;

 success:
  if ((end = memchr (beg + len, eol, (buf + size) - (beg + len))) != NULL)
    end++;
  else
    end = buf + size;
  while (buf < beg && beg[-1] != eol)
    --beg;
  len = end - beg;
 success_in_beg_and_len:
  *match_size = len;
  ret_val = beg - buf;
 out:
  return ret_val;
}
#endif /* defined(GREP_PROGRAM) || defined(FGREP_PROGRAM) */

#ifdef GREP_PROGRAM
#if HAVE_LIBPCRE
/* Compiled internal form of a Perl regular expression.  */
static pcre *cre;

/* Additional information about the pattern.  */
static pcre_extra *extra;
#endif

COMPILE_FCT(Pcompile)
{
#if !HAVE_LIBPCRE
  error (EXIT_TROUBLE, 0, "%s",
	 _("support for the -P option is not compiled into "
	   "this --disable-perl-regexp binary"));
#else
  int e;
  char const *ep;
  char *re = xmalloc (4 * size + 7);
  int flags = PCRE_MULTILINE | (match_icase ? PCRE_CASELESS : 0);
  char const *patlim = pattern + size;
  char *n = re;
  char const *p;
  char const *pnul;

  /* FIXME: Remove these restrictions.  */
  if (memchr(pattern, '\n', size))
    error (EXIT_TROUBLE, 0, _("the -P option only supports a single pattern"));

  *n = '\0';
  if (match_lines)
    strcpy (n, "^(");
  if (match_words)
    strcpy (n, "\\b(");
  n += strlen (n);

  /* The PCRE interface doesn't allow NUL bytes in the pattern, so
     replace each NUL byte in the pattern with the four characters
     "\000", removing a preceding backslash if there are an odd
     number of backslashes before the NUL.

     FIXME: This method does not work with some multibyte character
     encodings, notably Shift-JIS, where a multibyte character can end
     in a backslash byte.  */
  for (p = pattern; (pnul = memchr (p, '\0', patlim - p)); p = pnul + 1)
    {
      memcpy (n, p, pnul - p);
      n += pnul - p;
      for (p = pnul; pattern < p && p[-1] == '\\'; p--)
	continue;
      n -= (pnul - p) & 1;
      strcpy (n, "\\000");
      n += 4;
    }

  memcpy (n, p, patlim - p);
  n += patlim - p;
  *n = '\0';
  if (match_words)
    strcpy (n, ")\\b");
  if (match_lines)
    strcpy (n, ")$");

  cre = pcre_compile (re, flags, &ep, &e, pcre_maketables ());
  if (!cre)
    error (EXIT_TROUBLE, 0, "%s", ep);

  extra = pcre_study (cre, 0, &ep);
  if (ep)
    error (EXIT_TROUBLE, 0, "%s", ep);

  free (re);
#endif
}

EXECUTE_FCT(Pexecute)
{
#if !HAVE_LIBPCRE
  abort ();
  return -1;
#else
  /* This array must have at least two elements; everything after that
     is just for performance improvement in pcre_exec.  */
  int sub[300];

  const char *line_buf, *line_end, *line_next;
  int e = PCRE_ERROR_NOMATCH;
  ptrdiff_t start_ofs = start_ptr ? start_ptr - buf : 0;

  /* PCRE can't limit the matching to single lines, therefore we have to
     match each line in the buffer separately.  */
  for (line_next = buf;
       e == PCRE_ERROR_NOMATCH && line_next < buf + size;
       start_ofs -= line_next - line_buf)
    {
      line_buf = line_next;
      line_end = memchr (line_buf, eolbyte, (buf + size) - line_buf);
      if (line_end == NULL)
        line_next = line_end = buf + size;
      else
        line_next = line_end + 1;

      if (start_ptr && start_ptr >= line_end)
        continue;

      e = pcre_exec (cre, extra, line_buf, line_end - line_buf,
                     start_ofs < 0 ? 0 : start_ofs, 0,
                     sub, sizeof sub / sizeof *sub);
    }

  if (e <= 0)
    {
      switch (e)
	{
	case PCRE_ERROR_NOMATCH:
	  return -1;

	case PCRE_ERROR_NOMEMORY:
	  error (EXIT_TROUBLE, 0, _("memory exhausted"));

	default:
	  abort ();
	}
    }
  else
    {
      /* Narrow down to the line we've found.  */
      char const *beg = line_buf + sub[0];
      char const *end = line_buf + sub[1];
      char const *buflim = buf + size;
      char eol = eolbyte;
      if (!start_ptr)
	{
	  /* FIXME: The case when '\n' is not found indicates a bug:
	     Since grep is line oriented, the match should never contain
	     a newline, so there _must_ be a newline following.
	   */
	  if (!(end = memchr (end, eol, buflim - end)))
	    end = buflim;
	  else
	    end++;
	  while (buf < beg && beg[-1] != eol)
	    --beg;
	}

      *match_size = end - beg;
      return beg - buf;
    }
#endif
}

struct matcher const matchers[] = {
  { "default", Gcompile, EGexecute },
  { "grep",    Gcompile, EGexecute },
  { "egrep",   Ecompile, EGexecute },
  { "awk",     Acompile, EGexecute },
  { "fgrep",   Fcompile, Fexecute },
  { "perl",    Pcompile, Pexecute },
  { "", 0, 0 },
};
#endif /* GREP_PROGRAM */

Testing negative cases!
Testing 0 (with abstract condition) ENVIS_NEG
Iteration 0
Running test command:
/home/ubuntu/spr-fast/tools/grep-test.py /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-deccad69-db9d6340/tempworkdir2/src /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-deccad69-db9d6340/tempworkdir2/tests /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-deccad69-db9d6340/tempworkdir2 0  > __res
Opening:/home/ubuntu/spr-fast/tests/corebench/grep/grep-case-deccad69-db9d6340/tempworkdir2/neg.tmp!
NegativeBRANCH RECORD/home/ubuntu/spr-fast/tests/corebench/grep/grep-case-deccad69-db9d6340/tempworkdir2/neg.tmp!
APPENDING TO ISNEG:/home/ubuntu/spr-fast/tests/corebench/grep/grep-case-deccad69-db9d6340/tempworkdir2/neg.tmp!
Branch 0: 0
Iteration 1
Running test command:
/home/ubuntu/spr-fast/tools/grep-test.py /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-deccad69-db9d6340/tempworkdir2/src /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-deccad69-db9d6340/tempworkdir2/tests /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-deccad69-db9d6340/tempworkdir2 0  > __res
Opening:/home/ubuntu/spr-fast/tests/corebench/grep/grep-case-deccad69-db9d6340/tempworkdir2/neg.tmp!
NegativeBRANCH RECORD/home/ubuntu/spr-fast/tests/corebench/grep/grep-case-deccad69-db9d6340/tempworkdir2/neg.tmp!
APPENDING TO ISNEG:/home/ubuntu/spr-fast/tests/corebench/grep/grep-case-deccad69-db9d6340/tempworkdir2/neg.tmp!
Branch 0: 1
Running test command:
/home/ubuntu/spr-fast/tools/grep-test.py /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-deccad69-db9d6340/tempworkdir2/src /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-deccad69-db9d6340/tempworkdir2/tests /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-deccad69-db9d6340/tempworkdir2 0  > __res
a batched test job starts!
Building merged code:
src_file: src/search.c
full src: int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
/* search.c - searching subroutines using dfa, kwset and regex for grep.
   Copyright 1992, 1998, 2000, 2007, 2009-2010 Free Software Foundation, Inc.

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 3, or (at your option)
   any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program; if not, write to the Free Software
   Foundation, Inc., 51 Franklin Street - Fifth Floor, Boston, MA
   02110-1301, USA.  */

/* Written August 1992 by Mike Haertel. */

#include <config.h>

#include <sys/types.h>

#include "mbsupport.h"
#ifdef MBS_SUPPORT
/* We can handle multibyte strings. */
# include <wchar.h>
# include <wctype.h>
#endif

#include "system.h"
#include "grep.h"
#ifndef FGREP_PROGRAM
# include <regex.h>
# include "dfa.h"
#endif
#include "kwset.h"
#include "error.h"
#include "xalloc.h"
#ifdef HAVE_LIBPCRE
# include <pcre.h>
#endif

#define NCHAR (UCHAR_MAX + 1)

/* For -w, we also consider _ to be word constituent.  */
#define WCHAR(C) (ISALNUM(C) || (C) == '_')

/* KWset compiled pattern.  For Ecompile and Gcompile, we compile
   a list of strings, at least one of which is known to occur in
   any string matching the regexp. */
static kwset_t kwset;

static void
kwsinit (void)
{
  static char trans[NCHAR];
  int i;

  if (match_icase && MB_CUR_MAX == 1)
    {
      for (i = 0; i < NCHAR; ++i)
        trans[i] = TOLOWER (i);

      kwset = kwsalloc (trans);
    }
  else
    kwset = kwsalloc (NULL);

  if (!kwset)
    xalloc_die ();
}

#ifdef MBS_SUPPORT
/* Convert the *N-byte string, BEG, to lowercase, and write the
   NUL-terminated result into malloc'd storage.  Upon success, set *N
   to the length (in bytes) of the resulting string (not including the
   trailing NUL byte), and return a pointer to the lowercase string.
   Upon memory allocation failure, this function exits.

   Note that while this function returns a pointer to malloc'd storage,
   the caller must not free it, since this function retains a pointer
   to the buffer and reuses it on any subsequent call.  As a consequence,
   this function is not thread-safe.  */
static char *
mbtolower (const char *beg, size_t *n)
{
  static char *out;
  static size_t outalloc;
  size_t outlen, mb_cur_max;
  mbstate_t is, os;
  const char *end;
  char *p;

  if (*n > outalloc)
    {
      out = xrealloc (out, *n);
      outalloc = *n;
    }

  memset (&is, 0, sizeof (is));
  memset (&os, 0, sizeof (os));
  end = beg + *n;

  mb_cur_max = MB_CUR_MAX;
  p = out;
  outlen = 0;
  while (beg < end)
    {
      wchar_t wc;
      size_t mbclen = mbrtowc(&wc, beg, end - beg, &is);
      if (outlen + mb_cur_max >= outalloc)
        {
          out = x2nrealloc (out, &outalloc, 1);
          p = out + outlen;
        }

      if (mbclen == (size_t) -1 || mbclen == (size_t) -2 || mbclen == 0)
        {
          /* An invalid sequence, or a truncated multi-octet character.
             We treat it as a single-octet character.  */
          *p++ = *beg++;
          outlen++;
          memset (&is, 0, sizeof (is));
          memset (&os, 0, sizeof (os));
        }
      else
        {
          beg += mbclen;
          mbclen = wcrtomb (p, towlower ((wint_t) wc), &os);
          p += mbclen;
          outlen += mbclen;
        }
    }

  *n = p - out;
  *p++ = 0;
  return out;
}
#endif


#ifndef FGREP_PROGRAM
/* DFA compiled regexp. */
static struct dfa dfa;

/* The Regex compiled patterns.  */
static struct patterns
{
  /* Regex compiled regexp. */
  struct re_pattern_buffer regexbuf;
  struct re_registers regs; /* This is here on account of a BRAIN-DEAD
			       Q@#%!# library interface in regex.c.  */
} patterns0;

struct patterns *patterns;
size_t pcount;

void
dfaerror (char const *mesg)
{
  error (EXIT_TROUBLE, 0, "%s", mesg);
}

/* Number of compiled fixed strings known to exactly match the regexp.
   If kwsexec returns < kwset_exact_matches, then we don't need to
   call the regexp matcher at all. */
static int kwset_exact_matches;

static char const *
kwsincr_case (const char *must)
{
  const char *buf;
  size_t n;

  n = strlen (must);
#ifdef MBS_SUPPORT
  if (match_icase && MB_CUR_MAX > 1)
    buf = mbtolower (must, &n);
  else
#endif
    buf = must;
  return kwsincr (kwset, buf, n);
}

/* If the DFA turns out to have some set of fixed strings one of
   which must occur in the match, then we build a kwset matcher
   to find those strings, and thus quickly filter out impossible
   matches. */
static void
kwsmusts (void)
{
  struct dfamust const *dm;
  char const *err;

  if (dfa.musts)
    {
      kwsinit ();
      /* First, we compile in the substrings known to be exact
	 matches.  The kwset matcher will return the index
	 of the matching string that it chooses. */
      for (dm = dfa.musts; dm; dm = dm->next)
	{
	  if (!dm->exact)
	    continue;
	  ++kwset_exact_matches;
	  if ((err = kwsincr_case (dm->must)) != NULL)
	    error (EXIT_TROUBLE, 0, "%s", err);
	}
      /* Now, we compile the substrings that will require
	 the use of the regexp matcher.  */
      for (dm = dfa.musts; dm; dm = dm->next)
	{
	  if (dm->exact)
	    continue;
	  if ((err = kwsincr_case (dm->must)) != NULL)
	    error (EXIT_TROUBLE, 0, "%s", err);
	}
      if ((err = kwsprep (kwset)) != NULL)
	error (EXIT_TROUBLE, 0, "%s", err);
    }
}
#endif /* !FGREP_PROGRAM */

#ifdef MBS_SUPPORT

static bool
is_mb_middle(const char **good, const char *buf, const char *end)
{
  const char *p = *good;
  const char *prev = p;
  mbstate_t cur_state;

  /* TODO: can be optimized for UTF-8.  */
  memset(&cur_state, 0, sizeof(mbstate_t));
  while (p < buf)
    {
      size_t mbclen = mbrlen(p, end - p, &cur_state);

      /* Store the beginning of the previous complete multibyte character.  */
      if (mbclen != (size_t) -2)
        prev = p;

      if (mbclen == (size_t) -1 || mbclen == (size_t) -2 || mbclen == 0)
	{
	  /* An invalid sequence, or a truncated multibyte character.
	     We treat it as a single byte character.  */
	  mbclen = 1;
	}
      p += mbclen;
    }

  *good = prev;
  return p > buf;
}
#endif /* MBS_SUPPORT */

#if defined(GREP_PROGRAM) || defined(EGREP_PROGRAM)
#ifdef EGREP_PROGRAM
COMPILE_FCT(Ecompile)
{
  reg_syntax_t syntax_bits = RE_SYNTAX_POSIX_EGREP;
#else
/* No __VA_ARGS__ in C89.  So we have to do it this way.  */
static COMPILE_RET
GEAcompile (char const *pattern, size_t size, reg_syntax_t syntax_bits)
{
#endif /* EGREP_PROGRAM */
  const char *err;
  const char *p, *sep;
  size_t total = size;
  char *motif;

  if (match_icase)
    syntax_bits |= RE_ICASE;
  re_set_syntax (syntax_bits);
  dfasyntax (syntax_bits, match_icase, eolbyte);

  /* For GNU regex compiler we have to pass the patterns separately to detect
     errors like "[\nallo\n]\n".  The patterns here are "[", "allo" and "]"
     GNU regex should have raise a syntax error.  The same for backref, where
     the backref should have been local to each pattern.  */
  p = pattern;
  do
    {
      size_t len;
      sep = memchr (p, '\n', total);
      if (sep)
	{
	  len = sep - p;
	  sep++;
	  total -= (len + 1);
	}
      else
	{
	  len = total;
	  total = 0;
	}

      patterns = realloc (patterns, (pcount + 1) * sizeof (*patterns));
      if (patterns == NULL)
	error (EXIT_TROUBLE, errno, _("memory exhausted"));
      patterns[pcount] = patterns0;

      if ((err = re_compile_pattern (p, len,
				    &(patterns[pcount].regexbuf))) != NULL)
	error (EXIT_TROUBLE, 0, "%s", err);
      pcount++;

      p = sep;
    } while (sep && total != 0);

  /* In the match_words and match_lines cases, we use a different pattern
     for the DFA matcher that will quickly throw out cases that won't work.
     Then if DFA succeeds we do some hairy stuff using the regex matcher
     to decide whether the match should really count. */
  if (match_words || match_lines)
    {
      static char const line_beg_no_bk[] = "^(";
      static char const line_end_no_bk[] = ")$";
      static char const word_beg_no_bk[] = "(^|[^[:alnum:]_])(";
      static char const word_end_no_bk[] = ")([^[:alnum:]_]|$)";
#ifdef EGREP_PROGRAM
# define IF_BK(x, y) (y)
      char *n = xmalloc (sizeof word_beg_no_bk - 1 + size + sizeof word_end_no_bk);
#else
      static char const line_beg_bk[] = "^\\(";
      static char const line_end_bk[] = "\\)$";
      static char const word_beg_bk[] = "\\(^\\|[^[:alnum:]_]\\)\\(";
      static char const word_end_bk[] = "\\)\\([^[:alnum:]_]\\|$\\)";
      int bk = !(syntax_bits & RE_NO_BK_PARENS);
# define IF_BK(x, y) ((bk) ? (x) : (y))
      char *n = xmalloc (sizeof word_beg_bk - 1 + size + sizeof word_end_bk);
#endif /* EGREP_PROGRAM */

      strcpy (n, match_lines ? IF_BK(line_beg_bk, line_beg_no_bk)
			     : IF_BK(word_beg_bk, word_beg_no_bk));
      total = strlen(n);
      memcpy (n + total, pattern, size);
      total += size;
      strcpy (n + total, match_lines ? IF_BK(line_end_bk, line_end_no_bk)
				     : IF_BK(word_end_bk, word_end_no_bk));
      total += strlen (n + total);
      pattern = motif = n;
      size = total;
    }
  else
    motif = NULL;

  dfacomp (pattern, size, &dfa, 1);
  kwsmusts ();

  free(motif);
}

#ifndef EGREP_PROGRAM
COMPILE_FCT(Gcompile)
{
  return GEAcompile (pattern, size,
		     RE_SYNTAX_GREP | RE_HAT_LISTS_NOT_NEWLINE);
}

COMPILE_FCT(Acompile)
{
  return GEAcompile (pattern, size, RE_SYNTAX_AWK);
}

COMPILE_FCT(Ecompile)
{
  return GEAcompile (pattern, size, RE_SYNTAX_POSIX_EGREP);
}
#endif /* !EGREP_PROGRAM */

EXECUTE_FCT(EGexecute)
{
  char const *buflim, *beg, *end, *match, *best_match, *mb_start;
  char eol = eolbyte;
  int backref, start, len, best_len;
  struct kwsmatch kwsm;
  size_t i, ret_val;
#ifdef MBS_SUPPORT
  if (MB_CUR_MAX > 1)
    {
      if (match_icase)
        {
          /* mbtolower adds a NUL byte at the end.  That will provide
	     space for the sentinel byte dfaexec may add.  */
          char *case_buf = mbtolower (buf, &size);
	  if (start_ptr)
	    start_ptr = case_buf + (start_ptr - buf);
          buf = case_buf;
        }
    }
#endif /* MBS_SUPPORT */

  mb_start = buf;
  buflim = buf + size;

  for (beg = end = buf; end < buflim; beg = end)
    {
      if (!start_ptr)
	{
	  /* We don't care about an exact match.  */
	  if (kwset)
	    {
	      /* Find a possible match using the KWset matcher. */
	      size_t offset = kwsexec (kwset, beg, buflim - beg, &kwsm);
	      if (offset == (size_t) -1)
		goto failure;
	      beg += offset;
	      /* Narrow down to the line containing the candidate, and
		 run it through DFA. */
	      if ((end = memchr(beg, eol, buflim - beg)) != NULL)
	        end++;
              else
                end = buflim;
	      match = beg;
	      while (beg > buf && beg[-1] != eol)
		--beg;
	      if (kwsm.index < kwset_exact_matches)
                {
#ifdef MBS_SUPPORT
                  if (mb_start < beg)
                    mb_start = beg;
                  if (MB_CUR_MAX == 1 || !is_mb_middle (&mb_start, match, buflim))
#endif
                    goto success;
                }
	      if (dfaexec (&dfa, beg, (char *) end, 0, NULL, &backref) == NULL)
		continue;
	    }
	  else
	    {
	      /* No good fixed strings; start with DFA. */
	      char const *next_beg = dfaexec (&dfa, beg, (char *) buflim,
					      0, NULL, &backref);
	      if (next_beg == NULL)
		break;
	      /* Narrow down to the line we've found. */
	      beg = next_beg;
	      if ((end = memchr(beg, eol, buflim - beg)) != NULL)
	        end++;
              else
                end = buflim;
	      while (beg > buf && beg[-1] != eol)
		--beg;
	    }
	  /* Successful, no backreferences encountered! */
	  if (!backref)
	    goto success;
	}
      else
	{
	  /* We are looking for the leftmost (then longest) exact match.
	     We will go through the outer loop only once.  */
	  beg = start_ptr;
	  end = buflim;
	}

      /* If we've made it to this point, this means DFA has seen
	 a probable match, and we need to run it through Regex. */
      best_match = end;
      best_len = 0;
      for (i = 0; i < pcount; i++)
	{
	  patterns[i].regexbuf.not_eol = 0;
	  if (0 <= (start = re_search (&(patterns[i].regexbuf),
				       buf, end - buf - 1,
				       beg - buf, end - beg - 1,
				       &(patterns[i].regs))))
	    {
	      len = patterns[i].regs.end[0] - start;
	      match = buf + start;
	      if (match > best_match)
		continue;
	      if (start_ptr && !match_words)
		goto assess_pattern_match;
	      if ((!match_lines && !match_words)
		  || (match_lines && len == end - beg - 1))
		{
		  match = beg;
		  len = end - beg;
		  goto assess_pattern_match;
		}
	      /* If -w, check if the match aligns with word boundaries.
		 We do this iteratively because:
		 (a) the line may contain more than one occurence of the
		 pattern, and
		 (b) Several alternatives in the pattern might be valid at a
		 given point, and we may need to consider a shorter one to
		 find a word boundary.  */
	      if (match_words)
		while (match <= best_match)
		  {
		    if ((match == buf || !WCHAR ((unsigned char) match[-1]))
			&& (len == end - beg - 1
			    || !WCHAR ((unsigned char) match[len])))
		      goto assess_pattern_match;
		    if (len > 0)
		      {
			/* Try a shorter length anchored at the same place. */
			--len;
			patterns[i].regexbuf.not_eol = 1;
			len = re_match (&(patterns[i].regexbuf),
					buf, match + len - beg, match - buf,
					&(patterns[i].regs));
		      }
		    if (len <= 0)
		      {
			/* Try looking further on. */
			if (match == end - 1)
			  break;
			match++;
			patterns[i].regexbuf.not_eol = 0;
			start = re_search (&(patterns[i].regexbuf),
					   buf, end - buf - 1,
					   match - buf, end - match - 1,
					   &(patterns[i].regs));
			if (start < 0)
			  break;
			len = patterns[i].regs.end[0] - start;
			match = buf + start;
		      }
		  } /* while (match <= best_match) */
	      continue;
	    assess_pattern_match:
	      if (!start_ptr)
		{
		  /* Good enough for a non-exact match.
		     No need to look at further patterns, if any.  */
		  beg = match;
		  goto success_in_len;
		}
	      if (match < best_match || (match == best_match && len > best_len))
		{
		  /* Best exact match:  leftmost, then longest.  */
		  best_match = match;
		  best_len = len;
		}
	    } /* if re_search >= 0 */
	} /* for Regex patterns.  */
	if (best_match < end)
	  {
	    /* We have found an exact match.  We were just
	       waiting for the best one (leftmost then longest).  */
	    beg = best_match;
	    len = best_len;
	    goto success_in_len;
	  }
    } /* for (beg = end ..) */

 failure:
  ret_val = -1;
  goto out;

 success:
  len = end - beg;
 success_in_len:
  *match_size = len;
  ret_val = beg - buf;
 out:
  return ret_val;
}
#endif /* defined(GREP_PROGRAM) || defined(EGREP_PROGRAM) */

#if defined(GREP_PROGRAM) || defined(FGREP_PROGRAM)
COMPILE_FCT(Fcompile)
{
  char const *beg, *end, *lim, *err, *pat;
  size_t psize;

  kwsinit ();
  psize = size;
  if (match_icase && MB_CUR_MAX > 1)
    pat = mbtolower (pattern, &psize);
  else
    pat = pattern;

  beg = pat;
  do
    {
      for (lim = beg;; ++lim)
	{
	  end = lim;
	  //prophet generated patch
	  if (__get_mutant()==0) {
	  if ((lim >= pat + psize) && !(__is_neg(10, &(lim), sizeof (lim), &(pat), sizeof (pat), &(psize), sizeof (psize), &(end), sizeof (end), &(beg), sizeof (beg), &(pattern), sizeof (pattern), &(match_icase), sizeof (match_icase), &(size), sizeof (size), &(err), sizeof (err), &(kwset), sizeof (kwset))))
	      break;
	  }
	  else if (__get_mutant()==1) {
	  if ((lim >= pat + psize) || (__is_neg(10, &(lim), sizeof (lim), &(pat), sizeof (pat), &(psize), sizeof (psize), &(end), sizeof (end), &(beg), sizeof (beg), &(pattern), sizeof (pattern), &(match_icase), sizeof (match_icase), &(size), sizeof (size), &(err), sizeof (err), &(kwset), sizeof (kwset))))
	      break;
	  }
	 if (*lim == '\n')
	   {
	     lim++;
	     break;
	   }
#if HAVE_DOS_FILE_CONTENTS
	 if (*lim == '\r' && lim + 1 < pat + psize && lim[1] == '\n')
	   {
	     lim += 2;
	     break;
	   }
#endif
	}

      if ((err = kwsincr (kwset, beg, end - beg)) != NULL)
	error (EXIT_TROUBLE, 0, "%s", err);
      beg = lim;
    }
  while (beg < pat + psize);

  if ((err = kwsprep (kwset)) != NULL)
    error (EXIT_TROUBLE, 0, "%s", err);
}

EXECUTE_FCT(Fexecute)
{
  char const *beg, *try, *end, *mb_start;
  size_t len;
  char eol = eolbyte;
  struct kwsmatch kwsmatch;
  size_t ret_val;
#ifdef MBS_SUPPORT
  if (MB_CUR_MAX > 1)
    {
      if (match_icase)
        {
          char *case_buf = mbtolower (buf, &size);
	  if (start_ptr)
	    start_ptr = case_buf + (start_ptr - buf);
          buf = case_buf;
        }
    }
#endif /* MBS_SUPPORT */

  for (mb_start = beg = start_ptr ? start_ptr : buf; beg <= buf + size; beg++)
    {
      size_t offset = kwsexec (kwset, beg, buf + size - beg, &kwsmatch);
      if (offset == (size_t) -1)
	goto failure;
#ifdef MBS_SUPPORT
      if (MB_CUR_MAX > 1 && is_mb_middle (&mb_start, beg + offset, buf + size))
        {
          beg = mb_start - 1;
          continue; /* It is a part of multibyte character.  */
        }
#endif /* MBS_SUPPORT */
      beg += offset;
      len = kwsmatch.size[0];
      if (start_ptr && !match_words)
	goto success_in_beg_and_len;
      if (match_lines)
	{
	  if (beg > buf && beg[-1] != eol)
	    continue;
	  if (beg + len < buf + size && beg[len] != eol)
	    continue;
	  goto success;
	}
      else if (match_words)
	for (try = beg; len; )
	  {
	    if (try > buf && WCHAR((unsigned char) try[-1]))
	      break;
	    if (try + len < buf + size && WCHAR((unsigned char) try[len]))
	      {
		offset = kwsexec (kwset, beg, --len, &kwsmatch);
		if (offset == (size_t) -1)
		  break;
		try = beg + offset;
		len = kwsmatch.size[0];
	      }
	    else if (!start_ptr)
	      goto success;
	    else
	      goto success_in_beg_and_len;
	  } /* for (try) */
      else
	goto success;
    } /* for (beg in buf) */

 failure:
  ret_val = -1;
  goto out;

 success:
  if ((end = memchr (beg + len, eol, (buf + size) - (beg + len))) != NULL)
    end++;
  else
    end = buf + size;
  while (buf < beg && beg[-1] != eol)
    --beg;
  len = end - beg;
 success_in_beg_and_len:
  *match_size = len;
  ret_val = beg - buf;
 out:
  return ret_val;
}
#endif /* defined(GREP_PROGRAM) || defined(FGREP_PROGRAM) */

#ifdef GREP_PROGRAM
#if HAVE_LIBPCRE
/* Compiled internal form of a Perl regular expression.  */
static pcre *cre;

/* Additional information about the pattern.  */
static pcre_extra *extra;
#endif

COMPILE_FCT(Pcompile)
{
#if !HAVE_LIBPCRE
  error (EXIT_TROUBLE, 0, "%s",
	 _("support for the -P option is not compiled into "
	   "this --disable-perl-regexp binary"));
#else
  int e;
  char const *ep;
  char *re = xmalloc (4 * size + 7);
  int flags = PCRE_MULTILINE | (match_icase ? PCRE_CASELESS : 0);
  char const *patlim = pattern + size;
  char *n = re;
  char const *p;
  char const *pnul;

  /* FIXME: Remove these restrictions.  */
  if (memchr(pattern, '\n', size))
    error (EXIT_TROUBLE, 0, _("the -P option only supports a single pattern"));

  *n = '\0';
  if (match_lines)
    strcpy (n, "^(");
  if (match_words)
    strcpy (n, "\\b(");
  n += strlen (n);

  /* The PCRE interface doesn't allow NUL bytes in the pattern, so
     replace each NUL byte in the pattern with the four characters
     "\000", removing a preceding backslash if there are an odd
     number of backslashes before the NUL.

     FIXME: This method does not work with some multibyte character
     encodings, notably Shift-JIS, where a multibyte character can end
     in a backslash byte.  */
  for (p = pattern; (pnul = memchr (p, '\0', patlim - p)); p = pnul + 1)
    {
      memcpy (n, p, pnul - p);
      n += pnul - p;
      for (p = pnul; pattern < p && p[-1] == '\\'; p--)
	continue;
      n -= (pnul - p) & 1;
      strcpy (n, "\\000");
      n += 4;
    }

  memcpy (n, p, patlim - p);
  n += patlim - p;
  *n = '\0';
  if (match_words)
    strcpy (n, ")\\b");
  if (match_lines)
    strcpy (n, ")$");

  cre = pcre_compile (re, flags, &ep, &e, pcre_maketables ());
  if (!cre)
    error (EXIT_TROUBLE, 0, "%s", ep);

  extra = pcre_study (cre, 0, &ep);
  if (ep)
    error (EXIT_TROUBLE, 0, "%s", ep);

  free (re);
#endif
}

EXECUTE_FCT(Pexecute)
{
#if !HAVE_LIBPCRE
  abort ();
  return -1;
#else
  /* This array must have at least two elements; everything after that
     is just for performance improvement in pcre_exec.  */
  int sub[300];

  const char *line_buf, *line_end, *line_next;
  int e = PCRE_ERROR_NOMATCH;
  ptrdiff_t start_ofs = start_ptr ? start_ptr - buf : 0;

  /* PCRE can't limit the matching to single lines, therefore we have to
     match each line in the buffer separately.  */
  for (line_next = buf;
       e == PCRE_ERROR_NOMATCH && line_next < buf + size;
       start_ofs -= line_next - line_buf)
    {
      line_buf = line_next;
      line_end = memchr (line_buf, eolbyte, (buf + size) - line_buf);
      if (line_end == NULL)
        line_next = line_end = buf + size;
      else
        line_next = line_end + 1;

      if (start_ptr && start_ptr >= line_end)
        continue;

      e = pcre_exec (cre, extra, line_buf, line_end - line_buf,
                     start_ofs < 0 ? 0 : start_ofs, 0,
                     sub, sizeof sub / sizeof *sub);
    }

  if (e <= 0)
    {
      switch (e)
	{
	case PCRE_ERROR_NOMATCH:
	  return -1;

	case PCRE_ERROR_NOMEMORY:
	  error (EXIT_TROUBLE, 0, _("memory exhausted"));

	default:
	  abort ();
	}
    }
  else
    {
      /* Narrow down to the line we've found.  */
      char const *beg = line_buf + sub[0];
      char const *end = line_buf + sub[1];
      char const *buflim = buf + size;
      char eol = eolbyte;
      if (!start_ptr)
	{
	  /* FIXME: The case when '\n' is not found indicates a bug:
	     Since grep is line oriented, the match should never contain
	     a newline, so there _must_ be a newline following.
	   */
	  if (!(end = memchr (end, eol, buflim - end)))
	    end = buflim;
	  else
	    end++;
	  while (buf < beg && beg[-1] != eol)
	    --beg;
	}

      *match_size = end - beg;
      return beg - buf;
    }
#endif
}

struct matcher const matchers[] = {
  { "default", Gcompile, EGexecute },
  { "grep",    Gcompile, EGexecute },
  { "egrep",   Ecompile, EGexecute },
  { "awk",     Acompile, EGexecute },
  { "fgrep",   Fcompile, Fexecute },
  { "perl",    Pcompile, Pexecute },
  { "", 0, 0 },
};
#endif /* GREP_PROGRAM */

Building:src at:
/home/ubuntu/spr-fast/tests/corebench/grep/grep-case-deccad69-db9d6340/tempworkdir2/srcMerged code building succ, going to invoke tester!
CondTester, Testing instance id 17:
//src_file:src/search.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
/* search.c - searching subroutines using dfa, kwset and regex for grep.
   Copyright 1992, 1998, 2000, 2007, 2009-2010 Free Software Foundation, Inc.

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 3, or (at your option)
   any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program; if not, write to the Free Software
   Foundation, Inc., 51 Franklin Street - Fifth Floor, Boston, MA
   02110-1301, USA.  */

/* Written August 1992 by Mike Haertel. */

#include <config.h>

#include <sys/types.h>

#include "mbsupport.h"
#ifdef MBS_SUPPORT
/* We can handle multibyte strings. */
# include <wchar.h>
# include <wctype.h>
#endif

#include "system.h"
#include "grep.h"
#ifndef FGREP_PROGRAM
# include <regex.h>
# include "dfa.h"
#endif
#include "kwset.h"
#include "error.h"
#include "xalloc.h"
#ifdef HAVE_LIBPCRE
# include <pcre.h>
#endif

#define NCHAR (UCHAR_MAX + 1)

/* For -w, we also consider _ to be word constituent.  */
#define WCHAR(C) (ISALNUM(C) || (C) == '_')

/* KWset compiled pattern.  For Ecompile and Gcompile, we compile
   a list of strings, at least one of which is known to occur in
   any string matching the regexp. */
static kwset_t kwset;

static void
kwsinit (void)
{
  static char trans[NCHAR];
  int i;

  if (match_icase && MB_CUR_MAX == 1)
    {
      for (i = 0; i < NCHAR; ++i)
        trans[i] = TOLOWER (i);

      kwset = kwsalloc (trans);
    }
  else
    kwset = kwsalloc (NULL);

  if (!kwset)
    xalloc_die ();
}

#ifdef MBS_SUPPORT
/* Convert the *N-byte string, BEG, to lowercase, and write the
   NUL-terminated result into malloc'd storage.  Upon success, set *N
   to the length (in bytes) of the resulting string (not including the
   trailing NUL byte), and return a pointer to the lowercase string.
   Upon memory allocation failure, this function exits.

   Note that while this function returns a pointer to malloc'd storage,
   the caller must not free it, since this function retains a pointer
   to the buffer and reuses it on any subsequent call.  As a consequence,
   this function is not thread-safe.  */
static char *
mbtolower (const char *beg, size_t *n)
{
  static char *out;
  static size_t outalloc;
  size_t outlen, mb_cur_max;
  mbstate_t is, os;
  const char *end;
  char *p;

  if (*n > outalloc)
    {
      out = xrealloc (out, *n);
      outalloc = *n;
    }

  memset (&is, 0, sizeof (is));
  memset (&os, 0, sizeof (os));
  end = beg + *n;

  mb_cur_max = MB_CUR_MAX;
  p = out;
  outlen = 0;
  while (beg < end)
    {
      wchar_t wc;
      size_t mbclen = mbrtowc(&wc, beg, end - beg, &is);
      if (outlen + mb_cur_max >= outalloc)
        {
          out = x2nrealloc (out, &outalloc, 1);
          p = out + outlen;
        }

      if (mbclen == (size_t) -1 || mbclen == (size_t) -2 || mbclen == 0)
        {
          /* An invalid sequence, or a truncated multi-octet character.
             We treat it as a single-octet character.  */
          *p++ = *beg++;
          outlen++;
          memset (&is, 0, sizeof (is));
          memset (&os, 0, sizeof (os));
        }
      else
        {
          beg += mbclen;
          mbclen = wcrtomb (p, towlower ((wint_t) wc), &os);
          p += mbclen;
          outlen += mbclen;
        }
    }

  *n = p - out;
  *p++ = 0;
  return out;
}
#endif


#ifndef FGREP_PROGRAM
/* DFA compiled regexp. */
static struct dfa dfa;

/* The Regex compiled patterns.  */
static struct patterns
{
  /* Regex compiled regexp. */
  struct re_pattern_buffer regexbuf;
  struct re_registers regs; /* This is here on account of a BRAIN-DEAD
			       Q@#%!# library interface in regex.c.  */
} patterns0;

struct patterns *patterns;
size_t pcount;

void
dfaerror (char const *mesg)
{
  error (EXIT_TROUBLE, 0, "%s", mesg);
}

/* Number of compiled fixed strings known to exactly match the regexp.
   If kwsexec returns < kwset_exact_matches, then we don't need to
   call the regexp matcher at all. */
static int kwset_exact_matches;

static char const *
kwsincr_case (const char *must)
{
  const char *buf;
  size_t n;

  n = strlen (must);
#ifdef MBS_SUPPORT
  if (match_icase && MB_CUR_MAX > 1)
    buf = mbtolower (must, &n);
  else
#endif
    buf = must;
  return kwsincr (kwset, buf, n);
}

/* If the DFA turns out to have some set of fixed strings one of
   which must occur in the match, then we build a kwset matcher
   to find those strings, and thus quickly filter out impossible
   matches. */
static void
kwsmusts (void)
{
  struct dfamust const *dm;
  char const *err;

  if (dfa.musts)
    {
      kwsinit ();
      /* First, we compile in the substrings known to be exact
	 matches.  The kwset matcher will return the index
	 of the matching string that it chooses. */
      for (dm = dfa.musts; dm; dm = dm->next)
	{
	  if (!dm->exact)
	    continue;
	  ++kwset_exact_matches;
	  if ((err = kwsincr_case (dm->must)) != NULL)
	    error (EXIT_TROUBLE, 0, "%s", err);
	}
      /* Now, we compile the substrings that will require
	 the use of the regexp matcher.  */
      for (dm = dfa.musts; dm; dm = dm->next)
	{
	  if (dm->exact)
	    continue;
	  if ((err = kwsincr_case (dm->must)) != NULL)
	    error (EXIT_TROUBLE, 0, "%s", err);
	}
      if ((err = kwsprep (kwset)) != NULL)
	error (EXIT_TROUBLE, 0, "%s", err);
    }
}
#endif /* !FGREP_PROGRAM */

#ifdef MBS_SUPPORT

static bool
is_mb_middle(const char **good, const char *buf, const char *end)
{
  const char *p = *good;
  const char *prev = p;
  mbstate_t cur_state;

  /* TODO: can be optimized for UTF-8.  */
  memset(&cur_state, 0, sizeof(mbstate_t));
  while (p < buf)
    {
      size_t mbclen = mbrlen(p, end - p, &cur_state);

      /* Store the beginning of the previous complete multibyte character.  */
      if (mbclen != (size_t) -2)
        prev = p;

      if (mbclen == (size_t) -1 || mbclen == (size_t) -2 || mbclen == 0)
	{
	  /* An invalid sequence, or a truncated multibyte character.
	     We treat it as a single byte character.  */
	  mbclen = 1;
	}
      p += mbclen;
    }

  *good = prev;
  return p > buf;
}
#endif /* MBS_SUPPORT */

#if defined(GREP_PROGRAM) || defined(EGREP_PROGRAM)
#ifdef EGREP_PROGRAM
COMPILE_FCT(Ecompile)
{
  reg_syntax_t syntax_bits = RE_SYNTAX_POSIX_EGREP;
#else
/* No __VA_ARGS__ in C89.  So we have to do it this way.  */
static COMPILE_RET
GEAcompile (char const *pattern, size_t size, reg_syntax_t syntax_bits)
{
#endif /* EGREP_PROGRAM */
  const char *err;
  const char *p, *sep;
  size_t total = size;
  char *motif;

  if (match_icase)
    syntax_bits |= RE_ICASE;
  re_set_syntax (syntax_bits);
  dfasyntax (syntax_bits, match_icase, eolbyte);

  /* For GNU regex compiler we have to pass the patterns separately to detect
     errors like "[\nallo\n]\n".  The patterns here are "[", "allo" and "]"
     GNU regex should have raise a syntax error.  The same for backref, where
     the backref should have been local to each pattern.  */
  p = pattern;
  do
    {
      size_t len;
      sep = memchr (p, '\n', total);
      if (sep)
	{
	  len = sep - p;
	  sep++;
	  total -= (len + 1);
	}
      else
	{
	  len = total;
	  total = 0;
	}

      patterns = realloc (patterns, (pcount + 1) * sizeof (*patterns));
      if (patterns == NULL)
	error (EXIT_TROUBLE, errno, _("memory exhausted"));
      patterns[pcount] = patterns0;

      if ((err = re_compile_pattern (p, len,
				    &(patterns[pcount].regexbuf))) != NULL)
	error (EXIT_TROUBLE, 0, "%s", err);
      pcount++;

      p = sep;
    } while (sep && total != 0);

  /* In the match_words and match_lines cases, we use a different pattern
     for the DFA matcher that will quickly throw out cases that won't work.
     Then if DFA succeeds we do some hairy stuff using the regex matcher
     to decide whether the match should really count. */
  if (match_words || match_lines)
    {
      static char const line_beg_no_bk[] = "^(";
      static char const line_end_no_bk[] = ")$";
      static char const word_beg_no_bk[] = "(^|[^[:alnum:]_])(";
      static char const word_end_no_bk[] = ")([^[:alnum:]_]|$)";
#ifdef EGREP_PROGRAM
# define IF_BK(x, y) (y)
      char *n = xmalloc (sizeof word_beg_no_bk - 1 + size + sizeof word_end_no_bk);
#else
      static char const line_beg_bk[] = "^\\(";
      static char const line_end_bk[] = "\\)$";
      static char const word_beg_bk[] = "\\(^\\|[^[:alnum:]_]\\)\\(";
      static char const word_end_bk[] = "\\)\\([^[:alnum:]_]\\|$\\)";
      int bk = !(syntax_bits & RE_NO_BK_PARENS);
# define IF_BK(x, y) ((bk) ? (x) : (y))
      char *n = xmalloc (sizeof word_beg_bk - 1 + size + sizeof word_end_bk);
#endif /* EGREP_PROGRAM */

      strcpy (n, match_lines ? IF_BK(line_beg_bk, line_beg_no_bk)
			     : IF_BK(word_beg_bk, word_beg_no_bk));
      total = strlen(n);
      memcpy (n + total, pattern, size);
      total += size;
      strcpy (n + total, match_lines ? IF_BK(line_end_bk, line_end_no_bk)
				     : IF_BK(word_end_bk, word_end_no_bk));
      total += strlen (n + total);
      pattern = motif = n;
      size = total;
    }
  else
    motif = NULL;

  dfacomp (pattern, size, &dfa, 1);
  kwsmusts ();

  free(motif);
}

#ifndef EGREP_PROGRAM
COMPILE_FCT(Gcompile)
{
  return GEAcompile (pattern, size,
		     RE_SYNTAX_GREP | RE_HAT_LISTS_NOT_NEWLINE);
}

COMPILE_FCT(Acompile)
{
  return GEAcompile (pattern, size, RE_SYNTAX_AWK);
}

COMPILE_FCT(Ecompile)
{
  return GEAcompile (pattern, size, RE_SYNTAX_POSIX_EGREP);
}
#endif /* !EGREP_PROGRAM */

EXECUTE_FCT(EGexecute)
{
  char const *buflim, *beg, *end, *match, *best_match, *mb_start;
  char eol = eolbyte;
  int backref, start, len, best_len;
  struct kwsmatch kwsm;
  size_t i, ret_val;
#ifdef MBS_SUPPORT
  if (MB_CUR_MAX > 1)
    {
      if (match_icase)
        {
          /* mbtolower adds a NUL byte at the end.  That will provide
	     space for the sentinel byte dfaexec may add.  */
          char *case_buf = mbtolower (buf, &size);
	  if (start_ptr)
	    start_ptr = case_buf + (start_ptr - buf);
          buf = case_buf;
        }
    }
#endif /* MBS_SUPPORT */

  mb_start = buf;
  buflim = buf + size;

  for (beg = end = buf; end < buflim; beg = end)
    {
      if (!start_ptr)
	{
	  /* We don't care about an exact match.  */
	  if (kwset)
	    {
	      /* Find a possible match using the KWset matcher. */
	      size_t offset = kwsexec (kwset, beg, buflim - beg, &kwsm);
	      if (offset == (size_t) -1)
		goto failure;
	      beg += offset;
	      /* Narrow down to the line containing the candidate, and
		 run it through DFA. */
	      if ((end = memchr(beg, eol, buflim - beg)) != NULL)
	        end++;
              else
                end = buflim;
	      match = beg;
	      while (beg > buf && beg[-1] != eol)
		--beg;
	      if (kwsm.index < kwset_exact_matches)
                {
#ifdef MBS_SUPPORT
                  if (mb_start < beg)
                    mb_start = beg;
                  if (MB_CUR_MAX == 1 || !is_mb_middle (&mb_start, match, buflim))
#endif
                    goto success;
                }
	      if (dfaexec (&dfa, beg, (char *) end, 0, NULL, &backref) == NULL)
		continue;
	    }
	  else
	    {
	      /* No good fixed strings; start with DFA. */
	      char const *next_beg = dfaexec (&dfa, beg, (char *) buflim,
					      0, NULL, &backref);
	      if (next_beg == NULL)
		break;
	      /* Narrow down to the line we've found. */
	      beg = next_beg;
	      if ((end = memchr(beg, eol, buflim - beg)) != NULL)
	        end++;
              else
                end = buflim;
	      while (beg > buf && beg[-1] != eol)
		--beg;
	    }
	  /* Successful, no backreferences encountered! */
	  if (!backref)
	    goto success;
	}
      else
	{
	  /* We are looking for the leftmost (then longest) exact match.
	     We will go through the outer loop only once.  */
	  beg = start_ptr;
	  end = buflim;
	}

      /* If we've made it to this point, this means DFA has seen
	 a probable match, and we need to run it through Regex. */
      best_match = end;
      best_len = 0;
      for (i = 0; i < pcount; i++)
	{
	  patterns[i].regexbuf.not_eol = 0;
	  if (0 <= (start = re_search (&(patterns[i].regexbuf),
				       buf, end - buf - 1,
				       beg - buf, end - beg - 1,
				       &(patterns[i].regs))))
	    {
	      len = patterns[i].regs.end[0] - start;
	      match = buf + start;
	      if (match > best_match)
		continue;
	      if (start_ptr && !match_words)
		goto assess_pattern_match;
	      if ((!match_lines && !match_words)
		  || (match_lines && len == end - beg - 1))
		{
		  match = beg;
		  len = end - beg;
		  goto assess_pattern_match;
		}
	      /* If -w, check if the match aligns with word boundaries.
		 We do this iteratively because:
		 (a) the line may contain more than one occurence of the
		 pattern, and
		 (b) Several alternatives in the pattern might be valid at a
		 given point, and we may need to consider a shorter one to
		 find a word boundary.  */
	      if (match_words)
		while (match <= best_match)
		  {
		    if ((match == buf || !WCHAR ((unsigned char) match[-1]))
			&& (len == end - beg - 1
			    || !WCHAR ((unsigned char) match[len])))
		      goto assess_pattern_match;
		    if (len > 0)
		      {
			/* Try a shorter length anchored at the same place. */
			--len;
			patterns[i].regexbuf.not_eol = 1;
			len = re_match (&(patterns[i].regexbuf),
					buf, match + len - beg, match - buf,
					&(patterns[i].regs));
		      }
		    if (len <= 0)
		      {
			/* Try looking further on. */
			if (match == end - 1)
			  break;
			match++;
			patterns[i].regexbuf.not_eol = 0;
			start = re_search (&(patterns[i].regexbuf),
					   buf, end - buf - 1,
					   match - buf, end - match - 1,
					   &(patterns[i].regs));
			if (start < 0)
			  break;
			len = patterns[i].regs.end[0] - start;
			match = buf + start;
		      }
		  } /* while (match <= best_match) */
	      continue;
	    assess_pattern_match:
	      if (!start_ptr)
		{
		  /* Good enough for a non-exact match.
		     No need to look at further patterns, if any.  */
		  beg = match;
		  goto success_in_len;
		}
	      if (match < best_match || (match == best_match && len > best_len))
		{
		  /* Best exact match:  leftmost, then longest.  */
		  best_match = match;
		  best_len = len;
		}
	    } /* if re_search >= 0 */
	} /* for Regex patterns.  */
	if (best_match < end)
	  {
	    /* We have found an exact match.  We were just
	       waiting for the best one (leftmost then longest).  */
	    beg = best_match;
	    len = best_len;
	    goto success_in_len;
	  }
    } /* for (beg = end ..) */

 failure:
  ret_val = -1;
  goto out;

 success:
  len = end - beg;
 success_in_len:
  *match_size = len;
  ret_val = beg - buf;
 out:
  return ret_val;
}
#endif /* defined(GREP_PROGRAM) || defined(EGREP_PROGRAM) */

#if defined(GREP_PROGRAM) || defined(FGREP_PROGRAM)
COMPILE_FCT(Fcompile)
{
  char const *beg, *end, *lim, *err, *pat;
  size_t psize;

  kwsinit ();
  psize = size;
  if (match_icase && MB_CUR_MAX > 1)
    pat = mbtolower (pattern, &psize);
  else
    pat = pattern;

  beg = pat;
  do
    {
      for (lim = beg;; ++lim)
	{
	  end = lim;
	  
//Patch 0:
if ((lim >= pat + psize) && !(__is_neg(10, &(lim), sizeof (lim), &(pat), sizeof (pat), &(psize), sizeof (psize), &(end), sizeof (end), &(beg), sizeof (beg), &(pattern), sizeof (pattern), &(match_icase), sizeof (match_icase), &(size), sizeof (size), &(err), sizeof (err), &(kwset), sizeof (kwset))))
    break;

//CodeSeg 1:
	 if (*lim == '\n')
	   {
	     lim++;
	     break;
	   }
#if HAVE_DOS_FILE_CONTENTS
	 if (*lim == '\r' && lim + 1 < pat + psize && lim[1] == '\n')
	   {
	     lim += 2;
	     break;
	   }
#endif
	}

      if ((err = kwsincr (kwset, beg, end - beg)) != NULL)
	error (EXIT_TROUBLE, 0, "%s", err);
      beg = lim;
    }
  while (beg < pat + psize);

  if ((err = kwsprep (kwset)) != NULL)
    error (EXIT_TROUBLE, 0, "%s", err);
}

EXECUTE_FCT(Fexecute)
{
  char const *beg, *try, *end, *mb_start;
  size_t len;
  char eol = eolbyte;
  struct kwsmatch kwsmatch;
  size_t ret_val;
#ifdef MBS_SUPPORT
  if (MB_CUR_MAX > 1)
    {
      if (match_icase)
        {
          char *case_buf = mbtolower (buf, &size);
	  if (start_ptr)
	    start_ptr = case_buf + (start_ptr - buf);
          buf = case_buf;
        }
    }
#endif /* MBS_SUPPORT */

  for (mb_start = beg = start_ptr ? start_ptr : buf; beg <= buf + size; beg++)
    {
      size_t offset = kwsexec (kwset, beg, buf + size - beg, &kwsmatch);
      if (offset == (size_t) -1)
	goto failure;
#ifdef MBS_SUPPORT
      if (MB_CUR_MAX > 1 && is_mb_middle (&mb_start, beg + offset, buf + size))
        {
          beg = mb_start - 1;
          continue; /* It is a part of multibyte character.  */
        }
#endif /* MBS_SUPPORT */
      beg += offset;
      len = kwsmatch.size[0];
      if (start_ptr && !match_words)
	goto success_in_beg_and_len;
      if (match_lines)
	{
	  if (beg > buf && beg[-1] != eol)
	    continue;
	  if (beg + len < buf + size && beg[len] != eol)
	    continue;
	  goto success;
	}
      else if (match_words)
	for (try = beg; len; )
	  {
	    if (try > buf && WCHAR((unsigned char) try[-1]))
	      break;
	    if (try + len < buf + size && WCHAR((unsigned char) try[len]))
	      {
		offset = kwsexec (kwset, beg, --len, &kwsmatch);
		if (offset == (size_t) -1)
		  break;
		try = beg + offset;
		len = kwsmatch.size[0];
	      }
	    else if (!start_ptr)
	      goto success;
	    else
	      goto success_in_beg_and_len;
	  } /* for (try) */
      else
	goto success;
    } /* for (beg in buf) */

 failure:
  ret_val = -1;
  goto out;

 success:
  if ((end = memchr (beg + len, eol, (buf + size) - (beg + len))) != NULL)
    end++;
  else
    end = buf + size;
  while (buf < beg && beg[-1] != eol)
    --beg;
  len = end - beg;
 success_in_beg_and_len:
  *match_size = len;
  ret_val = beg - buf;
 out:
  return ret_val;
}
#endif /* defined(GREP_PROGRAM) || defined(FGREP_PROGRAM) */

#ifdef GREP_PROGRAM
#if HAVE_LIBPCRE
/* Compiled internal form of a Perl regular expression.  */
static pcre *cre;

/* Additional information about the pattern.  */
static pcre_extra *extra;
#endif

COMPILE_FCT(Pcompile)
{
#if !HAVE_LIBPCRE
  error (EXIT_TROUBLE, 0, "%s",
	 _("support for the -P option is not compiled into "
	   "this --disable-perl-regexp binary"));
#else
  int e;
  char const *ep;
  char *re = xmalloc (4 * size + 7);
  int flags = PCRE_MULTILINE | (match_icase ? PCRE_CASELESS : 0);
  char const *patlim = pattern + size;
  char *n = re;
  char const *p;
  char const *pnul;

  /* FIXME: Remove these restrictions.  */
  if (memchr(pattern, '\n', size))
    error (EXIT_TROUBLE, 0, _("the -P option only supports a single pattern"));

  *n = '\0';
  if (match_lines)
    strcpy (n, "^(");
  if (match_words)
    strcpy (n, "\\b(");
  n += strlen (n);

  /* The PCRE interface doesn't allow NUL bytes in the pattern, so
     replace each NUL byte in the pattern with the four characters
     "\000", removing a preceding backslash if there are an odd
     number of backslashes before the NUL.

     FIXME: This method does not work with some multibyte character
     encodings, notably Shift-JIS, where a multibyte character can end
     in a backslash byte.  */
  for (p = pattern; (pnul = memchr (p, '\0', patlim - p)); p = pnul + 1)
    {
      memcpy (n, p, pnul - p);
      n += pnul - p;
      for (p = pnul; pattern < p && p[-1] == '\\'; p--)
	continue;
      n -= (pnul - p) & 1;
      strcpy (n, "\\000");
      n += 4;
    }

  memcpy (n, p, patlim - p);
  n += patlim - p;
  *n = '\0';
  if (match_words)
    strcpy (n, ")\\b");
  if (match_lines)
    strcpy (n, ")$");

  cre = pcre_compile (re, flags, &ep, &e, pcre_maketables ());
  if (!cre)
    error (EXIT_TROUBLE, 0, "%s", ep);

  extra = pcre_study (cre, 0, &ep);
  if (ep)
    error (EXIT_TROUBLE, 0, "%s", ep);

  free (re);
#endif
}

EXECUTE_FCT(Pexecute)
{
#if !HAVE_LIBPCRE
  abort ();
  return -1;
#else
  /* This array must have at least two elements; everything after that
     is just for performance improvement in pcre_exec.  */
  int sub[300];

  const char *line_buf, *line_end, *line_next;
  int e = PCRE_ERROR_NOMATCH;
  ptrdiff_t start_ofs = start_ptr ? start_ptr - buf : 0;

  /* PCRE can't limit the matching to single lines, therefore we have to
     match each line in the buffer separately.  */
  for (line_next = buf;
       e == PCRE_ERROR_NOMATCH && line_next < buf + size;
       start_ofs -= line_next - line_buf)
    {
      line_buf = line_next;
      line_end = memchr (line_buf, eolbyte, (buf + size) - line_buf);
      if (line_end == NULL)
        line_next = line_end = buf + size;
      else
        line_next = line_end + 1;

      if (start_ptr && start_ptr >= line_end)
        continue;

      e = pcre_exec (cre, extra, line_buf, line_end - line_buf,
                     start_ofs < 0 ? 0 : start_ofs, 0,
                     sub, sizeof sub / sizeof *sub);
    }

  if (e <= 0)
    {
      switch (e)
	{
	case PCRE_ERROR_NOMATCH:
	  return -1;

	case PCRE_ERROR_NOMEMORY:
	  error (EXIT_TROUBLE, 0, _("memory exhausted"));

	default:
	  abort ();
	}
    }
  else
    {
      /* Narrow down to the line we've found.  */
      char const *beg = line_buf + sub[0];
      char const *end = line_buf + sub[1];
      char const *buflim = buf + size;
      char eol = eolbyte;
      if (!start_ptr)
	{
	  /* FIXME: The case when '\n' is not found indicates a bug:
	     Since grep is line oriented, the match should never contain
	     a newline, so there _must_ be a newline following.
	   */
	  if (!(end = memchr (end, eol, buflim - end)))
	    end = buflim;
	  else
	    end++;
	  while (buf < beg && beg[-1] != eol)
	    --beg;
	}

      *match_size = end - beg;
      return beg - buf;
    }
#endif
}

struct matcher const matchers[] = {
  { "default", Gcompile, EGexecute },
  { "grep",    Gcompile, EGexecute },
  { "egrep",   Ecompile, EGexecute },
  { "awk",     Acompile, EGexecute },
  { "fgrep",   Fcompile, Fexecute },
  { "perl",    Pcompile, Pexecute },
  { "", 0, 0 },
};
#endif /* GREP_PROGRAM */

Testing negative cases!
Testing 0 (with abstract condition) ENVIS_NEG
Iteration 0
Running test command:
/home/ubuntu/spr-fast/tools/grep-test.py /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-deccad69-db9d6340/tempworkdir2/src /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-deccad69-db9d6340/tempworkdir2/tests /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-deccad69-db9d6340/tempworkdir2 0  > __res
Opening:/home/ubuntu/spr-fast/tests/corebench/grep/grep-case-deccad69-db9d6340/tempworkdir2/neg.tmp!
NegativeBRANCH RECORD/home/ubuntu/spr-fast/tests/corebench/grep/grep-case-deccad69-db9d6340/tempworkdir2/neg.tmp!
APPENDING TO ISNEG:/home/ubuntu/spr-fast/tests/corebench/grep/grep-case-deccad69-db9d6340/tempworkdir2/neg.tmp!
Branch 0: 0
Iteration 1
Running test command:
/home/ubuntu/spr-fast/tools/grep-test.py /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-deccad69-db9d6340/tempworkdir2/src /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-deccad69-db9d6340/tempworkdir2/tests /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-deccad69-db9d6340/tempworkdir2 0  > __res
Opening:/home/ubuntu/spr-fast/tests/corebench/grep/grep-case-deccad69-db9d6340/tempworkdir2/neg.tmp!
NegativeBRANCH RECORD/home/ubuntu/spr-fast/tests/corebench/grep/grep-case-deccad69-db9d6340/tempworkdir2/neg.tmp!
APPENDING TO ISNEG:/home/ubuntu/spr-fast/tests/corebench/grep/grep-case-deccad69-db9d6340/tempworkdir2/neg.tmp!
Branch 0: 1
Branch 1: 0
Passed in iteration!
Passed Negative Cases wiht CondTestder!
Testing positive cases!
Running test command:
/home/ubuntu/spr-fast/tools/grep-test.py /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-deccad69-db9d6340/tempworkdir2/src /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-deccad69-db9d6340/tempworkdir2/tests /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-deccad69-db9d6340/tempworkdir2 9  > __res
Running test command:
/home/ubuntu/spr-fast/tools/grep-test.py /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-deccad69-db9d6340/tempworkdir2/src /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-deccad69-db9d6340/tempworkdir2/tests /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-deccad69-db9d6340/tempworkdir2 3  > __res
Running test command:
/home/ubuntu/spr-fast/tools/grep-test.py /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-deccad69-db9d6340/tempworkdir2/src /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-deccad69-db9d6340/tempworkdir2/tests /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-deccad69-db9d6340/tempworkdir2 4  > __res
Running test command:
/home/ubuntu/spr-fast/tools/grep-test.py /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-deccad69-db9d6340/tempworkdir2/src /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-deccad69-db9d6340/tempworkdir2/tests /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-deccad69-db9d6340/tempworkdir2 5  > __res
Running test command:
/home/ubuntu/spr-fast/tools/grep-test.py /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-deccad69-db9d6340/tempworkdir2/src /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-deccad69-db9d6340/tempworkdir2/tests /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-deccad69-db9d6340/tempworkdir2 6  > __res
Running test command:
/home/ubuntu/spr-fast/tools/grep-test.py /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-deccad69-db9d6340/tempworkdir2/src /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-deccad69-db9d6340/tempworkdir2/tests /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-deccad69-db9d6340/tempworkdir2 11  > __res
Running test command:
/home/ubuntu/spr-fast/tools/grep-test.py /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-deccad69-db9d6340/tempworkdir2/src /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-deccad69-db9d6340/tempworkdir2/tests /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-deccad69-db9d6340/tempworkdir2 12  > __res
Running test command:
/home/ubuntu/spr-fast/tools/grep-test.py /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-deccad69-db9d6340/tempworkdir2/src /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-deccad69-db9d6340/tempworkdir2/tests /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-deccad69-db9d6340/tempworkdir2 13  > __res
Running test command:
/home/ubuntu/spr-fast/tools/grep-test.py /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-deccad69-db9d6340/tempworkdir2/src /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-deccad69-db9d6340/tempworkdir2/tests /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-deccad69-db9d6340/tempworkdir2 14  > __res
Running test command:
/home/ubuntu/spr-fast/tools/grep-test.py /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-deccad69-db9d6340/tempworkdir2/src /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-deccad69-db9d6340/tempworkdir2/tests /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-deccad69-db9d6340/tempworkdir2 15  > __res
Running test command:
/home/ubuntu/spr-fast/tools/grep-test.py /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-deccad69-db9d6340/tempworkdir2/src /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-deccad69-db9d6340/tempworkdir2/tests /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-deccad69-db9d6340/tempworkdir2 17  > __res
Running test command:
/home/ubuntu/spr-fast/tools/grep-test.py /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-deccad69-db9d6340/tempworkdir2/src /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-deccad69-db9d6340/tempworkdir2/tests /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-deccad69-db9d6340/tempworkdir2 18  > __res
Running test command:
/home/ubuntu/spr-fast/tools/grep-test.py /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-deccad69-db9d6340/tempworkdir2/src /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-deccad69-db9d6340/tempworkdir2/tests /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-deccad69-db9d6340/tempworkdir2 20  > __res
Running test command:
/home/ubuntu/spr-fast/tools/grep-test.py /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-deccad69-db9d6340/tempworkdir2/src /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-deccad69-db9d6340/tempworkdir2/tests /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-deccad69-db9d6340/tempworkdir2 22  > __res
Running test command:
/home/ubuntu/spr-fast/tools/grep-test.py /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-deccad69-db9d6340/tempworkdir2/src /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-deccad69-db9d6340/tempworkdir2/tests /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-deccad69-db9d6340/tempworkdir2 23  > __res
Running test command:
/home/ubuntu/spr-fast/tools/grep-test.py /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-deccad69-db9d6340/tempworkdir2/src /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-deccad69-db9d6340/tempworkdir2/tests /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-deccad69-db9d6340/tempworkdir2 25  > __res
Passed Positive Cases
Collect values for post processing!
WRITING TO ISNEG:/home/ubuntu/spr-fast/tests/corebench/grep/grep-case-deccad69-db9d6340/tempworkdir2/neg.tmp!
Running test command:
/home/ubuntu/spr-fast/tools/grep-test.py /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-deccad69-db9d6340/tempworkdir2/src /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-deccad69-db9d6340/tempworkdir2/tests /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-deccad69-db9d6340/tempworkdir2 0  > __res
Running test command:
/home/ubuntu/spr-fast/tools/grep-test.py /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-deccad69-db9d6340/tempworkdir2/src /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-deccad69-db9d6340/tempworkdir2/tests /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-deccad69-db9d6340/tempworkdir2 3  > __res
Running test command:
/home/ubuntu/spr-fast/tools/grep-test.py /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-deccad69-db9d6340/tempworkdir2/src /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-deccad69-db9d6340/tempworkdir2/tests /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-deccad69-db9d6340/tempworkdir2 4  > __res
Running test command:
/home/ubuntu/spr-fast/tools/grep-test.py /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-deccad69-db9d6340/tempworkdir2/src /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-deccad69-db9d6340/tempworkdir2/tests /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-deccad69-db9d6340/tempworkdir2 5  > __res
Running test command:
/home/ubuntu/spr-fast/tools/grep-test.py /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-deccad69-db9d6340/tempworkdir2/src /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-deccad69-db9d6340/tempworkdir2/tests /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-deccad69-db9d6340/tempworkdir2 6  > __res
Running test command:
/home/ubuntu/spr-fast/tools/grep-test.py /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-deccad69-db9d6340/tempworkdir2/src /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-deccad69-db9d6340/tempworkdir2/tests /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-deccad69-db9d6340/tempworkdir2 9  > __res
Running test command:
/home/ubuntu/spr-fast/tools/grep-test.py /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-deccad69-db9d6340/tempworkdir2/src /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-deccad69-db9d6340/tempworkdir2/tests /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-deccad69-db9d6340/tempworkdir2 11  > __res
Running test command:
/home/ubuntu/spr-fast/tools/grep-test.py /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-deccad69-db9d6340/tempworkdir2/src /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-deccad69-db9d6340/tempworkdir2/tests /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-deccad69-db9d6340/tempworkdir2 12  > __res
Running test command:
/home/ubuntu/spr-fast/tools/grep-test.py /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-deccad69-db9d6340/tempworkdir2/src /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-deccad69-db9d6340/tempworkdir2/tests /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-deccad69-db9d6340/tempworkdir2 13  > __res
Running test command:
/home/ubuntu/spr-fast/tools/grep-test.py /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-deccad69-db9d6340/tempworkdir2/src /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-deccad69-db9d6340/tempworkdir2/tests /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-deccad69-db9d6340/tempworkdir2 14  > __res
Running test command:
/home/ubuntu/spr-fast/tools/grep-test.py /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-deccad69-db9d6340/tempworkdir2/src /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-deccad69-db9d6340/tempworkdir2/tests /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-deccad69-db9d6340/tempworkdir2 15  > __res
Running test command:
/home/ubuntu/spr-fast/tools/grep-test.py /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-deccad69-db9d6340/tempworkdir2/src /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-deccad69-db9d6340/tempworkdir2/tests /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-deccad69-db9d6340/tempworkdir2 17  > __res
Running test command:
/home/ubuntu/spr-fast/tools/grep-test.py /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-deccad69-db9d6340/tempworkdir2/src /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-deccad69-db9d6340/tempworkdir2/tests /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-deccad69-db9d6340/tempworkdir2 18  > __res
Running test command:
/home/ubuntu/spr-fast/tools/grep-test.py /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-deccad69-db9d6340/tempworkdir2/src /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-deccad69-db9d6340/tempworkdir2/tests /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-deccad69-db9d6340/tempworkdir2 20  > __res
Running test command:
/home/ubuntu/spr-fast/tools/grep-test.py /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-deccad69-db9d6340/tempworkdir2/src /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-deccad69-db9d6340/tempworkdir2/tests /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-deccad69-db9d6340/tempworkdir2 22  > __res
Running test command:
/home/ubuntu/spr-fast/tools/grep-test.py /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-deccad69-db9d6340/tempworkdir2/src /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-deccad69-db9d6340/tempworkdir2/tests /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-deccad69-db9d6340/tempworkdir2 23  > __res
Running test command:
/home/ubuntu/spr-fast/tools/grep-test.py /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-deccad69-db9d6340/tempworkdir2/src /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-deccad69-db9d6340/tempworkdir2/tests /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-deccad69-db9d6340/tempworkdir2 25  > __res
Passed!
CondTester, Testing instance id 20:
//src_file:src/search.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
/* search.c - searching subroutines using dfa, kwset and regex for grep.
   Copyright 1992, 1998, 2000, 2007, 2009-2010 Free Software Foundation, Inc.

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 3, or (at your option)
   any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program; if not, write to the Free Software
   Foundation, Inc., 51 Franklin Street - Fifth Floor, Boston, MA
   02110-1301, USA.  */

/* Written August 1992 by Mike Haertel. */

#include <config.h>

#include <sys/types.h>

#include "mbsupport.h"
#ifdef MBS_SUPPORT
/* We can handle multibyte strings. */
# include <wchar.h>
# include <wctype.h>
#endif

#include "system.h"
#include "grep.h"
#ifndef FGREP_PROGRAM
# include <regex.h>
# include "dfa.h"
#endif
#include "kwset.h"
#include "error.h"
#include "xalloc.h"
#ifdef HAVE_LIBPCRE
# include <pcre.h>
#endif

#define NCHAR (UCHAR_MAX + 1)

/* For -w, we also consider _ to be word constituent.  */
#define WCHAR(C) (ISALNUM(C) || (C) == '_')

/* KWset compiled pattern.  For Ecompile and Gcompile, we compile
   a list of strings, at least one of which is known to occur in
   any string matching the regexp. */
static kwset_t kwset;

static void
kwsinit (void)
{
  static char trans[NCHAR];
  int i;

  if (match_icase && MB_CUR_MAX == 1)
    {
      for (i = 0; i < NCHAR; ++i)
        trans[i] = TOLOWER (i);

      kwset = kwsalloc (trans);
    }
  else
    kwset = kwsalloc (NULL);

  if (!kwset)
    xalloc_die ();
}

#ifdef MBS_SUPPORT
/* Convert the *N-byte string, BEG, to lowercase, and write the
   NUL-terminated result into malloc'd storage.  Upon success, set *N
   to the length (in bytes) of the resulting string (not including the
   trailing NUL byte), and return a pointer to the lowercase string.
   Upon memory allocation failure, this function exits.

   Note that while this function returns a pointer to malloc'd storage,
   the caller must not free it, since this function retains a pointer
   to the buffer and reuses it on any subsequent call.  As a consequence,
   this function is not thread-safe.  */
static char *
mbtolower (const char *beg, size_t *n)
{
  static char *out;
  static size_t outalloc;
  size_t outlen, mb_cur_max;
  mbstate_t is, os;
  const char *end;
  char *p;

  if (*n > outalloc)
    {
      out = xrealloc (out, *n);
      outalloc = *n;
    }

  memset (&is, 0, sizeof (is));
  memset (&os, 0, sizeof (os));
  end = beg + *n;

  mb_cur_max = MB_CUR_MAX;
  p = out;
  outlen = 0;
  while (beg < end)
    {
      wchar_t wc;
      size_t mbclen = mbrtowc(&wc, beg, end - beg, &is);
      if (outlen + mb_cur_max >= outalloc)
        {
          out = x2nrealloc (out, &outalloc, 1);
          p = out + outlen;
        }

      if (mbclen == (size_t) -1 || mbclen == (size_t) -2 || mbclen == 0)
        {
          /* An invalid sequence, or a truncated multi-octet character.
             We treat it as a single-octet character.  */
          *p++ = *beg++;
          outlen++;
          memset (&is, 0, sizeof (is));
          memset (&os, 0, sizeof (os));
        }
      else
        {
          beg += mbclen;
          mbclen = wcrtomb (p, towlower ((wint_t) wc), &os);
          p += mbclen;
          outlen += mbclen;
        }
    }

  *n = p - out;
  *p++ = 0;
  return out;
}
#endif


#ifndef FGREP_PROGRAM
/* DFA compiled regexp. */
static struct dfa dfa;

/* The Regex compiled patterns.  */
static struct patterns
{
  /* Regex compiled regexp. */
  struct re_pattern_buffer regexbuf;
  struct re_registers regs; /* This is here on account of a BRAIN-DEAD
			       Q@#%!# library interface in regex.c.  */
} patterns0;

struct patterns *patterns;
size_t pcount;

void
dfaerror (char const *mesg)
{
  error (EXIT_TROUBLE, 0, "%s", mesg);
}

/* Number of compiled fixed strings known to exactly match the regexp.
   If kwsexec returns < kwset_exact_matches, then we don't need to
   call the regexp matcher at all. */
static int kwset_exact_matches;

static char const *
kwsincr_case (const char *must)
{
  const char *buf;
  size_t n;

  n = strlen (must);
#ifdef MBS_SUPPORT
  if (match_icase && MB_CUR_MAX > 1)
    buf = mbtolower (must, &n);
  else
#endif
    buf = must;
  return kwsincr (kwset, buf, n);
}

/* If the DFA turns out to have some set of fixed strings one of
   which must occur in the match, then we build a kwset matcher
   to find those strings, and thus quickly filter out impossible
   matches. */
static void
kwsmusts (void)
{
  struct dfamust const *dm;
  char const *err;

  if (dfa.musts)
    {
      kwsinit ();
      /* First, we compile in the substrings known to be exact
	 matches.  The kwset matcher will return the index
	 of the matching string that it chooses. */
      for (dm = dfa.musts; dm; dm = dm->next)
	{
	  if (!dm->exact)
	    continue;
	  ++kwset_exact_matches;
	  if ((err = kwsincr_case (dm->must)) != NULL)
	    error (EXIT_TROUBLE, 0, "%s", err);
	}
      /* Now, we compile the substrings that will require
	 the use of the regexp matcher.  */
      for (dm = dfa.musts; dm; dm = dm->next)
	{
	  if (dm->exact)
	    continue;
	  if ((err = kwsincr_case (dm->must)) != NULL)
	    error (EXIT_TROUBLE, 0, "%s", err);
	}
      if ((err = kwsprep (kwset)) != NULL)
	error (EXIT_TROUBLE, 0, "%s", err);
    }
}
#endif /* !FGREP_PROGRAM */

#ifdef MBS_SUPPORT

static bool
is_mb_middle(const char **good, const char *buf, const char *end)
{
  const char *p = *good;
  const char *prev = p;
  mbstate_t cur_state;

  /* TODO: can be optimized for UTF-8.  */
  memset(&cur_state, 0, sizeof(mbstate_t));
  while (p < buf)
    {
      size_t mbclen = mbrlen(p, end - p, &cur_state);

      /* Store the beginning of the previous complete multibyte character.  */
      if (mbclen != (size_t) -2)
        prev = p;

      if (mbclen == (size_t) -1 || mbclen == (size_t) -2 || mbclen == 0)
	{
	  /* An invalid sequence, or a truncated multibyte character.
	     We treat it as a single byte character.  */
	  mbclen = 1;
	}
      p += mbclen;
    }

  *good = prev;
  return p > buf;
}
#endif /* MBS_SUPPORT */

#if defined(GREP_PROGRAM) || defined(EGREP_PROGRAM)
#ifdef EGREP_PROGRAM
COMPILE_FCT(Ecompile)
{
  reg_syntax_t syntax_bits = RE_SYNTAX_POSIX_EGREP;
#else
/* No __VA_ARGS__ in C89.  So we have to do it this way.  */
static COMPILE_RET
GEAcompile (char const *pattern, size_t size, reg_syntax_t syntax_bits)
{
#endif /* EGREP_PROGRAM */
  const char *err;
  const char *p, *sep;
  size_t total = size;
  char *motif;

  if (match_icase)
    syntax_bits |= RE_ICASE;
  re_set_syntax (syntax_bits);
  dfasyntax (syntax_bits, match_icase, eolbyte);

  /* For GNU regex compiler we have to pass the patterns separately to detect
     errors like "[\nallo\n]\n".  The patterns here are "[", "allo" and "]"
     GNU regex should have raise a syntax error.  The same for backref, where
     the backref should have been local to each pattern.  */
  p = pattern;
  do
    {
      size_t len;
      sep = memchr (p, '\n', total);
      if (sep)
	{
	  len = sep - p;
	  sep++;
	  total -= (len + 1);
	}
      else
	{
	  len = total;
	  total = 0;
	}

      patterns = realloc (patterns, (pcount + 1) * sizeof (*patterns));
      if (patterns == NULL)
	error (EXIT_TROUBLE, errno, _("memory exhausted"));
      patterns[pcount] = patterns0;

      if ((err = re_compile_pattern (p, len,
				    &(patterns[pcount].regexbuf))) != NULL)
	error (EXIT_TROUBLE, 0, "%s", err);
      pcount++;

      p = sep;
    } while (sep && total != 0);

  /* In the match_words and match_lines cases, we use a different pattern
     for the DFA matcher that will quickly throw out cases that won't work.
     Then if DFA succeeds we do some hairy stuff using the regex matcher
     to decide whether the match should really count. */
  if (match_words || match_lines)
    {
      static char const line_beg_no_bk[] = "^(";
      static char const line_end_no_bk[] = ")$";
      static char const word_beg_no_bk[] = "(^|[^[:alnum:]_])(";
      static char const word_end_no_bk[] = ")([^[:alnum:]_]|$)";
#ifdef EGREP_PROGRAM
# define IF_BK(x, y) (y)
      char *n = xmalloc (sizeof word_beg_no_bk - 1 + size + sizeof word_end_no_bk);
#else
      static char const line_beg_bk[] = "^\\(";
      static char const line_end_bk[] = "\\)$";
      static char const word_beg_bk[] = "\\(^\\|[^[:alnum:]_]\\)\\(";
      static char const word_end_bk[] = "\\)\\([^[:alnum:]_]\\|$\\)";
      int bk = !(syntax_bits & RE_NO_BK_PARENS);
# define IF_BK(x, y) ((bk) ? (x) : (y))
      char *n = xmalloc (sizeof word_beg_bk - 1 + size + sizeof word_end_bk);
#endif /* EGREP_PROGRAM */

      strcpy (n, match_lines ? IF_BK(line_beg_bk, line_beg_no_bk)
			     : IF_BK(word_beg_bk, word_beg_no_bk));
      total = strlen(n);
      memcpy (n + total, pattern, size);
      total += size;
      strcpy (n + total, match_lines ? IF_BK(line_end_bk, line_end_no_bk)
				     : IF_BK(word_end_bk, word_end_no_bk));
      total += strlen (n + total);
      pattern = motif = n;
      size = total;
    }
  else
    motif = NULL;

  dfacomp (pattern, size, &dfa, 1);
  kwsmusts ();

  free(motif);
}

#ifndef EGREP_PROGRAM
COMPILE_FCT(Gcompile)
{
  return GEAcompile (pattern, size,
		     RE_SYNTAX_GREP | RE_HAT_LISTS_NOT_NEWLINE);
}

COMPILE_FCT(Acompile)
{
  return GEAcompile (pattern, size, RE_SYNTAX_AWK);
}

COMPILE_FCT(Ecompile)
{
  return GEAcompile (pattern, size, RE_SYNTAX_POSIX_EGREP);
}
#endif /* !EGREP_PROGRAM */

EXECUTE_FCT(EGexecute)
{
  char const *buflim, *beg, *end, *match, *best_match, *mb_start;
  char eol = eolbyte;
  int backref, start, len, best_len;
  struct kwsmatch kwsm;
  size_t i, ret_val;
#ifdef MBS_SUPPORT
  if (MB_CUR_MAX > 1)
    {
      if (match_icase)
        {
          /* mbtolower adds a NUL byte at the end.  That will provide
	     space for the sentinel byte dfaexec may add.  */
          char *case_buf = mbtolower (buf, &size);
	  if (start_ptr)
	    start_ptr = case_buf + (start_ptr - buf);
          buf = case_buf;
        }
    }
#endif /* MBS_SUPPORT */

  mb_start = buf;
  buflim = buf + size;

  for (beg = end = buf; end < buflim; beg = end)
    {
      if (!start_ptr)
	{
	  /* We don't care about an exact match.  */
	  if (kwset)
	    {
	      /* Find a possible match using the KWset matcher. */
	      size_t offset = kwsexec (kwset, beg, buflim - beg, &kwsm);
	      if (offset == (size_t) -1)
		goto failure;
	      beg += offset;
	      /* Narrow down to the line containing the candidate, and
		 run it through DFA. */
	      if ((end = memchr(beg, eol, buflim - beg)) != NULL)
	        end++;
              else
                end = buflim;
	      match = beg;
	      while (beg > buf && beg[-1] != eol)
		--beg;
	      if (kwsm.index < kwset_exact_matches)
                {
#ifdef MBS_SUPPORT
                  if (mb_start < beg)
                    mb_start = beg;
                  if (MB_CUR_MAX == 1 || !is_mb_middle (&mb_start, match, buflim))
#endif
                    goto success;
                }
	      if (dfaexec (&dfa, beg, (char *) end, 0, NULL, &backref) == NULL)
		continue;
	    }
	  else
	    {
	      /* No good fixed strings; start with DFA. */
	      char const *next_beg = dfaexec (&dfa, beg, (char *) buflim,
					      0, NULL, &backref);
	      if (next_beg == NULL)
		break;
	      /* Narrow down to the line we've found. */
	      beg = next_beg;
	      if ((end = memchr(beg, eol, buflim - beg)) != NULL)
	        end++;
              else
                end = buflim;
	      while (beg > buf && beg[-1] != eol)
		--beg;
	    }
	  /* Successful, no backreferences encountered! */
	  if (!backref)
	    goto success;
	}
      else
	{
	  /* We are looking for the leftmost (then longest) exact match.
	     We will go through the outer loop only once.  */
	  beg = start_ptr;
	  end = buflim;
	}

      /* If we've made it to this point, this means DFA has seen
	 a probable match, and we need to run it through Regex. */
      best_match = end;
      best_len = 0;
      for (i = 0; i < pcount; i++)
	{
	  patterns[i].regexbuf.not_eol = 0;
	  if (0 <= (start = re_search (&(patterns[i].regexbuf),
				       buf, end - buf - 1,
				       beg - buf, end - beg - 1,
				       &(patterns[i].regs))))
	    {
	      len = patterns[i].regs.end[0] - start;
	      match = buf + start;
	      if (match > best_match)
		continue;
	      if (start_ptr && !match_words)
		goto assess_pattern_match;
	      if ((!match_lines && !match_words)
		  || (match_lines && len == end - beg - 1))
		{
		  match = beg;
		  len = end - beg;
		  goto assess_pattern_match;
		}
	      /* If -w, check if the match aligns with word boundaries.
		 We do this iteratively because:
		 (a) the line may contain more than one occurence of the
		 pattern, and
		 (b) Several alternatives in the pattern might be valid at a
		 given point, and we may need to consider a shorter one to
		 find a word boundary.  */
	      if (match_words)
		while (match <= best_match)
		  {
		    if ((match == buf || !WCHAR ((unsigned char) match[-1]))
			&& (len == end - beg - 1
			    || !WCHAR ((unsigned char) match[len])))
		      goto assess_pattern_match;
		    if (len > 0)
		      {
			/* Try a shorter length anchored at the same place. */
			--len;
			patterns[i].regexbuf.not_eol = 1;
			len = re_match (&(patterns[i].regexbuf),
					buf, match + len - beg, match - buf,
					&(patterns[i].regs));
		      }
		    if (len <= 0)
		      {
			/* Try looking further on. */
			if (match == end - 1)
			  break;
			match++;
			patterns[i].regexbuf.not_eol = 0;
			start = re_search (&(patterns[i].regexbuf),
					   buf, end - buf - 1,
					   match - buf, end - match - 1,
					   &(patterns[i].regs));
			if (start < 0)
			  break;
			len = patterns[i].regs.end[0] - start;
			match = buf + start;
		      }
		  } /* while (match <= best_match) */
	      continue;
	    assess_pattern_match:
	      if (!start_ptr)
		{
		  /* Good enough for a non-exact match.
		     No need to look at further patterns, if any.  */
		  beg = match;
		  goto success_in_len;
		}
	      if (match < best_match || (match == best_match && len > best_len))
		{
		  /* Best exact match:  leftmost, then longest.  */
		  best_match = match;
		  best_len = len;
		}
	    } /* if re_search >= 0 */
	} /* for Regex patterns.  */
	if (best_match < end)
	  {
	    /* We have found an exact match.  We were just
	       waiting for the best one (leftmost then longest).  */
	    beg = best_match;
	    len = best_len;
	    goto success_in_len;
	  }
    } /* for (beg = end ..) */

 failure:
  ret_val = -1;
  goto out;

 success:
  len = end - beg;
 success_in_len:
  *match_size = len;
  ret_val = beg - buf;
 out:
  return ret_val;
}
#endif /* defined(GREP_PROGRAM) || defined(EGREP_PROGRAM) */

#if defined(GREP_PROGRAM) || defined(FGREP_PROGRAM)
COMPILE_FCT(Fcompile)
{
  char const *beg, *end, *lim, *err, *pat;
  size_t psize;

  kwsinit ();
  psize = size;
  if (match_icase && MB_CUR_MAX > 1)
    pat = mbtolower (pattern, &psize);
  else
    pat = pattern;

  beg = pat;
  do
    {
      for (lim = beg;; ++lim)
	{
	  end = lim;
	  
//Patch 0:
if ((lim >= pat + psize) || (__is_neg(10, &(lim), sizeof (lim), &(pat), sizeof (pat), &(psize), sizeof (psize), &(end), sizeof (end), &(beg), sizeof (beg), &(pattern), sizeof (pattern), &(match_icase), sizeof (match_icase), &(size), sizeof (size), &(err), sizeof (err), &(kwset), sizeof (kwset))))
    break;

//CodeSeg 1:
	 if (*lim == '\n')
	   {
	     lim++;
	     break;
	   }
#if HAVE_DOS_FILE_CONTENTS
	 if (*lim == '\r' && lim + 1 < pat + psize && lim[1] == '\n')
	   {
	     lim += 2;
	     break;
	   }
#endif
	}

      if ((err = kwsincr (kwset, beg, end - beg)) != NULL)
	error (EXIT_TROUBLE, 0, "%s", err);
      beg = lim;
    }
  while (beg < pat + psize);

  if ((err = kwsprep (kwset)) != NULL)
    error (EXIT_TROUBLE, 0, "%s", err);
}

EXECUTE_FCT(Fexecute)
{
  char const *beg, *try, *end, *mb_start;
  size_t len;
  char eol = eolbyte;
  struct kwsmatch kwsmatch;
  size_t ret_val;
#ifdef MBS_SUPPORT
  if (MB_CUR_MAX > 1)
    {
      if (match_icase)
        {
          char *case_buf = mbtolower (buf, &size);
	  if (start_ptr)
	    start_ptr = case_buf + (start_ptr - buf);
          buf = case_buf;
        }
    }
#endif /* MBS_SUPPORT */

  for (mb_start = beg = start_ptr ? start_ptr : buf; beg <= buf + size; beg++)
    {
      size_t offset = kwsexec (kwset, beg, buf + size - beg, &kwsmatch);
      if (offset == (size_t) -1)
	goto failure;
#ifdef MBS_SUPPORT
      if (MB_CUR_MAX > 1 && is_mb_middle (&mb_start, beg + offset, buf + size))
        {
          beg = mb_start - 1;
          continue; /* It is a part of multibyte character.  */
        }
#endif /* MBS_SUPPORT */
      beg += offset;
      len = kwsmatch.size[0];
      if (start_ptr && !match_words)
	goto success_in_beg_and_len;
      if (match_lines)
	{
	  if (beg > buf && beg[-1] != eol)
	    continue;
	  if (beg + len < buf + size && beg[len] != eol)
	    continue;
	  goto success;
	}
      else if (match_words)
	for (try = beg; len; )
	  {
	    if (try > buf && WCHAR((unsigned char) try[-1]))
	      break;
	    if (try + len < buf + size && WCHAR((unsigned char) try[len]))
	      {
		offset = kwsexec (kwset, beg, --len, &kwsmatch);
		if (offset == (size_t) -1)
		  break;
		try = beg + offset;
		len = kwsmatch.size[0];
	      }
	    else if (!start_ptr)
	      goto success;
	    else
	      goto success_in_beg_and_len;
	  } /* for (try) */
      else
	goto success;
    } /* for (beg in buf) */

 failure:
  ret_val = -1;
  goto out;

 success:
  if ((end = memchr (beg + len, eol, (buf + size) - (beg + len))) != NULL)
    end++;
  else
    end = buf + size;
  while (buf < beg && beg[-1] != eol)
    --beg;
  len = end - beg;
 success_in_beg_and_len:
  *match_size = len;
  ret_val = beg - buf;
 out:
  return ret_val;
}
#endif /* defined(GREP_PROGRAM) || defined(FGREP_PROGRAM) */

#ifdef GREP_PROGRAM
#if HAVE_LIBPCRE
/* Compiled internal form of a Perl regular expression.  */
static pcre *cre;

/* Additional information about the pattern.  */
static pcre_extra *extra;
#endif

COMPILE_FCT(Pcompile)
{
#if !HAVE_LIBPCRE
  error (EXIT_TROUBLE, 0, "%s",
	 _("support for the -P option is not compiled into "
	   "this --disable-perl-regexp binary"));
#else
  int e;
  char const *ep;
  char *re = xmalloc (4 * size + 7);
  int flags = PCRE_MULTILINE | (match_icase ? PCRE_CASELESS : 0);
  char const *patlim = pattern + size;
  char *n = re;
  char const *p;
  char const *pnul;

  /* FIXME: Remove these restrictions.  */
  if (memchr(pattern, '\n', size))
    error (EXIT_TROUBLE, 0, _("the -P option only supports a single pattern"));

  *n = '\0';
  if (match_lines)
    strcpy (n, "^(");
  if (match_words)
    strcpy (n, "\\b(");
  n += strlen (n);

  /* The PCRE interface doesn't allow NUL bytes in the pattern, so
     replace each NUL byte in the pattern with the four characters
     "\000", removing a preceding backslash if there are an odd
     number of backslashes before the NUL.

     FIXME: This method does not work with some multibyte character
     encodings, notably Shift-JIS, where a multibyte character can end
     in a backslash byte.  */
  for (p = pattern; (pnul = memchr (p, '\0', patlim - p)); p = pnul + 1)
    {
      memcpy (n, p, pnul - p);
      n += pnul - p;
      for (p = pnul; pattern < p && p[-1] == '\\'; p--)
	continue;
      n -= (pnul - p) & 1;
      strcpy (n, "\\000");
      n += 4;
    }

  memcpy (n, p, patlim - p);
  n += patlim - p;
  *n = '\0';
  if (match_words)
    strcpy (n, ")\\b");
  if (match_lines)
    strcpy (n, ")$");

  cre = pcre_compile (re, flags, &ep, &e, pcre_maketables ());
  if (!cre)
    error (EXIT_TROUBLE, 0, "%s", ep);

  extra = pcre_study (cre, 0, &ep);
  if (ep)
    error (EXIT_TROUBLE, 0, "%s", ep);

  free (re);
#endif
}

EXECUTE_FCT(Pexecute)
{
#if !HAVE_LIBPCRE
  abort ();
  return -1;
#else
  /* This array must have at least two elements; everything after that
     is just for performance improvement in pcre_exec.  */
  int sub[300];

  const char *line_buf, *line_end, *line_next;
  int e = PCRE_ERROR_NOMATCH;
  ptrdiff_t start_ofs = start_ptr ? start_ptr - buf : 0;

  /* PCRE can't limit the matching to single lines, therefore we have to
     match each line in the buffer separately.  */
  for (line_next = buf;
       e == PCRE_ERROR_NOMATCH && line_next < buf + size;
       start_ofs -= line_next - line_buf)
    {
      line_buf = line_next;
      line_end = memchr (line_buf, eolbyte, (buf + size) - line_buf);
      if (line_end == NULL)
        line_next = line_end = buf + size;
      else
        line_next = line_end + 1;

      if (start_ptr && start_ptr >= line_end)
        continue;

      e = pcre_exec (cre, extra, line_buf, line_end - line_buf,
                     start_ofs < 0 ? 0 : start_ofs, 0,
                     sub, sizeof sub / sizeof *sub);
    }

  if (e <= 0)
    {
      switch (e)
	{
	case PCRE_ERROR_NOMATCH:
	  return -1;

	case PCRE_ERROR_NOMEMORY:
	  error (EXIT_TROUBLE, 0, _("memory exhausted"));

	default:
	  abort ();
	}
    }
  else
    {
      /* Narrow down to the line we've found.  */
      char const *beg = line_buf + sub[0];
      char const *end = line_buf + sub[1];
      char const *buflim = buf + size;
      char eol = eolbyte;
      if (!start_ptr)
	{
	  /* FIXME: The case when '\n' is not found indicates a bug:
	     Since grep is line oriented, the match should never contain
	     a newline, so there _must_ be a newline following.
	   */
	  if (!(end = memchr (end, eol, buflim - end)))
	    end = buflim;
	  else
	    end++;
	  while (buf < beg && beg[-1] != eol)
	    --beg;
	}

      *match_size = end - beg;
      return beg - buf;
    }
#endif
}

struct matcher const matchers[] = {
  { "default", Gcompile, EGexecute },
  { "grep",    Gcompile, EGexecute },
  { "egrep",   Ecompile, EGexecute },
  { "awk",     Acompile, EGexecute },
  { "fgrep",   Fcompile, Fexecute },
  { "perl",    Pcompile, Pexecute },
  { "", 0, 0 },
};
#endif /* GREP_PROGRAM */

Testing negative cases!
Testing 0 (with abstract condition) ENVIS_NEG
Iteration 0
Running test command:
/home/ubuntu/spr-fast/tools/grep-test.py /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-deccad69-db9d6340/tempworkdir2/src /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-deccad69-db9d6340/tempworkdir2/tests /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-deccad69-db9d6340/tempworkdir2 0  > __res
Opening:/home/ubuntu/spr-fast/tests/corebench/grep/grep-case-deccad69-db9d6340/tempworkdir2/neg.tmp!
NegativeBRANCH RECORD/home/ubuntu/spr-fast/tests/corebench/grep/grep-case-deccad69-db9d6340/tempworkdir2/neg.tmp!
APPENDING TO ISNEG:/home/ubuntu/spr-fast/tests/corebench/grep/grep-case-deccad69-db9d6340/tempworkdir2/neg.tmp!
Branch 0: 0
Branch 1: 0
Iteration 1
Running test command:
/home/ubuntu/spr-fast/tools/grep-test.py /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-deccad69-db9d6340/tempworkdir2/src /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-deccad69-db9d6340/tempworkdir2/tests /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-deccad69-db9d6340/tempworkdir2 0  > __res
Opening:/home/ubuntu/spr-fast/tests/corebench/grep/grep-case-deccad69-db9d6340/tempworkdir2/neg.tmp!
NegativeBRANCH RECORD/home/ubuntu/spr-fast/tests/corebench/grep/grep-case-deccad69-db9d6340/tempworkdir2/neg.tmp!
APPENDING TO ISNEG:/home/ubuntu/spr-fast/tests/corebench/grep/grep-case-deccad69-db9d6340/tempworkdir2/neg.tmp!
Branch 0: 0
Branch 1: 1
Branch 2: 0
Iteration 2
Running test command:
/home/ubuntu/spr-fast/tools/grep-test.py /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-deccad69-db9d6340/tempworkdir2/src /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-deccad69-db9d6340/tempworkdir2/tests /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-deccad69-db9d6340/tempworkdir2 0  > __res
Opening:/home/ubuntu/spr-fast/tests/corebench/grep/grep-case-deccad69-db9d6340/tempworkdir2/neg.tmp!
NegativeBRANCH RECORD/home/ubuntu/spr-fast/tests/corebench/grep/grep-case-deccad69-db9d6340/tempworkdir2/neg.tmp!
APPENDING TO ISNEG:/home/ubuntu/spr-fast/tests/corebench/grep/grep-case-deccad69-db9d6340/tempworkdir2/neg.tmp!
Branch 0: 0
Branch 1: 1
Branch 2: 1
Branch 3: 0
Iteration 3
Running test command:
/home/ubuntu/spr-fast/tools/grep-test.py /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-deccad69-db9d6340/tempworkdir2/src /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-deccad69-db9d6340/tempworkdir2/tests /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-deccad69-db9d6340/tempworkdir2 0  > __res
Opening:/home/ubuntu/spr-fast/tests/corebench/grep/grep-case-deccad69-db9d6340/tempworkdir2/neg.tmp!
NegativeBRANCH RECORD/home/ubuntu/spr-fast/tests/corebench/grep/grep-case-deccad69-db9d6340/tempworkdir2/neg.tmp!
APPENDING TO ISNEG:/home/ubuntu/spr-fast/tests/corebench/grep/grep-case-deccad69-db9d6340/tempworkdir2/neg.tmp!
Branch 0: 0
Branch 1: 1
Branch 2: 1
Branch 3: 1
Branch 4: 0
Iteration 4
Running test command:
/home/ubuntu/spr-fast/tools/grep-test.py /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-deccad69-db9d6340/tempworkdir2/src /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-deccad69-db9d6340/tempworkdir2/tests /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-deccad69-db9d6340/tempworkdir2 0  > __res
Opening:/home/ubuntu/spr-fast/tests/corebench/grep/grep-case-deccad69-db9d6340/tempworkdir2/neg.tmp!
NegativeBRANCH RECORD/home/ubuntu/spr-fast/tests/corebench/grep/grep-case-deccad69-db9d6340/tempworkdir2/neg.tmp!
APPENDING TO ISNEG:/home/ubuntu/spr-fast/tests/corebench/grep/grep-case-deccad69-db9d6340/tempworkdir2/neg.tmp!
Branch 0: 0
Branch 1: 1
Branch 2: 1
Branch 3: 1
Branch 4: 1
Branch 5: 0
Iteration 5
Running test command:
/home/ubuntu/spr-fast/tools/grep-test.py /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-deccad69-db9d6340/tempworkdir2/src /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-deccad69-db9d6340/tempworkdir2/tests /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-deccad69-db9d6340/tempworkdir2 0  > __res
Opening:/home/ubuntu/spr-fast/tests/corebench/grep/grep-case-deccad69-db9d6340/tempworkdir2/neg.tmp!
NegativeBRANCH RECORD/home/ubuntu/spr-fast/tests/corebench/grep/grep-case-deccad69-db9d6340/tempworkdir2/neg.tmp!
APPENDING TO ISNEG:/home/ubuntu/spr-fast/tests/corebench/grep/grep-case-deccad69-db9d6340/tempworkdir2/neg.tmp!
Branch 0: 0
Branch 1: 1
Branch 2: 1
Branch 3: 1
Branch 4: 1
Branch 5: 1
Branch 6: 0
Iteration 6
Running test command:
/home/ubuntu/spr-fast/tools/grep-test.py /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-deccad69-db9d6340/tempworkdir2/src /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-deccad69-db9d6340/tempworkdir2/tests /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-deccad69-db9d6340/tempworkdir2 0  > __res
Opening:/home/ubuntu/spr-fast/tests/corebench/grep/grep-case-deccad69-db9d6340/tempworkdir2/neg.tmp!
NegativeBRANCH RECORD/home/ubuntu/spr-fast/tests/corebench/grep/grep-case-deccad69-db9d6340/tempworkdir2/neg.tmp!
APPENDING TO ISNEG:/home/ubuntu/spr-fast/tests/corebench/grep/grep-case-deccad69-db9d6340/tempworkdir2/neg.tmp!
Branch 0: 0
Branch 1: 1
Branch 2: 1
Branch 3: 1
Branch 4: 1
Branch 5: 1
Branch 6: 1
Branch 7: 0
Iteration 7
Running test command:
/home/ubuntu/spr-fast/tools/grep-test.py /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-deccad69-db9d6340/tempworkdir2/src /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-deccad69-db9d6340/tempworkdir2/tests /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-deccad69-db9d6340/tempworkdir2 0  > __res
Opening:/home/ubuntu/spr-fast/tests/corebench/grep/grep-case-deccad69-db9d6340/tempworkdir2/neg.tmp!
NegativeBRANCH RECORD/home/ubuntu/spr-fast/tests/corebench/grep/grep-case-deccad69-db9d6340/tempworkdir2/neg.tmp!
APPENDING TO ISNEG:/home/ubuntu/spr-fast/tests/corebench/grep/grep-case-deccad69-db9d6340/tempworkdir2/neg.tmp!
Branch 0: 0
Branch 1: 1
Branch 2: 1
Branch 3: 1
Branch 4: 1
Branch 5: 1
Branch 6: 1
Branch 7: 1
Branch 8: 0
Iteration 8
Running test command:
/home/ubuntu/spr-fast/tools/grep-test.py /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-deccad69-db9d6340/tempworkdir2/src /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-deccad69-db9d6340/tempworkdir2/tests /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-deccad69-db9d6340/tempworkdir2 0  > __res
Opening:/home/ubuntu/spr-fast/tests/corebench/grep/grep-case-deccad69-db9d6340/tempworkdir2/neg.tmp!
NegativeBRANCH RECORD/home/ubuntu/spr-fast/tests/corebench/grep/grep-case-deccad69-db9d6340/tempworkdir2/neg.tmp!
APPENDING TO ISNEG:/home/ubuntu/spr-fast/tests/corebench/grep/grep-case-deccad69-db9d6340/tempworkdir2/neg.tmp!
Branch 0: 0
Branch 1: 1
Branch 2: 1
Branch 3: 1
Branch 4: 1
Branch 5: 1
Branch 6: 1
Branch 7: 1
Branch 8: 1
Branch 9: 0
Iteration 9
Running test command:
/home/ubuntu/spr-fast/tools/grep-test.py /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-deccad69-db9d6340/tempworkdir2/src /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-deccad69-db9d6340/tempworkdir2/tests /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-deccad69-db9d6340/tempworkdir2 0  > __res
Opening:/home/ubuntu/spr-fast/tests/corebench/grep/grep-case-deccad69-db9d6340/tempworkdir2/neg.tmp!
NegativeBRANCH RECORD/home/ubuntu/spr-fast/tests/corebench/grep/grep-case-deccad69-db9d6340/tempworkdir2/neg.tmp!
APPENDING TO ISNEG:/home/ubuntu/spr-fast/tests/corebench/grep/grep-case-deccad69-db9d6340/tempworkdir2/neg.tmp!
Branch 0: 0
Branch 1: 1
Branch 2: 1
Branch 3: 1
Branch 4: 1
Branch 5: 1
Branch 6: 1
Branch 7: 1
Branch 8: 1
Branch 9: 1
Branch 10: 0
Running test command:
/home/ubuntu/spr-fast/tools/grep-test.py /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-deccad69-db9d6340/tempworkdir2/src /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-deccad69-db9d6340/tempworkdir2/tests /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-deccad69-db9d6340/tempworkdir2 0  > __res
CondTester, Postprocessing instance id 17:
//src_file:src/search.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
/* search.c - searching subroutines using dfa, kwset and regex for grep.
   Copyright 1992, 1998, 2000, 2007, 2009-2010 Free Software Foundation, Inc.

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 3, or (at your option)
   any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program; if not, write to the Free Software
   Foundation, Inc., 51 Franklin Street - Fifth Floor, Boston, MA
   02110-1301, USA.  */

/* Written August 1992 by Mike Haertel. */

#include <config.h>

#include <sys/types.h>

#include "mbsupport.h"
#ifdef MBS_SUPPORT
/* We can handle multibyte strings. */
# include <wchar.h>
# include <wctype.h>
#endif

#include "system.h"
#include "grep.h"
#ifndef FGREP_PROGRAM
# include <regex.h>
# include "dfa.h"
#endif
#include "kwset.h"
#include "error.h"
#include "xalloc.h"
#ifdef HAVE_LIBPCRE
# include <pcre.h>
#endif

#define NCHAR (UCHAR_MAX + 1)

/* For -w, we also consider _ to be word constituent.  */
#define WCHAR(C) (ISALNUM(C) || (C) == '_')

/* KWset compiled pattern.  For Ecompile and Gcompile, we compile
   a list of strings, at least one of which is known to occur in
   any string matching the regexp. */
static kwset_t kwset;

static void
kwsinit (void)
{
  static char trans[NCHAR];
  int i;

  if (match_icase && MB_CUR_MAX == 1)
    {
      for (i = 0; i < NCHAR; ++i)
        trans[i] = TOLOWER (i);

      kwset = kwsalloc (trans);
    }
  else
    kwset = kwsalloc (NULL);

  if (!kwset)
    xalloc_die ();
}

#ifdef MBS_SUPPORT
/* Convert the *N-byte string, BEG, to lowercase, and write the
   NUL-terminated result into malloc'd storage.  Upon success, set *N
   to the length (in bytes) of the resulting string (not including the
   trailing NUL byte), and return a pointer to the lowercase string.
   Upon memory allocation failure, this function exits.

   Note that while this function returns a pointer to malloc'd storage,
   the caller must not free it, since this function retains a pointer
   to the buffer and reuses it on any subsequent call.  As a consequence,
   this function is not thread-safe.  */
static char *
mbtolower (const char *beg, size_t *n)
{
  static char *out;
  static size_t outalloc;
  size_t outlen, mb_cur_max;
  mbstate_t is, os;
  const char *end;
  char *p;

  if (*n > outalloc)
    {
      out = xrealloc (out, *n);
      outalloc = *n;
    }

  memset (&is, 0, sizeof (is));
  memset (&os, 0, sizeof (os));
  end = beg + *n;

  mb_cur_max = MB_CUR_MAX;
  p = out;
  outlen = 0;
  while (beg < end)
    {
      wchar_t wc;
      size_t mbclen = mbrtowc(&wc, beg, end - beg, &is);
      if (outlen + mb_cur_max >= outalloc)
        {
          out = x2nrealloc (out, &outalloc, 1);
          p = out + outlen;
        }

      if (mbclen == (size_t) -1 || mbclen == (size_t) -2 || mbclen == 0)
        {
          /* An invalid sequence, or a truncated multi-octet character.
             We treat it as a single-octet character.  */
          *p++ = *beg++;
          outlen++;
          memset (&is, 0, sizeof (is));
          memset (&os, 0, sizeof (os));
        }
      else
        {
          beg += mbclen;
          mbclen = wcrtomb (p, towlower ((wint_t) wc), &os);
          p += mbclen;
          outlen += mbclen;
        }
    }

  *n = p - out;
  *p++ = 0;
  return out;
}
#endif


#ifndef FGREP_PROGRAM
/* DFA compiled regexp. */
static struct dfa dfa;

/* The Regex compiled patterns.  */
static struct patterns
{
  /* Regex compiled regexp. */
  struct re_pattern_buffer regexbuf;
  struct re_registers regs; /* This is here on account of a BRAIN-DEAD
			       Q@#%!# library interface in regex.c.  */
} patterns0;

struct patterns *patterns;
size_t pcount;

void
dfaerror (char const *mesg)
{
  error (EXIT_TROUBLE, 0, "%s", mesg);
}

/* Number of compiled fixed strings known to exactly match the regexp.
   If kwsexec returns < kwset_exact_matches, then we don't need to
   call the regexp matcher at all. */
static int kwset_exact_matches;

static char const *
kwsincr_case (const char *must)
{
  const char *buf;
  size_t n;

  n = strlen (must);
#ifdef MBS_SUPPORT
  if (match_icase && MB_CUR_MAX > 1)
    buf = mbtolower (must, &n);
  else
#endif
    buf = must;
  return kwsincr (kwset, buf, n);
}

/* If the DFA turns out to have some set of fixed strings one of
   which must occur in the match, then we build a kwset matcher
   to find those strings, and thus quickly filter out impossible
   matches. */
static void
kwsmusts (void)
{
  struct dfamust const *dm;
  char const *err;

  if (dfa.musts)
    {
      kwsinit ();
      /* First, we compile in the substrings known to be exact
	 matches.  The kwset matcher will return the index
	 of the matching string that it chooses. */
      for (dm = dfa.musts; dm; dm = dm->next)
	{
	  if (!dm->exact)
	    continue;
	  ++kwset_exact_matches;
	  if ((err = kwsincr_case (dm->must)) != NULL)
	    error (EXIT_TROUBLE, 0, "%s", err);
	}
      /* Now, we compile the substrings that will require
	 the use of the regexp matcher.  */
      for (dm = dfa.musts; dm; dm = dm->next)
	{
	  if (dm->exact)
	    continue;
	  if ((err = kwsincr_case (dm->must)) != NULL)
	    error (EXIT_TROUBLE, 0, "%s", err);
	}
      if ((err = kwsprep (kwset)) != NULL)
	error (EXIT_TROUBLE, 0, "%s", err);
    }
}
#endif /* !FGREP_PROGRAM */

#ifdef MBS_SUPPORT

static bool
is_mb_middle(const char **good, const char *buf, const char *end)
{
  const char *p = *good;
  const char *prev = p;
  mbstate_t cur_state;

  /* TODO: can be optimized for UTF-8.  */
  memset(&cur_state, 0, sizeof(mbstate_t));
  while (p < buf)
    {
      size_t mbclen = mbrlen(p, end - p, &cur_state);

      /* Store the beginning of the previous complete multibyte character.  */
      if (mbclen != (size_t) -2)
        prev = p;

      if (mbclen == (size_t) -1 || mbclen == (size_t) -2 || mbclen == 0)
	{
	  /* An invalid sequence, or a truncated multibyte character.
	     We treat it as a single byte character.  */
	  mbclen = 1;
	}
      p += mbclen;
    }

  *good = prev;
  return p > buf;
}
#endif /* MBS_SUPPORT */

#if defined(GREP_PROGRAM) || defined(EGREP_PROGRAM)
#ifdef EGREP_PROGRAM
COMPILE_FCT(Ecompile)
{
  reg_syntax_t syntax_bits = RE_SYNTAX_POSIX_EGREP;
#else
/* No __VA_ARGS__ in C89.  So we have to do it this way.  */
static COMPILE_RET
GEAcompile (char const *pattern, size_t size, reg_syntax_t syntax_bits)
{
#endif /* EGREP_PROGRAM */
  const char *err;
  const char *p, *sep;
  size_t total = size;
  char *motif;

  if (match_icase)
    syntax_bits |= RE_ICASE;
  re_set_syntax (syntax_bits);
  dfasyntax (syntax_bits, match_icase, eolbyte);

  /* For GNU regex compiler we have to pass the patterns separately to detect
     errors like "[\nallo\n]\n".  The patterns here are "[", "allo" and "]"
     GNU regex should have raise a syntax error.  The same for backref, where
     the backref should have been local to each pattern.  */
  p = pattern;
  do
    {
      size_t len;
      sep = memchr (p, '\n', total);
      if (sep)
	{
	  len = sep - p;
	  sep++;
	  total -= (len + 1);
	}
      else
	{
	  len = total;
	  total = 0;
	}

      patterns = realloc (patterns, (pcount + 1) * sizeof (*patterns));
      if (patterns == NULL)
	error (EXIT_TROUBLE, errno, _("memory exhausted"));
      patterns[pcount] = patterns0;

      if ((err = re_compile_pattern (p, len,
				    &(patterns[pcount].regexbuf))) != NULL)
	error (EXIT_TROUBLE, 0, "%s", err);
      pcount++;

      p = sep;
    } while (sep && total != 0);

  /* In the match_words and match_lines cases, we use a different pattern
     for the DFA matcher that will quickly throw out cases that won't work.
     Then if DFA succeeds we do some hairy stuff using the regex matcher
     to decide whether the match should really count. */
  if (match_words || match_lines)
    {
      static char const line_beg_no_bk[] = "^(";
      static char const line_end_no_bk[] = ")$";
      static char const word_beg_no_bk[] = "(^|[^[:alnum:]_])(";
      static char const word_end_no_bk[] = ")([^[:alnum:]_]|$)";
#ifdef EGREP_PROGRAM
# define IF_BK(x, y) (y)
      char *n = xmalloc (sizeof word_beg_no_bk - 1 + size + sizeof word_end_no_bk);
#else
      static char const line_beg_bk[] = "^\\(";
      static char const line_end_bk[] = "\\)$";
      static char const word_beg_bk[] = "\\(^\\|[^[:alnum:]_]\\)\\(";
      static char const word_end_bk[] = "\\)\\([^[:alnum:]_]\\|$\\)";
      int bk = !(syntax_bits & RE_NO_BK_PARENS);
# define IF_BK(x, y) ((bk) ? (x) : (y))
      char *n = xmalloc (sizeof word_beg_bk - 1 + size + sizeof word_end_bk);
#endif /* EGREP_PROGRAM */

      strcpy (n, match_lines ? IF_BK(line_beg_bk, line_beg_no_bk)
			     : IF_BK(word_beg_bk, word_beg_no_bk));
      total = strlen(n);
      memcpy (n + total, pattern, size);
      total += size;
      strcpy (n + total, match_lines ? IF_BK(line_end_bk, line_end_no_bk)
				     : IF_BK(word_end_bk, word_end_no_bk));
      total += strlen (n + total);
      pattern = motif = n;
      size = total;
    }
  else
    motif = NULL;

  dfacomp (pattern, size, &dfa, 1);
  kwsmusts ();

  free(motif);
}

#ifndef EGREP_PROGRAM
COMPILE_FCT(Gcompile)
{
  return GEAcompile (pattern, size,
		     RE_SYNTAX_GREP | RE_HAT_LISTS_NOT_NEWLINE);
}

COMPILE_FCT(Acompile)
{
  return GEAcompile (pattern, size, RE_SYNTAX_AWK);
}

COMPILE_FCT(Ecompile)
{
  return GEAcompile (pattern, size, RE_SYNTAX_POSIX_EGREP);
}
#endif /* !EGREP_PROGRAM */

EXECUTE_FCT(EGexecute)
{
  char const *buflim, *beg, *end, *match, *best_match, *mb_start;
  char eol = eolbyte;
  int backref, start, len, best_len;
  struct kwsmatch kwsm;
  size_t i, ret_val;
#ifdef MBS_SUPPORT
  if (MB_CUR_MAX > 1)
    {
      if (match_icase)
        {
          /* mbtolower adds a NUL byte at the end.  That will provide
	     space for the sentinel byte dfaexec may add.  */
          char *case_buf = mbtolower (buf, &size);
	  if (start_ptr)
	    start_ptr = case_buf + (start_ptr - buf);
          buf = case_buf;
        }
    }
#endif /* MBS_SUPPORT */

  mb_start = buf;
  buflim = buf + size;

  for (beg = end = buf; end < buflim; beg = end)
    {
      if (!start_ptr)
	{
	  /* We don't care about an exact match.  */
	  if (kwset)
	    {
	      /* Find a possible match using the KWset matcher. */
	      size_t offset = kwsexec (kwset, beg, buflim - beg, &kwsm);
	      if (offset == (size_t) -1)
		goto failure;
	      beg += offset;
	      /* Narrow down to the line containing the candidate, and
		 run it through DFA. */
	      if ((end = memchr(beg, eol, buflim - beg)) != NULL)
	        end++;
              else
                end = buflim;
	      match = beg;
	      while (beg > buf && beg[-1] != eol)
		--beg;
	      if (kwsm.index < kwset_exact_matches)
                {
#ifdef MBS_SUPPORT
                  if (mb_start < beg)
                    mb_start = beg;
                  if (MB_CUR_MAX == 1 || !is_mb_middle (&mb_start, match, buflim))
#endif
                    goto success;
                }
	      if (dfaexec (&dfa, beg, (char *) end, 0, NULL, &backref) == NULL)
		continue;
	    }
	  else
	    {
	      /* No good fixed strings; start with DFA. */
	      char const *next_beg = dfaexec (&dfa, beg, (char *) buflim,
					      0, NULL, &backref);
	      if (next_beg == NULL)
		break;
	      /* Narrow down to the line we've found. */
	      beg = next_beg;
	      if ((end = memchr(beg, eol, buflim - beg)) != NULL)
	        end++;
              else
                end = buflim;
	      while (beg > buf && beg[-1] != eol)
		--beg;
	    }
	  /* Successful, no backreferences encountered! */
	  if (!backref)
	    goto success;
	}
      else
	{
	  /* We are looking for the leftmost (then longest) exact match.
	     We will go through the outer loop only once.  */
	  beg = start_ptr;
	  end = buflim;
	}

      /* If we've made it to this point, this means DFA has seen
	 a probable match, and we need to run it through Regex. */
      best_match = end;
      best_len = 0;
      for (i = 0; i < pcount; i++)
	{
	  patterns[i].regexbuf.not_eol = 0;
	  if (0 <= (start = re_search (&(patterns[i].regexbuf),
				       buf, end - buf - 1,
				       beg - buf, end - beg - 1,
				       &(patterns[i].regs))))
	    {
	      len = patterns[i].regs.end[0] - start;
	      match = buf + start;
	      if (match > best_match)
		continue;
	      if (start_ptr && !match_words)
		goto assess_pattern_match;
	      if ((!match_lines && !match_words)
		  || (match_lines && len == end - beg - 1))
		{
		  match = beg;
		  len = end - beg;
		  goto assess_pattern_match;
		}
	      /* If -w, check if the match aligns with word boundaries.
		 We do this iteratively because:
		 (a) the line may contain more than one occurence of the
		 pattern, and
		 (b) Several alternatives in the pattern might be valid at a
		 given point, and we may need to consider a shorter one to
		 find a word boundary.  */
	      if (match_words)
		while (match <= best_match)
		  {
		    if ((match == buf || !WCHAR ((unsigned char) match[-1]))
			&& (len == end - beg - 1
			    || !WCHAR ((unsigned char) match[len])))
		      goto assess_pattern_match;
		    if (len > 0)
		      {
			/* Try a shorter length anchored at the same place. */
			--len;
			patterns[i].regexbuf.not_eol = 1;
			len = re_match (&(patterns[i].regexbuf),
					buf, match + len - beg, match - buf,
					&(patterns[i].regs));
		      }
		    if (len <= 0)
		      {
			/* Try looking further on. */
			if (match == end - 1)
			  break;
			match++;
			patterns[i].regexbuf.not_eol = 0;
			start = re_search (&(patterns[i].regexbuf),
					   buf, end - buf - 1,
					   match - buf, end - match - 1,
					   &(patterns[i].regs));
			if (start < 0)
			  break;
			len = patterns[i].regs.end[0] - start;
			match = buf + start;
		      }
		  } /* while (match <= best_match) */
	      continue;
	    assess_pattern_match:
	      if (!start_ptr)
		{
		  /* Good enough for a non-exact match.
		     No need to look at further patterns, if any.  */
		  beg = match;
		  goto success_in_len;
		}
	      if (match < best_match || (match == best_match && len > best_len))
		{
		  /* Best exact match:  leftmost, then longest.  */
		  best_match = match;
		  best_len = len;
		}
	    } /* if re_search >= 0 */
	} /* for Regex patterns.  */
	if (best_match < end)
	  {
	    /* We have found an exact match.  We were just
	       waiting for the best one (leftmost then longest).  */
	    beg = best_match;
	    len = best_len;
	    goto success_in_len;
	  }
    } /* for (beg = end ..) */

 failure:
  ret_val = -1;
  goto out;

 success:
  len = end - beg;
 success_in_len:
  *match_size = len;
  ret_val = beg - buf;
 out:
  return ret_val;
}
#endif /* defined(GREP_PROGRAM) || defined(EGREP_PROGRAM) */

#if defined(GREP_PROGRAM) || defined(FGREP_PROGRAM)
COMPILE_FCT(Fcompile)
{
  char const *beg, *end, *lim, *err, *pat;
  size_t psize;

  kwsinit ();
  psize = size;
  if (match_icase && MB_CUR_MAX > 1)
    pat = mbtolower (pattern, &psize);
  else
    pat = pattern;

  beg = pat;
  do
    {
      for (lim = beg;; ++lim)
	{
	  end = lim;
	  
//Patch 0:
if ((lim >= pat + psize) && !(__is_neg(10, &(lim), sizeof (lim), &(pat), sizeof (pat), &(psize), sizeof (psize), &(end), sizeof (end), &(beg), sizeof (beg), &(pattern), sizeof (pattern), &(match_icase), sizeof (match_icase), &(size), sizeof (size), &(err), sizeof (err), &(kwset), sizeof (kwset))))
    break;

//CodeSeg 1:
	 if (*lim == '\n')
	   {
	     lim++;
	     break;
	   }
#if HAVE_DOS_FILE_CONTENTS
	 if (*lim == '\r' && lim + 1 < pat + psize && lim[1] == '\n')
	   {
	     lim += 2;
	     break;
	   }
#endif
	}

      if ((err = kwsincr (kwset, beg, end - beg)) != NULL)
	error (EXIT_TROUBLE, 0, "%s", err);
      beg = lim;
    }
  while (beg < pat + psize);

  if ((err = kwsprep (kwset)) != NULL)
    error (EXIT_TROUBLE, 0, "%s", err);
}

EXECUTE_FCT(Fexecute)
{
  char const *beg, *try, *end, *mb_start;
  size_t len;
  char eol = eolbyte;
  struct kwsmatch kwsmatch;
  size_t ret_val;
#ifdef MBS_SUPPORT
  if (MB_CUR_MAX > 1)
    {
      if (match_icase)
        {
          char *case_buf = mbtolower (buf, &size);
	  if (start_ptr)
	    start_ptr = case_buf + (start_ptr - buf);
          buf = case_buf;
        }
    }
#endif /* MBS_SUPPORT */

  for (mb_start = beg = start_ptr ? start_ptr : buf; beg <= buf + size; beg++)
    {
      size_t offset = kwsexec (kwset, beg, buf + size - beg, &kwsmatch);
      if (offset == (size_t) -1)
	goto failure;
#ifdef MBS_SUPPORT
      if (MB_CUR_MAX > 1 && is_mb_middle (&mb_start, beg + offset, buf + size))
        {
          beg = mb_start - 1;
          continue; /* It is a part of multibyte character.  */
        }
#endif /* MBS_SUPPORT */
      beg += offset;
      len = kwsmatch.size[0];
      if (start_ptr && !match_words)
	goto success_in_beg_and_len;
      if (match_lines)
	{
	  if (beg > buf && beg[-1] != eol)
	    continue;
	  if (beg + len < buf + size && beg[len] != eol)
	    continue;
	  goto success;
	}
      else if (match_words)
	for (try = beg; len; )
	  {
	    if (try > buf && WCHAR((unsigned char) try[-1]))
	      break;
	    if (try + len < buf + size && WCHAR((unsigned char) try[len]))
	      {
		offset = kwsexec (kwset, beg, --len, &kwsmatch);
		if (offset == (size_t) -1)
		  break;
		try = beg + offset;
		len = kwsmatch.size[0];
	      }
	    else if (!start_ptr)
	      goto success;
	    else
	      goto success_in_beg_and_len;
	  } /* for (try) */
      else
	goto success;
    } /* for (beg in buf) */

 failure:
  ret_val = -1;
  goto out;

 success:
  if ((end = memchr (beg + len, eol, (buf + size) - (beg + len))) != NULL)
    end++;
  else
    end = buf + size;
  while (buf < beg && beg[-1] != eol)
    --beg;
  len = end - beg;
 success_in_beg_and_len:
  *match_size = len;
  ret_val = beg - buf;
 out:
  return ret_val;
}
#endif /* defined(GREP_PROGRAM) || defined(FGREP_PROGRAM) */

#ifdef GREP_PROGRAM
#if HAVE_LIBPCRE
/* Compiled internal form of a Perl regular expression.  */
static pcre *cre;

/* Additional information about the pattern.  */
static pcre_extra *extra;
#endif

COMPILE_FCT(Pcompile)
{
#if !HAVE_LIBPCRE
  error (EXIT_TROUBLE, 0, "%s",
	 _("support for the -P option is not compiled into "
	   "this --disable-perl-regexp binary"));
#else
  int e;
  char const *ep;
  char *re = xmalloc (4 * size + 7);
  int flags = PCRE_MULTILINE | (match_icase ? PCRE_CASELESS : 0);
  char const *patlim = pattern + size;
  char *n = re;
  char const *p;
  char const *pnul;

  /* FIXME: Remove these restrictions.  */
  if (memchr(pattern, '\n', size))
    error (EXIT_TROUBLE, 0, _("the -P option only supports a single pattern"));

  *n = '\0';
  if (match_lines)
    strcpy (n, "^(");
  if (match_words)
    strcpy (n, "\\b(");
  n += strlen (n);

  /* The PCRE interface doesn't allow NUL bytes in the pattern, so
     replace each NUL byte in the pattern with the four characters
     "\000", removing a preceding backslash if there are an odd
     number of backslashes before the NUL.

     FIXME: This method does not work with some multibyte character
     encodings, notably Shift-JIS, where a multibyte character can end
     in a backslash byte.  */
  for (p = pattern; (pnul = memchr (p, '\0', patlim - p)); p = pnul + 1)
    {
      memcpy (n, p, pnul - p);
      n += pnul - p;
      for (p = pnul; pattern < p && p[-1] == '\\'; p--)
	continue;
      n -= (pnul - p) & 1;
      strcpy (n, "\\000");
      n += 4;
    }

  memcpy (n, p, patlim - p);
  n += patlim - p;
  *n = '\0';
  if (match_words)
    strcpy (n, ")\\b");
  if (match_lines)
    strcpy (n, ")$");

  cre = pcre_compile (re, flags, &ep, &e, pcre_maketables ());
  if (!cre)
    error (EXIT_TROUBLE, 0, "%s", ep);

  extra = pcre_study (cre, 0, &ep);
  if (ep)
    error (EXIT_TROUBLE, 0, "%s", ep);

  free (re);
#endif
}

EXECUTE_FCT(Pexecute)
{
#if !HAVE_LIBPCRE
  abort ();
  return -1;
#else
  /* This array must have at least two elements; everything after that
     is just for performance improvement in pcre_exec.  */
  int sub[300];

  const char *line_buf, *line_end, *line_next;
  int e = PCRE_ERROR_NOMATCH;
  ptrdiff_t start_ofs = start_ptr ? start_ptr - buf : 0;

  /* PCRE can't limit the matching to single lines, therefore we have to
     match each line in the buffer separately.  */
  for (line_next = buf;
       e == PCRE_ERROR_NOMATCH && line_next < buf + size;
       start_ofs -= line_next - line_buf)
    {
      line_buf = line_next;
      line_end = memchr (line_buf, eolbyte, (buf + size) - line_buf);
      if (line_end == NULL)
        line_next = line_end = buf + size;
      else
        line_next = line_end + 1;

      if (start_ptr && start_ptr >= line_end)
        continue;

      e = pcre_exec (cre, extra, line_buf, line_end - line_buf,
                     start_ofs < 0 ? 0 : start_ofs, 0,
                     sub, sizeof sub / sizeof *sub);
    }

  if (e <= 0)
    {
      switch (e)
	{
	case PCRE_ERROR_NOMATCH:
	  return -1;

	case PCRE_ERROR_NOMEMORY:
	  error (EXIT_TROUBLE, 0, _("memory exhausted"));

	default:
	  abort ();
	}
    }
  else
    {
      /* Narrow down to the line we've found.  */
      char const *beg = line_buf + sub[0];
      char const *end = line_buf + sub[1];
      char const *buflim = buf + size;
      char eol = eolbyte;
      if (!start_ptr)
	{
	  /* FIXME: The case when '\n' is not found indicates a bug:
	     Since grep is line oriented, the match should never contain
	     a newline, so there _must_ be a newline following.
	   */
	  if (!(end = memchr (end, eol, buflim - end)))
	    end = buflim;
	  else
	    end++;
	  while (buf < beg && beg[-1] != eol)
	    --beg;
	}

      *match_size = end - beg;
      return beg - buf;
    }
#endif
}

struct matcher const matchers[] = {
  { "default", Gcompile, EGexecute },
  { "grep",    Gcompile, EGexecute },
  { "egrep",   Ecompile, EGexecute },
  { "awk",     Acompile, EGexecute },
  { "fgrep",   Fcompile, Fexecute },
  { "perl",    Pcompile, Pexecute },
  { "", 0, 0 },
};
#endif /* GREP_PROGRAM */

Trying a synthesis expr 1
Skipping a synthesis:1
Trying a synthesis expr match_icase == 0
Building:src at:
/home/ubuntu/spr-fast/tests/corebench/grep/grep-case-deccad69-db9d6340/tempworkdir2/srcVerifing Negative cases!
Running test command:
/home/ubuntu/spr-fast/tools/grep-test.py /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-deccad69-db9d6340/tempworkdir2/src /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-deccad69-db9d6340/tempworkdir2/tests /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-deccad69-db9d6340/tempworkdir2 0  > __res
Verifying positive cases
Running test command:
/home/ubuntu/spr-fast/tools/grep-test.py /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-deccad69-db9d6340/tempworkdir2/src /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-deccad69-db9d6340/tempworkdir2/tests /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-deccad69-db9d6340/tempworkdir2 9  > __res
Failed positive case 9
Not passed!
Trying a synthesis expr psize != 0
Building:src at:
/home/ubuntu/spr-fast/tests/corebench/grep/grep-case-deccad69-db9d6340/tempworkdir2/srcVerifing Negative cases!
Running test command:
/home/ubuntu/spr-fast/tools/grep-test.py /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-deccad69-db9d6340/tempworkdir2/src /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-deccad69-db9d6340/tempworkdir2/tests /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-deccad69-db9d6340/tempworkdir2 0  > __res
Verifying positive cases
Running test command:
/home/ubuntu/spr-fast/tools/grep-test.py /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-deccad69-db9d6340/tempworkdir2/src /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-deccad69-db9d6340/tempworkdir2/tests /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-deccad69-db9d6340/tempworkdir2 9  > __res
Failed positive case 9
Not passed!
Trying a synthesis expr size != 0
Building:src at:
/home/ubuntu/spr-fast/tests/corebench/grep/grep-case-deccad69-db9d6340/tempworkdir2/srcVerifing Negative cases!
Running test command:
/home/ubuntu/spr-fast/tools/grep-test.py /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-deccad69-db9d6340/tempworkdir2/src /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-deccad69-db9d6340/tempworkdir2/tests /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-deccad69-db9d6340/tempworkdir2 0  > __res
Verifying positive cases
Running test command:
/home/ubuntu/spr-fast/tools/grep-test.py /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-deccad69-db9d6340/tempworkdir2/src /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-deccad69-db9d6340/tempworkdir2/tests /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-deccad69-db9d6340/tempworkdir2 9  > __res
Failed positive case 9
Not passed!
Trying a synthesis expr err != 0
Building:src at:
/home/ubuntu/spr-fast/tests/corebench/grep/grep-case-deccad69-db9d6340/tempworkdir2/srcVerifing Negative cases!
Running test command:
/home/ubuntu/spr-fast/tools/grep-test.py /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-deccad69-db9d6340/tempworkdir2/src /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-deccad69-db9d6340/tempworkdir2/tests /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-deccad69-db9d6340/tempworkdir2 0  > __res
Verifying positive cases
Running test command:
/home/ubuntu/spr-fast/tools/grep-test.py /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-deccad69-db9d6340/tempworkdir2/src /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-deccad69-db9d6340/tempworkdir2/tests /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-deccad69-db9d6340/tempworkdir2 9  > __res
Failed positive case 9
Not passed!
Trying a synthesis expr psize == 2
Building:src at:
/home/ubuntu/spr-fast/tests/corebench/grep/grep-case-deccad69-db9d6340/tempworkdir2/srcVerifing Negative cases!
Running test command:
/home/ubuntu/spr-fast/tools/grep-test.py /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-deccad69-db9d6340/tempworkdir2/src /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-deccad69-db9d6340/tempworkdir2/tests /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-deccad69-db9d6340/tempworkdir2 0  > __res
Verifying positive cases
Running test command:
/home/ubuntu/spr-fast/tools/grep-test.py /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-deccad69-db9d6340/tempworkdir2/src /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-deccad69-db9d6340/tempworkdir2/tests /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-deccad69-db9d6340/tempworkdir2 9  > __res
Running test command:
/home/ubuntu/spr-fast/tools/grep-test.py /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-deccad69-db9d6340/tempworkdir2/src /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-deccad69-db9d6340/tempworkdir2/tests /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-deccad69-db9d6340/tempworkdir2 3  > __res
Running test command:
/home/ubuntu/spr-fast/tools/grep-test.py /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-deccad69-db9d6340/tempworkdir2/src /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-deccad69-db9d6340/tempworkdir2/tests /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-deccad69-db9d6340/tempworkdir2 4  > __res
Running test command:
/home/ubuntu/spr-fast/tools/grep-test.py /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-deccad69-db9d6340/tempworkdir2/src /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-deccad69-db9d6340/tempworkdir2/tests /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-deccad69-db9d6340/tempworkdir2 5  > __res
Running test command:
/home/ubuntu/spr-fast/tools/grep-test.py /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-deccad69-db9d6340/tempworkdir2/src /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-deccad69-db9d6340/tempworkdir2/tests /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-deccad69-db9d6340/tempworkdir2 6  > __res
Running test command:
/home/ubuntu/spr-fast/tools/grep-test.py /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-deccad69-db9d6340/tempworkdir2/src /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-deccad69-db9d6340/tempworkdir2/tests /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-deccad69-db9d6340/tempworkdir2 11  > __res
Running test command:
/home/ubuntu/spr-fast/tools/grep-test.py /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-deccad69-db9d6340/tempworkdir2/src /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-deccad69-db9d6340/tempworkdir2/tests /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-deccad69-db9d6340/tempworkdir2 12  > __res
Failed positive case 12
Not passed!
Trying a synthesis expr size == 2
Building:src at:
/home/ubuntu/spr-fast/tests/corebench/grep/grep-case-deccad69-db9d6340/tempworkdir2/srcVerifing Negative cases!
Running test command:
/home/ubuntu/spr-fast/tools/grep-test.py /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-deccad69-db9d6340/tempworkdir2/src /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-deccad69-db9d6340/tempworkdir2/tests /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-deccad69-db9d6340/tempworkdir2 0  > __res
Verifying positive cases
Running test command:
/home/ubuntu/spr-fast/tools/grep-test.py /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-deccad69-db9d6340/tempworkdir2/src /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-deccad69-db9d6340/tempworkdir2/tests /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-deccad69-db9d6340/tempworkdir2 9  > __res
Running test command:
/home/ubuntu/spr-fast/tools/grep-test.py /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-deccad69-db9d6340/tempworkdir2/src /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-deccad69-db9d6340/tempworkdir2/tests /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-deccad69-db9d6340/tempworkdir2 12  > __res
Failed positive case 12
Not passed!
Trying a synthesis expr psize != 1
Building:src at:
/home/ubuntu/spr-fast/tests/corebench/grep/grep-case-deccad69-db9d6340/tempworkdir2/srcVerifing Negative cases!
Running test command:
/home/ubuntu/spr-fast/tools/grep-test.py /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-deccad69-db9d6340/tempworkdir2/src /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-deccad69-db9d6340/tempworkdir2/tests /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-deccad69-db9d6340/tempworkdir2 0  > __res
Verifying positive cases
Running test command:
/home/ubuntu/spr-fast/tools/grep-test.py /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-deccad69-db9d6340/tempworkdir2/src /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-deccad69-db9d6340/tempworkdir2/tests /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-deccad69-db9d6340/tempworkdir2 9  > __res
Failed positive case 9
Not passed!
Trying a synthesis expr psize != 4
Building:src at:
/home/ubuntu/spr-fast/tests/corebench/grep/grep-case-deccad69-db9d6340/tempworkdir2/srcVerifing Negative cases!
Running test command:
/home/ubuntu/spr-fast/tools/grep-test.py /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-deccad69-db9d6340/tempworkdir2/src /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-deccad69-db9d6340/tempworkdir2/tests /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-deccad69-db9d6340/tempworkdir2 0  > __res
Verifying positive cases
Running test command:
/home/ubuntu/spr-fast/tools/grep-test.py /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-deccad69-db9d6340/tempworkdir2/src /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-deccad69-db9d6340/tempworkdir2/tests /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-deccad69-db9d6340/tempworkdir2 9  > __res
Running test command:
/home/ubuntu/spr-fast/tools/grep-test.py /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-deccad69-db9d6340/tempworkdir2/src /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-deccad69-db9d6340/tempworkdir2/tests /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-deccad69-db9d6340/tempworkdir2 12  > __res
Failed positive case 12
Not passed!
Trying a synthesis expr psize != 5
Building:src at:
/home/ubuntu/spr-fast/tests/corebench/grep/grep-case-deccad69-db9d6340/tempworkdir2/srcVerifing Negative cases!
Running test command:
/home/ubuntu/spr-fast/tools/grep-test.py /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-deccad69-db9d6340/tempworkdir2/src /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-deccad69-db9d6340/tempworkdir2/tests /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-deccad69-db9d6340/tempworkdir2 0  > __res
Verifying positive cases
Running test command:
/home/ubuntu/spr-fast/tools/grep-test.py /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-deccad69-db9d6340/tempworkdir2/src /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-deccad69-db9d6340/tempworkdir2/tests /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-deccad69-db9d6340/tempworkdir2 9  > __res
Failed positive case 9
Not passed!
Trying a synthesis expr psize != 6
Building:src at:
/home/ubuntu/spr-fast/tests/corebench/grep/grep-case-deccad69-db9d6340/tempworkdir2/srcVerifing Negative cases!
Running test command:
/home/ubuntu/spr-fast/tools/grep-test.py /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-deccad69-db9d6340/tempworkdir2/src /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-deccad69-db9d6340/tempworkdir2/tests /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-deccad69-db9d6340/tempworkdir2 0  > __res
Verifying positive cases
Running test command:
/home/ubuntu/spr-fast/tools/grep-test.py /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-deccad69-db9d6340/tempworkdir2/src /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-deccad69-db9d6340/tempworkdir2/tests /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-deccad69-db9d6340/tempworkdir2 9  > __res
Failed positive case 9
Not passed!
Trying a synthesis expr psize != 9
Building:src at:
/home/ubuntu/spr-fast/tests/corebench/grep/grep-case-deccad69-db9d6340/tempworkdir2/srcVerifing Negative cases!
Running test command:
/home/ubuntu/spr-fast/tools/grep-test.py /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-deccad69-db9d6340/tempworkdir2/src /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-deccad69-db9d6340/tempworkdir2/tests /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-deccad69-db9d6340/tempworkdir2 0  > __res
Verifying positive cases
Running test command:
/home/ubuntu/spr-fast/tools/grep-test.py /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-deccad69-db9d6340/tempworkdir2/src /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-deccad69-db9d6340/tempworkdir2/tests /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-deccad69-db9d6340/tempworkdir2 9  > __res
Failed positive case 9
Not passed!
Trying a synthesis expr match_icase != 1
Building:src at:
/home/ubuntu/spr-fast/tests/corebench/grep/grep-case-deccad69-db9d6340/tempworkdir2/srcVerifing Negative cases!
Running test command:
/home/ubuntu/spr-fast/tools/grep-test.py /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-deccad69-db9d6340/tempworkdir2/src /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-deccad69-db9d6340/tempworkdir2/tests /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-deccad69-db9d6340/tempworkdir2 0  > __res
Verifying positive cases
Running test command:
/home/ubuntu/spr-fast/tools/grep-test.py /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-deccad69-db9d6340/tempworkdir2/src /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-deccad69-db9d6340/tempworkdir2/tests /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-deccad69-db9d6340/tempworkdir2 9  > __res
Failed positive case 9
Not passed!
Trying a synthesis expr size != 1
Building:src at:
/home/ubuntu/spr-fast/tests/corebench/grep/grep-case-deccad69-db9d6340/tempworkdir2/srcVerifing Negative cases!
Running test command:
/home/ubuntu/spr-fast/tools/grep-test.py /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-deccad69-db9d6340/tempworkdir2/src /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-deccad69-db9d6340/tempworkdir2/tests /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-deccad69-db9d6340/tempworkdir2 0  > __res
Verifying positive cases
Running test command:
/home/ubuntu/spr-fast/tools/grep-test.py /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-deccad69-db9d6340/tempworkdir2/src /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-deccad69-db9d6340/tempworkdir2/tests /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-deccad69-db9d6340/tempworkdir2 9  > __res
Failed positive case 9
Not passed!
Trying a synthesis expr size != 4
Building:src at:
/home/ubuntu/spr-fast/tests/corebench/grep/grep-case-deccad69-db9d6340/tempworkdir2/srcVerifing Negative cases!
Running test command:
/home/ubuntu/spr-fast/tools/grep-test.py /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-deccad69-db9d6340/tempworkdir2/src /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-deccad69-db9d6340/tempworkdir2/tests /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-deccad69-db9d6340/tempworkdir2 0  > __res
Verifying positive cases
Running test command:
/home/ubuntu/spr-fast/tools/grep-test.py /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-deccad69-db9d6340/tempworkdir2/src /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-deccad69-db9d6340/tempworkdir2/tests /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-deccad69-db9d6340/tempworkdir2 9  > __res
Running test command:
/home/ubuntu/spr-fast/tools/grep-test.py /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-deccad69-db9d6340/tempworkdir2/src /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-deccad69-db9d6340/tempworkdir2/tests /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-deccad69-db9d6340/tempworkdir2 12  > __res
Failed positive case 12
Not passed!
Trying a synthesis expr size != 5
Building:src at:
/home/ubuntu/spr-fast/tests/corebench/grep/grep-case-deccad69-db9d6340/tempworkdir2/srcVerifing Negative cases!
Running test command:
/home/ubuntu/spr-fast/tools/grep-test.py /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-deccad69-db9d6340/tempworkdir2/src /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-deccad69-db9d6340/tempworkdir2/tests /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-deccad69-db9d6340/tempworkdir2 0  > __res
Verifying positive cases
Running test command:
/home/ubuntu/spr-fast/tools/grep-test.py /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-deccad69-db9d6340/tempworkdir2/src /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-deccad69-db9d6340/tempworkdir2/tests /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-deccad69-db9d6340/tempworkdir2 9  > __res
Failed positive case 9
Not passed!
Trying a synthesis expr size != 6
Building:src at:
/home/ubuntu/spr-fast/tests/corebench/grep/grep-case-deccad69-db9d6340/tempworkdir2/srcVerifing Negative cases!
Running test command:
/home/ubuntu/spr-fast/tools/grep-test.py /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-deccad69-db9d6340/tempworkdir2/src /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-deccad69-db9d6340/tempworkdir2/tests /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-deccad69-db9d6340/tempworkdir2 0  > __res
Verifying positive cases
Running test command:
/home/ubuntu/spr-fast/tools/grep-test.py /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-deccad69-db9d6340/tempworkdir2/src /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-deccad69-db9d6340/tempworkdir2/tests /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-deccad69-db9d6340/tempworkdir2 9  > __res
Failed positive case 9
Not passed!
Trying a synthesis expr size != 9
Building:src at:
/home/ubuntu/spr-fast/tests/corebench/grep/grep-case-deccad69-db9d6340/tempworkdir2/srcVerifing Negative cases!
Running test command:
/home/ubuntu/spr-fast/tools/grep-test.py /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-deccad69-db9d6340/tempworkdir2/src /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-deccad69-db9d6340/tempworkdir2/tests /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-deccad69-db9d6340/tempworkdir2 0  > __res
Verifying positive cases
Running test command:
/home/ubuntu/spr-fast/tools/grep-test.py /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-deccad69-db9d6340/tempworkdir2/src /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-deccad69-db9d6340/tempworkdir2/tests /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-deccad69-db9d6340/tempworkdir2 9  > __res
Failed positive case 9
Not passed!
Initial synthesize failed, final attempt
Skipping two clauses!(1) &&(0)
Found a clause! (lim >= pat + psize) 
Skipping a clause! (lim >= pat + psize) 
Postprocessing failed!
a batched test job starts!
Building merged code:
src_file: src/search.c
full src: int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
/* search.c - searching subroutines using dfa, kwset and regex for grep.
   Copyright 1992, 1998, 2000, 2007, 2009-2010 Free Software Foundation, Inc.

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 3, or (at your option)
   any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program; if not, write to the Free Software
   Foundation, Inc., 51 Franklin Street - Fifth Floor, Boston, MA
   02110-1301, USA.  */

/* Written August 1992 by Mike Haertel. */

#include <config.h>

#include <sys/types.h>

#include "mbsupport.h"
#ifdef MBS_SUPPORT
/* We can handle multibyte strings. */
# include <wchar.h>
# include <wctype.h>
#endif

#include "system.h"
#include "grep.h"
#ifndef FGREP_PROGRAM
# include <regex.h>
# include "dfa.h"
#endif
#include "kwset.h"
#include "error.h"
#include "xalloc.h"
#ifdef HAVE_LIBPCRE
# include <pcre.h>
#endif

#define NCHAR (UCHAR_MAX + 1)

/* For -w, we also consider _ to be word constituent.  */
#define WCHAR(C) (ISALNUM(C) || (C) == '_')

/* KWset compiled pattern.  For Ecompile and Gcompile, we compile
   a list of strings, at least one of which is known to occur in
   any string matching the regexp. */
static kwset_t kwset;

static void
kwsinit (void)
{
  static char trans[NCHAR];
  int i;

  if (match_icase && MB_CUR_MAX == 1)
    {
      for (i = 0; i < NCHAR; ++i)
        trans[i] = TOLOWER (i);

      kwset = kwsalloc (trans);
    }
  else
    kwset = kwsalloc (NULL);

  if (!kwset)
    xalloc_die ();
}

#ifdef MBS_SUPPORT
/* Convert the *N-byte string, BEG, to lowercase, and write the
   NUL-terminated result into malloc'd storage.  Upon success, set *N
   to the length (in bytes) of the resulting string (not including the
   trailing NUL byte), and return a pointer to the lowercase string.
   Upon memory allocation failure, this function exits.

   Note that while this function returns a pointer to malloc'd storage,
   the caller must not free it, since this function retains a pointer
   to the buffer and reuses it on any subsequent call.  As a consequence,
   this function is not thread-safe.  */
static char *
mbtolower (const char *beg, size_t *n)
{
  static char *out;
  static size_t outalloc;
  size_t outlen, mb_cur_max;
  mbstate_t is, os;
  const char *end;
  char *p;

  if (*n > outalloc)
    {
      out = xrealloc (out, *n);
      outalloc = *n;
    }

  memset (&is, 0, sizeof (is));
  memset (&os, 0, sizeof (os));
  end = beg + *n;

  mb_cur_max = MB_CUR_MAX;
  p = out;
  outlen = 0;
  while (beg < end)
    {
      wchar_t wc;
      size_t mbclen = mbrtowc(&wc, beg, end - beg, &is);
      if (outlen + mb_cur_max >= outalloc)
        {
          out = x2nrealloc (out, &outalloc, 1);
          p = out + outlen;
        }

      if (mbclen == (size_t) -1 || mbclen == (size_t) -2 || mbclen == 0)
        {
          /* An invalid sequence, or a truncated multi-octet character.
             We treat it as a single-octet character.  */
          *p++ = *beg++;
          outlen++;
          memset (&is, 0, sizeof (is));
          memset (&os, 0, sizeof (os));
        }
      else
        {
          beg += mbclen;
          mbclen = wcrtomb (p, towlower ((wint_t) wc), &os);
          p += mbclen;
          outlen += mbclen;
        }
    }

  *n = p - out;
  *p++ = 0;
  return out;
}
#endif


#ifndef FGREP_PROGRAM
/* DFA compiled regexp. */
static struct dfa dfa;

/* The Regex compiled patterns.  */
static struct patterns
{
  /* Regex compiled regexp. */
  struct re_pattern_buffer regexbuf;
  struct re_registers regs; /* This is here on account of a BRAIN-DEAD
			       Q@#%!# library interface in regex.c.  */
} patterns0;

struct patterns *patterns;
size_t pcount;

void
dfaerror (char const *mesg)
{
  error (EXIT_TROUBLE, 0, "%s", mesg);
}

/* Number of compiled fixed strings known to exactly match the regexp.
   If kwsexec returns < kwset_exact_matches, then we don't need to
   call the regexp matcher at all. */
static int kwset_exact_matches;

static char const *
kwsincr_case (const char *must)
{
  const char *buf;
  size_t n;

  n = strlen (must);
#ifdef MBS_SUPPORT
  if (match_icase && MB_CUR_MAX > 1)
    buf = mbtolower (must, &n);
  else
#endif
    buf = must;
  return kwsincr (kwset, buf, n);
}

/* If the DFA turns out to have some set of fixed strings one of
   which must occur in the match, then we build a kwset matcher
   to find those strings, and thus quickly filter out impossible
   matches. */
static void
kwsmusts (void)
{
  struct dfamust const *dm;
  char const *err;

  if (dfa.musts)
    {
      kwsinit ();
      /* First, we compile in the substrings known to be exact
	 matches.  The kwset matcher will return the index
	 of the matching string that it chooses. */
      for (dm = dfa.musts; dm; dm = dm->next)
	{
	  if (!dm->exact)
	    continue;
	  ++kwset_exact_matches;
	  if ((err = kwsincr_case (dm->must)) != NULL)
	    error (EXIT_TROUBLE, 0, "%s", err);
	}
      /* Now, we compile the substrings that will require
	 the use of the regexp matcher.  */
      for (dm = dfa.musts; dm; dm = dm->next)
	{
	  if (dm->exact)
	    continue;
	  if ((err = kwsincr_case (dm->must)) != NULL)
	    error (EXIT_TROUBLE, 0, "%s", err);
	}
      if ((err = kwsprep (kwset)) != NULL)
	error (EXIT_TROUBLE, 0, "%s", err);
    }
}
#endif /* !FGREP_PROGRAM */

#ifdef MBS_SUPPORT

static bool
is_mb_middle(const char **good, const char *buf, const char *end)
{
  const char *p = *good;
  const char *prev = p;
  mbstate_t cur_state;

  /* TODO: can be optimized for UTF-8.  */
  memset(&cur_state, 0, sizeof(mbstate_t));
  while (p < buf)
    {
      size_t mbclen = mbrlen(p, end - p, &cur_state);

      /* Store the beginning of the previous complete multibyte character.  */
      if (mbclen != (size_t) -2)
        prev = p;

      if (mbclen == (size_t) -1 || mbclen == (size_t) -2 || mbclen == 0)
	{
	  /* An invalid sequence, or a truncated multibyte character.
	     We treat it as a single byte character.  */
	  mbclen = 1;
	}
      p += mbclen;
    }

  *good = prev;
  return p > buf;
}
#endif /* MBS_SUPPORT */

#if defined(GREP_PROGRAM) || defined(EGREP_PROGRAM)
#ifdef EGREP_PROGRAM
COMPILE_FCT(Ecompile)
{
  reg_syntax_t syntax_bits = RE_SYNTAX_POSIX_EGREP;
#else
/* No __VA_ARGS__ in C89.  So we have to do it this way.  */
static COMPILE_RET
GEAcompile (char const *pattern, size_t size, reg_syntax_t syntax_bits)
{
#endif /* EGREP_PROGRAM */
  const char *err;
  const char *p, *sep;
  size_t total = size;
  char *motif;

  if (match_icase)
    syntax_bits |= RE_ICASE;
  re_set_syntax (syntax_bits);
  dfasyntax (syntax_bits, match_icase, eolbyte);

  /* For GNU regex compiler we have to pass the patterns separately to detect
     errors like "[\nallo\n]\n".  The patterns here are "[", "allo" and "]"
     GNU regex should have raise a syntax error.  The same for backref, where
     the backref should have been local to each pattern.  */
  p = pattern;
  do
    {
      size_t len;
      sep = memchr (p, '\n', total);
      if (sep)
	{
	  len = sep - p;
	  sep++;
	  total -= (len + 1);
	}
      else
	{
	  len = total;
	  total = 0;
	}

      patterns = realloc (patterns, (pcount + 1) * sizeof (*patterns));
      if (patterns == NULL)
	error (EXIT_TROUBLE, errno, _("memory exhausted"));
      patterns[pcount] = patterns0;

      if ((err = re_compile_pattern (p, len,
				    &(patterns[pcount].regexbuf))) != NULL)
	error (EXIT_TROUBLE, 0, "%s", err);
      pcount++;

      p = sep;
    } while (sep && total != 0);

  /* In the match_words and match_lines cases, we use a different pattern
     for the DFA matcher that will quickly throw out cases that won't work.
     Then if DFA succeeds we do some hairy stuff using the regex matcher
     to decide whether the match should really count. */
  if (match_words || match_lines)
    {
      static char const line_beg_no_bk[] = "^(";
      static char const line_end_no_bk[] = ")$";
      static char const word_beg_no_bk[] = "(^|[^[:alnum:]_])(";
      static char const word_end_no_bk[] = ")([^[:alnum:]_]|$)";
#ifdef EGREP_PROGRAM
# define IF_BK(x, y) (y)
      char *n = xmalloc (sizeof word_beg_no_bk - 1 + size + sizeof word_end_no_bk);
#else
      static char const line_beg_bk[] = "^\\(";
      static char const line_end_bk[] = "\\)$";
      static char const word_beg_bk[] = "\\(^\\|[^[:alnum:]_]\\)\\(";
      static char const word_end_bk[] = "\\)\\([^[:alnum:]_]\\|$\\)";
      int bk = !(syntax_bits & RE_NO_BK_PARENS);
# define IF_BK(x, y) ((bk) ? (x) : (y))
      char *n = xmalloc (sizeof word_beg_bk - 1 + size + sizeof word_end_bk);
#endif /* EGREP_PROGRAM */

      strcpy (n, match_lines ? IF_BK(line_beg_bk, line_beg_no_bk)
			     : IF_BK(word_beg_bk, word_beg_no_bk));
      total = strlen(n);
      memcpy (n + total, pattern, size);
      total += size;
      strcpy (n + total, match_lines ? IF_BK(line_end_bk, line_end_no_bk)
				     : IF_BK(word_end_bk, word_end_no_bk));
      total += strlen (n + total);
      pattern = motif = n;
      size = total;
    }
  else
    motif = NULL;

  dfacomp (pattern, size, &dfa, 1);
  kwsmusts ();

  free(motif);
}

#ifndef EGREP_PROGRAM
COMPILE_FCT(Gcompile)
{
  return GEAcompile (pattern, size,
		     RE_SYNTAX_GREP | RE_HAT_LISTS_NOT_NEWLINE);
}

COMPILE_FCT(Acompile)
{
  return GEAcompile (pattern, size, RE_SYNTAX_AWK);
}

COMPILE_FCT(Ecompile)
{
  return GEAcompile (pattern, size, RE_SYNTAX_POSIX_EGREP);
}
#endif /* !EGREP_PROGRAM */

EXECUTE_FCT(EGexecute)
{
  char const *buflim, *beg, *end, *match, *best_match, *mb_start;
  char eol = eolbyte;
  int backref, start, len, best_len;
  struct kwsmatch kwsm;
  size_t i, ret_val;
#ifdef MBS_SUPPORT
  if (MB_CUR_MAX > 1)
    {
      if (match_icase)
        {
          /* mbtolower adds a NUL byte at the end.  That will provide
	     space for the sentinel byte dfaexec may add.  */
          char *case_buf = mbtolower (buf, &size);
	  if (start_ptr)
	    start_ptr = case_buf + (start_ptr - buf);
          buf = case_buf;
        }
    }
#endif /* MBS_SUPPORT */

  mb_start = buf;
  buflim = buf + size;

  for (beg = end = buf; end < buflim; beg = end)
    {
      if (!start_ptr)
	{
	  /* We don't care about an exact match.  */
	  if (kwset)
	    {
	      /* Find a possible match using the KWset matcher. */
	      size_t offset = kwsexec (kwset, beg, buflim - beg, &kwsm);
	      if (offset == (size_t) -1)
		goto failure;
	      beg += offset;
	      /* Narrow down to the line containing the candidate, and
		 run it through DFA. */
	      if ((end = memchr(beg, eol, buflim - beg)) != NULL)
	        end++;
              else
                end = buflim;
	      match = beg;
	      while (beg > buf && beg[-1] != eol)
		--beg;
	      if (kwsm.index < kwset_exact_matches)
                {
#ifdef MBS_SUPPORT
                  if (mb_start < beg)
                    mb_start = beg;
                  if (MB_CUR_MAX == 1 || !is_mb_middle (&mb_start, match, buflim))
#endif
                    goto success;
                }
	      if (dfaexec (&dfa, beg, (char *) end, 0, NULL, &backref) == NULL)
		continue;
	    }
	  else
	    {
	      /* No good fixed strings; start with DFA. */
	      char const *next_beg = dfaexec (&dfa, beg, (char *) buflim,
					      0, NULL, &backref);
	      if (next_beg == NULL)
		break;
	      /* Narrow down to the line we've found. */
	      beg = next_beg;
	      if ((end = memchr(beg, eol, buflim - beg)) != NULL)
	        end++;
              else
                end = buflim;
	      while (beg > buf && beg[-1] != eol)
		--beg;
	    }
	  /* Successful, no backreferences encountered! */
	  if (!backref)
	    goto success;
	}
      else
	{
	  /* We are looking for the leftmost (then longest) exact match.
	     We will go through the outer loop only once.  */
	  beg = start_ptr;
	  end = buflim;
	}

      /* If we've made it to this point, this means DFA has seen
	 a probable match, and we need to run it through Regex. */
      best_match = end;
      best_len = 0;
      for (i = 0; i < pcount; i++)
	{
	  patterns[i].regexbuf.not_eol = 0;
	  if (0 <= (start = re_search (&(patterns[i].regexbuf),
				       buf, end - buf - 1,
				       beg - buf, end - beg - 1,
				       &(patterns[i].regs))))
	    {
	      len = patterns[i].regs.end[0] - start;
	      match = buf + start;
	      if (match > best_match)
		continue;
	      if (start_ptr && !match_words)
		goto assess_pattern_match;
	      if ((!match_lines && !match_words)
		  || (match_lines && len == end - beg - 1))
		{
		  match = beg;
		  len = end - beg;
		  goto assess_pattern_match;
		}
	      /* If -w, check if the match aligns with word boundaries.
		 We do this iteratively because:
		 (a) the line may contain more than one occurence of the
		 pattern, and
		 (b) Several alternatives in the pattern might be valid at a
		 given point, and we may need to consider a shorter one to
		 find a word boundary.  */
	      if (match_words)
		while (match <= best_match)
		  {
		    if ((match == buf || !WCHAR ((unsigned char) match[-1]))
			&& (len == end - beg - 1
			    || !WCHAR ((unsigned char) match[len])))
		      goto assess_pattern_match;
		    if (len > 0)
		      {
			/* Try a shorter length anchored at the same place. */
			--len;
			patterns[i].regexbuf.not_eol = 1;
			len = re_match (&(patterns[i].regexbuf),
					buf, match + len - beg, match - buf,
					&(patterns[i].regs));
		      }
		    if (len <= 0)
		      {
			/* Try looking further on. */
			if (match == end - 1)
			  break;
			match++;
			patterns[i].regexbuf.not_eol = 0;
			start = re_search (&(patterns[i].regexbuf),
					   buf, end - buf - 1,
					   match - buf, end - match - 1,
					   &(patterns[i].regs));
			if (start < 0)
			  break;
			len = patterns[i].regs.end[0] - start;
			match = buf + start;
		      }
		  } /* while (match <= best_match) */
	      continue;
	    assess_pattern_match:
	      if (!start_ptr)
		{
		  /* Good enough for a non-exact match.
		     No need to look at further patterns, if any.  */
		  beg = match;
		  goto success_in_len;
		}
	      if (match < best_match || (match == best_match && len > best_len))
		{
		  /* Best exact match:  leftmost, then longest.  */
		  best_match = match;
		  best_len = len;
		}
	    } /* if re_search >= 0 */
	} /* for Regex patterns.  */
	if (best_match < end)
	  {
	    /* We have found an exact match.  We were just
	       waiting for the best one (leftmost then longest).  */
	    beg = best_match;
	    len = best_len;
	    goto success_in_len;
	  }
    } /* for (beg = end ..) */

 failure:
  ret_val = -1;
  goto out;

 success:
  len = end - beg;
 success_in_len:
  *match_size = len;
  ret_val = beg - buf;
 out:
  return ret_val;
}
#endif /* defined(GREP_PROGRAM) || defined(EGREP_PROGRAM) */

#if defined(GREP_PROGRAM) || defined(FGREP_PROGRAM)
COMPILE_FCT(Fcompile)
{
  char const *beg, *end, *lim, *err, *pat;
  size_t psize;

  kwsinit ();
  psize = size;
  if (match_icase && MB_CUR_MAX > 1)
    pat = mbtolower (pattern, &psize);
  else
    pat = pattern;

  beg = pat;
  do
    {
      for (lim = beg;; ++lim)
	{
	  end = lim;
	  if (lim >= pat + psize)
	    break;
	 //prophet generated patch
	 if (__get_mutant()==0) {
	 if ((*lim == '\n') && !(__is_neg(10, &(lim), sizeof (lim), &(pat), sizeof (pat), &(psize), sizeof (psize), &(end), sizeof (end), &(beg), sizeof (beg), &(pattern), sizeof (pattern), &(match_icase), sizeof (match_icase), &(size), sizeof (size), &(err), sizeof (err), &(kwset), sizeof (kwset)))) {
	     lim++;
	     break;
	 }
	 }
	 else if (__get_mutant()==1) {
	 if ((*lim == '\n') || (__is_neg(10, &(lim), sizeof (lim), &(pat), sizeof (pat), &(psize), sizeof (psize), &(end), sizeof (end), &(beg), sizeof (beg), &(pattern), sizeof (pattern), &(match_icase), sizeof (match_icase), &(size), sizeof (size), &(err), sizeof (err), &(kwset), sizeof (kwset)))) {
	     lim++;
	     break;
	 }
	 }
#if HAVE_DOS_FILE_CONTENTS
	 if (*lim == '\r' && lim + 1 < pat + psize && lim[1] == '\n')
	   {
	     lim += 2;
	     break;
	   }
#endif
	}

      if ((err = kwsincr (kwset, beg, end - beg)) != NULL)
	error (EXIT_TROUBLE, 0, "%s", err);
      beg = lim;
    }
  while (beg < pat + psize);

  if ((err = kwsprep (kwset)) != NULL)
    error (EXIT_TROUBLE, 0, "%s", err);
}

EXECUTE_FCT(Fexecute)
{
  char const *beg, *try, *end, *mb_start;
  size_t len;
  char eol = eolbyte;
  struct kwsmatch kwsmatch;
  size_t ret_val;
#ifdef MBS_SUPPORT
  if (MB_CUR_MAX > 1)
    {
      if (match_icase)
        {
          char *case_buf = mbtolower (buf, &size);
	  if (start_ptr)
	    start_ptr = case_buf + (start_ptr - buf);
          buf = case_buf;
        }
    }
#endif /* MBS_SUPPORT */

  for (mb_start = beg = start_ptr ? start_ptr : buf; beg <= buf + size; beg++)
    {
      size_t offset = kwsexec (kwset, beg, buf + size - beg, &kwsmatch);
      if (offset == (size_t) -1)
	goto failure;
#ifdef MBS_SUPPORT
      if (MB_CUR_MAX > 1 && is_mb_middle (&mb_start, beg + offset, buf + size))
        {
          beg = mb_start - 1;
          continue; /* It is a part of multibyte character.  */
        }
#endif /* MBS_SUPPORT */
      beg += offset;
      len = kwsmatch.size[0];
      if (start_ptr && !match_words)
	goto success_in_beg_and_len;
      if (match_lines)
	{
	  if (beg > buf && beg[-1] != eol)
	    continue;
	  if (beg + len < buf + size && beg[len] != eol)
	    continue;
	  goto success;
	}
      else if (match_words)
	for (try = beg; len; )
	  {
	    if (try > buf && WCHAR((unsigned char) try[-1]))
	      break;
	    if (try + len < buf + size && WCHAR((unsigned char) try[len]))
	      {
		offset = kwsexec (kwset, beg, --len, &kwsmatch);
		if (offset == (size_t) -1)
		  break;
		try = beg + offset;
		len = kwsmatch.size[0];
	      }
	    else if (!start_ptr)
	      goto success;
	    else
	      goto success_in_beg_and_len;
	  } /* for (try) */
      else
	goto success;
    } /* for (beg in buf) */

 failure:
  ret_val = -1;
  goto out;

 success:
  if ((end = memchr (beg + len, eol, (buf + size) - (beg + len))) != NULL)
    end++;
  else
    end = buf + size;
  while (buf < beg && beg[-1] != eol)
    --beg;
  len = end - beg;
 success_in_beg_and_len:
  *match_size = len;
  ret_val = beg - buf;
 out:
  return ret_val;
}
#endif /* defined(GREP_PROGRAM) || defined(FGREP_PROGRAM) */

#ifdef GREP_PROGRAM
#if HAVE_LIBPCRE
/* Compiled internal form of a Perl regular expression.  */
static pcre *cre;

/* Additional information about the pattern.  */
static pcre_extra *extra;
#endif

COMPILE_FCT(Pcompile)
{
#if !HAVE_LIBPCRE
  error (EXIT_TROUBLE, 0, "%s",
	 _("support for the -P option is not compiled into "
	   "this --disable-perl-regexp binary"));
#else
  int e;
  char const *ep;
  char *re = xmalloc (4 * size + 7);
  int flags = PCRE_MULTILINE | (match_icase ? PCRE_CASELESS : 0);
  char const *patlim = pattern + size;
  char *n = re;
  char const *p;
  char const *pnul;

  /* FIXME: Remove these restrictions.  */
  if (memchr(pattern, '\n', size))
    error (EXIT_TROUBLE, 0, _("the -P option only supports a single pattern"));

  *n = '\0';
  if (match_lines)
    strcpy (n, "^(");
  if (match_words)
    strcpy (n, "\\b(");
  n += strlen (n);

  /* The PCRE interface doesn't allow NUL bytes in the pattern, so
     replace each NUL byte in the pattern with the four characters
     "\000", removing a preceding backslash if there are an odd
     number of backslashes before the NUL.

     FIXME: This method does not work with some multibyte character
     encodings, notably Shift-JIS, where a multibyte character can end
     in a backslash byte.  */
  for (p = pattern; (pnul = memchr (p, '\0', patlim - p)); p = pnul + 1)
    {
      memcpy (n, p, pnul - p);
      n += pnul - p;
      for (p = pnul; pattern < p && p[-1] == '\\'; p--)
	continue;
      n -= (pnul - p) & 1;
      strcpy (n, "\\000");
      n += 4;
    }

  memcpy (n, p, patlim - p);
  n += patlim - p;
  *n = '\0';
  if (match_words)
    strcpy (n, ")\\b");
  if (match_lines)
    strcpy (n, ")$");

  cre = pcre_compile (re, flags, &ep, &e, pcre_maketables ());
  if (!cre)
    error (EXIT_TROUBLE, 0, "%s", ep);

  extra = pcre_study (cre, 0, &ep);
  if (ep)
    error (EXIT_TROUBLE, 0, "%s", ep);

  free (re);
#endif
}

EXECUTE_FCT(Pexecute)
{
#if !HAVE_LIBPCRE
  abort ();
  return -1;
#else
  /* This array must have at least two elements; everything after that
     is just for performance improvement in pcre_exec.  */
  int sub[300];

  const char *line_buf, *line_end, *line_next;
  int e = PCRE_ERROR_NOMATCH;
  ptrdiff_t start_ofs = start_ptr ? start_ptr - buf : 0;

  /* PCRE can't limit the matching to single lines, therefore we have to
     match each line in the buffer separately.  */
  for (line_next = buf;
       e == PCRE_ERROR_NOMATCH && line_next < buf + size;
       start_ofs -= line_next - line_buf)
    {
      line_buf = line_next;
      line_end = memchr (line_buf, eolbyte, (buf + size) - line_buf);
      if (line_end == NULL)
        line_next = line_end = buf + size;
      else
        line_next = line_end + 1;

      if (start_ptr && start_ptr >= line_end)
        continue;

      e = pcre_exec (cre, extra, line_buf, line_end - line_buf,
                     start_ofs < 0 ? 0 : start_ofs, 0,
                     sub, sizeof sub / sizeof *sub);
    }

  if (e <= 0)
    {
      switch (e)
	{
	case PCRE_ERROR_NOMATCH:
	  return -1;

	case PCRE_ERROR_NOMEMORY:
	  error (EXIT_TROUBLE, 0, _("memory exhausted"));

	default:
	  abort ();
	}
    }
  else
    {
      /* Narrow down to the line we've found.  */
      char const *beg = line_buf + sub[0];
      char const *end = line_buf + sub[1];
      char const *buflim = buf + size;
      char eol = eolbyte;
      if (!start_ptr)
	{
	  /* FIXME: The case when '\n' is not found indicates a bug:
	     Since grep is line oriented, the match should never contain
	     a newline, so there _must_ be a newline following.
	   */
	  if (!(end = memchr (end, eol, buflim - end)))
	    end = buflim;
	  else
	    end++;
	  while (buf < beg && beg[-1] != eol)
	    --beg;
	}

      *match_size = end - beg;
      return beg - buf;
    }
#endif
}

struct matcher const matchers[] = {
  { "default", Gcompile, EGexecute },
  { "grep",    Gcompile, EGexecute },
  { "egrep",   Ecompile, EGexecute },
  { "awk",     Acompile, EGexecute },
  { "fgrep",   Fcompile, Fexecute },
  { "perl",    Pcompile, Pexecute },
  { "", 0, 0 },
};
#endif /* GREP_PROGRAM */

Building:src at:
/home/ubuntu/spr-fast/tests/corebench/grep/grep-case-deccad69-db9d6340/tempworkdir2/srcMerged code building succ, going to invoke tester!
CondTester, Testing instance id 18:
//src_file:src/search.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
/* search.c - searching subroutines using dfa, kwset and regex for grep.
   Copyright 1992, 1998, 2000, 2007, 2009-2010 Free Software Foundation, Inc.

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 3, or (at your option)
   any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program; if not, write to the Free Software
   Foundation, Inc., 51 Franklin Street - Fifth Floor, Boston, MA
   02110-1301, USA.  */

/* Written August 1992 by Mike Haertel. */

#include <config.h>

#include <sys/types.h>

#include "mbsupport.h"
#ifdef MBS_SUPPORT
/* We can handle multibyte strings. */
# include <wchar.h>
# include <wctype.h>
#endif

#include "system.h"
#include "grep.h"
#ifndef FGREP_PROGRAM
# include <regex.h>
# include "dfa.h"
#endif
#include "kwset.h"
#include "error.h"
#include "xalloc.h"
#ifdef HAVE_LIBPCRE
# include <pcre.h>
#endif

#define NCHAR (UCHAR_MAX + 1)

/* For -w, we also consider _ to be word constituent.  */
#define WCHAR(C) (ISALNUM(C) || (C) == '_')

/* KWset compiled pattern.  For Ecompile and Gcompile, we compile
   a list of strings, at least one of which is known to occur in
   any string matching the regexp. */
static kwset_t kwset;

static void
kwsinit (void)
{
  static char trans[NCHAR];
  int i;

  if (match_icase && MB_CUR_MAX == 1)
    {
      for (i = 0; i < NCHAR; ++i)
        trans[i] = TOLOWER (i);

      kwset = kwsalloc (trans);
    }
  else
    kwset = kwsalloc (NULL);

  if (!kwset)
    xalloc_die ();
}

#ifdef MBS_SUPPORT
/* Convert the *N-byte string, BEG, to lowercase, and write the
   NUL-terminated result into malloc'd storage.  Upon success, set *N
   to the length (in bytes) of the resulting string (not including the
   trailing NUL byte), and return a pointer to the lowercase string.
   Upon memory allocation failure, this function exits.

   Note that while this function returns a pointer to malloc'd storage,
   the caller must not free it, since this function retains a pointer
   to the buffer and reuses it on any subsequent call.  As a consequence,
   this function is not thread-safe.  */
static char *
mbtolower (const char *beg, size_t *n)
{
  static char *out;
  static size_t outalloc;
  size_t outlen, mb_cur_max;
  mbstate_t is, os;
  const char *end;
  char *p;

  if (*n > outalloc)
    {
      out = xrealloc (out, *n);
      outalloc = *n;
    }

  memset (&is, 0, sizeof (is));
  memset (&os, 0, sizeof (os));
  end = beg + *n;

  mb_cur_max = MB_CUR_MAX;
  p = out;
  outlen = 0;
  while (beg < end)
    {
      wchar_t wc;
      size_t mbclen = mbrtowc(&wc, beg, end - beg, &is);
      if (outlen + mb_cur_max >= outalloc)
        {
          out = x2nrealloc (out, &outalloc, 1);
          p = out + outlen;
        }

      if (mbclen == (size_t) -1 || mbclen == (size_t) -2 || mbclen == 0)
        {
          /* An invalid sequence, or a truncated multi-octet character.
             We treat it as a single-octet character.  */
          *p++ = *beg++;
          outlen++;
          memset (&is, 0, sizeof (is));
          memset (&os, 0, sizeof (os));
        }
      else
        {
          beg += mbclen;
          mbclen = wcrtomb (p, towlower ((wint_t) wc), &os);
          p += mbclen;
          outlen += mbclen;
        }
    }

  *n = p - out;
  *p++ = 0;
  return out;
}
#endif


#ifndef FGREP_PROGRAM
/* DFA compiled regexp. */
static struct dfa dfa;

/* The Regex compiled patterns.  */
static struct patterns
{
  /* Regex compiled regexp. */
  struct re_pattern_buffer regexbuf;
  struct re_registers regs; /* This is here on account of a BRAIN-DEAD
			       Q@#%!# library interface in regex.c.  */
} patterns0;

struct patterns *patterns;
size_t pcount;

void
dfaerror (char const *mesg)
{
  error (EXIT_TROUBLE, 0, "%s", mesg);
}

/* Number of compiled fixed strings known to exactly match the regexp.
   If kwsexec returns < kwset_exact_matches, then we don't need to
   call the regexp matcher at all. */
static int kwset_exact_matches;

static char const *
kwsincr_case (const char *must)
{
  const char *buf;
  size_t n;

  n = strlen (must);
#ifdef MBS_SUPPORT
  if (match_icase && MB_CUR_MAX > 1)
    buf = mbtolower (must, &n);
  else
#endif
    buf = must;
  return kwsincr (kwset, buf, n);
}

/* If the DFA turns out to have some set of fixed strings one of
   which must occur in the match, then we build a kwset matcher
   to find those strings, and thus quickly filter out impossible
   matches. */
static void
kwsmusts (void)
{
  struct dfamust const *dm;
  char const *err;

  if (dfa.musts)
    {
      kwsinit ();
      /* First, we compile in the substrings known to be exact
	 matches.  The kwset matcher will return the index
	 of the matching string that it chooses. */
      for (dm = dfa.musts; dm; dm = dm->next)
	{
	  if (!dm->exact)
	    continue;
	  ++kwset_exact_matches;
	  if ((err = kwsincr_case (dm->must)) != NULL)
	    error (EXIT_TROUBLE, 0, "%s", err);
	}
      /* Now, we compile the substrings that will require
	 the use of the regexp matcher.  */
      for (dm = dfa.musts; dm; dm = dm->next)
	{
	  if (dm->exact)
	    continue;
	  if ((err = kwsincr_case (dm->must)) != NULL)
	    error (EXIT_TROUBLE, 0, "%s", err);
	}
      if ((err = kwsprep (kwset)) != NULL)
	error (EXIT_TROUBLE, 0, "%s", err);
    }
}
#endif /* !FGREP_PROGRAM */

#ifdef MBS_SUPPORT

static bool
is_mb_middle(const char **good, const char *buf, const char *end)
{
  const char *p = *good;
  const char *prev = p;
  mbstate_t cur_state;

  /* TODO: can be optimized for UTF-8.  */
  memset(&cur_state, 0, sizeof(mbstate_t));
  while (p < buf)
    {
      size_t mbclen = mbrlen(p, end - p, &cur_state);

      /* Store the beginning of the previous complete multibyte character.  */
      if (mbclen != (size_t) -2)
        prev = p;

      if (mbclen == (size_t) -1 || mbclen == (size_t) -2 || mbclen == 0)
	{
	  /* An invalid sequence, or a truncated multibyte character.
	     We treat it as a single byte character.  */
	  mbclen = 1;
	}
      p += mbclen;
    }

  *good = prev;
  return p > buf;
}
#endif /* MBS_SUPPORT */

#if defined(GREP_PROGRAM) || defined(EGREP_PROGRAM)
#ifdef EGREP_PROGRAM
COMPILE_FCT(Ecompile)
{
  reg_syntax_t syntax_bits = RE_SYNTAX_POSIX_EGREP;
#else
/* No __VA_ARGS__ in C89.  So we have to do it this way.  */
static COMPILE_RET
GEAcompile (char const *pattern, size_t size, reg_syntax_t syntax_bits)
{
#endif /* EGREP_PROGRAM */
  const char *err;
  const char *p, *sep;
  size_t total = size;
  char *motif;

  if (match_icase)
    syntax_bits |= RE_ICASE;
  re_set_syntax (syntax_bits);
  dfasyntax (syntax_bits, match_icase, eolbyte);

  /* For GNU regex compiler we have to pass the patterns separately to detect
     errors like "[\nallo\n]\n".  The patterns here are "[", "allo" and "]"
     GNU regex should have raise a syntax error.  The same for backref, where
     the backref should have been local to each pattern.  */
  p = pattern;
  do
    {
      size_t len;
      sep = memchr (p, '\n', total);
      if (sep)
	{
	  len = sep - p;
	  sep++;
	  total -= (len + 1);
	}
      else
	{
	  len = total;
	  total = 0;
	}

      patterns = realloc (patterns, (pcount + 1) * sizeof (*patterns));
      if (patterns == NULL)
	error (EXIT_TROUBLE, errno, _("memory exhausted"));
      patterns[pcount] = patterns0;

      if ((err = re_compile_pattern (p, len,
				    &(patterns[pcount].regexbuf))) != NULL)
	error (EXIT_TROUBLE, 0, "%s", err);
      pcount++;

      p = sep;
    } while (sep && total != 0);

  /* In the match_words and match_lines cases, we use a different pattern
     for the DFA matcher that will quickly throw out cases that won't work.
     Then if DFA succeeds we do some hairy stuff using the regex matcher
     to decide whether the match should really count. */
  if (match_words || match_lines)
    {
      static char const line_beg_no_bk[] = "^(";
      static char const line_end_no_bk[] = ")$";
      static char const word_beg_no_bk[] = "(^|[^[:alnum:]_])(";
      static char const word_end_no_bk[] = ")([^[:alnum:]_]|$)";
#ifdef EGREP_PROGRAM
# define IF_BK(x, y) (y)
      char *n = xmalloc (sizeof word_beg_no_bk - 1 + size + sizeof word_end_no_bk);
#else
      static char const line_beg_bk[] = "^\\(";
      static char const line_end_bk[] = "\\)$";
      static char const word_beg_bk[] = "\\(^\\|[^[:alnum:]_]\\)\\(";
      static char const word_end_bk[] = "\\)\\([^[:alnum:]_]\\|$\\)";
      int bk = !(syntax_bits & RE_NO_BK_PARENS);
# define IF_BK(x, y) ((bk) ? (x) : (y))
      char *n = xmalloc (sizeof word_beg_bk - 1 + size + sizeof word_end_bk);
#endif /* EGREP_PROGRAM */

      strcpy (n, match_lines ? IF_BK(line_beg_bk, line_beg_no_bk)
			     : IF_BK(word_beg_bk, word_beg_no_bk));
      total = strlen(n);
      memcpy (n + total, pattern, size);
      total += size;
      strcpy (n + total, match_lines ? IF_BK(line_end_bk, line_end_no_bk)
				     : IF_BK(word_end_bk, word_end_no_bk));
      total += strlen (n + total);
      pattern = motif = n;
      size = total;
    }
  else
    motif = NULL;

  dfacomp (pattern, size, &dfa, 1);
  kwsmusts ();

  free(motif);
}

#ifndef EGREP_PROGRAM
COMPILE_FCT(Gcompile)
{
  return GEAcompile (pattern, size,
		     RE_SYNTAX_GREP | RE_HAT_LISTS_NOT_NEWLINE);
}

COMPILE_FCT(Acompile)
{
  return GEAcompile (pattern, size, RE_SYNTAX_AWK);
}

COMPILE_FCT(Ecompile)
{
  return GEAcompile (pattern, size, RE_SYNTAX_POSIX_EGREP);
}
#endif /* !EGREP_PROGRAM */

EXECUTE_FCT(EGexecute)
{
  char const *buflim, *beg, *end, *match, *best_match, *mb_start;
  char eol = eolbyte;
  int backref, start, len, best_len;
  struct kwsmatch kwsm;
  size_t i, ret_val;
#ifdef MBS_SUPPORT
  if (MB_CUR_MAX > 1)
    {
      if (match_icase)
        {
          /* mbtolower adds a NUL byte at the end.  That will provide
	     space for the sentinel byte dfaexec may add.  */
          char *case_buf = mbtolower (buf, &size);
	  if (start_ptr)
	    start_ptr = case_buf + (start_ptr - buf);
          buf = case_buf;
        }
    }
#endif /* MBS_SUPPORT */

  mb_start = buf;
  buflim = buf + size;

  for (beg = end = buf; end < buflim; beg = end)
    {
      if (!start_ptr)
	{
	  /* We don't care about an exact match.  */
	  if (kwset)
	    {
	      /* Find a possible match using the KWset matcher. */
	      size_t offset = kwsexec (kwset, beg, buflim - beg, &kwsm);
	      if (offset == (size_t) -1)
		goto failure;
	      beg += offset;
	      /* Narrow down to the line containing the candidate, and
		 run it through DFA. */
	      if ((end = memchr(beg, eol, buflim - beg)) != NULL)
	        end++;
              else
                end = buflim;
	      match = beg;
	      while (beg > buf && beg[-1] != eol)
		--beg;
	      if (kwsm.index < kwset_exact_matches)
                {
#ifdef MBS_SUPPORT
                  if (mb_start < beg)
                    mb_start = beg;
                  if (MB_CUR_MAX == 1 || !is_mb_middle (&mb_start, match, buflim))
#endif
                    goto success;
                }
	      if (dfaexec (&dfa, beg, (char *) end, 0, NULL, &backref) == NULL)
		continue;
	    }
	  else
	    {
	      /* No good fixed strings; start with DFA. */
	      char const *next_beg = dfaexec (&dfa, beg, (char *) buflim,
					      0, NULL, &backref);
	      if (next_beg == NULL)
		break;
	      /* Narrow down to the line we've found. */
	      beg = next_beg;
	      if ((end = memchr(beg, eol, buflim - beg)) != NULL)
	        end++;
              else
                end = buflim;
	      while (beg > buf && beg[-1] != eol)
		--beg;
	    }
	  /* Successful, no backreferences encountered! */
	  if (!backref)
	    goto success;
	}
      else
	{
	  /* We are looking for the leftmost (then longest) exact match.
	     We will go through the outer loop only once.  */
	  beg = start_ptr;
	  end = buflim;
	}

      /* If we've made it to this point, this means DFA has seen
	 a probable match, and we need to run it through Regex. */
      best_match = end;
      best_len = 0;
      for (i = 0; i < pcount; i++)
	{
	  patterns[i].regexbuf.not_eol = 0;
	  if (0 <= (start = re_search (&(patterns[i].regexbuf),
				       buf, end - buf - 1,
				       beg - buf, end - beg - 1,
				       &(patterns[i].regs))))
	    {
	      len = patterns[i].regs.end[0] - start;
	      match = buf + start;
	      if (match > best_match)
		continue;
	      if (start_ptr && !match_words)
		goto assess_pattern_match;
	      if ((!match_lines && !match_words)
		  || (match_lines && len == end - beg - 1))
		{
		  match = beg;
		  len = end - beg;
		  goto assess_pattern_match;
		}
	      /* If -w, check if the match aligns with word boundaries.
		 We do this iteratively because:
		 (a) the line may contain more than one occurence of the
		 pattern, and
		 (b) Several alternatives in the pattern might be valid at a
		 given point, and we may need to consider a shorter one to
		 find a word boundary.  */
	      if (match_words)
		while (match <= best_match)
		  {
		    if ((match == buf || !WCHAR ((unsigned char) match[-1]))
			&& (len == end - beg - 1
			    || !WCHAR ((unsigned char) match[len])))
		      goto assess_pattern_match;
		    if (len > 0)
		      {
			/* Try a shorter length anchored at the same place. */
			--len;
			patterns[i].regexbuf.not_eol = 1;
			len = re_match (&(patterns[i].regexbuf),
					buf, match + len - beg, match - buf,
					&(patterns[i].regs));
		      }
		    if (len <= 0)
		      {
			/* Try looking further on. */
			if (match == end - 1)
			  break;
			match++;
			patterns[i].regexbuf.not_eol = 0;
			start = re_search (&(patterns[i].regexbuf),
					   buf, end - buf - 1,
					   match - buf, end - match - 1,
					   &(patterns[i].regs));
			if (start < 0)
			  break;
			len = patterns[i].regs.end[0] - start;
			match = buf + start;
		      }
		  } /* while (match <= best_match) */
	      continue;
	    assess_pattern_match:
	      if (!start_ptr)
		{
		  /* Good enough for a non-exact match.
		     No need to look at further patterns, if any.  */
		  beg = match;
		  goto success_in_len;
		}
	      if (match < best_match || (match == best_match && len > best_len))
		{
		  /* Best exact match:  leftmost, then longest.  */
		  best_match = match;
		  best_len = len;
		}
	    } /* if re_search >= 0 */
	} /* for Regex patterns.  */
	if (best_match < end)
	  {
	    /* We have found an exact match.  We were just
	       waiting for the best one (leftmost then longest).  */
	    beg = best_match;
	    len = best_len;
	    goto success_in_len;
	  }
    } /* for (beg = end ..) */

 failure:
  ret_val = -1;
  goto out;

 success:
  len = end - beg;
 success_in_len:
  *match_size = len;
  ret_val = beg - buf;
 out:
  return ret_val;
}
#endif /* defined(GREP_PROGRAM) || defined(EGREP_PROGRAM) */

#if defined(GREP_PROGRAM) || defined(FGREP_PROGRAM)
COMPILE_FCT(Fcompile)
{
  char const *beg, *end, *lim, *err, *pat;
  size_t psize;

  kwsinit ();
  psize = size;
  if (match_icase && MB_CUR_MAX > 1)
    pat = mbtolower (pattern, &psize);
  else
    pat = pattern;

  beg = pat;
  do
    {
      for (lim = beg;; ++lim)
	{
	  end = lim;
	  if (lim >= pat + psize)
	    break;
	 
//Patch 0:
if ((*lim == '\n') && !(__is_neg(10, &(lim), sizeof (lim), &(pat), sizeof (pat), &(psize), sizeof (psize), &(end), sizeof (end), &(beg), sizeof (beg), &(pattern), sizeof (pattern), &(match_icase), sizeof (match_icase), &(size), sizeof (size), &(err), sizeof (err), &(kwset), sizeof (kwset)))) {
    lim++;
    break;
}

//CodeSeg 1:
#if HAVE_DOS_FILE_CONTENTS
	 if (*lim == '\r' && lim + 1 < pat + psize && lim[1] == '\n')
	   {
	     lim += 2;
	     break;
	   }
#endif
	}

      if ((err = kwsincr (kwset, beg, end - beg)) != NULL)
	error (EXIT_TROUBLE, 0, "%s", err);
      beg = lim;
    }
  while (beg < pat + psize);

  if ((err = kwsprep (kwset)) != NULL)
    error (EXIT_TROUBLE, 0, "%s", err);
}

EXECUTE_FCT(Fexecute)
{
  char const *beg, *try, *end, *mb_start;
  size_t len;
  char eol = eolbyte;
  struct kwsmatch kwsmatch;
  size_t ret_val;
#ifdef MBS_SUPPORT
  if (MB_CUR_MAX > 1)
    {
      if (match_icase)
        {
          char *case_buf = mbtolower (buf, &size);
	  if (start_ptr)
	    start_ptr = case_buf + (start_ptr - buf);
          buf = case_buf;
        }
    }
#endif /* MBS_SUPPORT */

  for (mb_start = beg = start_ptr ? start_ptr : buf; beg <= buf + size; beg++)
    {
      size_t offset = kwsexec (kwset, beg, buf + size - beg, &kwsmatch);
      if (offset == (size_t) -1)
	goto failure;
#ifdef MBS_SUPPORT
      if (MB_CUR_MAX > 1 && is_mb_middle (&mb_start, beg + offset, buf + size))
        {
          beg = mb_start - 1;
          continue; /* It is a part of multibyte character.  */
        }
#endif /* MBS_SUPPORT */
      beg += offset;
      len = kwsmatch.size[0];
      if (start_ptr && !match_words)
	goto success_in_beg_and_len;
      if (match_lines)
	{
	  if (beg > buf && beg[-1] != eol)
	    continue;
	  if (beg + len < buf + size && beg[len] != eol)
	    continue;
	  goto success;
	}
      else if (match_words)
	for (try = beg; len; )
	  {
	    if (try > buf && WCHAR((unsigned char) try[-1]))
	      break;
	    if (try + len < buf + size && WCHAR((unsigned char) try[len]))
	      {
		offset = kwsexec (kwset, beg, --len, &kwsmatch);
		if (offset == (size_t) -1)
		  break;
		try = beg + offset;
		len = kwsmatch.size[0];
	      }
	    else if (!start_ptr)
	      goto success;
	    else
	      goto success_in_beg_and_len;
	  } /* for (try) */
      else
	goto success;
    } /* for (beg in buf) */

 failure:
  ret_val = -1;
  goto out;

 success:
  if ((end = memchr (beg + len, eol, (buf + size) - (beg + len))) != NULL)
    end++;
  else
    end = buf + size;
  while (buf < beg && beg[-1] != eol)
    --beg;
  len = end - beg;
 success_in_beg_and_len:
  *match_size = len;
  ret_val = beg - buf;
 out:
  return ret_val;
}
#endif /* defined(GREP_PROGRAM) || defined(FGREP_PROGRAM) */

#ifdef GREP_PROGRAM
#if HAVE_LIBPCRE
/* Compiled internal form of a Perl regular expression.  */
static pcre *cre;

/* Additional information about the pattern.  */
static pcre_extra *extra;
#endif

COMPILE_FCT(Pcompile)
{
#if !HAVE_LIBPCRE
  error (EXIT_TROUBLE, 0, "%s",
	 _("support for the -P option is not compiled into "
	   "this --disable-perl-regexp binary"));
#else
  int e;
  char const *ep;
  char *re = xmalloc (4 * size + 7);
  int flags = PCRE_MULTILINE | (match_icase ? PCRE_CASELESS : 0);
  char const *patlim = pattern + size;
  char *n = re;
  char const *p;
  char const *pnul;

  /* FIXME: Remove these restrictions.  */
  if (memchr(pattern, '\n', size))
    error (EXIT_TROUBLE, 0, _("the -P option only supports a single pattern"));

  *n = '\0';
  if (match_lines)
    strcpy (n, "^(");
  if (match_words)
    strcpy (n, "\\b(");
  n += strlen (n);

  /* The PCRE interface doesn't allow NUL bytes in the pattern, so
     replace each NUL byte in the pattern with the four characters
     "\000", removing a preceding backslash if there are an odd
     number of backslashes before the NUL.

     FIXME: This method does not work with some multibyte character
     encodings, notably Shift-JIS, where a multibyte character can end
     in a backslash byte.  */
  for (p = pattern; (pnul = memchr (p, '\0', patlim - p)); p = pnul + 1)
    {
      memcpy (n, p, pnul - p);
      n += pnul - p;
      for (p = pnul; pattern < p && p[-1] == '\\'; p--)
	continue;
      n -= (pnul - p) & 1;
      strcpy (n, "\\000");
      n += 4;
    }

  memcpy (n, p, patlim - p);
  n += patlim - p;
  *n = '\0';
  if (match_words)
    strcpy (n, ")\\b");
  if (match_lines)
    strcpy (n, ")$");

  cre = pcre_compile (re, flags, &ep, &e, pcre_maketables ());
  if (!cre)
    error (EXIT_TROUBLE, 0, "%s", ep);

  extra = pcre_study (cre, 0, &ep);
  if (ep)
    error (EXIT_TROUBLE, 0, "%s", ep);

  free (re);
#endif
}

EXECUTE_FCT(Pexecute)
{
#if !HAVE_LIBPCRE
  abort ();
  return -1;
#else
  /* This array must have at least two elements; everything after that
     is just for performance improvement in pcre_exec.  */
  int sub[300];

  const char *line_buf, *line_end, *line_next;
  int e = PCRE_ERROR_NOMATCH;
  ptrdiff_t start_ofs = start_ptr ? start_ptr - buf : 0;

  /* PCRE can't limit the matching to single lines, therefore we have to
     match each line in the buffer separately.  */
  for (line_next = buf;
       e == PCRE_ERROR_NOMATCH && line_next < buf + size;
       start_ofs -= line_next - line_buf)
    {
      line_buf = line_next;
      line_end = memchr (line_buf, eolbyte, (buf + size) - line_buf);
      if (line_end == NULL)
        line_next = line_end = buf + size;
      else
        line_next = line_end + 1;

      if (start_ptr && start_ptr >= line_end)
        continue;

      e = pcre_exec (cre, extra, line_buf, line_end - line_buf,
                     start_ofs < 0 ? 0 : start_ofs, 0,
                     sub, sizeof sub / sizeof *sub);
    }

  if (e <= 0)
    {
      switch (e)
	{
	case PCRE_ERROR_NOMATCH:
	  return -1;

	case PCRE_ERROR_NOMEMORY:
	  error (EXIT_TROUBLE, 0, _("memory exhausted"));

	default:
	  abort ();
	}
    }
  else
    {
      /* Narrow down to the line we've found.  */
      char const *beg = line_buf + sub[0];
      char const *end = line_buf + sub[1];
      char const *buflim = buf + size;
      char eol = eolbyte;
      if (!start_ptr)
	{
	  /* FIXME: The case when '\n' is not found indicates a bug:
	     Since grep is line oriented, the match should never contain
	     a newline, so there _must_ be a newline following.
	   */
	  if (!(end = memchr (end, eol, buflim - end)))
	    end = buflim;
	  else
	    end++;
	  while (buf < beg && beg[-1] != eol)
	    --beg;
	}

      *match_size = end - beg;
      return beg - buf;
    }
#endif
}

struct matcher const matchers[] = {
  { "default", Gcompile, EGexecute },
  { "grep",    Gcompile, EGexecute },
  { "egrep",   Ecompile, EGexecute },
  { "awk",     Acompile, EGexecute },
  { "fgrep",   Fcompile, Fexecute },
  { "perl",    Pcompile, Pexecute },
  { "", 0, 0 },
};
#endif /* GREP_PROGRAM */

Testing negative cases!
Testing 0 (with abstract condition) ENVIS_NEG
Iteration 0
Running test command:
/home/ubuntu/spr-fast/tools/grep-test.py /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-deccad69-db9d6340/tempworkdir2/src /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-deccad69-db9d6340/tempworkdir2/tests /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-deccad69-db9d6340/tempworkdir2 0  > __res
Opening:/home/ubuntu/spr-fast/tests/corebench/grep/grep-case-deccad69-db9d6340/tempworkdir2/neg.tmp!
NegativeBRANCH RECORD/home/ubuntu/spr-fast/tests/corebench/grep/grep-case-deccad69-db9d6340/tempworkdir2/neg.tmp!
Not caught by the negative case, give up!
APPENDING TO ISNEG:/home/ubuntu/spr-fast/tests/corebench/grep/grep-case-deccad69-db9d6340/tempworkdir2/neg.tmp!
Running test command:
/home/ubuntu/spr-fast/tools/grep-test.py /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-deccad69-db9d6340/tempworkdir2/src /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-deccad69-db9d6340/tempworkdir2/tests /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-deccad69-db9d6340/tempworkdir2 0  > __res
CondTester, Testing instance id 19:
//src_file:src/search.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
/* search.c - searching subroutines using dfa, kwset and regex for grep.
   Copyright 1992, 1998, 2000, 2007, 2009-2010 Free Software Foundation, Inc.

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 3, or (at your option)
   any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program; if not, write to the Free Software
   Foundation, Inc., 51 Franklin Street - Fifth Floor, Boston, MA
   02110-1301, USA.  */

/* Written August 1992 by Mike Haertel. */

#include <config.h>

#include <sys/types.h>

#include "mbsupport.h"
#ifdef MBS_SUPPORT
/* We can handle multibyte strings. */
# include <wchar.h>
# include <wctype.h>
#endif

#include "system.h"
#include "grep.h"
#ifndef FGREP_PROGRAM
# include <regex.h>
# include "dfa.h"
#endif
#include "kwset.h"
#include "error.h"
#include "xalloc.h"
#ifdef HAVE_LIBPCRE
# include <pcre.h>
#endif

#define NCHAR (UCHAR_MAX + 1)

/* For -w, we also consider _ to be word constituent.  */
#define WCHAR(C) (ISALNUM(C) || (C) == '_')

/* KWset compiled pattern.  For Ecompile and Gcompile, we compile
   a list of strings, at least one of which is known to occur in
   any string matching the regexp. */
static kwset_t kwset;

static void
kwsinit (void)
{
  static char trans[NCHAR];
  int i;

  if (match_icase && MB_CUR_MAX == 1)
    {
      for (i = 0; i < NCHAR; ++i)
        trans[i] = TOLOWER (i);

      kwset = kwsalloc (trans);
    }
  else
    kwset = kwsalloc (NULL);

  if (!kwset)
    xalloc_die ();
}

#ifdef MBS_SUPPORT
/* Convert the *N-byte string, BEG, to lowercase, and write the
   NUL-terminated result into malloc'd storage.  Upon success, set *N
   to the length (in bytes) of the resulting string (not including the
   trailing NUL byte), and return a pointer to the lowercase string.
   Upon memory allocation failure, this function exits.

   Note that while this function returns a pointer to malloc'd storage,
   the caller must not free it, since this function retains a pointer
   to the buffer and reuses it on any subsequent call.  As a consequence,
   this function is not thread-safe.  */
static char *
mbtolower (const char *beg, size_t *n)
{
  static char *out;
  static size_t outalloc;
  size_t outlen, mb_cur_max;
  mbstate_t is, os;
  const char *end;
  char *p;

  if (*n > outalloc)
    {
      out = xrealloc (out, *n);
      outalloc = *n;
    }

  memset (&is, 0, sizeof (is));
  memset (&os, 0, sizeof (os));
  end = beg + *n;

  mb_cur_max = MB_CUR_MAX;
  p = out;
  outlen = 0;
  while (beg < end)
    {
      wchar_t wc;
      size_t mbclen = mbrtowc(&wc, beg, end - beg, &is);
      if (outlen + mb_cur_max >= outalloc)
        {
          out = x2nrealloc (out, &outalloc, 1);
          p = out + outlen;
        }

      if (mbclen == (size_t) -1 || mbclen == (size_t) -2 || mbclen == 0)
        {
          /* An invalid sequence, or a truncated multi-octet character.
             We treat it as a single-octet character.  */
          *p++ = *beg++;
          outlen++;
          memset (&is, 0, sizeof (is));
          memset (&os, 0, sizeof (os));
        }
      else
        {
          beg += mbclen;
          mbclen = wcrtomb (p, towlower ((wint_t) wc), &os);
          p += mbclen;
          outlen += mbclen;
        }
    }

  *n = p - out;
  *p++ = 0;
  return out;
}
#endif


#ifndef FGREP_PROGRAM
/* DFA compiled regexp. */
static struct dfa dfa;

/* The Regex compiled patterns.  */
static struct patterns
{
  /* Regex compiled regexp. */
  struct re_pattern_buffer regexbuf;
  struct re_registers regs; /* This is here on account of a BRAIN-DEAD
			       Q@#%!# library interface in regex.c.  */
} patterns0;

struct patterns *patterns;
size_t pcount;

void
dfaerror (char const *mesg)
{
  error (EXIT_TROUBLE, 0, "%s", mesg);
}

/* Number of compiled fixed strings known to exactly match the regexp.
   If kwsexec returns < kwset_exact_matches, then we don't need to
   call the regexp matcher at all. */
static int kwset_exact_matches;

static char const *
kwsincr_case (const char *must)
{
  const char *buf;
  size_t n;

  n = strlen (must);
#ifdef MBS_SUPPORT
  if (match_icase && MB_CUR_MAX > 1)
    buf = mbtolower (must, &n);
  else
#endif
    buf = must;
  return kwsincr (kwset, buf, n);
}

/* If the DFA turns out to have some set of fixed strings one of
   which must occur in the match, then we build a kwset matcher
   to find those strings, and thus quickly filter out impossible
   matches. */
static void
kwsmusts (void)
{
  struct dfamust const *dm;
  char const *err;

  if (dfa.musts)
    {
      kwsinit ();
      /* First, we compile in the substrings known to be exact
	 matches.  The kwset matcher will return the index
	 of the matching string that it chooses. */
      for (dm = dfa.musts; dm; dm = dm->next)
	{
	  if (!dm->exact)
	    continue;
	  ++kwset_exact_matches;
	  if ((err = kwsincr_case (dm->must)) != NULL)
	    error (EXIT_TROUBLE, 0, "%s", err);
	}
      /* Now, we compile the substrings that will require
	 the use of the regexp matcher.  */
      for (dm = dfa.musts; dm; dm = dm->next)
	{
	  if (dm->exact)
	    continue;
	  if ((err = kwsincr_case (dm->must)) != NULL)
	    error (EXIT_TROUBLE, 0, "%s", err);
	}
      if ((err = kwsprep (kwset)) != NULL)
	error (EXIT_TROUBLE, 0, "%s", err);
    }
}
#endif /* !FGREP_PROGRAM */

#ifdef MBS_SUPPORT

static bool
is_mb_middle(const char **good, const char *buf, const char *end)
{
  const char *p = *good;
  const char *prev = p;
  mbstate_t cur_state;

  /* TODO: can be optimized for UTF-8.  */
  memset(&cur_state, 0, sizeof(mbstate_t));
  while (p < buf)
    {
      size_t mbclen = mbrlen(p, end - p, &cur_state);

      /* Store the beginning of the previous complete multibyte character.  */
      if (mbclen != (size_t) -2)
        prev = p;

      if (mbclen == (size_t) -1 || mbclen == (size_t) -2 || mbclen == 0)
	{
	  /* An invalid sequence, or a truncated multibyte character.
	     We treat it as a single byte character.  */
	  mbclen = 1;
	}
      p += mbclen;
    }

  *good = prev;
  return p > buf;
}
#endif /* MBS_SUPPORT */

#if defined(GREP_PROGRAM) || defined(EGREP_PROGRAM)
#ifdef EGREP_PROGRAM
COMPILE_FCT(Ecompile)
{
  reg_syntax_t syntax_bits = RE_SYNTAX_POSIX_EGREP;
#else
/* No __VA_ARGS__ in C89.  So we have to do it this way.  */
static COMPILE_RET
GEAcompile (char const *pattern, size_t size, reg_syntax_t syntax_bits)
{
#endif /* EGREP_PROGRAM */
  const char *err;
  const char *p, *sep;
  size_t total = size;
  char *motif;

  if (match_icase)
    syntax_bits |= RE_ICASE;
  re_set_syntax (syntax_bits);
  dfasyntax (syntax_bits, match_icase, eolbyte);

  /* For GNU regex compiler we have to pass the patterns separately to detect
     errors like "[\nallo\n]\n".  The patterns here are "[", "allo" and "]"
     GNU regex should have raise a syntax error.  The same for backref, where
     the backref should have been local to each pattern.  */
  p = pattern;
  do
    {
      size_t len;
      sep = memchr (p, '\n', total);
      if (sep)
	{
	  len = sep - p;
	  sep++;
	  total -= (len + 1);
	}
      else
	{
	  len = total;
	  total = 0;
	}

      patterns = realloc (patterns, (pcount + 1) * sizeof (*patterns));
      if (patterns == NULL)
	error (EXIT_TROUBLE, errno, _("memory exhausted"));
      patterns[pcount] = patterns0;

      if ((err = re_compile_pattern (p, len,
				    &(patterns[pcount].regexbuf))) != NULL)
	error (EXIT_TROUBLE, 0, "%s", err);
      pcount++;

      p = sep;
    } while (sep && total != 0);

  /* In the match_words and match_lines cases, we use a different pattern
     for the DFA matcher that will quickly throw out cases that won't work.
     Then if DFA succeeds we do some hairy stuff using the regex matcher
     to decide whether the match should really count. */
  if (match_words || match_lines)
    {
      static char const line_beg_no_bk[] = "^(";
      static char const line_end_no_bk[] = ")$";
      static char const word_beg_no_bk[] = "(^|[^[:alnum:]_])(";
      static char const word_end_no_bk[] = ")([^[:alnum:]_]|$)";
#ifdef EGREP_PROGRAM
# define IF_BK(x, y) (y)
      char *n = xmalloc (sizeof word_beg_no_bk - 1 + size + sizeof word_end_no_bk);
#else
      static char const line_beg_bk[] = "^\\(";
      static char const line_end_bk[] = "\\)$";
      static char const word_beg_bk[] = "\\(^\\|[^[:alnum:]_]\\)\\(";
      static char const word_end_bk[] = "\\)\\([^[:alnum:]_]\\|$\\)";
      int bk = !(syntax_bits & RE_NO_BK_PARENS);
# define IF_BK(x, y) ((bk) ? (x) : (y))
      char *n = xmalloc (sizeof word_beg_bk - 1 + size + sizeof word_end_bk);
#endif /* EGREP_PROGRAM */

      strcpy (n, match_lines ? IF_BK(line_beg_bk, line_beg_no_bk)
			     : IF_BK(word_beg_bk, word_beg_no_bk));
      total = strlen(n);
      memcpy (n + total, pattern, size);
      total += size;
      strcpy (n + total, match_lines ? IF_BK(line_end_bk, line_end_no_bk)
				     : IF_BK(word_end_bk, word_end_no_bk));
      total += strlen (n + total);
      pattern = motif = n;
      size = total;
    }
  else
    motif = NULL;

  dfacomp (pattern, size, &dfa, 1);
  kwsmusts ();

  free(motif);
}

#ifndef EGREP_PROGRAM
COMPILE_FCT(Gcompile)
{
  return GEAcompile (pattern, size,
		     RE_SYNTAX_GREP | RE_HAT_LISTS_NOT_NEWLINE);
}

COMPILE_FCT(Acompile)
{
  return GEAcompile (pattern, size, RE_SYNTAX_AWK);
}

COMPILE_FCT(Ecompile)
{
  return GEAcompile (pattern, size, RE_SYNTAX_POSIX_EGREP);
}
#endif /* !EGREP_PROGRAM */

EXECUTE_FCT(EGexecute)
{
  char const *buflim, *beg, *end, *match, *best_match, *mb_start;
  char eol = eolbyte;
  int backref, start, len, best_len;
  struct kwsmatch kwsm;
  size_t i, ret_val;
#ifdef MBS_SUPPORT
  if (MB_CUR_MAX > 1)
    {
      if (match_icase)
        {
          /* mbtolower adds a NUL byte at the end.  That will provide
	     space for the sentinel byte dfaexec may add.  */
          char *case_buf = mbtolower (buf, &size);
	  if (start_ptr)
	    start_ptr = case_buf + (start_ptr - buf);
          buf = case_buf;
        }
    }
#endif /* MBS_SUPPORT */

  mb_start = buf;
  buflim = buf + size;

  for (beg = end = buf; end < buflim; beg = end)
    {
      if (!start_ptr)
	{
	  /* We don't care about an exact match.  */
	  if (kwset)
	    {
	      /* Find a possible match using the KWset matcher. */
	      size_t offset = kwsexec (kwset, beg, buflim - beg, &kwsm);
	      if (offset == (size_t) -1)
		goto failure;
	      beg += offset;
	      /* Narrow down to the line containing the candidate, and
		 run it through DFA. */
	      if ((end = memchr(beg, eol, buflim - beg)) != NULL)
	        end++;
              else
                end = buflim;
	      match = beg;
	      while (beg > buf && beg[-1] != eol)
		--beg;
	      if (kwsm.index < kwset_exact_matches)
                {
#ifdef MBS_SUPPORT
                  if (mb_start < beg)
                    mb_start = beg;
                  if (MB_CUR_MAX == 1 || !is_mb_middle (&mb_start, match, buflim))
#endif
                    goto success;
                }
	      if (dfaexec (&dfa, beg, (char *) end, 0, NULL, &backref) == NULL)
		continue;
	    }
	  else
	    {
	      /* No good fixed strings; start with DFA. */
	      char const *next_beg = dfaexec (&dfa, beg, (char *) buflim,
					      0, NULL, &backref);
	      if (next_beg == NULL)
		break;
	      /* Narrow down to the line we've found. */
	      beg = next_beg;
	      if ((end = memchr(beg, eol, buflim - beg)) != NULL)
	        end++;
              else
                end = buflim;
	      while (beg > buf && beg[-1] != eol)
		--beg;
	    }
	  /* Successful, no backreferences encountered! */
	  if (!backref)
	    goto success;
	}
      else
	{
	  /* We are looking for the leftmost (then longest) exact match.
	     We will go through the outer loop only once.  */
	  beg = start_ptr;
	  end = buflim;
	}

      /* If we've made it to this point, this means DFA has seen
	 a probable match, and we need to run it through Regex. */
      best_match = end;
      best_len = 0;
      for (i = 0; i < pcount; i++)
	{
	  patterns[i].regexbuf.not_eol = 0;
	  if (0 <= (start = re_search (&(patterns[i].regexbuf),
				       buf, end - buf - 1,
				       beg - buf, end - beg - 1,
				       &(patterns[i].regs))))
	    {
	      len = patterns[i].regs.end[0] - start;
	      match = buf + start;
	      if (match > best_match)
		continue;
	      if (start_ptr && !match_words)
		goto assess_pattern_match;
	      if ((!match_lines && !match_words)
		  || (match_lines && len == end - beg - 1))
		{
		  match = beg;
		  len = end - beg;
		  goto assess_pattern_match;
		}
	      /* If -w, check if the match aligns with word boundaries.
		 We do this iteratively because:
		 (a) the line may contain more than one occurence of the
		 pattern, and
		 (b) Several alternatives in the pattern might be valid at a
		 given point, and we may need to consider a shorter one to
		 find a word boundary.  */
	      if (match_words)
		while (match <= best_match)
		  {
		    if ((match == buf || !WCHAR ((unsigned char) match[-1]))
			&& (len == end - beg - 1
			    || !WCHAR ((unsigned char) match[len])))
		      goto assess_pattern_match;
		    if (len > 0)
		      {
			/* Try a shorter length anchored at the same place. */
			--len;
			patterns[i].regexbuf.not_eol = 1;
			len = re_match (&(patterns[i].regexbuf),
					buf, match + len - beg, match - buf,
					&(patterns[i].regs));
		      }
		    if (len <= 0)
		      {
			/* Try looking further on. */
			if (match == end - 1)
			  break;
			match++;
			patterns[i].regexbuf.not_eol = 0;
			start = re_search (&(patterns[i].regexbuf),
					   buf, end - buf - 1,
					   match - buf, end - match - 1,
					   &(patterns[i].regs));
			if (start < 0)
			  break;
			len = patterns[i].regs.end[0] - start;
			match = buf + start;
		      }
		  } /* while (match <= best_match) */
	      continue;
	    assess_pattern_match:
	      if (!start_ptr)
		{
		  /* Good enough for a non-exact match.
		     No need to look at further patterns, if any.  */
		  beg = match;
		  goto success_in_len;
		}
	      if (match < best_match || (match == best_match && len > best_len))
		{
		  /* Best exact match:  leftmost, then longest.  */
		  best_match = match;
		  best_len = len;
		}
	    } /* if re_search >= 0 */
	} /* for Regex patterns.  */
	if (best_match < end)
	  {
	    /* We have found an exact match.  We were just
	       waiting for the best one (leftmost then longest).  */
	    beg = best_match;
	    len = best_len;
	    goto success_in_len;
	  }
    } /* for (beg = end ..) */

 failure:
  ret_val = -1;
  goto out;

 success:
  len = end - beg;
 success_in_len:
  *match_size = len;
  ret_val = beg - buf;
 out:
  return ret_val;
}
#endif /* defined(GREP_PROGRAM) || defined(EGREP_PROGRAM) */

#if defined(GREP_PROGRAM) || defined(FGREP_PROGRAM)
COMPILE_FCT(Fcompile)
{
  char const *beg, *end, *lim, *err, *pat;
  size_t psize;

  kwsinit ();
  psize = size;
  if (match_icase && MB_CUR_MAX > 1)
    pat = mbtolower (pattern, &psize);
  else
    pat = pattern;

  beg = pat;
  do
    {
      for (lim = beg;; ++lim)
	{
	  end = lim;
	  if (lim >= pat + psize)
	    break;
	 
//Patch 0:
if ((*lim == '\n') || (__is_neg(10, &(lim), sizeof (lim), &(pat), sizeof (pat), &(psize), sizeof (psize), &(end), sizeof (end), &(beg), sizeof (beg), &(pattern), sizeof (pattern), &(match_icase), sizeof (match_icase), &(size), sizeof (size), &(err), sizeof (err), &(kwset), sizeof (kwset)))) {
    lim++;
    break;
}

//CodeSeg 1:
#if HAVE_DOS_FILE_CONTENTS
	 if (*lim == '\r' && lim + 1 < pat + psize && lim[1] == '\n')
	   {
	     lim += 2;
	     break;
	   }
#endif
	}

      if ((err = kwsincr (kwset, beg, end - beg)) != NULL)
	error (EXIT_TROUBLE, 0, "%s", err);
      beg = lim;
    }
  while (beg < pat + psize);

  if ((err = kwsprep (kwset)) != NULL)
    error (EXIT_TROUBLE, 0, "%s", err);
}

EXECUTE_FCT(Fexecute)
{
  char const *beg, *try, *end, *mb_start;
  size_t len;
  char eol = eolbyte;
  struct kwsmatch kwsmatch;
  size_t ret_val;
#ifdef MBS_SUPPORT
  if (MB_CUR_MAX > 1)
    {
      if (match_icase)
        {
          char *case_buf = mbtolower (buf, &size);
	  if (start_ptr)
	    start_ptr = case_buf + (start_ptr - buf);
          buf = case_buf;
        }
    }
#endif /* MBS_SUPPORT */

  for (mb_start = beg = start_ptr ? start_ptr : buf; beg <= buf + size; beg++)
    {
      size_t offset = kwsexec (kwset, beg, buf + size - beg, &kwsmatch);
      if (offset == (size_t) -1)
	goto failure;
#ifdef MBS_SUPPORT
      if (MB_CUR_MAX > 1 && is_mb_middle (&mb_start, beg + offset, buf + size))
        {
          beg = mb_start - 1;
          continue; /* It is a part of multibyte character.  */
        }
#endif /* MBS_SUPPORT */
      beg += offset;
      len = kwsmatch.size[0];
      if (start_ptr && !match_words)
	goto success_in_beg_and_len;
      if (match_lines)
	{
	  if (beg > buf && beg[-1] != eol)
	    continue;
	  if (beg + len < buf + size && beg[len] != eol)
	    continue;
	  goto success;
	}
      else if (match_words)
	for (try = beg; len; )
	  {
	    if (try > buf && WCHAR((unsigned char) try[-1]))
	      break;
	    if (try + len < buf + size && WCHAR((unsigned char) try[len]))
	      {
		offset = kwsexec (kwset, beg, --len, &kwsmatch);
		if (offset == (size_t) -1)
		  break;
		try = beg + offset;
		len = kwsmatch.size[0];
	      }
	    else if (!start_ptr)
	      goto success;
	    else
	      goto success_in_beg_and_len;
	  } /* for (try) */
      else
	goto success;
    } /* for (beg in buf) */

 failure:
  ret_val = -1;
  goto out;

 success:
  if ((end = memchr (beg + len, eol, (buf + size) - (beg + len))) != NULL)
    end++;
  else
    end = buf + size;
  while (buf < beg && beg[-1] != eol)
    --beg;
  len = end - beg;
 success_in_beg_and_len:
  *match_size = len;
  ret_val = beg - buf;
 out:
  return ret_val;
}
#endif /* defined(GREP_PROGRAM) || defined(FGREP_PROGRAM) */

#ifdef GREP_PROGRAM
#if HAVE_LIBPCRE
/* Compiled internal form of a Perl regular expression.  */
static pcre *cre;

/* Additional information about the pattern.  */
static pcre_extra *extra;
#endif

COMPILE_FCT(Pcompile)
{
#if !HAVE_LIBPCRE
  error (EXIT_TROUBLE, 0, "%s",
	 _("support for the -P option is not compiled into "
	   "this --disable-perl-regexp binary"));
#else
  int e;
  char const *ep;
  char *re = xmalloc (4 * size + 7);
  int flags = PCRE_MULTILINE | (match_icase ? PCRE_CASELESS : 0);
  char const *patlim = pattern + size;
  char *n = re;
  char const *p;
  char const *pnul;

  /* FIXME: Remove these restrictions.  */
  if (memchr(pattern, '\n', size))
    error (EXIT_TROUBLE, 0, _("the -P option only supports a single pattern"));

  *n = '\0';
  if (match_lines)
    strcpy (n, "^(");
  if (match_words)
    strcpy (n, "\\b(");
  n += strlen (n);

  /* The PCRE interface doesn't allow NUL bytes in the pattern, so
     replace each NUL byte in the pattern with the four characters
     "\000", removing a preceding backslash if there are an odd
     number of backslashes before the NUL.

     FIXME: This method does not work with some multibyte character
     encodings, notably Shift-JIS, where a multibyte character can end
     in a backslash byte.  */
  for (p = pattern; (pnul = memchr (p, '\0', patlim - p)); p = pnul + 1)
    {
      memcpy (n, p, pnul - p);
      n += pnul - p;
      for (p = pnul; pattern < p && p[-1] == '\\'; p--)
	continue;
      n -= (pnul - p) & 1;
      strcpy (n, "\\000");
      n += 4;
    }

  memcpy (n, p, patlim - p);
  n += patlim - p;
  *n = '\0';
  if (match_words)
    strcpy (n, ")\\b");
  if (match_lines)
    strcpy (n, ")$");

  cre = pcre_compile (re, flags, &ep, &e, pcre_maketables ());
  if (!cre)
    error (EXIT_TROUBLE, 0, "%s", ep);

  extra = pcre_study (cre, 0, &ep);
  if (ep)
    error (EXIT_TROUBLE, 0, "%s", ep);

  free (re);
#endif
}

EXECUTE_FCT(Pexecute)
{
#if !HAVE_LIBPCRE
  abort ();
  return -1;
#else
  /* This array must have at least two elements; everything after that
     is just for performance improvement in pcre_exec.  */
  int sub[300];

  const char *line_buf, *line_end, *line_next;
  int e = PCRE_ERROR_NOMATCH;
  ptrdiff_t start_ofs = start_ptr ? start_ptr - buf : 0;

  /* PCRE can't limit the matching to single lines, therefore we have to
     match each line in the buffer separately.  */
  for (line_next = buf;
       e == PCRE_ERROR_NOMATCH && line_next < buf + size;
       start_ofs -= line_next - line_buf)
    {
      line_buf = line_next;
      line_end = memchr (line_buf, eolbyte, (buf + size) - line_buf);
      if (line_end == NULL)
        line_next = line_end = buf + size;
      else
        line_next = line_end + 1;

      if (start_ptr && start_ptr >= line_end)
        continue;

      e = pcre_exec (cre, extra, line_buf, line_end - line_buf,
                     start_ofs < 0 ? 0 : start_ofs, 0,
                     sub, sizeof sub / sizeof *sub);
    }

  if (e <= 0)
    {
      switch (e)
	{
	case PCRE_ERROR_NOMATCH:
	  return -1;

	case PCRE_ERROR_NOMEMORY:
	  error (EXIT_TROUBLE, 0, _("memory exhausted"));

	default:
	  abort ();
	}
    }
  else
    {
      /* Narrow down to the line we've found.  */
      char const *beg = line_buf + sub[0];
      char const *end = line_buf + sub[1];
      char const *buflim = buf + size;
      char eol = eolbyte;
      if (!start_ptr)
	{
	  /* FIXME: The case when '\n' is not found indicates a bug:
	     Since grep is line oriented, the match should never contain
	     a newline, so there _must_ be a newline following.
	   */
	  if (!(end = memchr (end, eol, buflim - end)))
	    end = buflim;
	  else
	    end++;
	  while (buf < beg && beg[-1] != eol)
	    --beg;
	}

      *match_size = end - beg;
      return beg - buf;
    }
#endif
}

struct matcher const matchers[] = {
  { "default", Gcompile, EGexecute },
  { "grep",    Gcompile, EGexecute },
  { "egrep",   Ecompile, EGexecute },
  { "awk",     Acompile, EGexecute },
  { "fgrep",   Fcompile, Fexecute },
  { "perl",    Pcompile, Pexecute },
  { "", 0, 0 },
};
#endif /* GREP_PROGRAM */

Testing negative cases!
Testing 0 (with abstract condition) ENVIS_NEG
Iteration 0
Running test command:
/home/ubuntu/spr-fast/tools/grep-test.py /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-deccad69-db9d6340/tempworkdir2/src /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-deccad69-db9d6340/tempworkdir2/tests /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-deccad69-db9d6340/tempworkdir2 0  > __res
Opening:/home/ubuntu/spr-fast/tests/corebench/grep/grep-case-deccad69-db9d6340/tempworkdir2/neg.tmp!
NegativeBRANCH RECORD/home/ubuntu/spr-fast/tests/corebench/grep/grep-case-deccad69-db9d6340/tempworkdir2/neg.tmp!
APPENDING TO ISNEG:/home/ubuntu/spr-fast/tests/corebench/grep/grep-case-deccad69-db9d6340/tempworkdir2/neg.tmp!
Branch 0: 0
Branch 1: 0
Iteration 1
Running test command:
/home/ubuntu/spr-fast/tools/grep-test.py /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-deccad69-db9d6340/tempworkdir2/src /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-deccad69-db9d6340/tempworkdir2/tests /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-deccad69-db9d6340/tempworkdir2 0  > __res
Opening:/home/ubuntu/spr-fast/tests/corebench/grep/grep-case-deccad69-db9d6340/tempworkdir2/neg.tmp!
NegativeBRANCH RECORD/home/ubuntu/spr-fast/tests/corebench/grep/grep-case-deccad69-db9d6340/tempworkdir2/neg.tmp!
APPENDING TO ISNEG:/home/ubuntu/spr-fast/tests/corebench/grep/grep-case-deccad69-db9d6340/tempworkdir2/neg.tmp!
Branch 0: 0
Branch 1: 1
Iteration 2
Running test command:
/home/ubuntu/spr-fast/tools/grep-test.py /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-deccad69-db9d6340/tempworkdir2/src /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-deccad69-db9d6340/tempworkdir2/tests /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-deccad69-db9d6340/tempworkdir2 0  > __res
Opening:/home/ubuntu/spr-fast/tests/corebench/grep/grep-case-deccad69-db9d6340/tempworkdir2/neg.tmp!
NegativeBRANCH RECORD/home/ubuntu/spr-fast/tests/corebench/grep/grep-case-deccad69-db9d6340/tempworkdir2/neg.tmp!
APPENDING TO ISNEG:/home/ubuntu/spr-fast/tests/corebench/grep/grep-case-deccad69-db9d6340/tempworkdir2/neg.tmp!
Branch 0: 1
Branch 1: 0
Iteration 3
Running test command:
/home/ubuntu/spr-fast/tools/grep-test.py /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-deccad69-db9d6340/tempworkdir2/src /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-deccad69-db9d6340/tempworkdir2/tests /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-deccad69-db9d6340/tempworkdir2 0  > __res
Opening:/home/ubuntu/spr-fast/tests/corebench/grep/grep-case-deccad69-db9d6340/tempworkdir2/neg.tmp!
NegativeBRANCH RECORD/home/ubuntu/spr-fast/tests/corebench/grep/grep-case-deccad69-db9d6340/tempworkdir2/neg.tmp!
APPENDING TO ISNEG:/home/ubuntu/spr-fast/tests/corebench/grep/grep-case-deccad69-db9d6340/tempworkdir2/neg.tmp!
Branch 0: 1
Branch 1: 1
Running test command:
/home/ubuntu/spr-fast/tools/grep-test.py /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-deccad69-db9d6340/tempworkdir2/src /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-deccad69-db9d6340/tempworkdir2/tests /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-deccad69-db9d6340/tempworkdir2 0  > __res
a batched test job starts!
Building merged code:
src_file: src/search.c
full src: int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
/* search.c - searching subroutines using dfa, kwset and regex for grep.
   Copyright 1992, 1998, 2000, 2007, 2009-2010 Free Software Foundation, Inc.

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 3, or (at your option)
   any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program; if not, write to the Free Software
   Foundation, Inc., 51 Franklin Street - Fifth Floor, Boston, MA
   02110-1301, USA.  */

/* Written August 1992 by Mike Haertel. */

#include <config.h>

#include <sys/types.h>

#include "mbsupport.h"
#ifdef MBS_SUPPORT
/* We can handle multibyte strings. */
# include <wchar.h>
# include <wctype.h>
#endif

#include "system.h"
#include "grep.h"
#ifndef FGREP_PROGRAM
# include <regex.h>
# include "dfa.h"
#endif
#include "kwset.h"
#include "error.h"
#include "xalloc.h"
#ifdef HAVE_LIBPCRE
# include <pcre.h>
#endif

#define NCHAR (UCHAR_MAX + 1)

/* For -w, we also consider _ to be word constituent.  */
#define WCHAR(C) (ISALNUM(C) || (C) == '_')

/* KWset compiled pattern.  For Ecompile and Gcompile, we compile
   a list of strings, at least one of which is known to occur in
   any string matching the regexp. */
static kwset_t kwset;

static void
kwsinit (void)
{
  static char trans[NCHAR];
  int i;

  if (match_icase && MB_CUR_MAX == 1)
    {
      for (i = 0; i < NCHAR; ++i)
        trans[i] = TOLOWER (i);

      kwset = kwsalloc (trans);
    }
  else
    kwset = kwsalloc (NULL);

  if (!kwset)
    xalloc_die ();
}

#ifdef MBS_SUPPORT
/* Convert the *N-byte string, BEG, to lowercase, and write the
   NUL-terminated result into malloc'd storage.  Upon success, set *N
   to the length (in bytes) of the resulting string (not including the
   trailing NUL byte), and return a pointer to the lowercase string.
   Upon memory allocation failure, this function exits.

   Note that while this function returns a pointer to malloc'd storage,
   the caller must not free it, since this function retains a pointer
   to the buffer and reuses it on any subsequent call.  As a consequence,
   this function is not thread-safe.  */
static char *
mbtolower (const char *beg, size_t *n)
{
  static char *out;
  static size_t outalloc;
  size_t outlen, mb_cur_max;
  mbstate_t is, os;
  const char *end;
  char *p;

  if (*n > outalloc)
    {
      out = xrealloc (out, *n);
      outalloc = *n;
    }

  memset (&is, 0, sizeof (is));
  memset (&os, 0, sizeof (os));
  end = beg + *n;

  mb_cur_max = MB_CUR_MAX;
  p = out;
  outlen = 0;
  while (beg < end)
    {
      wchar_t wc;
      size_t mbclen = mbrtowc(&wc, beg, end - beg, &is);
      if (outlen + mb_cur_max >= outalloc)
        {
          out = x2nrealloc (out, &outalloc, 1);
          p = out + outlen;
        }

      if (mbclen == (size_t) -1 || mbclen == (size_t) -2 || mbclen == 0)
        {
          /* An invalid sequence, or a truncated multi-octet character.
             We treat it as a single-octet character.  */
          *p++ = *beg++;
          outlen++;
          memset (&is, 0, sizeof (is));
          memset (&os, 0, sizeof (os));
        }
      else
        {
          beg += mbclen;
          mbclen = wcrtomb (p, towlower ((wint_t) wc), &os);
          p += mbclen;
          outlen += mbclen;
        }
    }

  *n = p - out;
  *p++ = 0;
  return out;
}
#endif


#ifndef FGREP_PROGRAM
/* DFA compiled regexp. */
static struct dfa dfa;

/* The Regex compiled patterns.  */
static struct patterns
{
  /* Regex compiled regexp. */
  struct re_pattern_buffer regexbuf;
  struct re_registers regs; /* This is here on account of a BRAIN-DEAD
			       Q@#%!# library interface in regex.c.  */
} patterns0;

struct patterns *patterns;
size_t pcount;

void
dfaerror (char const *mesg)
{
  error (EXIT_TROUBLE, 0, "%s", mesg);
}

/* Number of compiled fixed strings known to exactly match the regexp.
   If kwsexec returns < kwset_exact_matches, then we don't need to
   call the regexp matcher at all. */
static int kwset_exact_matches;

static char const *
kwsincr_case (const char *must)
{
  const char *buf;
  size_t n;

  n = strlen (must);
#ifdef MBS_SUPPORT
  if (match_icase && MB_CUR_MAX > 1)
    buf = mbtolower (must, &n);
  else
#endif
    buf = must;
  return kwsincr (kwset, buf, n);
}

/* If the DFA turns out to have some set of fixed strings one of
   which must occur in the match, then we build a kwset matcher
   to find those strings, and thus quickly filter out impossible
   matches. */
static void
kwsmusts (void)
{
  struct dfamust const *dm;
  char const *err;

  if (dfa.musts)
    {
      kwsinit ();
      /* First, we compile in the substrings known to be exact
	 matches.  The kwset matcher will return the index
	 of the matching string that it chooses. */
      for (dm = dfa.musts; dm; dm = dm->next)
	{
	  if (!dm->exact)
	    continue;
	  ++kwset_exact_matches;
	  if ((err = kwsincr_case (dm->must)) != NULL)
	    error (EXIT_TROUBLE, 0, "%s", err);
	}
      /* Now, we compile the substrings that will require
	 the use of the regexp matcher.  */
      for (dm = dfa.musts; dm; dm = dm->next)
	{
	  if (dm->exact)
	    continue;
	  if ((err = kwsincr_case (dm->must)) != NULL)
	    error (EXIT_TROUBLE, 0, "%s", err);
	}
      if ((err = kwsprep (kwset)) != NULL)
	error (EXIT_TROUBLE, 0, "%s", err);
    }
}
#endif /* !FGREP_PROGRAM */

#ifdef MBS_SUPPORT

static bool
is_mb_middle(const char **good, const char *buf, const char *end)
{
  const char *p = *good;
  const char *prev = p;
  mbstate_t cur_state;

  /* TODO: can be optimized for UTF-8.  */
  memset(&cur_state, 0, sizeof(mbstate_t));
  while (p < buf)
    {
      size_t mbclen = mbrlen(p, end - p, &cur_state);

      /* Store the beginning of the previous complete multibyte character.  */
      if (mbclen != (size_t) -2)
        prev = p;

      if (mbclen == (size_t) -1 || mbclen == (size_t) -2 || mbclen == 0)
	{
	  /* An invalid sequence, or a truncated multibyte character.
	     We treat it as a single byte character.  */
	  mbclen = 1;
	}
      p += mbclen;
    }

  *good = prev;
  return p > buf;
}
#endif /* MBS_SUPPORT */

#if defined(GREP_PROGRAM) || defined(EGREP_PROGRAM)
#ifdef EGREP_PROGRAM
COMPILE_FCT(Ecompile)
{
  reg_syntax_t syntax_bits = RE_SYNTAX_POSIX_EGREP;
#else
/* No __VA_ARGS__ in C89.  So we have to do it this way.  */
static COMPILE_RET
GEAcompile (char const *pattern, size_t size, reg_syntax_t syntax_bits)
{
#endif /* EGREP_PROGRAM */
  const char *err;
  const char *p, *sep;
  size_t total = size;
  char *motif;

  if (match_icase)
    syntax_bits |= RE_ICASE;
  re_set_syntax (syntax_bits);
  dfasyntax (syntax_bits, match_icase, eolbyte);

  /* For GNU regex compiler we have to pass the patterns separately to detect
     errors like "[\nallo\n]\n".  The patterns here are "[", "allo" and "]"
     GNU regex should have raise a syntax error.  The same for backref, where
     the backref should have been local to each pattern.  */
  p = pattern;
  do
    {
      size_t len;
      sep = memchr (p, '\n', total);
      if (sep)
	{
	  len = sep - p;
	  sep++;
	  total -= (len + 1);
	}
      else
	{
	  len = total;
	  total = 0;
	}

      patterns = realloc (patterns, (pcount + 1) * sizeof (*patterns));
      if (patterns == NULL)
	error (EXIT_TROUBLE, errno, _("memory exhausted"));
      patterns[pcount] = patterns0;

      if ((err = re_compile_pattern (p, len,
				    &(patterns[pcount].regexbuf))) != NULL)
	error (EXIT_TROUBLE, 0, "%s", err);
      pcount++;

      p = sep;
    } while (sep && total != 0);

  /* In the match_words and match_lines cases, we use a different pattern
     for the DFA matcher that will quickly throw out cases that won't work.
     Then if DFA succeeds we do some hairy stuff using the regex matcher
     to decide whether the match should really count. */
  if (match_words || match_lines)
    {
      static char const line_beg_no_bk[] = "^(";
      static char const line_end_no_bk[] = ")$";
      static char const word_beg_no_bk[] = "(^|[^[:alnum:]_])(";
      static char const word_end_no_bk[] = ")([^[:alnum:]_]|$)";
#ifdef EGREP_PROGRAM
# define IF_BK(x, y) (y)
      char *n = xmalloc (sizeof word_beg_no_bk - 1 + size + sizeof word_end_no_bk);
#else
      static char const line_beg_bk[] = "^\\(";
      static char const line_end_bk[] = "\\)$";
      static char const word_beg_bk[] = "\\(^\\|[^[:alnum:]_]\\)\\(";
      static char const word_end_bk[] = "\\)\\([^[:alnum:]_]\\|$\\)";
      int bk = !(syntax_bits & RE_NO_BK_PARENS);
# define IF_BK(x, y) ((bk) ? (x) : (y))
      char *n = xmalloc (sizeof word_beg_bk - 1 + size + sizeof word_end_bk);
#endif /* EGREP_PROGRAM */

      strcpy (n, match_lines ? IF_BK(line_beg_bk, line_beg_no_bk)
			     : IF_BK(word_beg_bk, word_beg_no_bk));
      total = strlen(n);
      memcpy (n + total, pattern, size);
      total += size;
      strcpy (n + total, match_lines ? IF_BK(line_end_bk, line_end_no_bk)
				     : IF_BK(word_end_bk, word_end_no_bk));
      total += strlen (n + total);
      pattern = motif = n;
      size = total;
    }
  else
    motif = NULL;

  dfacomp (pattern, size, &dfa, 1);
  kwsmusts ();

  free(motif);
}

#ifndef EGREP_PROGRAM
COMPILE_FCT(Gcompile)
{
  return GEAcompile (pattern, size,
		     RE_SYNTAX_GREP | RE_HAT_LISTS_NOT_NEWLINE);
}

COMPILE_FCT(Acompile)
{
  return GEAcompile (pattern, size, RE_SYNTAX_AWK);
}

COMPILE_FCT(Ecompile)
{
  return GEAcompile (pattern, size, RE_SYNTAX_POSIX_EGREP);
}
#endif /* !EGREP_PROGRAM */

EXECUTE_FCT(EGexecute)
{
  char const *buflim, *beg, *end, *match, *best_match, *mb_start;
  char eol = eolbyte;
  int backref, start, len, best_len;
  struct kwsmatch kwsm;
  size_t i, ret_val;
#ifdef MBS_SUPPORT
  if (MB_CUR_MAX > 1)
    {
      if (match_icase)
        {
          /* mbtolower adds a NUL byte at the end.  That will provide
	     space for the sentinel byte dfaexec may add.  */
          char *case_buf = mbtolower (buf, &size);
	  if (start_ptr)
	    start_ptr = case_buf + (start_ptr - buf);
          buf = case_buf;
        }
    }
#endif /* MBS_SUPPORT */

  mb_start = buf;
  buflim = buf + size;

  for (beg = end = buf; end < buflim; beg = end)
    {
      if (!start_ptr)
	{
	  /* We don't care about an exact match.  */
	  if (kwset)
	    {
	      /* Find a possible match using the KWset matcher. */
	      size_t offset = kwsexec (kwset, beg, buflim - beg, &kwsm);
	      if (offset == (size_t) -1)
		goto failure;
	      beg += offset;
	      /* Narrow down to the line containing the candidate, and
		 run it through DFA. */
	      if ((end = memchr(beg, eol, buflim - beg)) != NULL)
	        end++;
              else
                end = buflim;
	      match = beg;
	      while (beg > buf && beg[-1] != eol)
		--beg;
	      if (kwsm.index < kwset_exact_matches)
                {
#ifdef MBS_SUPPORT
                  if (mb_start < beg)
                    mb_start = beg;
                  if (MB_CUR_MAX == 1 || !is_mb_middle (&mb_start, match, buflim))
#endif
                    goto success;
                }
	      if (dfaexec (&dfa, beg, (char *) end, 0, NULL, &backref) == NULL)
		continue;
	    }
	  else
	    {
	      /* No good fixed strings; start with DFA. */
	      char const *next_beg = dfaexec (&dfa, beg, (char *) buflim,
					      0, NULL, &backref);
	      if (next_beg == NULL)
		break;
	      /* Narrow down to the line we've found. */
	      beg = next_beg;
	      if ((end = memchr(beg, eol, buflim - beg)) != NULL)
	        end++;
              else
                end = buflim;
	      while (beg > buf && beg[-1] != eol)
		--beg;
	    }
	  /* Successful, no backreferences encountered! */
	  if (!backref)
	    goto success;
	}
      else
	{
	  /* We are looking for the leftmost (then longest) exact match.
	     We will go through the outer loop only once.  */
	  beg = start_ptr;
	  end = buflim;
	}

      /* If we've made it to this point, this means DFA has seen
	 a probable match, and we need to run it through Regex. */
      best_match = end;
      best_len = 0;
      for (i = 0; i < pcount; i++)
	{
	  patterns[i].regexbuf.not_eol = 0;
	  if (0 <= (start = re_search (&(patterns[i].regexbuf),
				       buf, end - buf - 1,
				       beg - buf, end - beg - 1,
				       &(patterns[i].regs))))
	    {
	      len = patterns[i].regs.end[0] - start;
	      match = buf + start;
	      if (match > best_match)
		continue;
	      if (start_ptr && !match_words)
		goto assess_pattern_match;
	      if ((!match_lines && !match_words)
		  || (match_lines && len == end - beg - 1))
		{
		  match = beg;
		  len = end - beg;
		  goto assess_pattern_match;
		}
	      /* If -w, check if the match aligns with word boundaries.
		 We do this iteratively because:
		 (a) the line may contain more than one occurence of the
		 pattern, and
		 (b) Several alternatives in the pattern might be valid at a
		 given point, and we may need to consider a shorter one to
		 find a word boundary.  */
	      if (match_words)
		while (match <= best_match)
		  {
		    if ((match == buf || !WCHAR ((unsigned char) match[-1]))
			&& (len == end - beg - 1
			    || !WCHAR ((unsigned char) match[len])))
		      goto assess_pattern_match;
		    if (len > 0)
		      {
			/* Try a shorter length anchored at the same place. */
			--len;
			patterns[i].regexbuf.not_eol = 1;
			len = re_match (&(patterns[i].regexbuf),
					buf, match + len - beg, match - buf,
					&(patterns[i].regs));
		      }
		    if (len <= 0)
		      {
			/* Try looking further on. */
			if (match == end - 1)
			  break;
			match++;
			patterns[i].regexbuf.not_eol = 0;
			start = re_search (&(patterns[i].regexbuf),
					   buf, end - buf - 1,
					   match - buf, end - match - 1,
					   &(patterns[i].regs));
			if (start < 0)
			  break;
			len = patterns[i].regs.end[0] - start;
			match = buf + start;
		      }
		  } /* while (match <= best_match) */
	      continue;
	    assess_pattern_match:
	      if (!start_ptr)
		{
		  /* Good enough for a non-exact match.
		     No need to look at further patterns, if any.  */
		  beg = match;
		  goto success_in_len;
		}
	      if (match < best_match || (match == best_match && len > best_len))
		{
		  /* Best exact match:  leftmost, then longest.  */
		  best_match = match;
		  best_len = len;
		}
	    } /* if re_search >= 0 */
	} /* for Regex patterns.  */
	if (best_match < end)
	  {
	    /* We have found an exact match.  We were just
	       waiting for the best one (leftmost then longest).  */
	    beg = best_match;
	    len = best_len;
	    goto success_in_len;
	  }
    } /* for (beg = end ..) */

 failure:
  ret_val = -1;
  goto out;

 success:
  len = end - beg;
 success_in_len:
  *match_size = len;
  ret_val = beg - buf;
 out:
  return ret_val;
}
#endif /* defined(GREP_PROGRAM) || defined(EGREP_PROGRAM) */

#if defined(GREP_PROGRAM) || defined(FGREP_PROGRAM)
COMPILE_FCT(Fcompile)
{
  char const *beg, *end, *lim, *err, *pat;
  size_t psize;

  kwsinit ();
  psize = size;
  if (match_icase && MB_CUR_MAX > 1)
    pat = mbtolower (pattern, &psize);
  else
    pat = pattern;

  beg = pat;
  do
    {
      for (lim = beg;; ++lim)
	{
	  end = lim;
	  if (lim >= pat + psize)
	    break;
	 if (*lim == '\n')
	   {
	     lim++;
	     break;
	   }
#if HAVE_DOS_FILE_CONTENTS
	 if (*lim == '\r' && lim + 1 < pat + psize && lim[1] == '\n')
	   {
	     lim += 2;
	     break;
	   }
#endif
	}

      //prophet generated patch
      if (__get_mutant()==0) {
      if (((err = kwsincr(kwset, beg, end - beg)) != ((void *)0)) && !(__is_neg(10, &(beg), sizeof (beg), &(end), sizeof (end), &(err), sizeof (err), &(kwset), sizeof (kwset), &(lim), sizeof (lim), &(pat), sizeof (pat), &(psize), sizeof (psize), &(pattern), sizeof (pattern), &(match_icase), sizeof (match_icase), &(size), sizeof (size))))
          error(EXIT_TROUBLE, 0, "%s", err);
      }
      else if (__get_mutant()==1) {
      if (((err = kwsincr(kwset, beg, end - beg)) != ((void *)0)) || (__is_neg(10, &(beg), sizeof (beg), &(end), sizeof (end), &(err), sizeof (err), &(kwset), sizeof (kwset), &(lim), sizeof (lim), &(pat), sizeof (pat), &(psize), sizeof (psize), &(pattern), sizeof (pattern), &(match_icase), sizeof (match_icase), &(size), sizeof (size))))
          error(EXIT_TROUBLE, 0, "%s", err);
      }
      beg = lim;
    }
  while (beg < pat + psize);

  if ((err = kwsprep (kwset)) != NULL)
    error (EXIT_TROUBLE, 0, "%s", err);
}

EXECUTE_FCT(Fexecute)
{
  char const *beg, *try, *end, *mb_start;
  size_t len;
  char eol = eolbyte;
  struct kwsmatch kwsmatch;
  size_t ret_val;
#ifdef MBS_SUPPORT
  if (MB_CUR_MAX > 1)
    {
      if (match_icase)
        {
          char *case_buf = mbtolower (buf, &size);
	  if (start_ptr)
	    start_ptr = case_buf + (start_ptr - buf);
          buf = case_buf;
        }
    }
#endif /* MBS_SUPPORT */

  for (mb_start = beg = start_ptr ? start_ptr : buf; beg <= buf + size; beg++)
    {
      size_t offset = kwsexec (kwset, beg, buf + size - beg, &kwsmatch);
      if (offset == (size_t) -1)
	goto failure;
#ifdef MBS_SUPPORT
      if (MB_CUR_MAX > 1 && is_mb_middle (&mb_start, beg + offset, buf + size))
        {
          beg = mb_start - 1;
          continue; /* It is a part of multibyte character.  */
        }
#endif /* MBS_SUPPORT */
      beg += offset;
      len = kwsmatch.size[0];
      if (start_ptr && !match_words)
	goto success_in_beg_and_len;
      if (match_lines)
	{
	  if (beg > buf && beg[-1] != eol)
	    continue;
	  if (beg + len < buf + size && beg[len] != eol)
	    continue;
	  goto success;
	}
      else if (match_words)
	for (try = beg; len; )
	  {
	    if (try > buf && WCHAR((unsigned char) try[-1]))
	      break;
	    if (try + len < buf + size && WCHAR((unsigned char) try[len]))
	      {
		offset = kwsexec (kwset, beg, --len, &kwsmatch);
		if (offset == (size_t) -1)
		  break;
		try = beg + offset;
		len = kwsmatch.size[0];
	      }
	    else if (!start_ptr)
	      goto success;
	    else
	      goto success_in_beg_and_len;
	  } /* for (try) */
      else
	goto success;
    } /* for (beg in buf) */

 failure:
  ret_val = -1;
  goto out;

 success:
  if ((end = memchr (beg + len, eol, (buf + size) - (beg + len))) != NULL)
    end++;
  else
    end = buf + size;
  while (buf < beg && beg[-1] != eol)
    --beg;
  len = end - beg;
 success_in_beg_and_len:
  *match_size = len;
  ret_val = beg - buf;
 out:
  return ret_val;
}
#endif /* defined(GREP_PROGRAM) || defined(FGREP_PROGRAM) */

#ifdef GREP_PROGRAM
#if HAVE_LIBPCRE
/* Compiled internal form of a Perl regular expression.  */
static pcre *cre;

/* Additional information about the pattern.  */
static pcre_extra *extra;
#endif

COMPILE_FCT(Pcompile)
{
#if !HAVE_LIBPCRE
  error (EXIT_TROUBLE, 0, "%s",
	 _("support for the -P option is not compiled into "
	   "this --disable-perl-regexp binary"));
#else
  int e;
  char const *ep;
  char *re = xmalloc (4 * size + 7);
  int flags = PCRE_MULTILINE | (match_icase ? PCRE_CASELESS : 0);
  char const *patlim = pattern + size;
  char *n = re;
  char const *p;
  char const *pnul;

  /* FIXME: Remove these restrictions.  */
  if (memchr(pattern, '\n', size))
    error (EXIT_TROUBLE, 0, _("the -P option only supports a single pattern"));

  *n = '\0';
  if (match_lines)
    strcpy (n, "^(");
  if (match_words)
    strcpy (n, "\\b(");
  n += strlen (n);

  /* The PCRE interface doesn't allow NUL bytes in the pattern, so
     replace each NUL byte in the pattern with the four characters
     "\000", removing a preceding backslash if there are an odd
     number of backslashes before the NUL.

     FIXME: This method does not work with some multibyte character
     encodings, notably Shift-JIS, where a multibyte character can end
     in a backslash byte.  */
  for (p = pattern; (pnul = memchr (p, '\0', patlim - p)); p = pnul + 1)
    {
      memcpy (n, p, pnul - p);
      n += pnul - p;
      for (p = pnul; pattern < p && p[-1] == '\\'; p--)
	continue;
      n -= (pnul - p) & 1;
      strcpy (n, "\\000");
      n += 4;
    }

  memcpy (n, p, patlim - p);
  n += patlim - p;
  *n = '\0';
  if (match_words)
    strcpy (n, ")\\b");
  if (match_lines)
    strcpy (n, ")$");

  cre = pcre_compile (re, flags, &ep, &e, pcre_maketables ());
  if (!cre)
    error (EXIT_TROUBLE, 0, "%s", ep);

  extra = pcre_study (cre, 0, &ep);
  if (ep)
    error (EXIT_TROUBLE, 0, "%s", ep);

  free (re);
#endif
}

EXECUTE_FCT(Pexecute)
{
#if !HAVE_LIBPCRE
  abort ();
  return -1;
#else
  /* This array must have at least two elements; everything after that
     is just for performance improvement in pcre_exec.  */
  int sub[300];

  const char *line_buf, *line_end, *line_next;
  int e = PCRE_ERROR_NOMATCH;
  ptrdiff_t start_ofs = start_ptr ? start_ptr - buf : 0;

  /* PCRE can't limit the matching to single lines, therefore we have to
     match each line in the buffer separately.  */
  for (line_next = buf;
       e == PCRE_ERROR_NOMATCH && line_next < buf + size;
       start_ofs -= line_next - line_buf)
    {
      line_buf = line_next;
      line_end = memchr (line_buf, eolbyte, (buf + size) - line_buf);
      if (line_end == NULL)
        line_next = line_end = buf + size;
      else
        line_next = line_end + 1;

      if (start_ptr && start_ptr >= line_end)
        continue;

      e = pcre_exec (cre, extra, line_buf, line_end - line_buf,
                     start_ofs < 0 ? 0 : start_ofs, 0,
                     sub, sizeof sub / sizeof *sub);
    }

  if (e <= 0)
    {
      switch (e)
	{
	case PCRE_ERROR_NOMATCH:
	  return -1;

	case PCRE_ERROR_NOMEMORY:
	  error (EXIT_TROUBLE, 0, _("memory exhausted"));

	default:
	  abort ();
	}
    }
  else
    {
      /* Narrow down to the line we've found.  */
      char const *beg = line_buf + sub[0];
      char const *end = line_buf + sub[1];
      char const *buflim = buf + size;
      char eol = eolbyte;
      if (!start_ptr)
	{
	  /* FIXME: The case when '\n' is not found indicates a bug:
	     Since grep is line oriented, the match should never contain
	     a newline, so there _must_ be a newline following.
	   */
	  if (!(end = memchr (end, eol, buflim - end)))
	    end = buflim;
	  else
	    end++;
	  while (buf < beg && beg[-1] != eol)
	    --beg;
	}

      *match_size = end - beg;
      return beg - buf;
    }
#endif
}

struct matcher const matchers[] = {
  { "default", Gcompile, EGexecute },
  { "grep",    Gcompile, EGexecute },
  { "egrep",   Ecompile, EGexecute },
  { "awk",     Acompile, EGexecute },
  { "fgrep",   Fcompile, Fexecute },
  { "perl",    Pcompile, Pexecute },
  { "", 0, 0 },
};
#endif /* GREP_PROGRAM */

Building:src at:
/home/ubuntu/spr-fast/tests/corebench/grep/grep-case-deccad69-db9d6340/tempworkdir2/srcMerged code building succ, going to invoke tester!
CondTester, Testing instance id 8:
//src_file:src/search.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
/* search.c - searching subroutines using dfa, kwset and regex for grep.
   Copyright 1992, 1998, 2000, 2007, 2009-2010 Free Software Foundation, Inc.

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 3, or (at your option)
   any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program; if not, write to the Free Software
   Foundation, Inc., 51 Franklin Street - Fifth Floor, Boston, MA
   02110-1301, USA.  */

/* Written August 1992 by Mike Haertel. */

#include <config.h>

#include <sys/types.h>

#include "mbsupport.h"
#ifdef MBS_SUPPORT
/* We can handle multibyte strings. */
# include <wchar.h>
# include <wctype.h>
#endif

#include "system.h"
#include "grep.h"
#ifndef FGREP_PROGRAM
# include <regex.h>
# include "dfa.h"
#endif
#include "kwset.h"
#include "error.h"
#include "xalloc.h"
#ifdef HAVE_LIBPCRE
# include <pcre.h>
#endif

#define NCHAR (UCHAR_MAX + 1)

/* For -w, we also consider _ to be word constituent.  */
#define WCHAR(C) (ISALNUM(C) || (C) == '_')

/* KWset compiled pattern.  For Ecompile and Gcompile, we compile
   a list of strings, at least one of which is known to occur in
   any string matching the regexp. */
static kwset_t kwset;

static void
kwsinit (void)
{
  static char trans[NCHAR];
  int i;

  if (match_icase && MB_CUR_MAX == 1)
    {
      for (i = 0; i < NCHAR; ++i)
        trans[i] = TOLOWER (i);

      kwset = kwsalloc (trans);
    }
  else
    kwset = kwsalloc (NULL);

  if (!kwset)
    xalloc_die ();
}

#ifdef MBS_SUPPORT
/* Convert the *N-byte string, BEG, to lowercase, and write the
   NUL-terminated result into malloc'd storage.  Upon success, set *N
   to the length (in bytes) of the resulting string (not including the
   trailing NUL byte), and return a pointer to the lowercase string.
   Upon memory allocation failure, this function exits.

   Note that while this function returns a pointer to malloc'd storage,
   the caller must not free it, since this function retains a pointer
   to the buffer and reuses it on any subsequent call.  As a consequence,
   this function is not thread-safe.  */
static char *
mbtolower (const char *beg, size_t *n)
{
  static char *out;
  static size_t outalloc;
  size_t outlen, mb_cur_max;
  mbstate_t is, os;
  const char *end;
  char *p;

  if (*n > outalloc)
    {
      out = xrealloc (out, *n);
      outalloc = *n;
    }

  memset (&is, 0, sizeof (is));
  memset (&os, 0, sizeof (os));
  end = beg + *n;

  mb_cur_max = MB_CUR_MAX;
  p = out;
  outlen = 0;
  while (beg < end)
    {
      wchar_t wc;
      size_t mbclen = mbrtowc(&wc, beg, end - beg, &is);
      if (outlen + mb_cur_max >= outalloc)
        {
          out = x2nrealloc (out, &outalloc, 1);
          p = out + outlen;
        }

      if (mbclen == (size_t) -1 || mbclen == (size_t) -2 || mbclen == 0)
        {
          /* An invalid sequence, or a truncated multi-octet character.
             We treat it as a single-octet character.  */
          *p++ = *beg++;
          outlen++;
          memset (&is, 0, sizeof (is));
          memset (&os, 0, sizeof (os));
        }
      else
        {
          beg += mbclen;
          mbclen = wcrtomb (p, towlower ((wint_t) wc), &os);
          p += mbclen;
          outlen += mbclen;
        }
    }

  *n = p - out;
  *p++ = 0;
  return out;
}
#endif


#ifndef FGREP_PROGRAM
/* DFA compiled regexp. */
static struct dfa dfa;

/* The Regex compiled patterns.  */
static struct patterns
{
  /* Regex compiled regexp. */
  struct re_pattern_buffer regexbuf;
  struct re_registers regs; /* This is here on account of a BRAIN-DEAD
			       Q@#%!# library interface in regex.c.  */
} patterns0;

struct patterns *patterns;
size_t pcount;

void
dfaerror (char const *mesg)
{
  error (EXIT_TROUBLE, 0, "%s", mesg);
}

/* Number of compiled fixed strings known to exactly match the regexp.
   If kwsexec returns < kwset_exact_matches, then we don't need to
   call the regexp matcher at all. */
static int kwset_exact_matches;

static char const *
kwsincr_case (const char *must)
{
  const char *buf;
  size_t n;

  n = strlen (must);
#ifdef MBS_SUPPORT
  if (match_icase && MB_CUR_MAX > 1)
    buf = mbtolower (must, &n);
  else
#endif
    buf = must;
  return kwsincr (kwset, buf, n);
}

/* If the DFA turns out to have some set of fixed strings one of
   which must occur in the match, then we build a kwset matcher
   to find those strings, and thus quickly filter out impossible
   matches. */
static void
kwsmusts (void)
{
  struct dfamust const *dm;
  char const *err;

  if (dfa.musts)
    {
      kwsinit ();
      /* First, we compile in the substrings known to be exact
	 matches.  The kwset matcher will return the index
	 of the matching string that it chooses. */
      for (dm = dfa.musts; dm; dm = dm->next)
	{
	  if (!dm->exact)
	    continue;
	  ++kwset_exact_matches;
	  if ((err = kwsincr_case (dm->must)) != NULL)
	    error (EXIT_TROUBLE, 0, "%s", err);
	}
      /* Now, we compile the substrings that will require
	 the use of the regexp matcher.  */
      for (dm = dfa.musts; dm; dm = dm->next)
	{
	  if (dm->exact)
	    continue;
	  if ((err = kwsincr_case (dm->must)) != NULL)
	    error (EXIT_TROUBLE, 0, "%s", err);
	}
      if ((err = kwsprep (kwset)) != NULL)
	error (EXIT_TROUBLE, 0, "%s", err);
    }
}
#endif /* !FGREP_PROGRAM */

#ifdef MBS_SUPPORT

static bool
is_mb_middle(const char **good, const char *buf, const char *end)
{
  const char *p = *good;
  const char *prev = p;
  mbstate_t cur_state;

  /* TODO: can be optimized for UTF-8.  */
  memset(&cur_state, 0, sizeof(mbstate_t));
  while (p < buf)
    {
      size_t mbclen = mbrlen(p, end - p, &cur_state);

      /* Store the beginning of the previous complete multibyte character.  */
      if (mbclen != (size_t) -2)
        prev = p;

      if (mbclen == (size_t) -1 || mbclen == (size_t) -2 || mbclen == 0)
	{
	  /* An invalid sequence, or a truncated multibyte character.
	     We treat it as a single byte character.  */
	  mbclen = 1;
	}
      p += mbclen;
    }

  *good = prev;
  return p > buf;
}
#endif /* MBS_SUPPORT */

#if defined(GREP_PROGRAM) || defined(EGREP_PROGRAM)
#ifdef EGREP_PROGRAM
COMPILE_FCT(Ecompile)
{
  reg_syntax_t syntax_bits = RE_SYNTAX_POSIX_EGREP;
#else
/* No __VA_ARGS__ in C89.  So we have to do it this way.  */
static COMPILE_RET
GEAcompile (char const *pattern, size_t size, reg_syntax_t syntax_bits)
{
#endif /* EGREP_PROGRAM */
  const char *err;
  const char *p, *sep;
  size_t total = size;
  char *motif;

  if (match_icase)
    syntax_bits |= RE_ICASE;
  re_set_syntax (syntax_bits);
  dfasyntax (syntax_bits, match_icase, eolbyte);

  /* For GNU regex compiler we have to pass the patterns separately to detect
     errors like "[\nallo\n]\n".  The patterns here are "[", "allo" and "]"
     GNU regex should have raise a syntax error.  The same for backref, where
     the backref should have been local to each pattern.  */
  p = pattern;
  do
    {
      size_t len;
      sep = memchr (p, '\n', total);
      if (sep)
	{
	  len = sep - p;
	  sep++;
	  total -= (len + 1);
	}
      else
	{
	  len = total;
	  total = 0;
	}

      patterns = realloc (patterns, (pcount + 1) * sizeof (*patterns));
      if (patterns == NULL)
	error (EXIT_TROUBLE, errno, _("memory exhausted"));
      patterns[pcount] = patterns0;

      if ((err = re_compile_pattern (p, len,
				    &(patterns[pcount].regexbuf))) != NULL)
	error (EXIT_TROUBLE, 0, "%s", err);
      pcount++;

      p = sep;
    } while (sep && total != 0);

  /* In the match_words and match_lines cases, we use a different pattern
     for the DFA matcher that will quickly throw out cases that won't work.
     Then if DFA succeeds we do some hairy stuff using the regex matcher
     to decide whether the match should really count. */
  if (match_words || match_lines)
    {
      static char const line_beg_no_bk[] = "^(";
      static char const line_end_no_bk[] = ")$";
      static char const word_beg_no_bk[] = "(^|[^[:alnum:]_])(";
      static char const word_end_no_bk[] = ")([^[:alnum:]_]|$)";
#ifdef EGREP_PROGRAM
# define IF_BK(x, y) (y)
      char *n = xmalloc (sizeof word_beg_no_bk - 1 + size + sizeof word_end_no_bk);
#else
      static char const line_beg_bk[] = "^\\(";
      static char const line_end_bk[] = "\\)$";
      static char const word_beg_bk[] = "\\(^\\|[^[:alnum:]_]\\)\\(";
      static char const word_end_bk[] = "\\)\\([^[:alnum:]_]\\|$\\)";
      int bk = !(syntax_bits & RE_NO_BK_PARENS);
# define IF_BK(x, y) ((bk) ? (x) : (y))
      char *n = xmalloc (sizeof word_beg_bk - 1 + size + sizeof word_end_bk);
#endif /* EGREP_PROGRAM */

      strcpy (n, match_lines ? IF_BK(line_beg_bk, line_beg_no_bk)
			     : IF_BK(word_beg_bk, word_beg_no_bk));
      total = strlen(n);
      memcpy (n + total, pattern, size);
      total += size;
      strcpy (n + total, match_lines ? IF_BK(line_end_bk, line_end_no_bk)
				     : IF_BK(word_end_bk, word_end_no_bk));
      total += strlen (n + total);
      pattern = motif = n;
      size = total;
    }
  else
    motif = NULL;

  dfacomp (pattern, size, &dfa, 1);
  kwsmusts ();

  free(motif);
}

#ifndef EGREP_PROGRAM
COMPILE_FCT(Gcompile)
{
  return GEAcompile (pattern, size,
		     RE_SYNTAX_GREP | RE_HAT_LISTS_NOT_NEWLINE);
}

COMPILE_FCT(Acompile)
{
  return GEAcompile (pattern, size, RE_SYNTAX_AWK);
}

COMPILE_FCT(Ecompile)
{
  return GEAcompile (pattern, size, RE_SYNTAX_POSIX_EGREP);
}
#endif /* !EGREP_PROGRAM */

EXECUTE_FCT(EGexecute)
{
  char const *buflim, *beg, *end, *match, *best_match, *mb_start;
  char eol = eolbyte;
  int backref, start, len, best_len;
  struct kwsmatch kwsm;
  size_t i, ret_val;
#ifdef MBS_SUPPORT
  if (MB_CUR_MAX > 1)
    {
      if (match_icase)
        {
          /* mbtolower adds a NUL byte at the end.  That will provide
	     space for the sentinel byte dfaexec may add.  */
          char *case_buf = mbtolower (buf, &size);
	  if (start_ptr)
	    start_ptr = case_buf + (start_ptr - buf);
          buf = case_buf;
        }
    }
#endif /* MBS_SUPPORT */

  mb_start = buf;
  buflim = buf + size;

  for (beg = end = buf; end < buflim; beg = end)
    {
      if (!start_ptr)
	{
	  /* We don't care about an exact match.  */
	  if (kwset)
	    {
	      /* Find a possible match using the KWset matcher. */
	      size_t offset = kwsexec (kwset, beg, buflim - beg, &kwsm);
	      if (offset == (size_t) -1)
		goto failure;
	      beg += offset;
	      /* Narrow down to the line containing the candidate, and
		 run it through DFA. */
	      if ((end = memchr(beg, eol, buflim - beg)) != NULL)
	        end++;
              else
                end = buflim;
	      match = beg;
	      while (beg > buf && beg[-1] != eol)
		--beg;
	      if (kwsm.index < kwset_exact_matches)
                {
#ifdef MBS_SUPPORT
                  if (mb_start < beg)
                    mb_start = beg;
                  if (MB_CUR_MAX == 1 || !is_mb_middle (&mb_start, match, buflim))
#endif
                    goto success;
                }
	      if (dfaexec (&dfa, beg, (char *) end, 0, NULL, &backref) == NULL)
		continue;
	    }
	  else
	    {
	      /* No good fixed strings; start with DFA. */
	      char const *next_beg = dfaexec (&dfa, beg, (char *) buflim,
					      0, NULL, &backref);
	      if (next_beg == NULL)
		break;
	      /* Narrow down to the line we've found. */
	      beg = next_beg;
	      if ((end = memchr(beg, eol, buflim - beg)) != NULL)
	        end++;
              else
                end = buflim;
	      while (beg > buf && beg[-1] != eol)
		--beg;
	    }
	  /* Successful, no backreferences encountered! */
	  if (!backref)
	    goto success;
	}
      else
	{
	  /* We are looking for the leftmost (then longest) exact match.
	     We will go through the outer loop only once.  */
	  beg = start_ptr;
	  end = buflim;
	}

      /* If we've made it to this point, this means DFA has seen
	 a probable match, and we need to run it through Regex. */
      best_match = end;
      best_len = 0;
      for (i = 0; i < pcount; i++)
	{
	  patterns[i].regexbuf.not_eol = 0;
	  if (0 <= (start = re_search (&(patterns[i].regexbuf),
				       buf, end - buf - 1,
				       beg - buf, end - beg - 1,
				       &(patterns[i].regs))))
	    {
	      len = patterns[i].regs.end[0] - start;
	      match = buf + start;
	      if (match > best_match)
		continue;
	      if (start_ptr && !match_words)
		goto assess_pattern_match;
	      if ((!match_lines && !match_words)
		  || (match_lines && len == end - beg - 1))
		{
		  match = beg;
		  len = end - beg;
		  goto assess_pattern_match;
		}
	      /* If -w, check if the match aligns with word boundaries.
		 We do this iteratively because:
		 (a) the line may contain more than one occurence of the
		 pattern, and
		 (b) Several alternatives in the pattern might be valid at a
		 given point, and we may need to consider a shorter one to
		 find a word boundary.  */
	      if (match_words)
		while (match <= best_match)
		  {
		    if ((match == buf || !WCHAR ((unsigned char) match[-1]))
			&& (len == end - beg - 1
			    || !WCHAR ((unsigned char) match[len])))
		      goto assess_pattern_match;
		    if (len > 0)
		      {
			/* Try a shorter length anchored at the same place. */
			--len;
			patterns[i].regexbuf.not_eol = 1;
			len = re_match (&(patterns[i].regexbuf),
					buf, match + len - beg, match - buf,
					&(patterns[i].regs));
		      }
		    if (len <= 0)
		      {
			/* Try looking further on. */
			if (match == end - 1)
			  break;
			match++;
			patterns[i].regexbuf.not_eol = 0;
			start = re_search (&(patterns[i].regexbuf),
					   buf, end - buf - 1,
					   match - buf, end - match - 1,
					   &(patterns[i].regs));
			if (start < 0)
			  break;
			len = patterns[i].regs.end[0] - start;
			match = buf + start;
		      }
		  } /* while (match <= best_match) */
	      continue;
	    assess_pattern_match:
	      if (!start_ptr)
		{
		  /* Good enough for a non-exact match.
		     No need to look at further patterns, if any.  */
		  beg = match;
		  goto success_in_len;
		}
	      if (match < best_match || (match == best_match && len > best_len))
		{
		  /* Best exact match:  leftmost, then longest.  */
		  best_match = match;
		  best_len = len;
		}
	    } /* if re_search >= 0 */
	} /* for Regex patterns.  */
	if (best_match < end)
	  {
	    /* We have found an exact match.  We were just
	       waiting for the best one (leftmost then longest).  */
	    beg = best_match;
	    len = best_len;
	    goto success_in_len;
	  }
    } /* for (beg = end ..) */

 failure:
  ret_val = -1;
  goto out;

 success:
  len = end - beg;
 success_in_len:
  *match_size = len;
  ret_val = beg - buf;
 out:
  return ret_val;
}
#endif /* defined(GREP_PROGRAM) || defined(EGREP_PROGRAM) */

#if defined(GREP_PROGRAM) || defined(FGREP_PROGRAM)
COMPILE_FCT(Fcompile)
{
  char const *beg, *end, *lim, *err, *pat;
  size_t psize;

  kwsinit ();
  psize = size;
  if (match_icase && MB_CUR_MAX > 1)
    pat = mbtolower (pattern, &psize);
  else
    pat = pattern;

  beg = pat;
  do
    {
      for (lim = beg;; ++lim)
	{
	  end = lim;
	  if (lim >= pat + psize)
	    break;
	 if (*lim == '\n')
	   {
	     lim++;
	     break;
	   }
#if HAVE_DOS_FILE_CONTENTS
	 if (*lim == '\r' && lim + 1 < pat + psize && lim[1] == '\n')
	   {
	     lim += 2;
	     break;
	   }
#endif
	}

      
//Patch 0:
if (((err = kwsincr(kwset, beg, end - beg)) != ((void *)0)) && !(__is_neg(10, &(beg), sizeof (beg), &(end), sizeof (end), &(err), sizeof (err), &(kwset), sizeof (kwset), &(lim), sizeof (lim), &(pat), sizeof (pat), &(psize), sizeof (psize), &(pattern), sizeof (pattern), &(match_icase), sizeof (match_icase), &(size), sizeof (size))))
    error(EXIT_TROUBLE, 0, "%s", err);

//CodeSeg 1:
      beg = lim;
    }
  while (beg < pat + psize);

  if ((err = kwsprep (kwset)) != NULL)
    error (EXIT_TROUBLE, 0, "%s", err);
}

EXECUTE_FCT(Fexecute)
{
  char const *beg, *try, *end, *mb_start;
  size_t len;
  char eol = eolbyte;
  struct kwsmatch kwsmatch;
  size_t ret_val;
#ifdef MBS_SUPPORT
  if (MB_CUR_MAX > 1)
    {
      if (match_icase)
        {
          char *case_buf = mbtolower (buf, &size);
	  if (start_ptr)
	    start_ptr = case_buf + (start_ptr - buf);
          buf = case_buf;
        }
    }
#endif /* MBS_SUPPORT */

  for (mb_start = beg = start_ptr ? start_ptr : buf; beg <= buf + size; beg++)
    {
      size_t offset = kwsexec (kwset, beg, buf + size - beg, &kwsmatch);
      if (offset == (size_t) -1)
	goto failure;
#ifdef MBS_SUPPORT
      if (MB_CUR_MAX > 1 && is_mb_middle (&mb_start, beg + offset, buf + size))
        {
          beg = mb_start - 1;
          continue; /* It is a part of multibyte character.  */
        }
#endif /* MBS_SUPPORT */
      beg += offset;
      len = kwsmatch.size[0];
      if (start_ptr && !match_words)
	goto success_in_beg_and_len;
      if (match_lines)
	{
	  if (beg > buf && beg[-1] != eol)
	    continue;
	  if (beg + len < buf + size && beg[len] != eol)
	    continue;
	  goto success;
	}
      else if (match_words)
	for (try = beg; len; )
	  {
	    if (try > buf && WCHAR((unsigned char) try[-1]))
	      break;
	    if (try + len < buf + size && WCHAR((unsigned char) try[len]))
	      {
		offset = kwsexec (kwset, beg, --len, &kwsmatch);
		if (offset == (size_t) -1)
		  break;
		try = beg + offset;
		len = kwsmatch.size[0];
	      }
	    else if (!start_ptr)
	      goto success;
	    else
	      goto success_in_beg_and_len;
	  } /* for (try) */
      else
	goto success;
    } /* for (beg in buf) */

 failure:
  ret_val = -1;
  goto out;

 success:
  if ((end = memchr (beg + len, eol, (buf + size) - (beg + len))) != NULL)
    end++;
  else
    end = buf + size;
  while (buf < beg && beg[-1] != eol)
    --beg;
  len = end - beg;
 success_in_beg_and_len:
  *match_size = len;
  ret_val = beg - buf;
 out:
  return ret_val;
}
#endif /* defined(GREP_PROGRAM) || defined(FGREP_PROGRAM) */

#ifdef GREP_PROGRAM
#if HAVE_LIBPCRE
/* Compiled internal form of a Perl regular expression.  */
static pcre *cre;

/* Additional information about the pattern.  */
static pcre_extra *extra;
#endif

COMPILE_FCT(Pcompile)
{
#if !HAVE_LIBPCRE
  error (EXIT_TROUBLE, 0, "%s",
	 _("support for the -P option is not compiled into "
	   "this --disable-perl-regexp binary"));
#else
  int e;
  char const *ep;
  char *re = xmalloc (4 * size + 7);
  int flags = PCRE_MULTILINE | (match_icase ? PCRE_CASELESS : 0);
  char const *patlim = pattern + size;
  char *n = re;
  char const *p;
  char const *pnul;

  /* FIXME: Remove these restrictions.  */
  if (memchr(pattern, '\n', size))
    error (EXIT_TROUBLE, 0, _("the -P option only supports a single pattern"));

  *n = '\0';
  if (match_lines)
    strcpy (n, "^(");
  if (match_words)
    strcpy (n, "\\b(");
  n += strlen (n);

  /* The PCRE interface doesn't allow NUL bytes in the pattern, so
     replace each NUL byte in the pattern with the four characters
     "\000", removing a preceding backslash if there are an odd
     number of backslashes before the NUL.

     FIXME: This method does not work with some multibyte character
     encodings, notably Shift-JIS, where a multibyte character can end
     in a backslash byte.  */
  for (p = pattern; (pnul = memchr (p, '\0', patlim - p)); p = pnul + 1)
    {
      memcpy (n, p, pnul - p);
      n += pnul - p;
      for (p = pnul; pattern < p && p[-1] == '\\'; p--)
	continue;
      n -= (pnul - p) & 1;
      strcpy (n, "\\000");
      n += 4;
    }

  memcpy (n, p, patlim - p);
  n += patlim - p;
  *n = '\0';
  if (match_words)
    strcpy (n, ")\\b");
  if (match_lines)
    strcpy (n, ")$");

  cre = pcre_compile (re, flags, &ep, &e, pcre_maketables ());
  if (!cre)
    error (EXIT_TROUBLE, 0, "%s", ep);

  extra = pcre_study (cre, 0, &ep);
  if (ep)
    error (EXIT_TROUBLE, 0, "%s", ep);

  free (re);
#endif
}

EXECUTE_FCT(Pexecute)
{
#if !HAVE_LIBPCRE
  abort ();
  return -1;
#else
  /* This array must have at least two elements; everything after that
     is just for performance improvement in pcre_exec.  */
  int sub[300];

  const char *line_buf, *line_end, *line_next;
  int e = PCRE_ERROR_NOMATCH;
  ptrdiff_t start_ofs = start_ptr ? start_ptr - buf : 0;

  /* PCRE can't limit the matching to single lines, therefore we have to
     match each line in the buffer separately.  */
  for (line_next = buf;
       e == PCRE_ERROR_NOMATCH && line_next < buf + size;
       start_ofs -= line_next - line_buf)
    {
      line_buf = line_next;
      line_end = memchr (line_buf, eolbyte, (buf + size) - line_buf);
      if (line_end == NULL)
        line_next = line_end = buf + size;
      else
        line_next = line_end + 1;

      if (start_ptr && start_ptr >= line_end)
        continue;

      e = pcre_exec (cre, extra, line_buf, line_end - line_buf,
                     start_ofs < 0 ? 0 : start_ofs, 0,
                     sub, sizeof sub / sizeof *sub);
    }

  if (e <= 0)
    {
      switch (e)
	{
	case PCRE_ERROR_NOMATCH:
	  return -1;

	case PCRE_ERROR_NOMEMORY:
	  error (EXIT_TROUBLE, 0, _("memory exhausted"));

	default:
	  abort ();
	}
    }
  else
    {
      /* Narrow down to the line we've found.  */
      char const *beg = line_buf + sub[0];
      char const *end = line_buf + sub[1];
      char const *buflim = buf + size;
      char eol = eolbyte;
      if (!start_ptr)
	{
	  /* FIXME: The case when '\n' is not found indicates a bug:
	     Since grep is line oriented, the match should never contain
	     a newline, so there _must_ be a newline following.
	   */
	  if (!(end = memchr (end, eol, buflim - end)))
	    end = buflim;
	  else
	    end++;
	  while (buf < beg && beg[-1] != eol)
	    --beg;
	}

      *match_size = end - beg;
      return beg - buf;
    }
#endif
}

struct matcher const matchers[] = {
  { "default", Gcompile, EGexecute },
  { "grep",    Gcompile, EGexecute },
  { "egrep",   Ecompile, EGexecute },
  { "awk",     Acompile, EGexecute },
  { "fgrep",   Fcompile, Fexecute },
  { "perl",    Pcompile, Pexecute },
  { "", 0, 0 },
};
#endif /* GREP_PROGRAM */

Testing negative cases!
Testing 0 (with abstract condition) ENVIS_NEG
Iteration 0
Running test command:
/home/ubuntu/spr-fast/tools/grep-test.py /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-deccad69-db9d6340/tempworkdir2/src /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-deccad69-db9d6340/tempworkdir2/tests /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-deccad69-db9d6340/tempworkdir2 0  > __res
Opening:/home/ubuntu/spr-fast/tests/corebench/grep/grep-case-deccad69-db9d6340/tempworkdir2/neg.tmp!
NegativeBRANCH RECORD/home/ubuntu/spr-fast/tests/corebench/grep/grep-case-deccad69-db9d6340/tempworkdir2/neg.tmp!
Not caught by the negative case, give up!
APPENDING TO ISNEG:/home/ubuntu/spr-fast/tests/corebench/grep/grep-case-deccad69-db9d6340/tempworkdir2/neg.tmp!
Running test command:
/home/ubuntu/spr-fast/tools/grep-test.py /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-deccad69-db9d6340/tempworkdir2/src /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-deccad69-db9d6340/tempworkdir2/tests /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-deccad69-db9d6340/tempworkdir2 0  > __res
CondTester, Testing instance id 11:
//src_file:src/search.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
/* search.c - searching subroutines using dfa, kwset and regex for grep.
   Copyright 1992, 1998, 2000, 2007, 2009-2010 Free Software Foundation, Inc.

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 3, or (at your option)
   any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program; if not, write to the Free Software
   Foundation, Inc., 51 Franklin Street - Fifth Floor, Boston, MA
   02110-1301, USA.  */

/* Written August 1992 by Mike Haertel. */

#include <config.h>

#include <sys/types.h>

#include "mbsupport.h"
#ifdef MBS_SUPPORT
/* We can handle multibyte strings. */
# include <wchar.h>
# include <wctype.h>
#endif

#include "system.h"
#include "grep.h"
#ifndef FGREP_PROGRAM
# include <regex.h>
# include "dfa.h"
#endif
#include "kwset.h"
#include "error.h"
#include "xalloc.h"
#ifdef HAVE_LIBPCRE
# include <pcre.h>
#endif

#define NCHAR (UCHAR_MAX + 1)

/* For -w, we also consider _ to be word constituent.  */
#define WCHAR(C) (ISALNUM(C) || (C) == '_')

/* KWset compiled pattern.  For Ecompile and Gcompile, we compile
   a list of strings, at least one of which is known to occur in
   any string matching the regexp. */
static kwset_t kwset;

static void
kwsinit (void)
{
  static char trans[NCHAR];
  int i;

  if (match_icase && MB_CUR_MAX == 1)
    {
      for (i = 0; i < NCHAR; ++i)
        trans[i] = TOLOWER (i);

      kwset = kwsalloc (trans);
    }
  else
    kwset = kwsalloc (NULL);

  if (!kwset)
    xalloc_die ();
}

#ifdef MBS_SUPPORT
/* Convert the *N-byte string, BEG, to lowercase, and write the
   NUL-terminated result into malloc'd storage.  Upon success, set *N
   to the length (in bytes) of the resulting string (not including the
   trailing NUL byte), and return a pointer to the lowercase string.
   Upon memory allocation failure, this function exits.

   Note that while this function returns a pointer to malloc'd storage,
   the caller must not free it, since this function retains a pointer
   to the buffer and reuses it on any subsequent call.  As a consequence,
   this function is not thread-safe.  */
static char *
mbtolower (const char *beg, size_t *n)
{
  static char *out;
  static size_t outalloc;
  size_t outlen, mb_cur_max;
  mbstate_t is, os;
  const char *end;
  char *p;

  if (*n > outalloc)
    {
      out = xrealloc (out, *n);
      outalloc = *n;
    }

  memset (&is, 0, sizeof (is));
  memset (&os, 0, sizeof (os));
  end = beg + *n;

  mb_cur_max = MB_CUR_MAX;
  p = out;
  outlen = 0;
  while (beg < end)
    {
      wchar_t wc;
      size_t mbclen = mbrtowc(&wc, beg, end - beg, &is);
      if (outlen + mb_cur_max >= outalloc)
        {
          out = x2nrealloc (out, &outalloc, 1);
          p = out + outlen;
        }

      if (mbclen == (size_t) -1 || mbclen == (size_t) -2 || mbclen == 0)
        {
          /* An invalid sequence, or a truncated multi-octet character.
             We treat it as a single-octet character.  */
          *p++ = *beg++;
          outlen++;
          memset (&is, 0, sizeof (is));
          memset (&os, 0, sizeof (os));
        }
      else
        {
          beg += mbclen;
          mbclen = wcrtomb (p, towlower ((wint_t) wc), &os);
          p += mbclen;
          outlen += mbclen;
        }
    }

  *n = p - out;
  *p++ = 0;
  return out;
}
#endif


#ifndef FGREP_PROGRAM
/* DFA compiled regexp. */
static struct dfa dfa;

/* The Regex compiled patterns.  */
static struct patterns
{
  /* Regex compiled regexp. */
  struct re_pattern_buffer regexbuf;
  struct re_registers regs; /* This is here on account of a BRAIN-DEAD
			       Q@#%!# library interface in regex.c.  */
} patterns0;

struct patterns *patterns;
size_t pcount;

void
dfaerror (char const *mesg)
{
  error (EXIT_TROUBLE, 0, "%s", mesg);
}

/* Number of compiled fixed strings known to exactly match the regexp.
   If kwsexec returns < kwset_exact_matches, then we don't need to
   call the regexp matcher at all. */
static int kwset_exact_matches;

static char const *
kwsincr_case (const char *must)
{
  const char *buf;
  size_t n;

  n = strlen (must);
#ifdef MBS_SUPPORT
  if (match_icase && MB_CUR_MAX > 1)
    buf = mbtolower (must, &n);
  else
#endif
    buf = must;
  return kwsincr (kwset, buf, n);
}

/* If the DFA turns out to have some set of fixed strings one of
   which must occur in the match, then we build a kwset matcher
   to find those strings, and thus quickly filter out impossible
   matches. */
static void
kwsmusts (void)
{
  struct dfamust const *dm;
  char const *err;

  if (dfa.musts)
    {
      kwsinit ();
      /* First, we compile in the substrings known to be exact
	 matches.  The kwset matcher will return the index
	 of the matching string that it chooses. */
      for (dm = dfa.musts; dm; dm = dm->next)
	{
	  if (!dm->exact)
	    continue;
	  ++kwset_exact_matches;
	  if ((err = kwsincr_case (dm->must)) != NULL)
	    error (EXIT_TROUBLE, 0, "%s", err);
	}
      /* Now, we compile the substrings that will require
	 the use of the regexp matcher.  */
      for (dm = dfa.musts; dm; dm = dm->next)
	{
	  if (dm->exact)
	    continue;
	  if ((err = kwsincr_case (dm->must)) != NULL)
	    error (EXIT_TROUBLE, 0, "%s", err);
	}
      if ((err = kwsprep (kwset)) != NULL)
	error (EXIT_TROUBLE, 0, "%s", err);
    }
}
#endif /* !FGREP_PROGRAM */

#ifdef MBS_SUPPORT

static bool
is_mb_middle(const char **good, const char *buf, const char *end)
{
  const char *p = *good;
  const char *prev = p;
  mbstate_t cur_state;

  /* TODO: can be optimized for UTF-8.  */
  memset(&cur_state, 0, sizeof(mbstate_t));
  while (p < buf)
    {
      size_t mbclen = mbrlen(p, end - p, &cur_state);

      /* Store the beginning of the previous complete multibyte character.  */
      if (mbclen != (size_t) -2)
        prev = p;

      if (mbclen == (size_t) -1 || mbclen == (size_t) -2 || mbclen == 0)
	{
	  /* An invalid sequence, or a truncated multibyte character.
	     We treat it as a single byte character.  */
	  mbclen = 1;
	}
      p += mbclen;
    }

  *good = prev;
  return p > buf;
}
#endif /* MBS_SUPPORT */

#if defined(GREP_PROGRAM) || defined(EGREP_PROGRAM)
#ifdef EGREP_PROGRAM
COMPILE_FCT(Ecompile)
{
  reg_syntax_t syntax_bits = RE_SYNTAX_POSIX_EGREP;
#else
/* No __VA_ARGS__ in C89.  So we have to do it this way.  */
static COMPILE_RET
GEAcompile (char const *pattern, size_t size, reg_syntax_t syntax_bits)
{
#endif /* EGREP_PROGRAM */
  const char *err;
  const char *p, *sep;
  size_t total = size;
  char *motif;

  if (match_icase)
    syntax_bits |= RE_ICASE;
  re_set_syntax (syntax_bits);
  dfasyntax (syntax_bits, match_icase, eolbyte);

  /* For GNU regex compiler we have to pass the patterns separately to detect
     errors like "[\nallo\n]\n".  The patterns here are "[", "allo" and "]"
     GNU regex should have raise a syntax error.  The same for backref, where
     the backref should have been local to each pattern.  */
  p = pattern;
  do
    {
      size_t len;
      sep = memchr (p, '\n', total);
      if (sep)
	{
	  len = sep - p;
	  sep++;
	  total -= (len + 1);
	}
      else
	{
	  len = total;
	  total = 0;
	}

      patterns = realloc (patterns, (pcount + 1) * sizeof (*patterns));
      if (patterns == NULL)
	error (EXIT_TROUBLE, errno, _("memory exhausted"));
      patterns[pcount] = patterns0;

      if ((err = re_compile_pattern (p, len,
				    &(patterns[pcount].regexbuf))) != NULL)
	error (EXIT_TROUBLE, 0, "%s", err);
      pcount++;

      p = sep;
    } while (sep && total != 0);

  /* In the match_words and match_lines cases, we use a different pattern
     for the DFA matcher that will quickly throw out cases that won't work.
     Then if DFA succeeds we do some hairy stuff using the regex matcher
     to decide whether the match should really count. */
  if (match_words || match_lines)
    {
      static char const line_beg_no_bk[] = "^(";
      static char const line_end_no_bk[] = ")$";
      static char const word_beg_no_bk[] = "(^|[^[:alnum:]_])(";
      static char const word_end_no_bk[] = ")([^[:alnum:]_]|$)";
#ifdef EGREP_PROGRAM
# define IF_BK(x, y) (y)
      char *n = xmalloc (sizeof word_beg_no_bk - 1 + size + sizeof word_end_no_bk);
#else
      static char const line_beg_bk[] = "^\\(";
      static char const line_end_bk[] = "\\)$";
      static char const word_beg_bk[] = "\\(^\\|[^[:alnum:]_]\\)\\(";
      static char const word_end_bk[] = "\\)\\([^[:alnum:]_]\\|$\\)";
      int bk = !(syntax_bits & RE_NO_BK_PARENS);
# define IF_BK(x, y) ((bk) ? (x) : (y))
      char *n = xmalloc (sizeof word_beg_bk - 1 + size + sizeof word_end_bk);
#endif /* EGREP_PROGRAM */

      strcpy (n, match_lines ? IF_BK(line_beg_bk, line_beg_no_bk)
			     : IF_BK(word_beg_bk, word_beg_no_bk));
      total = strlen(n);
      memcpy (n + total, pattern, size);
      total += size;
      strcpy (n + total, match_lines ? IF_BK(line_end_bk, line_end_no_bk)
				     : IF_BK(word_end_bk, word_end_no_bk));
      total += strlen (n + total);
      pattern = motif = n;
      size = total;
    }
  else
    motif = NULL;

  dfacomp (pattern, size, &dfa, 1);
  kwsmusts ();

  free(motif);
}

#ifndef EGREP_PROGRAM
COMPILE_FCT(Gcompile)
{
  return GEAcompile (pattern, size,
		     RE_SYNTAX_GREP | RE_HAT_LISTS_NOT_NEWLINE);
}

COMPILE_FCT(Acompile)
{
  return GEAcompile (pattern, size, RE_SYNTAX_AWK);
}

COMPILE_FCT(Ecompile)
{
  return GEAcompile (pattern, size, RE_SYNTAX_POSIX_EGREP);
}
#endif /* !EGREP_PROGRAM */

EXECUTE_FCT(EGexecute)
{
  char const *buflim, *beg, *end, *match, *best_match, *mb_start;
  char eol = eolbyte;
  int backref, start, len, best_len;
  struct kwsmatch kwsm;
  size_t i, ret_val;
#ifdef MBS_SUPPORT
  if (MB_CUR_MAX > 1)
    {
      if (match_icase)
        {
          /* mbtolower adds a NUL byte at the end.  That will provide
	     space for the sentinel byte dfaexec may add.  */
          char *case_buf = mbtolower (buf, &size);
	  if (start_ptr)
	    start_ptr = case_buf + (start_ptr - buf);
          buf = case_buf;
        }
    }
#endif /* MBS_SUPPORT */

  mb_start = buf;
  buflim = buf + size;

  for (beg = end = buf; end < buflim; beg = end)
    {
      if (!start_ptr)
	{
	  /* We don't care about an exact match.  */
	  if (kwset)
	    {
	      /* Find a possible match using the KWset matcher. */
	      size_t offset = kwsexec (kwset, beg, buflim - beg, &kwsm);
	      if (offset == (size_t) -1)
		goto failure;
	      beg += offset;
	      /* Narrow down to the line containing the candidate, and
		 run it through DFA. */
	      if ((end = memchr(beg, eol, buflim - beg)) != NULL)
	        end++;
              else
                end = buflim;
	      match = beg;
	      while (beg > buf && beg[-1] != eol)
		--beg;
	      if (kwsm.index < kwset_exact_matches)
                {
#ifdef MBS_SUPPORT
                  if (mb_start < beg)
                    mb_start = beg;
                  if (MB_CUR_MAX == 1 || !is_mb_middle (&mb_start, match, buflim))
#endif
                    goto success;
                }
	      if (dfaexec (&dfa, beg, (char *) end, 0, NULL, &backref) == NULL)
		continue;
	    }
	  else
	    {
	      /* No good fixed strings; start with DFA. */
	      char const *next_beg = dfaexec (&dfa, beg, (char *) buflim,
					      0, NULL, &backref);
	      if (next_beg == NULL)
		break;
	      /* Narrow down to the line we've found. */
	      beg = next_beg;
	      if ((end = memchr(beg, eol, buflim - beg)) != NULL)
	        end++;
              else
                end = buflim;
	      while (beg > buf && beg[-1] != eol)
		--beg;
	    }
	  /* Successful, no backreferences encountered! */
	  if (!backref)
	    goto success;
	}
      else
	{
	  /* We are looking for the leftmost (then longest) exact match.
	     We will go through the outer loop only once.  */
	  beg = start_ptr;
	  end = buflim;
	}

      /* If we've made it to this point, this means DFA has seen
	 a probable match, and we need to run it through Regex. */
      best_match = end;
      best_len = 0;
      for (i = 0; i < pcount; i++)
	{
	  patterns[i].regexbuf.not_eol = 0;
	  if (0 <= (start = re_search (&(patterns[i].regexbuf),
				       buf, end - buf - 1,
				       beg - buf, end - beg - 1,
				       &(patterns[i].regs))))
	    {
	      len = patterns[i].regs.end[0] - start;
	      match = buf + start;
	      if (match > best_match)
		continue;
	      if (start_ptr && !match_words)
		goto assess_pattern_match;
	      if ((!match_lines && !match_words)
		  || (match_lines && len == end - beg - 1))
		{
		  match = beg;
		  len = end - beg;
		  goto assess_pattern_match;
		}
	      /* If -w, check if the match aligns with word boundaries.
		 We do this iteratively because:
		 (a) the line may contain more than one occurence of the
		 pattern, and
		 (b) Several alternatives in the pattern might be valid at a
		 given point, and we may need to consider a shorter one to
		 find a word boundary.  */
	      if (match_words)
		while (match <= best_match)
		  {
		    if ((match == buf || !WCHAR ((unsigned char) match[-1]))
			&& (len == end - beg - 1
			    || !WCHAR ((unsigned char) match[len])))
		      goto assess_pattern_match;
		    if (len > 0)
		      {
			/* Try a shorter length anchored at the same place. */
			--len;
			patterns[i].regexbuf.not_eol = 1;
			len = re_match (&(patterns[i].regexbuf),
					buf, match + len - beg, match - buf,
					&(patterns[i].regs));
		      }
		    if (len <= 0)
		      {
			/* Try looking further on. */
			if (match == end - 1)
			  break;
			match++;
			patterns[i].regexbuf.not_eol = 0;
			start = re_search (&(patterns[i].regexbuf),
					   buf, end - buf - 1,
					   match - buf, end - match - 1,
					   &(patterns[i].regs));
			if (start < 0)
			  break;
			len = patterns[i].regs.end[0] - start;
			match = buf + start;
		      }
		  } /* while (match <= best_match) */
	      continue;
	    assess_pattern_match:
	      if (!start_ptr)
		{
		  /* Good enough for a non-exact match.
		     No need to look at further patterns, if any.  */
		  beg = match;
		  goto success_in_len;
		}
	      if (match < best_match || (match == best_match && len > best_len))
		{
		  /* Best exact match:  leftmost, then longest.  */
		  best_match = match;
		  best_len = len;
		}
	    } /* if re_search >= 0 */
	} /* for Regex patterns.  */
	if (best_match < end)
	  {
	    /* We have found an exact match.  We were just
	       waiting for the best one (leftmost then longest).  */
	    beg = best_match;
	    len = best_len;
	    goto success_in_len;
	  }
    } /* for (beg = end ..) */

 failure:
  ret_val = -1;
  goto out;

 success:
  len = end - beg;
 success_in_len:
  *match_size = len;
  ret_val = beg - buf;
 out:
  return ret_val;
}
#endif /* defined(GREP_PROGRAM) || defined(EGREP_PROGRAM) */

#if defined(GREP_PROGRAM) || defined(FGREP_PROGRAM)
COMPILE_FCT(Fcompile)
{
  char const *beg, *end, *lim, *err, *pat;
  size_t psize;

  kwsinit ();
  psize = size;
  if (match_icase && MB_CUR_MAX > 1)
    pat = mbtolower (pattern, &psize);
  else
    pat = pattern;

  beg = pat;
  do
    {
      for (lim = beg;; ++lim)
	{
	  end = lim;
	  if (lim >= pat + psize)
	    break;
	 if (*lim == '\n')
	   {
	     lim++;
	     break;
	   }
#if HAVE_DOS_FILE_CONTENTS
	 if (*lim == '\r' && lim + 1 < pat + psize && lim[1] == '\n')
	   {
	     lim += 2;
	     break;
	   }
#endif
	}

      
//Patch 0:
if (((err = kwsincr(kwset, beg, end - beg)) != ((void *)0)) || (__is_neg(10, &(beg), sizeof (beg), &(end), sizeof (end), &(err), sizeof (err), &(kwset), sizeof (kwset), &(lim), sizeof (lim), &(pat), sizeof (pat), &(psize), sizeof (psize), &(pattern), sizeof (pattern), &(match_icase), sizeof (match_icase), &(size), sizeof (size))))
    error(EXIT_TROUBLE, 0, "%s", err);

//CodeSeg 1:
      beg = lim;
    }
  while (beg < pat + psize);

  if ((err = kwsprep (kwset)) != NULL)
    error (EXIT_TROUBLE, 0, "%s", err);
}

EXECUTE_FCT(Fexecute)
{
  char const *beg, *try, *end, *mb_start;
  size_t len;
  char eol = eolbyte;
  struct kwsmatch kwsmatch;
  size_t ret_val;
#ifdef MBS_SUPPORT
  if (MB_CUR_MAX > 1)
    {
      if (match_icase)
        {
          char *case_buf = mbtolower (buf, &size);
	  if (start_ptr)
	    start_ptr = case_buf + (start_ptr - buf);
          buf = case_buf;
        }
    }
#endif /* MBS_SUPPORT */

  for (mb_start = beg = start_ptr ? start_ptr : buf; beg <= buf + size; beg++)
    {
      size_t offset = kwsexec (kwset, beg, buf + size - beg, &kwsmatch);
      if (offset == (size_t) -1)
	goto failure;
#ifdef MBS_SUPPORT
      if (MB_CUR_MAX > 1 && is_mb_middle (&mb_start, beg + offset, buf + size))
        {
          beg = mb_start - 1;
          continue; /* It is a part of multibyte character.  */
        }
#endif /* MBS_SUPPORT */
      beg += offset;
      len = kwsmatch.size[0];
      if (start_ptr && !match_words)
	goto success_in_beg_and_len;
      if (match_lines)
	{
	  if (beg > buf && beg[-1] != eol)
	    continue;
	  if (beg + len < buf + size && beg[len] != eol)
	    continue;
	  goto success;
	}
      else if (match_words)
	for (try = beg; len; )
	  {
	    if (try > buf && WCHAR((unsigned char) try[-1]))
	      break;
	    if (try + len < buf + size && WCHAR((unsigned char) try[len]))
	      {
		offset = kwsexec (kwset, beg, --len, &kwsmatch);
		if (offset == (size_t) -1)
		  break;
		try = beg + offset;
		len = kwsmatch.size[0];
	      }
	    else if (!start_ptr)
	      goto success;
	    else
	      goto success_in_beg_and_len;
	  } /* for (try) */
      else
	goto success;
    } /* for (beg in buf) */

 failure:
  ret_val = -1;
  goto out;

 success:
  if ((end = memchr (beg + len, eol, (buf + size) - (beg + len))) != NULL)
    end++;
  else
    end = buf + size;
  while (buf < beg && beg[-1] != eol)
    --beg;
  len = end - beg;
 success_in_beg_and_len:
  *match_size = len;
  ret_val = beg - buf;
 out:
  return ret_val;
}
#endif /* defined(GREP_PROGRAM) || defined(FGREP_PROGRAM) */

#ifdef GREP_PROGRAM
#if HAVE_LIBPCRE
/* Compiled internal form of a Perl regular expression.  */
static pcre *cre;

/* Additional information about the pattern.  */
static pcre_extra *extra;
#endif

COMPILE_FCT(Pcompile)
{
#if !HAVE_LIBPCRE
  error (EXIT_TROUBLE, 0, "%s",
	 _("support for the -P option is not compiled into "
	   "this --disable-perl-regexp binary"));
#else
  int e;
  char const *ep;
  char *re = xmalloc (4 * size + 7);
  int flags = PCRE_MULTILINE | (match_icase ? PCRE_CASELESS : 0);
  char const *patlim = pattern + size;
  char *n = re;
  char const *p;
  char const *pnul;

  /* FIXME: Remove these restrictions.  */
  if (memchr(pattern, '\n', size))
    error (EXIT_TROUBLE, 0, _("the -P option only supports a single pattern"));

  *n = '\0';
  if (match_lines)
    strcpy (n, "^(");
  if (match_words)
    strcpy (n, "\\b(");
  n += strlen (n);

  /* The PCRE interface doesn't allow NUL bytes in the pattern, so
     replace each NUL byte in the pattern with the four characters
     "\000", removing a preceding backslash if there are an odd
     number of backslashes before the NUL.

     FIXME: This method does not work with some multibyte character
     encodings, notably Shift-JIS, where a multibyte character can end
     in a backslash byte.  */
  for (p = pattern; (pnul = memchr (p, '\0', patlim - p)); p = pnul + 1)
    {
      memcpy (n, p, pnul - p);
      n += pnul - p;
      for (p = pnul; pattern < p && p[-1] == '\\'; p--)
	continue;
      n -= (pnul - p) & 1;
      strcpy (n, "\\000");
      n += 4;
    }

  memcpy (n, p, patlim - p);
  n += patlim - p;
  *n = '\0';
  if (match_words)
    strcpy (n, ")\\b");
  if (match_lines)
    strcpy (n, ")$");

  cre = pcre_compile (re, flags, &ep, &e, pcre_maketables ());
  if (!cre)
    error (EXIT_TROUBLE, 0, "%s", ep);

  extra = pcre_study (cre, 0, &ep);
  if (ep)
    error (EXIT_TROUBLE, 0, "%s", ep);

  free (re);
#endif
}

EXECUTE_FCT(Pexecute)
{
#if !HAVE_LIBPCRE
  abort ();
  return -1;
#else
  /* This array must have at least two elements; everything after that
     is just for performance improvement in pcre_exec.  */
  int sub[300];

  const char *line_buf, *line_end, *line_next;
  int e = PCRE_ERROR_NOMATCH;
  ptrdiff_t start_ofs = start_ptr ? start_ptr - buf : 0;

  /* PCRE can't limit the matching to single lines, therefore we have to
     match each line in the buffer separately.  */
  for (line_next = buf;
       e == PCRE_ERROR_NOMATCH && line_next < buf + size;
       start_ofs -= line_next - line_buf)
    {
      line_buf = line_next;
      line_end = memchr (line_buf, eolbyte, (buf + size) - line_buf);
      if (line_end == NULL)
        line_next = line_end = buf + size;
      else
        line_next = line_end + 1;

      if (start_ptr && start_ptr >= line_end)
        continue;

      e = pcre_exec (cre, extra, line_buf, line_end - line_buf,
                     start_ofs < 0 ? 0 : start_ofs, 0,
                     sub, sizeof sub / sizeof *sub);
    }

  if (e <= 0)
    {
      switch (e)
	{
	case PCRE_ERROR_NOMATCH:
	  return -1;

	case PCRE_ERROR_NOMEMORY:
	  error (EXIT_TROUBLE, 0, _("memory exhausted"));

	default:
	  abort ();
	}
    }
  else
    {
      /* Narrow down to the line we've found.  */
      char const *beg = line_buf + sub[0];
      char const *end = line_buf + sub[1];
      char const *buflim = buf + size;
      char eol = eolbyte;
      if (!start_ptr)
	{
	  /* FIXME: The case when '\n' is not found indicates a bug:
	     Since grep is line oriented, the match should never contain
	     a newline, so there _must_ be a newline following.
	   */
	  if (!(end = memchr (end, eol, buflim - end)))
	    end = buflim;
	  else
	    end++;
	  while (buf < beg && beg[-1] != eol)
	    --beg;
	}

      *match_size = end - beg;
      return beg - buf;
    }
#endif
}

struct matcher const matchers[] = {
  { "default", Gcompile, EGexecute },
  { "grep",    Gcompile, EGexecute },
  { "egrep",   Ecompile, EGexecute },
  { "awk",     Acompile, EGexecute },
  { "fgrep",   Fcompile, Fexecute },
  { "perl",    Pcompile, Pexecute },
  { "", 0, 0 },
};
#endif /* GREP_PROGRAM */

Testing negative cases!
Testing 0 (with abstract condition) ENVIS_NEG
Iteration 0
Running test command:
/home/ubuntu/spr-fast/tools/grep-test.py /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-deccad69-db9d6340/tempworkdir2/src /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-deccad69-db9d6340/tempworkdir2/tests /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-deccad69-db9d6340/tempworkdir2 0  > __res
Opening:/home/ubuntu/spr-fast/tests/corebench/grep/grep-case-deccad69-db9d6340/tempworkdir2/neg.tmp!
NegativeBRANCH RECORD/home/ubuntu/spr-fast/tests/corebench/grep/grep-case-deccad69-db9d6340/tempworkdir2/neg.tmp!
APPENDING TO ISNEG:/home/ubuntu/spr-fast/tests/corebench/grep/grep-case-deccad69-db9d6340/tempworkdir2/neg.tmp!
Branch 0: 0
Iteration 1
Running test command:
/home/ubuntu/spr-fast/tools/grep-test.py /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-deccad69-db9d6340/tempworkdir2/src /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-deccad69-db9d6340/tempworkdir2/tests /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-deccad69-db9d6340/tempworkdir2 0  > __res
Opening:/home/ubuntu/spr-fast/tests/corebench/grep/grep-case-deccad69-db9d6340/tempworkdir2/neg.tmp!
NegativeBRANCH RECORD/home/ubuntu/spr-fast/tests/corebench/grep/grep-case-deccad69-db9d6340/tempworkdir2/neg.tmp!
APPENDING TO ISNEG:/home/ubuntu/spr-fast/tests/corebench/grep/grep-case-deccad69-db9d6340/tempworkdir2/neg.tmp!
Branch 0: 1
Passed in iteration!
Passed Negative Cases wiht CondTestder!
Testing positive cases!
Running test command:
/home/ubuntu/spr-fast/tools/grep-test.py /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-deccad69-db9d6340/tempworkdir2/src /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-deccad69-db9d6340/tempworkdir2/tests /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-deccad69-db9d6340/tempworkdir2 9  > __res
Running test command:
/home/ubuntu/spr-fast/tools/grep-test.py /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-deccad69-db9d6340/tempworkdir2/src /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-deccad69-db9d6340/tempworkdir2/tests /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-deccad69-db9d6340/tempworkdir2 12  > __res
Running test command:
/home/ubuntu/spr-fast/tools/grep-test.py /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-deccad69-db9d6340/tempworkdir2/src /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-deccad69-db9d6340/tempworkdir2/tests /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-deccad69-db9d6340/tempworkdir2 3  > __res
Running test command:
/home/ubuntu/spr-fast/tools/grep-test.py /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-deccad69-db9d6340/tempworkdir2/src /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-deccad69-db9d6340/tempworkdir2/tests /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-deccad69-db9d6340/tempworkdir2 4  > __res
Running test command:
/home/ubuntu/spr-fast/tools/grep-test.py /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-deccad69-db9d6340/tempworkdir2/src /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-deccad69-db9d6340/tempworkdir2/tests /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-deccad69-db9d6340/tempworkdir2 5  > __res
Running test command:
/home/ubuntu/spr-fast/tools/grep-test.py /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-deccad69-db9d6340/tempworkdir2/src /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-deccad69-db9d6340/tempworkdir2/tests /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-deccad69-db9d6340/tempworkdir2 6  > __res
Running test command:
/home/ubuntu/spr-fast/tools/grep-test.py /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-deccad69-db9d6340/tempworkdir2/src /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-deccad69-db9d6340/tempworkdir2/tests /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-deccad69-db9d6340/tempworkdir2 11  > __res
Running test command:
/home/ubuntu/spr-fast/tools/grep-test.py /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-deccad69-db9d6340/tempworkdir2/src /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-deccad69-db9d6340/tempworkdir2/tests /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-deccad69-db9d6340/tempworkdir2 13  > __res
Running test command:
/home/ubuntu/spr-fast/tools/grep-test.py /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-deccad69-db9d6340/tempworkdir2/src /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-deccad69-db9d6340/tempworkdir2/tests /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-deccad69-db9d6340/tempworkdir2 14  > __res
Running test command:
/home/ubuntu/spr-fast/tools/grep-test.py /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-deccad69-db9d6340/tempworkdir2/src /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-deccad69-db9d6340/tempworkdir2/tests /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-deccad69-db9d6340/tempworkdir2 15  > __res
Running test command:
/home/ubuntu/spr-fast/tools/grep-test.py /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-deccad69-db9d6340/tempworkdir2/src /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-deccad69-db9d6340/tempworkdir2/tests /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-deccad69-db9d6340/tempworkdir2 17  > __res
Running test command:
/home/ubuntu/spr-fast/tools/grep-test.py /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-deccad69-db9d6340/tempworkdir2/src /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-deccad69-db9d6340/tempworkdir2/tests /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-deccad69-db9d6340/tempworkdir2 18  > __res
Running test command:
/home/ubuntu/spr-fast/tools/grep-test.py /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-deccad69-db9d6340/tempworkdir2/src /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-deccad69-db9d6340/tempworkdir2/tests /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-deccad69-db9d6340/tempworkdir2 20  > __res
Running test command:
/home/ubuntu/spr-fast/tools/grep-test.py /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-deccad69-db9d6340/tempworkdir2/src /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-deccad69-db9d6340/tempworkdir2/tests /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-deccad69-db9d6340/tempworkdir2 22  > __res
Running test command:
/home/ubuntu/spr-fast/tools/grep-test.py /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-deccad69-db9d6340/tempworkdir2/src /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-deccad69-db9d6340/tempworkdir2/tests /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-deccad69-db9d6340/tempworkdir2 23  > __res
Running test command:
/home/ubuntu/spr-fast/tools/grep-test.py /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-deccad69-db9d6340/tempworkdir2/src /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-deccad69-db9d6340/tempworkdir2/tests /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-deccad69-db9d6340/tempworkdir2 25  > __res
Passed Positive Cases
Collect values for post processing!
WRITING TO ISNEG:/home/ubuntu/spr-fast/tests/corebench/grep/grep-case-deccad69-db9d6340/tempworkdir2/neg.tmp!
Running test command:
/home/ubuntu/spr-fast/tools/grep-test.py /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-deccad69-db9d6340/tempworkdir2/src /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-deccad69-db9d6340/tempworkdir2/tests /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-deccad69-db9d6340/tempworkdir2 0  > __res
Running test command:
/home/ubuntu/spr-fast/tools/grep-test.py /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-deccad69-db9d6340/tempworkdir2/src /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-deccad69-db9d6340/tempworkdir2/tests /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-deccad69-db9d6340/tempworkdir2 3  > __res
Running test command:
/home/ubuntu/spr-fast/tools/grep-test.py /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-deccad69-db9d6340/tempworkdir2/src /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-deccad69-db9d6340/tempworkdir2/tests /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-deccad69-db9d6340/tempworkdir2 4  > __res
Running test command:
/home/ubuntu/spr-fast/tools/grep-test.py /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-deccad69-db9d6340/tempworkdir2/src /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-deccad69-db9d6340/tempworkdir2/tests /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-deccad69-db9d6340/tempworkdir2 5  > __res
Running test command:
/home/ubuntu/spr-fast/tools/grep-test.py /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-deccad69-db9d6340/tempworkdir2/src /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-deccad69-db9d6340/tempworkdir2/tests /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-deccad69-db9d6340/tempworkdir2 6  > __res
Running test command:
/home/ubuntu/spr-fast/tools/grep-test.py /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-deccad69-db9d6340/tempworkdir2/src /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-deccad69-db9d6340/tempworkdir2/tests /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-deccad69-db9d6340/tempworkdir2 9  > __res
Running test command:
/home/ubuntu/spr-fast/tools/grep-test.py /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-deccad69-db9d6340/tempworkdir2/src /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-deccad69-db9d6340/tempworkdir2/tests /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-deccad69-db9d6340/tempworkdir2 11  > __res
Running test command:
/home/ubuntu/spr-fast/tools/grep-test.py /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-deccad69-db9d6340/tempworkdir2/src /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-deccad69-db9d6340/tempworkdir2/tests /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-deccad69-db9d6340/tempworkdir2 12  > __res
Running test command:
/home/ubuntu/spr-fast/tools/grep-test.py /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-deccad69-db9d6340/tempworkdir2/src /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-deccad69-db9d6340/tempworkdir2/tests /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-deccad69-db9d6340/tempworkdir2 13  > __res
Running test command:
/home/ubuntu/spr-fast/tools/grep-test.py /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-deccad69-db9d6340/tempworkdir2/src /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-deccad69-db9d6340/tempworkdir2/tests /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-deccad69-db9d6340/tempworkdir2 14  > __res
Running test command:
/home/ubuntu/spr-fast/tools/grep-test.py /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-deccad69-db9d6340/tempworkdir2/src /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-deccad69-db9d6340/tempworkdir2/tests /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-deccad69-db9d6340/tempworkdir2 15  > __res
Running test command:
/home/ubuntu/spr-fast/tools/grep-test.py /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-deccad69-db9d6340/tempworkdir2/src /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-deccad69-db9d6340/tempworkdir2/tests /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-deccad69-db9d6340/tempworkdir2 17  > __res
Running test command:
/home/ubuntu/spr-fast/tools/grep-test.py /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-deccad69-db9d6340/tempworkdir2/src /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-deccad69-db9d6340/tempworkdir2/tests /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-deccad69-db9d6340/tempworkdir2 18  > __res
Running test command:
/home/ubuntu/spr-fast/tools/grep-test.py /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-deccad69-db9d6340/tempworkdir2/src /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-deccad69-db9d6340/tempworkdir2/tests /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-deccad69-db9d6340/tempworkdir2 20  > __res
Running test command:
/home/ubuntu/spr-fast/tools/grep-test.py /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-deccad69-db9d6340/tempworkdir2/src /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-deccad69-db9d6340/tempworkdir2/tests /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-deccad69-db9d6340/tempworkdir2 22  > __res
Running test command:
/home/ubuntu/spr-fast/tools/grep-test.py /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-deccad69-db9d6340/tempworkdir2/src /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-deccad69-db9d6340/tempworkdir2/tests /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-deccad69-db9d6340/tempworkdir2 23  > __res
Running test command:
/home/ubuntu/spr-fast/tools/grep-test.py /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-deccad69-db9d6340/tempworkdir2/src /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-deccad69-db9d6340/tempworkdir2/tests /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-deccad69-db9d6340/tempworkdir2 25  > __res
Passed!
CondTester, Postprocessing instance id 11:
//src_file:src/search.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
/* search.c - searching subroutines using dfa, kwset and regex for grep.
   Copyright 1992, 1998, 2000, 2007, 2009-2010 Free Software Foundation, Inc.

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 3, or (at your option)
   any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program; if not, write to the Free Software
   Foundation, Inc., 51 Franklin Street - Fifth Floor, Boston, MA
   02110-1301, USA.  */

/* Written August 1992 by Mike Haertel. */

#include <config.h>

#include <sys/types.h>

#include "mbsupport.h"
#ifdef MBS_SUPPORT
/* We can handle multibyte strings. */
# include <wchar.h>
# include <wctype.h>
#endif

#include "system.h"
#include "grep.h"
#ifndef FGREP_PROGRAM
# include <regex.h>
# include "dfa.h"
#endif
#include "kwset.h"
#include "error.h"
#include "xalloc.h"
#ifdef HAVE_LIBPCRE
# include <pcre.h>
#endif

#define NCHAR (UCHAR_MAX + 1)

/* For -w, we also consider _ to be word constituent.  */
#define WCHAR(C) (ISALNUM(C) || (C) == '_')

/* KWset compiled pattern.  For Ecompile and Gcompile, we compile
   a list of strings, at least one of which is known to occur in
   any string matching the regexp. */
static kwset_t kwset;

static void
kwsinit (void)
{
  static char trans[NCHAR];
  int i;

  if (match_icase && MB_CUR_MAX == 1)
    {
      for (i = 0; i < NCHAR; ++i)
        trans[i] = TOLOWER (i);

      kwset = kwsalloc (trans);
    }
  else
    kwset = kwsalloc (NULL);

  if (!kwset)
    xalloc_die ();
}

#ifdef MBS_SUPPORT
/* Convert the *N-byte string, BEG, to lowercase, and write the
   NUL-terminated result into malloc'd storage.  Upon success, set *N
   to the length (in bytes) of the resulting string (not including the
   trailing NUL byte), and return a pointer to the lowercase string.
   Upon memory allocation failure, this function exits.

   Note that while this function returns a pointer to malloc'd storage,
   the caller must not free it, since this function retains a pointer
   to the buffer and reuses it on any subsequent call.  As a consequence,
   this function is not thread-safe.  */
static char *
mbtolower (const char *beg, size_t *n)
{
  static char *out;
  static size_t outalloc;
  size_t outlen, mb_cur_max;
  mbstate_t is, os;
  const char *end;
  char *p;

  if (*n > outalloc)
    {
      out = xrealloc (out, *n);
      outalloc = *n;
    }

  memset (&is, 0, sizeof (is));
  memset (&os, 0, sizeof (os));
  end = beg + *n;

  mb_cur_max = MB_CUR_MAX;
  p = out;
  outlen = 0;
  while (beg < end)
    {
      wchar_t wc;
      size_t mbclen = mbrtowc(&wc, beg, end - beg, &is);
      if (outlen + mb_cur_max >= outalloc)
        {
          out = x2nrealloc (out, &outalloc, 1);
          p = out + outlen;
        }

      if (mbclen == (size_t) -1 || mbclen == (size_t) -2 || mbclen == 0)
        {
          /* An invalid sequence, or a truncated multi-octet character.
             We treat it as a single-octet character.  */
          *p++ = *beg++;
          outlen++;
          memset (&is, 0, sizeof (is));
          memset (&os, 0, sizeof (os));
        }
      else
        {
          beg += mbclen;
          mbclen = wcrtomb (p, towlower ((wint_t) wc), &os);
          p += mbclen;
          outlen += mbclen;
        }
    }

  *n = p - out;
  *p++ = 0;
  return out;
}
#endif


#ifndef FGREP_PROGRAM
/* DFA compiled regexp. */
static struct dfa dfa;

/* The Regex compiled patterns.  */
static struct patterns
{
  /* Regex compiled regexp. */
  struct re_pattern_buffer regexbuf;
  struct re_registers regs; /* This is here on account of a BRAIN-DEAD
			       Q@#%!# library interface in regex.c.  */
} patterns0;

struct patterns *patterns;
size_t pcount;

void
dfaerror (char const *mesg)
{
  error (EXIT_TROUBLE, 0, "%s", mesg);
}

/* Number of compiled fixed strings known to exactly match the regexp.
   If kwsexec returns < kwset_exact_matches, then we don't need to
   call the regexp matcher at all. */
static int kwset_exact_matches;

static char const *
kwsincr_case (const char *must)
{
  const char *buf;
  size_t n;

  n = strlen (must);
#ifdef MBS_SUPPORT
  if (match_icase && MB_CUR_MAX > 1)
    buf = mbtolower (must, &n);
  else
#endif
    buf = must;
  return kwsincr (kwset, buf, n);
}

/* If the DFA turns out to have some set of fixed strings one of
   which must occur in the match, then we build a kwset matcher
   to find those strings, and thus quickly filter out impossible
   matches. */
static void
kwsmusts (void)
{
  struct dfamust const *dm;
  char const *err;

  if (dfa.musts)
    {
      kwsinit ();
      /* First, we compile in the substrings known to be exact
	 matches.  The kwset matcher will return the index
	 of the matching string that it chooses. */
      for (dm = dfa.musts; dm; dm = dm->next)
	{
	  if (!dm->exact)
	    continue;
	  ++kwset_exact_matches;
	  if ((err = kwsincr_case (dm->must)) != NULL)
	    error (EXIT_TROUBLE, 0, "%s", err);
	}
      /* Now, we compile the substrings that will require
	 the use of the regexp matcher.  */
      for (dm = dfa.musts; dm; dm = dm->next)
	{
	  if (dm->exact)
	    continue;
	  if ((err = kwsincr_case (dm->must)) != NULL)
	    error (EXIT_TROUBLE, 0, "%s", err);
	}
      if ((err = kwsprep (kwset)) != NULL)
	error (EXIT_TROUBLE, 0, "%s", err);
    }
}
#endif /* !FGREP_PROGRAM */

#ifdef MBS_SUPPORT

static bool
is_mb_middle(const char **good, const char *buf, const char *end)
{
  const char *p = *good;
  const char *prev = p;
  mbstate_t cur_state;

  /* TODO: can be optimized for UTF-8.  */
  memset(&cur_state, 0, sizeof(mbstate_t));
  while (p < buf)
    {
      size_t mbclen = mbrlen(p, end - p, &cur_state);

      /* Store the beginning of the previous complete multibyte character.  */
      if (mbclen != (size_t) -2)
        prev = p;

      if (mbclen == (size_t) -1 || mbclen == (size_t) -2 || mbclen == 0)
	{
	  /* An invalid sequence, or a truncated multibyte character.
	     We treat it as a single byte character.  */
	  mbclen = 1;
	}
      p += mbclen;
    }

  *good = prev;
  return p > buf;
}
#endif /* MBS_SUPPORT */

#if defined(GREP_PROGRAM) || defined(EGREP_PROGRAM)
#ifdef EGREP_PROGRAM
COMPILE_FCT(Ecompile)
{
  reg_syntax_t syntax_bits = RE_SYNTAX_POSIX_EGREP;
#else
/* No __VA_ARGS__ in C89.  So we have to do it this way.  */
static COMPILE_RET
GEAcompile (char const *pattern, size_t size, reg_syntax_t syntax_bits)
{
#endif /* EGREP_PROGRAM */
  const char *err;
  const char *p, *sep;
  size_t total = size;
  char *motif;

  if (match_icase)
    syntax_bits |= RE_ICASE;
  re_set_syntax (syntax_bits);
  dfasyntax (syntax_bits, match_icase, eolbyte);

  /* For GNU regex compiler we have to pass the patterns separately to detect
     errors like "[\nallo\n]\n".  The patterns here are "[", "allo" and "]"
     GNU regex should have raise a syntax error.  The same for backref, where
     the backref should have been local to each pattern.  */
  p = pattern;
  do
    {
      size_t len;
      sep = memchr (p, '\n', total);
      if (sep)
	{
	  len = sep - p;
	  sep++;
	  total -= (len + 1);
	}
      else
	{
	  len = total;
	  total = 0;
	}

      patterns = realloc (patterns, (pcount + 1) * sizeof (*patterns));
      if (patterns == NULL)
	error (EXIT_TROUBLE, errno, _("memory exhausted"));
      patterns[pcount] = patterns0;

      if ((err = re_compile_pattern (p, len,
				    &(patterns[pcount].regexbuf))) != NULL)
	error (EXIT_TROUBLE, 0, "%s", err);
      pcount++;

      p = sep;
    } while (sep && total != 0);

  /* In the match_words and match_lines cases, we use a different pattern
     for the DFA matcher that will quickly throw out cases that won't work.
     Then if DFA succeeds we do some hairy stuff using the regex matcher
     to decide whether the match should really count. */
  if (match_words || match_lines)
    {
      static char const line_beg_no_bk[] = "^(";
      static char const line_end_no_bk[] = ")$";
      static char const word_beg_no_bk[] = "(^|[^[:alnum:]_])(";
      static char const word_end_no_bk[] = ")([^[:alnum:]_]|$)";
#ifdef EGREP_PROGRAM
# define IF_BK(x, y) (y)
      char *n = xmalloc (sizeof word_beg_no_bk - 1 + size + sizeof word_end_no_bk);
#else
      static char const line_beg_bk[] = "^\\(";
      static char const line_end_bk[] = "\\)$";
      static char const word_beg_bk[] = "\\(^\\|[^[:alnum:]_]\\)\\(";
      static char const word_end_bk[] = "\\)\\([^[:alnum:]_]\\|$\\)";
      int bk = !(syntax_bits & RE_NO_BK_PARENS);
# define IF_BK(x, y) ((bk) ? (x) : (y))
      char *n = xmalloc (sizeof word_beg_bk - 1 + size + sizeof word_end_bk);
#endif /* EGREP_PROGRAM */

      strcpy (n, match_lines ? IF_BK(line_beg_bk, line_beg_no_bk)
			     : IF_BK(word_beg_bk, word_beg_no_bk));
      total = strlen(n);
      memcpy (n + total, pattern, size);
      total += size;
      strcpy (n + total, match_lines ? IF_BK(line_end_bk, line_end_no_bk)
				     : IF_BK(word_end_bk, word_end_no_bk));
      total += strlen (n + total);
      pattern = motif = n;
      size = total;
    }
  else
    motif = NULL;

  dfacomp (pattern, size, &dfa, 1);
  kwsmusts ();

  free(motif);
}

#ifndef EGREP_PROGRAM
COMPILE_FCT(Gcompile)
{
  return GEAcompile (pattern, size,
		     RE_SYNTAX_GREP | RE_HAT_LISTS_NOT_NEWLINE);
}

COMPILE_FCT(Acompile)
{
  return GEAcompile (pattern, size, RE_SYNTAX_AWK);
}

COMPILE_FCT(Ecompile)
{
  return GEAcompile (pattern, size, RE_SYNTAX_POSIX_EGREP);
}
#endif /* !EGREP_PROGRAM */

EXECUTE_FCT(EGexecute)
{
  char const *buflim, *beg, *end, *match, *best_match, *mb_start;
  char eol = eolbyte;
  int backref, start, len, best_len;
  struct kwsmatch kwsm;
  size_t i, ret_val;
#ifdef MBS_SUPPORT
  if (MB_CUR_MAX > 1)
    {
      if (match_icase)
        {
          /* mbtolower adds a NUL byte at the end.  That will provide
	     space for the sentinel byte dfaexec may add.  */
          char *case_buf = mbtolower (buf, &size);
	  if (start_ptr)
	    start_ptr = case_buf + (start_ptr - buf);
          buf = case_buf;
        }
    }
#endif /* MBS_SUPPORT */

  mb_start = buf;
  buflim = buf + size;

  for (beg = end = buf; end < buflim; beg = end)
    {
      if (!start_ptr)
	{
	  /* We don't care about an exact match.  */
	  if (kwset)
	    {
	      /* Find a possible match using the KWset matcher. */
	      size_t offset = kwsexec (kwset, beg, buflim - beg, &kwsm);
	      if (offset == (size_t) -1)
		goto failure;
	      beg += offset;
	      /* Narrow down to the line containing the candidate, and
		 run it through DFA. */
	      if ((end = memchr(beg, eol, buflim - beg)) != NULL)
	        end++;
              else
                end = buflim;
	      match = beg;
	      while (beg > buf && beg[-1] != eol)
		--beg;
	      if (kwsm.index < kwset_exact_matches)
                {
#ifdef MBS_SUPPORT
                  if (mb_start < beg)
                    mb_start = beg;
                  if (MB_CUR_MAX == 1 || !is_mb_middle (&mb_start, match, buflim))
#endif
                    goto success;
                }
	      if (dfaexec (&dfa, beg, (char *) end, 0, NULL, &backref) == NULL)
		continue;
	    }
	  else
	    {
	      /* No good fixed strings; start with DFA. */
	      char const *next_beg = dfaexec (&dfa, beg, (char *) buflim,
					      0, NULL, &backref);
	      if (next_beg == NULL)
		break;
	      /* Narrow down to the line we've found. */
	      beg = next_beg;
	      if ((end = memchr(beg, eol, buflim - beg)) != NULL)
	        end++;
              else
                end = buflim;
	      while (beg > buf && beg[-1] != eol)
		--beg;
	    }
	  /* Successful, no backreferences encountered! */
	  if (!backref)
	    goto success;
	}
      else
	{
	  /* We are looking for the leftmost (then longest) exact match.
	     We will go through the outer loop only once.  */
	  beg = start_ptr;
	  end = buflim;
	}

      /* If we've made it to this point, this means DFA has seen
	 a probable match, and we need to run it through Regex. */
      best_match = end;
      best_len = 0;
      for (i = 0; i < pcount; i++)
	{
	  patterns[i].regexbuf.not_eol = 0;
	  if (0 <= (start = re_search (&(patterns[i].regexbuf),
				       buf, end - buf - 1,
				       beg - buf, end - beg - 1,
				       &(patterns[i].regs))))
	    {
	      len = patterns[i].regs.end[0] - start;
	      match = buf + start;
	      if (match > best_match)
		continue;
	      if (start_ptr && !match_words)
		goto assess_pattern_match;
	      if ((!match_lines && !match_words)
		  || (match_lines && len == end - beg - 1))
		{
		  match = beg;
		  len = end - beg;
		  goto assess_pattern_match;
		}
	      /* If -w, check if the match aligns with word boundaries.
		 We do this iteratively because:
		 (a) the line may contain more than one occurence of the
		 pattern, and
		 (b) Several alternatives in the pattern might be valid at a
		 given point, and we may need to consider a shorter one to
		 find a word boundary.  */
	      if (match_words)
		while (match <= best_match)
		  {
		    if ((match == buf || !WCHAR ((unsigned char) match[-1]))
			&& (len == end - beg - 1
			    || !WCHAR ((unsigned char) match[len])))
		      goto assess_pattern_match;
		    if (len > 0)
		      {
			/* Try a shorter length anchored at the same place. */
			--len;
			patterns[i].regexbuf.not_eol = 1;
			len = re_match (&(patterns[i].regexbuf),
					buf, match + len - beg, match - buf,
					&(patterns[i].regs));
		      }
		    if (len <= 0)
		      {
			/* Try looking further on. */
			if (match == end - 1)
			  break;
			match++;
			patterns[i].regexbuf.not_eol = 0;
			start = re_search (&(patterns[i].regexbuf),
					   buf, end - buf - 1,
					   match - buf, end - match - 1,
					   &(patterns[i].regs));
			if (start < 0)
			  break;
			len = patterns[i].regs.end[0] - start;
			match = buf + start;
		      }
		  } /* while (match <= best_match) */
	      continue;
	    assess_pattern_match:
	      if (!start_ptr)
		{
		  /* Good enough for a non-exact match.
		     No need to look at further patterns, if any.  */
		  beg = match;
		  goto success_in_len;
		}
	      if (match < best_match || (match == best_match && len > best_len))
		{
		  /* Best exact match:  leftmost, then longest.  */
		  best_match = match;
		  best_len = len;
		}
	    } /* if re_search >= 0 */
	} /* for Regex patterns.  */
	if (best_match < end)
	  {
	    /* We have found an exact match.  We were just
	       waiting for the best one (leftmost then longest).  */
	    beg = best_match;
	    len = best_len;
	    goto success_in_len;
	  }
    } /* for (beg = end ..) */

 failure:
  ret_val = -1;
  goto out;

 success:
  len = end - beg;
 success_in_len:
  *match_size = len;
  ret_val = beg - buf;
 out:
  return ret_val;
}
#endif /* defined(GREP_PROGRAM) || defined(EGREP_PROGRAM) */

#if defined(GREP_PROGRAM) || defined(FGREP_PROGRAM)
COMPILE_FCT(Fcompile)
{
  char const *beg, *end, *lim, *err, *pat;
  size_t psize;

  kwsinit ();
  psize = size;
  if (match_icase && MB_CUR_MAX > 1)
    pat = mbtolower (pattern, &psize);
  else
    pat = pattern;

  beg = pat;
  do
    {
      for (lim = beg;; ++lim)
	{
	  end = lim;
	  if (lim >= pat + psize)
	    break;
	 if (*lim == '\n')
	   {
	     lim++;
	     break;
	   }
#if HAVE_DOS_FILE_CONTENTS
	 if (*lim == '\r' && lim + 1 < pat + psize && lim[1] == '\n')
	   {
	     lim += 2;
	     break;
	   }
#endif
	}

      
//Patch 0:
if (((err = kwsincr(kwset, beg, end - beg)) != ((void *)0)) || (__is_neg(10, &(beg), sizeof (beg), &(end), sizeof (end), &(err), sizeof (err), &(kwset), sizeof (kwset), &(lim), sizeof (lim), &(pat), sizeof (pat), &(psize), sizeof (psize), &(pattern), sizeof (pattern), &(match_icase), sizeof (match_icase), &(size), sizeof (size))))
    error(EXIT_TROUBLE, 0, "%s", err);

//CodeSeg 1:
      beg = lim;
    }
  while (beg < pat + psize);

  if ((err = kwsprep (kwset)) != NULL)
    error (EXIT_TROUBLE, 0, "%s", err);
}

EXECUTE_FCT(Fexecute)
{
  char const *beg, *try, *end, *mb_start;
  size_t len;
  char eol = eolbyte;
  struct kwsmatch kwsmatch;
  size_t ret_val;
#ifdef MBS_SUPPORT
  if (MB_CUR_MAX > 1)
    {
      if (match_icase)
        {
          char *case_buf = mbtolower (buf, &size);
	  if (start_ptr)
	    start_ptr = case_buf + (start_ptr - buf);
          buf = case_buf;
        }
    }
#endif /* MBS_SUPPORT */

  for (mb_start = beg = start_ptr ? start_ptr : buf; beg <= buf + size; beg++)
    {
      size_t offset = kwsexec (kwset, beg, buf + size - beg, &kwsmatch);
      if (offset == (size_t) -1)
	goto failure;
#ifdef MBS_SUPPORT
      if (MB_CUR_MAX > 1 && is_mb_middle (&mb_start, beg + offset, buf + size))
        {
          beg = mb_start - 1;
          continue; /* It is a part of multibyte character.  */
        }
#endif /* MBS_SUPPORT */
      beg += offset;
      len = kwsmatch.size[0];
      if (start_ptr && !match_words)
	goto success_in_beg_and_len;
      if (match_lines)
	{
	  if (beg > buf && beg[-1] != eol)
	    continue;
	  if (beg + len < buf + size && beg[len] != eol)
	    continue;
	  goto success;
	}
      else if (match_words)
	for (try = beg; len; )
	  {
	    if (try > buf && WCHAR((unsigned char) try[-1]))
	      break;
	    if (try + len < buf + size && WCHAR((unsigned char) try[len]))
	      {
		offset = kwsexec (kwset, beg, --len, &kwsmatch);
		if (offset == (size_t) -1)
		  break;
		try = beg + offset;
		len = kwsmatch.size[0];
	      }
	    else if (!start_ptr)
	      goto success;
	    else
	      goto success_in_beg_and_len;
	  } /* for (try) */
      else
	goto success;
    } /* for (beg in buf) */

 failure:
  ret_val = -1;
  goto out;

 success:
  if ((end = memchr (beg + len, eol, (buf + size) - (beg + len))) != NULL)
    end++;
  else
    end = buf + size;
  while (buf < beg && beg[-1] != eol)
    --beg;
  len = end - beg;
 success_in_beg_and_len:
  *match_size = len;
  ret_val = beg - buf;
 out:
  return ret_val;
}
#endif /* defined(GREP_PROGRAM) || defined(FGREP_PROGRAM) */

#ifdef GREP_PROGRAM
#if HAVE_LIBPCRE
/* Compiled internal form of a Perl regular expression.  */
static pcre *cre;

/* Additional information about the pattern.  */
static pcre_extra *extra;
#endif

COMPILE_FCT(Pcompile)
{
#if !HAVE_LIBPCRE
  error (EXIT_TROUBLE, 0, "%s",
	 _("support for the -P option is not compiled into "
	   "this --disable-perl-regexp binary"));
#else
  int e;
  char const *ep;
  char *re = xmalloc (4 * size + 7);
  int flags = PCRE_MULTILINE | (match_icase ? PCRE_CASELESS : 0);
  char const *patlim = pattern + size;
  char *n = re;
  char const *p;
  char const *pnul;

  /* FIXME: Remove these restrictions.  */
  if (memchr(pattern, '\n', size))
    error (EXIT_TROUBLE, 0, _("the -P option only supports a single pattern"));

  *n = '\0';
  if (match_lines)
    strcpy (n, "^(");
  if (match_words)
    strcpy (n, "\\b(");
  n += strlen (n);

  /* The PCRE interface doesn't allow NUL bytes in the pattern, so
     replace each NUL byte in the pattern with the four characters
     "\000", removing a preceding backslash if there are an odd
     number of backslashes before the NUL.

     FIXME: This method does not work with some multibyte character
     encodings, notably Shift-JIS, where a multibyte character can end
     in a backslash byte.  */
  for (p = pattern; (pnul = memchr (p, '\0', patlim - p)); p = pnul + 1)
    {
      memcpy (n, p, pnul - p);
      n += pnul - p;
      for (p = pnul; pattern < p && p[-1] == '\\'; p--)
	continue;
      n -= (pnul - p) & 1;
      strcpy (n, "\\000");
      n += 4;
    }

  memcpy (n, p, patlim - p);
  n += patlim - p;
  *n = '\0';
  if (match_words)
    strcpy (n, ")\\b");
  if (match_lines)
    strcpy (n, ")$");

  cre = pcre_compile (re, flags, &ep, &e, pcre_maketables ());
  if (!cre)
    error (EXIT_TROUBLE, 0, "%s", ep);

  extra = pcre_study (cre, 0, &ep);
  if (ep)
    error (EXIT_TROUBLE, 0, "%s", ep);

  free (re);
#endif
}

EXECUTE_FCT(Pexecute)
{
#if !HAVE_LIBPCRE
  abort ();
  return -1;
#else
  /* This array must have at least two elements; everything after that
     is just for performance improvement in pcre_exec.  */
  int sub[300];

  const char *line_buf, *line_end, *line_next;
  int e = PCRE_ERROR_NOMATCH;
  ptrdiff_t start_ofs = start_ptr ? start_ptr - buf : 0;

  /* PCRE can't limit the matching to single lines, therefore we have to
     match each line in the buffer separately.  */
  for (line_next = buf;
       e == PCRE_ERROR_NOMATCH && line_next < buf + size;
       start_ofs -= line_next - line_buf)
    {
      line_buf = line_next;
      line_end = memchr (line_buf, eolbyte, (buf + size) - line_buf);
      if (line_end == NULL)
        line_next = line_end = buf + size;
      else
        line_next = line_end + 1;

      if (start_ptr && start_ptr >= line_end)
        continue;

      e = pcre_exec (cre, extra, line_buf, line_end - line_buf,
                     start_ofs < 0 ? 0 : start_ofs, 0,
                     sub, sizeof sub / sizeof *sub);
    }

  if (e <= 0)
    {
      switch (e)
	{
	case PCRE_ERROR_NOMATCH:
	  return -1;

	case PCRE_ERROR_NOMEMORY:
	  error (EXIT_TROUBLE, 0, _("memory exhausted"));

	default:
	  abort ();
	}
    }
  else
    {
      /* Narrow down to the line we've found.  */
      char const *beg = line_buf + sub[0];
      char const *end = line_buf + sub[1];
      char const *buflim = buf + size;
      char eol = eolbyte;
      if (!start_ptr)
	{
	  /* FIXME: The case when '\n' is not found indicates a bug:
	     Since grep is line oriented, the match should never contain
	     a newline, so there _must_ be a newline following.
	   */
	  if (!(end = memchr (end, eol, buflim - end)))
	    end = buflim;
	  else
	    end++;
	  while (buf < beg && beg[-1] != eol)
	    --beg;
	}

      *match_size = end - beg;
      return beg - buf;
    }
#endif
}

struct matcher const matchers[] = {
  { "default", Gcompile, EGexecute },
  { "grep",    Gcompile, EGexecute },
  { "egrep",   Ecompile, EGexecute },
  { "awk",     Acompile, EGexecute },
  { "fgrep",   Fcompile, Fexecute },
  { "perl",    Pcompile, Pexecute },
  { "", 0, 0 },
};
#endif /* GREP_PROGRAM */

Trying a synthesis expr 1
Skipping a synthesis:1
Trying a synthesis expr err == 0
Building:src at:
/home/ubuntu/spr-fast/tests/corebench/grep/grep-case-deccad69-db9d6340/tempworkdir2/srcVerifing Negative cases!
Running test command:
/home/ubuntu/spr-fast/tools/grep-test.py /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-deccad69-db9d6340/tempworkdir2/src /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-deccad69-db9d6340/tempworkdir2/tests /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-deccad69-db9d6340/tempworkdir2 0  > __res
Verifying positive cases
Running test command:
/home/ubuntu/spr-fast/tools/grep-test.py /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-deccad69-db9d6340/tempworkdir2/src /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-deccad69-db9d6340/tempworkdir2/tests /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-deccad69-db9d6340/tempworkdir2 9  > __res
Failed positive case 9
Not passed!
Trying a synthesis expr match_icase == 0
Building:src at:
/home/ubuntu/spr-fast/tests/corebench/grep/grep-case-deccad69-db9d6340/tempworkdir2/srcVerifing Negative cases!
Running test command:
/home/ubuntu/spr-fast/tools/grep-test.py /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-deccad69-db9d6340/tempworkdir2/src /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-deccad69-db9d6340/tempworkdir2/tests /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-deccad69-db9d6340/tempworkdir2 0  > __res
Verifying positive cases
Running test command:
/home/ubuntu/spr-fast/tools/grep-test.py /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-deccad69-db9d6340/tempworkdir2/src /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-deccad69-db9d6340/tempworkdir2/tests /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-deccad69-db9d6340/tempworkdir2 9  > __res
Failed positive case 9
Not passed!
Trying a synthesis expr psize != 0
Building:src at:
/home/ubuntu/spr-fast/tests/corebench/grep/grep-case-deccad69-db9d6340/tempworkdir2/srcVerifing Negative cases!
Running test command:
/home/ubuntu/spr-fast/tools/grep-test.py /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-deccad69-db9d6340/tempworkdir2/src /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-deccad69-db9d6340/tempworkdir2/tests /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-deccad69-db9d6340/tempworkdir2 0  > __res
Verifying positive cases
Running test command:
/home/ubuntu/spr-fast/tools/grep-test.py /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-deccad69-db9d6340/tempworkdir2/src /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-deccad69-db9d6340/tempworkdir2/tests /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-deccad69-db9d6340/tempworkdir2 9  > __res
Failed positive case 9
Not passed!
Trying a synthesis expr size != 0
Building:src at:
/home/ubuntu/spr-fast/tests/corebench/grep/grep-case-deccad69-db9d6340/tempworkdir2/srcVerifing Negative cases!
Running test command:
/home/ubuntu/spr-fast/tools/grep-test.py /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-deccad69-db9d6340/tempworkdir2/src /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-deccad69-db9d6340/tempworkdir2/tests /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-deccad69-db9d6340/tempworkdir2 0  > __res
Verifying positive cases
Running test command:
/home/ubuntu/spr-fast/tools/grep-test.py /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-deccad69-db9d6340/tempworkdir2/src /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-deccad69-db9d6340/tempworkdir2/tests /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-deccad69-db9d6340/tempworkdir2 9  > __res
Failed positive case 9
Not passed!
Trying a synthesis expr psize == 2
Building:src at:
/home/ubuntu/spr-fast/tests/corebench/grep/grep-case-deccad69-db9d6340/tempworkdir2/srcVerifing Negative cases!
Running test command:
/home/ubuntu/spr-fast/tools/grep-test.py /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-deccad69-db9d6340/tempworkdir2/src /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-deccad69-db9d6340/tempworkdir2/tests /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-deccad69-db9d6340/tempworkdir2 0  > __res
Verifying positive cases
Running test command:
/home/ubuntu/spr-fast/tools/grep-test.py /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-deccad69-db9d6340/tempworkdir2/src /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-deccad69-db9d6340/tempworkdir2/tests /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-deccad69-db9d6340/tempworkdir2 9  > __res
Running test command:
/home/ubuntu/spr-fast/tools/grep-test.py /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-deccad69-db9d6340/tempworkdir2/src /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-deccad69-db9d6340/tempworkdir2/tests /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-deccad69-db9d6340/tempworkdir2 12  > __res
Failed positive case 12
Not passed!
Trying a synthesis expr size == 2
Building:src at:
/home/ubuntu/spr-fast/tests/corebench/grep/grep-case-deccad69-db9d6340/tempworkdir2/srcVerifing Negative cases!
Running test command:
/home/ubuntu/spr-fast/tools/grep-test.py /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-deccad69-db9d6340/tempworkdir2/src /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-deccad69-db9d6340/tempworkdir2/tests /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-deccad69-db9d6340/tempworkdir2 0  > __res
Verifying positive cases
Running test command:
/home/ubuntu/spr-fast/tools/grep-test.py /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-deccad69-db9d6340/tempworkdir2/src /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-deccad69-db9d6340/tempworkdir2/tests /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-deccad69-db9d6340/tempworkdir2 9  > __res
Running test command:
/home/ubuntu/spr-fast/tools/grep-test.py /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-deccad69-db9d6340/tempworkdir2/src /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-deccad69-db9d6340/tempworkdir2/tests /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-deccad69-db9d6340/tempworkdir2 12  > __res
Failed positive case 12
Not passed!
Trying a synthesis expr psize != 1
Building:src at:
/home/ubuntu/spr-fast/tests/corebench/grep/grep-case-deccad69-db9d6340/tempworkdir2/srcVerifing Negative cases!
Running test command:
/home/ubuntu/spr-fast/tools/grep-test.py /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-deccad69-db9d6340/tempworkdir2/src /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-deccad69-db9d6340/tempworkdir2/tests /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-deccad69-db9d6340/tempworkdir2 0  > __res
Verifying positive cases
Running test command:
/home/ubuntu/spr-fast/tools/grep-test.py /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-deccad69-db9d6340/tempworkdir2/src /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-deccad69-db9d6340/tempworkdir2/tests /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-deccad69-db9d6340/tempworkdir2 9  > __res
Failed positive case 9
Not passed!
Trying a synthesis expr psize != 4
Building:src at:
/home/ubuntu/spr-fast/tests/corebench/grep/grep-case-deccad69-db9d6340/tempworkdir2/srcVerifing Negative cases!
Running test command:
/home/ubuntu/spr-fast/tools/grep-test.py /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-deccad69-db9d6340/tempworkdir2/src /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-deccad69-db9d6340/tempworkdir2/tests /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-deccad69-db9d6340/tempworkdir2 0  > __res
Verifying positive cases
Running test command:
/home/ubuntu/spr-fast/tools/grep-test.py /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-deccad69-db9d6340/tempworkdir2/src /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-deccad69-db9d6340/tempworkdir2/tests /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-deccad69-db9d6340/tempworkdir2 9  > __res
Failed positive case 9
Not passed!
Trying a synthesis expr psize != 5
Building:src at:
/home/ubuntu/spr-fast/tests/corebench/grep/grep-case-deccad69-db9d6340/tempworkdir2/srcVerifing Negative cases!
Running test command:
/home/ubuntu/spr-fast/tools/grep-test.py /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-deccad69-db9d6340/tempworkdir2/src /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-deccad69-db9d6340/tempworkdir2/tests /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-deccad69-db9d6340/tempworkdir2 0  > __res
Verifying positive cases
Running test command:
/home/ubuntu/spr-fast/tools/grep-test.py /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-deccad69-db9d6340/tempworkdir2/src /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-deccad69-db9d6340/tempworkdir2/tests /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-deccad69-db9d6340/tempworkdir2 9  > __res
Failed positive case 9
Not passed!
Trying a synthesis expr psize != 6
Building:src at:
/home/ubuntu/spr-fast/tests/corebench/grep/grep-case-deccad69-db9d6340/tempworkdir2/srcVerifing Negative cases!
Running test command:
/home/ubuntu/spr-fast/tools/grep-test.py /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-deccad69-db9d6340/tempworkdir2/src /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-deccad69-db9d6340/tempworkdir2/tests /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-deccad69-db9d6340/tempworkdir2 0  > __res
Verifying positive cases
Running test command:
/home/ubuntu/spr-fast/tools/grep-test.py /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-deccad69-db9d6340/tempworkdir2/src /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-deccad69-db9d6340/tempworkdir2/tests /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-deccad69-db9d6340/tempworkdir2 9  > __res
Failed positive case 9
Not passed!
Trying a synthesis expr psize != 9
Building:src at:
/home/ubuntu/spr-fast/tests/corebench/grep/grep-case-deccad69-db9d6340/tempworkdir2/srcVerifing Negative cases!
Running test command:
/home/ubuntu/spr-fast/tools/grep-test.py /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-deccad69-db9d6340/tempworkdir2/src /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-deccad69-db9d6340/tempworkdir2/tests /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-deccad69-db9d6340/tempworkdir2 0  > __res
Verifying positive cases
Running test command:
/home/ubuntu/spr-fast/tools/grep-test.py /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-deccad69-db9d6340/tempworkdir2/src /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-deccad69-db9d6340/tempworkdir2/tests /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-deccad69-db9d6340/tempworkdir2 9  > __res
Failed positive case 9
Not passed!
Trying a synthesis expr match_icase != 1
Building:src at:
/home/ubuntu/spr-fast/tests/corebench/grep/grep-case-deccad69-db9d6340/tempworkdir2/srcVerifing Negative cases!
Running test command:
/home/ubuntu/spr-fast/tools/grep-test.py /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-deccad69-db9d6340/tempworkdir2/src /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-deccad69-db9d6340/tempworkdir2/tests /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-deccad69-db9d6340/tempworkdir2 0  > __res
Verifying positive cases
Running test command:
/home/ubuntu/spr-fast/tools/grep-test.py /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-deccad69-db9d6340/tempworkdir2/src /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-deccad69-db9d6340/tempworkdir2/tests /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-deccad69-db9d6340/tempworkdir2 9  > __res
Failed positive case 9
Not passed!
Trying a synthesis expr size != 1
Building:src at:
/home/ubuntu/spr-fast/tests/corebench/grep/grep-case-deccad69-db9d6340/tempworkdir2/srcVerifing Negative cases!
Running test command:
/home/ubuntu/spr-fast/tools/grep-test.py /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-deccad69-db9d6340/tempworkdir2/src /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-deccad69-db9d6340/tempworkdir2/tests /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-deccad69-db9d6340/tempworkdir2 0  > __res
Verifying positive cases
Running test command:
/home/ubuntu/spr-fast/tools/grep-test.py /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-deccad69-db9d6340/tempworkdir2/src /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-deccad69-db9d6340/tempworkdir2/tests /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-deccad69-db9d6340/tempworkdir2 9  > __res
Failed positive case 9
Not passed!
Trying a synthesis expr size != 4
Building:src at:
/home/ubuntu/spr-fast/tests/corebench/grep/grep-case-deccad69-db9d6340/tempworkdir2/srcVerifing Negative cases!
Running test command:
/home/ubuntu/spr-fast/tools/grep-test.py /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-deccad69-db9d6340/tempworkdir2/src /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-deccad69-db9d6340/tempworkdir2/tests /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-deccad69-db9d6340/tempworkdir2 0  > __res
Verifying positive cases
Running test command:
/home/ubuntu/spr-fast/tools/grep-test.py /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-deccad69-db9d6340/tempworkdir2/src /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-deccad69-db9d6340/tempworkdir2/tests /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-deccad69-db9d6340/tempworkdir2 9  > __res
Failed positive case 9
Not passed!
Trying a synthesis expr size != 5
Building:src at:
/home/ubuntu/spr-fast/tests/corebench/grep/grep-case-deccad69-db9d6340/tempworkdir2/srcVerifing Negative cases!
Running test command:
/home/ubuntu/spr-fast/tools/grep-test.py /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-deccad69-db9d6340/tempworkdir2/src /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-deccad69-db9d6340/tempworkdir2/tests /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-deccad69-db9d6340/tempworkdir2 0  > __res
Verifying positive cases
Running test command:
/home/ubuntu/spr-fast/tools/grep-test.py /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-deccad69-db9d6340/tempworkdir2/src /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-deccad69-db9d6340/tempworkdir2/tests /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-deccad69-db9d6340/tempworkdir2 9  > __res
Failed positive case 9
Not passed!
Trying a synthesis expr size != 6
Building:src at:
/home/ubuntu/spr-fast/tests/corebench/grep/grep-case-deccad69-db9d6340/tempworkdir2/srcVerifing Negative cases!
Running test command:
/home/ubuntu/spr-fast/tools/grep-test.py /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-deccad69-db9d6340/tempworkdir2/src /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-deccad69-db9d6340/tempworkdir2/tests /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-deccad69-db9d6340/tempworkdir2 0  > __res
Verifying positive cases
Running test command:
/home/ubuntu/spr-fast/tools/grep-test.py /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-deccad69-db9d6340/tempworkdir2/src /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-deccad69-db9d6340/tempworkdir2/tests /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-deccad69-db9d6340/tempworkdir2 9  > __res
Failed positive case 9
Not passed!
Trying a synthesis expr size != 9
Building:src at:
/home/ubuntu/spr-fast/tests/corebench/grep/grep-case-deccad69-db9d6340/tempworkdir2/srcVerifing Negative cases!
Running test command:
/home/ubuntu/spr-fast/tools/grep-test.py /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-deccad69-db9d6340/tempworkdir2/src /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-deccad69-db9d6340/tempworkdir2/tests /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-deccad69-db9d6340/tempworkdir2 0  > __res
Verifying positive cases
Running test command:
/home/ubuntu/spr-fast/tools/grep-test.py /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-deccad69-db9d6340/tempworkdir2/src /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-deccad69-db9d6340/tempworkdir2/tests /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-deccad69-db9d6340/tempworkdir2 9  > __res
Failed positive case 9
Not passed!
Initial synthesize failed, final attempt
Skipping two clauses!(1) &&(0)
Found a clause! ((err = kwsincr(kwset, beg, end - beg)) != ((void *)0)) 
Skipping a clause! ((err = kwsincr(kwset, beg, end - beg)) != ((void *)0)) 
Postprocessing failed!
a batched test job starts!
Building merged code:
src_file: src/search.c
full src: int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
/* search.c - searching subroutines using dfa, kwset and regex for grep.
   Copyright 1992, 1998, 2000, 2007, 2009-2010 Free Software Foundation, Inc.

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 3, or (at your option)
   any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program; if not, write to the Free Software
   Foundation, Inc., 51 Franklin Street - Fifth Floor, Boston, MA
   02110-1301, USA.  */

/* Written August 1992 by Mike Haertel. */

#include <config.h>

#include <sys/types.h>

#include "mbsupport.h"
#ifdef MBS_SUPPORT
/* We can handle multibyte strings. */
# include <wchar.h>
# include <wctype.h>
#endif

#include "system.h"
#include "grep.h"
#ifndef FGREP_PROGRAM
# include <regex.h>
# include "dfa.h"
#endif
#include "kwset.h"
#include "error.h"
#include "xalloc.h"
#ifdef HAVE_LIBPCRE
# include <pcre.h>
#endif

#define NCHAR (UCHAR_MAX + 1)

/* For -w, we also consider _ to be word constituent.  */
#define WCHAR(C) (ISALNUM(C) || (C) == '_')

/* KWset compiled pattern.  For Ecompile and Gcompile, we compile
   a list of strings, at least one of which is known to occur in
   any string matching the regexp. */
static kwset_t kwset;

static void
kwsinit (void)
{
  static char trans[NCHAR];
  int i;

  if (match_icase && MB_CUR_MAX == 1)
    {
      for (i = 0; i < NCHAR; ++i)
        trans[i] = TOLOWER (i);

      kwset = kwsalloc (trans);
    }
  else
    kwset = kwsalloc (NULL);

  if (!kwset)
    xalloc_die ();
}

#ifdef MBS_SUPPORT
/* Convert the *N-byte string, BEG, to lowercase, and write the
   NUL-terminated result into malloc'd storage.  Upon success, set *N
   to the length (in bytes) of the resulting string (not including the
   trailing NUL byte), and return a pointer to the lowercase string.
   Upon memory allocation failure, this function exits.

   Note that while this function returns a pointer to malloc'd storage,
   the caller must not free it, since this function retains a pointer
   to the buffer and reuses it on any subsequent call.  As a consequence,
   this function is not thread-safe.  */
static char *
mbtolower (const char *beg, size_t *n)
{
  static char *out;
  static size_t outalloc;
  size_t outlen, mb_cur_max;
  mbstate_t is, os;
  const char *end;
  char *p;

  if (*n > outalloc)
    {
      out = xrealloc (out, *n);
      outalloc = *n;
    }

  memset (&is, 0, sizeof (is));
  memset (&os, 0, sizeof (os));
  end = beg + *n;

  mb_cur_max = MB_CUR_MAX;
  p = out;
  outlen = 0;
  while (beg < end)
    {
      wchar_t wc;
      size_t mbclen = mbrtowc(&wc, beg, end - beg, &is);
      if (outlen + mb_cur_max >= outalloc)
        {
          out = x2nrealloc (out, &outalloc, 1);
          p = out + outlen;
        }

      if (mbclen == (size_t) -1 || mbclen == (size_t) -2 || mbclen == 0)
        {
          /* An invalid sequence, or a truncated multi-octet character.
             We treat it as a single-octet character.  */
          *p++ = *beg++;
          outlen++;
          memset (&is, 0, sizeof (is));
          memset (&os, 0, sizeof (os));
        }
      else
        {
          beg += mbclen;
          mbclen = wcrtomb (p, towlower ((wint_t) wc), &os);
          p += mbclen;
          outlen += mbclen;
        }
    }

  *n = p - out;
  *p++ = 0;
  return out;
}
#endif


#ifndef FGREP_PROGRAM
/* DFA compiled regexp. */
static struct dfa dfa;

/* The Regex compiled patterns.  */
static struct patterns
{
  /* Regex compiled regexp. */
  struct re_pattern_buffer regexbuf;
  struct re_registers regs; /* This is here on account of a BRAIN-DEAD
			       Q@#%!# library interface in regex.c.  */
} patterns0;

struct patterns *patterns;
size_t pcount;

void
dfaerror (char const *mesg)
{
  error (EXIT_TROUBLE, 0, "%s", mesg);
}

/* Number of compiled fixed strings known to exactly match the regexp.
   If kwsexec returns < kwset_exact_matches, then we don't need to
   call the regexp matcher at all. */
static int kwset_exact_matches;

static char const *
kwsincr_case (const char *must)
{
  const char *buf;
  size_t n;

  n = strlen (must);
#ifdef MBS_SUPPORT
  if (match_icase && MB_CUR_MAX > 1)
    buf = mbtolower (must, &n);
  else
#endif
    buf = must;
  return kwsincr (kwset, buf, n);
}

/* If the DFA turns out to have some set of fixed strings one of
   which must occur in the match, then we build a kwset matcher
   to find those strings, and thus quickly filter out impossible
   matches. */
static void
kwsmusts (void)
{
  struct dfamust const *dm;
  char const *err;

  if (dfa.musts)
    {
      kwsinit ();
      /* First, we compile in the substrings known to be exact
	 matches.  The kwset matcher will return the index
	 of the matching string that it chooses. */
      for (dm = dfa.musts; dm; dm = dm->next)
	{
	  if (!dm->exact)
	    continue;
	  ++kwset_exact_matches;
	  if ((err = kwsincr_case (dm->must)) != NULL)
	    error (EXIT_TROUBLE, 0, "%s", err);
	}
      /* Now, we compile the substrings that will require
	 the use of the regexp matcher.  */
      for (dm = dfa.musts; dm; dm = dm->next)
	{
	  if (dm->exact)
	    continue;
	  if ((err = kwsincr_case (dm->must)) != NULL)
	    error (EXIT_TROUBLE, 0, "%s", err);
	}
      if ((err = kwsprep (kwset)) != NULL)
	error (EXIT_TROUBLE, 0, "%s", err);
    }
}
#endif /* !FGREP_PROGRAM */

#ifdef MBS_SUPPORT

static bool
is_mb_middle(const char **good, const char *buf, const char *end)
{
  const char *p = *good;
  const char *prev = p;
  mbstate_t cur_state;

  /* TODO: can be optimized for UTF-8.  */
  memset(&cur_state, 0, sizeof(mbstate_t));
  while (p < buf)
    {
      size_t mbclen = mbrlen(p, end - p, &cur_state);

      /* Store the beginning of the previous complete multibyte character.  */
      if (mbclen != (size_t) -2)
        prev = p;

      if (mbclen == (size_t) -1 || mbclen == (size_t) -2 || mbclen == 0)
	{
	  /* An invalid sequence, or a truncated multibyte character.
	     We treat it as a single byte character.  */
	  mbclen = 1;
	}
      p += mbclen;
    }

  *good = prev;
  return p > buf;
}
#endif /* MBS_SUPPORT */

#if defined(GREP_PROGRAM) || defined(EGREP_PROGRAM)
#ifdef EGREP_PROGRAM
COMPILE_FCT(Ecompile)
{
  reg_syntax_t syntax_bits = RE_SYNTAX_POSIX_EGREP;
#else
/* No __VA_ARGS__ in C89.  So we have to do it this way.  */
static COMPILE_RET
GEAcompile (char const *pattern, size_t size, reg_syntax_t syntax_bits)
{
#endif /* EGREP_PROGRAM */
  const char *err;
  const char *p, *sep;
  size_t total = size;
  char *motif;

  if (match_icase)
    syntax_bits |= RE_ICASE;
  re_set_syntax (syntax_bits);
  dfasyntax (syntax_bits, match_icase, eolbyte);

  /* For GNU regex compiler we have to pass the patterns separately to detect
     errors like "[\nallo\n]\n".  The patterns here are "[", "allo" and "]"
     GNU regex should have raise a syntax error.  The same for backref, where
     the backref should have been local to each pattern.  */
  p = pattern;
  do
    {
      size_t len;
      sep = memchr (p, '\n', total);
      if (sep)
	{
	  len = sep - p;
	  sep++;
	  total -= (len + 1);
	}
      else
	{
	  len = total;
	  total = 0;
	}

      patterns = realloc (patterns, (pcount + 1) * sizeof (*patterns));
      if (patterns == NULL)
	error (EXIT_TROUBLE, errno, _("memory exhausted"));
      patterns[pcount] = patterns0;

      if ((err = re_compile_pattern (p, len,
				    &(patterns[pcount].regexbuf))) != NULL)
	error (EXIT_TROUBLE, 0, "%s", err);
      pcount++;

      p = sep;
    } while (sep && total != 0);

  /* In the match_words and match_lines cases, we use a different pattern
     for the DFA matcher that will quickly throw out cases that won't work.
     Then if DFA succeeds we do some hairy stuff using the regex matcher
     to decide whether the match should really count. */
  if (match_words || match_lines)
    {
      static char const line_beg_no_bk[] = "^(";
      static char const line_end_no_bk[] = ")$";
      static char const word_beg_no_bk[] = "(^|[^[:alnum:]_])(";
      static char const word_end_no_bk[] = ")([^[:alnum:]_]|$)";
#ifdef EGREP_PROGRAM
# define IF_BK(x, y) (y)
      char *n = xmalloc (sizeof word_beg_no_bk - 1 + size + sizeof word_end_no_bk);
#else
      static char const line_beg_bk[] = "^\\(";
      static char const line_end_bk[] = "\\)$";
      static char const word_beg_bk[] = "\\(^\\|[^[:alnum:]_]\\)\\(";
      static char const word_end_bk[] = "\\)\\([^[:alnum:]_]\\|$\\)";
      int bk = !(syntax_bits & RE_NO_BK_PARENS);
# define IF_BK(x, y) ((bk) ? (x) : (y))
      char *n = xmalloc (sizeof word_beg_bk - 1 + size + sizeof word_end_bk);
#endif /* EGREP_PROGRAM */

      strcpy (n, match_lines ? IF_BK(line_beg_bk, line_beg_no_bk)
			     : IF_BK(word_beg_bk, word_beg_no_bk));
      total = strlen(n);
      memcpy (n + total, pattern, size);
      total += size;
      strcpy (n + total, match_lines ? IF_BK(line_end_bk, line_end_no_bk)
				     : IF_BK(word_end_bk, word_end_no_bk));
      total += strlen (n + total);
      pattern = motif = n;
      size = total;
    }
  else
    motif = NULL;

  dfacomp (pattern, size, &dfa, 1);
  kwsmusts ();

  free(motif);
}

#ifndef EGREP_PROGRAM
COMPILE_FCT(Gcompile)
{
  return GEAcompile (pattern, size,
		     RE_SYNTAX_GREP | RE_HAT_LISTS_NOT_NEWLINE);
}

COMPILE_FCT(Acompile)
{
  return GEAcompile (pattern, size, RE_SYNTAX_AWK);
}

COMPILE_FCT(Ecompile)
{
  return GEAcompile (pattern, size, RE_SYNTAX_POSIX_EGREP);
}
#endif /* !EGREP_PROGRAM */

EXECUTE_FCT(EGexecute)
{
  char const *buflim, *beg, *end, *match, *best_match, *mb_start;
  char eol = eolbyte;
  int backref, start, len, best_len;
  struct kwsmatch kwsm;
  size_t i, ret_val;
#ifdef MBS_SUPPORT
  if (MB_CUR_MAX > 1)
    {
      if (match_icase)
        {
          /* mbtolower adds a NUL byte at the end.  That will provide
	     space for the sentinel byte dfaexec may add.  */
          char *case_buf = mbtolower (buf, &size);
	  if (start_ptr)
	    start_ptr = case_buf + (start_ptr - buf);
          buf = case_buf;
        }
    }
#endif /* MBS_SUPPORT */

  mb_start = buf;
  buflim = buf + size;

  for (beg = end = buf; end < buflim; beg = end)
    {
      if (!start_ptr)
	{
	  /* We don't care about an exact match.  */
	  if (kwset)
	    {
	      /* Find a possible match using the KWset matcher. */
	      size_t offset = kwsexec (kwset, beg, buflim - beg, &kwsm);
	      if (offset == (size_t) -1)
		goto failure;
	      beg += offset;
	      /* Narrow down to the line containing the candidate, and
		 run it through DFA. */
	      if ((end = memchr(beg, eol, buflim - beg)) != NULL)
	        end++;
              else
                end = buflim;
	      match = beg;
	      while (beg > buf && beg[-1] != eol)
		--beg;
	      if (kwsm.index < kwset_exact_matches)
                {
#ifdef MBS_SUPPORT
                  if (mb_start < beg)
                    mb_start = beg;
                  if (MB_CUR_MAX == 1 || !is_mb_middle (&mb_start, match, buflim))
#endif
                    goto success;
                }
	      if (dfaexec (&dfa, beg, (char *) end, 0, NULL, &backref) == NULL)
		continue;
	    }
	  else
	    {
	      /* No good fixed strings; start with DFA. */
	      char const *next_beg = dfaexec (&dfa, beg, (char *) buflim,
					      0, NULL, &backref);
	      if (next_beg == NULL)
		break;
	      /* Narrow down to the line we've found. */
	      beg = next_beg;
	      if ((end = memchr(beg, eol, buflim - beg)) != NULL)
	        end++;
              else
                end = buflim;
	      while (beg > buf && beg[-1] != eol)
		--beg;
	    }
	  /* Successful, no backreferences encountered! */
	  if (!backref)
	    goto success;
	}
      else
	{
	  /* We are looking for the leftmost (then longest) exact match.
	     We will go through the outer loop only once.  */
	  beg = start_ptr;
	  end = buflim;
	}

      /* If we've made it to this point, this means DFA has seen
	 a probable match, and we need to run it through Regex. */
      best_match = end;
      best_len = 0;
      for (i = 0; i < pcount; i++)
	{
	  patterns[i].regexbuf.not_eol = 0;
	  if (0 <= (start = re_search (&(patterns[i].regexbuf),
				       buf, end - buf - 1,
				       beg - buf, end - beg - 1,
				       &(patterns[i].regs))))
	    {
	      len = patterns[i].regs.end[0] - start;
	      match = buf + start;
	      if (match > best_match)
		continue;
	      if (start_ptr && !match_words)
		goto assess_pattern_match;
	      if ((!match_lines && !match_words)
		  || (match_lines && len == end - beg - 1))
		{
		  match = beg;
		  len = end - beg;
		  goto assess_pattern_match;
		}
	      /* If -w, check if the match aligns with word boundaries.
		 We do this iteratively because:
		 (a) the line may contain more than one occurence of the
		 pattern, and
		 (b) Several alternatives in the pattern might be valid at a
		 given point, and we may need to consider a shorter one to
		 find a word boundary.  */
	      if (match_words)
		while (match <= best_match)
		  {
		    if ((match == buf || !WCHAR ((unsigned char) match[-1]))
			&& (len == end - beg - 1
			    || !WCHAR ((unsigned char) match[len])))
		      goto assess_pattern_match;
		    if (len > 0)
		      {
			/* Try a shorter length anchored at the same place. */
			--len;
			patterns[i].regexbuf.not_eol = 1;
			len = re_match (&(patterns[i].regexbuf),
					buf, match + len - beg, match - buf,
					&(patterns[i].regs));
		      }
		    if (len <= 0)
		      {
			/* Try looking further on. */
			if (match == end - 1)
			  break;
			match++;
			patterns[i].regexbuf.not_eol = 0;
			start = re_search (&(patterns[i].regexbuf),
					   buf, end - buf - 1,
					   match - buf, end - match - 1,
					   &(patterns[i].regs));
			if (start < 0)
			  break;
			len = patterns[i].regs.end[0] - start;
			match = buf + start;
		      }
		  } /* while (match <= best_match) */
	      continue;
	    assess_pattern_match:
	      if (!start_ptr)
		{
		  /* Good enough for a non-exact match.
		     No need to look at further patterns, if any.  */
		  beg = match;
		  goto success_in_len;
		}
	      if (match < best_match || (match == best_match && len > best_len))
		{
		  /* Best exact match:  leftmost, then longest.  */
		  best_match = match;
		  best_len = len;
		}
	    } /* if re_search >= 0 */
	} /* for Regex patterns.  */
	if (best_match < end)
	  {
	    /* We have found an exact match.  We were just
	       waiting for the best one (leftmost then longest).  */
	    beg = best_match;
	    len = best_len;
	    goto success_in_len;
	  }
    } /* for (beg = end ..) */

 failure:
  ret_val = -1;
  goto out;

 success:
  len = end - beg;
 success_in_len:
  *match_size = len;
  ret_val = beg - buf;
 out:
  return ret_val;
}
#endif /* defined(GREP_PROGRAM) || defined(EGREP_PROGRAM) */

#if defined(GREP_PROGRAM) || defined(FGREP_PROGRAM)
COMPILE_FCT(Fcompile)
{
  char const *beg, *end, *lim, *err, *pat;
  size_t psize;

  kwsinit ();
  psize = size;
  if (match_icase && MB_CUR_MAX > 1)
    pat = mbtolower (pattern, &psize);
  else
    pat = pattern;

  beg = pat;
  do
    {
      for (lim = beg;; ++lim)
	{
	  end = lim;
	  if (lim >= pat + psize)
	    break;
	 if (*lim == '\n')
	   {
	     lim++;
	     break;
	   }
#if HAVE_DOS_FILE_CONTENTS
	 if (*lim == '\r' && lim + 1 < pat + psize && lim[1] == '\n')
	   {
	     lim += 2;
	     break;
	   }
#endif
	}

      if ((err = kwsincr (kwset, beg, end - beg)) != NULL)
	error (EXIT_TROUBLE, 0, "%s", err);
      beg = lim;
    }
  while (beg < pat + psize);

  //prophet generated patch
  if (__get_mutant()==0) {
  if (((err = kwsprep(kwset)) != ((void *)0)) && !(__is_neg(10, &(err), sizeof (err), &(kwset), sizeof (kwset), &(beg), sizeof (beg), &(pat), sizeof (pat), &(psize), sizeof (psize), &(lim), sizeof (lim), &(end), sizeof (end), &(pattern), sizeof (pattern), &(match_icase), sizeof (match_icase), &(size), sizeof (size))))
      error(EXIT_TROUBLE, 0, "%s", err);
  }
  else if (__get_mutant()==1) {
  if (((err = kwsprep(kwset)) != ((void *)0)) || (__is_neg(10, &(err), sizeof (err), &(kwset), sizeof (kwset), &(beg), sizeof (beg), &(pat), sizeof (pat), &(psize), sizeof (psize), &(lim), sizeof (lim), &(end), sizeof (end), &(pattern), sizeof (pattern), &(match_icase), sizeof (match_icase), &(size), sizeof (size))))
      error(EXIT_TROUBLE, 0, "%s", err);
  }
}

EXECUTE_FCT(Fexecute)
{
  char const *beg, *try, *end, *mb_start;
  size_t len;
  char eol = eolbyte;
  struct kwsmatch kwsmatch;
  size_t ret_val;
#ifdef MBS_SUPPORT
  if (MB_CUR_MAX > 1)
    {
      if (match_icase)
        {
          char *case_buf = mbtolower (buf, &size);
	  if (start_ptr)
	    start_ptr = case_buf + (start_ptr - buf);
          buf = case_buf;
        }
    }
#endif /* MBS_SUPPORT */

  for (mb_start = beg = start_ptr ? start_ptr : buf; beg <= buf + size; beg++)
    {
      size_t offset = kwsexec (kwset, beg, buf + size - beg, &kwsmatch);
      if (offset == (size_t) -1)
	goto failure;
#ifdef MBS_SUPPORT
      if (MB_CUR_MAX > 1 && is_mb_middle (&mb_start, beg + offset, buf + size))
        {
          beg = mb_start - 1;
          continue; /* It is a part of multibyte character.  */
        }
#endif /* MBS_SUPPORT */
      beg += offset;
      len = kwsmatch.size[0];
      if (start_ptr && !match_words)
	goto success_in_beg_and_len;
      if (match_lines)
	{
	  if (beg > buf && beg[-1] != eol)
	    continue;
	  if (beg + len < buf + size && beg[len] != eol)
	    continue;
	  goto success;
	}
      else if (match_words)
	for (try = beg; len; )
	  {
	    if (try > buf && WCHAR((unsigned char) try[-1]))
	      break;
	    if (try + len < buf + size && WCHAR((unsigned char) try[len]))
	      {
		offset = kwsexec (kwset, beg, --len, &kwsmatch);
		if (offset == (size_t) -1)
		  break;
		try = beg + offset;
		len = kwsmatch.size[0];
	      }
	    else if (!start_ptr)
	      goto success;
	    else
	      goto success_in_beg_and_len;
	  } /* for (try) */
      else
	goto success;
    } /* for (beg in buf) */

 failure:
  ret_val = -1;
  goto out;

 success:
  if ((end = memchr (beg + len, eol, (buf + size) - (beg + len))) != NULL)
    end++;
  else
    end = buf + size;
  while (buf < beg && beg[-1] != eol)
    --beg;
  len = end - beg;
 success_in_beg_and_len:
  *match_size = len;
  ret_val = beg - buf;
 out:
  return ret_val;
}
#endif /* defined(GREP_PROGRAM) || defined(FGREP_PROGRAM) */

#ifdef GREP_PROGRAM
#if HAVE_LIBPCRE
/* Compiled internal form of a Perl regular expression.  */
static pcre *cre;

/* Additional information about the pattern.  */
static pcre_extra *extra;
#endif

COMPILE_FCT(Pcompile)
{
#if !HAVE_LIBPCRE
  error (EXIT_TROUBLE, 0, "%s",
	 _("support for the -P option is not compiled into "
	   "this --disable-perl-regexp binary"));
#else
  int e;
  char const *ep;
  char *re = xmalloc (4 * size + 7);
  int flags = PCRE_MULTILINE | (match_icase ? PCRE_CASELESS : 0);
  char const *patlim = pattern + size;
  char *n = re;
  char const *p;
  char const *pnul;

  /* FIXME: Remove these restrictions.  */
  if (memchr(pattern, '\n', size))
    error (EXIT_TROUBLE, 0, _("the -P option only supports a single pattern"));

  *n = '\0';
  if (match_lines)
    strcpy (n, "^(");
  if (match_words)
    strcpy (n, "\\b(");
  n += strlen (n);

  /* The PCRE interface doesn't allow NUL bytes in the pattern, so
     replace each NUL byte in the pattern with the four characters
     "\000", removing a preceding backslash if there are an odd
     number of backslashes before the NUL.

     FIXME: This method does not work with some multibyte character
     encodings, notably Shift-JIS, where a multibyte character can end
     in a backslash byte.  */
  for (p = pattern; (pnul = memchr (p, '\0', patlim - p)); p = pnul + 1)
    {
      memcpy (n, p, pnul - p);
      n += pnul - p;
      for (p = pnul; pattern < p && p[-1] == '\\'; p--)
	continue;
      n -= (pnul - p) & 1;
      strcpy (n, "\\000");
      n += 4;
    }

  memcpy (n, p, patlim - p);
  n += patlim - p;
  *n = '\0';
  if (match_words)
    strcpy (n, ")\\b");
  if (match_lines)
    strcpy (n, ")$");

  cre = pcre_compile (re, flags, &ep, &e, pcre_maketables ());
  if (!cre)
    error (EXIT_TROUBLE, 0, "%s", ep);

  extra = pcre_study (cre, 0, &ep);
  if (ep)
    error (EXIT_TROUBLE, 0, "%s", ep);

  free (re);
#endif
}

EXECUTE_FCT(Pexecute)
{
#if !HAVE_LIBPCRE
  abort ();
  return -1;
#else
  /* This array must have at least two elements; everything after that
     is just for performance improvement in pcre_exec.  */
  int sub[300];

  const char *line_buf, *line_end, *line_next;
  int e = PCRE_ERROR_NOMATCH;
  ptrdiff_t start_ofs = start_ptr ? start_ptr - buf : 0;

  /* PCRE can't limit the matching to single lines, therefore we have to
     match each line in the buffer separately.  */
  for (line_next = buf;
       e == PCRE_ERROR_NOMATCH && line_next < buf + size;
       start_ofs -= line_next - line_buf)
    {
      line_buf = line_next;
      line_end = memchr (line_buf, eolbyte, (buf + size) - line_buf);
      if (line_end == NULL)
        line_next = line_end = buf + size;
      else
        line_next = line_end + 1;

      if (start_ptr && start_ptr >= line_end)
        continue;

      e = pcre_exec (cre, extra, line_buf, line_end - line_buf,
                     start_ofs < 0 ? 0 : start_ofs, 0,
                     sub, sizeof sub / sizeof *sub);
    }

  if (e <= 0)
    {
      switch (e)
	{
	case PCRE_ERROR_NOMATCH:
	  return -1;

	case PCRE_ERROR_NOMEMORY:
	  error (EXIT_TROUBLE, 0, _("memory exhausted"));

	default:
	  abort ();
	}
    }
  else
    {
      /* Narrow down to the line we've found.  */
      char const *beg = line_buf + sub[0];
      char const *end = line_buf + sub[1];
      char const *buflim = buf + size;
      char eol = eolbyte;
      if (!start_ptr)
	{
	  /* FIXME: The case when '\n' is not found indicates a bug:
	     Since grep is line oriented, the match should never contain
	     a newline, so there _must_ be a newline following.
	   */
	  if (!(end = memchr (end, eol, buflim - end)))
	    end = buflim;
	  else
	    end++;
	  while (buf < beg && beg[-1] != eol)
	    --beg;
	}

      *match_size = end - beg;
      return beg - buf;
    }
#endif
}

struct matcher const matchers[] = {
  { "default", Gcompile, EGexecute },
  { "grep",    Gcompile, EGexecute },
  { "egrep",   Ecompile, EGexecute },
  { "awk",     Acompile, EGexecute },
  { "fgrep",   Fcompile, Fexecute },
  { "perl",    Pcompile, Pexecute },
  { "", 0, 0 },
};
#endif /* GREP_PROGRAM */

Building:src at:
/home/ubuntu/spr-fast/tests/corebench/grep/grep-case-deccad69-db9d6340/tempworkdir2/srcMerged code building succ, going to invoke tester!
CondTester, Testing instance id 9:
//src_file:src/search.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
/* search.c - searching subroutines using dfa, kwset and regex for grep.
   Copyright 1992, 1998, 2000, 2007, 2009-2010 Free Software Foundation, Inc.

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 3, or (at your option)
   any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program; if not, write to the Free Software
   Foundation, Inc., 51 Franklin Street - Fifth Floor, Boston, MA
   02110-1301, USA.  */

/* Written August 1992 by Mike Haertel. */

#include <config.h>

#include <sys/types.h>

#include "mbsupport.h"
#ifdef MBS_SUPPORT
/* We can handle multibyte strings. */
# include <wchar.h>
# include <wctype.h>
#endif

#include "system.h"
#include "grep.h"
#ifndef FGREP_PROGRAM
# include <regex.h>
# include "dfa.h"
#endif
#include "kwset.h"
#include "error.h"
#include "xalloc.h"
#ifdef HAVE_LIBPCRE
# include <pcre.h>
#endif

#define NCHAR (UCHAR_MAX + 1)

/* For -w, we also consider _ to be word constituent.  */
#define WCHAR(C) (ISALNUM(C) || (C) == '_')

/* KWset compiled pattern.  For Ecompile and Gcompile, we compile
   a list of strings, at least one of which is known to occur in
   any string matching the regexp. */
static kwset_t kwset;

static void
kwsinit (void)
{
  static char trans[NCHAR];
  int i;

  if (match_icase && MB_CUR_MAX == 1)
    {
      for (i = 0; i < NCHAR; ++i)
        trans[i] = TOLOWER (i);

      kwset = kwsalloc (trans);
    }
  else
    kwset = kwsalloc (NULL);

  if (!kwset)
    xalloc_die ();
}

#ifdef MBS_SUPPORT
/* Convert the *N-byte string, BEG, to lowercase, and write the
   NUL-terminated result into malloc'd storage.  Upon success, set *N
   to the length (in bytes) of the resulting string (not including the
   trailing NUL byte), and return a pointer to the lowercase string.
   Upon memory allocation failure, this function exits.

   Note that while this function returns a pointer to malloc'd storage,
   the caller must not free it, since this function retains a pointer
   to the buffer and reuses it on any subsequent call.  As a consequence,
   this function is not thread-safe.  */
static char *
mbtolower (const char *beg, size_t *n)
{
  static char *out;
  static size_t outalloc;
  size_t outlen, mb_cur_max;
  mbstate_t is, os;
  const char *end;
  char *p;

  if (*n > outalloc)
    {
      out = xrealloc (out, *n);
      outalloc = *n;
    }

  memset (&is, 0, sizeof (is));
  memset (&os, 0, sizeof (os));
  end = beg + *n;

  mb_cur_max = MB_CUR_MAX;
  p = out;
  outlen = 0;
  while (beg < end)
    {
      wchar_t wc;
      size_t mbclen = mbrtowc(&wc, beg, end - beg, &is);
      if (outlen + mb_cur_max >= outalloc)
        {
          out = x2nrealloc (out, &outalloc, 1);
          p = out + outlen;
        }

      if (mbclen == (size_t) -1 || mbclen == (size_t) -2 || mbclen == 0)
        {
          /* An invalid sequence, or a truncated multi-octet character.
             We treat it as a single-octet character.  */
          *p++ = *beg++;
          outlen++;
          memset (&is, 0, sizeof (is));
          memset (&os, 0, sizeof (os));
        }
      else
        {
          beg += mbclen;
          mbclen = wcrtomb (p, towlower ((wint_t) wc), &os);
          p += mbclen;
          outlen += mbclen;
        }
    }

  *n = p - out;
  *p++ = 0;
  return out;
}
#endif


#ifndef FGREP_PROGRAM
/* DFA compiled regexp. */
static struct dfa dfa;

/* The Regex compiled patterns.  */
static struct patterns
{
  /* Regex compiled regexp. */
  struct re_pattern_buffer regexbuf;
  struct re_registers regs; /* This is here on account of a BRAIN-DEAD
			       Q@#%!# library interface in regex.c.  */
} patterns0;

struct patterns *patterns;
size_t pcount;

void
dfaerror (char const *mesg)
{
  error (EXIT_TROUBLE, 0, "%s", mesg);
}

/* Number of compiled fixed strings known to exactly match the regexp.
   If kwsexec returns < kwset_exact_matches, then we don't need to
   call the regexp matcher at all. */
static int kwset_exact_matches;

static char const *
kwsincr_case (const char *must)
{
  const char *buf;
  size_t n;

  n = strlen (must);
#ifdef MBS_SUPPORT
  if (match_icase && MB_CUR_MAX > 1)
    buf = mbtolower (must, &n);
  else
#endif
    buf = must;
  return kwsincr (kwset, buf, n);
}

/* If the DFA turns out to have some set of fixed strings one of
   which must occur in the match, then we build a kwset matcher
   to find those strings, and thus quickly filter out impossible
   matches. */
static void
kwsmusts (void)
{
  struct dfamust const *dm;
  char const *err;

  if (dfa.musts)
    {
      kwsinit ();
      /* First, we compile in the substrings known to be exact
	 matches.  The kwset matcher will return the index
	 of the matching string that it chooses. */
      for (dm = dfa.musts; dm; dm = dm->next)
	{
	  if (!dm->exact)
	    continue;
	  ++kwset_exact_matches;
	  if ((err = kwsincr_case (dm->must)) != NULL)
	    error (EXIT_TROUBLE, 0, "%s", err);
	}
      /* Now, we compile the substrings that will require
	 the use of the regexp matcher.  */
      for (dm = dfa.musts; dm; dm = dm->next)
	{
	  if (dm->exact)
	    continue;
	  if ((err = kwsincr_case (dm->must)) != NULL)
	    error (EXIT_TROUBLE, 0, "%s", err);
	}
      if ((err = kwsprep (kwset)) != NULL)
	error (EXIT_TROUBLE, 0, "%s", err);
    }
}
#endif /* !FGREP_PROGRAM */

#ifdef MBS_SUPPORT

static bool
is_mb_middle(const char **good, const char *buf, const char *end)
{
  const char *p = *good;
  const char *prev = p;
  mbstate_t cur_state;

  /* TODO: can be optimized for UTF-8.  */
  memset(&cur_state, 0, sizeof(mbstate_t));
  while (p < buf)
    {
      size_t mbclen = mbrlen(p, end - p, &cur_state);

      /* Store the beginning of the previous complete multibyte character.  */
      if (mbclen != (size_t) -2)
        prev = p;

      if (mbclen == (size_t) -1 || mbclen == (size_t) -2 || mbclen == 0)
	{
	  /* An invalid sequence, or a truncated multibyte character.
	     We treat it as a single byte character.  */
	  mbclen = 1;
	}
      p += mbclen;
    }

  *good = prev;
  return p > buf;
}
#endif /* MBS_SUPPORT */

#if defined(GREP_PROGRAM) || defined(EGREP_PROGRAM)
#ifdef EGREP_PROGRAM
COMPILE_FCT(Ecompile)
{
  reg_syntax_t syntax_bits = RE_SYNTAX_POSIX_EGREP;
#else
/* No __VA_ARGS__ in C89.  So we have to do it this way.  */
static COMPILE_RET
GEAcompile (char const *pattern, size_t size, reg_syntax_t syntax_bits)
{
#endif /* EGREP_PROGRAM */
  const char *err;
  const char *p, *sep;
  size_t total = size;
  char *motif;

  if (match_icase)
    syntax_bits |= RE_ICASE;
  re_set_syntax (syntax_bits);
  dfasyntax (syntax_bits, match_icase, eolbyte);

  /* For GNU regex compiler we have to pass the patterns separately to detect
     errors like "[\nallo\n]\n".  The patterns here are "[", "allo" and "]"
     GNU regex should have raise a syntax error.  The same for backref, where
     the backref should have been local to each pattern.  */
  p = pattern;
  do
    {
      size_t len;
      sep = memchr (p, '\n', total);
      if (sep)
	{
	  len = sep - p;
	  sep++;
	  total -= (len + 1);
	}
      else
	{
	  len = total;
	  total = 0;
	}

      patterns = realloc (patterns, (pcount + 1) * sizeof (*patterns));
      if (patterns == NULL)
	error (EXIT_TROUBLE, errno, _("memory exhausted"));
      patterns[pcount] = patterns0;

      if ((err = re_compile_pattern (p, len,
				    &(patterns[pcount].regexbuf))) != NULL)
	error (EXIT_TROUBLE, 0, "%s", err);
      pcount++;

      p = sep;
    } while (sep && total != 0);

  /* In the match_words and match_lines cases, we use a different pattern
     for the DFA matcher that will quickly throw out cases that won't work.
     Then if DFA succeeds we do some hairy stuff using the regex matcher
     to decide whether the match should really count. */
  if (match_words || match_lines)
    {
      static char const line_beg_no_bk[] = "^(";
      static char const line_end_no_bk[] = ")$";
      static char const word_beg_no_bk[] = "(^|[^[:alnum:]_])(";
      static char const word_end_no_bk[] = ")([^[:alnum:]_]|$)";
#ifdef EGREP_PROGRAM
# define IF_BK(x, y) (y)
      char *n = xmalloc (sizeof word_beg_no_bk - 1 + size + sizeof word_end_no_bk);
#else
      static char const line_beg_bk[] = "^\\(";
      static char const line_end_bk[] = "\\)$";
      static char const word_beg_bk[] = "\\(^\\|[^[:alnum:]_]\\)\\(";
      static char const word_end_bk[] = "\\)\\([^[:alnum:]_]\\|$\\)";
      int bk = !(syntax_bits & RE_NO_BK_PARENS);
# define IF_BK(x, y) ((bk) ? (x) : (y))
      char *n = xmalloc (sizeof word_beg_bk - 1 + size + sizeof word_end_bk);
#endif /* EGREP_PROGRAM */

      strcpy (n, match_lines ? IF_BK(line_beg_bk, line_beg_no_bk)
			     : IF_BK(word_beg_bk, word_beg_no_bk));
      total = strlen(n);
      memcpy (n + total, pattern, size);
      total += size;
      strcpy (n + total, match_lines ? IF_BK(line_end_bk, line_end_no_bk)
				     : IF_BK(word_end_bk, word_end_no_bk));
      total += strlen (n + total);
      pattern = motif = n;
      size = total;
    }
  else
    motif = NULL;

  dfacomp (pattern, size, &dfa, 1);
  kwsmusts ();

  free(motif);
}

#ifndef EGREP_PROGRAM
COMPILE_FCT(Gcompile)
{
  return GEAcompile (pattern, size,
		     RE_SYNTAX_GREP | RE_HAT_LISTS_NOT_NEWLINE);
}

COMPILE_FCT(Acompile)
{
  return GEAcompile (pattern, size, RE_SYNTAX_AWK);
}

COMPILE_FCT(Ecompile)
{
  return GEAcompile (pattern, size, RE_SYNTAX_POSIX_EGREP);
}
#endif /* !EGREP_PROGRAM */

EXECUTE_FCT(EGexecute)
{
  char const *buflim, *beg, *end, *match, *best_match, *mb_start;
  char eol = eolbyte;
  int backref, start, len, best_len;
  struct kwsmatch kwsm;
  size_t i, ret_val;
#ifdef MBS_SUPPORT
  if (MB_CUR_MAX > 1)
    {
      if (match_icase)
        {
          /* mbtolower adds a NUL byte at the end.  That will provide
	     space for the sentinel byte dfaexec may add.  */
          char *case_buf = mbtolower (buf, &size);
	  if (start_ptr)
	    start_ptr = case_buf + (start_ptr - buf);
          buf = case_buf;
        }
    }
#endif /* MBS_SUPPORT */

  mb_start = buf;
  buflim = buf + size;

  for (beg = end = buf; end < buflim; beg = end)
    {
      if (!start_ptr)
	{
	  /* We don't care about an exact match.  */
	  if (kwset)
	    {
	      /* Find a possible match using the KWset matcher. */
	      size_t offset = kwsexec (kwset, beg, buflim - beg, &kwsm);
	      if (offset == (size_t) -1)
		goto failure;
	      beg += offset;
	      /* Narrow down to the line containing the candidate, and
		 run it through DFA. */
	      if ((end = memchr(beg, eol, buflim - beg)) != NULL)
	        end++;
              else
                end = buflim;
	      match = beg;
	      while (beg > buf && beg[-1] != eol)
		--beg;
	      if (kwsm.index < kwset_exact_matches)
                {
#ifdef MBS_SUPPORT
                  if (mb_start < beg)
                    mb_start = beg;
                  if (MB_CUR_MAX == 1 || !is_mb_middle (&mb_start, match, buflim))
#endif
                    goto success;
                }
	      if (dfaexec (&dfa, beg, (char *) end, 0, NULL, &backref) == NULL)
		continue;
	    }
	  else
	    {
	      /* No good fixed strings; start with DFA. */
	      char const *next_beg = dfaexec (&dfa, beg, (char *) buflim,
					      0, NULL, &backref);
	      if (next_beg == NULL)
		break;
	      /* Narrow down to the line we've found. */
	      beg = next_beg;
	      if ((end = memchr(beg, eol, buflim - beg)) != NULL)
	        end++;
              else
                end = buflim;
	      while (beg > buf && beg[-1] != eol)
		--beg;
	    }
	  /* Successful, no backreferences encountered! */
	  if (!backref)
	    goto success;
	}
      else
	{
	  /* We are looking for the leftmost (then longest) exact match.
	     We will go through the outer loop only once.  */
	  beg = start_ptr;
	  end = buflim;
	}

      /* If we've made it to this point, this means DFA has seen
	 a probable match, and we need to run it through Regex. */
      best_match = end;
      best_len = 0;
      for (i = 0; i < pcount; i++)
	{
	  patterns[i].regexbuf.not_eol = 0;
	  if (0 <= (start = re_search (&(patterns[i].regexbuf),
				       buf, end - buf - 1,
				       beg - buf, end - beg - 1,
				       &(patterns[i].regs))))
	    {
	      len = patterns[i].regs.end[0] - start;
	      match = buf + start;
	      if (match > best_match)
		continue;
	      if (start_ptr && !match_words)
		goto assess_pattern_match;
	      if ((!match_lines && !match_words)
		  || (match_lines && len == end - beg - 1))
		{
		  match = beg;
		  len = end - beg;
		  goto assess_pattern_match;
		}
	      /* If -w, check if the match aligns with word boundaries.
		 We do this iteratively because:
		 (a) the line may contain more than one occurence of the
		 pattern, and
		 (b) Several alternatives in the pattern might be valid at a
		 given point, and we may need to consider a shorter one to
		 find a word boundary.  */
	      if (match_words)
		while (match <= best_match)
		  {
		    if ((match == buf || !WCHAR ((unsigned char) match[-1]))
			&& (len == end - beg - 1
			    || !WCHAR ((unsigned char) match[len])))
		      goto assess_pattern_match;
		    if (len > 0)
		      {
			/* Try a shorter length anchored at the same place. */
			--len;
			patterns[i].regexbuf.not_eol = 1;
			len = re_match (&(patterns[i].regexbuf),
					buf, match + len - beg, match - buf,
					&(patterns[i].regs));
		      }
		    if (len <= 0)
		      {
			/* Try looking further on. */
			if (match == end - 1)
			  break;
			match++;
			patterns[i].regexbuf.not_eol = 0;
			start = re_search (&(patterns[i].regexbuf),
					   buf, end - buf - 1,
					   match - buf, end - match - 1,
					   &(patterns[i].regs));
			if (start < 0)
			  break;
			len = patterns[i].regs.end[0] - start;
			match = buf + start;
		      }
		  } /* while (match <= best_match) */
	      continue;
	    assess_pattern_match:
	      if (!start_ptr)
		{
		  /* Good enough for a non-exact match.
		     No need to look at further patterns, if any.  */
		  beg = match;
		  goto success_in_len;
		}
	      if (match < best_match || (match == best_match && len > best_len))
		{
		  /* Best exact match:  leftmost, then longest.  */
		  best_match = match;
		  best_len = len;
		}
	    } /* if re_search >= 0 */
	} /* for Regex patterns.  */
	if (best_match < end)
	  {
	    /* We have found an exact match.  We were just
	       waiting for the best one (leftmost then longest).  */
	    beg = best_match;
	    len = best_len;
	    goto success_in_len;
	  }
    } /* for (beg = end ..) */

 failure:
  ret_val = -1;
  goto out;

 success:
  len = end - beg;
 success_in_len:
  *match_size = len;
  ret_val = beg - buf;
 out:
  return ret_val;
}
#endif /* defined(GREP_PROGRAM) || defined(EGREP_PROGRAM) */

#if defined(GREP_PROGRAM) || defined(FGREP_PROGRAM)
COMPILE_FCT(Fcompile)
{
  char const *beg, *end, *lim, *err, *pat;
  size_t psize;

  kwsinit ();
  psize = size;
  if (match_icase && MB_CUR_MAX > 1)
    pat = mbtolower (pattern, &psize);
  else
    pat = pattern;

  beg = pat;
  do
    {
      for (lim = beg;; ++lim)
	{
	  end = lim;
	  if (lim >= pat + psize)
	    break;
	 if (*lim == '\n')
	   {
	     lim++;
	     break;
	   }
#if HAVE_DOS_FILE_CONTENTS
	 if (*lim == '\r' && lim + 1 < pat + psize && lim[1] == '\n')
	   {
	     lim += 2;
	     break;
	   }
#endif
	}

      if ((err = kwsincr (kwset, beg, end - beg)) != NULL)
	error (EXIT_TROUBLE, 0, "%s", err);
      beg = lim;
    }
  while (beg < pat + psize);

  
//Patch 0:
if (((err = kwsprep(kwset)) != ((void *)0)) && !(__is_neg(10, &(err), sizeof (err), &(kwset), sizeof (kwset), &(beg), sizeof (beg), &(pat), sizeof (pat), &(psize), sizeof (psize), &(lim), sizeof (lim), &(end), sizeof (end), &(pattern), sizeof (pattern), &(match_icase), sizeof (match_icase), &(size), sizeof (size))))
    error(EXIT_TROUBLE, 0, "%s", err);

//CodeSeg 1:
}

EXECUTE_FCT(Fexecute)
{
  char const *beg, *try, *end, *mb_start;
  size_t len;
  char eol = eolbyte;
  struct kwsmatch kwsmatch;
  size_t ret_val;
#ifdef MBS_SUPPORT
  if (MB_CUR_MAX > 1)
    {
      if (match_icase)
        {
          char *case_buf = mbtolower (buf, &size);
	  if (start_ptr)
	    start_ptr = case_buf + (start_ptr - buf);
          buf = case_buf;
        }
    }
#endif /* MBS_SUPPORT */

  for (mb_start = beg = start_ptr ? start_ptr : buf; beg <= buf + size; beg++)
    {
      size_t offset = kwsexec (kwset, beg, buf + size - beg, &kwsmatch);
      if (offset == (size_t) -1)
	goto failure;
#ifdef MBS_SUPPORT
      if (MB_CUR_MAX > 1 && is_mb_middle (&mb_start, beg + offset, buf + size))
        {
          beg = mb_start - 1;
          continue; /* It is a part of multibyte character.  */
        }
#endif /* MBS_SUPPORT */
      beg += offset;
      len = kwsmatch.size[0];
      if (start_ptr && !match_words)
	goto success_in_beg_and_len;
      if (match_lines)
	{
	  if (beg > buf && beg[-1] != eol)
	    continue;
	  if (beg + len < buf + size && beg[len] != eol)
	    continue;
	  goto success;
	}
      else if (match_words)
	for (try = beg; len; )
	  {
	    if (try > buf && WCHAR((unsigned char) try[-1]))
	      break;
	    if (try + len < buf + size && WCHAR((unsigned char) try[len]))
	      {
		offset = kwsexec (kwset, beg, --len, &kwsmatch);
		if (offset == (size_t) -1)
		  break;
		try = beg + offset;
		len = kwsmatch.size[0];
	      }
	    else if (!start_ptr)
	      goto success;
	    else
	      goto success_in_beg_and_len;
	  } /* for (try) */
      else
	goto success;
    } /* for (beg in buf) */

 failure:
  ret_val = -1;
  goto out;

 success:
  if ((end = memchr (beg + len, eol, (buf + size) - (beg + len))) != NULL)
    end++;
  else
    end = buf + size;
  while (buf < beg && beg[-1] != eol)
    --beg;
  len = end - beg;
 success_in_beg_and_len:
  *match_size = len;
  ret_val = beg - buf;
 out:
  return ret_val;
}
#endif /* defined(GREP_PROGRAM) || defined(FGREP_PROGRAM) */

#ifdef GREP_PROGRAM
#if HAVE_LIBPCRE
/* Compiled internal form of a Perl regular expression.  */
static pcre *cre;

/* Additional information about the pattern.  */
static pcre_extra *extra;
#endif

COMPILE_FCT(Pcompile)
{
#if !HAVE_LIBPCRE
  error (EXIT_TROUBLE, 0, "%s",
	 _("support for the -P option is not compiled into "
	   "this --disable-perl-regexp binary"));
#else
  int e;
  char const *ep;
  char *re = xmalloc (4 * size + 7);
  int flags = PCRE_MULTILINE | (match_icase ? PCRE_CASELESS : 0);
  char const *patlim = pattern + size;
  char *n = re;
  char const *p;
  char const *pnul;

  /* FIXME: Remove these restrictions.  */
  if (memchr(pattern, '\n', size))
    error (EXIT_TROUBLE, 0, _("the -P option only supports a single pattern"));

  *n = '\0';
  if (match_lines)
    strcpy (n, "^(");
  if (match_words)
    strcpy (n, "\\b(");
  n += strlen (n);

  /* The PCRE interface doesn't allow NUL bytes in the pattern, so
     replace each NUL byte in the pattern with the four characters
     "\000", removing a preceding backslash if there are an odd
     number of backslashes before the NUL.

     FIXME: This method does not work with some multibyte character
     encodings, notably Shift-JIS, where a multibyte character can end
     in a backslash byte.  */
  for (p = pattern; (pnul = memchr (p, '\0', patlim - p)); p = pnul + 1)
    {
      memcpy (n, p, pnul - p);
      n += pnul - p;
      for (p = pnul; pattern < p && p[-1] == '\\'; p--)
	continue;
      n -= (pnul - p) & 1;
      strcpy (n, "\\000");
      n += 4;
    }

  memcpy (n, p, patlim - p);
  n += patlim - p;
  *n = '\0';
  if (match_words)
    strcpy (n, ")\\b");
  if (match_lines)
    strcpy (n, ")$");

  cre = pcre_compile (re, flags, &ep, &e, pcre_maketables ());
  if (!cre)
    error (EXIT_TROUBLE, 0, "%s", ep);

  extra = pcre_study (cre, 0, &ep);
  if (ep)
    error (EXIT_TROUBLE, 0, "%s", ep);

  free (re);
#endif
}

EXECUTE_FCT(Pexecute)
{
#if !HAVE_LIBPCRE
  abort ();
  return -1;
#else
  /* This array must have at least two elements; everything after that
     is just for performance improvement in pcre_exec.  */
  int sub[300];

  const char *line_buf, *line_end, *line_next;
  int e = PCRE_ERROR_NOMATCH;
  ptrdiff_t start_ofs = start_ptr ? start_ptr - buf : 0;

  /* PCRE can't limit the matching to single lines, therefore we have to
     match each line in the buffer separately.  */
  for (line_next = buf;
       e == PCRE_ERROR_NOMATCH && line_next < buf + size;
       start_ofs -= line_next - line_buf)
    {
      line_buf = line_next;
      line_end = memchr (line_buf, eolbyte, (buf + size) - line_buf);
      if (line_end == NULL)
        line_next = line_end = buf + size;
      else
        line_next = line_end + 1;

      if (start_ptr && start_ptr >= line_end)
        continue;

      e = pcre_exec (cre, extra, line_buf, line_end - line_buf,
                     start_ofs < 0 ? 0 : start_ofs, 0,
                     sub, sizeof sub / sizeof *sub);
    }

  if (e <= 0)
    {
      switch (e)
	{
	case PCRE_ERROR_NOMATCH:
	  return -1;

	case PCRE_ERROR_NOMEMORY:
	  error (EXIT_TROUBLE, 0, _("memory exhausted"));

	default:
	  abort ();
	}
    }
  else
    {
      /* Narrow down to the line we've found.  */
      char const *beg = line_buf + sub[0];
      char const *end = line_buf + sub[1];
      char const *buflim = buf + size;
      char eol = eolbyte;
      if (!start_ptr)
	{
	  /* FIXME: The case when '\n' is not found indicates a bug:
	     Since grep is line oriented, the match should never contain
	     a newline, so there _must_ be a newline following.
	   */
	  if (!(end = memchr (end, eol, buflim - end)))
	    end = buflim;
	  else
	    end++;
	  while (buf < beg && beg[-1] != eol)
	    --beg;
	}

      *match_size = end - beg;
      return beg - buf;
    }
#endif
}

struct matcher const matchers[] = {
  { "default", Gcompile, EGexecute },
  { "grep",    Gcompile, EGexecute },
  { "egrep",   Ecompile, EGexecute },
  { "awk",     Acompile, EGexecute },
  { "fgrep",   Fcompile, Fexecute },
  { "perl",    Pcompile, Pexecute },
  { "", 0, 0 },
};
#endif /* GREP_PROGRAM */

Testing negative cases!
Testing 0 (with abstract condition) ENVIS_NEG
Iteration 0
Running test command:
/home/ubuntu/spr-fast/tools/grep-test.py /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-deccad69-db9d6340/tempworkdir2/src /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-deccad69-db9d6340/tempworkdir2/tests /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-deccad69-db9d6340/tempworkdir2 0  > __res
Opening:/home/ubuntu/spr-fast/tests/corebench/grep/grep-case-deccad69-db9d6340/tempworkdir2/neg.tmp!
NegativeBRANCH RECORD/home/ubuntu/spr-fast/tests/corebench/grep/grep-case-deccad69-db9d6340/tempworkdir2/neg.tmp!
Not caught by the negative case, give up!
APPENDING TO ISNEG:/home/ubuntu/spr-fast/tests/corebench/grep/grep-case-deccad69-db9d6340/tempworkdir2/neg.tmp!
Running test command:
/home/ubuntu/spr-fast/tools/grep-test.py /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-deccad69-db9d6340/tempworkdir2/src /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-deccad69-db9d6340/tempworkdir2/tests /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-deccad69-db9d6340/tempworkdir2 0  > __res
CondTester, Testing instance id 10:
//src_file:src/search.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
/* search.c - searching subroutines using dfa, kwset and regex for grep.
   Copyright 1992, 1998, 2000, 2007, 2009-2010 Free Software Foundation, Inc.

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 3, or (at your option)
   any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program; if not, write to the Free Software
   Foundation, Inc., 51 Franklin Street - Fifth Floor, Boston, MA
   02110-1301, USA.  */

/* Written August 1992 by Mike Haertel. */

#include <config.h>

#include <sys/types.h>

#include "mbsupport.h"
#ifdef MBS_SUPPORT
/* We can handle multibyte strings. */
# include <wchar.h>
# include <wctype.h>
#endif

#include "system.h"
#include "grep.h"
#ifndef FGREP_PROGRAM
# include <regex.h>
# include "dfa.h"
#endif
#include "kwset.h"
#include "error.h"
#include "xalloc.h"
#ifdef HAVE_LIBPCRE
# include <pcre.h>
#endif

#define NCHAR (UCHAR_MAX + 1)

/* For -w, we also consider _ to be word constituent.  */
#define WCHAR(C) (ISALNUM(C) || (C) == '_')

/* KWset compiled pattern.  For Ecompile and Gcompile, we compile
   a list of strings, at least one of which is known to occur in
   any string matching the regexp. */
static kwset_t kwset;

static void
kwsinit (void)
{
  static char trans[NCHAR];
  int i;

  if (match_icase && MB_CUR_MAX == 1)
    {
      for (i = 0; i < NCHAR; ++i)
        trans[i] = TOLOWER (i);

      kwset = kwsalloc (trans);
    }
  else
    kwset = kwsalloc (NULL);

  if (!kwset)
    xalloc_die ();
}

#ifdef MBS_SUPPORT
/* Convert the *N-byte string, BEG, to lowercase, and write the
   NUL-terminated result into malloc'd storage.  Upon success, set *N
   to the length (in bytes) of the resulting string (not including the
   trailing NUL byte), and return a pointer to the lowercase string.
   Upon memory allocation failure, this function exits.

   Note that while this function returns a pointer to malloc'd storage,
   the caller must not free it, since this function retains a pointer
   to the buffer and reuses it on any subsequent call.  As a consequence,
   this function is not thread-safe.  */
static char *
mbtolower (const char *beg, size_t *n)
{
  static char *out;
  static size_t outalloc;
  size_t outlen, mb_cur_max;
  mbstate_t is, os;
  const char *end;
  char *p;

  if (*n > outalloc)
    {
      out = xrealloc (out, *n);
      outalloc = *n;
    }

  memset (&is, 0, sizeof (is));
  memset (&os, 0, sizeof (os));
  end = beg + *n;

  mb_cur_max = MB_CUR_MAX;
  p = out;
  outlen = 0;
  while (beg < end)
    {
      wchar_t wc;
      size_t mbclen = mbrtowc(&wc, beg, end - beg, &is);
      if (outlen + mb_cur_max >= outalloc)
        {
          out = x2nrealloc (out, &outalloc, 1);
          p = out + outlen;
        }

      if (mbclen == (size_t) -1 || mbclen == (size_t) -2 || mbclen == 0)
        {
          /* An invalid sequence, or a truncated multi-octet character.
             We treat it as a single-octet character.  */
          *p++ = *beg++;
          outlen++;
          memset (&is, 0, sizeof (is));
          memset (&os, 0, sizeof (os));
        }
      else
        {
          beg += mbclen;
          mbclen = wcrtomb (p, towlower ((wint_t) wc), &os);
          p += mbclen;
          outlen += mbclen;
        }
    }

  *n = p - out;
  *p++ = 0;
  return out;
}
#endif


#ifndef FGREP_PROGRAM
/* DFA compiled regexp. */
static struct dfa dfa;

/* The Regex compiled patterns.  */
static struct patterns
{
  /* Regex compiled regexp. */
  struct re_pattern_buffer regexbuf;
  struct re_registers regs; /* This is here on account of a BRAIN-DEAD
			       Q@#%!# library interface in regex.c.  */
} patterns0;

struct patterns *patterns;
size_t pcount;

void
dfaerror (char const *mesg)
{
  error (EXIT_TROUBLE, 0, "%s", mesg);
}

/* Number of compiled fixed strings known to exactly match the regexp.
   If kwsexec returns < kwset_exact_matches, then we don't need to
   call the regexp matcher at all. */
static int kwset_exact_matches;

static char const *
kwsincr_case (const char *must)
{
  const char *buf;
  size_t n;

  n = strlen (must);
#ifdef MBS_SUPPORT
  if (match_icase && MB_CUR_MAX > 1)
    buf = mbtolower (must, &n);
  else
#endif
    buf = must;
  return kwsincr (kwset, buf, n);
}

/* If the DFA turns out to have some set of fixed strings one of
   which must occur in the match, then we build a kwset matcher
   to find those strings, and thus quickly filter out impossible
   matches. */
static void
kwsmusts (void)
{
  struct dfamust const *dm;
  char const *err;

  if (dfa.musts)
    {
      kwsinit ();
      /* First, we compile in the substrings known to be exact
	 matches.  The kwset matcher will return the index
	 of the matching string that it chooses. */
      for (dm = dfa.musts; dm; dm = dm->next)
	{
	  if (!dm->exact)
	    continue;
	  ++kwset_exact_matches;
	  if ((err = kwsincr_case (dm->must)) != NULL)
	    error (EXIT_TROUBLE, 0, "%s", err);
	}
      /* Now, we compile the substrings that will require
	 the use of the regexp matcher.  */
      for (dm = dfa.musts; dm; dm = dm->next)
	{
	  if (dm->exact)
	    continue;
	  if ((err = kwsincr_case (dm->must)) != NULL)
	    error (EXIT_TROUBLE, 0, "%s", err);
	}
      if ((err = kwsprep (kwset)) != NULL)
	error (EXIT_TROUBLE, 0, "%s", err);
    }
}
#endif /* !FGREP_PROGRAM */

#ifdef MBS_SUPPORT

static bool
is_mb_middle(const char **good, const char *buf, const char *end)
{
  const char *p = *good;
  const char *prev = p;
  mbstate_t cur_state;

  /* TODO: can be optimized for UTF-8.  */
  memset(&cur_state, 0, sizeof(mbstate_t));
  while (p < buf)
    {
      size_t mbclen = mbrlen(p, end - p, &cur_state);

      /* Store the beginning of the previous complete multibyte character.  */
      if (mbclen != (size_t) -2)
        prev = p;

      if (mbclen == (size_t) -1 || mbclen == (size_t) -2 || mbclen == 0)
	{
	  /* An invalid sequence, or a truncated multibyte character.
	     We treat it as a single byte character.  */
	  mbclen = 1;
	}
      p += mbclen;
    }

  *good = prev;
  return p > buf;
}
#endif /* MBS_SUPPORT */

#if defined(GREP_PROGRAM) || defined(EGREP_PROGRAM)
#ifdef EGREP_PROGRAM
COMPILE_FCT(Ecompile)
{
  reg_syntax_t syntax_bits = RE_SYNTAX_POSIX_EGREP;
#else
/* No __VA_ARGS__ in C89.  So we have to do it this way.  */
static COMPILE_RET
GEAcompile (char const *pattern, size_t size, reg_syntax_t syntax_bits)
{
#endif /* EGREP_PROGRAM */
  const char *err;
  const char *p, *sep;
  size_t total = size;
  char *motif;

  if (match_icase)
    syntax_bits |= RE_ICASE;
  re_set_syntax (syntax_bits);
  dfasyntax (syntax_bits, match_icase, eolbyte);

  /* For GNU regex compiler we have to pass the patterns separately to detect
     errors like "[\nallo\n]\n".  The patterns here are "[", "allo" and "]"
     GNU regex should have raise a syntax error.  The same for backref, where
     the backref should have been local to each pattern.  */
  p = pattern;
  do
    {
      size_t len;
      sep = memchr (p, '\n', total);
      if (sep)
	{
	  len = sep - p;
	  sep++;
	  total -= (len + 1);
	}
      else
	{
	  len = total;
	  total = 0;
	}

      patterns = realloc (patterns, (pcount + 1) * sizeof (*patterns));
      if (patterns == NULL)
	error (EXIT_TROUBLE, errno, _("memory exhausted"));
      patterns[pcount] = patterns0;

      if ((err = re_compile_pattern (p, len,
				    &(patterns[pcount].regexbuf))) != NULL)
	error (EXIT_TROUBLE, 0, "%s", err);
      pcount++;

      p = sep;
    } while (sep && total != 0);

  /* In the match_words and match_lines cases, we use a different pattern
     for the DFA matcher that will quickly throw out cases that won't work.
     Then if DFA succeeds we do some hairy stuff using the regex matcher
     to decide whether the match should really count. */
  if (match_words || match_lines)
    {
      static char const line_beg_no_bk[] = "^(";
      static char const line_end_no_bk[] = ")$";
      static char const word_beg_no_bk[] = "(^|[^[:alnum:]_])(";
      static char const word_end_no_bk[] = ")([^[:alnum:]_]|$)";
#ifdef EGREP_PROGRAM
# define IF_BK(x, y) (y)
      char *n = xmalloc (sizeof word_beg_no_bk - 1 + size + sizeof word_end_no_bk);
#else
      static char const line_beg_bk[] = "^\\(";
      static char const line_end_bk[] = "\\)$";
      static char const word_beg_bk[] = "\\(^\\|[^[:alnum:]_]\\)\\(";
      static char const word_end_bk[] = "\\)\\([^[:alnum:]_]\\|$\\)";
      int bk = !(syntax_bits & RE_NO_BK_PARENS);
# define IF_BK(x, y) ((bk) ? (x) : (y))
      char *n = xmalloc (sizeof word_beg_bk - 1 + size + sizeof word_end_bk);
#endif /* EGREP_PROGRAM */

      strcpy (n, match_lines ? IF_BK(line_beg_bk, line_beg_no_bk)
			     : IF_BK(word_beg_bk, word_beg_no_bk));
      total = strlen(n);
      memcpy (n + total, pattern, size);
      total += size;
      strcpy (n + total, match_lines ? IF_BK(line_end_bk, line_end_no_bk)
				     : IF_BK(word_end_bk, word_end_no_bk));
      total += strlen (n + total);
      pattern = motif = n;
      size = total;
    }
  else
    motif = NULL;

  dfacomp (pattern, size, &dfa, 1);
  kwsmusts ();

  free(motif);
}

#ifndef EGREP_PROGRAM
COMPILE_FCT(Gcompile)
{
  return GEAcompile (pattern, size,
		     RE_SYNTAX_GREP | RE_HAT_LISTS_NOT_NEWLINE);
}

COMPILE_FCT(Acompile)
{
  return GEAcompile (pattern, size, RE_SYNTAX_AWK);
}

COMPILE_FCT(Ecompile)
{
  return GEAcompile (pattern, size, RE_SYNTAX_POSIX_EGREP);
}
#endif /* !EGREP_PROGRAM */

EXECUTE_FCT(EGexecute)
{
  char const *buflim, *beg, *end, *match, *best_match, *mb_start;
  char eol = eolbyte;
  int backref, start, len, best_len;
  struct kwsmatch kwsm;
  size_t i, ret_val;
#ifdef MBS_SUPPORT
  if (MB_CUR_MAX > 1)
    {
      if (match_icase)
        {
          /* mbtolower adds a NUL byte at the end.  That will provide
	     space for the sentinel byte dfaexec may add.  */
          char *case_buf = mbtolower (buf, &size);
	  if (start_ptr)
	    start_ptr = case_buf + (start_ptr - buf);
          buf = case_buf;
        }
    }
#endif /* MBS_SUPPORT */

  mb_start = buf;
  buflim = buf + size;

  for (beg = end = buf; end < buflim; beg = end)
    {
      if (!start_ptr)
	{
	  /* We don't care about an exact match.  */
	  if (kwset)
	    {
	      /* Find a possible match using the KWset matcher. */
	      size_t offset = kwsexec (kwset, beg, buflim - beg, &kwsm);
	      if (offset == (size_t) -1)
		goto failure;
	      beg += offset;
	      /* Narrow down to the line containing the candidate, and
		 run it through DFA. */
	      if ((end = memchr(beg, eol, buflim - beg)) != NULL)
	        end++;
              else
                end = buflim;
	      match = beg;
	      while (beg > buf && beg[-1] != eol)
		--beg;
	      if (kwsm.index < kwset_exact_matches)
                {
#ifdef MBS_SUPPORT
                  if (mb_start < beg)
                    mb_start = beg;
                  if (MB_CUR_MAX == 1 || !is_mb_middle (&mb_start, match, buflim))
#endif
                    goto success;
                }
	      if (dfaexec (&dfa, beg, (char *) end, 0, NULL, &backref) == NULL)
		continue;
	    }
	  else
	    {
	      /* No good fixed strings; start with DFA. */
	      char const *next_beg = dfaexec (&dfa, beg, (char *) buflim,
					      0, NULL, &backref);
	      if (next_beg == NULL)
		break;
	      /* Narrow down to the line we've found. */
	      beg = next_beg;
	      if ((end = memchr(beg, eol, buflim - beg)) != NULL)
	        end++;
              else
                end = buflim;
	      while (beg > buf && beg[-1] != eol)
		--beg;
	    }
	  /* Successful, no backreferences encountered! */
	  if (!backref)
	    goto success;
	}
      else
	{
	  /* We are looking for the leftmost (then longest) exact match.
	     We will go through the outer loop only once.  */
	  beg = start_ptr;
	  end = buflim;
	}

      /* If we've made it to this point, this means DFA has seen
	 a probable match, and we need to run it through Regex. */
      best_match = end;
      best_len = 0;
      for (i = 0; i < pcount; i++)
	{
	  patterns[i].regexbuf.not_eol = 0;
	  if (0 <= (start = re_search (&(patterns[i].regexbuf),
				       buf, end - buf - 1,
				       beg - buf, end - beg - 1,
				       &(patterns[i].regs))))
	    {
	      len = patterns[i].regs.end[0] - start;
	      match = buf + start;
	      if (match > best_match)
		continue;
	      if (start_ptr && !match_words)
		goto assess_pattern_match;
	      if ((!match_lines && !match_words)
		  || (match_lines && len == end - beg - 1))
		{
		  match = beg;
		  len = end - beg;
		  goto assess_pattern_match;
		}
	      /* If -w, check if the match aligns with word boundaries.
		 We do this iteratively because:
		 (a) the line may contain more than one occurence of the
		 pattern, and
		 (b) Several alternatives in the pattern might be valid at a
		 given point, and we may need to consider a shorter one to
		 find a word boundary.  */
	      if (match_words)
		while (match <= best_match)
		  {
		    if ((match == buf || !WCHAR ((unsigned char) match[-1]))
			&& (len == end - beg - 1
			    || !WCHAR ((unsigned char) match[len])))
		      goto assess_pattern_match;
		    if (len > 0)
		      {
			/* Try a shorter length anchored at the same place. */
			--len;
			patterns[i].regexbuf.not_eol = 1;
			len = re_match (&(patterns[i].regexbuf),
					buf, match + len - beg, match - buf,
					&(patterns[i].regs));
		      }
		    if (len <= 0)
		      {
			/* Try looking further on. */
			if (match == end - 1)
			  break;
			match++;
			patterns[i].regexbuf.not_eol = 0;
			start = re_search (&(patterns[i].regexbuf),
					   buf, end - buf - 1,
					   match - buf, end - match - 1,
					   &(patterns[i].regs));
			if (start < 0)
			  break;
			len = patterns[i].regs.end[0] - start;
			match = buf + start;
		      }
		  } /* while (match <= best_match) */
	      continue;
	    assess_pattern_match:
	      if (!start_ptr)
		{
		  /* Good enough for a non-exact match.
		     No need to look at further patterns, if any.  */
		  beg = match;
		  goto success_in_len;
		}
	      if (match < best_match || (match == best_match && len > best_len))
		{
		  /* Best exact match:  leftmost, then longest.  */
		  best_match = match;
		  best_len = len;
		}
	    } /* if re_search >= 0 */
	} /* for Regex patterns.  */
	if (best_match < end)
	  {
	    /* We have found an exact match.  We were just
	       waiting for the best one (leftmost then longest).  */
	    beg = best_match;
	    len = best_len;
	    goto success_in_len;
	  }
    } /* for (beg = end ..) */

 failure:
  ret_val = -1;
  goto out;

 success:
  len = end - beg;
 success_in_len:
  *match_size = len;
  ret_val = beg - buf;
 out:
  return ret_val;
}
#endif /* defined(GREP_PROGRAM) || defined(EGREP_PROGRAM) */

#if defined(GREP_PROGRAM) || defined(FGREP_PROGRAM)
COMPILE_FCT(Fcompile)
{
  char const *beg, *end, *lim, *err, *pat;
  size_t psize;

  kwsinit ();
  psize = size;
  if (match_icase && MB_CUR_MAX > 1)
    pat = mbtolower (pattern, &psize);
  else
    pat = pattern;

  beg = pat;
  do
    {
      for (lim = beg;; ++lim)
	{
	  end = lim;
	  if (lim >= pat + psize)
	    break;
	 if (*lim == '\n')
	   {
	     lim++;
	     break;
	   }
#if HAVE_DOS_FILE_CONTENTS
	 if (*lim == '\r' && lim + 1 < pat + psize && lim[1] == '\n')
	   {
	     lim += 2;
	     break;
	   }
#endif
	}

      if ((err = kwsincr (kwset, beg, end - beg)) != NULL)
	error (EXIT_TROUBLE, 0, "%s", err);
      beg = lim;
    }
  while (beg < pat + psize);

  
//Patch 0:
if (((err = kwsprep(kwset)) != ((void *)0)) || (__is_neg(10, &(err), sizeof (err), &(kwset), sizeof (kwset), &(beg), sizeof (beg), &(pat), sizeof (pat), &(psize), sizeof (psize), &(lim), sizeof (lim), &(end), sizeof (end), &(pattern), sizeof (pattern), &(match_icase), sizeof (match_icase), &(size), sizeof (size))))
    error(EXIT_TROUBLE, 0, "%s", err);

//CodeSeg 1:
}

EXECUTE_FCT(Fexecute)
{
  char const *beg, *try, *end, *mb_start;
  size_t len;
  char eol = eolbyte;
  struct kwsmatch kwsmatch;
  size_t ret_val;
#ifdef MBS_SUPPORT
  if (MB_CUR_MAX > 1)
    {
      if (match_icase)
        {
          char *case_buf = mbtolower (buf, &size);
	  if (start_ptr)
	    start_ptr = case_buf + (start_ptr - buf);
          buf = case_buf;
        }
    }
#endif /* MBS_SUPPORT */

  for (mb_start = beg = start_ptr ? start_ptr : buf; beg <= buf + size; beg++)
    {
      size_t offset = kwsexec (kwset, beg, buf + size - beg, &kwsmatch);
      if (offset == (size_t) -1)
	goto failure;
#ifdef MBS_SUPPORT
      if (MB_CUR_MAX > 1 && is_mb_middle (&mb_start, beg + offset, buf + size))
        {
          beg = mb_start - 1;
          continue; /* It is a part of multibyte character.  */
        }
#endif /* MBS_SUPPORT */
      beg += offset;
      len = kwsmatch.size[0];
      if (start_ptr && !match_words)
	goto success_in_beg_and_len;
      if (match_lines)
	{
	  if (beg > buf && beg[-1] != eol)
	    continue;
	  if (beg + len < buf + size && beg[len] != eol)
	    continue;
	  goto success;
	}
      else if (match_words)
	for (try = beg; len; )
	  {
	    if (try > buf && WCHAR((unsigned char) try[-1]))
	      break;
	    if (try + len < buf + size && WCHAR((unsigned char) try[len]))
	      {
		offset = kwsexec (kwset, beg, --len, &kwsmatch);
		if (offset == (size_t) -1)
		  break;
		try = beg + offset;
		len = kwsmatch.size[0];
	      }
	    else if (!start_ptr)
	      goto success;
	    else
	      goto success_in_beg_and_len;
	  } /* for (try) */
      else
	goto success;
    } /* for (beg in buf) */

 failure:
  ret_val = -1;
  goto out;

 success:
  if ((end = memchr (beg + len, eol, (buf + size) - (beg + len))) != NULL)
    end++;
  else
    end = buf + size;
  while (buf < beg && beg[-1] != eol)
    --beg;
  len = end - beg;
 success_in_beg_and_len:
  *match_size = len;
  ret_val = beg - buf;
 out:
  return ret_val;
}
#endif /* defined(GREP_PROGRAM) || defined(FGREP_PROGRAM) */

#ifdef GREP_PROGRAM
#if HAVE_LIBPCRE
/* Compiled internal form of a Perl regular expression.  */
static pcre *cre;

/* Additional information about the pattern.  */
static pcre_extra *extra;
#endif

COMPILE_FCT(Pcompile)
{
#if !HAVE_LIBPCRE
  error (EXIT_TROUBLE, 0, "%s",
	 _("support for the -P option is not compiled into "
	   "this --disable-perl-regexp binary"));
#else
  int e;
  char const *ep;
  char *re = xmalloc (4 * size + 7);
  int flags = PCRE_MULTILINE | (match_icase ? PCRE_CASELESS : 0);
  char const *patlim = pattern + size;
  char *n = re;
  char const *p;
  char const *pnul;

  /* FIXME: Remove these restrictions.  */
  if (memchr(pattern, '\n', size))
    error (EXIT_TROUBLE, 0, _("the -P option only supports a single pattern"));

  *n = '\0';
  if (match_lines)
    strcpy (n, "^(");
  if (match_words)
    strcpy (n, "\\b(");
  n += strlen (n);

  /* The PCRE interface doesn't allow NUL bytes in the pattern, so
     replace each NUL byte in the pattern with the four characters
     "\000", removing a preceding backslash if there are an odd
     number of backslashes before the NUL.

     FIXME: This method does not work with some multibyte character
     encodings, notably Shift-JIS, where a multibyte character can end
     in a backslash byte.  */
  for (p = pattern; (pnul = memchr (p, '\0', patlim - p)); p = pnul + 1)
    {
      memcpy (n, p, pnul - p);
      n += pnul - p;
      for (p = pnul; pattern < p && p[-1] == '\\'; p--)
	continue;
      n -= (pnul - p) & 1;
      strcpy (n, "\\000");
      n += 4;
    }

  memcpy (n, p, patlim - p);
  n += patlim - p;
  *n = '\0';
  if (match_words)
    strcpy (n, ")\\b");
  if (match_lines)
    strcpy (n, ")$");

  cre = pcre_compile (re, flags, &ep, &e, pcre_maketables ());
  if (!cre)
    error (EXIT_TROUBLE, 0, "%s", ep);

  extra = pcre_study (cre, 0, &ep);
  if (ep)
    error (EXIT_TROUBLE, 0, "%s", ep);

  free (re);
#endif
}

EXECUTE_FCT(Pexecute)
{
#if !HAVE_LIBPCRE
  abort ();
  return -1;
#else
  /* This array must have at least two elements; everything after that
     is just for performance improvement in pcre_exec.  */
  int sub[300];

  const char *line_buf, *line_end, *line_next;
  int e = PCRE_ERROR_NOMATCH;
  ptrdiff_t start_ofs = start_ptr ? start_ptr - buf : 0;

  /* PCRE can't limit the matching to single lines, therefore we have to
     match each line in the buffer separately.  */
  for (line_next = buf;
       e == PCRE_ERROR_NOMATCH && line_next < buf + size;
       start_ofs -= line_next - line_buf)
    {
      line_buf = line_next;
      line_end = memchr (line_buf, eolbyte, (buf + size) - line_buf);
      if (line_end == NULL)
        line_next = line_end = buf + size;
      else
        line_next = line_end + 1;

      if (start_ptr && start_ptr >= line_end)
        continue;

      e = pcre_exec (cre, extra, line_buf, line_end - line_buf,
                     start_ofs < 0 ? 0 : start_ofs, 0,
                     sub, sizeof sub / sizeof *sub);
    }

  if (e <= 0)
    {
      switch (e)
	{
	case PCRE_ERROR_NOMATCH:
	  return -1;

	case PCRE_ERROR_NOMEMORY:
	  error (EXIT_TROUBLE, 0, _("memory exhausted"));

	default:
	  abort ();
	}
    }
  else
    {
      /* Narrow down to the line we've found.  */
      char const *beg = line_buf + sub[0];
      char const *end = line_buf + sub[1];
      char const *buflim = buf + size;
      char eol = eolbyte;
      if (!start_ptr)
	{
	  /* FIXME: The case when '\n' is not found indicates a bug:
	     Since grep is line oriented, the match should never contain
	     a newline, so there _must_ be a newline following.
	   */
	  if (!(end = memchr (end, eol, buflim - end)))
	    end = buflim;
	  else
	    end++;
	  while (buf < beg && beg[-1] != eol)
	    --beg;
	}

      *match_size = end - beg;
      return beg - buf;
    }
#endif
}

struct matcher const matchers[] = {
  { "default", Gcompile, EGexecute },
  { "grep",    Gcompile, EGexecute },
  { "egrep",   Ecompile, EGexecute },
  { "awk",     Acompile, EGexecute },
  { "fgrep",   Fcompile, Fexecute },
  { "perl",    Pcompile, Pexecute },
  { "", 0, 0 },
};
#endif /* GREP_PROGRAM */

Testing negative cases!
Testing 0 (with abstract condition) ENVIS_NEG
Iteration 0
Running test command:
/home/ubuntu/spr-fast/tools/grep-test.py /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-deccad69-db9d6340/tempworkdir2/src /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-deccad69-db9d6340/tempworkdir2/tests /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-deccad69-db9d6340/tempworkdir2 0  > __res
Opening:/home/ubuntu/spr-fast/tests/corebench/grep/grep-case-deccad69-db9d6340/tempworkdir2/neg.tmp!
NegativeBRANCH RECORD/home/ubuntu/spr-fast/tests/corebench/grep/grep-case-deccad69-db9d6340/tempworkdir2/neg.tmp!
APPENDING TO ISNEG:/home/ubuntu/spr-fast/tests/corebench/grep/grep-case-deccad69-db9d6340/tempworkdir2/neg.tmp!
Branch 0: 0
Iteration 1
Running test command:
/home/ubuntu/spr-fast/tools/grep-test.py /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-deccad69-db9d6340/tempworkdir2/src /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-deccad69-db9d6340/tempworkdir2/tests /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-deccad69-db9d6340/tempworkdir2 0  > __res
Opening:/home/ubuntu/spr-fast/tests/corebench/grep/grep-case-deccad69-db9d6340/tempworkdir2/neg.tmp!
NegativeBRANCH RECORD/home/ubuntu/spr-fast/tests/corebench/grep/grep-case-deccad69-db9d6340/tempworkdir2/neg.tmp!
APPENDING TO ISNEG:/home/ubuntu/spr-fast/tests/corebench/grep/grep-case-deccad69-db9d6340/tempworkdir2/neg.tmp!
Branch 0: 1
Passed in iteration!
Passed Negative Cases wiht CondTestder!
Testing positive cases!
Running test command:
/home/ubuntu/spr-fast/tools/grep-test.py /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-deccad69-db9d6340/tempworkdir2/src /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-deccad69-db9d6340/tempworkdir2/tests /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-deccad69-db9d6340/tempworkdir2 9  > __res
Running test command:
/home/ubuntu/spr-fast/tools/grep-test.py /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-deccad69-db9d6340/tempworkdir2/src /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-deccad69-db9d6340/tempworkdir2/tests /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-deccad69-db9d6340/tempworkdir2 12  > __res
Running test command:
/home/ubuntu/spr-fast/tools/grep-test.py /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-deccad69-db9d6340/tempworkdir2/src /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-deccad69-db9d6340/tempworkdir2/tests /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-deccad69-db9d6340/tempworkdir2 3  > __res
Running test command:
/home/ubuntu/spr-fast/tools/grep-test.py /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-deccad69-db9d6340/tempworkdir2/src /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-deccad69-db9d6340/tempworkdir2/tests /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-deccad69-db9d6340/tempworkdir2 4  > __res
Running test command:
/home/ubuntu/spr-fast/tools/grep-test.py /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-deccad69-db9d6340/tempworkdir2/src /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-deccad69-db9d6340/tempworkdir2/tests /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-deccad69-db9d6340/tempworkdir2 5  > __res
Running test command:
/home/ubuntu/spr-fast/tools/grep-test.py /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-deccad69-db9d6340/tempworkdir2/src /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-deccad69-db9d6340/tempworkdir2/tests /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-deccad69-db9d6340/tempworkdir2 6  > __res
Running test command:
/home/ubuntu/spr-fast/tools/grep-test.py /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-deccad69-db9d6340/tempworkdir2/src /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-deccad69-db9d6340/tempworkdir2/tests /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-deccad69-db9d6340/tempworkdir2 11  > __res
Running test command:
/home/ubuntu/spr-fast/tools/grep-test.py /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-deccad69-db9d6340/tempworkdir2/src /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-deccad69-db9d6340/tempworkdir2/tests /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-deccad69-db9d6340/tempworkdir2 13  > __res
Running test command:
/home/ubuntu/spr-fast/tools/grep-test.py /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-deccad69-db9d6340/tempworkdir2/src /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-deccad69-db9d6340/tempworkdir2/tests /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-deccad69-db9d6340/tempworkdir2 14  > __res
Running test command:
/home/ubuntu/spr-fast/tools/grep-test.py /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-deccad69-db9d6340/tempworkdir2/src /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-deccad69-db9d6340/tempworkdir2/tests /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-deccad69-db9d6340/tempworkdir2 15  > __res
Running test command:
/home/ubuntu/spr-fast/tools/grep-test.py /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-deccad69-db9d6340/tempworkdir2/src /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-deccad69-db9d6340/tempworkdir2/tests /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-deccad69-db9d6340/tempworkdir2 17  > __res
Running test command:
/home/ubuntu/spr-fast/tools/grep-test.py /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-deccad69-db9d6340/tempworkdir2/src /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-deccad69-db9d6340/tempworkdir2/tests /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-deccad69-db9d6340/tempworkdir2 18  > __res
Running test command:
/home/ubuntu/spr-fast/tools/grep-test.py /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-deccad69-db9d6340/tempworkdir2/src /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-deccad69-db9d6340/tempworkdir2/tests /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-deccad69-db9d6340/tempworkdir2 20  > __res
Running test command:
/home/ubuntu/spr-fast/tools/grep-test.py /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-deccad69-db9d6340/tempworkdir2/src /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-deccad69-db9d6340/tempworkdir2/tests /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-deccad69-db9d6340/tempworkdir2 22  > __res
Running test command:
/home/ubuntu/spr-fast/tools/grep-test.py /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-deccad69-db9d6340/tempworkdir2/src /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-deccad69-db9d6340/tempworkdir2/tests /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-deccad69-db9d6340/tempworkdir2 23  > __res
Running test command:
/home/ubuntu/spr-fast/tools/grep-test.py /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-deccad69-db9d6340/tempworkdir2/src /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-deccad69-db9d6340/tempworkdir2/tests /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-deccad69-db9d6340/tempworkdir2 25  > __res
Passed Positive Cases
Collect values for post processing!
WRITING TO ISNEG:/home/ubuntu/spr-fast/tests/corebench/grep/grep-case-deccad69-db9d6340/tempworkdir2/neg.tmp!
Running test command:
/home/ubuntu/spr-fast/tools/grep-test.py /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-deccad69-db9d6340/tempworkdir2/src /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-deccad69-db9d6340/tempworkdir2/tests /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-deccad69-db9d6340/tempworkdir2 0  > __res
Running test command:
/home/ubuntu/spr-fast/tools/grep-test.py /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-deccad69-db9d6340/tempworkdir2/src /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-deccad69-db9d6340/tempworkdir2/tests /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-deccad69-db9d6340/tempworkdir2 3  > __res
Running test command:
/home/ubuntu/spr-fast/tools/grep-test.py /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-deccad69-db9d6340/tempworkdir2/src /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-deccad69-db9d6340/tempworkdir2/tests /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-deccad69-db9d6340/tempworkdir2 4  > __res
Running test command:
/home/ubuntu/spr-fast/tools/grep-test.py /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-deccad69-db9d6340/tempworkdir2/src /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-deccad69-db9d6340/tempworkdir2/tests /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-deccad69-db9d6340/tempworkdir2 5  > __res
Running test command:
/home/ubuntu/spr-fast/tools/grep-test.py /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-deccad69-db9d6340/tempworkdir2/src /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-deccad69-db9d6340/tempworkdir2/tests /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-deccad69-db9d6340/tempworkdir2 6  > __res
Running test command:
/home/ubuntu/spr-fast/tools/grep-test.py /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-deccad69-db9d6340/tempworkdir2/src /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-deccad69-db9d6340/tempworkdir2/tests /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-deccad69-db9d6340/tempworkdir2 9  > __res
Running test command:
/home/ubuntu/spr-fast/tools/grep-test.py /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-deccad69-db9d6340/tempworkdir2/src /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-deccad69-db9d6340/tempworkdir2/tests /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-deccad69-db9d6340/tempworkdir2 11  > __res
Running test command:
/home/ubuntu/spr-fast/tools/grep-test.py /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-deccad69-db9d6340/tempworkdir2/src /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-deccad69-db9d6340/tempworkdir2/tests /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-deccad69-db9d6340/tempworkdir2 12  > __res
Running test command:
/home/ubuntu/spr-fast/tools/grep-test.py /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-deccad69-db9d6340/tempworkdir2/src /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-deccad69-db9d6340/tempworkdir2/tests /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-deccad69-db9d6340/tempworkdir2 13  > __res
Running test command:
/home/ubuntu/spr-fast/tools/grep-test.py /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-deccad69-db9d6340/tempworkdir2/src /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-deccad69-db9d6340/tempworkdir2/tests /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-deccad69-db9d6340/tempworkdir2 14  > __res
Running test command:
/home/ubuntu/spr-fast/tools/grep-test.py /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-deccad69-db9d6340/tempworkdir2/src /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-deccad69-db9d6340/tempworkdir2/tests /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-deccad69-db9d6340/tempworkdir2 15  > __res
Running test command:
/home/ubuntu/spr-fast/tools/grep-test.py /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-deccad69-db9d6340/tempworkdir2/src /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-deccad69-db9d6340/tempworkdir2/tests /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-deccad69-db9d6340/tempworkdir2 17  > __res
Running test command:
/home/ubuntu/spr-fast/tools/grep-test.py /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-deccad69-db9d6340/tempworkdir2/src /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-deccad69-db9d6340/tempworkdir2/tests /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-deccad69-db9d6340/tempworkdir2 18  > __res
Running test command:
/home/ubuntu/spr-fast/tools/grep-test.py /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-deccad69-db9d6340/tempworkdir2/src /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-deccad69-db9d6340/tempworkdir2/tests /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-deccad69-db9d6340/tempworkdir2 20  > __res
Running test command:
/home/ubuntu/spr-fast/tools/grep-test.py /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-deccad69-db9d6340/tempworkdir2/src /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-deccad69-db9d6340/tempworkdir2/tests /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-deccad69-db9d6340/tempworkdir2 22  > __res
Running test command:
/home/ubuntu/spr-fast/tools/grep-test.py /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-deccad69-db9d6340/tempworkdir2/src /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-deccad69-db9d6340/tempworkdir2/tests /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-deccad69-db9d6340/tempworkdir2 23  > __res
Running test command:
/home/ubuntu/spr-fast/tools/grep-test.py /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-deccad69-db9d6340/tempworkdir2/src /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-deccad69-db9d6340/tempworkdir2/tests /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-deccad69-db9d6340/tempworkdir2 25  > __res
Passed!
CondTester, Postprocessing instance id 10:
//src_file:src/search.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
/* search.c - searching subroutines using dfa, kwset and regex for grep.
   Copyright 1992, 1998, 2000, 2007, 2009-2010 Free Software Foundation, Inc.

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 3, or (at your option)
   any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program; if not, write to the Free Software
   Foundation, Inc., 51 Franklin Street - Fifth Floor, Boston, MA
   02110-1301, USA.  */

/* Written August 1992 by Mike Haertel. */

#include <config.h>

#include <sys/types.h>

#include "mbsupport.h"
#ifdef MBS_SUPPORT
/* We can handle multibyte strings. */
# include <wchar.h>
# include <wctype.h>
#endif

#include "system.h"
#include "grep.h"
#ifndef FGREP_PROGRAM
# include <regex.h>
# include "dfa.h"
#endif
#include "kwset.h"
#include "error.h"
#include "xalloc.h"
#ifdef HAVE_LIBPCRE
# include <pcre.h>
#endif

#define NCHAR (UCHAR_MAX + 1)

/* For -w, we also consider _ to be word constituent.  */
#define WCHAR(C) (ISALNUM(C) || (C) == '_')

/* KWset compiled pattern.  For Ecompile and Gcompile, we compile
   a list of strings, at least one of which is known to occur in
   any string matching the regexp. */
static kwset_t kwset;

static void
kwsinit (void)
{
  static char trans[NCHAR];
  int i;

  if (match_icase && MB_CUR_MAX == 1)
    {
      for (i = 0; i < NCHAR; ++i)
        trans[i] = TOLOWER (i);

      kwset = kwsalloc (trans);
    }
  else
    kwset = kwsalloc (NULL);

  if (!kwset)
    xalloc_die ();
}

#ifdef MBS_SUPPORT
/* Convert the *N-byte string, BEG, to lowercase, and write the
   NUL-terminated result into malloc'd storage.  Upon success, set *N
   to the length (in bytes) of the resulting string (not including the
   trailing NUL byte), and return a pointer to the lowercase string.
   Upon memory allocation failure, this function exits.

   Note that while this function returns a pointer to malloc'd storage,
   the caller must not free it, since this function retains a pointer
   to the buffer and reuses it on any subsequent call.  As a consequence,
   this function is not thread-safe.  */
static char *
mbtolower (const char *beg, size_t *n)
{
  static char *out;
  static size_t outalloc;
  size_t outlen, mb_cur_max;
  mbstate_t is, os;
  const char *end;
  char *p;

  if (*n > outalloc)
    {
      out = xrealloc (out, *n);
      outalloc = *n;
    }

  memset (&is, 0, sizeof (is));
  memset (&os, 0, sizeof (os));
  end = beg + *n;

  mb_cur_max = MB_CUR_MAX;
  p = out;
  outlen = 0;
  while (beg < end)
    {
      wchar_t wc;
      size_t mbclen = mbrtowc(&wc, beg, end - beg, &is);
      if (outlen + mb_cur_max >= outalloc)
        {
          out = x2nrealloc (out, &outalloc, 1);
          p = out + outlen;
        }

      if (mbclen == (size_t) -1 || mbclen == (size_t) -2 || mbclen == 0)
        {
          /* An invalid sequence, or a truncated multi-octet character.
             We treat it as a single-octet character.  */
          *p++ = *beg++;
          outlen++;
          memset (&is, 0, sizeof (is));
          memset (&os, 0, sizeof (os));
        }
      else
        {
          beg += mbclen;
          mbclen = wcrtomb (p, towlower ((wint_t) wc), &os);
          p += mbclen;
          outlen += mbclen;
        }
    }

  *n = p - out;
  *p++ = 0;
  return out;
}
#endif


#ifndef FGREP_PROGRAM
/* DFA compiled regexp. */
static struct dfa dfa;

/* The Regex compiled patterns.  */
static struct patterns
{
  /* Regex compiled regexp. */
  struct re_pattern_buffer regexbuf;
  struct re_registers regs; /* This is here on account of a BRAIN-DEAD
			       Q@#%!# library interface in regex.c.  */
} patterns0;

struct patterns *patterns;
size_t pcount;

void
dfaerror (char const *mesg)
{
  error (EXIT_TROUBLE, 0, "%s", mesg);
}

/* Number of compiled fixed strings known to exactly match the regexp.
   If kwsexec returns < kwset_exact_matches, then we don't need to
   call the regexp matcher at all. */
static int kwset_exact_matches;

static char const *
kwsincr_case (const char *must)
{
  const char *buf;
  size_t n;

  n = strlen (must);
#ifdef MBS_SUPPORT
  if (match_icase && MB_CUR_MAX > 1)
    buf = mbtolower (must, &n);
  else
#endif
    buf = must;
  return kwsincr (kwset, buf, n);
}

/* If the DFA turns out to have some set of fixed strings one of
   which must occur in the match, then we build a kwset matcher
   to find those strings, and thus quickly filter out impossible
   matches. */
static void
kwsmusts (void)
{
  struct dfamust const *dm;
  char const *err;

  if (dfa.musts)
    {
      kwsinit ();
      /* First, we compile in the substrings known to be exact
	 matches.  The kwset matcher will return the index
	 of the matching string that it chooses. */
      for (dm = dfa.musts; dm; dm = dm->next)
	{
	  if (!dm->exact)
	    continue;
	  ++kwset_exact_matches;
	  if ((err = kwsincr_case (dm->must)) != NULL)
	    error (EXIT_TROUBLE, 0, "%s", err);
	}
      /* Now, we compile the substrings that will require
	 the use of the regexp matcher.  */
      for (dm = dfa.musts; dm; dm = dm->next)
	{
	  if (dm->exact)
	    continue;
	  if ((err = kwsincr_case (dm->must)) != NULL)
	    error (EXIT_TROUBLE, 0, "%s", err);
	}
      if ((err = kwsprep (kwset)) != NULL)
	error (EXIT_TROUBLE, 0, "%s", err);
    }
}
#endif /* !FGREP_PROGRAM */

#ifdef MBS_SUPPORT

static bool
is_mb_middle(const char **good, const char *buf, const char *end)
{
  const char *p = *good;
  const char *prev = p;
  mbstate_t cur_state;

  /* TODO: can be optimized for UTF-8.  */
  memset(&cur_state, 0, sizeof(mbstate_t));
  while (p < buf)
    {
      size_t mbclen = mbrlen(p, end - p, &cur_state);

      /* Store the beginning of the previous complete multibyte character.  */
      if (mbclen != (size_t) -2)
        prev = p;

      if (mbclen == (size_t) -1 || mbclen == (size_t) -2 || mbclen == 0)
	{
	  /* An invalid sequence, or a truncated multibyte character.
	     We treat it as a single byte character.  */
	  mbclen = 1;
	}
      p += mbclen;
    }

  *good = prev;
  return p > buf;
}
#endif /* MBS_SUPPORT */

#if defined(GREP_PROGRAM) || defined(EGREP_PROGRAM)
#ifdef EGREP_PROGRAM
COMPILE_FCT(Ecompile)
{
  reg_syntax_t syntax_bits = RE_SYNTAX_POSIX_EGREP;
#else
/* No __VA_ARGS__ in C89.  So we have to do it this way.  */
static COMPILE_RET
GEAcompile (char const *pattern, size_t size, reg_syntax_t syntax_bits)
{
#endif /* EGREP_PROGRAM */
  const char *err;
  const char *p, *sep;
  size_t total = size;
  char *motif;

  if (match_icase)
    syntax_bits |= RE_ICASE;
  re_set_syntax (syntax_bits);
  dfasyntax (syntax_bits, match_icase, eolbyte);

  /* For GNU regex compiler we have to pass the patterns separately to detect
     errors like "[\nallo\n]\n".  The patterns here are "[", "allo" and "]"
     GNU regex should have raise a syntax error.  The same for backref, where
     the backref should have been local to each pattern.  */
  p = pattern;
  do
    {
      size_t len;
      sep = memchr (p, '\n', total);
      if (sep)
	{
	  len = sep - p;
	  sep++;
	  total -= (len + 1);
	}
      else
	{
	  len = total;
	  total = 0;
	}

      patterns = realloc (patterns, (pcount + 1) * sizeof (*patterns));
      if (patterns == NULL)
	error (EXIT_TROUBLE, errno, _("memory exhausted"));
      patterns[pcount] = patterns0;

      if ((err = re_compile_pattern (p, len,
				    &(patterns[pcount].regexbuf))) != NULL)
	error (EXIT_TROUBLE, 0, "%s", err);
      pcount++;

      p = sep;
    } while (sep && total != 0);

  /* In the match_words and match_lines cases, we use a different pattern
     for the DFA matcher that will quickly throw out cases that won't work.
     Then if DFA succeeds we do some hairy stuff using the regex matcher
     to decide whether the match should really count. */
  if (match_words || match_lines)
    {
      static char const line_beg_no_bk[] = "^(";
      static char const line_end_no_bk[] = ")$";
      static char const word_beg_no_bk[] = "(^|[^[:alnum:]_])(";
      static char const word_end_no_bk[] = ")([^[:alnum:]_]|$)";
#ifdef EGREP_PROGRAM
# define IF_BK(x, y) (y)
      char *n = xmalloc (sizeof word_beg_no_bk - 1 + size + sizeof word_end_no_bk);
#else
      static char const line_beg_bk[] = "^\\(";
      static char const line_end_bk[] = "\\)$";
      static char const word_beg_bk[] = "\\(^\\|[^[:alnum:]_]\\)\\(";
      static char const word_end_bk[] = "\\)\\([^[:alnum:]_]\\|$\\)";
      int bk = !(syntax_bits & RE_NO_BK_PARENS);
# define IF_BK(x, y) ((bk) ? (x) : (y))
      char *n = xmalloc (sizeof word_beg_bk - 1 + size + sizeof word_end_bk);
#endif /* EGREP_PROGRAM */

      strcpy (n, match_lines ? IF_BK(line_beg_bk, line_beg_no_bk)
			     : IF_BK(word_beg_bk, word_beg_no_bk));
      total = strlen(n);
      memcpy (n + total, pattern, size);
      total += size;
      strcpy (n + total, match_lines ? IF_BK(line_end_bk, line_end_no_bk)
				     : IF_BK(word_end_bk, word_end_no_bk));
      total += strlen (n + total);
      pattern = motif = n;
      size = total;
    }
  else
    motif = NULL;

  dfacomp (pattern, size, &dfa, 1);
  kwsmusts ();

  free(motif);
}

#ifndef EGREP_PROGRAM
COMPILE_FCT(Gcompile)
{
  return GEAcompile (pattern, size,
		     RE_SYNTAX_GREP | RE_HAT_LISTS_NOT_NEWLINE);
}

COMPILE_FCT(Acompile)
{
  return GEAcompile (pattern, size, RE_SYNTAX_AWK);
}

COMPILE_FCT(Ecompile)
{
  return GEAcompile (pattern, size, RE_SYNTAX_POSIX_EGREP);
}
#endif /* !EGREP_PROGRAM */

EXECUTE_FCT(EGexecute)
{
  char const *buflim, *beg, *end, *match, *best_match, *mb_start;
  char eol = eolbyte;
  int backref, start, len, best_len;
  struct kwsmatch kwsm;
  size_t i, ret_val;
#ifdef MBS_SUPPORT
  if (MB_CUR_MAX > 1)
    {
      if (match_icase)
        {
          /* mbtolower adds a NUL byte at the end.  That will provide
	     space for the sentinel byte dfaexec may add.  */
          char *case_buf = mbtolower (buf, &size);
	  if (start_ptr)
	    start_ptr = case_buf + (start_ptr - buf);
          buf = case_buf;
        }
    }
#endif /* MBS_SUPPORT */

  mb_start = buf;
  buflim = buf + size;

  for (beg = end = buf; end < buflim; beg = end)
    {
      if (!start_ptr)
	{
	  /* We don't care about an exact match.  */
	  if (kwset)
	    {
	      /* Find a possible match using the KWset matcher. */
	      size_t offset = kwsexec (kwset, beg, buflim - beg, &kwsm);
	      if (offset == (size_t) -1)
		goto failure;
	      beg += offset;
	      /* Narrow down to the line containing the candidate, and
		 run it through DFA. */
	      if ((end = memchr(beg, eol, buflim - beg)) != NULL)
	        end++;
              else
                end = buflim;
	      match = beg;
	      while (beg > buf && beg[-1] != eol)
		--beg;
	      if (kwsm.index < kwset_exact_matches)
                {
#ifdef MBS_SUPPORT
                  if (mb_start < beg)
                    mb_start = beg;
                  if (MB_CUR_MAX == 1 || !is_mb_middle (&mb_start, match, buflim))
#endif
                    goto success;
                }
	      if (dfaexec (&dfa, beg, (char *) end, 0, NULL, &backref) == NULL)
		continue;
	    }
	  else
	    {
	      /* No good fixed strings; start with DFA. */
	      char const *next_beg = dfaexec (&dfa, beg, (char *) buflim,
					      0, NULL, &backref);
	      if (next_beg == NULL)
		break;
	      /* Narrow down to the line we've found. */
	      beg = next_beg;
	      if ((end = memchr(beg, eol, buflim - beg)) != NULL)
	        end++;
              else
                end = buflim;
	      while (beg > buf && beg[-1] != eol)
		--beg;
	    }
	  /* Successful, no backreferences encountered! */
	  if (!backref)
	    goto success;
	}
      else
	{
	  /* We are looking for the leftmost (then longest) exact match.
	     We will go through the outer loop only once.  */
	  beg = start_ptr;
	  end = buflim;
	}

      /* If we've made it to this point, this means DFA has seen
	 a probable match, and we need to run it through Regex. */
      best_match = end;
      best_len = 0;
      for (i = 0; i < pcount; i++)
	{
	  patterns[i].regexbuf.not_eol = 0;
	  if (0 <= (start = re_search (&(patterns[i].regexbuf),
				       buf, end - buf - 1,
				       beg - buf, end - beg - 1,
				       &(patterns[i].regs))))
	    {
	      len = patterns[i].regs.end[0] - start;
	      match = buf + start;
	      if (match > best_match)
		continue;
	      if (start_ptr && !match_words)
		goto assess_pattern_match;
	      if ((!match_lines && !match_words)
		  || (match_lines && len == end - beg - 1))
		{
		  match = beg;
		  len = end - beg;
		  goto assess_pattern_match;
		}
	      /* If -w, check if the match aligns with word boundaries.
		 We do this iteratively because:
		 (a) the line may contain more than one occurence of the
		 pattern, and
		 (b) Several alternatives in the pattern might be valid at a
		 given point, and we may need to consider a shorter one to
		 find a word boundary.  */
	      if (match_words)
		while (match <= best_match)
		  {
		    if ((match == buf || !WCHAR ((unsigned char) match[-1]))
			&& (len == end - beg - 1
			    || !WCHAR ((unsigned char) match[len])))
		      goto assess_pattern_match;
		    if (len > 0)
		      {
			/* Try a shorter length anchored at the same place. */
			--len;
			patterns[i].regexbuf.not_eol = 1;
			len = re_match (&(patterns[i].regexbuf),
					buf, match + len - beg, match - buf,
					&(patterns[i].regs));
		      }
		    if (len <= 0)
		      {
			/* Try looking further on. */
			if (match == end - 1)
			  break;
			match++;
			patterns[i].regexbuf.not_eol = 0;
			start = re_search (&(patterns[i].regexbuf),
					   buf, end - buf - 1,
					   match - buf, end - match - 1,
					   &(patterns[i].regs));
			if (start < 0)
			  break;
			len = patterns[i].regs.end[0] - start;
			match = buf + start;
		      }
		  } /* while (match <= best_match) */
	      continue;
	    assess_pattern_match:
	      if (!start_ptr)
		{
		  /* Good enough for a non-exact match.
		     No need to look at further patterns, if any.  */
		  beg = match;
		  goto success_in_len;
		}
	      if (match < best_match || (match == best_match && len > best_len))
		{
		  /* Best exact match:  leftmost, then longest.  */
		  best_match = match;
		  best_len = len;
		}
	    } /* if re_search >= 0 */
	} /* for Regex patterns.  */
	if (best_match < end)
	  {
	    /* We have found an exact match.  We were just
	       waiting for the best one (leftmost then longest).  */
	    beg = best_match;
	    len = best_len;
	    goto success_in_len;
	  }
    } /* for (beg = end ..) */

 failure:
  ret_val = -1;
  goto out;

 success:
  len = end - beg;
 success_in_len:
  *match_size = len;
  ret_val = beg - buf;
 out:
  return ret_val;
}
#endif /* defined(GREP_PROGRAM) || defined(EGREP_PROGRAM) */

#if defined(GREP_PROGRAM) || defined(FGREP_PROGRAM)
COMPILE_FCT(Fcompile)
{
  char const *beg, *end, *lim, *err, *pat;
  size_t psize;

  kwsinit ();
  psize = size;
  if (match_icase && MB_CUR_MAX > 1)
    pat = mbtolower (pattern, &psize);
  else
    pat = pattern;

  beg = pat;
  do
    {
      for (lim = beg;; ++lim)
	{
	  end = lim;
	  if (lim >= pat + psize)
	    break;
	 if (*lim == '\n')
	   {
	     lim++;
	     break;
	   }
#if HAVE_DOS_FILE_CONTENTS
	 if (*lim == '\r' && lim + 1 < pat + psize && lim[1] == '\n')
	   {
	     lim += 2;
	     break;
	   }
#endif
	}

      if ((err = kwsincr (kwset, beg, end - beg)) != NULL)
	error (EXIT_TROUBLE, 0, "%s", err);
      beg = lim;
    }
  while (beg < pat + psize);

  
//Patch 0:
if (((err = kwsprep(kwset)) != ((void *)0)) || (__is_neg(10, &(err), sizeof (err), &(kwset), sizeof (kwset), &(beg), sizeof (beg), &(pat), sizeof (pat), &(psize), sizeof (psize), &(lim), sizeof (lim), &(end), sizeof (end), &(pattern), sizeof (pattern), &(match_icase), sizeof (match_icase), &(size), sizeof (size))))
    error(EXIT_TROUBLE, 0, "%s", err);

//CodeSeg 1:
}

EXECUTE_FCT(Fexecute)
{
  char const *beg, *try, *end, *mb_start;
  size_t len;
  char eol = eolbyte;
  struct kwsmatch kwsmatch;
  size_t ret_val;
#ifdef MBS_SUPPORT
  if (MB_CUR_MAX > 1)
    {
      if (match_icase)
        {
          char *case_buf = mbtolower (buf, &size);
	  if (start_ptr)
	    start_ptr = case_buf + (start_ptr - buf);
          buf = case_buf;
        }
    }
#endif /* MBS_SUPPORT */

  for (mb_start = beg = start_ptr ? start_ptr : buf; beg <= buf + size; beg++)
    {
      size_t offset = kwsexec (kwset, beg, buf + size - beg, &kwsmatch);
      if (offset == (size_t) -1)
	goto failure;
#ifdef MBS_SUPPORT
      if (MB_CUR_MAX > 1 && is_mb_middle (&mb_start, beg + offset, buf + size))
        {
          beg = mb_start - 1;
          continue; /* It is a part of multibyte character.  */
        }
#endif /* MBS_SUPPORT */
      beg += offset;
      len = kwsmatch.size[0];
      if (start_ptr && !match_words)
	goto success_in_beg_and_len;
      if (match_lines)
	{
	  if (beg > buf && beg[-1] != eol)
	    continue;
	  if (beg + len < buf + size && beg[len] != eol)
	    continue;
	  goto success;
	}
      else if (match_words)
	for (try = beg; len; )
	  {
	    if (try > buf && WCHAR((unsigned char) try[-1]))
	      break;
	    if (try + len < buf + size && WCHAR((unsigned char) try[len]))
	      {
		offset = kwsexec (kwset, beg, --len, &kwsmatch);
		if (offset == (size_t) -1)
		  break;
		try = beg + offset;
		len = kwsmatch.size[0];
	      }
	    else if (!start_ptr)
	      goto success;
	    else
	      goto success_in_beg_and_len;
	  } /* for (try) */
      else
	goto success;
    } /* for (beg in buf) */

 failure:
  ret_val = -1;
  goto out;

 success:
  if ((end = memchr (beg + len, eol, (buf + size) - (beg + len))) != NULL)
    end++;
  else
    end = buf + size;
  while (buf < beg && beg[-1] != eol)
    --beg;
  len = end - beg;
 success_in_beg_and_len:
  *match_size = len;
  ret_val = beg - buf;
 out:
  return ret_val;
}
#endif /* defined(GREP_PROGRAM) || defined(FGREP_PROGRAM) */

#ifdef GREP_PROGRAM
#if HAVE_LIBPCRE
/* Compiled internal form of a Perl regular expression.  */
static pcre *cre;

/* Additional information about the pattern.  */
static pcre_extra *extra;
#endif

COMPILE_FCT(Pcompile)
{
#if !HAVE_LIBPCRE
  error (EXIT_TROUBLE, 0, "%s",
	 _("support for the -P option is not compiled into "
	   "this --disable-perl-regexp binary"));
#else
  int e;
  char const *ep;
  char *re = xmalloc (4 * size + 7);
  int flags = PCRE_MULTILINE | (match_icase ? PCRE_CASELESS : 0);
  char const *patlim = pattern + size;
  char *n = re;
  char const *p;
  char const *pnul;

  /* FIXME: Remove these restrictions.  */
  if (memchr(pattern, '\n', size))
    error (EXIT_TROUBLE, 0, _("the -P option only supports a single pattern"));

  *n = '\0';
  if (match_lines)
    strcpy (n, "^(");
  if (match_words)
    strcpy (n, "\\b(");
  n += strlen (n);

  /* The PCRE interface doesn't allow NUL bytes in the pattern, so
     replace each NUL byte in the pattern with the four characters
     "\000", removing a preceding backslash if there are an odd
     number of backslashes before the NUL.

     FIXME: This method does not work with some multibyte character
     encodings, notably Shift-JIS, where a multibyte character can end
     in a backslash byte.  */
  for (p = pattern; (pnul = memchr (p, '\0', patlim - p)); p = pnul + 1)
    {
      memcpy (n, p, pnul - p);
      n += pnul - p;
      for (p = pnul; pattern < p && p[-1] == '\\'; p--)
	continue;
      n -= (pnul - p) & 1;
      strcpy (n, "\\000");
      n += 4;
    }

  memcpy (n, p, patlim - p);
  n += patlim - p;
  *n = '\0';
  if (match_words)
    strcpy (n, ")\\b");
  if (match_lines)
    strcpy (n, ")$");

  cre = pcre_compile (re, flags, &ep, &e, pcre_maketables ());
  if (!cre)
    error (EXIT_TROUBLE, 0, "%s", ep);

  extra = pcre_study (cre, 0, &ep);
  if (ep)
    error (EXIT_TROUBLE, 0, "%s", ep);

  free (re);
#endif
}

EXECUTE_FCT(Pexecute)
{
#if !HAVE_LIBPCRE
  abort ();
  return -1;
#else
  /* This array must have at least two elements; everything after that
     is just for performance improvement in pcre_exec.  */
  int sub[300];

  const char *line_buf, *line_end, *line_next;
  int e = PCRE_ERROR_NOMATCH;
  ptrdiff_t start_ofs = start_ptr ? start_ptr - buf : 0;

  /* PCRE can't limit the matching to single lines, therefore we have to
     match each line in the buffer separately.  */
  for (line_next = buf;
       e == PCRE_ERROR_NOMATCH && line_next < buf + size;
       start_ofs -= line_next - line_buf)
    {
      line_buf = line_next;
      line_end = memchr (line_buf, eolbyte, (buf + size) - line_buf);
      if (line_end == NULL)
        line_next = line_end = buf + size;
      else
        line_next = line_end + 1;

      if (start_ptr && start_ptr >= line_end)
        continue;

      e = pcre_exec (cre, extra, line_buf, line_end - line_buf,
                     start_ofs < 0 ? 0 : start_ofs, 0,
                     sub, sizeof sub / sizeof *sub);
    }

  if (e <= 0)
    {
      switch (e)
	{
	case PCRE_ERROR_NOMATCH:
	  return -1;

	case PCRE_ERROR_NOMEMORY:
	  error (EXIT_TROUBLE, 0, _("memory exhausted"));

	default:
	  abort ();
	}
    }
  else
    {
      /* Narrow down to the line we've found.  */
      char const *beg = line_buf + sub[0];
      char const *end = line_buf + sub[1];
      char const *buflim = buf + size;
      char eol = eolbyte;
      if (!start_ptr)
	{
	  /* FIXME: The case when '\n' is not found indicates a bug:
	     Since grep is line oriented, the match should never contain
	     a newline, so there _must_ be a newline following.
	   */
	  if (!(end = memchr (end, eol, buflim - end)))
	    end = buflim;
	  else
	    end++;
	  while (buf < beg && beg[-1] != eol)
	    --beg;
	}

      *match_size = end - beg;
      return beg - buf;
    }
#endif
}

struct matcher const matchers[] = {
  { "default", Gcompile, EGexecute },
  { "grep",    Gcompile, EGexecute },
  { "egrep",   Ecompile, EGexecute },
  { "awk",     Acompile, EGexecute },
  { "fgrep",   Fcompile, Fexecute },
  { "perl",    Pcompile, Pexecute },
  { "", 0, 0 },
};
#endif /* GREP_PROGRAM */

Trying a synthesis expr 1
Skipping a synthesis:1
Trying a synthesis expr err == 0
Building:src at:
/home/ubuntu/spr-fast/tests/corebench/grep/grep-case-deccad69-db9d6340/tempworkdir2/srcVerifing Negative cases!
Running test command:
/home/ubuntu/spr-fast/tools/grep-test.py /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-deccad69-db9d6340/tempworkdir2/src /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-deccad69-db9d6340/tempworkdir2/tests /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-deccad69-db9d6340/tempworkdir2 0  > __res
Verifying positive cases
Running test command:
/home/ubuntu/spr-fast/tools/grep-test.py /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-deccad69-db9d6340/tempworkdir2/src /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-deccad69-db9d6340/tempworkdir2/tests /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-deccad69-db9d6340/tempworkdir2 9  > __res
Failed positive case 9
Not passed!
Trying a synthesis expr match_icase == 0
Building:src at:
/home/ubuntu/spr-fast/tests/corebench/grep/grep-case-deccad69-db9d6340/tempworkdir2/srcVerifing Negative cases!
Running test command:
/home/ubuntu/spr-fast/tools/grep-test.py /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-deccad69-db9d6340/tempworkdir2/src /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-deccad69-db9d6340/tempworkdir2/tests /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-deccad69-db9d6340/tempworkdir2 0  > __res
Verifying positive cases
Running test command:
/home/ubuntu/spr-fast/tools/grep-test.py /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-deccad69-db9d6340/tempworkdir2/src /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-deccad69-db9d6340/tempworkdir2/tests /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-deccad69-db9d6340/tempworkdir2 9  > __res
Failed positive case 9
Not passed!
Trying a synthesis expr psize != 0
Building:src at:
/home/ubuntu/spr-fast/tests/corebench/grep/grep-case-deccad69-db9d6340/tempworkdir2/srcVerifing Negative cases!
Running test command:
/home/ubuntu/spr-fast/tools/grep-test.py /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-deccad69-db9d6340/tempworkdir2/src /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-deccad69-db9d6340/tempworkdir2/tests /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-deccad69-db9d6340/tempworkdir2 0  > __res
Verifying positive cases
Running test command:
/home/ubuntu/spr-fast/tools/grep-test.py /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-deccad69-db9d6340/tempworkdir2/src /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-deccad69-db9d6340/tempworkdir2/tests /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-deccad69-db9d6340/tempworkdir2 9  > __res
Failed positive case 9
Not passed!
Trying a synthesis expr size != 0
Building:src at:
/home/ubuntu/spr-fast/tests/corebench/grep/grep-case-deccad69-db9d6340/tempworkdir2/srcVerifing Negative cases!
Running test command:
/home/ubuntu/spr-fast/tools/grep-test.py /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-deccad69-db9d6340/tempworkdir2/src /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-deccad69-db9d6340/tempworkdir2/tests /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-deccad69-db9d6340/tempworkdir2 0  > __res
Verifying positive cases
Running test command:
/home/ubuntu/spr-fast/tools/grep-test.py /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-deccad69-db9d6340/tempworkdir2/src /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-deccad69-db9d6340/tempworkdir2/tests /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-deccad69-db9d6340/tempworkdir2 9  > __res
Failed positive case 9
Not passed!
Trying a synthesis expr psize == 2
Building:src at:
/home/ubuntu/spr-fast/tests/corebench/grep/grep-case-deccad69-db9d6340/tempworkdir2/srcVerifing Negative cases!
Running test command:
/home/ubuntu/spr-fast/tools/grep-test.py /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-deccad69-db9d6340/tempworkdir2/src /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-deccad69-db9d6340/tempworkdir2/tests /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-deccad69-db9d6340/tempworkdir2 0  > __res
Verifying positive cases
Running test command:
/home/ubuntu/spr-fast/tools/grep-test.py /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-deccad69-db9d6340/tempworkdir2/src /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-deccad69-db9d6340/tempworkdir2/tests /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-deccad69-db9d6340/tempworkdir2 9  > __res
Running test command:
/home/ubuntu/spr-fast/tools/grep-test.py /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-deccad69-db9d6340/tempworkdir2/src /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-deccad69-db9d6340/tempworkdir2/tests /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-deccad69-db9d6340/tempworkdir2 12  > __res
Failed positive case 12
Not passed!
Trying a synthesis expr size == 2
Building:src at:
/home/ubuntu/spr-fast/tests/corebench/grep/grep-case-deccad69-db9d6340/tempworkdir2/srcVerifing Negative cases!
Running test command:
/home/ubuntu/spr-fast/tools/grep-test.py /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-deccad69-db9d6340/tempworkdir2/src /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-deccad69-db9d6340/tempworkdir2/tests /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-deccad69-db9d6340/tempworkdir2 0  > __res
Verifying positive cases
Running test command:
/home/ubuntu/spr-fast/tools/grep-test.py /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-deccad69-db9d6340/tempworkdir2/src /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-deccad69-db9d6340/tempworkdir2/tests /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-deccad69-db9d6340/tempworkdir2 9  > __res
Running test command:
/home/ubuntu/spr-fast/tools/grep-test.py /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-deccad69-db9d6340/tempworkdir2/src /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-deccad69-db9d6340/tempworkdir2/tests /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-deccad69-db9d6340/tempworkdir2 12  > __res
Failed positive case 12
Not passed!
Trying a synthesis expr psize != 1
Building:src at:
/home/ubuntu/spr-fast/tests/corebench/grep/grep-case-deccad69-db9d6340/tempworkdir2/srcVerifing Negative cases!
Running test command:
/home/ubuntu/spr-fast/tools/grep-test.py /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-deccad69-db9d6340/tempworkdir2/src /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-deccad69-db9d6340/tempworkdir2/tests /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-deccad69-db9d6340/tempworkdir2 0  > __res
Verifying positive cases
Running test command:
/home/ubuntu/spr-fast/tools/grep-test.py /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-deccad69-db9d6340/tempworkdir2/src /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-deccad69-db9d6340/tempworkdir2/tests /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-deccad69-db9d6340/tempworkdir2 9  > __res
Failed positive case 9
Not passed!
Trying a synthesis expr psize != 4
Building:src at:
/home/ubuntu/spr-fast/tests/corebench/grep/grep-case-deccad69-db9d6340/tempworkdir2/srcVerifing Negative cases!
Running test command:
/home/ubuntu/spr-fast/tools/grep-test.py /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-deccad69-db9d6340/tempworkdir2/src /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-deccad69-db9d6340/tempworkdir2/tests /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-deccad69-db9d6340/tempworkdir2 0  > __res
Verifying positive cases
Running test command:
/home/ubuntu/spr-fast/tools/grep-test.py /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-deccad69-db9d6340/tempworkdir2/src /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-deccad69-db9d6340/tempworkdir2/tests /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-deccad69-db9d6340/tempworkdir2 9  > __res
Failed positive case 9
Not passed!
Trying a synthesis expr psize != 5
Building:src at:
/home/ubuntu/spr-fast/tests/corebench/grep/grep-case-deccad69-db9d6340/tempworkdir2/srcVerifing Negative cases!
Running test command:
/home/ubuntu/spr-fast/tools/grep-test.py /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-deccad69-db9d6340/tempworkdir2/src /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-deccad69-db9d6340/tempworkdir2/tests /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-deccad69-db9d6340/tempworkdir2 0  > __res
Verifying positive cases
Running test command:
/home/ubuntu/spr-fast/tools/grep-test.py /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-deccad69-db9d6340/tempworkdir2/src /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-deccad69-db9d6340/tempworkdir2/tests /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-deccad69-db9d6340/tempworkdir2 9  > __res
Failed positive case 9
Not passed!
Trying a synthesis expr psize != 6
Building:src at:
/home/ubuntu/spr-fast/tests/corebench/grep/grep-case-deccad69-db9d6340/tempworkdir2/srcVerifing Negative cases!
Running test command:
/home/ubuntu/spr-fast/tools/grep-test.py /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-deccad69-db9d6340/tempworkdir2/src /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-deccad69-db9d6340/tempworkdir2/tests /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-deccad69-db9d6340/tempworkdir2 0  > __res
Verifying positive cases
Running test command:
/home/ubuntu/spr-fast/tools/grep-test.py /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-deccad69-db9d6340/tempworkdir2/src /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-deccad69-db9d6340/tempworkdir2/tests /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-deccad69-db9d6340/tempworkdir2 9  > __res
Failed positive case 9
Not passed!
Trying a synthesis expr psize != 9
Building:src at:
/home/ubuntu/spr-fast/tests/corebench/grep/grep-case-deccad69-db9d6340/tempworkdir2/srcVerifing Negative cases!
Running test command:
/home/ubuntu/spr-fast/tools/grep-test.py /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-deccad69-db9d6340/tempworkdir2/src /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-deccad69-db9d6340/tempworkdir2/tests /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-deccad69-db9d6340/tempworkdir2 0  > __res
Verifying positive cases
Running test command:
/home/ubuntu/spr-fast/tools/grep-test.py /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-deccad69-db9d6340/tempworkdir2/src /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-deccad69-db9d6340/tempworkdir2/tests /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-deccad69-db9d6340/tempworkdir2 9  > __res
Failed positive case 9
Not passed!
Trying a synthesis expr match_icase != 1
Building:src at:
/home/ubuntu/spr-fast/tests/corebench/grep/grep-case-deccad69-db9d6340/tempworkdir2/srcVerifing Negative cases!
Running test command:
/home/ubuntu/spr-fast/tools/grep-test.py /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-deccad69-db9d6340/tempworkdir2/src /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-deccad69-db9d6340/tempworkdir2/tests /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-deccad69-db9d6340/tempworkdir2 0  > __res
Verifying positive cases
Running test command:
/home/ubuntu/spr-fast/tools/grep-test.py /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-deccad69-db9d6340/tempworkdir2/src /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-deccad69-db9d6340/tempworkdir2/tests /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-deccad69-db9d6340/tempworkdir2 9  > __res
Failed positive case 9
Not passed!
Trying a synthesis expr size != 1
Building:src at:
/home/ubuntu/spr-fast/tests/corebench/grep/grep-case-deccad69-db9d6340/tempworkdir2/srcVerifing Negative cases!
Running test command:
/home/ubuntu/spr-fast/tools/grep-test.py /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-deccad69-db9d6340/tempworkdir2/src /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-deccad69-db9d6340/tempworkdir2/tests /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-deccad69-db9d6340/tempworkdir2 0  > __res
Verifying positive cases
Running test command:
/home/ubuntu/spr-fast/tools/grep-test.py /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-deccad69-db9d6340/tempworkdir2/src /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-deccad69-db9d6340/tempworkdir2/tests /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-deccad69-db9d6340/tempworkdir2 9  > __res
Failed positive case 9
Not passed!
Trying a synthesis expr size != 4
Building:src at:
/home/ubuntu/spr-fast/tests/corebench/grep/grep-case-deccad69-db9d6340/tempworkdir2/srcVerifing Negative cases!
Running test command:
/home/ubuntu/spr-fast/tools/grep-test.py /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-deccad69-db9d6340/tempworkdir2/src /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-deccad69-db9d6340/tempworkdir2/tests /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-deccad69-db9d6340/tempworkdir2 0  > __res
Verifying positive cases
Running test command:
/home/ubuntu/spr-fast/tools/grep-test.py /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-deccad69-db9d6340/tempworkdir2/src /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-deccad69-db9d6340/tempworkdir2/tests /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-deccad69-db9d6340/tempworkdir2 9  > __res
Failed positive case 9
Not passed!
Trying a synthesis expr size != 5
Building:src at:
/home/ubuntu/spr-fast/tests/corebench/grep/grep-case-deccad69-db9d6340/tempworkdir2/srcVerifing Negative cases!
Running test command:
/home/ubuntu/spr-fast/tools/grep-test.py /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-deccad69-db9d6340/tempworkdir2/src /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-deccad69-db9d6340/tempworkdir2/tests /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-deccad69-db9d6340/tempworkdir2 0  > __res
Verifying positive cases
Running test command:
/home/ubuntu/spr-fast/tools/grep-test.py /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-deccad69-db9d6340/tempworkdir2/src /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-deccad69-db9d6340/tempworkdir2/tests /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-deccad69-db9d6340/tempworkdir2 9  > __res
Failed positive case 9
Not passed!
Trying a synthesis expr size != 6
Building:src at:
/home/ubuntu/spr-fast/tests/corebench/grep/grep-case-deccad69-db9d6340/tempworkdir2/srcVerifing Negative cases!
Running test command:
/home/ubuntu/spr-fast/tools/grep-test.py /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-deccad69-db9d6340/tempworkdir2/src /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-deccad69-db9d6340/tempworkdir2/tests /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-deccad69-db9d6340/tempworkdir2 0  > __res
Verifying positive cases
Running test command:
/home/ubuntu/spr-fast/tools/grep-test.py /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-deccad69-db9d6340/tempworkdir2/src /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-deccad69-db9d6340/tempworkdir2/tests /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-deccad69-db9d6340/tempworkdir2 9  > __res
Failed positive case 9
Not passed!
Trying a synthesis expr size != 9
Building:src at:
/home/ubuntu/spr-fast/tests/corebench/grep/grep-case-deccad69-db9d6340/tempworkdir2/srcVerifing Negative cases!
Running test command:
/home/ubuntu/spr-fast/tools/grep-test.py /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-deccad69-db9d6340/tempworkdir2/src /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-deccad69-db9d6340/tempworkdir2/tests /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-deccad69-db9d6340/tempworkdir2 0  > __res
Verifying positive cases
Running test command:
/home/ubuntu/spr-fast/tools/grep-test.py /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-deccad69-db9d6340/tempworkdir2/src /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-deccad69-db9d6340/tempworkdir2/tests /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-deccad69-db9d6340/tempworkdir2 9  > __res
Failed positive case 9
Not passed!
Initial synthesize failed, final attempt
Skipping two clauses!(1) &&(0)
Found a clause! ((err = kwsprep(kwset)) != ((void *)0)) 
Skipping a clause! ((err = kwsprep(kwset)) != ((void *)0)) 
Postprocessing failed!
a batched test job starts!
Building merged code:
src_file: src/search.c
full src: int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
/* search.c - searching subroutines using dfa, kwset and regex for grep.
   Copyright 1992, 1998, 2000, 2007, 2009-2010 Free Software Foundation, Inc.

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 3, or (at your option)
   any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program; if not, write to the Free Software
   Foundation, Inc., 51 Franklin Street - Fifth Floor, Boston, MA
   02110-1301, USA.  */

/* Written August 1992 by Mike Haertel. */

#include <config.h>

#include <sys/types.h>

#include "mbsupport.h"
#ifdef MBS_SUPPORT
/* We can handle multibyte strings. */
# include <wchar.h>
# include <wctype.h>
#endif

#include "system.h"
#include "grep.h"
#ifndef FGREP_PROGRAM
# include <regex.h>
# include "dfa.h"
#endif
#include "kwset.h"
#include "error.h"
#include "xalloc.h"
#ifdef HAVE_LIBPCRE
# include <pcre.h>
#endif

#define NCHAR (UCHAR_MAX + 1)

/* For -w, we also consider _ to be word constituent.  */
#define WCHAR(C) (ISALNUM(C) || (C) == '_')

/* KWset compiled pattern.  For Ecompile and Gcompile, we compile
   a list of strings, at least one of which is known to occur in
   any string matching the regexp. */
static kwset_t kwset;

static void
kwsinit (void)
{
  static char trans[NCHAR];
  int i;

  if (match_icase && MB_CUR_MAX == 1)
    {
      for (i = 0; i < NCHAR; ++i)
        trans[i] = TOLOWER (i);

      kwset = kwsalloc (trans);
    }
  else
    kwset = kwsalloc (NULL);

  if (!kwset)
    xalloc_die ();
}

#ifdef MBS_SUPPORT
/* Convert the *N-byte string, BEG, to lowercase, and write the
   NUL-terminated result into malloc'd storage.  Upon success, set *N
   to the length (in bytes) of the resulting string (not including the
   trailing NUL byte), and return a pointer to the lowercase string.
   Upon memory allocation failure, this function exits.

   Note that while this function returns a pointer to malloc'd storage,
   the caller must not free it, since this function retains a pointer
   to the buffer and reuses it on any subsequent call.  As a consequence,
   this function is not thread-safe.  */
static char *
mbtolower (const char *beg, size_t *n)
{
  static char *out;
  static size_t outalloc;
  size_t outlen, mb_cur_max;
  mbstate_t is, os;
  const char *end;
  char *p;

  if (*n > outalloc)
    {
      out = xrealloc (out, *n);
      outalloc = *n;
    }

  memset (&is, 0, sizeof (is));
  memset (&os, 0, sizeof (os));
  end = beg + *n;

  mb_cur_max = MB_CUR_MAX;
  p = out;
  outlen = 0;
  while (beg < end)
    {
      wchar_t wc;
      size_t mbclen = mbrtowc(&wc, beg, end - beg, &is);
      if (outlen + mb_cur_max >= outalloc)
        {
          out = x2nrealloc (out, &outalloc, 1);
          p = out + outlen;
        }

      if (mbclen == (size_t) -1 || mbclen == (size_t) -2 || mbclen == 0)
        {
          /* An invalid sequence, or a truncated multi-octet character.
             We treat it as a single-octet character.  */
          *p++ = *beg++;
          outlen++;
          memset (&is, 0, sizeof (is));
          memset (&os, 0, sizeof (os));
        }
      else
        {
          beg += mbclen;
          mbclen = wcrtomb (p, towlower ((wint_t) wc), &os);
          p += mbclen;
          outlen += mbclen;
        }
    }

  *n = p - out;
  *p++ = 0;
  return out;
}
#endif


#ifndef FGREP_PROGRAM
/* DFA compiled regexp. */
static struct dfa dfa;

/* The Regex compiled patterns.  */
static struct patterns
{
  /* Regex compiled regexp. */
  struct re_pattern_buffer regexbuf;
  struct re_registers regs; /* This is here on account of a BRAIN-DEAD
			       Q@#%!# library interface in regex.c.  */
} patterns0;

struct patterns *patterns;
size_t pcount;

void
dfaerror (char const *mesg)
{
  error (EXIT_TROUBLE, 0, "%s", mesg);
}

/* Number of compiled fixed strings known to exactly match the regexp.
   If kwsexec returns < kwset_exact_matches, then we don't need to
   call the regexp matcher at all. */
static int kwset_exact_matches;

static char const *
kwsincr_case (const char *must)
{
  const char *buf;
  size_t n;

  n = strlen (must);
#ifdef MBS_SUPPORT
  if (match_icase && MB_CUR_MAX > 1)
    buf = mbtolower (must, &n);
  else
#endif
    buf = must;
  return kwsincr (kwset, buf, n);
}

/* If the DFA turns out to have some set of fixed strings one of
   which must occur in the match, then we build a kwset matcher
   to find those strings, and thus quickly filter out impossible
   matches. */
static void
kwsmusts (void)
{
  struct dfamust const *dm;
  char const *err;

  if (dfa.musts)
    {
      kwsinit ();
      /* First, we compile in the substrings known to be exact
	 matches.  The kwset matcher will return the index
	 of the matching string that it chooses. */
      for (dm = dfa.musts; dm; dm = dm->next)
	{
	  if (!dm->exact)
	    continue;
	  ++kwset_exact_matches;
	  if ((err = kwsincr_case (dm->must)) != NULL)
	    error (EXIT_TROUBLE, 0, "%s", err);
	}
      /* Now, we compile the substrings that will require
	 the use of the regexp matcher.  */
      for (dm = dfa.musts; dm; dm = dm->next)
	{
	  if (dm->exact)
	    continue;
	  if ((err = kwsincr_case (dm->must)) != NULL)
	    error (EXIT_TROUBLE, 0, "%s", err);
	}
      if ((err = kwsprep (kwset)) != NULL)
	error (EXIT_TROUBLE, 0, "%s", err);
    }
}
#endif /* !FGREP_PROGRAM */

#ifdef MBS_SUPPORT

static bool
is_mb_middle(const char **good, const char *buf, const char *end)
{
  const char *p = *good;
  const char *prev = p;
  mbstate_t cur_state;

  /* TODO: can be optimized for UTF-8.  */
  memset(&cur_state, 0, sizeof(mbstate_t));
  while (p < buf)
    {
      size_t mbclen = mbrlen(p, end - p, &cur_state);

      /* Store the beginning of the previous complete multibyte character.  */
      if (mbclen != (size_t) -2)
        prev = p;

      if (mbclen == (size_t) -1 || mbclen == (size_t) -2 || mbclen == 0)
	{
	  /* An invalid sequence, or a truncated multibyte character.
	     We treat it as a single byte character.  */
	  mbclen = 1;
	}
      p += mbclen;
    }

  *good = prev;
  return p > buf;
}
#endif /* MBS_SUPPORT */

#if defined(GREP_PROGRAM) || defined(EGREP_PROGRAM)
#ifdef EGREP_PROGRAM
COMPILE_FCT(Ecompile)
{
  reg_syntax_t syntax_bits = RE_SYNTAX_POSIX_EGREP;
#else
/* No __VA_ARGS__ in C89.  So we have to do it this way.  */
static COMPILE_RET
GEAcompile (char const *pattern, size_t size, reg_syntax_t syntax_bits)
{
#endif /* EGREP_PROGRAM */
  const char *err;
  const char *p, *sep;
  size_t total = size;
  char *motif;

  if (match_icase)
    syntax_bits |= RE_ICASE;
  re_set_syntax (syntax_bits);
  dfasyntax (syntax_bits, match_icase, eolbyte);

  /* For GNU regex compiler we have to pass the patterns separately to detect
     errors like "[\nallo\n]\n".  The patterns here are "[", "allo" and "]"
     GNU regex should have raise a syntax error.  The same for backref, where
     the backref should have been local to each pattern.  */
  p = pattern;
  do
    {
      size_t len;
      sep = memchr (p, '\n', total);
      if (sep)
	{
	  len = sep - p;
	  sep++;
	  total -= (len + 1);
	}
      else
	{
	  len = total;
	  total = 0;
	}

      patterns = realloc (patterns, (pcount + 1) * sizeof (*patterns));
      if (patterns == NULL)
	error (EXIT_TROUBLE, errno, _("memory exhausted"));
      patterns[pcount] = patterns0;

      if ((err = re_compile_pattern (p, len,
				    &(patterns[pcount].regexbuf))) != NULL)
	error (EXIT_TROUBLE, 0, "%s", err);
      pcount++;

      p = sep;
    } while (sep && total != 0);

  /* In the match_words and match_lines cases, we use a different pattern
     for the DFA matcher that will quickly throw out cases that won't work.
     Then if DFA succeeds we do some hairy stuff using the regex matcher
     to decide whether the match should really count. */
  if (match_words || match_lines)
    {
      static char const line_beg_no_bk[] = "^(";
      static char const line_end_no_bk[] = ")$";
      static char const word_beg_no_bk[] = "(^|[^[:alnum:]_])(";
      static char const word_end_no_bk[] = ")([^[:alnum:]_]|$)";
#ifdef EGREP_PROGRAM
# define IF_BK(x, y) (y)
      char *n = xmalloc (sizeof word_beg_no_bk - 1 + size + sizeof word_end_no_bk);
#else
      static char const line_beg_bk[] = "^\\(";
      static char const line_end_bk[] = "\\)$";
      static char const word_beg_bk[] = "\\(^\\|[^[:alnum:]_]\\)\\(";
      static char const word_end_bk[] = "\\)\\([^[:alnum:]_]\\|$\\)";
      int bk = !(syntax_bits & RE_NO_BK_PARENS);
# define IF_BK(x, y) ((bk) ? (x) : (y))
      char *n = xmalloc (sizeof word_beg_bk - 1 + size + sizeof word_end_bk);
#endif /* EGREP_PROGRAM */

      strcpy (n, match_lines ? IF_BK(line_beg_bk, line_beg_no_bk)
			     : IF_BK(word_beg_bk, word_beg_no_bk));
      total = strlen(n);
      memcpy (n + total, pattern, size);
      total += size;
      strcpy (n + total, match_lines ? IF_BK(line_end_bk, line_end_no_bk)
				     : IF_BK(word_end_bk, word_end_no_bk));
      total += strlen (n + total);
      pattern = motif = n;
      size = total;
    }
  else
    motif = NULL;

  dfacomp (pattern, size, &dfa, 1);
  kwsmusts ();

  free(motif);
}

#ifndef EGREP_PROGRAM
COMPILE_FCT(Gcompile)
{
  return GEAcompile (pattern, size,
		     RE_SYNTAX_GREP | RE_HAT_LISTS_NOT_NEWLINE);
}

COMPILE_FCT(Acompile)
{
  return GEAcompile (pattern, size, RE_SYNTAX_AWK);
}

COMPILE_FCT(Ecompile)
{
  return GEAcompile (pattern, size, RE_SYNTAX_POSIX_EGREP);
}
#endif /* !EGREP_PROGRAM */

EXECUTE_FCT(EGexecute)
{
  char const *buflim, *beg, *end, *match, *best_match, *mb_start;
  char eol = eolbyte;
  int backref, start, len, best_len;
  struct kwsmatch kwsm;
  size_t i, ret_val;
#ifdef MBS_SUPPORT
  if (MB_CUR_MAX > 1)
    {
      if (match_icase)
        {
          /* mbtolower adds a NUL byte at the end.  That will provide
	     space for the sentinel byte dfaexec may add.  */
          char *case_buf = mbtolower (buf, &size);
	  if (start_ptr)
	    start_ptr = case_buf + (start_ptr - buf);
          buf = case_buf;
        }
    }
#endif /* MBS_SUPPORT */

  mb_start = buf;
  buflim = buf + size;

  for (beg = end = buf; end < buflim; beg = end)
    {
      if (!start_ptr)
	{
	  /* We don't care about an exact match.  */
	  if (kwset)
	    {
	      /* Find a possible match using the KWset matcher. */
	      size_t offset = kwsexec (kwset, beg, buflim - beg, &kwsm);
	      if (offset == (size_t) -1)
		goto failure;
	      beg += offset;
	      /* Narrow down to the line containing the candidate, and
		 run it through DFA. */
	      if ((end = memchr(beg, eol, buflim - beg)) != NULL)
	        end++;
              else
                end = buflim;
	      match = beg;
	      while (beg > buf && beg[-1] != eol)
		--beg;
	      if (kwsm.index < kwset_exact_matches)
                {
#ifdef MBS_SUPPORT
                  if (mb_start < beg)
                    mb_start = beg;
                  if (MB_CUR_MAX == 1 || !is_mb_middle (&mb_start, match, buflim))
#endif
                    goto success;
                }
	      if (dfaexec (&dfa, beg, (char *) end, 0, NULL, &backref) == NULL)
		continue;
	    }
	  else
	    {
	      /* No good fixed strings; start with DFA. */
	      char const *next_beg = dfaexec (&dfa, beg, (char *) buflim,
					      0, NULL, &backref);
	      if (next_beg == NULL)
		break;
	      /* Narrow down to the line we've found. */
	      beg = next_beg;
	      if ((end = memchr(beg, eol, buflim - beg)) != NULL)
	        end++;
              else
                end = buflim;
	      while (beg > buf && beg[-1] != eol)
		--beg;
	    }
	  /* Successful, no backreferences encountered! */
	  if (!backref)
	    goto success;
	}
      else
	{
	  /* We are looking for the leftmost (then longest) exact match.
	     We will go through the outer loop only once.  */
	  beg = start_ptr;
	  end = buflim;
	}

      /* If we've made it to this point, this means DFA has seen
	 a probable match, and we need to run it through Regex. */
      best_match = end;
      best_len = 0;
      for (i = 0; i < pcount; i++)
	{
	  patterns[i].regexbuf.not_eol = 0;
	  if (0 <= (start = re_search (&(patterns[i].regexbuf),
				       buf, end - buf - 1,
				       beg - buf, end - beg - 1,
				       &(patterns[i].regs))))
	    {
	      len = patterns[i].regs.end[0] - start;
	      match = buf + start;
	      if (match > best_match)
		continue;
	      if (start_ptr && !match_words)
		goto assess_pattern_match;
	      if ((!match_lines && !match_words)
		  || (match_lines && len == end - beg - 1))
		{
		  match = beg;
		  len = end - beg;
		  goto assess_pattern_match;
		}
	      /* If -w, check if the match aligns with word boundaries.
		 We do this iteratively because:
		 (a) the line may contain more than one occurence of the
		 pattern, and
		 (b) Several alternatives in the pattern might be valid at a
		 given point, and we may need to consider a shorter one to
		 find a word boundary.  */
	      if (match_words)
		while (match <= best_match)
		  {
		    if ((match == buf || !WCHAR ((unsigned char) match[-1]))
			&& (len == end - beg - 1
			    || !WCHAR ((unsigned char) match[len])))
		      goto assess_pattern_match;
		    if (len > 0)
		      {
			/* Try a shorter length anchored at the same place. */
			--len;
			patterns[i].regexbuf.not_eol = 1;
			len = re_match (&(patterns[i].regexbuf),
					buf, match + len - beg, match - buf,
					&(patterns[i].regs));
		      }
		    if (len <= 0)
		      {
			/* Try looking further on. */
			if (match == end - 1)
			  break;
			match++;
			patterns[i].regexbuf.not_eol = 0;
			start = re_search (&(patterns[i].regexbuf),
					   buf, end - buf - 1,
					   match - buf, end - match - 1,
					   &(patterns[i].regs));
			if (start < 0)
			  break;
			len = patterns[i].regs.end[0] - start;
			match = buf + start;
		      }
		  } /* while (match <= best_match) */
	      continue;
	    assess_pattern_match:
	      if (!start_ptr)
		{
		  /* Good enough for a non-exact match.
		     No need to look at further patterns, if any.  */
		  beg = match;
		  goto success_in_len;
		}
	      if (match < best_match || (match == best_match && len > best_len))
		{
		  /* Best exact match:  leftmost, then longest.  */
		  best_match = match;
		  best_len = len;
		}
	    } /* if re_search >= 0 */
	} /* for Regex patterns.  */
	if (best_match < end)
	  {
	    /* We have found an exact match.  We were just
	       waiting for the best one (leftmost then longest).  */
	    beg = best_match;
	    len = best_len;
	    goto success_in_len;
	  }
    } /* for (beg = end ..) */

 failure:
  ret_val = -1;
  goto out;

 success:
  len = end - beg;
 success_in_len:
  *match_size = len;
  ret_val = beg - buf;
 out:
  return ret_val;
}
#endif /* defined(GREP_PROGRAM) || defined(EGREP_PROGRAM) */

#if defined(GREP_PROGRAM) || defined(FGREP_PROGRAM)
COMPILE_FCT(Fcompile)
{
  char const *beg, *end, *lim, *err, *pat;
  size_t psize;

  kwsinit ();
  psize = size;
  if (match_icase && MB_CUR_MAX > 1)
    pat = mbtolower (pattern, &psize);
  else
    pat = pattern;

  beg = pat;
  do
    {
      for (lim = beg;; ++lim)
	{
	  end = lim;
	  if (lim >= pat + psize)
	    break;
	 if (*lim == '\n')
	   {
	     lim++;
	     break;
	   }
#if HAVE_DOS_FILE_CONTENTS
	 if (*lim == '\r' && lim + 1 < pat + psize && lim[1] == '\n')
	   {
	     lim += 2;
	     break;
	   }
#endif
	}

      if ((err = kwsincr (kwset, beg, end - beg)) != NULL)
	error (EXIT_TROUBLE, 0, "%s", err);
      beg = lim;
    }
  while (beg < pat + psize);

  if ((err = kwsprep (kwset)) != NULL)
    error (EXIT_TROUBLE, 0, "%s", err);
}

EXECUTE_FCT(Fexecute)
{
  char const *beg, *try, *end, *mb_start;
  size_t len;
  char eol = eolbyte;
  struct kwsmatch kwsmatch;
  size_t ret_val;
#ifdef MBS_SUPPORT
  //prophet generated patch
  if (__get_mutant()==0) {
  if (((__ctype_get_mb_cur_max()) > 1) && !(__is_neg(16, &(match_icase), sizeof (match_icase), &(buf), sizeof (buf), &(size), sizeof (size), &(eolbyte), sizeof (eolbyte), &(start_ptr), sizeof (start_ptr), &(beg), sizeof (beg), &(mb_start), sizeof (mb_start), &(kwset), sizeof (kwset), &(len), sizeof (len), &(match_words), sizeof (match_words), &(match_lines), sizeof (match_lines), &(eol), sizeof (eol), &(try), sizeof (try), &(ret_val), sizeof (ret_val), &(end), sizeof (end), &(match_size), sizeof (match_size)))) {
      if (match_icase) {
          char *case_buf = mbtolower(buf, &size);
          if (start_ptr)
              start_ptr = case_buf + (start_ptr - buf);
          buf = case_buf;
      }
  }
  }
  else if (__get_mutant()==1) {
  if (((__ctype_get_mb_cur_max()) > 1) || (__is_neg(16, &(match_icase), sizeof (match_icase), &(buf), sizeof (buf), &(size), sizeof (size), &(eolbyte), sizeof (eolbyte), &(start_ptr), sizeof (start_ptr), &(beg), sizeof (beg), &(mb_start), sizeof (mb_start), &(kwset), sizeof (kwset), &(len), sizeof (len), &(match_words), sizeof (match_words), &(match_lines), sizeof (match_lines), &(eol), sizeof (eol), &(try), sizeof (try), &(ret_val), sizeof (ret_val), &(end), sizeof (end), &(match_size), sizeof (match_size)))) {
      if (match_icase) {
          char *case_buf = mbtolower(buf, &size);
          if (start_ptr)
              start_ptr = case_buf + (start_ptr - buf);
          buf = case_buf;
      }
  }
  }
#endif /* MBS_SUPPORT */

  for (mb_start = beg = start_ptr ? start_ptr : buf; beg <= buf + size; beg++)
    {
      size_t offset = kwsexec (kwset, beg, buf + size - beg, &kwsmatch);
      if (offset == (size_t) -1)
	goto failure;
#ifdef MBS_SUPPORT
      if (MB_CUR_MAX > 1 && is_mb_middle (&mb_start, beg + offset, buf + size))
        {
          beg = mb_start - 1;
          continue; /* It is a part of multibyte character.  */
        }
#endif /* MBS_SUPPORT */
      beg += offset;
      len = kwsmatch.size[0];
      if (start_ptr && !match_words)
	goto success_in_beg_and_len;
      if (match_lines)
	{
	  if (beg > buf && beg[-1] != eol)
	    continue;
	  if (beg + len < buf + size && beg[len] != eol)
	    continue;
	  goto success;
	}
      else if (match_words)
	for (try = beg; len; )
	  {
	    if (try > buf && WCHAR((unsigned char) try[-1]))
	      break;
	    if (try + len < buf + size && WCHAR((unsigned char) try[len]))
	      {
		offset = kwsexec (kwset, beg, --len, &kwsmatch);
		if (offset == (size_t) -1)
		  break;
		try = beg + offset;
		len = kwsmatch.size[0];
	      }
	    else if (!start_ptr)
	      goto success;
	    else
	      goto success_in_beg_and_len;
	  } /* for (try) */
      else
	goto success;
    } /* for (beg in buf) */

 failure:
  ret_val = -1;
  goto out;

 success:
  if ((end = memchr (beg + len, eol, (buf + size) - (beg + len))) != NULL)
    end++;
  else
    end = buf + size;
  while (buf < beg && beg[-1] != eol)
    --beg;
  len = end - beg;
 success_in_beg_and_len:
  *match_size = len;
  ret_val = beg - buf;
 out:
  return ret_val;
}
#endif /* defined(GREP_PROGRAM) || defined(FGREP_PROGRAM) */

#ifdef GREP_PROGRAM
#if HAVE_LIBPCRE
/* Compiled internal form of a Perl regular expression.  */
static pcre *cre;

/* Additional information about the pattern.  */
static pcre_extra *extra;
#endif

COMPILE_FCT(Pcompile)
{
#if !HAVE_LIBPCRE
  error (EXIT_TROUBLE, 0, "%s",
	 _("support for the -P option is not compiled into "
	   "this --disable-perl-regexp binary"));
#else
  int e;
  char const *ep;
  char *re = xmalloc (4 * size + 7);
  int flags = PCRE_MULTILINE | (match_icase ? PCRE_CASELESS : 0);
  char const *patlim = pattern + size;
  char *n = re;
  char const *p;
  char const *pnul;

  /* FIXME: Remove these restrictions.  */
  if (memchr(pattern, '\n', size))
    error (EXIT_TROUBLE, 0, _("the -P option only supports a single pattern"));

  *n = '\0';
  if (match_lines)
    strcpy (n, "^(");
  if (match_words)
    strcpy (n, "\\b(");
  n += strlen (n);

  /* The PCRE interface doesn't allow NUL bytes in the pattern, so
     replace each NUL byte in the pattern with the four characters
     "\000", removing a preceding backslash if there are an odd
     number of backslashes before the NUL.

     FIXME: This method does not work with some multibyte character
     encodings, notably Shift-JIS, where a multibyte character can end
     in a backslash byte.  */
  for (p = pattern; (pnul = memchr (p, '\0', patlim - p)); p = pnul + 1)
    {
      memcpy (n, p, pnul - p);
      n += pnul - p;
      for (p = pnul; pattern < p && p[-1] == '\\'; p--)
	continue;
      n -= (pnul - p) & 1;
      strcpy (n, "\\000");
      n += 4;
    }

  memcpy (n, p, patlim - p);
  n += patlim - p;
  *n = '\0';
  if (match_words)
    strcpy (n, ")\\b");
  if (match_lines)
    strcpy (n, ")$");

  cre = pcre_compile (re, flags, &ep, &e, pcre_maketables ());
  if (!cre)
    error (EXIT_TROUBLE, 0, "%s", ep);

  extra = pcre_study (cre, 0, &ep);
  if (ep)
    error (EXIT_TROUBLE, 0, "%s", ep);

  free (re);
#endif
}

EXECUTE_FCT(Pexecute)
{
#if !HAVE_LIBPCRE
  abort ();
  return -1;
#else
  /* This array must have at least two elements; everything after that
     is just for performance improvement in pcre_exec.  */
  int sub[300];

  const char *line_buf, *line_end, *line_next;
  int e = PCRE_ERROR_NOMATCH;
  ptrdiff_t start_ofs = start_ptr ? start_ptr - buf : 0;

  /* PCRE can't limit the matching to single lines, therefore we have to
     match each line in the buffer separately.  */
  for (line_next = buf;
       e == PCRE_ERROR_NOMATCH && line_next < buf + size;
       start_ofs -= line_next - line_buf)
    {
      line_buf = line_next;
      line_end = memchr (line_buf, eolbyte, (buf + size) - line_buf);
      if (line_end == NULL)
        line_next = line_end = buf + size;
      else
        line_next = line_end + 1;

      if (start_ptr && start_ptr >= line_end)
        continue;

      e = pcre_exec (cre, extra, line_buf, line_end - line_buf,
                     start_ofs < 0 ? 0 : start_ofs, 0,
                     sub, sizeof sub / sizeof *sub);
    }

  if (e <= 0)
    {
      switch (e)
	{
	case PCRE_ERROR_NOMATCH:
	  return -1;

	case PCRE_ERROR_NOMEMORY:
	  error (EXIT_TROUBLE, 0, _("memory exhausted"));

	default:
	  abort ();
	}
    }
  else
    {
      /* Narrow down to the line we've found.  */
      char const *beg = line_buf + sub[0];
      char const *end = line_buf + sub[1];
      char const *buflim = buf + size;
      char eol = eolbyte;
      if (!start_ptr)
	{
	  /* FIXME: The case when '\n' is not found indicates a bug:
	     Since grep is line oriented, the match should never contain
	     a newline, so there _must_ be a newline following.
	   */
	  if (!(end = memchr (end, eol, buflim - end)))
	    end = buflim;
	  else
	    end++;
	  while (buf < beg && beg[-1] != eol)
	    --beg;
	}

      *match_size = end - beg;
      return beg - buf;
    }
#endif
}

struct matcher const matchers[] = {
  { "default", Gcompile, EGexecute },
  { "grep",    Gcompile, EGexecute },
  { "egrep",   Ecompile, EGexecute },
  { "awk",     Acompile, EGexecute },
  { "fgrep",   Fcompile, Fexecute },
  { "perl",    Pcompile, Pexecute },
  { "", 0, 0 },
};
#endif /* GREP_PROGRAM */

Building:src at:
/home/ubuntu/spr-fast/tests/corebench/grep/grep-case-deccad69-db9d6340/tempworkdir2/srcMerged code building succ, going to invoke tester!
CondTester, Testing instance id 26:
//src_file:src/search.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
/* search.c - searching subroutines using dfa, kwset and regex for grep.
   Copyright 1992, 1998, 2000, 2007, 2009-2010 Free Software Foundation, Inc.

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 3, or (at your option)
   any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program; if not, write to the Free Software
   Foundation, Inc., 51 Franklin Street - Fifth Floor, Boston, MA
   02110-1301, USA.  */

/* Written August 1992 by Mike Haertel. */

#include <config.h>

#include <sys/types.h>

#include "mbsupport.h"
#ifdef MBS_SUPPORT
/* We can handle multibyte strings. */
# include <wchar.h>
# include <wctype.h>
#endif

#include "system.h"
#include "grep.h"
#ifndef FGREP_PROGRAM
# include <regex.h>
# include "dfa.h"
#endif
#include "kwset.h"
#include "error.h"
#include "xalloc.h"
#ifdef HAVE_LIBPCRE
# include <pcre.h>
#endif

#define NCHAR (UCHAR_MAX + 1)

/* For -w, we also consider _ to be word constituent.  */
#define WCHAR(C) (ISALNUM(C) || (C) == '_')

/* KWset compiled pattern.  For Ecompile and Gcompile, we compile
   a list of strings, at least one of which is known to occur in
   any string matching the regexp. */
static kwset_t kwset;

static void
kwsinit (void)
{
  static char trans[NCHAR];
  int i;

  if (match_icase && MB_CUR_MAX == 1)
    {
      for (i = 0; i < NCHAR; ++i)
        trans[i] = TOLOWER (i);

      kwset = kwsalloc (trans);
    }
  else
    kwset = kwsalloc (NULL);

  if (!kwset)
    xalloc_die ();
}

#ifdef MBS_SUPPORT
/* Convert the *N-byte string, BEG, to lowercase, and write the
   NUL-terminated result into malloc'd storage.  Upon success, set *N
   to the length (in bytes) of the resulting string (not including the
   trailing NUL byte), and return a pointer to the lowercase string.
   Upon memory allocation failure, this function exits.

   Note that while this function returns a pointer to malloc'd storage,
   the caller must not free it, since this function retains a pointer
   to the buffer and reuses it on any subsequent call.  As a consequence,
   this function is not thread-safe.  */
static char *
mbtolower (const char *beg, size_t *n)
{
  static char *out;
  static size_t outalloc;
  size_t outlen, mb_cur_max;
  mbstate_t is, os;
  const char *end;
  char *p;

  if (*n > outalloc)
    {
      out = xrealloc (out, *n);
      outalloc = *n;
    }

  memset (&is, 0, sizeof (is));
  memset (&os, 0, sizeof (os));
  end = beg + *n;

  mb_cur_max = MB_CUR_MAX;
  p = out;
  outlen = 0;
  while (beg < end)
    {
      wchar_t wc;
      size_t mbclen = mbrtowc(&wc, beg, end - beg, &is);
      if (outlen + mb_cur_max >= outalloc)
        {
          out = x2nrealloc (out, &outalloc, 1);
          p = out + outlen;
        }

      if (mbclen == (size_t) -1 || mbclen == (size_t) -2 || mbclen == 0)
        {
          /* An invalid sequence, or a truncated multi-octet character.
             We treat it as a single-octet character.  */
          *p++ = *beg++;
          outlen++;
          memset (&is, 0, sizeof (is));
          memset (&os, 0, sizeof (os));
        }
      else
        {
          beg += mbclen;
          mbclen = wcrtomb (p, towlower ((wint_t) wc), &os);
          p += mbclen;
          outlen += mbclen;
        }
    }

  *n = p - out;
  *p++ = 0;
  return out;
}
#endif


#ifndef FGREP_PROGRAM
/* DFA compiled regexp. */
static struct dfa dfa;

/* The Regex compiled patterns.  */
static struct patterns
{
  /* Regex compiled regexp. */
  struct re_pattern_buffer regexbuf;
  struct re_registers regs; /* This is here on account of a BRAIN-DEAD
			       Q@#%!# library interface in regex.c.  */
} patterns0;

struct patterns *patterns;
size_t pcount;

void
dfaerror (char const *mesg)
{
  error (EXIT_TROUBLE, 0, "%s", mesg);
}

/* Number of compiled fixed strings known to exactly match the regexp.
   If kwsexec returns < kwset_exact_matches, then we don't need to
   call the regexp matcher at all. */
static int kwset_exact_matches;

static char const *
kwsincr_case (const char *must)
{
  const char *buf;
  size_t n;

  n = strlen (must);
#ifdef MBS_SUPPORT
  if (match_icase && MB_CUR_MAX > 1)
    buf = mbtolower (must, &n);
  else
#endif
    buf = must;
  return kwsincr (kwset, buf, n);
}

/* If the DFA turns out to have some set of fixed strings one of
   which must occur in the match, then we build a kwset matcher
   to find those strings, and thus quickly filter out impossible
   matches. */
static void
kwsmusts (void)
{
  struct dfamust const *dm;
  char const *err;

  if (dfa.musts)
    {
      kwsinit ();
      /* First, we compile in the substrings known to be exact
	 matches.  The kwset matcher will return the index
	 of the matching string that it chooses. */
      for (dm = dfa.musts; dm; dm = dm->next)
	{
	  if (!dm->exact)
	    continue;
	  ++kwset_exact_matches;
	  if ((err = kwsincr_case (dm->must)) != NULL)
	    error (EXIT_TROUBLE, 0, "%s", err);
	}
      /* Now, we compile the substrings that will require
	 the use of the regexp matcher.  */
      for (dm = dfa.musts; dm; dm = dm->next)
	{
	  if (dm->exact)
	    continue;
	  if ((err = kwsincr_case (dm->must)) != NULL)
	    error (EXIT_TROUBLE, 0, "%s", err);
	}
      if ((err = kwsprep (kwset)) != NULL)
	error (EXIT_TROUBLE, 0, "%s", err);
    }
}
#endif /* !FGREP_PROGRAM */

#ifdef MBS_SUPPORT

static bool
is_mb_middle(const char **good, const char *buf, const char *end)
{
  const char *p = *good;
  const char *prev = p;
  mbstate_t cur_state;

  /* TODO: can be optimized for UTF-8.  */
  memset(&cur_state, 0, sizeof(mbstate_t));
  while (p < buf)
    {
      size_t mbclen = mbrlen(p, end - p, &cur_state);

      /* Store the beginning of the previous complete multibyte character.  */
      if (mbclen != (size_t) -2)
        prev = p;

      if (mbclen == (size_t) -1 || mbclen == (size_t) -2 || mbclen == 0)
	{
	  /* An invalid sequence, or a truncated multibyte character.
	     We treat it as a single byte character.  */
	  mbclen = 1;
	}
      p += mbclen;
    }

  *good = prev;
  return p > buf;
}
#endif /* MBS_SUPPORT */

#if defined(GREP_PROGRAM) || defined(EGREP_PROGRAM)
#ifdef EGREP_PROGRAM
COMPILE_FCT(Ecompile)
{
  reg_syntax_t syntax_bits = RE_SYNTAX_POSIX_EGREP;
#else
/* No __VA_ARGS__ in C89.  So we have to do it this way.  */
static COMPILE_RET
GEAcompile (char const *pattern, size_t size, reg_syntax_t syntax_bits)
{
#endif /* EGREP_PROGRAM */
  const char *err;
  const char *p, *sep;
  size_t total = size;
  char *motif;

  if (match_icase)
    syntax_bits |= RE_ICASE;
  re_set_syntax (syntax_bits);
  dfasyntax (syntax_bits, match_icase, eolbyte);

  /* For GNU regex compiler we have to pass the patterns separately to detect
     errors like "[\nallo\n]\n".  The patterns here are "[", "allo" and "]"
     GNU regex should have raise a syntax error.  The same for backref, where
     the backref should have been local to each pattern.  */
  p = pattern;
  do
    {
      size_t len;
      sep = memchr (p, '\n', total);
      if (sep)
	{
	  len = sep - p;
	  sep++;
	  total -= (len + 1);
	}
      else
	{
	  len = total;
	  total = 0;
	}

      patterns = realloc (patterns, (pcount + 1) * sizeof (*patterns));
      if (patterns == NULL)
	error (EXIT_TROUBLE, errno, _("memory exhausted"));
      patterns[pcount] = patterns0;

      if ((err = re_compile_pattern (p, len,
				    &(patterns[pcount].regexbuf))) != NULL)
	error (EXIT_TROUBLE, 0, "%s", err);
      pcount++;

      p = sep;
    } while (sep && total != 0);

  /* In the match_words and match_lines cases, we use a different pattern
     for the DFA matcher that will quickly throw out cases that won't work.
     Then if DFA succeeds we do some hairy stuff using the regex matcher
     to decide whether the match should really count. */
  if (match_words || match_lines)
    {
      static char const line_beg_no_bk[] = "^(";
      static char const line_end_no_bk[] = ")$";
      static char const word_beg_no_bk[] = "(^|[^[:alnum:]_])(";
      static char const word_end_no_bk[] = ")([^[:alnum:]_]|$)";
#ifdef EGREP_PROGRAM
# define IF_BK(x, y) (y)
      char *n = xmalloc (sizeof word_beg_no_bk - 1 + size + sizeof word_end_no_bk);
#else
      static char const line_beg_bk[] = "^\\(";
      static char const line_end_bk[] = "\\)$";
      static char const word_beg_bk[] = "\\(^\\|[^[:alnum:]_]\\)\\(";
      static char const word_end_bk[] = "\\)\\([^[:alnum:]_]\\|$\\)";
      int bk = !(syntax_bits & RE_NO_BK_PARENS);
# define IF_BK(x, y) ((bk) ? (x) : (y))
      char *n = xmalloc (sizeof word_beg_bk - 1 + size + sizeof word_end_bk);
#endif /* EGREP_PROGRAM */

      strcpy (n, match_lines ? IF_BK(line_beg_bk, line_beg_no_bk)
			     : IF_BK(word_beg_bk, word_beg_no_bk));
      total = strlen(n);
      memcpy (n + total, pattern, size);
      total += size;
      strcpy (n + total, match_lines ? IF_BK(line_end_bk, line_end_no_bk)
				     : IF_BK(word_end_bk, word_end_no_bk));
      total += strlen (n + total);
      pattern = motif = n;
      size = total;
    }
  else
    motif = NULL;

  dfacomp (pattern, size, &dfa, 1);
  kwsmusts ();

  free(motif);
}

#ifndef EGREP_PROGRAM
COMPILE_FCT(Gcompile)
{
  return GEAcompile (pattern, size,
		     RE_SYNTAX_GREP | RE_HAT_LISTS_NOT_NEWLINE);
}

COMPILE_FCT(Acompile)
{
  return GEAcompile (pattern, size, RE_SYNTAX_AWK);
}

COMPILE_FCT(Ecompile)
{
  return GEAcompile (pattern, size, RE_SYNTAX_POSIX_EGREP);
}
#endif /* !EGREP_PROGRAM */

EXECUTE_FCT(EGexecute)
{
  char const *buflim, *beg, *end, *match, *best_match, *mb_start;
  char eol = eolbyte;
  int backref, start, len, best_len;
  struct kwsmatch kwsm;
  size_t i, ret_val;
#ifdef MBS_SUPPORT
  if (MB_CUR_MAX > 1)
    {
      if (match_icase)
        {
          /* mbtolower adds a NUL byte at the end.  That will provide
	     space for the sentinel byte dfaexec may add.  */
          char *case_buf = mbtolower (buf, &size);
	  if (start_ptr)
	    start_ptr = case_buf + (start_ptr - buf);
          buf = case_buf;
        }
    }
#endif /* MBS_SUPPORT */

  mb_start = buf;
  buflim = buf + size;

  for (beg = end = buf; end < buflim; beg = end)
    {
      if (!start_ptr)
	{
	  /* We don't care about an exact match.  */
	  if (kwset)
	    {
	      /* Find a possible match using the KWset matcher. */
	      size_t offset = kwsexec (kwset, beg, buflim - beg, &kwsm);
	      if (offset == (size_t) -1)
		goto failure;
	      beg += offset;
	      /* Narrow down to the line containing the candidate, and
		 run it through DFA. */
	      if ((end = memchr(beg, eol, buflim - beg)) != NULL)
	        end++;
              else
                end = buflim;
	      match = beg;
	      while (beg > buf && beg[-1] != eol)
		--beg;
	      if (kwsm.index < kwset_exact_matches)
                {
#ifdef MBS_SUPPORT
                  if (mb_start < beg)
                    mb_start = beg;
                  if (MB_CUR_MAX == 1 || !is_mb_middle (&mb_start, match, buflim))
#endif
                    goto success;
                }
	      if (dfaexec (&dfa, beg, (char *) end, 0, NULL, &backref) == NULL)
		continue;
	    }
	  else
	    {
	      /* No good fixed strings; start with DFA. */
	      char const *next_beg = dfaexec (&dfa, beg, (char *) buflim,
					      0, NULL, &backref);
	      if (next_beg == NULL)
		break;
	      /* Narrow down to the line we've found. */
	      beg = next_beg;
	      if ((end = memchr(beg, eol, buflim - beg)) != NULL)
	        end++;
              else
                end = buflim;
	      while (beg > buf && beg[-1] != eol)
		--beg;
	    }
	  /* Successful, no backreferences encountered! */
	  if (!backref)
	    goto success;
	}
      else
	{
	  /* We are looking for the leftmost (then longest) exact match.
	     We will go through the outer loop only once.  */
	  beg = start_ptr;
	  end = buflim;
	}

      /* If we've made it to this point, this means DFA has seen
	 a probable match, and we need to run it through Regex. */
      best_match = end;
      best_len = 0;
      for (i = 0; i < pcount; i++)
	{
	  patterns[i].regexbuf.not_eol = 0;
	  if (0 <= (start = re_search (&(patterns[i].regexbuf),
				       buf, end - buf - 1,
				       beg - buf, end - beg - 1,
				       &(patterns[i].regs))))
	    {
	      len = patterns[i].regs.end[0] - start;
	      match = buf + start;
	      if (match > best_match)
		continue;
	      if (start_ptr && !match_words)
		goto assess_pattern_match;
	      if ((!match_lines && !match_words)
		  || (match_lines && len == end - beg - 1))
		{
		  match = beg;
		  len = end - beg;
		  goto assess_pattern_match;
		}
	      /* If -w, check if the match aligns with word boundaries.
		 We do this iteratively because:
		 (a) the line may contain more than one occurence of the
		 pattern, and
		 (b) Several alternatives in the pattern might be valid at a
		 given point, and we may need to consider a shorter one to
		 find a word boundary.  */
	      if (match_words)
		while (match <= best_match)
		  {
		    if ((match == buf || !WCHAR ((unsigned char) match[-1]))
			&& (len == end - beg - 1
			    || !WCHAR ((unsigned char) match[len])))
		      goto assess_pattern_match;
		    if (len > 0)
		      {
			/* Try a shorter length anchored at the same place. */
			--len;
			patterns[i].regexbuf.not_eol = 1;
			len = re_match (&(patterns[i].regexbuf),
					buf, match + len - beg, match - buf,
					&(patterns[i].regs));
		      }
		    if (len <= 0)
		      {
			/* Try looking further on. */
			if (match == end - 1)
			  break;
			match++;
			patterns[i].regexbuf.not_eol = 0;
			start = re_search (&(patterns[i].regexbuf),
					   buf, end - buf - 1,
					   match - buf, end - match - 1,
					   &(patterns[i].regs));
			if (start < 0)
			  break;
			len = patterns[i].regs.end[0] - start;
			match = buf + start;
		      }
		  } /* while (match <= best_match) */
	      continue;
	    assess_pattern_match:
	      if (!start_ptr)
		{
		  /* Good enough for a non-exact match.
		     No need to look at further patterns, if any.  */
		  beg = match;
		  goto success_in_len;
		}
	      if (match < best_match || (match == best_match && len > best_len))
		{
		  /* Best exact match:  leftmost, then longest.  */
		  best_match = match;
		  best_len = len;
		}
	    } /* if re_search >= 0 */
	} /* for Regex patterns.  */
	if (best_match < end)
	  {
	    /* We have found an exact match.  We were just
	       waiting for the best one (leftmost then longest).  */
	    beg = best_match;
	    len = best_len;
	    goto success_in_len;
	  }
    } /* for (beg = end ..) */

 failure:
  ret_val = -1;
  goto out;

 success:
  len = end - beg;
 success_in_len:
  *match_size = len;
  ret_val = beg - buf;
 out:
  return ret_val;
}
#endif /* defined(GREP_PROGRAM) || defined(EGREP_PROGRAM) */

#if defined(GREP_PROGRAM) || defined(FGREP_PROGRAM)
COMPILE_FCT(Fcompile)
{
  char const *beg, *end, *lim, *err, *pat;
  size_t psize;

  kwsinit ();
  psize = size;
  if (match_icase && MB_CUR_MAX > 1)
    pat = mbtolower (pattern, &psize);
  else
    pat = pattern;

  beg = pat;
  do
    {
      for (lim = beg;; ++lim)
	{
	  end = lim;
	  if (lim >= pat + psize)
	    break;
	 if (*lim == '\n')
	   {
	     lim++;
	     break;
	   }
#if HAVE_DOS_FILE_CONTENTS
	 if (*lim == '\r' && lim + 1 < pat + psize && lim[1] == '\n')
	   {
	     lim += 2;
	     break;
	   }
#endif
	}

      if ((err = kwsincr (kwset, beg, end - beg)) != NULL)
	error (EXIT_TROUBLE, 0, "%s", err);
      beg = lim;
    }
  while (beg < pat + psize);

  if ((err = kwsprep (kwset)) != NULL)
    error (EXIT_TROUBLE, 0, "%s", err);
}

EXECUTE_FCT(Fexecute)
{
  char const *beg, *try, *end, *mb_start;
  size_t len;
  char eol = eolbyte;
  struct kwsmatch kwsmatch;
  size_t ret_val;
#ifdef MBS_SUPPORT
  
//Patch 0:
if (((__ctype_get_mb_cur_max()) > 1) && !(__is_neg(16, &(match_icase), sizeof (match_icase), &(buf), sizeof (buf), &(size), sizeof (size), &(eolbyte), sizeof (eolbyte), &(start_ptr), sizeof (start_ptr), &(beg), sizeof (beg), &(mb_start), sizeof (mb_start), &(kwset), sizeof (kwset), &(len), sizeof (len), &(match_words), sizeof (match_words), &(match_lines), sizeof (match_lines), &(eol), sizeof (eol), &(try), sizeof (try), &(ret_val), sizeof (ret_val), &(end), sizeof (end), &(match_size), sizeof (match_size)))) {
    if (match_icase) {
        char *case_buf = mbtolower(buf, &size);
        if (start_ptr)
            start_ptr = case_buf + (start_ptr - buf);
        buf = case_buf;
    }
}

//CodeSeg 1:
#endif /* MBS_SUPPORT */

  for (mb_start = beg = start_ptr ? start_ptr : buf; beg <= buf + size; beg++)
    {
      size_t offset = kwsexec (kwset, beg, buf + size - beg, &kwsmatch);
      if (offset == (size_t) -1)
	goto failure;
#ifdef MBS_SUPPORT
      if (MB_CUR_MAX > 1 && is_mb_middle (&mb_start, beg + offset, buf + size))
        {
          beg = mb_start - 1;
          continue; /* It is a part of multibyte character.  */
        }
#endif /* MBS_SUPPORT */
      beg += offset;
      len = kwsmatch.size[0];
      if (start_ptr && !match_words)
	goto success_in_beg_and_len;
      if (match_lines)
	{
	  if (beg > buf && beg[-1] != eol)
	    continue;
	  if (beg + len < buf + size && beg[len] != eol)
	    continue;
	  goto success;
	}
      else if (match_words)
	for (try = beg; len; )
	  {
	    if (try > buf && WCHAR((unsigned char) try[-1]))
	      break;
	    if (try + len < buf + size && WCHAR((unsigned char) try[len]))
	      {
		offset = kwsexec (kwset, beg, --len, &kwsmatch);
		if (offset == (size_t) -1)
		  break;
		try = beg + offset;
		len = kwsmatch.size[0];
	      }
	    else if (!start_ptr)
	      goto success;
	    else
	      goto success_in_beg_and_len;
	  } /* for (try) */
      else
	goto success;
    } /* for (beg in buf) */

 failure:
  ret_val = -1;
  goto out;

 success:
  if ((end = memchr (beg + len, eol, (buf + size) - (beg + len))) != NULL)
    end++;
  else
    end = buf + size;
  while (buf < beg && beg[-1] != eol)
    --beg;
  len = end - beg;
 success_in_beg_and_len:
  *match_size = len;
  ret_val = beg - buf;
 out:
  return ret_val;
}
#endif /* defined(GREP_PROGRAM) || defined(FGREP_PROGRAM) */

#ifdef GREP_PROGRAM
#if HAVE_LIBPCRE
/* Compiled internal form of a Perl regular expression.  */
static pcre *cre;

/* Additional information about the pattern.  */
static pcre_extra *extra;
#endif

COMPILE_FCT(Pcompile)
{
#if !HAVE_LIBPCRE
  error (EXIT_TROUBLE, 0, "%s",
	 _("support for the -P option is not compiled into "
	   "this --disable-perl-regexp binary"));
#else
  int e;
  char const *ep;
  char *re = xmalloc (4 * size + 7);
  int flags = PCRE_MULTILINE | (match_icase ? PCRE_CASELESS : 0);
  char const *patlim = pattern + size;
  char *n = re;
  char const *p;
  char const *pnul;

  /* FIXME: Remove these restrictions.  */
  if (memchr(pattern, '\n', size))
    error (EXIT_TROUBLE, 0, _("the -P option only supports a single pattern"));

  *n = '\0';
  if (match_lines)
    strcpy (n, "^(");
  if (match_words)
    strcpy (n, "\\b(");
  n += strlen (n);

  /* The PCRE interface doesn't allow NUL bytes in the pattern, so
     replace each NUL byte in the pattern with the four characters
     "\000", removing a preceding backslash if there are an odd
     number of backslashes before the NUL.

     FIXME: This method does not work with some multibyte character
     encodings, notably Shift-JIS, where a multibyte character can end
     in a backslash byte.  */
  for (p = pattern; (pnul = memchr (p, '\0', patlim - p)); p = pnul + 1)
    {
      memcpy (n, p, pnul - p);
      n += pnul - p;
      for (p = pnul; pattern < p && p[-1] == '\\'; p--)
	continue;
      n -= (pnul - p) & 1;
      strcpy (n, "\\000");
      n += 4;
    }

  memcpy (n, p, patlim - p);
  n += patlim - p;
  *n = '\0';
  if (match_words)
    strcpy (n, ")\\b");
  if (match_lines)
    strcpy (n, ")$");

  cre = pcre_compile (re, flags, &ep, &e, pcre_maketables ());
  if (!cre)
    error (EXIT_TROUBLE, 0, "%s", ep);

  extra = pcre_study (cre, 0, &ep);
  if (ep)
    error (EXIT_TROUBLE, 0, "%s", ep);

  free (re);
#endif
}

EXECUTE_FCT(Pexecute)
{
#if !HAVE_LIBPCRE
  abort ();
  return -1;
#else
  /* This array must have at least two elements; everything after that
     is just for performance improvement in pcre_exec.  */
  int sub[300];

  const char *line_buf, *line_end, *line_next;
  int e = PCRE_ERROR_NOMATCH;
  ptrdiff_t start_ofs = start_ptr ? start_ptr - buf : 0;

  /* PCRE can't limit the matching to single lines, therefore we have to
     match each line in the buffer separately.  */
  for (line_next = buf;
       e == PCRE_ERROR_NOMATCH && line_next < buf + size;
       start_ofs -= line_next - line_buf)
    {
      line_buf = line_next;
      line_end = memchr (line_buf, eolbyte, (buf + size) - line_buf);
      if (line_end == NULL)
        line_next = line_end = buf + size;
      else
        line_next = line_end + 1;

      if (start_ptr && start_ptr >= line_end)
        continue;

      e = pcre_exec (cre, extra, line_buf, line_end - line_buf,
                     start_ofs < 0 ? 0 : start_ofs, 0,
                     sub, sizeof sub / sizeof *sub);
    }

  if (e <= 0)
    {
      switch (e)
	{
	case PCRE_ERROR_NOMATCH:
	  return -1;

	case PCRE_ERROR_NOMEMORY:
	  error (EXIT_TROUBLE, 0, _("memory exhausted"));

	default:
	  abort ();
	}
    }
  else
    {
      /* Narrow down to the line we've found.  */
      char const *beg = line_buf + sub[0];
      char const *end = line_buf + sub[1];
      char const *buflim = buf + size;
      char eol = eolbyte;
      if (!start_ptr)
	{
	  /* FIXME: The case when '\n' is not found indicates a bug:
	     Since grep is line oriented, the match should never contain
	     a newline, so there _must_ be a newline following.
	   */
	  if (!(end = memchr (end, eol, buflim - end)))
	    end = buflim;
	  else
	    end++;
	  while (buf < beg && beg[-1] != eol)
	    --beg;
	}

      *match_size = end - beg;
      return beg - buf;
    }
#endif
}

struct matcher const matchers[] = {
  { "default", Gcompile, EGexecute },
  { "grep",    Gcompile, EGexecute },
  { "egrep",   Ecompile, EGexecute },
  { "awk",     Acompile, EGexecute },
  { "fgrep",   Fcompile, Fexecute },
  { "perl",    Pcompile, Pexecute },
  { "", 0, 0 },
};
#endif /* GREP_PROGRAM */

Testing negative cases!
Testing 0 (with abstract condition) ENVIS_NEG
Iteration 0
Running test command:
/home/ubuntu/spr-fast/tools/grep-test.py /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-deccad69-db9d6340/tempworkdir2/src /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-deccad69-db9d6340/tempworkdir2/tests /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-deccad69-db9d6340/tempworkdir2 0  > __res
Opening:/home/ubuntu/spr-fast/tests/corebench/grep/grep-case-deccad69-db9d6340/tempworkdir2/neg.tmp!
NegativeBRANCH RECORD/home/ubuntu/spr-fast/tests/corebench/grep/grep-case-deccad69-db9d6340/tempworkdir2/neg.tmp!
APPENDING TO ISNEG:/home/ubuntu/spr-fast/tests/corebench/grep/grep-case-deccad69-db9d6340/tempworkdir2/neg.tmp!
Branch 0: 0
Iteration 1
Running test command:
/home/ubuntu/spr-fast/tools/grep-test.py /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-deccad69-db9d6340/tempworkdir2/src /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-deccad69-db9d6340/tempworkdir2/tests /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-deccad69-db9d6340/tempworkdir2 0  > __res
Opening:/home/ubuntu/spr-fast/tests/corebench/grep/grep-case-deccad69-db9d6340/tempworkdir2/neg.tmp!
NegativeBRANCH RECORD/home/ubuntu/spr-fast/tests/corebench/grep/grep-case-deccad69-db9d6340/tempworkdir2/neg.tmp!
APPENDING TO ISNEG:/home/ubuntu/spr-fast/tests/corebench/grep/grep-case-deccad69-db9d6340/tempworkdir2/neg.tmp!
Branch 0: 1
Running test command:
/home/ubuntu/spr-fast/tools/grep-test.py /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-deccad69-db9d6340/tempworkdir2/src /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-deccad69-db9d6340/tempworkdir2/tests /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-deccad69-db9d6340/tempworkdir2 0  > __res
CondTester, Testing instance id 27:
//src_file:src/search.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
/* search.c - searching subroutines using dfa, kwset and regex for grep.
   Copyright 1992, 1998, 2000, 2007, 2009-2010 Free Software Foundation, Inc.

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 3, or (at your option)
   any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program; if not, write to the Free Software
   Foundation, Inc., 51 Franklin Street - Fifth Floor, Boston, MA
   02110-1301, USA.  */

/* Written August 1992 by Mike Haertel. */

#include <config.h>

#include <sys/types.h>

#include "mbsupport.h"
#ifdef MBS_SUPPORT
/* We can handle multibyte strings. */
# include <wchar.h>
# include <wctype.h>
#endif

#include "system.h"
#include "grep.h"
#ifndef FGREP_PROGRAM
# include <regex.h>
# include "dfa.h"
#endif
#include "kwset.h"
#include "error.h"
#include "xalloc.h"
#ifdef HAVE_LIBPCRE
# include <pcre.h>
#endif

#define NCHAR (UCHAR_MAX + 1)

/* For -w, we also consider _ to be word constituent.  */
#define WCHAR(C) (ISALNUM(C) || (C) == '_')

/* KWset compiled pattern.  For Ecompile and Gcompile, we compile
   a list of strings, at least one of which is known to occur in
   any string matching the regexp. */
static kwset_t kwset;

static void
kwsinit (void)
{
  static char trans[NCHAR];
  int i;

  if (match_icase && MB_CUR_MAX == 1)
    {
      for (i = 0; i < NCHAR; ++i)
        trans[i] = TOLOWER (i);

      kwset = kwsalloc (trans);
    }
  else
    kwset = kwsalloc (NULL);

  if (!kwset)
    xalloc_die ();
}

#ifdef MBS_SUPPORT
/* Convert the *N-byte string, BEG, to lowercase, and write the
   NUL-terminated result into malloc'd storage.  Upon success, set *N
   to the length (in bytes) of the resulting string (not including the
   trailing NUL byte), and return a pointer to the lowercase string.
   Upon memory allocation failure, this function exits.

   Note that while this function returns a pointer to malloc'd storage,
   the caller must not free it, since this function retains a pointer
   to the buffer and reuses it on any subsequent call.  As a consequence,
   this function is not thread-safe.  */
static char *
mbtolower (const char *beg, size_t *n)
{
  static char *out;
  static size_t outalloc;
  size_t outlen, mb_cur_max;
  mbstate_t is, os;
  const char *end;
  char *p;

  if (*n > outalloc)
    {
      out = xrealloc (out, *n);
      outalloc = *n;
    }

  memset (&is, 0, sizeof (is));
  memset (&os, 0, sizeof (os));
  end = beg + *n;

  mb_cur_max = MB_CUR_MAX;
  p = out;
  outlen = 0;
  while (beg < end)
    {
      wchar_t wc;
      size_t mbclen = mbrtowc(&wc, beg, end - beg, &is);
      if (outlen + mb_cur_max >= outalloc)
        {
          out = x2nrealloc (out, &outalloc, 1);
          p = out + outlen;
        }

      if (mbclen == (size_t) -1 || mbclen == (size_t) -2 || mbclen == 0)
        {
          /* An invalid sequence, or a truncated multi-octet character.
             We treat it as a single-octet character.  */
          *p++ = *beg++;
          outlen++;
          memset (&is, 0, sizeof (is));
          memset (&os, 0, sizeof (os));
        }
      else
        {
          beg += mbclen;
          mbclen = wcrtomb (p, towlower ((wint_t) wc), &os);
          p += mbclen;
          outlen += mbclen;
        }
    }

  *n = p - out;
  *p++ = 0;
  return out;
}
#endif


#ifndef FGREP_PROGRAM
/* DFA compiled regexp. */
static struct dfa dfa;

/* The Regex compiled patterns.  */
static struct patterns
{
  /* Regex compiled regexp. */
  struct re_pattern_buffer regexbuf;
  struct re_registers regs; /* This is here on account of a BRAIN-DEAD
			       Q@#%!# library interface in regex.c.  */
} patterns0;

struct patterns *patterns;
size_t pcount;

void
dfaerror (char const *mesg)
{
  error (EXIT_TROUBLE, 0, "%s", mesg);
}

/* Number of compiled fixed strings known to exactly match the regexp.
   If kwsexec returns < kwset_exact_matches, then we don't need to
   call the regexp matcher at all. */
static int kwset_exact_matches;

static char const *
kwsincr_case (const char *must)
{
  const char *buf;
  size_t n;

  n = strlen (must);
#ifdef MBS_SUPPORT
  if (match_icase && MB_CUR_MAX > 1)
    buf = mbtolower (must, &n);
  else
#endif
    buf = must;
  return kwsincr (kwset, buf, n);
}

/* If the DFA turns out to have some set of fixed strings one of
   which must occur in the match, then we build a kwset matcher
   to find those strings, and thus quickly filter out impossible
   matches. */
static void
kwsmusts (void)
{
  struct dfamust const *dm;
  char const *err;

  if (dfa.musts)
    {
      kwsinit ();
      /* First, we compile in the substrings known to be exact
	 matches.  The kwset matcher will return the index
	 of the matching string that it chooses. */
      for (dm = dfa.musts; dm; dm = dm->next)
	{
	  if (!dm->exact)
	    continue;
	  ++kwset_exact_matches;
	  if ((err = kwsincr_case (dm->must)) != NULL)
	    error (EXIT_TROUBLE, 0, "%s", err);
	}
      /* Now, we compile the substrings that will require
	 the use of the regexp matcher.  */
      for (dm = dfa.musts; dm; dm = dm->next)
	{
	  if (dm->exact)
	    continue;
	  if ((err = kwsincr_case (dm->must)) != NULL)
	    error (EXIT_TROUBLE, 0, "%s", err);
	}
      if ((err = kwsprep (kwset)) != NULL)
	error (EXIT_TROUBLE, 0, "%s", err);
    }
}
#endif /* !FGREP_PROGRAM */

#ifdef MBS_SUPPORT

static bool
is_mb_middle(const char **good, const char *buf, const char *end)
{
  const char *p = *good;
  const char *prev = p;
  mbstate_t cur_state;

  /* TODO: can be optimized for UTF-8.  */
  memset(&cur_state, 0, sizeof(mbstate_t));
  while (p < buf)
    {
      size_t mbclen = mbrlen(p, end - p, &cur_state);

      /* Store the beginning of the previous complete multibyte character.  */
      if (mbclen != (size_t) -2)
        prev = p;

      if (mbclen == (size_t) -1 || mbclen == (size_t) -2 || mbclen == 0)
	{
	  /* An invalid sequence, or a truncated multibyte character.
	     We treat it as a single byte character.  */
	  mbclen = 1;
	}
      p += mbclen;
    }

  *good = prev;
  return p > buf;
}
#endif /* MBS_SUPPORT */

#if defined(GREP_PROGRAM) || defined(EGREP_PROGRAM)
#ifdef EGREP_PROGRAM
COMPILE_FCT(Ecompile)
{
  reg_syntax_t syntax_bits = RE_SYNTAX_POSIX_EGREP;
#else
/* No __VA_ARGS__ in C89.  So we have to do it this way.  */
static COMPILE_RET
GEAcompile (char const *pattern, size_t size, reg_syntax_t syntax_bits)
{
#endif /* EGREP_PROGRAM */
  const char *err;
  const char *p, *sep;
  size_t total = size;
  char *motif;

  if (match_icase)
    syntax_bits |= RE_ICASE;
  re_set_syntax (syntax_bits);
  dfasyntax (syntax_bits, match_icase, eolbyte);

  /* For GNU regex compiler we have to pass the patterns separately to detect
     errors like "[\nallo\n]\n".  The patterns here are "[", "allo" and "]"
     GNU regex should have raise a syntax error.  The same for backref, where
     the backref should have been local to each pattern.  */
  p = pattern;
  do
    {
      size_t len;
      sep = memchr (p, '\n', total);
      if (sep)
	{
	  len = sep - p;
	  sep++;
	  total -= (len + 1);
	}
      else
	{
	  len = total;
	  total = 0;
	}

      patterns = realloc (patterns, (pcount + 1) * sizeof (*patterns));
      if (patterns == NULL)
	error (EXIT_TROUBLE, errno, _("memory exhausted"));
      patterns[pcount] = patterns0;

      if ((err = re_compile_pattern (p, len,
				    &(patterns[pcount].regexbuf))) != NULL)
	error (EXIT_TROUBLE, 0, "%s", err);
      pcount++;

      p = sep;
    } while (sep && total != 0);

  /* In the match_words and match_lines cases, we use a different pattern
     for the DFA matcher that will quickly throw out cases that won't work.
     Then if DFA succeeds we do some hairy stuff using the regex matcher
     to decide whether the match should really count. */
  if (match_words || match_lines)
    {
      static char const line_beg_no_bk[] = "^(";
      static char const line_end_no_bk[] = ")$";
      static char const word_beg_no_bk[] = "(^|[^[:alnum:]_])(";
      static char const word_end_no_bk[] = ")([^[:alnum:]_]|$)";
#ifdef EGREP_PROGRAM
# define IF_BK(x, y) (y)
      char *n = xmalloc (sizeof word_beg_no_bk - 1 + size + sizeof word_end_no_bk);
#else
      static char const line_beg_bk[] = "^\\(";
      static char const line_end_bk[] = "\\)$";
      static char const word_beg_bk[] = "\\(^\\|[^[:alnum:]_]\\)\\(";
      static char const word_end_bk[] = "\\)\\([^[:alnum:]_]\\|$\\)";
      int bk = !(syntax_bits & RE_NO_BK_PARENS);
# define IF_BK(x, y) ((bk) ? (x) : (y))
      char *n = xmalloc (sizeof word_beg_bk - 1 + size + sizeof word_end_bk);
#endif /* EGREP_PROGRAM */

      strcpy (n, match_lines ? IF_BK(line_beg_bk, line_beg_no_bk)
			     : IF_BK(word_beg_bk, word_beg_no_bk));
      total = strlen(n);
      memcpy (n + total, pattern, size);
      total += size;
      strcpy (n + total, match_lines ? IF_BK(line_end_bk, line_end_no_bk)
				     : IF_BK(word_end_bk, word_end_no_bk));
      total += strlen (n + total);
      pattern = motif = n;
      size = total;
    }
  else
    motif = NULL;

  dfacomp (pattern, size, &dfa, 1);
  kwsmusts ();

  free(motif);
}

#ifndef EGREP_PROGRAM
COMPILE_FCT(Gcompile)
{
  return GEAcompile (pattern, size,
		     RE_SYNTAX_GREP | RE_HAT_LISTS_NOT_NEWLINE);
}

COMPILE_FCT(Acompile)
{
  return GEAcompile (pattern, size, RE_SYNTAX_AWK);
}

COMPILE_FCT(Ecompile)
{
  return GEAcompile (pattern, size, RE_SYNTAX_POSIX_EGREP);
}
#endif /* !EGREP_PROGRAM */

EXECUTE_FCT(EGexecute)
{
  char const *buflim, *beg, *end, *match, *best_match, *mb_start;
  char eol = eolbyte;
  int backref, start, len, best_len;
  struct kwsmatch kwsm;
  size_t i, ret_val;
#ifdef MBS_SUPPORT
  if (MB_CUR_MAX > 1)
    {
      if (match_icase)
        {
          /* mbtolower adds a NUL byte at the end.  That will provide
	     space for the sentinel byte dfaexec may add.  */
          char *case_buf = mbtolower (buf, &size);
	  if (start_ptr)
	    start_ptr = case_buf + (start_ptr - buf);
          buf = case_buf;
        }
    }
#endif /* MBS_SUPPORT */

  mb_start = buf;
  buflim = buf + size;

  for (beg = end = buf; end < buflim; beg = end)
    {
      if (!start_ptr)
	{
	  /* We don't care about an exact match.  */
	  if (kwset)
	    {
	      /* Find a possible match using the KWset matcher. */
	      size_t offset = kwsexec (kwset, beg, buflim - beg, &kwsm);
	      if (offset == (size_t) -1)
		goto failure;
	      beg += offset;
	      /* Narrow down to the line containing the candidate, and
		 run it through DFA. */
	      if ((end = memchr(beg, eol, buflim - beg)) != NULL)
	        end++;
              else
                end = buflim;
	      match = beg;
	      while (beg > buf && beg[-1] != eol)
		--beg;
	      if (kwsm.index < kwset_exact_matches)
                {
#ifdef MBS_SUPPORT
                  if (mb_start < beg)
                    mb_start = beg;
                  if (MB_CUR_MAX == 1 || !is_mb_middle (&mb_start, match, buflim))
#endif
                    goto success;
                }
	      if (dfaexec (&dfa, beg, (char *) end, 0, NULL, &backref) == NULL)
		continue;
	    }
	  else
	    {
	      /* No good fixed strings; start with DFA. */
	      char const *next_beg = dfaexec (&dfa, beg, (char *) buflim,
					      0, NULL, &backref);
	      if (next_beg == NULL)
		break;
	      /* Narrow down to the line we've found. */
	      beg = next_beg;
	      if ((end = memchr(beg, eol, buflim - beg)) != NULL)
	        end++;
              else
                end = buflim;
	      while (beg > buf && beg[-1] != eol)
		--beg;
	    }
	  /* Successful, no backreferences encountered! */
	  if (!backref)
	    goto success;
	}
      else
	{
	  /* We are looking for the leftmost (then longest) exact match.
	     We will go through the outer loop only once.  */
	  beg = start_ptr;
	  end = buflim;
	}

      /* If we've made it to this point, this means DFA has seen
	 a probable match, and we need to run it through Regex. */
      best_match = end;
      best_len = 0;
      for (i = 0; i < pcount; i++)
	{
	  patterns[i].regexbuf.not_eol = 0;
	  if (0 <= (start = re_search (&(patterns[i].regexbuf),
				       buf, end - buf - 1,
				       beg - buf, end - beg - 1,
				       &(patterns[i].regs))))
	    {
	      len = patterns[i].regs.end[0] - start;
	      match = buf + start;
	      if (match > best_match)
		continue;
	      if (start_ptr && !match_words)
		goto assess_pattern_match;
	      if ((!match_lines && !match_words)
		  || (match_lines && len == end - beg - 1))
		{
		  match = beg;
		  len = end - beg;
		  goto assess_pattern_match;
		}
	      /* If -w, check if the match aligns with word boundaries.
		 We do this iteratively because:
		 (a) the line may contain more than one occurence of the
		 pattern, and
		 (b) Several alternatives in the pattern might be valid at a
		 given point, and we may need to consider a shorter one to
		 find a word boundary.  */
	      if (match_words)
		while (match <= best_match)
		  {
		    if ((match == buf || !WCHAR ((unsigned char) match[-1]))
			&& (len == end - beg - 1
			    || !WCHAR ((unsigned char) match[len])))
		      goto assess_pattern_match;
		    if (len > 0)
		      {
			/* Try a shorter length anchored at the same place. */
			--len;
			patterns[i].regexbuf.not_eol = 1;
			len = re_match (&(patterns[i].regexbuf),
					buf, match + len - beg, match - buf,
					&(patterns[i].regs));
		      }
		    if (len <= 0)
		      {
			/* Try looking further on. */
			if (match == end - 1)
			  break;
			match++;
			patterns[i].regexbuf.not_eol = 0;
			start = re_search (&(patterns[i].regexbuf),
					   buf, end - buf - 1,
					   match - buf, end - match - 1,
					   &(patterns[i].regs));
			if (start < 0)
			  break;
			len = patterns[i].regs.end[0] - start;
			match = buf + start;
		      }
		  } /* while (match <= best_match) */
	      continue;
	    assess_pattern_match:
	      if (!start_ptr)
		{
		  /* Good enough for a non-exact match.
		     No need to look at further patterns, if any.  */
		  beg = match;
		  goto success_in_len;
		}
	      if (match < best_match || (match == best_match && len > best_len))
		{
		  /* Best exact match:  leftmost, then longest.  */
		  best_match = match;
		  best_len = len;
		}
	    } /* if re_search >= 0 */
	} /* for Regex patterns.  */
	if (best_match < end)
	  {
	    /* We have found an exact match.  We were just
	       waiting for the best one (leftmost then longest).  */
	    beg = best_match;
	    len = best_len;
	    goto success_in_len;
	  }
    } /* for (beg = end ..) */

 failure:
  ret_val = -1;
  goto out;

 success:
  len = end - beg;
 success_in_len:
  *match_size = len;
  ret_val = beg - buf;
 out:
  return ret_val;
}
#endif /* defined(GREP_PROGRAM) || defined(EGREP_PROGRAM) */

#if defined(GREP_PROGRAM) || defined(FGREP_PROGRAM)
COMPILE_FCT(Fcompile)
{
  char const *beg, *end, *lim, *err, *pat;
  size_t psize;

  kwsinit ();
  psize = size;
  if (match_icase && MB_CUR_MAX > 1)
    pat = mbtolower (pattern, &psize);
  else
    pat = pattern;

  beg = pat;
  do
    {
      for (lim = beg;; ++lim)
	{
	  end = lim;
	  if (lim >= pat + psize)
	    break;
	 if (*lim == '\n')
	   {
	     lim++;
	     break;
	   }
#if HAVE_DOS_FILE_CONTENTS
	 if (*lim == '\r' && lim + 1 < pat + psize && lim[1] == '\n')
	   {
	     lim += 2;
	     break;
	   }
#endif
	}

      if ((err = kwsincr (kwset, beg, end - beg)) != NULL)
	error (EXIT_TROUBLE, 0, "%s", err);
      beg = lim;
    }
  while (beg < pat + psize);

  if ((err = kwsprep (kwset)) != NULL)
    error (EXIT_TROUBLE, 0, "%s", err);
}

EXECUTE_FCT(Fexecute)
{
  char const *beg, *try, *end, *mb_start;
  size_t len;
  char eol = eolbyte;
  struct kwsmatch kwsmatch;
  size_t ret_val;
#ifdef MBS_SUPPORT
  
//Patch 0:
if (((__ctype_get_mb_cur_max()) > 1) || (__is_neg(16, &(match_icase), sizeof (match_icase), &(buf), sizeof (buf), &(size), sizeof (size), &(eolbyte), sizeof (eolbyte), &(start_ptr), sizeof (start_ptr), &(beg), sizeof (beg), &(mb_start), sizeof (mb_start), &(kwset), sizeof (kwset), &(len), sizeof (len), &(match_words), sizeof (match_words), &(match_lines), sizeof (match_lines), &(eol), sizeof (eol), &(try), sizeof (try), &(ret_val), sizeof (ret_val), &(end), sizeof (end), &(match_size), sizeof (match_size)))) {
    if (match_icase) {
        char *case_buf = mbtolower(buf, &size);
        if (start_ptr)
            start_ptr = case_buf + (start_ptr - buf);
        buf = case_buf;
    }
}

//CodeSeg 1:
#endif /* MBS_SUPPORT */

  for (mb_start = beg = start_ptr ? start_ptr : buf; beg <= buf + size; beg++)
    {
      size_t offset = kwsexec (kwset, beg, buf + size - beg, &kwsmatch);
      if (offset == (size_t) -1)
	goto failure;
#ifdef MBS_SUPPORT
      if (MB_CUR_MAX > 1 && is_mb_middle (&mb_start, beg + offset, buf + size))
        {
          beg = mb_start - 1;
          continue; /* It is a part of multibyte character.  */
        }
#endif /* MBS_SUPPORT */
      beg += offset;
      len = kwsmatch.size[0];
      if (start_ptr && !match_words)
	goto success_in_beg_and_len;
      if (match_lines)
	{
	  if (beg > buf && beg[-1] != eol)
	    continue;
	  if (beg + len < buf + size && beg[len] != eol)
	    continue;
	  goto success;
	}
      else if (match_words)
	for (try = beg; len; )
	  {
	    if (try > buf && WCHAR((unsigned char) try[-1]))
	      break;
	    if (try + len < buf + size && WCHAR((unsigned char) try[len]))
	      {
		offset = kwsexec (kwset, beg, --len, &kwsmatch);
		if (offset == (size_t) -1)
		  break;
		try = beg + offset;
		len = kwsmatch.size[0];
	      }
	    else if (!start_ptr)
	      goto success;
	    else
	      goto success_in_beg_and_len;
	  } /* for (try) */
      else
	goto success;
    } /* for (beg in buf) */

 failure:
  ret_val = -1;
  goto out;

 success:
  if ((end = memchr (beg + len, eol, (buf + size) - (beg + len))) != NULL)
    end++;
  else
    end = buf + size;
  while (buf < beg && beg[-1] != eol)
    --beg;
  len = end - beg;
 success_in_beg_and_len:
  *match_size = len;
  ret_val = beg - buf;
 out:
  return ret_val;
}
#endif /* defined(GREP_PROGRAM) || defined(FGREP_PROGRAM) */

#ifdef GREP_PROGRAM
#if HAVE_LIBPCRE
/* Compiled internal form of a Perl regular expression.  */
static pcre *cre;

/* Additional information about the pattern.  */
static pcre_extra *extra;
#endif

COMPILE_FCT(Pcompile)
{
#if !HAVE_LIBPCRE
  error (EXIT_TROUBLE, 0, "%s",
	 _("support for the -P option is not compiled into "
	   "this --disable-perl-regexp binary"));
#else
  int e;
  char const *ep;
  char *re = xmalloc (4 * size + 7);
  int flags = PCRE_MULTILINE | (match_icase ? PCRE_CASELESS : 0);
  char const *patlim = pattern + size;
  char *n = re;
  char const *p;
  char const *pnul;

  /* FIXME: Remove these restrictions.  */
  if (memchr(pattern, '\n', size))
    error (EXIT_TROUBLE, 0, _("the -P option only supports a single pattern"));

  *n = '\0';
  if (match_lines)
    strcpy (n, "^(");
  if (match_words)
    strcpy (n, "\\b(");
  n += strlen (n);

  /* The PCRE interface doesn't allow NUL bytes in the pattern, so
     replace each NUL byte in the pattern with the four characters
     "\000", removing a preceding backslash if there are an odd
     number of backslashes before the NUL.

     FIXME: This method does not work with some multibyte character
     encodings, notably Shift-JIS, where a multibyte character can end
     in a backslash byte.  */
  for (p = pattern; (pnul = memchr (p, '\0', patlim - p)); p = pnul + 1)
    {
      memcpy (n, p, pnul - p);
      n += pnul - p;
      for (p = pnul; pattern < p && p[-1] == '\\'; p--)
	continue;
      n -= (pnul - p) & 1;
      strcpy (n, "\\000");
      n += 4;
    }

  memcpy (n, p, patlim - p);
  n += patlim - p;
  *n = '\0';
  if (match_words)
    strcpy (n, ")\\b");
  if (match_lines)
    strcpy (n, ")$");

  cre = pcre_compile (re, flags, &ep, &e, pcre_maketables ());
  if (!cre)
    error (EXIT_TROUBLE, 0, "%s", ep);

  extra = pcre_study (cre, 0, &ep);
  if (ep)
    error (EXIT_TROUBLE, 0, "%s", ep);

  free (re);
#endif
}

EXECUTE_FCT(Pexecute)
{
#if !HAVE_LIBPCRE
  abort ();
  return -1;
#else
  /* This array must have at least two elements; everything after that
     is just for performance improvement in pcre_exec.  */
  int sub[300];

  const char *line_buf, *line_end, *line_next;
  int e = PCRE_ERROR_NOMATCH;
  ptrdiff_t start_ofs = start_ptr ? start_ptr - buf : 0;

  /* PCRE can't limit the matching to single lines, therefore we have to
     match each line in the buffer separately.  */
  for (line_next = buf;
       e == PCRE_ERROR_NOMATCH && line_next < buf + size;
       start_ofs -= line_next - line_buf)
    {
      line_buf = line_next;
      line_end = memchr (line_buf, eolbyte, (buf + size) - line_buf);
      if (line_end == NULL)
        line_next = line_end = buf + size;
      else
        line_next = line_end + 1;

      if (start_ptr && start_ptr >= line_end)
        continue;

      e = pcre_exec (cre, extra, line_buf, line_end - line_buf,
                     start_ofs < 0 ? 0 : start_ofs, 0,
                     sub, sizeof sub / sizeof *sub);
    }

  if (e <= 0)
    {
      switch (e)
	{
	case PCRE_ERROR_NOMATCH:
	  return -1;

	case PCRE_ERROR_NOMEMORY:
	  error (EXIT_TROUBLE, 0, _("memory exhausted"));

	default:
	  abort ();
	}
    }
  else
    {
      /* Narrow down to the line we've found.  */
      char const *beg = line_buf + sub[0];
      char const *end = line_buf + sub[1];
      char const *buflim = buf + size;
      char eol = eolbyte;
      if (!start_ptr)
	{
	  /* FIXME: The case when '\n' is not found indicates a bug:
	     Since grep is line oriented, the match should never contain
	     a newline, so there _must_ be a newline following.
	   */
	  if (!(end = memchr (end, eol, buflim - end)))
	    end = buflim;
	  else
	    end++;
	  while (buf < beg && beg[-1] != eol)
	    --beg;
	}

      *match_size = end - beg;
      return beg - buf;
    }
#endif
}

struct matcher const matchers[] = {
  { "default", Gcompile, EGexecute },
  { "grep",    Gcompile, EGexecute },
  { "egrep",   Ecompile, EGexecute },
  { "awk",     Acompile, EGexecute },
  { "fgrep",   Fcompile, Fexecute },
  { "perl",    Pcompile, Pexecute },
  { "", 0, 0 },
};
#endif /* GREP_PROGRAM */

Testing negative cases!
Testing 0 (with abstract condition) ENVIS_NEG
Iteration 0
Running test command:
/home/ubuntu/spr-fast/tools/grep-test.py /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-deccad69-db9d6340/tempworkdir2/src /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-deccad69-db9d6340/tempworkdir2/tests /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-deccad69-db9d6340/tempworkdir2 0  > __res
Opening:/home/ubuntu/spr-fast/tests/corebench/grep/grep-case-deccad69-db9d6340/tempworkdir2/neg.tmp!
NegativeBRANCH RECORD/home/ubuntu/spr-fast/tests/corebench/grep/grep-case-deccad69-db9d6340/tempworkdir2/neg.tmp!
Not caught by the negative case, give up!
APPENDING TO ISNEG:/home/ubuntu/spr-fast/tests/corebench/grep/grep-case-deccad69-db9d6340/tempworkdir2/neg.tmp!
Running test command:
/home/ubuntu/spr-fast/tools/grep-test.py /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-deccad69-db9d6340/tempworkdir2/src /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-deccad69-db9d6340/tempworkdir2/tests /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-deccad69-db9d6340/tempworkdir2 0  > __res
a batched test job starts!
Building merged code:
src_file: src/search.c
full src: int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
/* search.c - searching subroutines using dfa, kwset and regex for grep.
   Copyright 1992, 1998, 2000, 2007, 2009-2010 Free Software Foundation, Inc.

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 3, or (at your option)
   any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program; if not, write to the Free Software
   Foundation, Inc., 51 Franklin Street - Fifth Floor, Boston, MA
   02110-1301, USA.  */

/* Written August 1992 by Mike Haertel. */

#include <config.h>

#include <sys/types.h>

#include "mbsupport.h"
#ifdef MBS_SUPPORT
/* We can handle multibyte strings. */
# include <wchar.h>
# include <wctype.h>
#endif

#include "system.h"
#include "grep.h"
#ifndef FGREP_PROGRAM
# include <regex.h>
# include "dfa.h"
#endif
#include "kwset.h"
#include "error.h"
#include "xalloc.h"
#ifdef HAVE_LIBPCRE
# include <pcre.h>
#endif

#define NCHAR (UCHAR_MAX + 1)

/* For -w, we also consider _ to be word constituent.  */
#define WCHAR(C) (ISALNUM(C) || (C) == '_')

/* KWset compiled pattern.  For Ecompile and Gcompile, we compile
   a list of strings, at least one of which is known to occur in
   any string matching the regexp. */
static kwset_t kwset;

static void
kwsinit (void)
{
  static char trans[NCHAR];
  int i;

  if (match_icase && MB_CUR_MAX == 1)
    {
      for (i = 0; i < NCHAR; ++i)
        trans[i] = TOLOWER (i);

      kwset = kwsalloc (trans);
    }
  else
    kwset = kwsalloc (NULL);

  if (!kwset)
    xalloc_die ();
}

#ifdef MBS_SUPPORT
/* Convert the *N-byte string, BEG, to lowercase, and write the
   NUL-terminated result into malloc'd storage.  Upon success, set *N
   to the length (in bytes) of the resulting string (not including the
   trailing NUL byte), and return a pointer to the lowercase string.
   Upon memory allocation failure, this function exits.

   Note that while this function returns a pointer to malloc'd storage,
   the caller must not free it, since this function retains a pointer
   to the buffer and reuses it on any subsequent call.  As a consequence,
   this function is not thread-safe.  */
static char *
mbtolower (const char *beg, size_t *n)
{
  static char *out;
  static size_t outalloc;
  size_t outlen, mb_cur_max;
  mbstate_t is, os;
  const char *end;
  char *p;

  if (*n > outalloc)
    {
      out = xrealloc (out, *n);
      outalloc = *n;
    }

  memset (&is, 0, sizeof (is));
  memset (&os, 0, sizeof (os));
  end = beg + *n;

  mb_cur_max = MB_CUR_MAX;
  p = out;
  outlen = 0;
  while (beg < end)
    {
      wchar_t wc;
      size_t mbclen = mbrtowc(&wc, beg, end - beg, &is);
      if (outlen + mb_cur_max >= outalloc)
        {
          out = x2nrealloc (out, &outalloc, 1);
          p = out + outlen;
        }

      if (mbclen == (size_t) -1 || mbclen == (size_t) -2 || mbclen == 0)
        {
          /* An invalid sequence, or a truncated multi-octet character.
             We treat it as a single-octet character.  */
          *p++ = *beg++;
          outlen++;
          memset (&is, 0, sizeof (is));
          memset (&os, 0, sizeof (os));
        }
      else
        {
          beg += mbclen;
          mbclen = wcrtomb (p, towlower ((wint_t) wc), &os);
          p += mbclen;
          outlen += mbclen;
        }
    }

  *n = p - out;
  *p++ = 0;
  return out;
}
#endif


#ifndef FGREP_PROGRAM
/* DFA compiled regexp. */
static struct dfa dfa;

/* The Regex compiled patterns.  */
static struct patterns
{
  /* Regex compiled regexp. */
  struct re_pattern_buffer regexbuf;
  struct re_registers regs; /* This is here on account of a BRAIN-DEAD
			       Q@#%!# library interface in regex.c.  */
} patterns0;

struct patterns *patterns;
size_t pcount;

void
dfaerror (char const *mesg)
{
  error (EXIT_TROUBLE, 0, "%s", mesg);
}

/* Number of compiled fixed strings known to exactly match the regexp.
   If kwsexec returns < kwset_exact_matches, then we don't need to
   call the regexp matcher at all. */
static int kwset_exact_matches;

static char const *
kwsincr_case (const char *must)
{
  const char *buf;
  size_t n;

  n = strlen (must);
#ifdef MBS_SUPPORT
  if (match_icase && MB_CUR_MAX > 1)
    buf = mbtolower (must, &n);
  else
#endif
    buf = must;
  return kwsincr (kwset, buf, n);
}

/* If the DFA turns out to have some set of fixed strings one of
   which must occur in the match, then we build a kwset matcher
   to find those strings, and thus quickly filter out impossible
   matches. */
static void
kwsmusts (void)
{
  struct dfamust const *dm;
  char const *err;

  if (dfa.musts)
    {
      kwsinit ();
      /* First, we compile in the substrings known to be exact
	 matches.  The kwset matcher will return the index
	 of the matching string that it chooses. */
      for (dm = dfa.musts; dm; dm = dm->next)
	{
	  if (!dm->exact)
	    continue;
	  ++kwset_exact_matches;
	  if ((err = kwsincr_case (dm->must)) != NULL)
	    error (EXIT_TROUBLE, 0, "%s", err);
	}
      /* Now, we compile the substrings that will require
	 the use of the regexp matcher.  */
      for (dm = dfa.musts; dm; dm = dm->next)
	{
	  if (dm->exact)
	    continue;
	  if ((err = kwsincr_case (dm->must)) != NULL)
	    error (EXIT_TROUBLE, 0, "%s", err);
	}
      if ((err = kwsprep (kwset)) != NULL)
	error (EXIT_TROUBLE, 0, "%s", err);
    }
}
#endif /* !FGREP_PROGRAM */

#ifdef MBS_SUPPORT

static bool
is_mb_middle(const char **good, const char *buf, const char *end)
{
  const char *p = *good;
  const char *prev = p;
  mbstate_t cur_state;

  /* TODO: can be optimized for UTF-8.  */
  memset(&cur_state, 0, sizeof(mbstate_t));
  while (p < buf)
    {
      size_t mbclen = mbrlen(p, end - p, &cur_state);

      /* Store the beginning of the previous complete multibyte character.  */
      if (mbclen != (size_t) -2)
        prev = p;

      if (mbclen == (size_t) -1 || mbclen == (size_t) -2 || mbclen == 0)
	{
	  /* An invalid sequence, or a truncated multibyte character.
	     We treat it as a single byte character.  */
	  mbclen = 1;
	}
      p += mbclen;
    }

  *good = prev;
  return p > buf;
}
#endif /* MBS_SUPPORT */

#if defined(GREP_PROGRAM) || defined(EGREP_PROGRAM)
#ifdef EGREP_PROGRAM
COMPILE_FCT(Ecompile)
{
  reg_syntax_t syntax_bits = RE_SYNTAX_POSIX_EGREP;
#else
/* No __VA_ARGS__ in C89.  So we have to do it this way.  */
static COMPILE_RET
GEAcompile (char const *pattern, size_t size, reg_syntax_t syntax_bits)
{
#endif /* EGREP_PROGRAM */
  const char *err;
  const char *p, *sep;
  size_t total = size;
  char *motif;

  if (match_icase)
    syntax_bits |= RE_ICASE;
  re_set_syntax (syntax_bits);
  dfasyntax (syntax_bits, match_icase, eolbyte);

  /* For GNU regex compiler we have to pass the patterns separately to detect
     errors like "[\nallo\n]\n".  The patterns here are "[", "allo" and "]"
     GNU regex should have raise a syntax error.  The same for backref, where
     the backref should have been local to each pattern.  */
  p = pattern;
  do
    {
      size_t len;
      sep = memchr (p, '\n', total);
      if (sep)
	{
	  len = sep - p;
	  sep++;
	  total -= (len + 1);
	}
      else
	{
	  len = total;
	  total = 0;
	}

      patterns = realloc (patterns, (pcount + 1) * sizeof (*patterns));
      if (patterns == NULL)
	error (EXIT_TROUBLE, errno, _("memory exhausted"));
      patterns[pcount] = patterns0;

      if ((err = re_compile_pattern (p, len,
				    &(patterns[pcount].regexbuf))) != NULL)
	error (EXIT_TROUBLE, 0, "%s", err);
      pcount++;

      p = sep;
    } while (sep && total != 0);

  /* In the match_words and match_lines cases, we use a different pattern
     for the DFA matcher that will quickly throw out cases that won't work.
     Then if DFA succeeds we do some hairy stuff using the regex matcher
     to decide whether the match should really count. */
  if (match_words || match_lines)
    {
      static char const line_beg_no_bk[] = "^(";
      static char const line_end_no_bk[] = ")$";
      static char const word_beg_no_bk[] = "(^|[^[:alnum:]_])(";
      static char const word_end_no_bk[] = ")([^[:alnum:]_]|$)";
#ifdef EGREP_PROGRAM
# define IF_BK(x, y) (y)
      char *n = xmalloc (sizeof word_beg_no_bk - 1 + size + sizeof word_end_no_bk);
#else
      static char const line_beg_bk[] = "^\\(";
      static char const line_end_bk[] = "\\)$";
      static char const word_beg_bk[] = "\\(^\\|[^[:alnum:]_]\\)\\(";
      static char const word_end_bk[] = "\\)\\([^[:alnum:]_]\\|$\\)";
      int bk = !(syntax_bits & RE_NO_BK_PARENS);
# define IF_BK(x, y) ((bk) ? (x) : (y))
      char *n = xmalloc (sizeof word_beg_bk - 1 + size + sizeof word_end_bk);
#endif /* EGREP_PROGRAM */

      strcpy (n, match_lines ? IF_BK(line_beg_bk, line_beg_no_bk)
			     : IF_BK(word_beg_bk, word_beg_no_bk));
      total = strlen(n);
      memcpy (n + total, pattern, size);
      total += size;
      strcpy (n + total, match_lines ? IF_BK(line_end_bk, line_end_no_bk)
				     : IF_BK(word_end_bk, word_end_no_bk));
      total += strlen (n + total);
      pattern = motif = n;
      size = total;
    }
  else
    motif = NULL;

  dfacomp (pattern, size, &dfa, 1);
  kwsmusts ();

  free(motif);
}

#ifndef EGREP_PROGRAM
COMPILE_FCT(Gcompile)
{
  return GEAcompile (pattern, size,
		     RE_SYNTAX_GREP | RE_HAT_LISTS_NOT_NEWLINE);
}

COMPILE_FCT(Acompile)
{
  return GEAcompile (pattern, size, RE_SYNTAX_AWK);
}

COMPILE_FCT(Ecompile)
{
  return GEAcompile (pattern, size, RE_SYNTAX_POSIX_EGREP);
}
#endif /* !EGREP_PROGRAM */

EXECUTE_FCT(EGexecute)
{
  char const *buflim, *beg, *end, *match, *best_match, *mb_start;
  char eol = eolbyte;
  int backref, start, len, best_len;
  struct kwsmatch kwsm;
  size_t i, ret_val;
#ifdef MBS_SUPPORT
  if (MB_CUR_MAX > 1)
    {
      if (match_icase)
        {
          /* mbtolower adds a NUL byte at the end.  That will provide
	     space for the sentinel byte dfaexec may add.  */
          char *case_buf = mbtolower (buf, &size);
	  if (start_ptr)
	    start_ptr = case_buf + (start_ptr - buf);
          buf = case_buf;
        }
    }
#endif /* MBS_SUPPORT */

  mb_start = buf;
  buflim = buf + size;

  for (beg = end = buf; end < buflim; beg = end)
    {
      if (!start_ptr)
	{
	  /* We don't care about an exact match.  */
	  if (kwset)
	    {
	      /* Find a possible match using the KWset matcher. */
	      size_t offset = kwsexec (kwset, beg, buflim - beg, &kwsm);
	      if (offset == (size_t) -1)
		goto failure;
	      beg += offset;
	      /* Narrow down to the line containing the candidate, and
		 run it through DFA. */
	      if ((end = memchr(beg, eol, buflim - beg)) != NULL)
	        end++;
              else
                end = buflim;
	      match = beg;
	      while (beg > buf && beg[-1] != eol)
		--beg;
	      if (kwsm.index < kwset_exact_matches)
                {
#ifdef MBS_SUPPORT
                  if (mb_start < beg)
                    mb_start = beg;
                  if (MB_CUR_MAX == 1 || !is_mb_middle (&mb_start, match, buflim))
#endif
                    goto success;
                }
	      if (dfaexec (&dfa, beg, (char *) end, 0, NULL, &backref) == NULL)
		continue;
	    }
	  else
	    {
	      /* No good fixed strings; start with DFA. */
	      char const *next_beg = dfaexec (&dfa, beg, (char *) buflim,
					      0, NULL, &backref);
	      if (next_beg == NULL)
		break;
	      /* Narrow down to the line we've found. */
	      beg = next_beg;
	      if ((end = memchr(beg, eol, buflim - beg)) != NULL)
	        end++;
              else
                end = buflim;
	      while (beg > buf && beg[-1] != eol)
		--beg;
	    }
	  /* Successful, no backreferences encountered! */
	  if (!backref)
	    goto success;
	}
      else
	{
	  /* We are looking for the leftmost (then longest) exact match.
	     We will go through the outer loop only once.  */
	  beg = start_ptr;
	  end = buflim;
	}

      /* If we've made it to this point, this means DFA has seen
	 a probable match, and we need to run it through Regex. */
      best_match = end;
      best_len = 0;
      for (i = 0; i < pcount; i++)
	{
	  patterns[i].regexbuf.not_eol = 0;
	  if (0 <= (start = re_search (&(patterns[i].regexbuf),
				       buf, end - buf - 1,
				       beg - buf, end - beg - 1,
				       &(patterns[i].regs))))
	    {
	      len = patterns[i].regs.end[0] - start;
	      match = buf + start;
	      if (match > best_match)
		continue;
	      if (start_ptr && !match_words)
		goto assess_pattern_match;
	      if ((!match_lines && !match_words)
		  || (match_lines && len == end - beg - 1))
		{
		  match = beg;
		  len = end - beg;
		  goto assess_pattern_match;
		}
	      /* If -w, check if the match aligns with word boundaries.
		 We do this iteratively because:
		 (a) the line may contain more than one occurence of the
		 pattern, and
		 (b) Several alternatives in the pattern might be valid at a
		 given point, and we may need to consider a shorter one to
		 find a word boundary.  */
	      if (match_words)
		while (match <= best_match)
		  {
		    if ((match == buf || !WCHAR ((unsigned char) match[-1]))
			&& (len == end - beg - 1
			    || !WCHAR ((unsigned char) match[len])))
		      goto assess_pattern_match;
		    if (len > 0)
		      {
			/* Try a shorter length anchored at the same place. */
			--len;
			patterns[i].regexbuf.not_eol = 1;
			len = re_match (&(patterns[i].regexbuf),
					buf, match + len - beg, match - buf,
					&(patterns[i].regs));
		      }
		    if (len <= 0)
		      {
			/* Try looking further on. */
			if (match == end - 1)
			  break;
			match++;
			patterns[i].regexbuf.not_eol = 0;
			start = re_search (&(patterns[i].regexbuf),
					   buf, end - buf - 1,
					   match - buf, end - match - 1,
					   &(patterns[i].regs));
			if (start < 0)
			  break;
			len = patterns[i].regs.end[0] - start;
			match = buf + start;
		      }
		  } /* while (match <= best_match) */
	      continue;
	    assess_pattern_match:
	      if (!start_ptr)
		{
		  /* Good enough for a non-exact match.
		     No need to look at further patterns, if any.  */
		  beg = match;
		  goto success_in_len;
		}
	      if (match < best_match || (match == best_match && len > best_len))
		{
		  /* Best exact match:  leftmost, then longest.  */
		  best_match = match;
		  best_len = len;
		}
	    } /* if re_search >= 0 */
	} /* for Regex patterns.  */
	if (best_match < end)
	  {
	    /* We have found an exact match.  We were just
	       waiting for the best one (leftmost then longest).  */
	    beg = best_match;
	    len = best_len;
	    goto success_in_len;
	  }
    } /* for (beg = end ..) */

 failure:
  ret_val = -1;
  goto out;

 success:
  len = end - beg;
 success_in_len:
  *match_size = len;
  ret_val = beg - buf;
 out:
  return ret_val;
}
#endif /* defined(GREP_PROGRAM) || defined(EGREP_PROGRAM) */

#if defined(GREP_PROGRAM) || defined(FGREP_PROGRAM)
COMPILE_FCT(Fcompile)
{
  char const *beg, *end, *lim, *err, *pat;
  size_t psize;

  kwsinit ();
  psize = size;
  if (match_icase && MB_CUR_MAX > 1)
    pat = mbtolower (pattern, &psize);
  else
    pat = pattern;

  beg = pat;
  do
    {
      for (lim = beg;; ++lim)
	{
	  end = lim;
	  if (lim >= pat + psize)
	    break;
	 if (*lim == '\n')
	   {
	     lim++;
	     break;
	   }
#if HAVE_DOS_FILE_CONTENTS
	 if (*lim == '\r' && lim + 1 < pat + psize && lim[1] == '\n')
	   {
	     lim += 2;
	     break;
	   }
#endif
	}

      if ((err = kwsincr (kwset, beg, end - beg)) != NULL)
	error (EXIT_TROUBLE, 0, "%s", err);
      beg = lim;
    }
  while (beg < pat + psize);

  if ((err = kwsprep (kwset)) != NULL)
    error (EXIT_TROUBLE, 0, "%s", err);
}

EXECUTE_FCT(Fexecute)
{
  char const *beg, *try, *end, *mb_start;
  size_t len;
  char eol = eolbyte;
  struct kwsmatch kwsmatch;
  size_t ret_val;
#ifdef MBS_SUPPORT
  if (MB_CUR_MAX > 1)
    {
      //prophet generated patch
      if (__get_mutant()==0) {
      if ((match_icase) && !(__is_neg(16, &(match_icase), sizeof (match_icase), &(buf), sizeof (buf), &(size), sizeof (size), &(start_ptr), sizeof (start_ptr), &(eolbyte), sizeof (eolbyte), &(beg), sizeof (beg), &(mb_start), sizeof (mb_start), &(kwset), sizeof (kwset), &(len), sizeof (len), &(match_words), sizeof (match_words), &(match_lines), sizeof (match_lines), &(eol), sizeof (eol), &(try), sizeof (try), &(ret_val), sizeof (ret_val), &(end), sizeof (end), &(match_size), sizeof (match_size)))) {
          char *case_buf = mbtolower(buf, &size);
          if (start_ptr)
              start_ptr = case_buf + (start_ptr - buf);
          buf = case_buf;
      }
      }
      else if (__get_mutant()==1) {
      if ((match_icase) || (__is_neg(16, &(match_icase), sizeof (match_icase), &(buf), sizeof (buf), &(size), sizeof (size), &(start_ptr), sizeof (start_ptr), &(eolbyte), sizeof (eolbyte), &(beg), sizeof (beg), &(mb_start), sizeof (mb_start), &(kwset), sizeof (kwset), &(len), sizeof (len), &(match_words), sizeof (match_words), &(match_lines), sizeof (match_lines), &(eol), sizeof (eol), &(try), sizeof (try), &(ret_val), sizeof (ret_val), &(end), sizeof (end), &(match_size), sizeof (match_size)))) {
          char *case_buf = mbtolower(buf, &size);
          if (start_ptr)
              start_ptr = case_buf + (start_ptr - buf);
          buf = case_buf;
      }
      }
    }
#endif /* MBS_SUPPORT */

  for (mb_start = beg = start_ptr ? start_ptr : buf; beg <= buf + size; beg++)
    {
      size_t offset = kwsexec (kwset, beg, buf + size - beg, &kwsmatch);
      if (offset == (size_t) -1)
	goto failure;
#ifdef MBS_SUPPORT
      if (MB_CUR_MAX > 1 && is_mb_middle (&mb_start, beg + offset, buf + size))
        {
          beg = mb_start - 1;
          continue; /* It is a part of multibyte character.  */
        }
#endif /* MBS_SUPPORT */
      beg += offset;
      len = kwsmatch.size[0];
      if (start_ptr && !match_words)
	goto success_in_beg_and_len;
      if (match_lines)
	{
	  if (beg > buf && beg[-1] != eol)
	    continue;
	  if (beg + len < buf + size && beg[len] != eol)
	    continue;
	  goto success;
	}
      else if (match_words)
	for (try = beg; len; )
	  {
	    if (try > buf && WCHAR((unsigned char) try[-1]))
	      break;
	    if (try + len < buf + size && WCHAR((unsigned char) try[len]))
	      {
		offset = kwsexec (kwset, beg, --len, &kwsmatch);
		if (offset == (size_t) -1)
		  break;
		try = beg + offset;
		len = kwsmatch.size[0];
	      }
	    else if (!start_ptr)
	      goto success;
	    else
	      goto success_in_beg_and_len;
	  } /* for (try) */
      else
	goto success;
    } /* for (beg in buf) */

 failure:
  ret_val = -1;
  goto out;

 success:
  if ((end = memchr (beg + len, eol, (buf + size) - (beg + len))) != NULL)
    end++;
  else
    end = buf + size;
  while (buf < beg && beg[-1] != eol)
    --beg;
  len = end - beg;
 success_in_beg_and_len:
  *match_size = len;
  ret_val = beg - buf;
 out:
  return ret_val;
}
#endif /* defined(GREP_PROGRAM) || defined(FGREP_PROGRAM) */

#ifdef GREP_PROGRAM
#if HAVE_LIBPCRE
/* Compiled internal form of a Perl regular expression.  */
static pcre *cre;

/* Additional information about the pattern.  */
static pcre_extra *extra;
#endif

COMPILE_FCT(Pcompile)
{
#if !HAVE_LIBPCRE
  error (EXIT_TROUBLE, 0, "%s",
	 _("support for the -P option is not compiled into "
	   "this --disable-perl-regexp binary"));
#else
  int e;
  char const *ep;
  char *re = xmalloc (4 * size + 7);
  int flags = PCRE_MULTILINE | (match_icase ? PCRE_CASELESS : 0);
  char const *patlim = pattern + size;
  char *n = re;
  char const *p;
  char const *pnul;

  /* FIXME: Remove these restrictions.  */
  if (memchr(pattern, '\n', size))
    error (EXIT_TROUBLE, 0, _("the -P option only supports a single pattern"));

  *n = '\0';
  if (match_lines)
    strcpy (n, "^(");
  if (match_words)
    strcpy (n, "\\b(");
  n += strlen (n);

  /* The PCRE interface doesn't allow NUL bytes in the pattern, so
     replace each NUL byte in the pattern with the four characters
     "\000", removing a preceding backslash if there are an odd
     number of backslashes before the NUL.

     FIXME: This method does not work with some multibyte character
     encodings, notably Shift-JIS, where a multibyte character can end
     in a backslash byte.  */
  for (p = pattern; (pnul = memchr (p, '\0', patlim - p)); p = pnul + 1)
    {
      memcpy (n, p, pnul - p);
      n += pnul - p;
      for (p = pnul; pattern < p && p[-1] == '\\'; p--)
	continue;
      n -= (pnul - p) & 1;
      strcpy (n, "\\000");
      n += 4;
    }

  memcpy (n, p, patlim - p);
  n += patlim - p;
  *n = '\0';
  if (match_words)
    strcpy (n, ")\\b");
  if (match_lines)
    strcpy (n, ")$");

  cre = pcre_compile (re, flags, &ep, &e, pcre_maketables ());
  if (!cre)
    error (EXIT_TROUBLE, 0, "%s", ep);

  extra = pcre_study (cre, 0, &ep);
  if (ep)
    error (EXIT_TROUBLE, 0, "%s", ep);

  free (re);
#endif
}

EXECUTE_FCT(Pexecute)
{
#if !HAVE_LIBPCRE
  abort ();
  return -1;
#else
  /* This array must have at least two elements; everything after that
     is just for performance improvement in pcre_exec.  */
  int sub[300];

  const char *line_buf, *line_end, *line_next;
  int e = PCRE_ERROR_NOMATCH;
  ptrdiff_t start_ofs = start_ptr ? start_ptr - buf : 0;

  /* PCRE can't limit the matching to single lines, therefore we have to
     match each line in the buffer separately.  */
  for (line_next = buf;
       e == PCRE_ERROR_NOMATCH && line_next < buf + size;
       start_ofs -= line_next - line_buf)
    {
      line_buf = line_next;
      line_end = memchr (line_buf, eolbyte, (buf + size) - line_buf);
      if (line_end == NULL)
        line_next = line_end = buf + size;
      else
        line_next = line_end + 1;

      if (start_ptr && start_ptr >= line_end)
        continue;

      e = pcre_exec (cre, extra, line_buf, line_end - line_buf,
                     start_ofs < 0 ? 0 : start_ofs, 0,
                     sub, sizeof sub / sizeof *sub);
    }

  if (e <= 0)
    {
      switch (e)
	{
	case PCRE_ERROR_NOMATCH:
	  return -1;

	case PCRE_ERROR_NOMEMORY:
	  error (EXIT_TROUBLE, 0, _("memory exhausted"));

	default:
	  abort ();
	}
    }
  else
    {
      /* Narrow down to the line we've found.  */
      char const *beg = line_buf + sub[0];
      char const *end = line_buf + sub[1];
      char const *buflim = buf + size;
      char eol = eolbyte;
      if (!start_ptr)
	{
	  /* FIXME: The case when '\n' is not found indicates a bug:
	     Since grep is line oriented, the match should never contain
	     a newline, so there _must_ be a newline following.
	   */
	  if (!(end = memchr (end, eol, buflim - end)))
	    end = buflim;
	  else
	    end++;
	  while (buf < beg && beg[-1] != eol)
	    --beg;
	}

      *match_size = end - beg;
      return beg - buf;
    }
#endif
}

struct matcher const matchers[] = {
  { "default", Gcompile, EGexecute },
  { "grep",    Gcompile, EGexecute },
  { "egrep",   Ecompile, EGexecute },
  { "awk",     Acompile, EGexecute },
  { "fgrep",   Fcompile, Fexecute },
  { "perl",    Pcompile, Pexecute },
  { "", 0, 0 },
};
#endif /* GREP_PROGRAM */

Building:src at:
/home/ubuntu/spr-fast/tests/corebench/grep/grep-case-deccad69-db9d6340/tempworkdir2/srcMerged code building succ, going to invoke tester!
CondTester, Testing instance id 24:
//src_file:src/search.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
/* search.c - searching subroutines using dfa, kwset and regex for grep.
   Copyright 1992, 1998, 2000, 2007, 2009-2010 Free Software Foundation, Inc.

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 3, or (at your option)
   any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program; if not, write to the Free Software
   Foundation, Inc., 51 Franklin Street - Fifth Floor, Boston, MA
   02110-1301, USA.  */

/* Written August 1992 by Mike Haertel. */

#include <config.h>

#include <sys/types.h>

#include "mbsupport.h"
#ifdef MBS_SUPPORT
/* We can handle multibyte strings. */
# include <wchar.h>
# include <wctype.h>
#endif

#include "system.h"
#include "grep.h"
#ifndef FGREP_PROGRAM
# include <regex.h>
# include "dfa.h"
#endif
#include "kwset.h"
#include "error.h"
#include "xalloc.h"
#ifdef HAVE_LIBPCRE
# include <pcre.h>
#endif

#define NCHAR (UCHAR_MAX + 1)

/* For -w, we also consider _ to be word constituent.  */
#define WCHAR(C) (ISALNUM(C) || (C) == '_')

/* KWset compiled pattern.  For Ecompile and Gcompile, we compile
   a list of strings, at least one of which is known to occur in
   any string matching the regexp. */
static kwset_t kwset;

static void
kwsinit (void)
{
  static char trans[NCHAR];
  int i;

  if (match_icase && MB_CUR_MAX == 1)
    {
      for (i = 0; i < NCHAR; ++i)
        trans[i] = TOLOWER (i);

      kwset = kwsalloc (trans);
    }
  else
    kwset = kwsalloc (NULL);

  if (!kwset)
    xalloc_die ();
}

#ifdef MBS_SUPPORT
/* Convert the *N-byte string, BEG, to lowercase, and write the
   NUL-terminated result into malloc'd storage.  Upon success, set *N
   to the length (in bytes) of the resulting string (not including the
   trailing NUL byte), and return a pointer to the lowercase string.
   Upon memory allocation failure, this function exits.

   Note that while this function returns a pointer to malloc'd storage,
   the caller must not free it, since this function retains a pointer
   to the buffer and reuses it on any subsequent call.  As a consequence,
   this function is not thread-safe.  */
static char *
mbtolower (const char *beg, size_t *n)
{
  static char *out;
  static size_t outalloc;
  size_t outlen, mb_cur_max;
  mbstate_t is, os;
  const char *end;
  char *p;

  if (*n > outalloc)
    {
      out = xrealloc (out, *n);
      outalloc = *n;
    }

  memset (&is, 0, sizeof (is));
  memset (&os, 0, sizeof (os));
  end = beg + *n;

  mb_cur_max = MB_CUR_MAX;
  p = out;
  outlen = 0;
  while (beg < end)
    {
      wchar_t wc;
      size_t mbclen = mbrtowc(&wc, beg, end - beg, &is);
      if (outlen + mb_cur_max >= outalloc)
        {
          out = x2nrealloc (out, &outalloc, 1);
          p = out + outlen;
        }

      if (mbclen == (size_t) -1 || mbclen == (size_t) -2 || mbclen == 0)
        {
          /* An invalid sequence, or a truncated multi-octet character.
             We treat it as a single-octet character.  */
          *p++ = *beg++;
          outlen++;
          memset (&is, 0, sizeof (is));
          memset (&os, 0, sizeof (os));
        }
      else
        {
          beg += mbclen;
          mbclen = wcrtomb (p, towlower ((wint_t) wc), &os);
          p += mbclen;
          outlen += mbclen;
        }
    }

  *n = p - out;
  *p++ = 0;
  return out;
}
#endif


#ifndef FGREP_PROGRAM
/* DFA compiled regexp. */
static struct dfa dfa;

/* The Regex compiled patterns.  */
static struct patterns
{
  /* Regex compiled regexp. */
  struct re_pattern_buffer regexbuf;
  struct re_registers regs; /* This is here on account of a BRAIN-DEAD
			       Q@#%!# library interface in regex.c.  */
} patterns0;

struct patterns *patterns;
size_t pcount;

void
dfaerror (char const *mesg)
{
  error (EXIT_TROUBLE, 0, "%s", mesg);
}

/* Number of compiled fixed strings known to exactly match the regexp.
   If kwsexec returns < kwset_exact_matches, then we don't need to
   call the regexp matcher at all. */
static int kwset_exact_matches;

static char const *
kwsincr_case (const char *must)
{
  const char *buf;
  size_t n;

  n = strlen (must);
#ifdef MBS_SUPPORT
  if (match_icase && MB_CUR_MAX > 1)
    buf = mbtolower (must, &n);
  else
#endif
    buf = must;
  return kwsincr (kwset, buf, n);
}

/* If the DFA turns out to have some set of fixed strings one of
   which must occur in the match, then we build a kwset matcher
   to find those strings, and thus quickly filter out impossible
   matches. */
static void
kwsmusts (void)
{
  struct dfamust const *dm;
  char const *err;

  if (dfa.musts)
    {
      kwsinit ();
      /* First, we compile in the substrings known to be exact
	 matches.  The kwset matcher will return the index
	 of the matching string that it chooses. */
      for (dm = dfa.musts; dm; dm = dm->next)
	{
	  if (!dm->exact)
	    continue;
	  ++kwset_exact_matches;
	  if ((err = kwsincr_case (dm->must)) != NULL)
	    error (EXIT_TROUBLE, 0, "%s", err);
	}
      /* Now, we compile the substrings that will require
	 the use of the regexp matcher.  */
      for (dm = dfa.musts; dm; dm = dm->next)
	{
	  if (dm->exact)
	    continue;
	  if ((err = kwsincr_case (dm->must)) != NULL)
	    error (EXIT_TROUBLE, 0, "%s", err);
	}
      if ((err = kwsprep (kwset)) != NULL)
	error (EXIT_TROUBLE, 0, "%s", err);
    }
}
#endif /* !FGREP_PROGRAM */

#ifdef MBS_SUPPORT

static bool
is_mb_middle(const char **good, const char *buf, const char *end)
{
  const char *p = *good;
  const char *prev = p;
  mbstate_t cur_state;

  /* TODO: can be optimized for UTF-8.  */
  memset(&cur_state, 0, sizeof(mbstate_t));
  while (p < buf)
    {
      size_t mbclen = mbrlen(p, end - p, &cur_state);

      /* Store the beginning of the previous complete multibyte character.  */
      if (mbclen != (size_t) -2)
        prev = p;

      if (mbclen == (size_t) -1 || mbclen == (size_t) -2 || mbclen == 0)
	{
	  /* An invalid sequence, or a truncated multibyte character.
	     We treat it as a single byte character.  */
	  mbclen = 1;
	}
      p += mbclen;
    }

  *good = prev;
  return p > buf;
}
#endif /* MBS_SUPPORT */

#if defined(GREP_PROGRAM) || defined(EGREP_PROGRAM)
#ifdef EGREP_PROGRAM
COMPILE_FCT(Ecompile)
{
  reg_syntax_t syntax_bits = RE_SYNTAX_POSIX_EGREP;
#else
/* No __VA_ARGS__ in C89.  So we have to do it this way.  */
static COMPILE_RET
GEAcompile (char const *pattern, size_t size, reg_syntax_t syntax_bits)
{
#endif /* EGREP_PROGRAM */
  const char *err;
  const char *p, *sep;
  size_t total = size;
  char *motif;

  if (match_icase)
    syntax_bits |= RE_ICASE;
  re_set_syntax (syntax_bits);
  dfasyntax (syntax_bits, match_icase, eolbyte);

  /* For GNU regex compiler we have to pass the patterns separately to detect
     errors like "[\nallo\n]\n".  The patterns here are "[", "allo" and "]"
     GNU regex should have raise a syntax error.  The same for backref, where
     the backref should have been local to each pattern.  */
  p = pattern;
  do
    {
      size_t len;
      sep = memchr (p, '\n', total);
      if (sep)
	{
	  len = sep - p;
	  sep++;
	  total -= (len + 1);
	}
      else
	{
	  len = total;
	  total = 0;
	}

      patterns = realloc (patterns, (pcount + 1) * sizeof (*patterns));
      if (patterns == NULL)
	error (EXIT_TROUBLE, errno, _("memory exhausted"));
      patterns[pcount] = patterns0;

      if ((err = re_compile_pattern (p, len,
				    &(patterns[pcount].regexbuf))) != NULL)
	error (EXIT_TROUBLE, 0, "%s", err);
      pcount++;

      p = sep;
    } while (sep && total != 0);

  /* In the match_words and match_lines cases, we use a different pattern
     for the DFA matcher that will quickly throw out cases that won't work.
     Then if DFA succeeds we do some hairy stuff using the regex matcher
     to decide whether the match should really count. */
  if (match_words || match_lines)
    {
      static char const line_beg_no_bk[] = "^(";
      static char const line_end_no_bk[] = ")$";
      static char const word_beg_no_bk[] = "(^|[^[:alnum:]_])(";
      static char const word_end_no_bk[] = ")([^[:alnum:]_]|$)";
#ifdef EGREP_PROGRAM
# define IF_BK(x, y) (y)
      char *n = xmalloc (sizeof word_beg_no_bk - 1 + size + sizeof word_end_no_bk);
#else
      static char const line_beg_bk[] = "^\\(";
      static char const line_end_bk[] = "\\)$";
      static char const word_beg_bk[] = "\\(^\\|[^[:alnum:]_]\\)\\(";
      static char const word_end_bk[] = "\\)\\([^[:alnum:]_]\\|$\\)";
      int bk = !(syntax_bits & RE_NO_BK_PARENS);
# define IF_BK(x, y) ((bk) ? (x) : (y))
      char *n = xmalloc (sizeof word_beg_bk - 1 + size + sizeof word_end_bk);
#endif /* EGREP_PROGRAM */

      strcpy (n, match_lines ? IF_BK(line_beg_bk, line_beg_no_bk)
			     : IF_BK(word_beg_bk, word_beg_no_bk));
      total = strlen(n);
      memcpy (n + total, pattern, size);
      total += size;
      strcpy (n + total, match_lines ? IF_BK(line_end_bk, line_end_no_bk)
				     : IF_BK(word_end_bk, word_end_no_bk));
      total += strlen (n + total);
      pattern = motif = n;
      size = total;
    }
  else
    motif = NULL;

  dfacomp (pattern, size, &dfa, 1);
  kwsmusts ();

  free(motif);
}

#ifndef EGREP_PROGRAM
COMPILE_FCT(Gcompile)
{
  return GEAcompile (pattern, size,
		     RE_SYNTAX_GREP | RE_HAT_LISTS_NOT_NEWLINE);
}

COMPILE_FCT(Acompile)
{
  return GEAcompile (pattern, size, RE_SYNTAX_AWK);
}

COMPILE_FCT(Ecompile)
{
  return GEAcompile (pattern, size, RE_SYNTAX_POSIX_EGREP);
}
#endif /* !EGREP_PROGRAM */

EXECUTE_FCT(EGexecute)
{
  char const *buflim, *beg, *end, *match, *best_match, *mb_start;
  char eol = eolbyte;
  int backref, start, len, best_len;
  struct kwsmatch kwsm;
  size_t i, ret_val;
#ifdef MBS_SUPPORT
  if (MB_CUR_MAX > 1)
    {
      if (match_icase)
        {
          /* mbtolower adds a NUL byte at the end.  That will provide
	     space for the sentinel byte dfaexec may add.  */
          char *case_buf = mbtolower (buf, &size);
	  if (start_ptr)
	    start_ptr = case_buf + (start_ptr - buf);
          buf = case_buf;
        }
    }
#endif /* MBS_SUPPORT */

  mb_start = buf;
  buflim = buf + size;

  for (beg = end = buf; end < buflim; beg = end)
    {
      if (!start_ptr)
	{
	  /* We don't care about an exact match.  */
	  if (kwset)
	    {
	      /* Find a possible match using the KWset matcher. */
	      size_t offset = kwsexec (kwset, beg, buflim - beg, &kwsm);
	      if (offset == (size_t) -1)
		goto failure;
	      beg += offset;
	      /* Narrow down to the line containing the candidate, and
		 run it through DFA. */
	      if ((end = memchr(beg, eol, buflim - beg)) != NULL)
	        end++;
              else
                end = buflim;
	      match = beg;
	      while (beg > buf && beg[-1] != eol)
		--beg;
	      if (kwsm.index < kwset_exact_matches)
                {
#ifdef MBS_SUPPORT
                  if (mb_start < beg)
                    mb_start = beg;
                  if (MB_CUR_MAX == 1 || !is_mb_middle (&mb_start, match, buflim))
#endif
                    goto success;
                }
	      if (dfaexec (&dfa, beg, (char *) end, 0, NULL, &backref) == NULL)
		continue;
	    }
	  else
	    {
	      /* No good fixed strings; start with DFA. */
	      char const *next_beg = dfaexec (&dfa, beg, (char *) buflim,
					      0, NULL, &backref);
	      if (next_beg == NULL)
		break;
	      /* Narrow down to the line we've found. */
	      beg = next_beg;
	      if ((end = memchr(beg, eol, buflim - beg)) != NULL)
	        end++;
              else
                end = buflim;
	      while (beg > buf && beg[-1] != eol)
		--beg;
	    }
	  /* Successful, no backreferences encountered! */
	  if (!backref)
	    goto success;
	}
      else
	{
	  /* We are looking for the leftmost (then longest) exact match.
	     We will go through the outer loop only once.  */
	  beg = start_ptr;
	  end = buflim;
	}

      /* If we've made it to this point, this means DFA has seen
	 a probable match, and we need to run it through Regex. */
      best_match = end;
      best_len = 0;
      for (i = 0; i < pcount; i++)
	{
	  patterns[i].regexbuf.not_eol = 0;
	  if (0 <= (start = re_search (&(patterns[i].regexbuf),
				       buf, end - buf - 1,
				       beg - buf, end - beg - 1,
				       &(patterns[i].regs))))
	    {
	      len = patterns[i].regs.end[0] - start;
	      match = buf + start;
	      if (match > best_match)
		continue;
	      if (start_ptr && !match_words)
		goto assess_pattern_match;
	      if ((!match_lines && !match_words)
		  || (match_lines && len == end - beg - 1))
		{
		  match = beg;
		  len = end - beg;
		  goto assess_pattern_match;
		}
	      /* If -w, check if the match aligns with word boundaries.
		 We do this iteratively because:
		 (a) the line may contain more than one occurence of the
		 pattern, and
		 (b) Several alternatives in the pattern might be valid at a
		 given point, and we may need to consider a shorter one to
		 find a word boundary.  */
	      if (match_words)
		while (match <= best_match)
		  {
		    if ((match == buf || !WCHAR ((unsigned char) match[-1]))
			&& (len == end - beg - 1
			    || !WCHAR ((unsigned char) match[len])))
		      goto assess_pattern_match;
		    if (len > 0)
		      {
			/* Try a shorter length anchored at the same place. */
			--len;
			patterns[i].regexbuf.not_eol = 1;
			len = re_match (&(patterns[i].regexbuf),
					buf, match + len - beg, match - buf,
					&(patterns[i].regs));
		      }
		    if (len <= 0)
		      {
			/* Try looking further on. */
			if (match == end - 1)
			  break;
			match++;
			patterns[i].regexbuf.not_eol = 0;
			start = re_search (&(patterns[i].regexbuf),
					   buf, end - buf - 1,
					   match - buf, end - match - 1,
					   &(patterns[i].regs));
			if (start < 0)
			  break;
			len = patterns[i].regs.end[0] - start;
			match = buf + start;
		      }
		  } /* while (match <= best_match) */
	      continue;
	    assess_pattern_match:
	      if (!start_ptr)
		{
		  /* Good enough for a non-exact match.
		     No need to look at further patterns, if any.  */
		  beg = match;
		  goto success_in_len;
		}
	      if (match < best_match || (match == best_match && len > best_len))
		{
		  /* Best exact match:  leftmost, then longest.  */
		  best_match = match;
		  best_len = len;
		}
	    } /* if re_search >= 0 */
	} /* for Regex patterns.  */
	if (best_match < end)
	  {
	    /* We have found an exact match.  We were just
	       waiting for the best one (leftmost then longest).  */
	    beg = best_match;
	    len = best_len;
	    goto success_in_len;
	  }
    } /* for (beg = end ..) */

 failure:
  ret_val = -1;
  goto out;

 success:
  len = end - beg;
 success_in_len:
  *match_size = len;
  ret_val = beg - buf;
 out:
  return ret_val;
}
#endif /* defined(GREP_PROGRAM) || defined(EGREP_PROGRAM) */

#if defined(GREP_PROGRAM) || defined(FGREP_PROGRAM)
COMPILE_FCT(Fcompile)
{
  char const *beg, *end, *lim, *err, *pat;
  size_t psize;

  kwsinit ();
  psize = size;
  if (match_icase && MB_CUR_MAX > 1)
    pat = mbtolower (pattern, &psize);
  else
    pat = pattern;

  beg = pat;
  do
    {
      for (lim = beg;; ++lim)
	{
	  end = lim;
	  if (lim >= pat + psize)
	    break;
	 if (*lim == '\n')
	   {
	     lim++;
	     break;
	   }
#if HAVE_DOS_FILE_CONTENTS
	 if (*lim == '\r' && lim + 1 < pat + psize && lim[1] == '\n')
	   {
	     lim += 2;
	     break;
	   }
#endif
	}

      if ((err = kwsincr (kwset, beg, end - beg)) != NULL)
	error (EXIT_TROUBLE, 0, "%s", err);
      beg = lim;
    }
  while (beg < pat + psize);

  if ((err = kwsprep (kwset)) != NULL)
    error (EXIT_TROUBLE, 0, "%s", err);
}

EXECUTE_FCT(Fexecute)
{
  char const *beg, *try, *end, *mb_start;
  size_t len;
  char eol = eolbyte;
  struct kwsmatch kwsmatch;
  size_t ret_val;
#ifdef MBS_SUPPORT
  if (MB_CUR_MAX > 1)
    {
      
//Patch 0:
if ((match_icase) && !(__is_neg(16, &(match_icase), sizeof (match_icase), &(buf), sizeof (buf), &(size), sizeof (size), &(start_ptr), sizeof (start_ptr), &(eolbyte), sizeof (eolbyte), &(beg), sizeof (beg), &(mb_start), sizeof (mb_start), &(kwset), sizeof (kwset), &(len), sizeof (len), &(match_words), sizeof (match_words), &(match_lines), sizeof (match_lines), &(eol), sizeof (eol), &(try), sizeof (try), &(ret_val), sizeof (ret_val), &(end), sizeof (end), &(match_size), sizeof (match_size)))) {
    char *case_buf = mbtolower(buf, &size);
    if (start_ptr)
        start_ptr = case_buf + (start_ptr - buf);
    buf = case_buf;
}

//CodeSeg 1:
    }
#endif /* MBS_SUPPORT */

  for (mb_start = beg = start_ptr ? start_ptr : buf; beg <= buf + size; beg++)
    {
      size_t offset = kwsexec (kwset, beg, buf + size - beg, &kwsmatch);
      if (offset == (size_t) -1)
	goto failure;
#ifdef MBS_SUPPORT
      if (MB_CUR_MAX > 1 && is_mb_middle (&mb_start, beg + offset, buf + size))
        {
          beg = mb_start - 1;
          continue; /* It is a part of multibyte character.  */
        }
#endif /* MBS_SUPPORT */
      beg += offset;
      len = kwsmatch.size[0];
      if (start_ptr && !match_words)
	goto success_in_beg_and_len;
      if (match_lines)
	{
	  if (beg > buf && beg[-1] != eol)
	    continue;
	  if (beg + len < buf + size && beg[len] != eol)
	    continue;
	  goto success;
	}
      else if (match_words)
	for (try = beg; len; )
	  {
	    if (try > buf && WCHAR((unsigned char) try[-1]))
	      break;
	    if (try + len < buf + size && WCHAR((unsigned char) try[len]))
	      {
		offset = kwsexec (kwset, beg, --len, &kwsmatch);
		if (offset == (size_t) -1)
		  break;
		try = beg + offset;
		len = kwsmatch.size[0];
	      }
	    else if (!start_ptr)
	      goto success;
	    else
	      goto success_in_beg_and_len;
	  } /* for (try) */
      else
	goto success;
    } /* for (beg in buf) */

 failure:
  ret_val = -1;
  goto out;

 success:
  if ((end = memchr (beg + len, eol, (buf + size) - (beg + len))) != NULL)
    end++;
  else
    end = buf + size;
  while (buf < beg && beg[-1] != eol)
    --beg;
  len = end - beg;
 success_in_beg_and_len:
  *match_size = len;
  ret_val = beg - buf;
 out:
  return ret_val;
}
#endif /* defined(GREP_PROGRAM) || defined(FGREP_PROGRAM) */

#ifdef GREP_PROGRAM
#if HAVE_LIBPCRE
/* Compiled internal form of a Perl regular expression.  */
static pcre *cre;

/* Additional information about the pattern.  */
static pcre_extra *extra;
#endif

COMPILE_FCT(Pcompile)
{
#if !HAVE_LIBPCRE
  error (EXIT_TROUBLE, 0, "%s",
	 _("support for the -P option is not compiled into "
	   "this --disable-perl-regexp binary"));
#else
  int e;
  char const *ep;
  char *re = xmalloc (4 * size + 7);
  int flags = PCRE_MULTILINE | (match_icase ? PCRE_CASELESS : 0);
  char const *patlim = pattern + size;
  char *n = re;
  char const *p;
  char const *pnul;

  /* FIXME: Remove these restrictions.  */
  if (memchr(pattern, '\n', size))
    error (EXIT_TROUBLE, 0, _("the -P option only supports a single pattern"));

  *n = '\0';
  if (match_lines)
    strcpy (n, "^(");
  if (match_words)
    strcpy (n, "\\b(");
  n += strlen (n);

  /* The PCRE interface doesn't allow NUL bytes in the pattern, so
     replace each NUL byte in the pattern with the four characters
     "\000", removing a preceding backslash if there are an odd
     number of backslashes before the NUL.

     FIXME: This method does not work with some multibyte character
     encodings, notably Shift-JIS, where a multibyte character can end
     in a backslash byte.  */
  for (p = pattern; (pnul = memchr (p, '\0', patlim - p)); p = pnul + 1)
    {
      memcpy (n, p, pnul - p);
      n += pnul - p;
      for (p = pnul; pattern < p && p[-1] == '\\'; p--)
	continue;
      n -= (pnul - p) & 1;
      strcpy (n, "\\000");
      n += 4;
    }

  memcpy (n, p, patlim - p);
  n += patlim - p;
  *n = '\0';
  if (match_words)
    strcpy (n, ")\\b");
  if (match_lines)
    strcpy (n, ")$");

  cre = pcre_compile (re, flags, &ep, &e, pcre_maketables ());
  if (!cre)
    error (EXIT_TROUBLE, 0, "%s", ep);

  extra = pcre_study (cre, 0, &ep);
  if (ep)
    error (EXIT_TROUBLE, 0, "%s", ep);

  free (re);
#endif
}

EXECUTE_FCT(Pexecute)
{
#if !HAVE_LIBPCRE
  abort ();
  return -1;
#else
  /* This array must have at least two elements; everything after that
     is just for performance improvement in pcre_exec.  */
  int sub[300];

  const char *line_buf, *line_end, *line_next;
  int e = PCRE_ERROR_NOMATCH;
  ptrdiff_t start_ofs = start_ptr ? start_ptr - buf : 0;

  /* PCRE can't limit the matching to single lines, therefore we have to
     match each line in the buffer separately.  */
  for (line_next = buf;
       e == PCRE_ERROR_NOMATCH && line_next < buf + size;
       start_ofs -= line_next - line_buf)
    {
      line_buf = line_next;
      line_end = memchr (line_buf, eolbyte, (buf + size) - line_buf);
      if (line_end == NULL)
        line_next = line_end = buf + size;
      else
        line_next = line_end + 1;

      if (start_ptr && start_ptr >= line_end)
        continue;

      e = pcre_exec (cre, extra, line_buf, line_end - line_buf,
                     start_ofs < 0 ? 0 : start_ofs, 0,
                     sub, sizeof sub / sizeof *sub);
    }

  if (e <= 0)
    {
      switch (e)
	{
	case PCRE_ERROR_NOMATCH:
	  return -1;

	case PCRE_ERROR_NOMEMORY:
	  error (EXIT_TROUBLE, 0, _("memory exhausted"));

	default:
	  abort ();
	}
    }
  else
    {
      /* Narrow down to the line we've found.  */
      char const *beg = line_buf + sub[0];
      char const *end = line_buf + sub[1];
      char const *buflim = buf + size;
      char eol = eolbyte;
      if (!start_ptr)
	{
	  /* FIXME: The case when '\n' is not found indicates a bug:
	     Since grep is line oriented, the match should never contain
	     a newline, so there _must_ be a newline following.
	   */
	  if (!(end = memchr (end, eol, buflim - end)))
	    end = buflim;
	  else
	    end++;
	  while (buf < beg && beg[-1] != eol)
	    --beg;
	}

      *match_size = end - beg;
      return beg - buf;
    }
#endif
}

struct matcher const matchers[] = {
  { "default", Gcompile, EGexecute },
  { "grep",    Gcompile, EGexecute },
  { "egrep",   Ecompile, EGexecute },
  { "awk",     Acompile, EGexecute },
  { "fgrep",   Fcompile, Fexecute },
  { "perl",    Pcompile, Pexecute },
  { "", 0, 0 },
};
#endif /* GREP_PROGRAM */

Testing negative cases!
Testing 0 (with abstract condition) ENVIS_NEG
Iteration 0
Running test command:
/home/ubuntu/spr-fast/tools/grep-test.py /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-deccad69-db9d6340/tempworkdir2/src /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-deccad69-db9d6340/tempworkdir2/tests /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-deccad69-db9d6340/tempworkdir2 0  > __res
Opening:/home/ubuntu/spr-fast/tests/corebench/grep/grep-case-deccad69-db9d6340/tempworkdir2/neg.tmp!
NegativeBRANCH RECORD/home/ubuntu/spr-fast/tests/corebench/grep/grep-case-deccad69-db9d6340/tempworkdir2/neg.tmp!
Not caught by the negative case, give up!
APPENDING TO ISNEG:/home/ubuntu/spr-fast/tests/corebench/grep/grep-case-deccad69-db9d6340/tempworkdir2/neg.tmp!
Running test command:
/home/ubuntu/spr-fast/tools/grep-test.py /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-deccad69-db9d6340/tempworkdir2/src /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-deccad69-db9d6340/tempworkdir2/tests /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-deccad69-db9d6340/tempworkdir2 0  > __res
CondTester, Testing instance id 25:
//src_file:src/search.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
/* search.c - searching subroutines using dfa, kwset and regex for grep.
   Copyright 1992, 1998, 2000, 2007, 2009-2010 Free Software Foundation, Inc.

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 3, or (at your option)
   any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program; if not, write to the Free Software
   Foundation, Inc., 51 Franklin Street - Fifth Floor, Boston, MA
   02110-1301, USA.  */

/* Written August 1992 by Mike Haertel. */

#include <config.h>

#include <sys/types.h>

#include "mbsupport.h"
#ifdef MBS_SUPPORT
/* We can handle multibyte strings. */
# include <wchar.h>
# include <wctype.h>
#endif

#include "system.h"
#include "grep.h"
#ifndef FGREP_PROGRAM
# include <regex.h>
# include "dfa.h"
#endif
#include "kwset.h"
#include "error.h"
#include "xalloc.h"
#ifdef HAVE_LIBPCRE
# include <pcre.h>
#endif

#define NCHAR (UCHAR_MAX + 1)

/* For -w, we also consider _ to be word constituent.  */
#define WCHAR(C) (ISALNUM(C) || (C) == '_')

/* KWset compiled pattern.  For Ecompile and Gcompile, we compile
   a list of strings, at least one of which is known to occur in
   any string matching the regexp. */
static kwset_t kwset;

static void
kwsinit (void)
{
  static char trans[NCHAR];
  int i;

  if (match_icase && MB_CUR_MAX == 1)
    {
      for (i = 0; i < NCHAR; ++i)
        trans[i] = TOLOWER (i);

      kwset = kwsalloc (trans);
    }
  else
    kwset = kwsalloc (NULL);

  if (!kwset)
    xalloc_die ();
}

#ifdef MBS_SUPPORT
/* Convert the *N-byte string, BEG, to lowercase, and write the
   NUL-terminated result into malloc'd storage.  Upon success, set *N
   to the length (in bytes) of the resulting string (not including the
   trailing NUL byte), and return a pointer to the lowercase string.
   Upon memory allocation failure, this function exits.

   Note that while this function returns a pointer to malloc'd storage,
   the caller must not free it, since this function retains a pointer
   to the buffer and reuses it on any subsequent call.  As a consequence,
   this function is not thread-safe.  */
static char *
mbtolower (const char *beg, size_t *n)
{
  static char *out;
  static size_t outalloc;
  size_t outlen, mb_cur_max;
  mbstate_t is, os;
  const char *end;
  char *p;

  if (*n > outalloc)
    {
      out = xrealloc (out, *n);
      outalloc = *n;
    }

  memset (&is, 0, sizeof (is));
  memset (&os, 0, sizeof (os));
  end = beg + *n;

  mb_cur_max = MB_CUR_MAX;
  p = out;
  outlen = 0;
  while (beg < end)
    {
      wchar_t wc;
      size_t mbclen = mbrtowc(&wc, beg, end - beg, &is);
      if (outlen + mb_cur_max >= outalloc)
        {
          out = x2nrealloc (out, &outalloc, 1);
          p = out + outlen;
        }

      if (mbclen == (size_t) -1 || mbclen == (size_t) -2 || mbclen == 0)
        {
          /* An invalid sequence, or a truncated multi-octet character.
             We treat it as a single-octet character.  */
          *p++ = *beg++;
          outlen++;
          memset (&is, 0, sizeof (is));
          memset (&os, 0, sizeof (os));
        }
      else
        {
          beg += mbclen;
          mbclen = wcrtomb (p, towlower ((wint_t) wc), &os);
          p += mbclen;
          outlen += mbclen;
        }
    }

  *n = p - out;
  *p++ = 0;
  return out;
}
#endif


#ifndef FGREP_PROGRAM
/* DFA compiled regexp. */
static struct dfa dfa;

/* The Regex compiled patterns.  */
static struct patterns
{
  /* Regex compiled regexp. */
  struct re_pattern_buffer regexbuf;
  struct re_registers regs; /* This is here on account of a BRAIN-DEAD
			       Q@#%!# library interface in regex.c.  */
} patterns0;

struct patterns *patterns;
size_t pcount;

void
dfaerror (char const *mesg)
{
  error (EXIT_TROUBLE, 0, "%s", mesg);
}

/* Number of compiled fixed strings known to exactly match the regexp.
   If kwsexec returns < kwset_exact_matches, then we don't need to
   call the regexp matcher at all. */
static int kwset_exact_matches;

static char const *
kwsincr_case (const char *must)
{
  const char *buf;
  size_t n;

  n = strlen (must);
#ifdef MBS_SUPPORT
  if (match_icase && MB_CUR_MAX > 1)
    buf = mbtolower (must, &n);
  else
#endif
    buf = must;
  return kwsincr (kwset, buf, n);
}

/* If the DFA turns out to have some set of fixed strings one of
   which must occur in the match, then we build a kwset matcher
   to find those strings, and thus quickly filter out impossible
   matches. */
static void
kwsmusts (void)
{
  struct dfamust const *dm;
  char const *err;

  if (dfa.musts)
    {
      kwsinit ();
      /* First, we compile in the substrings known to be exact
	 matches.  The kwset matcher will return the index
	 of the matching string that it chooses. */
      for (dm = dfa.musts; dm; dm = dm->next)
	{
	  if (!dm->exact)
	    continue;
	  ++kwset_exact_matches;
	  if ((err = kwsincr_case (dm->must)) != NULL)
	    error (EXIT_TROUBLE, 0, "%s", err);
	}
      /* Now, we compile the substrings that will require
	 the use of the regexp matcher.  */
      for (dm = dfa.musts; dm; dm = dm->next)
	{
	  if (dm->exact)
	    continue;
	  if ((err = kwsincr_case (dm->must)) != NULL)
	    error (EXIT_TROUBLE, 0, "%s", err);
	}
      if ((err = kwsprep (kwset)) != NULL)
	error (EXIT_TROUBLE, 0, "%s", err);
    }
}
#endif /* !FGREP_PROGRAM */

#ifdef MBS_SUPPORT

static bool
is_mb_middle(const char **good, const char *buf, const char *end)
{
  const char *p = *good;
  const char *prev = p;
  mbstate_t cur_state;

  /* TODO: can be optimized for UTF-8.  */
  memset(&cur_state, 0, sizeof(mbstate_t));
  while (p < buf)
    {
      size_t mbclen = mbrlen(p, end - p, &cur_state);

      /* Store the beginning of the previous complete multibyte character.  */
      if (mbclen != (size_t) -2)
        prev = p;

      if (mbclen == (size_t) -1 || mbclen == (size_t) -2 || mbclen == 0)
	{
	  /* An invalid sequence, or a truncated multibyte character.
	     We treat it as a single byte character.  */
	  mbclen = 1;
	}
      p += mbclen;
    }

  *good = prev;
  return p > buf;
}
#endif /* MBS_SUPPORT */

#if defined(GREP_PROGRAM) || defined(EGREP_PROGRAM)
#ifdef EGREP_PROGRAM
COMPILE_FCT(Ecompile)
{
  reg_syntax_t syntax_bits = RE_SYNTAX_POSIX_EGREP;
#else
/* No __VA_ARGS__ in C89.  So we have to do it this way.  */
static COMPILE_RET
GEAcompile (char const *pattern, size_t size, reg_syntax_t syntax_bits)
{
#endif /* EGREP_PROGRAM */
  const char *err;
  const char *p, *sep;
  size_t total = size;
  char *motif;

  if (match_icase)
    syntax_bits |= RE_ICASE;
  re_set_syntax (syntax_bits);
  dfasyntax (syntax_bits, match_icase, eolbyte);

  /* For GNU regex compiler we have to pass the patterns separately to detect
     errors like "[\nallo\n]\n".  The patterns here are "[", "allo" and "]"
     GNU regex should have raise a syntax error.  The same for backref, where
     the backref should have been local to each pattern.  */
  p = pattern;
  do
    {
      size_t len;
      sep = memchr (p, '\n', total);
      if (sep)
	{
	  len = sep - p;
	  sep++;
	  total -= (len + 1);
	}
      else
	{
	  len = total;
	  total = 0;
	}

      patterns = realloc (patterns, (pcount + 1) * sizeof (*patterns));
      if (patterns == NULL)
	error (EXIT_TROUBLE, errno, _("memory exhausted"));
      patterns[pcount] = patterns0;

      if ((err = re_compile_pattern (p, len,
				    &(patterns[pcount].regexbuf))) != NULL)
	error (EXIT_TROUBLE, 0, "%s", err);
      pcount++;

      p = sep;
    } while (sep && total != 0);

  /* In the match_words and match_lines cases, we use a different pattern
     for the DFA matcher that will quickly throw out cases that won't work.
     Then if DFA succeeds we do some hairy stuff using the regex matcher
     to decide whether the match should really count. */
  if (match_words || match_lines)
    {
      static char const line_beg_no_bk[] = "^(";
      static char const line_end_no_bk[] = ")$";
      static char const word_beg_no_bk[] = "(^|[^[:alnum:]_])(";
      static char const word_end_no_bk[] = ")([^[:alnum:]_]|$)";
#ifdef EGREP_PROGRAM
# define IF_BK(x, y) (y)
      char *n = xmalloc (sizeof word_beg_no_bk - 1 + size + sizeof word_end_no_bk);
#else
      static char const line_beg_bk[] = "^\\(";
      static char const line_end_bk[] = "\\)$";
      static char const word_beg_bk[] = "\\(^\\|[^[:alnum:]_]\\)\\(";
      static char const word_end_bk[] = "\\)\\([^[:alnum:]_]\\|$\\)";
      int bk = !(syntax_bits & RE_NO_BK_PARENS);
# define IF_BK(x, y) ((bk) ? (x) : (y))
      char *n = xmalloc (sizeof word_beg_bk - 1 + size + sizeof word_end_bk);
#endif /* EGREP_PROGRAM */

      strcpy (n, match_lines ? IF_BK(line_beg_bk, line_beg_no_bk)
			     : IF_BK(word_beg_bk, word_beg_no_bk));
      total = strlen(n);
      memcpy (n + total, pattern, size);
      total += size;
      strcpy (n + total, match_lines ? IF_BK(line_end_bk, line_end_no_bk)
				     : IF_BK(word_end_bk, word_end_no_bk));
      total += strlen (n + total);
      pattern = motif = n;
      size = total;
    }
  else
    motif = NULL;

  dfacomp (pattern, size, &dfa, 1);
  kwsmusts ();

  free(motif);
}

#ifndef EGREP_PROGRAM
COMPILE_FCT(Gcompile)
{
  return GEAcompile (pattern, size,
		     RE_SYNTAX_GREP | RE_HAT_LISTS_NOT_NEWLINE);
}

COMPILE_FCT(Acompile)
{
  return GEAcompile (pattern, size, RE_SYNTAX_AWK);
}

COMPILE_FCT(Ecompile)
{
  return GEAcompile (pattern, size, RE_SYNTAX_POSIX_EGREP);
}
#endif /* !EGREP_PROGRAM */

EXECUTE_FCT(EGexecute)
{
  char const *buflim, *beg, *end, *match, *best_match, *mb_start;
  char eol = eolbyte;
  int backref, start, len, best_len;
  struct kwsmatch kwsm;
  size_t i, ret_val;
#ifdef MBS_SUPPORT
  if (MB_CUR_MAX > 1)
    {
      if (match_icase)
        {
          /* mbtolower adds a NUL byte at the end.  That will provide
	     space for the sentinel byte dfaexec may add.  */
          char *case_buf = mbtolower (buf, &size);
	  if (start_ptr)
	    start_ptr = case_buf + (start_ptr - buf);
          buf = case_buf;
        }
    }
#endif /* MBS_SUPPORT */

  mb_start = buf;
  buflim = buf + size;

  for (beg = end = buf; end < buflim; beg = end)
    {
      if (!start_ptr)
	{
	  /* We don't care about an exact match.  */
	  if (kwset)
	    {
	      /* Find a possible match using the KWset matcher. */
	      size_t offset = kwsexec (kwset, beg, buflim - beg, &kwsm);
	      if (offset == (size_t) -1)
		goto failure;
	      beg += offset;
	      /* Narrow down to the line containing the candidate, and
		 run it through DFA. */
	      if ((end = memchr(beg, eol, buflim - beg)) != NULL)
	        end++;
              else
                end = buflim;
	      match = beg;
	      while (beg > buf && beg[-1] != eol)
		--beg;
	      if (kwsm.index < kwset_exact_matches)
                {
#ifdef MBS_SUPPORT
                  if (mb_start < beg)
                    mb_start = beg;
                  if (MB_CUR_MAX == 1 || !is_mb_middle (&mb_start, match, buflim))
#endif
                    goto success;
                }
	      if (dfaexec (&dfa, beg, (char *) end, 0, NULL, &backref) == NULL)
		continue;
	    }
	  else
	    {
	      /* No good fixed strings; start with DFA. */
	      char const *next_beg = dfaexec (&dfa, beg, (char *) buflim,
					      0, NULL, &backref);
	      if (next_beg == NULL)
		break;
	      /* Narrow down to the line we've found. */
	      beg = next_beg;
	      if ((end = memchr(beg, eol, buflim - beg)) != NULL)
	        end++;
              else
                end = buflim;
	      while (beg > buf && beg[-1] != eol)
		--beg;
	    }
	  /* Successful, no backreferences encountered! */
	  if (!backref)
	    goto success;
	}
      else
	{
	  /* We are looking for the leftmost (then longest) exact match.
	     We will go through the outer loop only once.  */
	  beg = start_ptr;
	  end = buflim;
	}

      /* If we've made it to this point, this means DFA has seen
	 a probable match, and we need to run it through Regex. */
      best_match = end;
      best_len = 0;
      for (i = 0; i < pcount; i++)
	{
	  patterns[i].regexbuf.not_eol = 0;
	  if (0 <= (start = re_search (&(patterns[i].regexbuf),
				       buf, end - buf - 1,
				       beg - buf, end - beg - 1,
				       &(patterns[i].regs))))
	    {
	      len = patterns[i].regs.end[0] - start;
	      match = buf + start;
	      if (match > best_match)
		continue;
	      if (start_ptr && !match_words)
		goto assess_pattern_match;
	      if ((!match_lines && !match_words)
		  || (match_lines && len == end - beg - 1))
		{
		  match = beg;
		  len = end - beg;
		  goto assess_pattern_match;
		}
	      /* If -w, check if the match aligns with word boundaries.
		 We do this iteratively because:
		 (a) the line may contain more than one occurence of the
		 pattern, and
		 (b) Several alternatives in the pattern might be valid at a
		 given point, and we may need to consider a shorter one to
		 find a word boundary.  */
	      if (match_words)
		while (match <= best_match)
		  {
		    if ((match == buf || !WCHAR ((unsigned char) match[-1]))
			&& (len == end - beg - 1
			    || !WCHAR ((unsigned char) match[len])))
		      goto assess_pattern_match;
		    if (len > 0)
		      {
			/* Try a shorter length anchored at the same place. */
			--len;
			patterns[i].regexbuf.not_eol = 1;
			len = re_match (&(patterns[i].regexbuf),
					buf, match + len - beg, match - buf,
					&(patterns[i].regs));
		      }
		    if (len <= 0)
		      {
			/* Try looking further on. */
			if (match == end - 1)
			  break;
			match++;
			patterns[i].regexbuf.not_eol = 0;
			start = re_search (&(patterns[i].regexbuf),
					   buf, end - buf - 1,
					   match - buf, end - match - 1,
					   &(patterns[i].regs));
			if (start < 0)
			  break;
			len = patterns[i].regs.end[0] - start;
			match = buf + start;
		      }
		  } /* while (match <= best_match) */
	      continue;
	    assess_pattern_match:
	      if (!start_ptr)
		{
		  /* Good enough for a non-exact match.
		     No need to look at further patterns, if any.  */
		  beg = match;
		  goto success_in_len;
		}
	      if (match < best_match || (match == best_match && len > best_len))
		{
		  /* Best exact match:  leftmost, then longest.  */
		  best_match = match;
		  best_len = len;
		}
	    } /* if re_search >= 0 */
	} /* for Regex patterns.  */
	if (best_match < end)
	  {
	    /* We have found an exact match.  We were just
	       waiting for the best one (leftmost then longest).  */
	    beg = best_match;
	    len = best_len;
	    goto success_in_len;
	  }
    } /* for (beg = end ..) */

 failure:
  ret_val = -1;
  goto out;

 success:
  len = end - beg;
 success_in_len:
  *match_size = len;
  ret_val = beg - buf;
 out:
  return ret_val;
}
#endif /* defined(GREP_PROGRAM) || defined(EGREP_PROGRAM) */

#if defined(GREP_PROGRAM) || defined(FGREP_PROGRAM)
COMPILE_FCT(Fcompile)
{
  char const *beg, *end, *lim, *err, *pat;
  size_t psize;

  kwsinit ();
  psize = size;
  if (match_icase && MB_CUR_MAX > 1)
    pat = mbtolower (pattern, &psize);
  else
    pat = pattern;

  beg = pat;
  do
    {
      for (lim = beg;; ++lim)
	{
	  end = lim;
	  if (lim >= pat + psize)
	    break;
	 if (*lim == '\n')
	   {
	     lim++;
	     break;
	   }
#if HAVE_DOS_FILE_CONTENTS
	 if (*lim == '\r' && lim + 1 < pat + psize && lim[1] == '\n')
	   {
	     lim += 2;
	     break;
	   }
#endif
	}

      if ((err = kwsincr (kwset, beg, end - beg)) != NULL)
	error (EXIT_TROUBLE, 0, "%s", err);
      beg = lim;
    }
  while (beg < pat + psize);

  if ((err = kwsprep (kwset)) != NULL)
    error (EXIT_TROUBLE, 0, "%s", err);
}

EXECUTE_FCT(Fexecute)
{
  char const *beg, *try, *end, *mb_start;
  size_t len;
  char eol = eolbyte;
  struct kwsmatch kwsmatch;
  size_t ret_val;
#ifdef MBS_SUPPORT
  if (MB_CUR_MAX > 1)
    {
      
//Patch 0:
if ((match_icase) || (__is_neg(16, &(match_icase), sizeof (match_icase), &(buf), sizeof (buf), &(size), sizeof (size), &(start_ptr), sizeof (start_ptr), &(eolbyte), sizeof (eolbyte), &(beg), sizeof (beg), &(mb_start), sizeof (mb_start), &(kwset), sizeof (kwset), &(len), sizeof (len), &(match_words), sizeof (match_words), &(match_lines), sizeof (match_lines), &(eol), sizeof (eol), &(try), sizeof (try), &(ret_val), sizeof (ret_val), &(end), sizeof (end), &(match_size), sizeof (match_size)))) {
    char *case_buf = mbtolower(buf, &size);
    if (start_ptr)
        start_ptr = case_buf + (start_ptr - buf);
    buf = case_buf;
}

//CodeSeg 1:
    }
#endif /* MBS_SUPPORT */

  for (mb_start = beg = start_ptr ? start_ptr : buf; beg <= buf + size; beg++)
    {
      size_t offset = kwsexec (kwset, beg, buf + size - beg, &kwsmatch);
      if (offset == (size_t) -1)
	goto failure;
#ifdef MBS_SUPPORT
      if (MB_CUR_MAX > 1 && is_mb_middle (&mb_start, beg + offset, buf + size))
        {
          beg = mb_start - 1;
          continue; /* It is a part of multibyte character.  */
        }
#endif /* MBS_SUPPORT */
      beg += offset;
      len = kwsmatch.size[0];
      if (start_ptr && !match_words)
	goto success_in_beg_and_len;
      if (match_lines)
	{
	  if (beg > buf && beg[-1] != eol)
	    continue;
	  if (beg + len < buf + size && beg[len] != eol)
	    continue;
	  goto success;
	}
      else if (match_words)
	for (try = beg; len; )
	  {
	    if (try > buf && WCHAR((unsigned char) try[-1]))
	      break;
	    if (try + len < buf + size && WCHAR((unsigned char) try[len]))
	      {
		offset = kwsexec (kwset, beg, --len, &kwsmatch);
		if (offset == (size_t) -1)
		  break;
		try = beg + offset;
		len = kwsmatch.size[0];
	      }
	    else if (!start_ptr)
	      goto success;
	    else
	      goto success_in_beg_and_len;
	  } /* for (try) */
      else
	goto success;
    } /* for (beg in buf) */

 failure:
  ret_val = -1;
  goto out;

 success:
  if ((end = memchr (beg + len, eol, (buf + size) - (beg + len))) != NULL)
    end++;
  else
    end = buf + size;
  while (buf < beg && beg[-1] != eol)
    --beg;
  len = end - beg;
 success_in_beg_and_len:
  *match_size = len;
  ret_val = beg - buf;
 out:
  return ret_val;
}
#endif /* defined(GREP_PROGRAM) || defined(FGREP_PROGRAM) */

#ifdef GREP_PROGRAM
#if HAVE_LIBPCRE
/* Compiled internal form of a Perl regular expression.  */
static pcre *cre;

/* Additional information about the pattern.  */
static pcre_extra *extra;
#endif

COMPILE_FCT(Pcompile)
{
#if !HAVE_LIBPCRE
  error (EXIT_TROUBLE, 0, "%s",
	 _("support for the -P option is not compiled into "
	   "this --disable-perl-regexp binary"));
#else
  int e;
  char const *ep;
  char *re = xmalloc (4 * size + 7);
  int flags = PCRE_MULTILINE | (match_icase ? PCRE_CASELESS : 0);
  char const *patlim = pattern + size;
  char *n = re;
  char const *p;
  char const *pnul;

  /* FIXME: Remove these restrictions.  */
  if (memchr(pattern, '\n', size))
    error (EXIT_TROUBLE, 0, _("the -P option only supports a single pattern"));

  *n = '\0';
  if (match_lines)
    strcpy (n, "^(");
  if (match_words)
    strcpy (n, "\\b(");
  n += strlen (n);

  /* The PCRE interface doesn't allow NUL bytes in the pattern, so
     replace each NUL byte in the pattern with the four characters
     "\000", removing a preceding backslash if there are an odd
     number of backslashes before the NUL.

     FIXME: This method does not work with some multibyte character
     encodings, notably Shift-JIS, where a multibyte character can end
     in a backslash byte.  */
  for (p = pattern; (pnul = memchr (p, '\0', patlim - p)); p = pnul + 1)
    {
      memcpy (n, p, pnul - p);
      n += pnul - p;
      for (p = pnul; pattern < p && p[-1] == '\\'; p--)
	continue;
      n -= (pnul - p) & 1;
      strcpy (n, "\\000");
      n += 4;
    }

  memcpy (n, p, patlim - p);
  n += patlim - p;
  *n = '\0';
  if (match_words)
    strcpy (n, ")\\b");
  if (match_lines)
    strcpy (n, ")$");

  cre = pcre_compile (re, flags, &ep, &e, pcre_maketables ());
  if (!cre)
    error (EXIT_TROUBLE, 0, "%s", ep);

  extra = pcre_study (cre, 0, &ep);
  if (ep)
    error (EXIT_TROUBLE, 0, "%s", ep);

  free (re);
#endif
}

EXECUTE_FCT(Pexecute)
{
#if !HAVE_LIBPCRE
  abort ();
  return -1;
#else
  /* This array must have at least two elements; everything after that
     is just for performance improvement in pcre_exec.  */
  int sub[300];

  const char *line_buf, *line_end, *line_next;
  int e = PCRE_ERROR_NOMATCH;
  ptrdiff_t start_ofs = start_ptr ? start_ptr - buf : 0;

  /* PCRE can't limit the matching to single lines, therefore we have to
     match each line in the buffer separately.  */
  for (line_next = buf;
       e == PCRE_ERROR_NOMATCH && line_next < buf + size;
       start_ofs -= line_next - line_buf)
    {
      line_buf = line_next;
      line_end = memchr (line_buf, eolbyte, (buf + size) - line_buf);
      if (line_end == NULL)
        line_next = line_end = buf + size;
      else
        line_next = line_end + 1;

      if (start_ptr && start_ptr >= line_end)
        continue;

      e = pcre_exec (cre, extra, line_buf, line_end - line_buf,
                     start_ofs < 0 ? 0 : start_ofs, 0,
                     sub, sizeof sub / sizeof *sub);
    }

  if (e <= 0)
    {
      switch (e)
	{
	case PCRE_ERROR_NOMATCH:
	  return -1;

	case PCRE_ERROR_NOMEMORY:
	  error (EXIT_TROUBLE, 0, _("memory exhausted"));

	default:
	  abort ();
	}
    }
  else
    {
      /* Narrow down to the line we've found.  */
      char const *beg = line_buf + sub[0];
      char const *end = line_buf + sub[1];
      char const *buflim = buf + size;
      char eol = eolbyte;
      if (!start_ptr)
	{
	  /* FIXME: The case when '\n' is not found indicates a bug:
	     Since grep is line oriented, the match should never contain
	     a newline, so there _must_ be a newline following.
	   */
	  if (!(end = memchr (end, eol, buflim - end)))
	    end = buflim;
	  else
	    end++;
	  while (buf < beg && beg[-1] != eol)
	    --beg;
	}

      *match_size = end - beg;
      return beg - buf;
    }
#endif
}

struct matcher const matchers[] = {
  { "default", Gcompile, EGexecute },
  { "grep",    Gcompile, EGexecute },
  { "egrep",   Ecompile, EGexecute },
  { "awk",     Acompile, EGexecute },
  { "fgrep",   Fcompile, Fexecute },
  { "perl",    Pcompile, Pexecute },
  { "", 0, 0 },
};
#endif /* GREP_PROGRAM */

Testing negative cases!
Testing 0 (with abstract condition) ENVIS_NEG
Iteration 0
Running test command:
/home/ubuntu/spr-fast/tools/grep-test.py /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-deccad69-db9d6340/tempworkdir2/src /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-deccad69-db9d6340/tempworkdir2/tests /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-deccad69-db9d6340/tempworkdir2 0  > __res
Opening:/home/ubuntu/spr-fast/tests/corebench/grep/grep-case-deccad69-db9d6340/tempworkdir2/neg.tmp!
NegativeBRANCH RECORD/home/ubuntu/spr-fast/tests/corebench/grep/grep-case-deccad69-db9d6340/tempworkdir2/neg.tmp!
APPENDING TO ISNEG:/home/ubuntu/spr-fast/tests/corebench/grep/grep-case-deccad69-db9d6340/tempworkdir2/neg.tmp!
Branch 0: 0
Iteration 1
Running test command:
/home/ubuntu/spr-fast/tools/grep-test.py /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-deccad69-db9d6340/tempworkdir2/src /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-deccad69-db9d6340/tempworkdir2/tests /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-deccad69-db9d6340/tempworkdir2 0  > __res
Opening:/home/ubuntu/spr-fast/tests/corebench/grep/grep-case-deccad69-db9d6340/tempworkdir2/neg.tmp!
NegativeBRANCH RECORD/home/ubuntu/spr-fast/tests/corebench/grep/grep-case-deccad69-db9d6340/tempworkdir2/neg.tmp!
APPENDING TO ISNEG:/home/ubuntu/spr-fast/tests/corebench/grep/grep-case-deccad69-db9d6340/tempworkdir2/neg.tmp!
Branch 0: 1
Passed in iteration!
Passed Negative Cases wiht CondTestder!
Testing positive cases!
Running test command:
/home/ubuntu/spr-fast/tools/grep-test.py /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-deccad69-db9d6340/tempworkdir2/src /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-deccad69-db9d6340/tempworkdir2/tests /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-deccad69-db9d6340/tempworkdir2 9  > __res
Running test command:
/home/ubuntu/spr-fast/tools/grep-test.py /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-deccad69-db9d6340/tempworkdir2/src /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-deccad69-db9d6340/tempworkdir2/tests /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-deccad69-db9d6340/tempworkdir2 12  > __res
Running test command:
/home/ubuntu/spr-fast/tools/grep-test.py /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-deccad69-db9d6340/tempworkdir2/src /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-deccad69-db9d6340/tempworkdir2/tests /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-deccad69-db9d6340/tempworkdir2 3  > __res
Running test command:
/home/ubuntu/spr-fast/tools/grep-test.py /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-deccad69-db9d6340/tempworkdir2/src /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-deccad69-db9d6340/tempworkdir2/tests /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-deccad69-db9d6340/tempworkdir2 4  > __res
Running test command:
/home/ubuntu/spr-fast/tools/grep-test.py /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-deccad69-db9d6340/tempworkdir2/src /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-deccad69-db9d6340/tempworkdir2/tests /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-deccad69-db9d6340/tempworkdir2 5  > __res
Running test command:
/home/ubuntu/spr-fast/tools/grep-test.py /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-deccad69-db9d6340/tempworkdir2/src /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-deccad69-db9d6340/tempworkdir2/tests /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-deccad69-db9d6340/tempworkdir2 6  > __res
Running test command:
/home/ubuntu/spr-fast/tools/grep-test.py /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-deccad69-db9d6340/tempworkdir2/src /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-deccad69-db9d6340/tempworkdir2/tests /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-deccad69-db9d6340/tempworkdir2 11  > __res
Running test command:
/home/ubuntu/spr-fast/tools/grep-test.py /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-deccad69-db9d6340/tempworkdir2/src /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-deccad69-db9d6340/tempworkdir2/tests /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-deccad69-db9d6340/tempworkdir2 13  > __res
Running test command:
/home/ubuntu/spr-fast/tools/grep-test.py /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-deccad69-db9d6340/tempworkdir2/src /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-deccad69-db9d6340/tempworkdir2/tests /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-deccad69-db9d6340/tempworkdir2 14  > __res
Running test command:
/home/ubuntu/spr-fast/tools/grep-test.py /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-deccad69-db9d6340/tempworkdir2/src /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-deccad69-db9d6340/tempworkdir2/tests /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-deccad69-db9d6340/tempworkdir2 15  > __res
Running test command:
/home/ubuntu/spr-fast/tools/grep-test.py /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-deccad69-db9d6340/tempworkdir2/src /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-deccad69-db9d6340/tempworkdir2/tests /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-deccad69-db9d6340/tempworkdir2 17  > __res
Running test command:
/home/ubuntu/spr-fast/tools/grep-test.py /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-deccad69-db9d6340/tempworkdir2/src /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-deccad69-db9d6340/tempworkdir2/tests /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-deccad69-db9d6340/tempworkdir2 18  > __res
Running test command:
/home/ubuntu/spr-fast/tools/grep-test.py /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-deccad69-db9d6340/tempworkdir2/src /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-deccad69-db9d6340/tempworkdir2/tests /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-deccad69-db9d6340/tempworkdir2 20  > __res
Running test command:
/home/ubuntu/spr-fast/tools/grep-test.py /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-deccad69-db9d6340/tempworkdir2/src /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-deccad69-db9d6340/tempworkdir2/tests /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-deccad69-db9d6340/tempworkdir2 22  > __res
Running test command:
/home/ubuntu/spr-fast/tools/grep-test.py /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-deccad69-db9d6340/tempworkdir2/src /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-deccad69-db9d6340/tempworkdir2/tests /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-deccad69-db9d6340/tempworkdir2 23  > __res
Running test command:
/home/ubuntu/spr-fast/tools/grep-test.py /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-deccad69-db9d6340/tempworkdir2/src /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-deccad69-db9d6340/tempworkdir2/tests /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-deccad69-db9d6340/tempworkdir2 25  > __res
Passed Positive Cases
Collect values for post processing!
WRITING TO ISNEG:/home/ubuntu/spr-fast/tests/corebench/grep/grep-case-deccad69-db9d6340/tempworkdir2/neg.tmp!
Running test command:
/home/ubuntu/spr-fast/tools/grep-test.py /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-deccad69-db9d6340/tempworkdir2/src /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-deccad69-db9d6340/tempworkdir2/tests /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-deccad69-db9d6340/tempworkdir2 0  > __res
Running test command:
/home/ubuntu/spr-fast/tools/grep-test.py /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-deccad69-db9d6340/tempworkdir2/src /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-deccad69-db9d6340/tempworkdir2/tests /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-deccad69-db9d6340/tempworkdir2 3  > __res
Running test command:
/home/ubuntu/spr-fast/tools/grep-test.py /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-deccad69-db9d6340/tempworkdir2/src /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-deccad69-db9d6340/tempworkdir2/tests /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-deccad69-db9d6340/tempworkdir2 4  > __res
Running test command:
/home/ubuntu/spr-fast/tools/grep-test.py /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-deccad69-db9d6340/tempworkdir2/src /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-deccad69-db9d6340/tempworkdir2/tests /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-deccad69-db9d6340/tempworkdir2 5  > __res
Running test command:
/home/ubuntu/spr-fast/tools/grep-test.py /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-deccad69-db9d6340/tempworkdir2/src /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-deccad69-db9d6340/tempworkdir2/tests /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-deccad69-db9d6340/tempworkdir2 6  > __res
Running test command:
/home/ubuntu/spr-fast/tools/grep-test.py /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-deccad69-db9d6340/tempworkdir2/src /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-deccad69-db9d6340/tempworkdir2/tests /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-deccad69-db9d6340/tempworkdir2 9  > __res
Running test command:
/home/ubuntu/spr-fast/tools/grep-test.py /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-deccad69-db9d6340/tempworkdir2/src /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-deccad69-db9d6340/tempworkdir2/tests /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-deccad69-db9d6340/tempworkdir2 11  > __res
Running test command:
/home/ubuntu/spr-fast/tools/grep-test.py /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-deccad69-db9d6340/tempworkdir2/src /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-deccad69-db9d6340/tempworkdir2/tests /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-deccad69-db9d6340/tempworkdir2 12  > __res
Running test command:
/home/ubuntu/spr-fast/tools/grep-test.py /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-deccad69-db9d6340/tempworkdir2/src /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-deccad69-db9d6340/tempworkdir2/tests /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-deccad69-db9d6340/tempworkdir2 13  > __res
Running test command:
/home/ubuntu/spr-fast/tools/grep-test.py /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-deccad69-db9d6340/tempworkdir2/src /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-deccad69-db9d6340/tempworkdir2/tests /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-deccad69-db9d6340/tempworkdir2 14  > __res
Running test command:
/home/ubuntu/spr-fast/tools/grep-test.py /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-deccad69-db9d6340/tempworkdir2/src /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-deccad69-db9d6340/tempworkdir2/tests /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-deccad69-db9d6340/tempworkdir2 15  > __res
Running test command:
/home/ubuntu/spr-fast/tools/grep-test.py /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-deccad69-db9d6340/tempworkdir2/src /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-deccad69-db9d6340/tempworkdir2/tests /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-deccad69-db9d6340/tempworkdir2 17  > __res
Running test command:
/home/ubuntu/spr-fast/tools/grep-test.py /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-deccad69-db9d6340/tempworkdir2/src /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-deccad69-db9d6340/tempworkdir2/tests /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-deccad69-db9d6340/tempworkdir2 18  > __res
Running test command:
/home/ubuntu/spr-fast/tools/grep-test.py /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-deccad69-db9d6340/tempworkdir2/src /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-deccad69-db9d6340/tempworkdir2/tests /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-deccad69-db9d6340/tempworkdir2 20  > __res
Running test command:
/home/ubuntu/spr-fast/tools/grep-test.py /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-deccad69-db9d6340/tempworkdir2/src /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-deccad69-db9d6340/tempworkdir2/tests /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-deccad69-db9d6340/tempworkdir2 22  > __res
Running test command:
/home/ubuntu/spr-fast/tools/grep-test.py /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-deccad69-db9d6340/tempworkdir2/src /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-deccad69-db9d6340/tempworkdir2/tests /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-deccad69-db9d6340/tempworkdir2 23  > __res
Running test command:
/home/ubuntu/spr-fast/tools/grep-test.py /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-deccad69-db9d6340/tempworkdir2/src /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-deccad69-db9d6340/tempworkdir2/tests /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-deccad69-db9d6340/tempworkdir2 25  > __res
Passed!
CondTester, Postprocessing instance id 25:
//src_file:src/search.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
/* search.c - searching subroutines using dfa, kwset and regex for grep.
   Copyright 1992, 1998, 2000, 2007, 2009-2010 Free Software Foundation, Inc.

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 3, or (at your option)
   any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program; if not, write to the Free Software
   Foundation, Inc., 51 Franklin Street - Fifth Floor, Boston, MA
   02110-1301, USA.  */

/* Written August 1992 by Mike Haertel. */

#include <config.h>

#include <sys/types.h>

#include "mbsupport.h"
#ifdef MBS_SUPPORT
/* We can handle multibyte strings. */
# include <wchar.h>
# include <wctype.h>
#endif

#include "system.h"
#include "grep.h"
#ifndef FGREP_PROGRAM
# include <regex.h>
# include "dfa.h"
#endif
#include "kwset.h"
#include "error.h"
#include "xalloc.h"
#ifdef HAVE_LIBPCRE
# include <pcre.h>
#endif

#define NCHAR (UCHAR_MAX + 1)

/* For -w, we also consider _ to be word constituent.  */
#define WCHAR(C) (ISALNUM(C) || (C) == '_')

/* KWset compiled pattern.  For Ecompile and Gcompile, we compile
   a list of strings, at least one of which is known to occur in
   any string matching the regexp. */
static kwset_t kwset;

static void
kwsinit (void)
{
  static char trans[NCHAR];
  int i;

  if (match_icase && MB_CUR_MAX == 1)
    {
      for (i = 0; i < NCHAR; ++i)
        trans[i] = TOLOWER (i);

      kwset = kwsalloc (trans);
    }
  else
    kwset = kwsalloc (NULL);

  if (!kwset)
    xalloc_die ();
}

#ifdef MBS_SUPPORT
/* Convert the *N-byte string, BEG, to lowercase, and write the
   NUL-terminated result into malloc'd storage.  Upon success, set *N
   to the length (in bytes) of the resulting string (not including the
   trailing NUL byte), and return a pointer to the lowercase string.
   Upon memory allocation failure, this function exits.

   Note that while this function returns a pointer to malloc'd storage,
   the caller must not free it, since this function retains a pointer
   to the buffer and reuses it on any subsequent call.  As a consequence,
   this function is not thread-safe.  */
static char *
mbtolower (const char *beg, size_t *n)
{
  static char *out;
  static size_t outalloc;
  size_t outlen, mb_cur_max;
  mbstate_t is, os;
  const char *end;
  char *p;

  if (*n > outalloc)
    {
      out = xrealloc (out, *n);
      outalloc = *n;
    }

  memset (&is, 0, sizeof (is));
  memset (&os, 0, sizeof (os));
  end = beg + *n;

  mb_cur_max = MB_CUR_MAX;
  p = out;
  outlen = 0;
  while (beg < end)
    {
      wchar_t wc;
      size_t mbclen = mbrtowc(&wc, beg, end - beg, &is);
      if (outlen + mb_cur_max >= outalloc)
        {
          out = x2nrealloc (out, &outalloc, 1);
          p = out + outlen;
        }

      if (mbclen == (size_t) -1 || mbclen == (size_t) -2 || mbclen == 0)
        {
          /* An invalid sequence, or a truncated multi-octet character.
             We treat it as a single-octet character.  */
          *p++ = *beg++;
          outlen++;
          memset (&is, 0, sizeof (is));
          memset (&os, 0, sizeof (os));
        }
      else
        {
          beg += mbclen;
          mbclen = wcrtomb (p, towlower ((wint_t) wc), &os);
          p += mbclen;
          outlen += mbclen;
        }
    }

  *n = p - out;
  *p++ = 0;
  return out;
}
#endif


#ifndef FGREP_PROGRAM
/* DFA compiled regexp. */
static struct dfa dfa;

/* The Regex compiled patterns.  */
static struct patterns
{
  /* Regex compiled regexp. */
  struct re_pattern_buffer regexbuf;
  struct re_registers regs; /* This is here on account of a BRAIN-DEAD
			       Q@#%!# library interface in regex.c.  */
} patterns0;

struct patterns *patterns;
size_t pcount;

void
dfaerror (char const *mesg)
{
  error (EXIT_TROUBLE, 0, "%s", mesg);
}

/* Number of compiled fixed strings known to exactly match the regexp.
   If kwsexec returns < kwset_exact_matches, then we don't need to
   call the regexp matcher at all. */
static int kwset_exact_matches;

static char const *
kwsincr_case (const char *must)
{
  const char *buf;
  size_t n;

  n = strlen (must);
#ifdef MBS_SUPPORT
  if (match_icase && MB_CUR_MAX > 1)
    buf = mbtolower (must, &n);
  else
#endif
    buf = must;
  return kwsincr (kwset, buf, n);
}

/* If the DFA turns out to have some set of fixed strings one of
   which must occur in the match, then we build a kwset matcher
   to find those strings, and thus quickly filter out impossible
   matches. */
static void
kwsmusts (void)
{
  struct dfamust const *dm;
  char const *err;

  if (dfa.musts)
    {
      kwsinit ();
      /* First, we compile in the substrings known to be exact
	 matches.  The kwset matcher will return the index
	 of the matching string that it chooses. */
      for (dm = dfa.musts; dm; dm = dm->next)
	{
	  if (!dm->exact)
	    continue;
	  ++kwset_exact_matches;
	  if ((err = kwsincr_case (dm->must)) != NULL)
	    error (EXIT_TROUBLE, 0, "%s", err);
	}
      /* Now, we compile the substrings that will require
	 the use of the regexp matcher.  */
      for (dm = dfa.musts; dm; dm = dm->next)
	{
	  if (dm->exact)
	    continue;
	  if ((err = kwsincr_case (dm->must)) != NULL)
	    error (EXIT_TROUBLE, 0, "%s", err);
	}
      if ((err = kwsprep (kwset)) != NULL)
	error (EXIT_TROUBLE, 0, "%s", err);
    }
}
#endif /* !FGREP_PROGRAM */

#ifdef MBS_SUPPORT

static bool
is_mb_middle(const char **good, const char *buf, const char *end)
{
  const char *p = *good;
  const char *prev = p;
  mbstate_t cur_state;

  /* TODO: can be optimized for UTF-8.  */
  memset(&cur_state, 0, sizeof(mbstate_t));
  while (p < buf)
    {
      size_t mbclen = mbrlen(p, end - p, &cur_state);

      /* Store the beginning of the previous complete multibyte character.  */
      if (mbclen != (size_t) -2)
        prev = p;

      if (mbclen == (size_t) -1 || mbclen == (size_t) -2 || mbclen == 0)
	{
	  /* An invalid sequence, or a truncated multibyte character.
	     We treat it as a single byte character.  */
	  mbclen = 1;
	}
      p += mbclen;
    }

  *good = prev;
  return p > buf;
}
#endif /* MBS_SUPPORT */

#if defined(GREP_PROGRAM) || defined(EGREP_PROGRAM)
#ifdef EGREP_PROGRAM
COMPILE_FCT(Ecompile)
{
  reg_syntax_t syntax_bits = RE_SYNTAX_POSIX_EGREP;
#else
/* No __VA_ARGS__ in C89.  So we have to do it this way.  */
static COMPILE_RET
GEAcompile (char const *pattern, size_t size, reg_syntax_t syntax_bits)
{
#endif /* EGREP_PROGRAM */
  const char *err;
  const char *p, *sep;
  size_t total = size;
  char *motif;

  if (match_icase)
    syntax_bits |= RE_ICASE;
  re_set_syntax (syntax_bits);
  dfasyntax (syntax_bits, match_icase, eolbyte);

  /* For GNU regex compiler we have to pass the patterns separately to detect
     errors like "[\nallo\n]\n".  The patterns here are "[", "allo" and "]"
     GNU regex should have raise a syntax error.  The same for backref, where
     the backref should have been local to each pattern.  */
  p = pattern;
  do
    {
      size_t len;
      sep = memchr (p, '\n', total);
      if (sep)
	{
	  len = sep - p;
	  sep++;
	  total -= (len + 1);
	}
      else
	{
	  len = total;
	  total = 0;
	}

      patterns = realloc (patterns, (pcount + 1) * sizeof (*patterns));
      if (patterns == NULL)
	error (EXIT_TROUBLE, errno, _("memory exhausted"));
      patterns[pcount] = patterns0;

      if ((err = re_compile_pattern (p, len,
				    &(patterns[pcount].regexbuf))) != NULL)
	error (EXIT_TROUBLE, 0, "%s", err);
      pcount++;

      p = sep;
    } while (sep && total != 0);

  /* In the match_words and match_lines cases, we use a different pattern
     for the DFA matcher that will quickly throw out cases that won't work.
     Then if DFA succeeds we do some hairy stuff using the regex matcher
     to decide whether the match should really count. */
  if (match_words || match_lines)
    {
      static char const line_beg_no_bk[] = "^(";
      static char const line_end_no_bk[] = ")$";
      static char const word_beg_no_bk[] = "(^|[^[:alnum:]_])(";
      static char const word_end_no_bk[] = ")([^[:alnum:]_]|$)";
#ifdef EGREP_PROGRAM
# define IF_BK(x, y) (y)
      char *n = xmalloc (sizeof word_beg_no_bk - 1 + size + sizeof word_end_no_bk);
#else
      static char const line_beg_bk[] = "^\\(";
      static char const line_end_bk[] = "\\)$";
      static char const word_beg_bk[] = "\\(^\\|[^[:alnum:]_]\\)\\(";
      static char const word_end_bk[] = "\\)\\([^[:alnum:]_]\\|$\\)";
      int bk = !(syntax_bits & RE_NO_BK_PARENS);
# define IF_BK(x, y) ((bk) ? (x) : (y))
      char *n = xmalloc (sizeof word_beg_bk - 1 + size + sizeof word_end_bk);
#endif /* EGREP_PROGRAM */

      strcpy (n, match_lines ? IF_BK(line_beg_bk, line_beg_no_bk)
			     : IF_BK(word_beg_bk, word_beg_no_bk));
      total = strlen(n);
      memcpy (n + total, pattern, size);
      total += size;
      strcpy (n + total, match_lines ? IF_BK(line_end_bk, line_end_no_bk)
				     : IF_BK(word_end_bk, word_end_no_bk));
      total += strlen (n + total);
      pattern = motif = n;
      size = total;
    }
  else
    motif = NULL;

  dfacomp (pattern, size, &dfa, 1);
  kwsmusts ();

  free(motif);
}

#ifndef EGREP_PROGRAM
COMPILE_FCT(Gcompile)
{
  return GEAcompile (pattern, size,
		     RE_SYNTAX_GREP | RE_HAT_LISTS_NOT_NEWLINE);
}

COMPILE_FCT(Acompile)
{
  return GEAcompile (pattern, size, RE_SYNTAX_AWK);
}

COMPILE_FCT(Ecompile)
{
  return GEAcompile (pattern, size, RE_SYNTAX_POSIX_EGREP);
}
#endif /* !EGREP_PROGRAM */

EXECUTE_FCT(EGexecute)
{
  char const *buflim, *beg, *end, *match, *best_match, *mb_start;
  char eol = eolbyte;
  int backref, start, len, best_len;
  struct kwsmatch kwsm;
  size_t i, ret_val;
#ifdef MBS_SUPPORT
  if (MB_CUR_MAX > 1)
    {
      if (match_icase)
        {
          /* mbtolower adds a NUL byte at the end.  That will provide
	     space for the sentinel byte dfaexec may add.  */
          char *case_buf = mbtolower (buf, &size);
	  if (start_ptr)
	    start_ptr = case_buf + (start_ptr - buf);
          buf = case_buf;
        }
    }
#endif /* MBS_SUPPORT */

  mb_start = buf;
  buflim = buf + size;

  for (beg = end = buf; end < buflim; beg = end)
    {
      if (!start_ptr)
	{
	  /* We don't care about an exact match.  */
	  if (kwset)
	    {
	      /* Find a possible match using the KWset matcher. */
	      size_t offset = kwsexec (kwset, beg, buflim - beg, &kwsm);
	      if (offset == (size_t) -1)
		goto failure;
	      beg += offset;
	      /* Narrow down to the line containing the candidate, and
		 run it through DFA. */
	      if ((end = memchr(beg, eol, buflim - beg)) != NULL)
	        end++;
              else
                end = buflim;
	      match = beg;
	      while (beg > buf && beg[-1] != eol)
		--beg;
	      if (kwsm.index < kwset_exact_matches)
                {
#ifdef MBS_SUPPORT
                  if (mb_start < beg)
                    mb_start = beg;
                  if (MB_CUR_MAX == 1 || !is_mb_middle (&mb_start, match, buflim))
#endif
                    goto success;
                }
	      if (dfaexec (&dfa, beg, (char *) end, 0, NULL, &backref) == NULL)
		continue;
	    }
	  else
	    {
	      /* No good fixed strings; start with DFA. */
	      char const *next_beg = dfaexec (&dfa, beg, (char *) buflim,
					      0, NULL, &backref);
	      if (next_beg == NULL)
		break;
	      /* Narrow down to the line we've found. */
	      beg = next_beg;
	      if ((end = memchr(beg, eol, buflim - beg)) != NULL)
	        end++;
              else
                end = buflim;
	      while (beg > buf && beg[-1] != eol)
		--beg;
	    }
	  /* Successful, no backreferences encountered! */
	  if (!backref)
	    goto success;
	}
      else
	{
	  /* We are looking for the leftmost (then longest) exact match.
	     We will go through the outer loop only once.  */
	  beg = start_ptr;
	  end = buflim;
	}

      /* If we've made it to this point, this means DFA has seen
	 a probable match, and we need to run it through Regex. */
      best_match = end;
      best_len = 0;
      for (i = 0; i < pcount; i++)
	{
	  patterns[i].regexbuf.not_eol = 0;
	  if (0 <= (start = re_search (&(patterns[i].regexbuf),
				       buf, end - buf - 1,
				       beg - buf, end - beg - 1,
				       &(patterns[i].regs))))
	    {
	      len = patterns[i].regs.end[0] - start;
	      match = buf + start;
	      if (match > best_match)
		continue;
	      if (start_ptr && !match_words)
		goto assess_pattern_match;
	      if ((!match_lines && !match_words)
		  || (match_lines && len == end - beg - 1))
		{
		  match = beg;
		  len = end - beg;
		  goto assess_pattern_match;
		}
	      /* If -w, check if the match aligns with word boundaries.
		 We do this iteratively because:
		 (a) the line may contain more than one occurence of the
		 pattern, and
		 (b) Several alternatives in the pattern might be valid at a
		 given point, and we may need to consider a shorter one to
		 find a word boundary.  */
	      if (match_words)
		while (match <= best_match)
		  {
		    if ((match == buf || !WCHAR ((unsigned char) match[-1]))
			&& (len == end - beg - 1
			    || !WCHAR ((unsigned char) match[len])))
		      goto assess_pattern_match;
		    if (len > 0)
		      {
			/* Try a shorter length anchored at the same place. */
			--len;
			patterns[i].regexbuf.not_eol = 1;
			len = re_match (&(patterns[i].regexbuf),
					buf, match + len - beg, match - buf,
					&(patterns[i].regs));
		      }
		    if (len <= 0)
		      {
			/* Try looking further on. */
			if (match == end - 1)
			  break;
			match++;
			patterns[i].regexbuf.not_eol = 0;
			start = re_search (&(patterns[i].regexbuf),
					   buf, end - buf - 1,
					   match - buf, end - match - 1,
					   &(patterns[i].regs));
			if (start < 0)
			  break;
			len = patterns[i].regs.end[0] - start;
			match = buf + start;
		      }
		  } /* while (match <= best_match) */
	      continue;
	    assess_pattern_match:
	      if (!start_ptr)
		{
		  /* Good enough for a non-exact match.
		     No need to look at further patterns, if any.  */
		  beg = match;
		  goto success_in_len;
		}
	      if (match < best_match || (match == best_match && len > best_len))
		{
		  /* Best exact match:  leftmost, then longest.  */
		  best_match = match;
		  best_len = len;
		}
	    } /* if re_search >= 0 */
	} /* for Regex patterns.  */
	if (best_match < end)
	  {
	    /* We have found an exact match.  We were just
	       waiting for the best one (leftmost then longest).  */
	    beg = best_match;
	    len = best_len;
	    goto success_in_len;
	  }
    } /* for (beg = end ..) */

 failure:
  ret_val = -1;
  goto out;

 success:
  len = end - beg;
 success_in_len:
  *match_size = len;
  ret_val = beg - buf;
 out:
  return ret_val;
}
#endif /* defined(GREP_PROGRAM) || defined(EGREP_PROGRAM) */

#if defined(GREP_PROGRAM) || defined(FGREP_PROGRAM)
COMPILE_FCT(Fcompile)
{
  char const *beg, *end, *lim, *err, *pat;
  size_t psize;

  kwsinit ();
  psize = size;
  if (match_icase && MB_CUR_MAX > 1)
    pat = mbtolower (pattern, &psize);
  else
    pat = pattern;

  beg = pat;
  do
    {
      for (lim = beg;; ++lim)
	{
	  end = lim;
	  if (lim >= pat + psize)
	    break;
	 if (*lim == '\n')
	   {
	     lim++;
	     break;
	   }
#if HAVE_DOS_FILE_CONTENTS
	 if (*lim == '\r' && lim + 1 < pat + psize && lim[1] == '\n')
	   {
	     lim += 2;
	     break;
	   }
#endif
	}

      if ((err = kwsincr (kwset, beg, end - beg)) != NULL)
	error (EXIT_TROUBLE, 0, "%s", err);
      beg = lim;
    }
  while (beg < pat + psize);

  if ((err = kwsprep (kwset)) != NULL)
    error (EXIT_TROUBLE, 0, "%s", err);
}

EXECUTE_FCT(Fexecute)
{
  char const *beg, *try, *end, *mb_start;
  size_t len;
  char eol = eolbyte;
  struct kwsmatch kwsmatch;
  size_t ret_val;
#ifdef MBS_SUPPORT
  if (MB_CUR_MAX > 1)
    {
      
//Patch 0:
if ((match_icase) || (__is_neg(16, &(match_icase), sizeof (match_icase), &(buf), sizeof (buf), &(size), sizeof (size), &(start_ptr), sizeof (start_ptr), &(eolbyte), sizeof (eolbyte), &(beg), sizeof (beg), &(mb_start), sizeof (mb_start), &(kwset), sizeof (kwset), &(len), sizeof (len), &(match_words), sizeof (match_words), &(match_lines), sizeof (match_lines), &(eol), sizeof (eol), &(try), sizeof (try), &(ret_val), sizeof (ret_val), &(end), sizeof (end), &(match_size), sizeof (match_size)))) {
    char *case_buf = mbtolower(buf, &size);
    if (start_ptr)
        start_ptr = case_buf + (start_ptr - buf);
    buf = case_buf;
}

//CodeSeg 1:
    }
#endif /* MBS_SUPPORT */

  for (mb_start = beg = start_ptr ? start_ptr : buf; beg <= buf + size; beg++)
    {
      size_t offset = kwsexec (kwset, beg, buf + size - beg, &kwsmatch);
      if (offset == (size_t) -1)
	goto failure;
#ifdef MBS_SUPPORT
      if (MB_CUR_MAX > 1 && is_mb_middle (&mb_start, beg + offset, buf + size))
        {
          beg = mb_start - 1;
          continue; /* It is a part of multibyte character.  */
        }
#endif /* MBS_SUPPORT */
      beg += offset;
      len = kwsmatch.size[0];
      if (start_ptr && !match_words)
	goto success_in_beg_and_len;
      if (match_lines)
	{
	  if (beg > buf && beg[-1] != eol)
	    continue;
	  if (beg + len < buf + size && beg[len] != eol)
	    continue;
	  goto success;
	}
      else if (match_words)
	for (try = beg; len; )
	  {
	    if (try > buf && WCHAR((unsigned char) try[-1]))
	      break;
	    if (try + len < buf + size && WCHAR((unsigned char) try[len]))
	      {
		offset = kwsexec (kwset, beg, --len, &kwsmatch);
		if (offset == (size_t) -1)
		  break;
		try = beg + offset;
		len = kwsmatch.size[0];
	      }
	    else if (!start_ptr)
	      goto success;
	    else
	      goto success_in_beg_and_len;
	  } /* for (try) */
      else
	goto success;
    } /* for (beg in buf) */

 failure:
  ret_val = -1;
  goto out;

 success:
  if ((end = memchr (beg + len, eol, (buf + size) - (beg + len))) != NULL)
    end++;
  else
    end = buf + size;
  while (buf < beg && beg[-1] != eol)
    --beg;
  len = end - beg;
 success_in_beg_and_len:
  *match_size = len;
  ret_val = beg - buf;
 out:
  return ret_val;
}
#endif /* defined(GREP_PROGRAM) || defined(FGREP_PROGRAM) */

#ifdef GREP_PROGRAM
#if HAVE_LIBPCRE
/* Compiled internal form of a Perl regular expression.  */
static pcre *cre;

/* Additional information about the pattern.  */
static pcre_extra *extra;
#endif

COMPILE_FCT(Pcompile)
{
#if !HAVE_LIBPCRE
  error (EXIT_TROUBLE, 0, "%s",
	 _("support for the -P option is not compiled into "
	   "this --disable-perl-regexp binary"));
#else
  int e;
  char const *ep;
  char *re = xmalloc (4 * size + 7);
  int flags = PCRE_MULTILINE | (match_icase ? PCRE_CASELESS : 0);
  char const *patlim = pattern + size;
  char *n = re;
  char const *p;
  char const *pnul;

  /* FIXME: Remove these restrictions.  */
  if (memchr(pattern, '\n', size))
    error (EXIT_TROUBLE, 0, _("the -P option only supports a single pattern"));

  *n = '\0';
  if (match_lines)
    strcpy (n, "^(");
  if (match_words)
    strcpy (n, "\\b(");
  n += strlen (n);

  /* The PCRE interface doesn't allow NUL bytes in the pattern, so
     replace each NUL byte in the pattern with the four characters
     "\000", removing a preceding backslash if there are an odd
     number of backslashes before the NUL.

     FIXME: This method does not work with some multibyte character
     encodings, notably Shift-JIS, where a multibyte character can end
     in a backslash byte.  */
  for (p = pattern; (pnul = memchr (p, '\0', patlim - p)); p = pnul + 1)
    {
      memcpy (n, p, pnul - p);
      n += pnul - p;
      for (p = pnul; pattern < p && p[-1] == '\\'; p--)
	continue;
      n -= (pnul - p) & 1;
      strcpy (n, "\\000");
      n += 4;
    }

  memcpy (n, p, patlim - p);
  n += patlim - p;
  *n = '\0';
  if (match_words)
    strcpy (n, ")\\b");
  if (match_lines)
    strcpy (n, ")$");

  cre = pcre_compile (re, flags, &ep, &e, pcre_maketables ());
  if (!cre)
    error (EXIT_TROUBLE, 0, "%s", ep);

  extra = pcre_study (cre, 0, &ep);
  if (ep)
    error (EXIT_TROUBLE, 0, "%s", ep);

  free (re);
#endif
}

EXECUTE_FCT(Pexecute)
{
#if !HAVE_LIBPCRE
  abort ();
  return -1;
#else
  /* This array must have at least two elements; everything after that
     is just for performance improvement in pcre_exec.  */
  int sub[300];

  const char *line_buf, *line_end, *line_next;
  int e = PCRE_ERROR_NOMATCH;
  ptrdiff_t start_ofs = start_ptr ? start_ptr - buf : 0;

  /* PCRE can't limit the matching to single lines, therefore we have to
     match each line in the buffer separately.  */
  for (line_next = buf;
       e == PCRE_ERROR_NOMATCH && line_next < buf + size;
       start_ofs -= line_next - line_buf)
    {
      line_buf = line_next;
      line_end = memchr (line_buf, eolbyte, (buf + size) - line_buf);
      if (line_end == NULL)
        line_next = line_end = buf + size;
      else
        line_next = line_end + 1;

      if (start_ptr && start_ptr >= line_end)
        continue;

      e = pcre_exec (cre, extra, line_buf, line_end - line_buf,
                     start_ofs < 0 ? 0 : start_ofs, 0,
                     sub, sizeof sub / sizeof *sub);
    }

  if (e <= 0)
    {
      switch (e)
	{
	case PCRE_ERROR_NOMATCH:
	  return -1;

	case PCRE_ERROR_NOMEMORY:
	  error (EXIT_TROUBLE, 0, _("memory exhausted"));

	default:
	  abort ();
	}
    }
  else
    {
      /* Narrow down to the line we've found.  */
      char const *beg = line_buf + sub[0];
      char const *end = line_buf + sub[1];
      char const *buflim = buf + size;
      char eol = eolbyte;
      if (!start_ptr)
	{
	  /* FIXME: The case when '\n' is not found indicates a bug:
	     Since grep is line oriented, the match should never contain
	     a newline, so there _must_ be a newline following.
	   */
	  if (!(end = memchr (end, eol, buflim - end)))
	    end = buflim;
	  else
	    end++;
	  while (buf < beg && beg[-1] != eol)
	    --beg;
	}

      *match_size = end - beg;
      return beg - buf;
    }
#endif
}

struct matcher const matchers[] = {
  { "default", Gcompile, EGexecute },
  { "grep",    Gcompile, EGexecute },
  { "egrep",   Ecompile, EGexecute },
  { "awk",     Acompile, EGexecute },
  { "fgrep",   Fcompile, Fexecute },
  { "perl",    Pcompile, Pexecute },
  { "", 0, 0 },
};
#endif /* GREP_PROGRAM */

Trying a synthesis expr 1
Skipping a synthesis:1
Trying a synthesis expr match_icase == 0
Skipping a synthesis expr :match_icase == 0: in origcond:(match_icase) || __is_neg()
Trying a synthesis expr start_ptr == 0
Building:src at:
/home/ubuntu/spr-fast/tests/corebench/grep/grep-case-deccad69-db9d6340/tempworkdir2/srcVerifing Negative cases!
Running test command:
/home/ubuntu/spr-fast/tools/grep-test.py /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-deccad69-db9d6340/tempworkdir2/src /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-deccad69-db9d6340/tempworkdir2/tests /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-deccad69-db9d6340/tempworkdir2 0  > __res
Verifying positive cases
Running test command:
/home/ubuntu/spr-fast/tools/grep-test.py /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-deccad69-db9d6340/tempworkdir2/src /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-deccad69-db9d6340/tempworkdir2/tests /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-deccad69-db9d6340/tempworkdir2 9  > __res
Running test command:
/home/ubuntu/spr-fast/tools/grep-test.py /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-deccad69-db9d6340/tempworkdir2/src /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-deccad69-db9d6340/tempworkdir2/tests /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-deccad69-db9d6340/tempworkdir2 12  > __res
Running test command:
/home/ubuntu/spr-fast/tools/grep-test.py /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-deccad69-db9d6340/tempworkdir2/src /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-deccad69-db9d6340/tempworkdir2/tests /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-deccad69-db9d6340/tempworkdir2 3  > __res
Running test command:
/home/ubuntu/spr-fast/tools/grep-test.py /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-deccad69-db9d6340/tempworkdir2/src /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-deccad69-db9d6340/tempworkdir2/tests /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-deccad69-db9d6340/tempworkdir2 4  > __res
Running test command:
/home/ubuntu/spr-fast/tools/grep-test.py /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-deccad69-db9d6340/tempworkdir2/src /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-deccad69-db9d6340/tempworkdir2/tests /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-deccad69-db9d6340/tempworkdir2 5  > __res
Running test command:
/home/ubuntu/spr-fast/tools/grep-test.py /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-deccad69-db9d6340/tempworkdir2/src /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-deccad69-db9d6340/tempworkdir2/tests /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-deccad69-db9d6340/tempworkdir2 6  > __res
Running test command:
/home/ubuntu/spr-fast/tools/grep-test.py /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-deccad69-db9d6340/tempworkdir2/src /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-deccad69-db9d6340/tempworkdir2/tests /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-deccad69-db9d6340/tempworkdir2 11  > __res
Running test command:
/home/ubuntu/spr-fast/tools/grep-test.py /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-deccad69-db9d6340/tempworkdir2/src /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-deccad69-db9d6340/tempworkdir2/tests /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-deccad69-db9d6340/tempworkdir2 13  > __res
Running test command:
/home/ubuntu/spr-fast/tools/grep-test.py /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-deccad69-db9d6340/tempworkdir2/src /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-deccad69-db9d6340/tempworkdir2/tests /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-deccad69-db9d6340/tempworkdir2 14  > __res
Running test command:
/home/ubuntu/spr-fast/tools/grep-test.py /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-deccad69-db9d6340/tempworkdir2/src /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-deccad69-db9d6340/tempworkdir2/tests /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-deccad69-db9d6340/tempworkdir2 15  > __res
Running test command:
/home/ubuntu/spr-fast/tools/grep-test.py /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-deccad69-db9d6340/tempworkdir2/src /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-deccad69-db9d6340/tempworkdir2/tests /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-deccad69-db9d6340/tempworkdir2 17  > __res
Running test command:
/home/ubuntu/spr-fast/tools/grep-test.py /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-deccad69-db9d6340/tempworkdir2/src /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-deccad69-db9d6340/tempworkdir2/tests /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-deccad69-db9d6340/tempworkdir2 18  > __res
Running test command:
/home/ubuntu/spr-fast/tools/grep-test.py /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-deccad69-db9d6340/tempworkdir2/src /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-deccad69-db9d6340/tempworkdir2/tests /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-deccad69-db9d6340/tempworkdir2 20  > __res
Running test command:
/home/ubuntu/spr-fast/tools/grep-test.py /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-deccad69-db9d6340/tempworkdir2/src /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-deccad69-db9d6340/tempworkdir2/tests /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-deccad69-db9d6340/tempworkdir2 22  > __res
Running test command:
/home/ubuntu/spr-fast/tools/grep-test.py /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-deccad69-db9d6340/tempworkdir2/src /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-deccad69-db9d6340/tempworkdir2/tests /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-deccad69-db9d6340/tempworkdir2 23  > __res
Running test command:
/home/ubuntu/spr-fast/tools/grep-test.py /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-deccad69-db9d6340/tempworkdir2/src /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-deccad69-db9d6340/tempworkdir2/tests /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-deccad69-db9d6340/tempworkdir2 25  > __res
Passed Positive Cases
Passed!
Passed with updated best score 19999975.000000
a batched test job starts!
Building merged code:
src_file: src/search.c
full src: int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
/* search.c - searching subroutines using dfa, kwset and regex for grep.
   Copyright 1992, 1998, 2000, 2007, 2009-2010 Free Software Foundation, Inc.

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 3, or (at your option)
   any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program; if not, write to the Free Software
   Foundation, Inc., 51 Franklin Street - Fifth Floor, Boston, MA
   02110-1301, USA.  */

/* Written August 1992 by Mike Haertel. */

#include <config.h>

#include <sys/types.h>

#include "mbsupport.h"
#ifdef MBS_SUPPORT
/* We can handle multibyte strings. */
# include <wchar.h>
# include <wctype.h>
#endif

#include "system.h"
#include "grep.h"
#ifndef FGREP_PROGRAM
# include <regex.h>
# include "dfa.h"
#endif
#include "kwset.h"
#include "error.h"
#include "xalloc.h"
#ifdef HAVE_LIBPCRE
# include <pcre.h>
#endif

#define NCHAR (UCHAR_MAX + 1)

/* For -w, we also consider _ to be word constituent.  */
#define WCHAR(C) (ISALNUM(C) || (C) == '_')

/* KWset compiled pattern.  For Ecompile and Gcompile, we compile
   a list of strings, at least one of which is known to occur in
   any string matching the regexp. */
static kwset_t kwset;

static void
kwsinit (void)
{
  static char trans[NCHAR];
  int i;

  if (match_icase && MB_CUR_MAX == 1)
    {
      for (i = 0; i < NCHAR; ++i)
        trans[i] = TOLOWER (i);

      kwset = kwsalloc (trans);
    }
  else
    kwset = kwsalloc (NULL);

  if (!kwset)
    xalloc_die ();
}

#ifdef MBS_SUPPORT
/* Convert the *N-byte string, BEG, to lowercase, and write the
   NUL-terminated result into malloc'd storage.  Upon success, set *N
   to the length (in bytes) of the resulting string (not including the
   trailing NUL byte), and return a pointer to the lowercase string.
   Upon memory allocation failure, this function exits.

   Note that while this function returns a pointer to malloc'd storage,
   the caller must not free it, since this function retains a pointer
   to the buffer and reuses it on any subsequent call.  As a consequence,
   this function is not thread-safe.  */
static char *
mbtolower (const char *beg, size_t *n)
{
  static char *out;
  static size_t outalloc;
  size_t outlen, mb_cur_max;
  mbstate_t is, os;
  const char *end;
  char *p;

  if (*n > outalloc)
    {
      out = xrealloc (out, *n);
      outalloc = *n;
    }

  memset (&is, 0, sizeof (is));
  memset (&os, 0, sizeof (os));
  end = beg + *n;

  mb_cur_max = MB_CUR_MAX;
  p = out;
  outlen = 0;
  while (beg < end)
    {
      wchar_t wc;
      size_t mbclen = mbrtowc(&wc, beg, end - beg, &is);
      if (outlen + mb_cur_max >= outalloc)
        {
          out = x2nrealloc (out, &outalloc, 1);
          p = out + outlen;
        }

      if (mbclen == (size_t) -1 || mbclen == (size_t) -2 || mbclen == 0)
        {
          /* An invalid sequence, or a truncated multi-octet character.
             We treat it as a single-octet character.  */
          *p++ = *beg++;
          outlen++;
          memset (&is, 0, sizeof (is));
          memset (&os, 0, sizeof (os));
        }
      else
        {
          beg += mbclen;
          mbclen = wcrtomb (p, towlower ((wint_t) wc), &os);
          p += mbclen;
          outlen += mbclen;
        }
    }

  *n = p - out;
  *p++ = 0;
  return out;
}
#endif


#ifndef FGREP_PROGRAM
/* DFA compiled regexp. */
static struct dfa dfa;

/* The Regex compiled patterns.  */
static struct patterns
{
  /* Regex compiled regexp. */
  struct re_pattern_buffer regexbuf;
  struct re_registers regs; /* This is here on account of a BRAIN-DEAD
			       Q@#%!# library interface in regex.c.  */
} patterns0;

struct patterns *patterns;
size_t pcount;

void
dfaerror (char const *mesg)
{
  error (EXIT_TROUBLE, 0, "%s", mesg);
}

/* Number of compiled fixed strings known to exactly match the regexp.
   If kwsexec returns < kwset_exact_matches, then we don't need to
   call the regexp matcher at all. */
static int kwset_exact_matches;

static char const *
kwsincr_case (const char *must)
{
  const char *buf;
  size_t n;

  n = strlen (must);
#ifdef MBS_SUPPORT
  if (match_icase && MB_CUR_MAX > 1)
    buf = mbtolower (must, &n);
  else
#endif
    buf = must;
  return kwsincr (kwset, buf, n);
}

/* If the DFA turns out to have some set of fixed strings one of
   which must occur in the match, then we build a kwset matcher
   to find those strings, and thus quickly filter out impossible
   matches. */
static void
kwsmusts (void)
{
  struct dfamust const *dm;
  char const *err;

  if (dfa.musts)
    {
      kwsinit ();
      /* First, we compile in the substrings known to be exact
	 matches.  The kwset matcher will return the index
	 of the matching string that it chooses. */
      for (dm = dfa.musts; dm; dm = dm->next)
	{
	  if (!dm->exact)
	    continue;
	  ++kwset_exact_matches;
	  if ((err = kwsincr_case (dm->must)) != NULL)
	    error (EXIT_TROUBLE, 0, "%s", err);
	}
      /* Now, we compile the substrings that will require
	 the use of the regexp matcher.  */
      for (dm = dfa.musts; dm; dm = dm->next)
	{
	  if (dm->exact)
	    continue;
	  if ((err = kwsincr_case (dm->must)) != NULL)
	    error (EXIT_TROUBLE, 0, "%s", err);
	}
      if ((err = kwsprep (kwset)) != NULL)
	error (EXIT_TROUBLE, 0, "%s", err);
    }
}
#endif /* !FGREP_PROGRAM */

#ifdef MBS_SUPPORT

static bool
is_mb_middle(const char **good, const char *buf, const char *end)
{
  const char *p = *good;
  const char *prev = p;
  mbstate_t cur_state;

  /* TODO: can be optimized for UTF-8.  */
  memset(&cur_state, 0, sizeof(mbstate_t));
  while (p < buf)
    {
      size_t mbclen = mbrlen(p, end - p, &cur_state);

      /* Store the beginning of the previous complete multibyte character.  */
      if (mbclen != (size_t) -2)
        prev = p;

      if (mbclen == (size_t) -1 || mbclen == (size_t) -2 || mbclen == 0)
	{
	  /* An invalid sequence, or a truncated multibyte character.
	     We treat it as a single byte character.  */
	  mbclen = 1;
	}
      p += mbclen;
    }

  *good = prev;
  return p > buf;
}
#endif /* MBS_SUPPORT */

#if defined(GREP_PROGRAM) || defined(EGREP_PROGRAM)
#ifdef EGREP_PROGRAM
COMPILE_FCT(Ecompile)
{
  reg_syntax_t syntax_bits = RE_SYNTAX_POSIX_EGREP;
#else
/* No __VA_ARGS__ in C89.  So we have to do it this way.  */
static COMPILE_RET
GEAcompile (char const *pattern, size_t size, reg_syntax_t syntax_bits)
{
#endif /* EGREP_PROGRAM */
  const char *err;
  const char *p, *sep;
  size_t total = size;
  char *motif;

  if (match_icase)
    syntax_bits |= RE_ICASE;
  re_set_syntax (syntax_bits);
  dfasyntax (syntax_bits, match_icase, eolbyte);

  /* For GNU regex compiler we have to pass the patterns separately to detect
     errors like "[\nallo\n]\n".  The patterns here are "[", "allo" and "]"
     GNU regex should have raise a syntax error.  The same for backref, where
     the backref should have been local to each pattern.  */
  p = pattern;
  do
    {
      size_t len;
      sep = memchr (p, '\n', total);
      if (sep)
	{
	  len = sep - p;
	  sep++;
	  total -= (len + 1);
	}
      else
	{
	  len = total;
	  total = 0;
	}

      patterns = realloc (patterns, (pcount + 1) * sizeof (*patterns));
      if (patterns == NULL)
	error (EXIT_TROUBLE, errno, _("memory exhausted"));
      patterns[pcount] = patterns0;

      if ((err = re_compile_pattern (p, len,
				    &(patterns[pcount].regexbuf))) != NULL)
	error (EXIT_TROUBLE, 0, "%s", err);
      pcount++;

      p = sep;
    } while (sep && total != 0);

  /* In the match_words and match_lines cases, we use a different pattern
     for the DFA matcher that will quickly throw out cases that won't work.
     Then if DFA succeeds we do some hairy stuff using the regex matcher
     to decide whether the match should really count. */
  if (match_words || match_lines)
    {
      static char const line_beg_no_bk[] = "^(";
      static char const line_end_no_bk[] = ")$";
      static char const word_beg_no_bk[] = "(^|[^[:alnum:]_])(";
      static char const word_end_no_bk[] = ")([^[:alnum:]_]|$)";
#ifdef EGREP_PROGRAM
# define IF_BK(x, y) (y)
      char *n = xmalloc (sizeof word_beg_no_bk - 1 + size + sizeof word_end_no_bk);
#else
      static char const line_beg_bk[] = "^\\(";
      static char const line_end_bk[] = "\\)$";
      static char const word_beg_bk[] = "\\(^\\|[^[:alnum:]_]\\)\\(";
      static char const word_end_bk[] = "\\)\\([^[:alnum:]_]\\|$\\)";
      int bk = !(syntax_bits & RE_NO_BK_PARENS);
# define IF_BK(x, y) ((bk) ? (x) : (y))
      char *n = xmalloc (sizeof word_beg_bk - 1 + size + sizeof word_end_bk);
#endif /* EGREP_PROGRAM */

      strcpy (n, match_lines ? IF_BK(line_beg_bk, line_beg_no_bk)
			     : IF_BK(word_beg_bk, word_beg_no_bk));
      total = strlen(n);
      memcpy (n + total, pattern, size);
      total += size;
      strcpy (n + total, match_lines ? IF_BK(line_end_bk, line_end_no_bk)
				     : IF_BK(word_end_bk, word_end_no_bk));
      total += strlen (n + total);
      pattern = motif = n;
      size = total;
    }
  else
    motif = NULL;

  dfacomp (pattern, size, &dfa, 1);
  kwsmusts ();

  free(motif);
}

#ifndef EGREP_PROGRAM
COMPILE_FCT(Gcompile)
{
  return GEAcompile (pattern, size,
		     RE_SYNTAX_GREP | RE_HAT_LISTS_NOT_NEWLINE);
}

COMPILE_FCT(Acompile)
{
  return GEAcompile (pattern, size, RE_SYNTAX_AWK);
}

COMPILE_FCT(Ecompile)
{
  return GEAcompile (pattern, size, RE_SYNTAX_POSIX_EGREP);
}
#endif /* !EGREP_PROGRAM */

EXECUTE_FCT(EGexecute)
{
  char const *buflim, *beg, *end, *match, *best_match, *mb_start;
  char eol = eolbyte;
  int backref, start, len, best_len;
  struct kwsmatch kwsm;
  size_t i, ret_val;
#ifdef MBS_SUPPORT
  if (MB_CUR_MAX > 1)
    {
      if (match_icase)
        {
          /* mbtolower adds a NUL byte at the end.  That will provide
	     space for the sentinel byte dfaexec may add.  */
          char *case_buf = mbtolower (buf, &size);
	  if (start_ptr)
	    start_ptr = case_buf + (start_ptr - buf);
          buf = case_buf;
        }
    }
#endif /* MBS_SUPPORT */

  mb_start = buf;
  buflim = buf + size;

  for (beg = end = buf; end < buflim; beg = end)
    {
      if (!start_ptr)
	{
	  /* We don't care about an exact match.  */
	  if (kwset)
	    {
	      /* Find a possible match using the KWset matcher. */
	      size_t offset = kwsexec (kwset, beg, buflim - beg, &kwsm);
	      if (offset == (size_t) -1)
		goto failure;
	      beg += offset;
	      /* Narrow down to the line containing the candidate, and
		 run it through DFA. */
	      if ((end = memchr(beg, eol, buflim - beg)) != NULL)
	        end++;
              else
                end = buflim;
	      match = beg;
	      while (beg > buf && beg[-1] != eol)
		--beg;
	      if (kwsm.index < kwset_exact_matches)
                {
#ifdef MBS_SUPPORT
                  if (mb_start < beg)
                    mb_start = beg;
                  if (MB_CUR_MAX == 1 || !is_mb_middle (&mb_start, match, buflim))
#endif
                    goto success;
                }
	      if (dfaexec (&dfa, beg, (char *) end, 0, NULL, &backref) == NULL)
		continue;
	    }
	  else
	    {
	      /* No good fixed strings; start with DFA. */
	      char const *next_beg = dfaexec (&dfa, beg, (char *) buflim,
					      0, NULL, &backref);
	      if (next_beg == NULL)
		break;
	      /* Narrow down to the line we've found. */
	      beg = next_beg;
	      if ((end = memchr(beg, eol, buflim - beg)) != NULL)
	        end++;
              else
                end = buflim;
	      while (beg > buf && beg[-1] != eol)
		--beg;
	    }
	  /* Successful, no backreferences encountered! */
	  if (!backref)
	    goto success;
	}
      else
	{
	  /* We are looking for the leftmost (then longest) exact match.
	     We will go through the outer loop only once.  */
	  beg = start_ptr;
	  end = buflim;
	}

      /* If we've made it to this point, this means DFA has seen
	 a probable match, and we need to run it through Regex. */
      best_match = end;
      best_len = 0;
      for (i = 0; i < pcount; i++)
	{
	  patterns[i].regexbuf.not_eol = 0;
	  if (0 <= (start = re_search (&(patterns[i].regexbuf),
				       buf, end - buf - 1,
				       beg - buf, end - beg - 1,
				       &(patterns[i].regs))))
	    {
	      len = patterns[i].regs.end[0] - start;
	      match = buf + start;
	      if (match > best_match)
		continue;
	      if (start_ptr && !match_words)
		goto assess_pattern_match;
	      if ((!match_lines && !match_words)
		  || (match_lines && len == end - beg - 1))
		{
		  match = beg;
		  len = end - beg;
		  goto assess_pattern_match;
		}
	      /* If -w, check if the match aligns with word boundaries.
		 We do this iteratively because:
		 (a) the line may contain more than one occurence of the
		 pattern, and
		 (b) Several alternatives in the pattern might be valid at a
		 given point, and we may need to consider a shorter one to
		 find a word boundary.  */
	      if (match_words)
		while (match <= best_match)
		  {
		    if ((match == buf || !WCHAR ((unsigned char) match[-1]))
			&& (len == end - beg - 1
			    || !WCHAR ((unsigned char) match[len])))
		      goto assess_pattern_match;
		    if (len > 0)
		      {
			/* Try a shorter length anchored at the same place. */
			--len;
			patterns[i].regexbuf.not_eol = 1;
			len = re_match (&(patterns[i].regexbuf),
					buf, match + len - beg, match - buf,
					&(patterns[i].regs));
		      }
		    if (len <= 0)
		      {
			/* Try looking further on. */
			if (match == end - 1)
			  break;
			match++;
			patterns[i].regexbuf.not_eol = 0;
			start = re_search (&(patterns[i].regexbuf),
					   buf, end - buf - 1,
					   match - buf, end - match - 1,
					   &(patterns[i].regs));
			if (start < 0)
			  break;
			len = patterns[i].regs.end[0] - start;
			match = buf + start;
		      }
		  } /* while (match <= best_match) */
	      continue;
	    assess_pattern_match:
	      if (!start_ptr)
		{
		  /* Good enough for a non-exact match.
		     No need to look at further patterns, if any.  */
		  beg = match;
		  goto success_in_len;
		}
	      if (match < best_match || (match == best_match && len > best_len))
		{
		  /* Best exact match:  leftmost, then longest.  */
		  best_match = match;
		  best_len = len;
		}
	    } /* if re_search >= 0 */
	} /* for Regex patterns.  */
	if (best_match < end)
	  {
	    /* We have found an exact match.  We were just
	       waiting for the best one (leftmost then longest).  */
	    beg = best_match;
	    len = best_len;
	    goto success_in_len;
	  }
    } /* for (beg = end ..) */

 failure:
  ret_val = -1;
  goto out;

 success:
  len = end - beg;
 success_in_len:
  *match_size = len;
  ret_val = beg - buf;
 out:
  return ret_val;
}
#endif /* defined(GREP_PROGRAM) || defined(EGREP_PROGRAM) */

#if defined(GREP_PROGRAM) || defined(FGREP_PROGRAM)
COMPILE_FCT(Fcompile)
{
  char const *beg, *end, *lim, *err, *pat;
  size_t psize;

  kwsinit ();
  psize = size;
  if (match_icase && MB_CUR_MAX > 1)
    pat = mbtolower (pattern, &psize);
  else
    pat = pattern;

  beg = pat;
  do
    {
      for (lim = beg;; ++lim)
	{
	  end = lim;
	  if (lim >= pat + psize)
	    break;
	 if (*lim == '\n')
	   {
	     lim++;
	     break;
	   }
#if HAVE_DOS_FILE_CONTENTS
	 if (*lim == '\r' && lim + 1 < pat + psize && lim[1] == '\n')
	   {
	     lim += 2;
	     break;
	   }
#endif
	}

      if ((err = kwsincr (kwset, beg, end - beg)) != NULL)
	error (EXIT_TROUBLE, 0, "%s", err);
      beg = lim;
    }
  while (beg < pat + psize);

  if ((err = kwsprep (kwset)) != NULL)
    error (EXIT_TROUBLE, 0, "%s", err);
}

EXECUTE_FCT(Fexecute)
{
  char const *beg, *try, *end, *mb_start;
  size_t len;
  char eol = eolbyte;
  struct kwsmatch kwsmatch;
  size_t ret_val;
#ifdef MBS_SUPPORT
  if (MB_CUR_MAX > 1)
    {
      if (match_icase)
        {
          char *case_buf = mbtolower (buf, &size);
	  if (start_ptr)
	    start_ptr = case_buf + (start_ptr - buf);
          buf = case_buf;
        }
    }
#endif /* MBS_SUPPORT */

  for (mb_start = beg = start_ptr ? start_ptr : buf; beg <= buf + size; beg++)
    {
      size_t offset = kwsexec (kwset, beg, buf + size - beg, &kwsmatch);
      //prophet generated patch
      if (__get_mutant()==0) {
      if ((offset == (size_t)-1) && !(__is_neg(18, &(offset), sizeof (offset), &(buf), sizeof (buf), &(size), sizeof (size), &(beg), sizeof (beg), &(kwset), sizeof (kwset), &(start_ptr), sizeof (start_ptr), &(mb_start), sizeof (mb_start), &(len), sizeof (len), &(match_words), sizeof (match_words), &(match_icase), sizeof (match_icase), &(match_lines), sizeof (match_lines), &(eol), sizeof (eol), &(eolbyte), sizeof (eolbyte), &(try), sizeof (try), &(ret_val), sizeof (ret_val), &(end), sizeof (end), &(match_size), sizeof (match_size), &(kwsmatch.index), sizeof (kwsmatch.index))))
          goto failure;
      }
      else if (__get_mutant()==1) {
      if ((offset == (size_t)-1) || (__is_neg(18, &(offset), sizeof (offset), &(buf), sizeof (buf), &(size), sizeof (size), &(beg), sizeof (beg), &(kwset), sizeof (kwset), &(start_ptr), sizeof (start_ptr), &(mb_start), sizeof (mb_start), &(len), sizeof (len), &(match_words), sizeof (match_words), &(match_icase), sizeof (match_icase), &(match_lines), sizeof (match_lines), &(eol), sizeof (eol), &(eolbyte), sizeof (eolbyte), &(try), sizeof (try), &(ret_val), sizeof (ret_val), &(end), sizeof (end), &(match_size), sizeof (match_size), &(kwsmatch.index), sizeof (kwsmatch.index))))
          goto failure;
      }
#ifdef MBS_SUPPORT
      if (MB_CUR_MAX > 1 && is_mb_middle (&mb_start, beg + offset, buf + size))
        {
          beg = mb_start - 1;
          continue; /* It is a part of multibyte character.  */
        }
#endif /* MBS_SUPPORT */
      beg += offset;
      len = kwsmatch.size[0];
      if (start_ptr && !match_words)
	goto success_in_beg_and_len;
      if (match_lines)
	{
	  if (beg > buf && beg[-1] != eol)
	    continue;
	  if (beg + len < buf + size && beg[len] != eol)
	    continue;
	  goto success;
	}
      else if (match_words)
	for (try = beg; len; )
	  {
	    if (try > buf && WCHAR((unsigned char) try[-1]))
	      break;
	    if (try + len < buf + size && WCHAR((unsigned char) try[len]))
	      {
		offset = kwsexec (kwset, beg, --len, &kwsmatch);
		if (offset == (size_t) -1)
		  break;
		try = beg + offset;
		len = kwsmatch.size[0];
	      }
	    else if (!start_ptr)
	      goto success;
	    else
	      goto success_in_beg_and_len;
	  } /* for (try) */
      else
	goto success;
    } /* for (beg in buf) */

 failure:
  ret_val = -1;
  goto out;

 success:
  if ((end = memchr (beg + len, eol, (buf + size) - (beg + len))) != NULL)
    end++;
  else
    end = buf + size;
  while (buf < beg && beg[-1] != eol)
    --beg;
  len = end - beg;
 success_in_beg_and_len:
  *match_size = len;
  ret_val = beg - buf;
 out:
  return ret_val;
}
#endif /* defined(GREP_PROGRAM) || defined(FGREP_PROGRAM) */

#ifdef GREP_PROGRAM
#if HAVE_LIBPCRE
/* Compiled internal form of a Perl regular expression.  */
static pcre *cre;

/* Additional information about the pattern.  */
static pcre_extra *extra;
#endif

COMPILE_FCT(Pcompile)
{
#if !HAVE_LIBPCRE
  error (EXIT_TROUBLE, 0, "%s",
	 _("support for the -P option is not compiled into "
	   "this --disable-perl-regexp binary"));
#else
  int e;
  char const *ep;
  char *re = xmalloc (4 * size + 7);
  int flags = PCRE_MULTILINE | (match_icase ? PCRE_CASELESS : 0);
  char const *patlim = pattern + size;
  char *n = re;
  char const *p;
  char const *pnul;

  /* FIXME: Remove these restrictions.  */
  if (memchr(pattern, '\n', size))
    error (EXIT_TROUBLE, 0, _("the -P option only supports a single pattern"));

  *n = '\0';
  if (match_lines)
    strcpy (n, "^(");
  if (match_words)
    strcpy (n, "\\b(");
  n += strlen (n);

  /* The PCRE interface doesn't allow NUL bytes in the pattern, so
     replace each NUL byte in the pattern with the four characters
     "\000", removing a preceding backslash if there are an odd
     number of backslashes before the NUL.

     FIXME: This method does not work with some multibyte character
     encodings, notably Shift-JIS, where a multibyte character can end
     in a backslash byte.  */
  for (p = pattern; (pnul = memchr (p, '\0', patlim - p)); p = pnul + 1)
    {
      memcpy (n, p, pnul - p);
      n += pnul - p;
      for (p = pnul; pattern < p && p[-1] == '\\'; p--)
	continue;
      n -= (pnul - p) & 1;
      strcpy (n, "\\000");
      n += 4;
    }

  memcpy (n, p, patlim - p);
  n += patlim - p;
  *n = '\0';
  if (match_words)
    strcpy (n, ")\\b");
  if (match_lines)
    strcpy (n, ")$");

  cre = pcre_compile (re, flags, &ep, &e, pcre_maketables ());
  if (!cre)
    error (EXIT_TROUBLE, 0, "%s", ep);

  extra = pcre_study (cre, 0, &ep);
  if (ep)
    error (EXIT_TROUBLE, 0, "%s", ep);

  free (re);
#endif
}

EXECUTE_FCT(Pexecute)
{
#if !HAVE_LIBPCRE
  abort ();
  return -1;
#else
  /* This array must have at least two elements; everything after that
     is just for performance improvement in pcre_exec.  */
  int sub[300];

  const char *line_buf, *line_end, *line_next;
  int e = PCRE_ERROR_NOMATCH;
  ptrdiff_t start_ofs = start_ptr ? start_ptr - buf : 0;

  /* PCRE can't limit the matching to single lines, therefore we have to
     match each line in the buffer separately.  */
  for (line_next = buf;
       e == PCRE_ERROR_NOMATCH && line_next < buf + size;
       start_ofs -= line_next - line_buf)
    {
      line_buf = line_next;
      line_end = memchr (line_buf, eolbyte, (buf + size) - line_buf);
      if (line_end == NULL)
        line_next = line_end = buf + size;
      else
        line_next = line_end + 1;

      if (start_ptr && start_ptr >= line_end)
        continue;

      e = pcre_exec (cre, extra, line_buf, line_end - line_buf,
                     start_ofs < 0 ? 0 : start_ofs, 0,
                     sub, sizeof sub / sizeof *sub);
    }

  if (e <= 0)
    {
      switch (e)
	{
	case PCRE_ERROR_NOMATCH:
	  return -1;

	case PCRE_ERROR_NOMEMORY:
	  error (EXIT_TROUBLE, 0, _("memory exhausted"));

	default:
	  abort ();
	}
    }
  else
    {
      /* Narrow down to the line we've found.  */
      char const *beg = line_buf + sub[0];
      char const *end = line_buf + sub[1];
      char const *buflim = buf + size;
      char eol = eolbyte;
      if (!start_ptr)
	{
	  /* FIXME: The case when '\n' is not found indicates a bug:
	     Since grep is line oriented, the match should never contain
	     a newline, so there _must_ be a newline following.
	   */
	  if (!(end = memchr (end, eol, buflim - end)))
	    end = buflim;
	  else
	    end++;
	  while (buf < beg && beg[-1] != eol)
	    --beg;
	}

      *match_size = end - beg;
      return beg - buf;
    }
#endif
}

struct matcher const matchers[] = {
  { "default", Gcompile, EGexecute },
  { "grep",    Gcompile, EGexecute },
  { "egrep",   Ecompile, EGexecute },
  { "awk",     Acompile, EGexecute },
  { "fgrep",   Fcompile, Fexecute },
  { "perl",    Pcompile, Pexecute },
  { "", 0, 0 },
};
#endif /* GREP_PROGRAM */

Building:src at:
/home/ubuntu/spr-fast/tests/corebench/grep/grep-case-deccad69-db9d6340/tempworkdir2/srcMerged code building succ, going to invoke tester!
CondTester, Testing instance id 21:
//src_file:src/search.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
/* search.c - searching subroutines using dfa, kwset and regex for grep.
   Copyright 1992, 1998, 2000, 2007, 2009-2010 Free Software Foundation, Inc.

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 3, or (at your option)
   any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program; if not, write to the Free Software
   Foundation, Inc., 51 Franklin Street - Fifth Floor, Boston, MA
   02110-1301, USA.  */

/* Written August 1992 by Mike Haertel. */

#include <config.h>

#include <sys/types.h>

#include "mbsupport.h"
#ifdef MBS_SUPPORT
/* We can handle multibyte strings. */
# include <wchar.h>
# include <wctype.h>
#endif

#include "system.h"
#include "grep.h"
#ifndef FGREP_PROGRAM
# include <regex.h>
# include "dfa.h"
#endif
#include "kwset.h"
#include "error.h"
#include "xalloc.h"
#ifdef HAVE_LIBPCRE
# include <pcre.h>
#endif

#define NCHAR (UCHAR_MAX + 1)

/* For -w, we also consider _ to be word constituent.  */
#define WCHAR(C) (ISALNUM(C) || (C) == '_')

/* KWset compiled pattern.  For Ecompile and Gcompile, we compile
   a list of strings, at least one of which is known to occur in
   any string matching the regexp. */
static kwset_t kwset;

static void
kwsinit (void)
{
  static char trans[NCHAR];
  int i;

  if (match_icase && MB_CUR_MAX == 1)
    {
      for (i = 0; i < NCHAR; ++i)
        trans[i] = TOLOWER (i);

      kwset = kwsalloc (trans);
    }
  else
    kwset = kwsalloc (NULL);

  if (!kwset)
    xalloc_die ();
}

#ifdef MBS_SUPPORT
/* Convert the *N-byte string, BEG, to lowercase, and write the
   NUL-terminated result into malloc'd storage.  Upon success, set *N
   to the length (in bytes) of the resulting string (not including the
   trailing NUL byte), and return a pointer to the lowercase string.
   Upon memory allocation failure, this function exits.

   Note that while this function returns a pointer to malloc'd storage,
   the caller must not free it, since this function retains a pointer
   to the buffer and reuses it on any subsequent call.  As a consequence,
   this function is not thread-safe.  */
static char *
mbtolower (const char *beg, size_t *n)
{
  static char *out;
  static size_t outalloc;
  size_t outlen, mb_cur_max;
  mbstate_t is, os;
  const char *end;
  char *p;

  if (*n > outalloc)
    {
      out = xrealloc (out, *n);
      outalloc = *n;
    }

  memset (&is, 0, sizeof (is));
  memset (&os, 0, sizeof (os));
  end = beg + *n;

  mb_cur_max = MB_CUR_MAX;
  p = out;
  outlen = 0;
  while (beg < end)
    {
      wchar_t wc;
      size_t mbclen = mbrtowc(&wc, beg, end - beg, &is);
      if (outlen + mb_cur_max >= outalloc)
        {
          out = x2nrealloc (out, &outalloc, 1);
          p = out + outlen;
        }

      if (mbclen == (size_t) -1 || mbclen == (size_t) -2 || mbclen == 0)
        {
          /* An invalid sequence, or a truncated multi-octet character.
             We treat it as a single-octet character.  */
          *p++ = *beg++;
          outlen++;
          memset (&is, 0, sizeof (is));
          memset (&os, 0, sizeof (os));
        }
      else
        {
          beg += mbclen;
          mbclen = wcrtomb (p, towlower ((wint_t) wc), &os);
          p += mbclen;
          outlen += mbclen;
        }
    }

  *n = p - out;
  *p++ = 0;
  return out;
}
#endif


#ifndef FGREP_PROGRAM
/* DFA compiled regexp. */
static struct dfa dfa;

/* The Regex compiled patterns.  */
static struct patterns
{
  /* Regex compiled regexp. */
  struct re_pattern_buffer regexbuf;
  struct re_registers regs; /* This is here on account of a BRAIN-DEAD
			       Q@#%!# library interface in regex.c.  */
} patterns0;

struct patterns *patterns;
size_t pcount;

void
dfaerror (char const *mesg)
{
  error (EXIT_TROUBLE, 0, "%s", mesg);
}

/* Number of compiled fixed strings known to exactly match the regexp.
   If kwsexec returns < kwset_exact_matches, then we don't need to
   call the regexp matcher at all. */
static int kwset_exact_matches;

static char const *
kwsincr_case (const char *must)
{
  const char *buf;
  size_t n;

  n = strlen (must);
#ifdef MBS_SUPPORT
  if (match_icase && MB_CUR_MAX > 1)
    buf = mbtolower (must, &n);
  else
#endif
    buf = must;
  return kwsincr (kwset, buf, n);
}

/* If the DFA turns out to have some set of fixed strings one of
   which must occur in the match, then we build a kwset matcher
   to find those strings, and thus quickly filter out impossible
   matches. */
static void
kwsmusts (void)
{
  struct dfamust const *dm;
  char const *err;

  if (dfa.musts)
    {
      kwsinit ();
      /* First, we compile in the substrings known to be exact
	 matches.  The kwset matcher will return the index
	 of the matching string that it chooses. */
      for (dm = dfa.musts; dm; dm = dm->next)
	{
	  if (!dm->exact)
	    continue;
	  ++kwset_exact_matches;
	  if ((err = kwsincr_case (dm->must)) != NULL)
	    error (EXIT_TROUBLE, 0, "%s", err);
	}
      /* Now, we compile the substrings that will require
	 the use of the regexp matcher.  */
      for (dm = dfa.musts; dm; dm = dm->next)
	{
	  if (dm->exact)
	    continue;
	  if ((err = kwsincr_case (dm->must)) != NULL)
	    error (EXIT_TROUBLE, 0, "%s", err);
	}
      if ((err = kwsprep (kwset)) != NULL)
	error (EXIT_TROUBLE, 0, "%s", err);
    }
}
#endif /* !FGREP_PROGRAM */

#ifdef MBS_SUPPORT

static bool
is_mb_middle(const char **good, const char *buf, const char *end)
{
  const char *p = *good;
  const char *prev = p;
  mbstate_t cur_state;

  /* TODO: can be optimized for UTF-8.  */
  memset(&cur_state, 0, sizeof(mbstate_t));
  while (p < buf)
    {
      size_t mbclen = mbrlen(p, end - p, &cur_state);

      /* Store the beginning of the previous complete multibyte character.  */
      if (mbclen != (size_t) -2)
        prev = p;

      if (mbclen == (size_t) -1 || mbclen == (size_t) -2 || mbclen == 0)
	{
	  /* An invalid sequence, or a truncated multibyte character.
	     We treat it as a single byte character.  */
	  mbclen = 1;
	}
      p += mbclen;
    }

  *good = prev;
  return p > buf;
}
#endif /* MBS_SUPPORT */

#if defined(GREP_PROGRAM) || defined(EGREP_PROGRAM)
#ifdef EGREP_PROGRAM
COMPILE_FCT(Ecompile)
{
  reg_syntax_t syntax_bits = RE_SYNTAX_POSIX_EGREP;
#else
/* No __VA_ARGS__ in C89.  So we have to do it this way.  */
static COMPILE_RET
GEAcompile (char const *pattern, size_t size, reg_syntax_t syntax_bits)
{
#endif /* EGREP_PROGRAM */
  const char *err;
  const char *p, *sep;
  size_t total = size;
  char *motif;

  if (match_icase)
    syntax_bits |= RE_ICASE;
  re_set_syntax (syntax_bits);
  dfasyntax (syntax_bits, match_icase, eolbyte);

  /* For GNU regex compiler we have to pass the patterns separately to detect
     errors like "[\nallo\n]\n".  The patterns here are "[", "allo" and "]"
     GNU regex should have raise a syntax error.  The same for backref, where
     the backref should have been local to each pattern.  */
  p = pattern;
  do
    {
      size_t len;
      sep = memchr (p, '\n', total);
      if (sep)
	{
	  len = sep - p;
	  sep++;
	  total -= (len + 1);
	}
      else
	{
	  len = total;
	  total = 0;
	}

      patterns = realloc (patterns, (pcount + 1) * sizeof (*patterns));
      if (patterns == NULL)
	error (EXIT_TROUBLE, errno, _("memory exhausted"));
      patterns[pcount] = patterns0;

      if ((err = re_compile_pattern (p, len,
				    &(patterns[pcount].regexbuf))) != NULL)
	error (EXIT_TROUBLE, 0, "%s", err);
      pcount++;

      p = sep;
    } while (sep && total != 0);

  /* In the match_words and match_lines cases, we use a different pattern
     for the DFA matcher that will quickly throw out cases that won't work.
     Then if DFA succeeds we do some hairy stuff using the regex matcher
     to decide whether the match should really count. */
  if (match_words || match_lines)
    {
      static char const line_beg_no_bk[] = "^(";
      static char const line_end_no_bk[] = ")$";
      static char const word_beg_no_bk[] = "(^|[^[:alnum:]_])(";
      static char const word_end_no_bk[] = ")([^[:alnum:]_]|$)";
#ifdef EGREP_PROGRAM
# define IF_BK(x, y) (y)
      char *n = xmalloc (sizeof word_beg_no_bk - 1 + size + sizeof word_end_no_bk);
#else
      static char const line_beg_bk[] = "^\\(";
      static char const line_end_bk[] = "\\)$";
      static char const word_beg_bk[] = "\\(^\\|[^[:alnum:]_]\\)\\(";
      static char const word_end_bk[] = "\\)\\([^[:alnum:]_]\\|$\\)";
      int bk = !(syntax_bits & RE_NO_BK_PARENS);
# define IF_BK(x, y) ((bk) ? (x) : (y))
      char *n = xmalloc (sizeof word_beg_bk - 1 + size + sizeof word_end_bk);
#endif /* EGREP_PROGRAM */

      strcpy (n, match_lines ? IF_BK(line_beg_bk, line_beg_no_bk)
			     : IF_BK(word_beg_bk, word_beg_no_bk));
      total = strlen(n);
      memcpy (n + total, pattern, size);
      total += size;
      strcpy (n + total, match_lines ? IF_BK(line_end_bk, line_end_no_bk)
				     : IF_BK(word_end_bk, word_end_no_bk));
      total += strlen (n + total);
      pattern = motif = n;
      size = total;
    }
  else
    motif = NULL;

  dfacomp (pattern, size, &dfa, 1);
  kwsmusts ();

  free(motif);
}

#ifndef EGREP_PROGRAM
COMPILE_FCT(Gcompile)
{
  return GEAcompile (pattern, size,
		     RE_SYNTAX_GREP | RE_HAT_LISTS_NOT_NEWLINE);
}

COMPILE_FCT(Acompile)
{
  return GEAcompile (pattern, size, RE_SYNTAX_AWK);
}

COMPILE_FCT(Ecompile)
{
  return GEAcompile (pattern, size, RE_SYNTAX_POSIX_EGREP);
}
#endif /* !EGREP_PROGRAM */

EXECUTE_FCT(EGexecute)
{
  char const *buflim, *beg, *end, *match, *best_match, *mb_start;
  char eol = eolbyte;
  int backref, start, len, best_len;
  struct kwsmatch kwsm;
  size_t i, ret_val;
#ifdef MBS_SUPPORT
  if (MB_CUR_MAX > 1)
    {
      if (match_icase)
        {
          /* mbtolower adds a NUL byte at the end.  That will provide
	     space for the sentinel byte dfaexec may add.  */
          char *case_buf = mbtolower (buf, &size);
	  if (start_ptr)
	    start_ptr = case_buf + (start_ptr - buf);
          buf = case_buf;
        }
    }
#endif /* MBS_SUPPORT */

  mb_start = buf;
  buflim = buf + size;

  for (beg = end = buf; end < buflim; beg = end)
    {
      if (!start_ptr)
	{
	  /* We don't care about an exact match.  */
	  if (kwset)
	    {
	      /* Find a possible match using the KWset matcher. */
	      size_t offset = kwsexec (kwset, beg, buflim - beg, &kwsm);
	      if (offset == (size_t) -1)
		goto failure;
	      beg += offset;
	      /* Narrow down to the line containing the candidate, and
		 run it through DFA. */
	      if ((end = memchr(beg, eol, buflim - beg)) != NULL)
	        end++;
              else
                end = buflim;
	      match = beg;
	      while (beg > buf && beg[-1] != eol)
		--beg;
	      if (kwsm.index < kwset_exact_matches)
                {
#ifdef MBS_SUPPORT
                  if (mb_start < beg)
                    mb_start = beg;
                  if (MB_CUR_MAX == 1 || !is_mb_middle (&mb_start, match, buflim))
#endif
                    goto success;
                }
	      if (dfaexec (&dfa, beg, (char *) end, 0, NULL, &backref) == NULL)
		continue;
	    }
	  else
	    {
	      /* No good fixed strings; start with DFA. */
	      char const *next_beg = dfaexec (&dfa, beg, (char *) buflim,
					      0, NULL, &backref);
	      if (next_beg == NULL)
		break;
	      /* Narrow down to the line we've found. */
	      beg = next_beg;
	      if ((end = memchr(beg, eol, buflim - beg)) != NULL)
	        end++;
              else
                end = buflim;
	      while (beg > buf && beg[-1] != eol)
		--beg;
	    }
	  /* Successful, no backreferences encountered! */
	  if (!backref)
	    goto success;
	}
      else
	{
	  /* We are looking for the leftmost (then longest) exact match.
	     We will go through the outer loop only once.  */
	  beg = start_ptr;
	  end = buflim;
	}

      /* If we've made it to this point, this means DFA has seen
	 a probable match, and we need to run it through Regex. */
      best_match = end;
      best_len = 0;
      for (i = 0; i < pcount; i++)
	{
	  patterns[i].regexbuf.not_eol = 0;
	  if (0 <= (start = re_search (&(patterns[i].regexbuf),
				       buf, end - buf - 1,
				       beg - buf, end - beg - 1,
				       &(patterns[i].regs))))
	    {
	      len = patterns[i].regs.end[0] - start;
	      match = buf + start;
	      if (match > best_match)
		continue;
	      if (start_ptr && !match_words)
		goto assess_pattern_match;
	      if ((!match_lines && !match_words)
		  || (match_lines && len == end - beg - 1))
		{
		  match = beg;
		  len = end - beg;
		  goto assess_pattern_match;
		}
	      /* If -w, check if the match aligns with word boundaries.
		 We do this iteratively because:
		 (a) the line may contain more than one occurence of the
		 pattern, and
		 (b) Several alternatives in the pattern might be valid at a
		 given point, and we may need to consider a shorter one to
		 find a word boundary.  */
	      if (match_words)
		while (match <= best_match)
		  {
		    if ((match == buf || !WCHAR ((unsigned char) match[-1]))
			&& (len == end - beg - 1
			    || !WCHAR ((unsigned char) match[len])))
		      goto assess_pattern_match;
		    if (len > 0)
		      {
			/* Try a shorter length anchored at the same place. */
			--len;
			patterns[i].regexbuf.not_eol = 1;
			len = re_match (&(patterns[i].regexbuf),
					buf, match + len - beg, match - buf,
					&(patterns[i].regs));
		      }
		    if (len <= 0)
		      {
			/* Try looking further on. */
			if (match == end - 1)
			  break;
			match++;
			patterns[i].regexbuf.not_eol = 0;
			start = re_search (&(patterns[i].regexbuf),
					   buf, end - buf - 1,
					   match - buf, end - match - 1,
					   &(patterns[i].regs));
			if (start < 0)
			  break;
			len = patterns[i].regs.end[0] - start;
			match = buf + start;
		      }
		  } /* while (match <= best_match) */
	      continue;
	    assess_pattern_match:
	      if (!start_ptr)
		{
		  /* Good enough for a non-exact match.
		     No need to look at further patterns, if any.  */
		  beg = match;
		  goto success_in_len;
		}
	      if (match < best_match || (match == best_match && len > best_len))
		{
		  /* Best exact match:  leftmost, then longest.  */
		  best_match = match;
		  best_len = len;
		}
	    } /* if re_search >= 0 */
	} /* for Regex patterns.  */
	if (best_match < end)
	  {
	    /* We have found an exact match.  We were just
	       waiting for the best one (leftmost then longest).  */
	    beg = best_match;
	    len = best_len;
	    goto success_in_len;
	  }
    } /* for (beg = end ..) */

 failure:
  ret_val = -1;
  goto out;

 success:
  len = end - beg;
 success_in_len:
  *match_size = len;
  ret_val = beg - buf;
 out:
  return ret_val;
}
#endif /* defined(GREP_PROGRAM) || defined(EGREP_PROGRAM) */

#if defined(GREP_PROGRAM) || defined(FGREP_PROGRAM)
COMPILE_FCT(Fcompile)
{
  char const *beg, *end, *lim, *err, *pat;
  size_t psize;

  kwsinit ();
  psize = size;
  if (match_icase && MB_CUR_MAX > 1)
    pat = mbtolower (pattern, &psize);
  else
    pat = pattern;

  beg = pat;
  do
    {
      for (lim = beg;; ++lim)
	{
	  end = lim;
	  if (lim >= pat + psize)
	    break;
	 if (*lim == '\n')
	   {
	     lim++;
	     break;
	   }
#if HAVE_DOS_FILE_CONTENTS
	 if (*lim == '\r' && lim + 1 < pat + psize && lim[1] == '\n')
	   {
	     lim += 2;
	     break;
	   }
#endif
	}

      if ((err = kwsincr (kwset, beg, end - beg)) != NULL)
	error (EXIT_TROUBLE, 0, "%s", err);
      beg = lim;
    }
  while (beg < pat + psize);

  if ((err = kwsprep (kwset)) != NULL)
    error (EXIT_TROUBLE, 0, "%s", err);
}

EXECUTE_FCT(Fexecute)
{
  char const *beg, *try, *end, *mb_start;
  size_t len;
  char eol = eolbyte;
  struct kwsmatch kwsmatch;
  size_t ret_val;
#ifdef MBS_SUPPORT
  if (MB_CUR_MAX > 1)
    {
      if (match_icase)
        {
          char *case_buf = mbtolower (buf, &size);
	  if (start_ptr)
	    start_ptr = case_buf + (start_ptr - buf);
          buf = case_buf;
        }
    }
#endif /* MBS_SUPPORT */

  for (mb_start = beg = start_ptr ? start_ptr : buf; beg <= buf + size; beg++)
    {
      size_t offset = kwsexec (kwset, beg, buf + size - beg, &kwsmatch);
      
//Patch 0:
if ((offset == (size_t)-1) && !(__is_neg(18, &(offset), sizeof (offset), &(buf), sizeof (buf), &(size), sizeof (size), &(beg), sizeof (beg), &(kwset), sizeof (kwset), &(start_ptr), sizeof (start_ptr), &(mb_start), sizeof (mb_start), &(len), sizeof (len), &(match_words), sizeof (match_words), &(match_icase), sizeof (match_icase), &(match_lines), sizeof (match_lines), &(eol), sizeof (eol), &(eolbyte), sizeof (eolbyte), &(try), sizeof (try), &(ret_val), sizeof (ret_val), &(end), sizeof (end), &(match_size), sizeof (match_size), &(kwsmatch.index), sizeof (kwsmatch.index))))
    goto failure;

//CodeSeg 1:
#ifdef MBS_SUPPORT
      if (MB_CUR_MAX > 1 && is_mb_middle (&mb_start, beg + offset, buf + size))
        {
          beg = mb_start - 1;
          continue; /* It is a part of multibyte character.  */
        }
#endif /* MBS_SUPPORT */
      beg += offset;
      len = kwsmatch.size[0];
      if (start_ptr && !match_words)
	goto success_in_beg_and_len;
      if (match_lines)
	{
	  if (beg > buf && beg[-1] != eol)
	    continue;
	  if (beg + len < buf + size && beg[len] != eol)
	    continue;
	  goto success;
	}
      else if (match_words)
	for (try = beg; len; )
	  {
	    if (try > buf && WCHAR((unsigned char) try[-1]))
	      break;
	    if (try + len < buf + size && WCHAR((unsigned char) try[len]))
	      {
		offset = kwsexec (kwset, beg, --len, &kwsmatch);
		if (offset == (size_t) -1)
		  break;
		try = beg + offset;
		len = kwsmatch.size[0];
	      }
	    else if (!start_ptr)
	      goto success;
	    else
	      goto success_in_beg_and_len;
	  } /* for (try) */
      else
	goto success;
    } /* for (beg in buf) */

 failure:
  ret_val = -1;
  goto out;

 success:
  if ((end = memchr (beg + len, eol, (buf + size) - (beg + len))) != NULL)
    end++;
  else
    end = buf + size;
  while (buf < beg && beg[-1] != eol)
    --beg;
  len = end - beg;
 success_in_beg_and_len:
  *match_size = len;
  ret_val = beg - buf;
 out:
  return ret_val;
}
#endif /* defined(GREP_PROGRAM) || defined(FGREP_PROGRAM) */

#ifdef GREP_PROGRAM
#if HAVE_LIBPCRE
/* Compiled internal form of a Perl regular expression.  */
static pcre *cre;

/* Additional information about the pattern.  */
static pcre_extra *extra;
#endif

COMPILE_FCT(Pcompile)
{
#if !HAVE_LIBPCRE
  error (EXIT_TROUBLE, 0, "%s",
	 _("support for the -P option is not compiled into "
	   "this --disable-perl-regexp binary"));
#else
  int e;
  char const *ep;
  char *re = xmalloc (4 * size + 7);
  int flags = PCRE_MULTILINE | (match_icase ? PCRE_CASELESS : 0);
  char const *patlim = pattern + size;
  char *n = re;
  char const *p;
  char const *pnul;

  /* FIXME: Remove these restrictions.  */
  if (memchr(pattern, '\n', size))
    error (EXIT_TROUBLE, 0, _("the -P option only supports a single pattern"));

  *n = '\0';
  if (match_lines)
    strcpy (n, "^(");
  if (match_words)
    strcpy (n, "\\b(");
  n += strlen (n);

  /* The PCRE interface doesn't allow NUL bytes in the pattern, so
     replace each NUL byte in the pattern with the four characters
     "\000", removing a preceding backslash if there are an odd
     number of backslashes before the NUL.

     FIXME: This method does not work with some multibyte character
     encodings, notably Shift-JIS, where a multibyte character can end
     in a backslash byte.  */
  for (p = pattern; (pnul = memchr (p, '\0', patlim - p)); p = pnul + 1)
    {
      memcpy (n, p, pnul - p);
      n += pnul - p;
      for (p = pnul; pattern < p && p[-1] == '\\'; p--)
	continue;
      n -= (pnul - p) & 1;
      strcpy (n, "\\000");
      n += 4;
    }

  memcpy (n, p, patlim - p);
  n += patlim - p;
  *n = '\0';
  if (match_words)
    strcpy (n, ")\\b");
  if (match_lines)
    strcpy (n, ")$");

  cre = pcre_compile (re, flags, &ep, &e, pcre_maketables ());
  if (!cre)
    error (EXIT_TROUBLE, 0, "%s", ep);

  extra = pcre_study (cre, 0, &ep);
  if (ep)
    error (EXIT_TROUBLE, 0, "%s", ep);

  free (re);
#endif
}

EXECUTE_FCT(Pexecute)
{
#if !HAVE_LIBPCRE
  abort ();
  return -1;
#else
  /* This array must have at least two elements; everything after that
     is just for performance improvement in pcre_exec.  */
  int sub[300];

  const char *line_buf, *line_end, *line_next;
  int e = PCRE_ERROR_NOMATCH;
  ptrdiff_t start_ofs = start_ptr ? start_ptr - buf : 0;

  /* PCRE can't limit the matching to single lines, therefore we have to
     match each line in the buffer separately.  */
  for (line_next = buf;
       e == PCRE_ERROR_NOMATCH && line_next < buf + size;
       start_ofs -= line_next - line_buf)
    {
      line_buf = line_next;
      line_end = memchr (line_buf, eolbyte, (buf + size) - line_buf);
      if (line_end == NULL)
        line_next = line_end = buf + size;
      else
        line_next = line_end + 1;

      if (start_ptr && start_ptr >= line_end)
        continue;

      e = pcre_exec (cre, extra, line_buf, line_end - line_buf,
                     start_ofs < 0 ? 0 : start_ofs, 0,
                     sub, sizeof sub / sizeof *sub);
    }

  if (e <= 0)
    {
      switch (e)
	{
	case PCRE_ERROR_NOMATCH:
	  return -1;

	case PCRE_ERROR_NOMEMORY:
	  error (EXIT_TROUBLE, 0, _("memory exhausted"));

	default:
	  abort ();
	}
    }
  else
    {
      /* Narrow down to the line we've found.  */
      char const *beg = line_buf + sub[0];
      char const *end = line_buf + sub[1];
      char const *buflim = buf + size;
      char eol = eolbyte;
      if (!start_ptr)
	{
	  /* FIXME: The case when '\n' is not found indicates a bug:
	     Since grep is line oriented, the match should never contain
	     a newline, so there _must_ be a newline following.
	   */
	  if (!(end = memchr (end, eol, buflim - end)))
	    end = buflim;
	  else
	    end++;
	  while (buf < beg && beg[-1] != eol)
	    --beg;
	}

      *match_size = end - beg;
      return beg - buf;
    }
#endif
}

struct matcher const matchers[] = {
  { "default", Gcompile, EGexecute },
  { "grep",    Gcompile, EGexecute },
  { "egrep",   Ecompile, EGexecute },
  { "awk",     Acompile, EGexecute },
  { "fgrep",   Fcompile, Fexecute },
  { "perl",    Pcompile, Pexecute },
  { "", 0, 0 },
};
#endif /* GREP_PROGRAM */

Testing negative cases!
Testing 0 (with abstract condition) ENVIS_NEG
Iteration 0
Running test command:
/home/ubuntu/spr-fast/tools/grep-test.py /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-deccad69-db9d6340/tempworkdir2/src /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-deccad69-db9d6340/tempworkdir2/tests /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-deccad69-db9d6340/tempworkdir2 0  > __res
Opening:/home/ubuntu/spr-fast/tests/corebench/grep/grep-case-deccad69-db9d6340/tempworkdir2/neg.tmp!
NegativeBRANCH RECORD/home/ubuntu/spr-fast/tests/corebench/grep/grep-case-deccad69-db9d6340/tempworkdir2/neg.tmp!
Not caught by the negative case, give up!
APPENDING TO ISNEG:/home/ubuntu/spr-fast/tests/corebench/grep/grep-case-deccad69-db9d6340/tempworkdir2/neg.tmp!
Running test command:
/home/ubuntu/spr-fast/tools/grep-test.py /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-deccad69-db9d6340/tempworkdir2/src /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-deccad69-db9d6340/tempworkdir2/tests /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-deccad69-db9d6340/tempworkdir2 0  > __res
CondTester, Testing instance id 22:
//src_file:src/search.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
/* search.c - searching subroutines using dfa, kwset and regex for grep.
   Copyright 1992, 1998, 2000, 2007, 2009-2010 Free Software Foundation, Inc.

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 3, or (at your option)
   any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program; if not, write to the Free Software
   Foundation, Inc., 51 Franklin Street - Fifth Floor, Boston, MA
   02110-1301, USA.  */

/* Written August 1992 by Mike Haertel. */

#include <config.h>

#include <sys/types.h>

#include "mbsupport.h"
#ifdef MBS_SUPPORT
/* We can handle multibyte strings. */
# include <wchar.h>
# include <wctype.h>
#endif

#include "system.h"
#include "grep.h"
#ifndef FGREP_PROGRAM
# include <regex.h>
# include "dfa.h"
#endif
#include "kwset.h"
#include "error.h"
#include "xalloc.h"
#ifdef HAVE_LIBPCRE
# include <pcre.h>
#endif

#define NCHAR (UCHAR_MAX + 1)

/* For -w, we also consider _ to be word constituent.  */
#define WCHAR(C) (ISALNUM(C) || (C) == '_')

/* KWset compiled pattern.  For Ecompile and Gcompile, we compile
   a list of strings, at least one of which is known to occur in
   any string matching the regexp. */
static kwset_t kwset;

static void
kwsinit (void)
{
  static char trans[NCHAR];
  int i;

  if (match_icase && MB_CUR_MAX == 1)
    {
      for (i = 0; i < NCHAR; ++i)
        trans[i] = TOLOWER (i);

      kwset = kwsalloc (trans);
    }
  else
    kwset = kwsalloc (NULL);

  if (!kwset)
    xalloc_die ();
}

#ifdef MBS_SUPPORT
/* Convert the *N-byte string, BEG, to lowercase, and write the
   NUL-terminated result into malloc'd storage.  Upon success, set *N
   to the length (in bytes) of the resulting string (not including the
   trailing NUL byte), and return a pointer to the lowercase string.
   Upon memory allocation failure, this function exits.

   Note that while this function returns a pointer to malloc'd storage,
   the caller must not free it, since this function retains a pointer
   to the buffer and reuses it on any subsequent call.  As a consequence,
   this function is not thread-safe.  */
static char *
mbtolower (const char *beg, size_t *n)
{
  static char *out;
  static size_t outalloc;
  size_t outlen, mb_cur_max;
  mbstate_t is, os;
  const char *end;
  char *p;

  if (*n > outalloc)
    {
      out = xrealloc (out, *n);
      outalloc = *n;
    }

  memset (&is, 0, sizeof (is));
  memset (&os, 0, sizeof (os));
  end = beg + *n;

  mb_cur_max = MB_CUR_MAX;
  p = out;
  outlen = 0;
  while (beg < end)
    {
      wchar_t wc;
      size_t mbclen = mbrtowc(&wc, beg, end - beg, &is);
      if (outlen + mb_cur_max >= outalloc)
        {
          out = x2nrealloc (out, &outalloc, 1);
          p = out + outlen;
        }

      if (mbclen == (size_t) -1 || mbclen == (size_t) -2 || mbclen == 0)
        {
          /* An invalid sequence, or a truncated multi-octet character.
             We treat it as a single-octet character.  */
          *p++ = *beg++;
          outlen++;
          memset (&is, 0, sizeof (is));
          memset (&os, 0, sizeof (os));
        }
      else
        {
          beg += mbclen;
          mbclen = wcrtomb (p, towlower ((wint_t) wc), &os);
          p += mbclen;
          outlen += mbclen;
        }
    }

  *n = p - out;
  *p++ = 0;
  return out;
}
#endif


#ifndef FGREP_PROGRAM
/* DFA compiled regexp. */
static struct dfa dfa;

/* The Regex compiled patterns.  */
static struct patterns
{
  /* Regex compiled regexp. */
  struct re_pattern_buffer regexbuf;
  struct re_registers regs; /* This is here on account of a BRAIN-DEAD
			       Q@#%!# library interface in regex.c.  */
} patterns0;

struct patterns *patterns;
size_t pcount;

void
dfaerror (char const *mesg)
{
  error (EXIT_TROUBLE, 0, "%s", mesg);
}

/* Number of compiled fixed strings known to exactly match the regexp.
   If kwsexec returns < kwset_exact_matches, then we don't need to
   call the regexp matcher at all. */
static int kwset_exact_matches;

static char const *
kwsincr_case (const char *must)
{
  const char *buf;
  size_t n;

  n = strlen (must);
#ifdef MBS_SUPPORT
  if (match_icase && MB_CUR_MAX > 1)
    buf = mbtolower (must, &n);
  else
#endif
    buf = must;
  return kwsincr (kwset, buf, n);
}

/* If the DFA turns out to have some set of fixed strings one of
   which must occur in the match, then we build a kwset matcher
   to find those strings, and thus quickly filter out impossible
   matches. */
static void
kwsmusts (void)
{
  struct dfamust const *dm;
  char const *err;

  if (dfa.musts)
    {
      kwsinit ();
      /* First, we compile in the substrings known to be exact
	 matches.  The kwset matcher will return the index
	 of the matching string that it chooses. */
      for (dm = dfa.musts; dm; dm = dm->next)
	{
	  if (!dm->exact)
	    continue;
	  ++kwset_exact_matches;
	  if ((err = kwsincr_case (dm->must)) != NULL)
	    error (EXIT_TROUBLE, 0, "%s", err);
	}
      /* Now, we compile the substrings that will require
	 the use of the regexp matcher.  */
      for (dm = dfa.musts; dm; dm = dm->next)
	{
	  if (dm->exact)
	    continue;
	  if ((err = kwsincr_case (dm->must)) != NULL)
	    error (EXIT_TROUBLE, 0, "%s", err);
	}
      if ((err = kwsprep (kwset)) != NULL)
	error (EXIT_TROUBLE, 0, "%s", err);
    }
}
#endif /* !FGREP_PROGRAM */

#ifdef MBS_SUPPORT

static bool
is_mb_middle(const char **good, const char *buf, const char *end)
{
  const char *p = *good;
  const char *prev = p;
  mbstate_t cur_state;

  /* TODO: can be optimized for UTF-8.  */
  memset(&cur_state, 0, sizeof(mbstate_t));
  while (p < buf)
    {
      size_t mbclen = mbrlen(p, end - p, &cur_state);

      /* Store the beginning of the previous complete multibyte character.  */
      if (mbclen != (size_t) -2)
        prev = p;

      if (mbclen == (size_t) -1 || mbclen == (size_t) -2 || mbclen == 0)
	{
	  /* An invalid sequence, or a truncated multibyte character.
	     We treat it as a single byte character.  */
	  mbclen = 1;
	}
      p += mbclen;
    }

  *good = prev;
  return p > buf;
}
#endif /* MBS_SUPPORT */

#if defined(GREP_PROGRAM) || defined(EGREP_PROGRAM)
#ifdef EGREP_PROGRAM
COMPILE_FCT(Ecompile)
{
  reg_syntax_t syntax_bits = RE_SYNTAX_POSIX_EGREP;
#else
/* No __VA_ARGS__ in C89.  So we have to do it this way.  */
static COMPILE_RET
GEAcompile (char const *pattern, size_t size, reg_syntax_t syntax_bits)
{
#endif /* EGREP_PROGRAM */
  const char *err;
  const char *p, *sep;
  size_t total = size;
  char *motif;

  if (match_icase)
    syntax_bits |= RE_ICASE;
  re_set_syntax (syntax_bits);
  dfasyntax (syntax_bits, match_icase, eolbyte);

  /* For GNU regex compiler we have to pass the patterns separately to detect
     errors like "[\nallo\n]\n".  The patterns here are "[", "allo" and "]"
     GNU regex should have raise a syntax error.  The same for backref, where
     the backref should have been local to each pattern.  */
  p = pattern;
  do
    {
      size_t len;
      sep = memchr (p, '\n', total);
      if (sep)
	{
	  len = sep - p;
	  sep++;
	  total -= (len + 1);
	}
      else
	{
	  len = total;
	  total = 0;
	}

      patterns = realloc (patterns, (pcount + 1) * sizeof (*patterns));
      if (patterns == NULL)
	error (EXIT_TROUBLE, errno, _("memory exhausted"));
      patterns[pcount] = patterns0;

      if ((err = re_compile_pattern (p, len,
				    &(patterns[pcount].regexbuf))) != NULL)
	error (EXIT_TROUBLE, 0, "%s", err);
      pcount++;

      p = sep;
    } while (sep && total != 0);

  /* In the match_words and match_lines cases, we use a different pattern
     for the DFA matcher that will quickly throw out cases that won't work.
     Then if DFA succeeds we do some hairy stuff using the regex matcher
     to decide whether the match should really count. */
  if (match_words || match_lines)
    {
      static char const line_beg_no_bk[] = "^(";
      static char const line_end_no_bk[] = ")$";
      static char const word_beg_no_bk[] = "(^|[^[:alnum:]_])(";
      static char const word_end_no_bk[] = ")([^[:alnum:]_]|$)";
#ifdef EGREP_PROGRAM
# define IF_BK(x, y) (y)
      char *n = xmalloc (sizeof word_beg_no_bk - 1 + size + sizeof word_end_no_bk);
#else
      static char const line_beg_bk[] = "^\\(";
      static char const line_end_bk[] = "\\)$";
      static char const word_beg_bk[] = "\\(^\\|[^[:alnum:]_]\\)\\(";
      static char const word_end_bk[] = "\\)\\([^[:alnum:]_]\\|$\\)";
      int bk = !(syntax_bits & RE_NO_BK_PARENS);
# define IF_BK(x, y) ((bk) ? (x) : (y))
      char *n = xmalloc (sizeof word_beg_bk - 1 + size + sizeof word_end_bk);
#endif /* EGREP_PROGRAM */

      strcpy (n, match_lines ? IF_BK(line_beg_bk, line_beg_no_bk)
			     : IF_BK(word_beg_bk, word_beg_no_bk));
      total = strlen(n);
      memcpy (n + total, pattern, size);
      total += size;
      strcpy (n + total, match_lines ? IF_BK(line_end_bk, line_end_no_bk)
				     : IF_BK(word_end_bk, word_end_no_bk));
      total += strlen (n + total);
      pattern = motif = n;
      size = total;
    }
  else
    motif = NULL;

  dfacomp (pattern, size, &dfa, 1);
  kwsmusts ();

  free(motif);
}

#ifndef EGREP_PROGRAM
COMPILE_FCT(Gcompile)
{
  return GEAcompile (pattern, size,
		     RE_SYNTAX_GREP | RE_HAT_LISTS_NOT_NEWLINE);
}

COMPILE_FCT(Acompile)
{
  return GEAcompile (pattern, size, RE_SYNTAX_AWK);
}

COMPILE_FCT(Ecompile)
{
  return GEAcompile (pattern, size, RE_SYNTAX_POSIX_EGREP);
}
#endif /* !EGREP_PROGRAM */

EXECUTE_FCT(EGexecute)
{
  char const *buflim, *beg, *end, *match, *best_match, *mb_start;
  char eol = eolbyte;
  int backref, start, len, best_len;
  struct kwsmatch kwsm;
  size_t i, ret_val;
#ifdef MBS_SUPPORT
  if (MB_CUR_MAX > 1)
    {
      if (match_icase)
        {
          /* mbtolower adds a NUL byte at the end.  That will provide
	     space for the sentinel byte dfaexec may add.  */
          char *case_buf = mbtolower (buf, &size);
	  if (start_ptr)
	    start_ptr = case_buf + (start_ptr - buf);
          buf = case_buf;
        }
    }
#endif /* MBS_SUPPORT */

  mb_start = buf;
  buflim = buf + size;

  for (beg = end = buf; end < buflim; beg = end)
    {
      if (!start_ptr)
	{
	  /* We don't care about an exact match.  */
	  if (kwset)
	    {
	      /* Find a possible match using the KWset matcher. */
	      size_t offset = kwsexec (kwset, beg, buflim - beg, &kwsm);
	      if (offset == (size_t) -1)
		goto failure;
	      beg += offset;
	      /* Narrow down to the line containing the candidate, and
		 run it through DFA. */
	      if ((end = memchr(beg, eol, buflim - beg)) != NULL)
	        end++;
              else
                end = buflim;
	      match = beg;
	      while (beg > buf && beg[-1] != eol)
		--beg;
	      if (kwsm.index < kwset_exact_matches)
                {
#ifdef MBS_SUPPORT
                  if (mb_start < beg)
                    mb_start = beg;
                  if (MB_CUR_MAX == 1 || !is_mb_middle (&mb_start, match, buflim))
#endif
                    goto success;
                }
	      if (dfaexec (&dfa, beg, (char *) end, 0, NULL, &backref) == NULL)
		continue;
	    }
	  else
	    {
	      /* No good fixed strings; start with DFA. */
	      char const *next_beg = dfaexec (&dfa, beg, (char *) buflim,
					      0, NULL, &backref);
	      if (next_beg == NULL)
		break;
	      /* Narrow down to the line we've found. */
	      beg = next_beg;
	      if ((end = memchr(beg, eol, buflim - beg)) != NULL)
	        end++;
              else
                end = buflim;
	      while (beg > buf && beg[-1] != eol)
		--beg;
	    }
	  /* Successful, no backreferences encountered! */
	  if (!backref)
	    goto success;
	}
      else
	{
	  /* We are looking for the leftmost (then longest) exact match.
	     We will go through the outer loop only once.  */
	  beg = start_ptr;
	  end = buflim;
	}

      /* If we've made it to this point, this means DFA has seen
	 a probable match, and we need to run it through Regex. */
      best_match = end;
      best_len = 0;
      for (i = 0; i < pcount; i++)
	{
	  patterns[i].regexbuf.not_eol = 0;
	  if (0 <= (start = re_search (&(patterns[i].regexbuf),
				       buf, end - buf - 1,
				       beg - buf, end - beg - 1,
				       &(patterns[i].regs))))
	    {
	      len = patterns[i].regs.end[0] - start;
	      match = buf + start;
	      if (match > best_match)
		continue;
	      if (start_ptr && !match_words)
		goto assess_pattern_match;
	      if ((!match_lines && !match_words)
		  || (match_lines && len == end - beg - 1))
		{
		  match = beg;
		  len = end - beg;
		  goto assess_pattern_match;
		}
	      /* If -w, check if the match aligns with word boundaries.
		 We do this iteratively because:
		 (a) the line may contain more than one occurence of the
		 pattern, and
		 (b) Several alternatives in the pattern might be valid at a
		 given point, and we may need to consider a shorter one to
		 find a word boundary.  */
	      if (match_words)
		while (match <= best_match)
		  {
		    if ((match == buf || !WCHAR ((unsigned char) match[-1]))
			&& (len == end - beg - 1
			    || !WCHAR ((unsigned char) match[len])))
		      goto assess_pattern_match;
		    if (len > 0)
		      {
			/* Try a shorter length anchored at the same place. */
			--len;
			patterns[i].regexbuf.not_eol = 1;
			len = re_match (&(patterns[i].regexbuf),
					buf, match + len - beg, match - buf,
					&(patterns[i].regs));
		      }
		    if (len <= 0)
		      {
			/* Try looking further on. */
			if (match == end - 1)
			  break;
			match++;
			patterns[i].regexbuf.not_eol = 0;
			start = re_search (&(patterns[i].regexbuf),
					   buf, end - buf - 1,
					   match - buf, end - match - 1,
					   &(patterns[i].regs));
			if (start < 0)
			  break;
			len = patterns[i].regs.end[0] - start;
			match = buf + start;
		      }
		  } /* while (match <= best_match) */
	      continue;
	    assess_pattern_match:
	      if (!start_ptr)
		{
		  /* Good enough for a non-exact match.
		     No need to look at further patterns, if any.  */
		  beg = match;
		  goto success_in_len;
		}
	      if (match < best_match || (match == best_match && len > best_len))
		{
		  /* Best exact match:  leftmost, then longest.  */
		  best_match = match;
		  best_len = len;
		}
	    } /* if re_search >= 0 */
	} /* for Regex patterns.  */
	if (best_match < end)
	  {
	    /* We have found an exact match.  We were just
	       waiting for the best one (leftmost then longest).  */
	    beg = best_match;
	    len = best_len;
	    goto success_in_len;
	  }
    } /* for (beg = end ..) */

 failure:
  ret_val = -1;
  goto out;

 success:
  len = end - beg;
 success_in_len:
  *match_size = len;
  ret_val = beg - buf;
 out:
  return ret_val;
}
#endif /* defined(GREP_PROGRAM) || defined(EGREP_PROGRAM) */

#if defined(GREP_PROGRAM) || defined(FGREP_PROGRAM)
COMPILE_FCT(Fcompile)
{
  char const *beg, *end, *lim, *err, *pat;
  size_t psize;

  kwsinit ();
  psize = size;
  if (match_icase && MB_CUR_MAX > 1)
    pat = mbtolower (pattern, &psize);
  else
    pat = pattern;

  beg = pat;
  do
    {
      for (lim = beg;; ++lim)
	{
	  end = lim;
	  if (lim >= pat + psize)
	    break;
	 if (*lim == '\n')
	   {
	     lim++;
	     break;
	   }
#if HAVE_DOS_FILE_CONTENTS
	 if (*lim == '\r' && lim + 1 < pat + psize && lim[1] == '\n')
	   {
	     lim += 2;
	     break;
	   }
#endif
	}

      if ((err = kwsincr (kwset, beg, end - beg)) != NULL)
	error (EXIT_TROUBLE, 0, "%s", err);
      beg = lim;
    }
  while (beg < pat + psize);

  if ((err = kwsprep (kwset)) != NULL)
    error (EXIT_TROUBLE, 0, "%s", err);
}

EXECUTE_FCT(Fexecute)
{
  char const *beg, *try, *end, *mb_start;
  size_t len;
  char eol = eolbyte;
  struct kwsmatch kwsmatch;
  size_t ret_val;
#ifdef MBS_SUPPORT
  if (MB_CUR_MAX > 1)
    {
      if (match_icase)
        {
          char *case_buf = mbtolower (buf, &size);
	  if (start_ptr)
	    start_ptr = case_buf + (start_ptr - buf);
          buf = case_buf;
        }
    }
#endif /* MBS_SUPPORT */

  for (mb_start = beg = start_ptr ? start_ptr : buf; beg <= buf + size; beg++)
    {
      size_t offset = kwsexec (kwset, beg, buf + size - beg, &kwsmatch);
      
//Patch 0:
if ((offset == (size_t)-1) || (__is_neg(18, &(offset), sizeof (offset), &(buf), sizeof (buf), &(size), sizeof (size), &(beg), sizeof (beg), &(kwset), sizeof (kwset), &(start_ptr), sizeof (start_ptr), &(mb_start), sizeof (mb_start), &(len), sizeof (len), &(match_words), sizeof (match_words), &(match_icase), sizeof (match_icase), &(match_lines), sizeof (match_lines), &(eol), sizeof (eol), &(eolbyte), sizeof (eolbyte), &(try), sizeof (try), &(ret_val), sizeof (ret_val), &(end), sizeof (end), &(match_size), sizeof (match_size), &(kwsmatch.index), sizeof (kwsmatch.index))))
    goto failure;

//CodeSeg 1:
#ifdef MBS_SUPPORT
      if (MB_CUR_MAX > 1 && is_mb_middle (&mb_start, beg + offset, buf + size))
        {
          beg = mb_start - 1;
          continue; /* It is a part of multibyte character.  */
        }
#endif /* MBS_SUPPORT */
      beg += offset;
      len = kwsmatch.size[0];
      if (start_ptr && !match_words)
	goto success_in_beg_and_len;
      if (match_lines)
	{
	  if (beg > buf && beg[-1] != eol)
	    continue;
	  if (beg + len < buf + size && beg[len] != eol)
	    continue;
	  goto success;
	}
      else if (match_words)
	for (try = beg; len; )
	  {
	    if (try > buf && WCHAR((unsigned char) try[-1]))
	      break;
	    if (try + len < buf + size && WCHAR((unsigned char) try[len]))
	      {
		offset = kwsexec (kwset, beg, --len, &kwsmatch);
		if (offset == (size_t) -1)
		  break;
		try = beg + offset;
		len = kwsmatch.size[0];
	      }
	    else if (!start_ptr)
	      goto success;
	    else
	      goto success_in_beg_and_len;
	  } /* for (try) */
      else
	goto success;
    } /* for (beg in buf) */

 failure:
  ret_val = -1;
  goto out;

 success:
  if ((end = memchr (beg + len, eol, (buf + size) - (beg + len))) != NULL)
    end++;
  else
    end = buf + size;
  while (buf < beg && beg[-1] != eol)
    --beg;
  len = end - beg;
 success_in_beg_and_len:
  *match_size = len;
  ret_val = beg - buf;
 out:
  return ret_val;
}
#endif /* defined(GREP_PROGRAM) || defined(FGREP_PROGRAM) */

#ifdef GREP_PROGRAM
#if HAVE_LIBPCRE
/* Compiled internal form of a Perl regular expression.  */
static pcre *cre;

/* Additional information about the pattern.  */
static pcre_extra *extra;
#endif

COMPILE_FCT(Pcompile)
{
#if !HAVE_LIBPCRE
  error (EXIT_TROUBLE, 0, "%s",
	 _("support for the -P option is not compiled into "
	   "this --disable-perl-regexp binary"));
#else
  int e;
  char const *ep;
  char *re = xmalloc (4 * size + 7);
  int flags = PCRE_MULTILINE | (match_icase ? PCRE_CASELESS : 0);
  char const *patlim = pattern + size;
  char *n = re;
  char const *p;
  char const *pnul;

  /* FIXME: Remove these restrictions.  */
  if (memchr(pattern, '\n', size))
    error (EXIT_TROUBLE, 0, _("the -P option only supports a single pattern"));

  *n = '\0';
  if (match_lines)
    strcpy (n, "^(");
  if (match_words)
    strcpy (n, "\\b(");
  n += strlen (n);

  /* The PCRE interface doesn't allow NUL bytes in the pattern, so
     replace each NUL byte in the pattern with the four characters
     "\000", removing a preceding backslash if there are an odd
     number of backslashes before the NUL.

     FIXME: This method does not work with some multibyte character
     encodings, notably Shift-JIS, where a multibyte character can end
     in a backslash byte.  */
  for (p = pattern; (pnul = memchr (p, '\0', patlim - p)); p = pnul + 1)
    {
      memcpy (n, p, pnul - p);
      n += pnul - p;
      for (p = pnul; pattern < p && p[-1] == '\\'; p--)
	continue;
      n -= (pnul - p) & 1;
      strcpy (n, "\\000");
      n += 4;
    }

  memcpy (n, p, patlim - p);
  n += patlim - p;
  *n = '\0';
  if (match_words)
    strcpy (n, ")\\b");
  if (match_lines)
    strcpy (n, ")$");

  cre = pcre_compile (re, flags, &ep, &e, pcre_maketables ());
  if (!cre)
    error (EXIT_TROUBLE, 0, "%s", ep);

  extra = pcre_study (cre, 0, &ep);
  if (ep)
    error (EXIT_TROUBLE, 0, "%s", ep);

  free (re);
#endif
}

EXECUTE_FCT(Pexecute)
{
#if !HAVE_LIBPCRE
  abort ();
  return -1;
#else
  /* This array must have at least two elements; everything after that
     is just for performance improvement in pcre_exec.  */
  int sub[300];

  const char *line_buf, *line_end, *line_next;
  int e = PCRE_ERROR_NOMATCH;
  ptrdiff_t start_ofs = start_ptr ? start_ptr - buf : 0;

  /* PCRE can't limit the matching to single lines, therefore we have to
     match each line in the buffer separately.  */
  for (line_next = buf;
       e == PCRE_ERROR_NOMATCH && line_next < buf + size;
       start_ofs -= line_next - line_buf)
    {
      line_buf = line_next;
      line_end = memchr (line_buf, eolbyte, (buf + size) - line_buf);
      if (line_end == NULL)
        line_next = line_end = buf + size;
      else
        line_next = line_end + 1;

      if (start_ptr && start_ptr >= line_end)
        continue;

      e = pcre_exec (cre, extra, line_buf, line_end - line_buf,
                     start_ofs < 0 ? 0 : start_ofs, 0,
                     sub, sizeof sub / sizeof *sub);
    }

  if (e <= 0)
    {
      switch (e)
	{
	case PCRE_ERROR_NOMATCH:
	  return -1;

	case PCRE_ERROR_NOMEMORY:
	  error (EXIT_TROUBLE, 0, _("memory exhausted"));

	default:
	  abort ();
	}
    }
  else
    {
      /* Narrow down to the line we've found.  */
      char const *beg = line_buf + sub[0];
      char const *end = line_buf + sub[1];
      char const *buflim = buf + size;
      char eol = eolbyte;
      if (!start_ptr)
	{
	  /* FIXME: The case when '\n' is not found indicates a bug:
	     Since grep is line oriented, the match should never contain
	     a newline, so there _must_ be a newline following.
	   */
	  if (!(end = memchr (end, eol, buflim - end)))
	    end = buflim;
	  else
	    end++;
	  while (buf < beg && beg[-1] != eol)
	    --beg;
	}

      *match_size = end - beg;
      return beg - buf;
    }
#endif
}

struct matcher const matchers[] = {
  { "default", Gcompile, EGexecute },
  { "grep",    Gcompile, EGexecute },
  { "egrep",   Ecompile, EGexecute },
  { "awk",     Acompile, EGexecute },
  { "fgrep",   Fcompile, Fexecute },
  { "perl",    Pcompile, Pexecute },
  { "", 0, 0 },
};
#endif /* GREP_PROGRAM */

Testing negative cases!
Testing 0 (with abstract condition) ENVIS_NEG
Iteration 0
Running test command:
/home/ubuntu/spr-fast/tools/grep-test.py /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-deccad69-db9d6340/tempworkdir2/src /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-deccad69-db9d6340/tempworkdir2/tests /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-deccad69-db9d6340/tempworkdir2 0  > __res
Opening:/home/ubuntu/spr-fast/tests/corebench/grep/grep-case-deccad69-db9d6340/tempworkdir2/neg.tmp!
NegativeBRANCH RECORD/home/ubuntu/spr-fast/tests/corebench/grep/grep-case-deccad69-db9d6340/tempworkdir2/neg.tmp!
APPENDING TO ISNEG:/home/ubuntu/spr-fast/tests/corebench/grep/grep-case-deccad69-db9d6340/tempworkdir2/neg.tmp!
Running test command:
/home/ubuntu/spr-fast/tools/grep-test.py /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-deccad69-db9d6340/tempworkdir2/src /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-deccad69-db9d6340/tempworkdir2/tests /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-deccad69-db9d6340/tempworkdir2 0  > __res
Opening:/home/ubuntu/spr-fast/tests/corebench/grep/grep-case-deccad69-db9d6340/tempworkdir2/neg.tmp!
NegativeBRANCH RECORD/home/ubuntu/spr-fast/tests/corebench/grep/grep-case-deccad69-db9d6340/tempworkdir2/neg.tmp!
Log 0 1
Passed Negative Cases wiht CondTestder!
Testing positive cases!
Running test command:
/home/ubuntu/spr-fast/tools/grep-test.py /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-deccad69-db9d6340/tempworkdir2/src /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-deccad69-db9d6340/tempworkdir2/tests /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-deccad69-db9d6340/tempworkdir2 9  > __res
Running test command:
/home/ubuntu/spr-fast/tools/grep-test.py /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-deccad69-db9d6340/tempworkdir2/src /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-deccad69-db9d6340/tempworkdir2/tests /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-deccad69-db9d6340/tempworkdir2 12  > __res
Running test command:
/home/ubuntu/spr-fast/tools/grep-test.py /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-deccad69-db9d6340/tempworkdir2/src /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-deccad69-db9d6340/tempworkdir2/tests /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-deccad69-db9d6340/tempworkdir2 3  > __res
Running test command:
/home/ubuntu/spr-fast/tools/grep-test.py /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-deccad69-db9d6340/tempworkdir2/src /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-deccad69-db9d6340/tempworkdir2/tests /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-deccad69-db9d6340/tempworkdir2 4  > __res
Running test command:
/home/ubuntu/spr-fast/tools/grep-test.py /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-deccad69-db9d6340/tempworkdir2/src /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-deccad69-db9d6340/tempworkdir2/tests /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-deccad69-db9d6340/tempworkdir2 5  > __res
Running test command:
/home/ubuntu/spr-fast/tools/grep-test.py /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-deccad69-db9d6340/tempworkdir2/src /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-deccad69-db9d6340/tempworkdir2/tests /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-deccad69-db9d6340/tempworkdir2 6  > __res
Running test command:
/home/ubuntu/spr-fast/tools/grep-test.py /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-deccad69-db9d6340/tempworkdir2/src /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-deccad69-db9d6340/tempworkdir2/tests /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-deccad69-db9d6340/tempworkdir2 11  > __res
Running test command:
/home/ubuntu/spr-fast/tools/grep-test.py /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-deccad69-db9d6340/tempworkdir2/src /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-deccad69-db9d6340/tempworkdir2/tests /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-deccad69-db9d6340/tempworkdir2 13  > __res
Running test command:
/home/ubuntu/spr-fast/tools/grep-test.py /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-deccad69-db9d6340/tempworkdir2/src /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-deccad69-db9d6340/tempworkdir2/tests /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-deccad69-db9d6340/tempworkdir2 14  > __res
Running test command:
/home/ubuntu/spr-fast/tools/grep-test.py /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-deccad69-db9d6340/tempworkdir2/src /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-deccad69-db9d6340/tempworkdir2/tests /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-deccad69-db9d6340/tempworkdir2 15  > __res
Running test command:
/home/ubuntu/spr-fast/tools/grep-test.py /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-deccad69-db9d6340/tempworkdir2/src /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-deccad69-db9d6340/tempworkdir2/tests /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-deccad69-db9d6340/tempworkdir2 17  > __res
Running test command:
/home/ubuntu/spr-fast/tools/grep-test.py /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-deccad69-db9d6340/tempworkdir2/src /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-deccad69-db9d6340/tempworkdir2/tests /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-deccad69-db9d6340/tempworkdir2 18  > __res
Running test command:
/home/ubuntu/spr-fast/tools/grep-test.py /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-deccad69-db9d6340/tempworkdir2/src /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-deccad69-db9d6340/tempworkdir2/tests /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-deccad69-db9d6340/tempworkdir2 20  > __res
Running test command:
/home/ubuntu/spr-fast/tools/grep-test.py /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-deccad69-db9d6340/tempworkdir2/src /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-deccad69-db9d6340/tempworkdir2/tests /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-deccad69-db9d6340/tempworkdir2 22  > __res
Running test command:
/home/ubuntu/spr-fast/tools/grep-test.py /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-deccad69-db9d6340/tempworkdir2/src /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-deccad69-db9d6340/tempworkdir2/tests /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-deccad69-db9d6340/tempworkdir2 23  > __res
Running test command:
/home/ubuntu/spr-fast/tools/grep-test.py /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-deccad69-db9d6340/tempworkdir2/src /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-deccad69-db9d6340/tempworkdir2/tests /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-deccad69-db9d6340/tempworkdir2 25  > __res
Passed Positive Cases
Collect values for post processing!
WRITING TO ISNEG:/home/ubuntu/spr-fast/tests/corebench/grep/grep-case-deccad69-db9d6340/tempworkdir2/neg.tmp!
Running test command:
/home/ubuntu/spr-fast/tools/grep-test.py /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-deccad69-db9d6340/tempworkdir2/src /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-deccad69-db9d6340/tempworkdir2/tests /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-deccad69-db9d6340/tempworkdir2 0  > __res
Running test command:
/home/ubuntu/spr-fast/tools/grep-test.py /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-deccad69-db9d6340/tempworkdir2/src /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-deccad69-db9d6340/tempworkdir2/tests /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-deccad69-db9d6340/tempworkdir2 3  > __res
Running test command:
/home/ubuntu/spr-fast/tools/grep-test.py /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-deccad69-db9d6340/tempworkdir2/src /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-deccad69-db9d6340/tempworkdir2/tests /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-deccad69-db9d6340/tempworkdir2 4  > __res
Running test command:
/home/ubuntu/spr-fast/tools/grep-test.py /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-deccad69-db9d6340/tempworkdir2/src /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-deccad69-db9d6340/tempworkdir2/tests /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-deccad69-db9d6340/tempworkdir2 5  > __res
Running test command:
/home/ubuntu/spr-fast/tools/grep-test.py /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-deccad69-db9d6340/tempworkdir2/src /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-deccad69-db9d6340/tempworkdir2/tests /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-deccad69-db9d6340/tempworkdir2 6  > __res
Running test command:
/home/ubuntu/spr-fast/tools/grep-test.py /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-deccad69-db9d6340/tempworkdir2/src /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-deccad69-db9d6340/tempworkdir2/tests /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-deccad69-db9d6340/tempworkdir2 9  > __res
Running test command:
/home/ubuntu/spr-fast/tools/grep-test.py /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-deccad69-db9d6340/tempworkdir2/src /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-deccad69-db9d6340/tempworkdir2/tests /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-deccad69-db9d6340/tempworkdir2 11  > __res
Running test command:
/home/ubuntu/spr-fast/tools/grep-test.py /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-deccad69-db9d6340/tempworkdir2/src /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-deccad69-db9d6340/tempworkdir2/tests /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-deccad69-db9d6340/tempworkdir2 12  > __res
Running test command:
/home/ubuntu/spr-fast/tools/grep-test.py /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-deccad69-db9d6340/tempworkdir2/src /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-deccad69-db9d6340/tempworkdir2/tests /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-deccad69-db9d6340/tempworkdir2 13  > __res
Running test command:
/home/ubuntu/spr-fast/tools/grep-test.py /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-deccad69-db9d6340/tempworkdir2/src /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-deccad69-db9d6340/tempworkdir2/tests /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-deccad69-db9d6340/tempworkdir2 14  > __res
Running test command:
/home/ubuntu/spr-fast/tools/grep-test.py /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-deccad69-db9d6340/tempworkdir2/src /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-deccad69-db9d6340/tempworkdir2/tests /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-deccad69-db9d6340/tempworkdir2 15  > __res
Running test command:
/home/ubuntu/spr-fast/tools/grep-test.py /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-deccad69-db9d6340/tempworkdir2/src /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-deccad69-db9d6340/tempworkdir2/tests /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-deccad69-db9d6340/tempworkdir2 17  > __res
Running test command:
/home/ubuntu/spr-fast/tools/grep-test.py /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-deccad69-db9d6340/tempworkdir2/src /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-deccad69-db9d6340/tempworkdir2/tests /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-deccad69-db9d6340/tempworkdir2 18  > __res
Running test command:
/home/ubuntu/spr-fast/tools/grep-test.py /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-deccad69-db9d6340/tempworkdir2/src /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-deccad69-db9d6340/tempworkdir2/tests /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-deccad69-db9d6340/tempworkdir2 20  > __res
Running test command:
/home/ubuntu/spr-fast/tools/grep-test.py /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-deccad69-db9d6340/tempworkdir2/src /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-deccad69-db9d6340/tempworkdir2/tests /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-deccad69-db9d6340/tempworkdir2 22  > __res
Running test command:
/home/ubuntu/spr-fast/tools/grep-test.py /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-deccad69-db9d6340/tempworkdir2/src /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-deccad69-db9d6340/tempworkdir2/tests /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-deccad69-db9d6340/tempworkdir2 23  > __res
Running test command:
/home/ubuntu/spr-fast/tools/grep-test.py /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-deccad69-db9d6340/tempworkdir2/src /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-deccad69-db9d6340/tempworkdir2/tests /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-deccad69-db9d6340/tempworkdir2 25  > __res
Passed!
CondTester, Postprocessing instance id 22:
//src_file:src/search.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
/* search.c - searching subroutines using dfa, kwset and regex for grep.
   Copyright 1992, 1998, 2000, 2007, 2009-2010 Free Software Foundation, Inc.

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 3, or (at your option)
   any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program; if not, write to the Free Software
   Foundation, Inc., 51 Franklin Street - Fifth Floor, Boston, MA
   02110-1301, USA.  */

/* Written August 1992 by Mike Haertel. */

#include <config.h>

#include <sys/types.h>

#include "mbsupport.h"
#ifdef MBS_SUPPORT
/* We can handle multibyte strings. */
# include <wchar.h>
# include <wctype.h>
#endif

#include "system.h"
#include "grep.h"
#ifndef FGREP_PROGRAM
# include <regex.h>
# include "dfa.h"
#endif
#include "kwset.h"
#include "error.h"
#include "xalloc.h"
#ifdef HAVE_LIBPCRE
# include <pcre.h>
#endif

#define NCHAR (UCHAR_MAX + 1)

/* For -w, we also consider _ to be word constituent.  */
#define WCHAR(C) (ISALNUM(C) || (C) == '_')

/* KWset compiled pattern.  For Ecompile and Gcompile, we compile
   a list of strings, at least one of which is known to occur in
   any string matching the regexp. */
static kwset_t kwset;

static void
kwsinit (void)
{
  static char trans[NCHAR];
  int i;

  if (match_icase && MB_CUR_MAX == 1)
    {
      for (i = 0; i < NCHAR; ++i)
        trans[i] = TOLOWER (i);

      kwset = kwsalloc (trans);
    }
  else
    kwset = kwsalloc (NULL);

  if (!kwset)
    xalloc_die ();
}

#ifdef MBS_SUPPORT
/* Convert the *N-byte string, BEG, to lowercase, and write the
   NUL-terminated result into malloc'd storage.  Upon success, set *N
   to the length (in bytes) of the resulting string (not including the
   trailing NUL byte), and return a pointer to the lowercase string.
   Upon memory allocation failure, this function exits.

   Note that while this function returns a pointer to malloc'd storage,
   the caller must not free it, since this function retains a pointer
   to the buffer and reuses it on any subsequent call.  As a consequence,
   this function is not thread-safe.  */
static char *
mbtolower (const char *beg, size_t *n)
{
  static char *out;
  static size_t outalloc;
  size_t outlen, mb_cur_max;
  mbstate_t is, os;
  const char *end;
  char *p;

  if (*n > outalloc)
    {
      out = xrealloc (out, *n);
      outalloc = *n;
    }

  memset (&is, 0, sizeof (is));
  memset (&os, 0, sizeof (os));
  end = beg + *n;

  mb_cur_max = MB_CUR_MAX;
  p = out;
  outlen = 0;
  while (beg < end)
    {
      wchar_t wc;
      size_t mbclen = mbrtowc(&wc, beg, end - beg, &is);
      if (outlen + mb_cur_max >= outalloc)
        {
          out = x2nrealloc (out, &outalloc, 1);
          p = out + outlen;
        }

      if (mbclen == (size_t) -1 || mbclen == (size_t) -2 || mbclen == 0)
        {
          /* An invalid sequence, or a truncated multi-octet character.
             We treat it as a single-octet character.  */
          *p++ = *beg++;
          outlen++;
          memset (&is, 0, sizeof (is));
          memset (&os, 0, sizeof (os));
        }
      else
        {
          beg += mbclen;
          mbclen = wcrtomb (p, towlower ((wint_t) wc), &os);
          p += mbclen;
          outlen += mbclen;
        }
    }

  *n = p - out;
  *p++ = 0;
  return out;
}
#endif


#ifndef FGREP_PROGRAM
/* DFA compiled regexp. */
static struct dfa dfa;

/* The Regex compiled patterns.  */
static struct patterns
{
  /* Regex compiled regexp. */
  struct re_pattern_buffer regexbuf;
  struct re_registers regs; /* This is here on account of a BRAIN-DEAD
			       Q@#%!# library interface in regex.c.  */
} patterns0;

struct patterns *patterns;
size_t pcount;

void
dfaerror (char const *mesg)
{
  error (EXIT_TROUBLE, 0, "%s", mesg);
}

/* Number of compiled fixed strings known to exactly match the regexp.
   If kwsexec returns < kwset_exact_matches, then we don't need to
   call the regexp matcher at all. */
static int kwset_exact_matches;

static char const *
kwsincr_case (const char *must)
{
  const char *buf;
  size_t n;

  n = strlen (must);
#ifdef MBS_SUPPORT
  if (match_icase && MB_CUR_MAX > 1)
    buf = mbtolower (must, &n);
  else
#endif
    buf = must;
  return kwsincr (kwset, buf, n);
}

/* If the DFA turns out to have some set of fixed strings one of
   which must occur in the match, then we build a kwset matcher
   to find those strings, and thus quickly filter out impossible
   matches. */
static void
kwsmusts (void)
{
  struct dfamust const *dm;
  char const *err;

  if (dfa.musts)
    {
      kwsinit ();
      /* First, we compile in the substrings known to be exact
	 matches.  The kwset matcher will return the index
	 of the matching string that it chooses. */
      for (dm = dfa.musts; dm; dm = dm->next)
	{
	  if (!dm->exact)
	    continue;
	  ++kwset_exact_matches;
	  if ((err = kwsincr_case (dm->must)) != NULL)
	    error (EXIT_TROUBLE, 0, "%s", err);
	}
      /* Now, we compile the substrings that will require
	 the use of the regexp matcher.  */
      for (dm = dfa.musts; dm; dm = dm->next)
	{
	  if (dm->exact)
	    continue;
	  if ((err = kwsincr_case (dm->must)) != NULL)
	    error (EXIT_TROUBLE, 0, "%s", err);
	}
      if ((err = kwsprep (kwset)) != NULL)
	error (EXIT_TROUBLE, 0, "%s", err);
    }
}
#endif /* !FGREP_PROGRAM */

#ifdef MBS_SUPPORT

static bool
is_mb_middle(const char **good, const char *buf, const char *end)
{
  const char *p = *good;
  const char *prev = p;
  mbstate_t cur_state;

  /* TODO: can be optimized for UTF-8.  */
  memset(&cur_state, 0, sizeof(mbstate_t));
  while (p < buf)
    {
      size_t mbclen = mbrlen(p, end - p, &cur_state);

      /* Store the beginning of the previous complete multibyte character.  */
      if (mbclen != (size_t) -2)
        prev = p;

      if (mbclen == (size_t) -1 || mbclen == (size_t) -2 || mbclen == 0)
	{
	  /* An invalid sequence, or a truncated multibyte character.
	     We treat it as a single byte character.  */
	  mbclen = 1;
	}
      p += mbclen;
    }

  *good = prev;
  return p > buf;
}
#endif /* MBS_SUPPORT */

#if defined(GREP_PROGRAM) || defined(EGREP_PROGRAM)
#ifdef EGREP_PROGRAM
COMPILE_FCT(Ecompile)
{
  reg_syntax_t syntax_bits = RE_SYNTAX_POSIX_EGREP;
#else
/* No __VA_ARGS__ in C89.  So we have to do it this way.  */
static COMPILE_RET
GEAcompile (char const *pattern, size_t size, reg_syntax_t syntax_bits)
{
#endif /* EGREP_PROGRAM */
  const char *err;
  const char *p, *sep;
  size_t total = size;
  char *motif;

  if (match_icase)
    syntax_bits |= RE_ICASE;
  re_set_syntax (syntax_bits);
  dfasyntax (syntax_bits, match_icase, eolbyte);

  /* For GNU regex compiler we have to pass the patterns separately to detect
     errors like "[\nallo\n]\n".  The patterns here are "[", "allo" and "]"
     GNU regex should have raise a syntax error.  The same for backref, where
     the backref should have been local to each pattern.  */
  p = pattern;
  do
    {
      size_t len;
      sep = memchr (p, '\n', total);
      if (sep)
	{
	  len = sep - p;
	  sep++;
	  total -= (len + 1);
	}
      else
	{
	  len = total;
	  total = 0;
	}

      patterns = realloc (patterns, (pcount + 1) * sizeof (*patterns));
      if (patterns == NULL)
	error (EXIT_TROUBLE, errno, _("memory exhausted"));
      patterns[pcount] = patterns0;

      if ((err = re_compile_pattern (p, len,
				    &(patterns[pcount].regexbuf))) != NULL)
	error (EXIT_TROUBLE, 0, "%s", err);
      pcount++;

      p = sep;
    } while (sep && total != 0);

  /* In the match_words and match_lines cases, we use a different pattern
     for the DFA matcher that will quickly throw out cases that won't work.
     Then if DFA succeeds we do some hairy stuff using the regex matcher
     to decide whether the match should really count. */
  if (match_words || match_lines)
    {
      static char const line_beg_no_bk[] = "^(";
      static char const line_end_no_bk[] = ")$";
      static char const word_beg_no_bk[] = "(^|[^[:alnum:]_])(";
      static char const word_end_no_bk[] = ")([^[:alnum:]_]|$)";
#ifdef EGREP_PROGRAM
# define IF_BK(x, y) (y)
      char *n = xmalloc (sizeof word_beg_no_bk - 1 + size + sizeof word_end_no_bk);
#else
      static char const line_beg_bk[] = "^\\(";
      static char const line_end_bk[] = "\\)$";
      static char const word_beg_bk[] = "\\(^\\|[^[:alnum:]_]\\)\\(";
      static char const word_end_bk[] = "\\)\\([^[:alnum:]_]\\|$\\)";
      int bk = !(syntax_bits & RE_NO_BK_PARENS);
# define IF_BK(x, y) ((bk) ? (x) : (y))
      char *n = xmalloc (sizeof word_beg_bk - 1 + size + sizeof word_end_bk);
#endif /* EGREP_PROGRAM */

      strcpy (n, match_lines ? IF_BK(line_beg_bk, line_beg_no_bk)
			     : IF_BK(word_beg_bk, word_beg_no_bk));
      total = strlen(n);
      memcpy (n + total, pattern, size);
      total += size;
      strcpy (n + total, match_lines ? IF_BK(line_end_bk, line_end_no_bk)
				     : IF_BK(word_end_bk, word_end_no_bk));
      total += strlen (n + total);
      pattern = motif = n;
      size = total;
    }
  else
    motif = NULL;

  dfacomp (pattern, size, &dfa, 1);
  kwsmusts ();

  free(motif);
}

#ifndef EGREP_PROGRAM
COMPILE_FCT(Gcompile)
{
  return GEAcompile (pattern, size,
		     RE_SYNTAX_GREP | RE_HAT_LISTS_NOT_NEWLINE);
}

COMPILE_FCT(Acompile)
{
  return GEAcompile (pattern, size, RE_SYNTAX_AWK);
}

COMPILE_FCT(Ecompile)
{
  return GEAcompile (pattern, size, RE_SYNTAX_POSIX_EGREP);
}
#endif /* !EGREP_PROGRAM */

EXECUTE_FCT(EGexecute)
{
  char const *buflim, *beg, *end, *match, *best_match, *mb_start;
  char eol = eolbyte;
  int backref, start, len, best_len;
  struct kwsmatch kwsm;
  size_t i, ret_val;
#ifdef MBS_SUPPORT
  if (MB_CUR_MAX > 1)
    {
      if (match_icase)
        {
          /* mbtolower adds a NUL byte at the end.  That will provide
	     space for the sentinel byte dfaexec may add.  */
          char *case_buf = mbtolower (buf, &size);
	  if (start_ptr)
	    start_ptr = case_buf + (start_ptr - buf);
          buf = case_buf;
        }
    }
#endif /* MBS_SUPPORT */

  mb_start = buf;
  buflim = buf + size;

  for (beg = end = buf; end < buflim; beg = end)
    {
      if (!start_ptr)
	{
	  /* We don't care about an exact match.  */
	  if (kwset)
	    {
	      /* Find a possible match using the KWset matcher. */
	      size_t offset = kwsexec (kwset, beg, buflim - beg, &kwsm);
	      if (offset == (size_t) -1)
		goto failure;
	      beg += offset;
	      /* Narrow down to the line containing the candidate, and
		 run it through DFA. */
	      if ((end = memchr(beg, eol, buflim - beg)) != NULL)
	        end++;
              else
                end = buflim;
	      match = beg;
	      while (beg > buf && beg[-1] != eol)
		--beg;
	      if (kwsm.index < kwset_exact_matches)
                {
#ifdef MBS_SUPPORT
                  if (mb_start < beg)
                    mb_start = beg;
                  if (MB_CUR_MAX == 1 || !is_mb_middle (&mb_start, match, buflim))
#endif
                    goto success;
                }
	      if (dfaexec (&dfa, beg, (char *) end, 0, NULL, &backref) == NULL)
		continue;
	    }
	  else
	    {
	      /* No good fixed strings; start with DFA. */
	      char const *next_beg = dfaexec (&dfa, beg, (char *) buflim,
					      0, NULL, &backref);
	      if (next_beg == NULL)
		break;
	      /* Narrow down to the line we've found. */
	      beg = next_beg;
	      if ((end = memchr(beg, eol, buflim - beg)) != NULL)
	        end++;
              else
                end = buflim;
	      while (beg > buf && beg[-1] != eol)
		--beg;
	    }
	  /* Successful, no backreferences encountered! */
	  if (!backref)
	    goto success;
	}
      else
	{
	  /* We are looking for the leftmost (then longest) exact match.
	     We will go through the outer loop only once.  */
	  beg = start_ptr;
	  end = buflim;
	}

      /* If we've made it to this point, this means DFA has seen
	 a probable match, and we need to run it through Regex. */
      best_match = end;
      best_len = 0;
      for (i = 0; i < pcount; i++)
	{
	  patterns[i].regexbuf.not_eol = 0;
	  if (0 <= (start = re_search (&(patterns[i].regexbuf),
				       buf, end - buf - 1,
				       beg - buf, end - beg - 1,
				       &(patterns[i].regs))))
	    {
	      len = patterns[i].regs.end[0] - start;
	      match = buf + start;
	      if (match > best_match)
		continue;
	      if (start_ptr && !match_words)
		goto assess_pattern_match;
	      if ((!match_lines && !match_words)
		  || (match_lines && len == end - beg - 1))
		{
		  match = beg;
		  len = end - beg;
		  goto assess_pattern_match;
		}
	      /* If -w, check if the match aligns with word boundaries.
		 We do this iteratively because:
		 (a) the line may contain more than one occurence of the
		 pattern, and
		 (b) Several alternatives in the pattern might be valid at a
		 given point, and we may need to consider a shorter one to
		 find a word boundary.  */
	      if (match_words)
		while (match <= best_match)
		  {
		    if ((match == buf || !WCHAR ((unsigned char) match[-1]))
			&& (len == end - beg - 1
			    || !WCHAR ((unsigned char) match[len])))
		      goto assess_pattern_match;
		    if (len > 0)
		      {
			/* Try a shorter length anchored at the same place. */
			--len;
			patterns[i].regexbuf.not_eol = 1;
			len = re_match (&(patterns[i].regexbuf),
					buf, match + len - beg, match - buf,
					&(patterns[i].regs));
		      }
		    if (len <= 0)
		      {
			/* Try looking further on. */
			if (match == end - 1)
			  break;
			match++;
			patterns[i].regexbuf.not_eol = 0;
			start = re_search (&(patterns[i].regexbuf),
					   buf, end - buf - 1,
					   match - buf, end - match - 1,
					   &(patterns[i].regs));
			if (start < 0)
			  break;
			len = patterns[i].regs.end[0] - start;
			match = buf + start;
		      }
		  } /* while (match <= best_match) */
	      continue;
	    assess_pattern_match:
	      if (!start_ptr)
		{
		  /* Good enough for a non-exact match.
		     No need to look at further patterns, if any.  */
		  beg = match;
		  goto success_in_len;
		}
	      if (match < best_match || (match == best_match && len > best_len))
		{
		  /* Best exact match:  leftmost, then longest.  */
		  best_match = match;
		  best_len = len;
		}
	    } /* if re_search >= 0 */
	} /* for Regex patterns.  */
	if (best_match < end)
	  {
	    /* We have found an exact match.  We were just
	       waiting for the best one (leftmost then longest).  */
	    beg = best_match;
	    len = best_len;
	    goto success_in_len;
	  }
    } /* for (beg = end ..) */

 failure:
  ret_val = -1;
  goto out;

 success:
  len = end - beg;
 success_in_len:
  *match_size = len;
  ret_val = beg - buf;
 out:
  return ret_val;
}
#endif /* defined(GREP_PROGRAM) || defined(EGREP_PROGRAM) */

#if defined(GREP_PROGRAM) || defined(FGREP_PROGRAM)
COMPILE_FCT(Fcompile)
{
  char const *beg, *end, *lim, *err, *pat;
  size_t psize;

  kwsinit ();
  psize = size;
  if (match_icase && MB_CUR_MAX > 1)
    pat = mbtolower (pattern, &psize);
  else
    pat = pattern;

  beg = pat;
  do
    {
      for (lim = beg;; ++lim)
	{
	  end = lim;
	  if (lim >= pat + psize)
	    break;
	 if (*lim == '\n')
	   {
	     lim++;
	     break;
	   }
#if HAVE_DOS_FILE_CONTENTS
	 if (*lim == '\r' && lim + 1 < pat + psize && lim[1] == '\n')
	   {
	     lim += 2;
	     break;
	   }
#endif
	}

      if ((err = kwsincr (kwset, beg, end - beg)) != NULL)
	error (EXIT_TROUBLE, 0, "%s", err);
      beg = lim;
    }
  while (beg < pat + psize);

  if ((err = kwsprep (kwset)) != NULL)
    error (EXIT_TROUBLE, 0, "%s", err);
}

EXECUTE_FCT(Fexecute)
{
  char const *beg, *try, *end, *mb_start;
  size_t len;
  char eol = eolbyte;
  struct kwsmatch kwsmatch;
  size_t ret_val;
#ifdef MBS_SUPPORT
  if (MB_CUR_MAX > 1)
    {
      if (match_icase)
        {
          char *case_buf = mbtolower (buf, &size);
	  if (start_ptr)
	    start_ptr = case_buf + (start_ptr - buf);
          buf = case_buf;
        }
    }
#endif /* MBS_SUPPORT */

  for (mb_start = beg = start_ptr ? start_ptr : buf; beg <= buf + size; beg++)
    {
      size_t offset = kwsexec (kwset, beg, buf + size - beg, &kwsmatch);
      
//Patch 0:
if ((offset == (size_t)-1) || (__is_neg(18, &(offset), sizeof (offset), &(buf), sizeof (buf), &(size), sizeof (size), &(beg), sizeof (beg), &(kwset), sizeof (kwset), &(start_ptr), sizeof (start_ptr), &(mb_start), sizeof (mb_start), &(len), sizeof (len), &(match_words), sizeof (match_words), &(match_icase), sizeof (match_icase), &(match_lines), sizeof (match_lines), &(eol), sizeof (eol), &(eolbyte), sizeof (eolbyte), &(try), sizeof (try), &(ret_val), sizeof (ret_val), &(end), sizeof (end), &(match_size), sizeof (match_size), &(kwsmatch.index), sizeof (kwsmatch.index))))
    goto failure;

//CodeSeg 1:
#ifdef MBS_SUPPORT
      if (MB_CUR_MAX > 1 && is_mb_middle (&mb_start, beg + offset, buf + size))
        {
          beg = mb_start - 1;
          continue; /* It is a part of multibyte character.  */
        }
#endif /* MBS_SUPPORT */
      beg += offset;
      len = kwsmatch.size[0];
      if (start_ptr && !match_words)
	goto success_in_beg_and_len;
      if (match_lines)
	{
	  if (beg > buf && beg[-1] != eol)
	    continue;
	  if (beg + len < buf + size && beg[len] != eol)
	    continue;
	  goto success;
	}
      else if (match_words)
	for (try = beg; len; )
	  {
	    if (try > buf && WCHAR((unsigned char) try[-1]))
	      break;
	    if (try + len < buf + size && WCHAR((unsigned char) try[len]))
	      {
		offset = kwsexec (kwset, beg, --len, &kwsmatch);
		if (offset == (size_t) -1)
		  break;
		try = beg + offset;
		len = kwsmatch.size[0];
	      }
	    else if (!start_ptr)
	      goto success;
	    else
	      goto success_in_beg_and_len;
	  } /* for (try) */
      else
	goto success;
    } /* for (beg in buf) */

 failure:
  ret_val = -1;
  goto out;

 success:
  if ((end = memchr (beg + len, eol, (buf + size) - (beg + len))) != NULL)
    end++;
  else
    end = buf + size;
  while (buf < beg && beg[-1] != eol)
    --beg;
  len = end - beg;
 success_in_beg_and_len:
  *match_size = len;
  ret_val = beg - buf;
 out:
  return ret_val;
}
#endif /* defined(GREP_PROGRAM) || defined(FGREP_PROGRAM) */

#ifdef GREP_PROGRAM
#if HAVE_LIBPCRE
/* Compiled internal form of a Perl regular expression.  */
static pcre *cre;

/* Additional information about the pattern.  */
static pcre_extra *extra;
#endif

COMPILE_FCT(Pcompile)
{
#if !HAVE_LIBPCRE
  error (EXIT_TROUBLE, 0, "%s",
	 _("support for the -P option is not compiled into "
	   "this --disable-perl-regexp binary"));
#else
  int e;
  char const *ep;
  char *re = xmalloc (4 * size + 7);
  int flags = PCRE_MULTILINE | (match_icase ? PCRE_CASELESS : 0);
  char const *patlim = pattern + size;
  char *n = re;
  char const *p;
  char const *pnul;

  /* FIXME: Remove these restrictions.  */
  if (memchr(pattern, '\n', size))
    error (EXIT_TROUBLE, 0, _("the -P option only supports a single pattern"));

  *n = '\0';
  if (match_lines)
    strcpy (n, "^(");
  if (match_words)
    strcpy (n, "\\b(");
  n += strlen (n);

  /* The PCRE interface doesn't allow NUL bytes in the pattern, so
     replace each NUL byte in the pattern with the four characters
     "\000", removing a preceding backslash if there are an odd
     number of backslashes before the NUL.

     FIXME: This method does not work with some multibyte character
     encodings, notably Shift-JIS, where a multibyte character can end
     in a backslash byte.  */
  for (p = pattern; (pnul = memchr (p, '\0', patlim - p)); p = pnul + 1)
    {
      memcpy (n, p, pnul - p);
      n += pnul - p;
      for (p = pnul; pattern < p && p[-1] == '\\'; p--)
	continue;
      n -= (pnul - p) & 1;
      strcpy (n, "\\000");
      n += 4;
    }

  memcpy (n, p, patlim - p);
  n += patlim - p;
  *n = '\0';
  if (match_words)
    strcpy (n, ")\\b");
  if (match_lines)
    strcpy (n, ")$");

  cre = pcre_compile (re, flags, &ep, &e, pcre_maketables ());
  if (!cre)
    error (EXIT_TROUBLE, 0, "%s", ep);

  extra = pcre_study (cre, 0, &ep);
  if (ep)
    error (EXIT_TROUBLE, 0, "%s", ep);

  free (re);
#endif
}

EXECUTE_FCT(Pexecute)
{
#if !HAVE_LIBPCRE
  abort ();
  return -1;
#else
  /* This array must have at least two elements; everything after that
     is just for performance improvement in pcre_exec.  */
  int sub[300];

  const char *line_buf, *line_end, *line_next;
  int e = PCRE_ERROR_NOMATCH;
  ptrdiff_t start_ofs = start_ptr ? start_ptr - buf : 0;

  /* PCRE can't limit the matching to single lines, therefore we have to
     match each line in the buffer separately.  */
  for (line_next = buf;
       e == PCRE_ERROR_NOMATCH && line_next < buf + size;
       start_ofs -= line_next - line_buf)
    {
      line_buf = line_next;
      line_end = memchr (line_buf, eolbyte, (buf + size) - line_buf);
      if (line_end == NULL)
        line_next = line_end = buf + size;
      else
        line_next = line_end + 1;

      if (start_ptr && start_ptr >= line_end)
        continue;

      e = pcre_exec (cre, extra, line_buf, line_end - line_buf,
                     start_ofs < 0 ? 0 : start_ofs, 0,
                     sub, sizeof sub / sizeof *sub);
    }

  if (e <= 0)
    {
      switch (e)
	{
	case PCRE_ERROR_NOMATCH:
	  return -1;

	case PCRE_ERROR_NOMEMORY:
	  error (EXIT_TROUBLE, 0, _("memory exhausted"));

	default:
	  abort ();
	}
    }
  else
    {
      /* Narrow down to the line we've found.  */
      char const *beg = line_buf + sub[0];
      char const *end = line_buf + sub[1];
      char const *buflim = buf + size;
      char eol = eolbyte;
      if (!start_ptr)
	{
	  /* FIXME: The case when '\n' is not found indicates a bug:
	     Since grep is line oriented, the match should never contain
	     a newline, so there _must_ be a newline following.
	   */
	  if (!(end = memchr (end, eol, buflim - end)))
	    end = buflim;
	  else
	    end++;
	  while (buf < beg && beg[-1] != eol)
	    --beg;
	}

      *match_size = end - beg;
      return beg - buf;
    }
#endif
}

struct matcher const matchers[] = {
  { "default", Gcompile, EGexecute },
  { "grep",    Gcompile, EGexecute },
  { "egrep",   Ecompile, EGexecute },
  { "awk",     Acompile, EGexecute },
  { "fgrep",   Fcompile, Fexecute },
  { "perl",    Pcompile, Pexecute },
  { "", 0, 0 },
};
#endif /* GREP_PROGRAM */

Trying a synthesis expr 1
Skipping a synthesis:1
Trying a synthesis expr start_ptr == 0
Building:src at:
/home/ubuntu/spr-fast/tests/corebench/grep/grep-case-deccad69-db9d6340/tempworkdir2/srcVerifing Negative cases!
Running test command:
/home/ubuntu/spr-fast/tools/grep-test.py /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-deccad69-db9d6340/tempworkdir2/src /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-deccad69-db9d6340/tempworkdir2/tests /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-deccad69-db9d6340/tempworkdir2 0  > __res
Verifying positive cases
Running test command:
/home/ubuntu/spr-fast/tools/grep-test.py /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-deccad69-db9d6340/tempworkdir2/src /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-deccad69-db9d6340/tempworkdir2/tests /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-deccad69-db9d6340/tempworkdir2 9  > __res
Failed positive case 9
Not passed!
Trying a synthesis expr match_words == 0
Building:src at:
/home/ubuntu/spr-fast/tests/corebench/grep/grep-case-deccad69-db9d6340/tempworkdir2/srcVerifing Negative cases!
Running test command:
/home/ubuntu/spr-fast/tools/grep-test.py /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-deccad69-db9d6340/tempworkdir2/src /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-deccad69-db9d6340/tempworkdir2/tests /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-deccad69-db9d6340/tempworkdir2 0  > __res
Verifying positive cases
Running test command:
/home/ubuntu/spr-fast/tools/grep-test.py /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-deccad69-db9d6340/tempworkdir2/src /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-deccad69-db9d6340/tempworkdir2/tests /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-deccad69-db9d6340/tempworkdir2 9  > __res
Running test command:
/home/ubuntu/spr-fast/tools/grep-test.py /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-deccad69-db9d6340/tempworkdir2/src /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-deccad69-db9d6340/tempworkdir2/tests /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-deccad69-db9d6340/tempworkdir2 12  > __res
Failed positive case 12
Not passed!
Trying a synthesis expr match_icase == 0
Building:src at:
/home/ubuntu/spr-fast/tests/corebench/grep/grep-case-deccad69-db9d6340/tempworkdir2/srcVerifing Negative cases!
Running test command:
/home/ubuntu/spr-fast/tools/grep-test.py /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-deccad69-db9d6340/tempworkdir2/src /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-deccad69-db9d6340/tempworkdir2/tests /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-deccad69-db9d6340/tempworkdir2 0  > __res
Verifying positive cases
Running test command:
/home/ubuntu/spr-fast/tools/grep-test.py /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-deccad69-db9d6340/tempworkdir2/src /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-deccad69-db9d6340/tempworkdir2/tests /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-deccad69-db9d6340/tempworkdir2 9  > __res
Failed positive case 9
Not passed!
Trying a synthesis expr match_lines == 0
Building:src at:
/home/ubuntu/spr-fast/tests/corebench/grep/grep-case-deccad69-db9d6340/tempworkdir2/srcVerifing Negative cases!
Running test command:
/home/ubuntu/spr-fast/tools/grep-test.py /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-deccad69-db9d6340/tempworkdir2/src /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-deccad69-db9d6340/tempworkdir2/tests /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-deccad69-db9d6340/tempworkdir2 0  > __res
Verifying positive cases
Running test command:
/home/ubuntu/spr-fast/tools/grep-test.py /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-deccad69-db9d6340/tempworkdir2/src /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-deccad69-db9d6340/tempworkdir2/tests /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-deccad69-db9d6340/tempworkdir2 9  > __res
Failed positive case 9
Not passed!
Trying a synthesis expr ret_val == 0
Building:src at:
/home/ubuntu/spr-fast/tests/corebench/grep/grep-case-deccad69-db9d6340/tempworkdir2/srcVerifing Negative cases!
Running test command:
/home/ubuntu/spr-fast/tools/grep-test.py /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-deccad69-db9d6340/tempworkdir2/src /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-deccad69-db9d6340/tempworkdir2/tests /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-deccad69-db9d6340/tempworkdir2 0  > __res
Verifying positive cases
Running test command:
/home/ubuntu/spr-fast/tools/grep-test.py /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-deccad69-db9d6340/tempworkdir2/src /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-deccad69-db9d6340/tempworkdir2/tests /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-deccad69-db9d6340/tempworkdir2 9  > __res
Failed positive case 9
Not passed!
Trying a synthesis expr kwsmatch.index == 0
Building:src at:
/home/ubuntu/spr-fast/tests/corebench/grep/grep-case-deccad69-db9d6340/tempworkdir2/srcVerifing Negative cases!
Running test command:
/home/ubuntu/spr-fast/tools/grep-test.py /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-deccad69-db9d6340/tempworkdir2/src /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-deccad69-db9d6340/tempworkdir2/tests /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-deccad69-db9d6340/tempworkdir2 0  > __res
Verifying positive cases
Running test command:
/home/ubuntu/spr-fast/tools/grep-test.py /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-deccad69-db9d6340/tempworkdir2/src /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-deccad69-db9d6340/tempworkdir2/tests /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-deccad69-db9d6340/tempworkdir2 9  > __res
Failed positive case 9
Not passed!
Trying a synthesis expr offset != 0
Building:src at:
/home/ubuntu/spr-fast/tests/corebench/grep/grep-case-deccad69-db9d6340/tempworkdir2/srcVerifing Negative cases!
Running test command:
/home/ubuntu/spr-fast/tools/grep-test.py /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-deccad69-db9d6340/tempworkdir2/src /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-deccad69-db9d6340/tempworkdir2/tests /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-deccad69-db9d6340/tempworkdir2 0  > __res
Verifying positive cases
Running test command:
/home/ubuntu/spr-fast/tools/grep-test.py /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-deccad69-db9d6340/tempworkdir2/src /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-deccad69-db9d6340/tempworkdir2/tests /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-deccad69-db9d6340/tempworkdir2 9  > __res
Failed positive case 9
Not passed!
Trying a synthesis expr len == 4
Building:src at:
/home/ubuntu/spr-fast/tests/corebench/grep/grep-case-deccad69-db9d6340/tempworkdir2/srcVerifing Negative cases!
Running test command:
/home/ubuntu/spr-fast/tools/grep-test.py /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-deccad69-db9d6340/tempworkdir2/src /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-deccad69-db9d6340/tempworkdir2/tests /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-deccad69-db9d6340/tempworkdir2 0  > __res
Not passed!
Trying a synthesis expr offset == 1
Building:src at:
/home/ubuntu/spr-fast/tests/corebench/grep/grep-case-deccad69-db9d6340/tempworkdir2/srcVerifing Negative cases!
Running test command:
/home/ubuntu/spr-fast/tools/grep-test.py /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-deccad69-db9d6340/tempworkdir2/src /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-deccad69-db9d6340/tempworkdir2/tests /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-deccad69-db9d6340/tempworkdir2 0  > __res
Verifying positive cases
Running test command:
/home/ubuntu/spr-fast/tools/grep-test.py /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-deccad69-db9d6340/tempworkdir2/src /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-deccad69-db9d6340/tempworkdir2/tests /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-deccad69-db9d6340/tempworkdir2 9  > __res
Running test command:
/home/ubuntu/spr-fast/tools/grep-test.py /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-deccad69-db9d6340/tempworkdir2/src /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-deccad69-db9d6340/tempworkdir2/tests /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-deccad69-db9d6340/tempworkdir2 12  > __res
Failed positive case 12
Not passed!
Trying a synthesis expr size == 4
Building:src at:
/home/ubuntu/spr-fast/tests/corebench/grep/grep-case-deccad69-db9d6340/tempworkdir2/srcVerifing Negative cases!
Running test command:
/home/ubuntu/spr-fast/tools/grep-test.py /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-deccad69-db9d6340/tempworkdir2/src /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-deccad69-db9d6340/tempworkdir2/tests /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-deccad69-db9d6340/tempworkdir2 0  > __res
Verifying positive cases
Running test command:
/home/ubuntu/spr-fast/tools/grep-test.py /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-deccad69-db9d6340/tempworkdir2/src /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-deccad69-db9d6340/tempworkdir2/tests /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-deccad69-db9d6340/tempworkdir2 9  > __res
Running test command:
/home/ubuntu/spr-fast/tools/grep-test.py /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-deccad69-db9d6340/tempworkdir2/src /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-deccad69-db9d6340/tempworkdir2/tests /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-deccad69-db9d6340/tempworkdir2 12  > __res
Failed positive case 12
Not passed!
Trying a synthesis expr eol == 10
Building:src at:
/home/ubuntu/spr-fast/tests/corebench/grep/grep-case-deccad69-db9d6340/tempworkdir2/srcVerifing Negative cases!
Running test command:
/home/ubuntu/spr-fast/tools/grep-test.py /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-deccad69-db9d6340/tempworkdir2/src /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-deccad69-db9d6340/tempworkdir2/tests /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-deccad69-db9d6340/tempworkdir2 0  > __res
Verifying positive cases
Running test command:
/home/ubuntu/spr-fast/tools/grep-test.py /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-deccad69-db9d6340/tempworkdir2/src /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-deccad69-db9d6340/tempworkdir2/tests /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-deccad69-db9d6340/tempworkdir2 9  > __res
Failed positive case 9
Not passed!
Trying a synthesis expr eolbyte == 10
Building:src at:
/home/ubuntu/spr-fast/tests/corebench/grep/grep-case-deccad69-db9d6340/tempworkdir2/srcVerifing Negative cases!
Running test command:
/home/ubuntu/spr-fast/tools/grep-test.py /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-deccad69-db9d6340/tempworkdir2/src /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-deccad69-db9d6340/tempworkdir2/tests /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-deccad69-db9d6340/tempworkdir2 0  > __res
Verifying positive cases
Running test command:
/home/ubuntu/spr-fast/tools/grep-test.py /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-deccad69-db9d6340/tempworkdir2/src /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-deccad69-db9d6340/tempworkdir2/tests /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-deccad69-db9d6340/tempworkdir2 9  > __res
Failed positive case 9
Not passed!
Trying a synthesis expr offset != 2
Building:src at:
/home/ubuntu/spr-fast/tests/corebench/grep/grep-case-deccad69-db9d6340/tempworkdir2/srcVerifing Negative cases!
Running test command:
/home/ubuntu/spr-fast/tools/grep-test.py /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-deccad69-db9d6340/tempworkdir2/src /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-deccad69-db9d6340/tempworkdir2/tests /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-deccad69-db9d6340/tempworkdir2 0  > __res
Verifying positive cases
Running test command:
/home/ubuntu/spr-fast/tools/grep-test.py /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-deccad69-db9d6340/tempworkdir2/src /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-deccad69-db9d6340/tempworkdir2/tests /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-deccad69-db9d6340/tempworkdir2 9  > __res
Failed positive case 9
Not passed!
Trying a synthesis expr offset != 3
Building:src at:
/home/ubuntu/spr-fast/tests/corebench/grep/grep-case-deccad69-db9d6340/tempworkdir2/srcVerifing Negative cases!
Running test command:
/home/ubuntu/spr-fast/tools/grep-test.py /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-deccad69-db9d6340/tempworkdir2/src /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-deccad69-db9d6340/tempworkdir2/tests /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-deccad69-db9d6340/tempworkdir2 0  > __res
Verifying positive cases
Running test command:
/home/ubuntu/spr-fast/tools/grep-test.py /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-deccad69-db9d6340/tempworkdir2/src /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-deccad69-db9d6340/tempworkdir2/tests /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-deccad69-db9d6340/tempworkdir2 9  > __res
Failed positive case 9
Not passed!
Trying a synthesis expr offset != 4
Building:src at:
/home/ubuntu/spr-fast/tests/corebench/grep/grep-case-deccad69-db9d6340/tempworkdir2/srcVerifing Negative cases!
Running test command:
/home/ubuntu/spr-fast/tools/grep-test.py /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-deccad69-db9d6340/tempworkdir2/src /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-deccad69-db9d6340/tempworkdir2/tests /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-deccad69-db9d6340/tempworkdir2 0  > __res
Verifying positive cases
Running test command:
/home/ubuntu/spr-fast/tools/grep-test.py /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-deccad69-db9d6340/tempworkdir2/src /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-deccad69-db9d6340/tempworkdir2/tests /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-deccad69-db9d6340/tempworkdir2 9  > __res
Failed positive case 9
Not passed!
Trying a synthesis expr offset != 5
Building:src at:
/home/ubuntu/spr-fast/tests/corebench/grep/grep-case-deccad69-db9d6340/tempworkdir2/srcVerifing Negative cases!
Running test command:
/home/ubuntu/spr-fast/tools/grep-test.py /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-deccad69-db9d6340/tempworkdir2/src /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-deccad69-db9d6340/tempworkdir2/tests /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-deccad69-db9d6340/tempworkdir2 0  > __res
Verifying positive cases
Running test command:
/home/ubuntu/spr-fast/tools/grep-test.py /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-deccad69-db9d6340/tempworkdir2/src /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-deccad69-db9d6340/tempworkdir2/tests /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-deccad69-db9d6340/tempworkdir2 9  > __res
Failed positive case 9
Not passed!
Trying a synthesis expr offset != 6
Building:src at:
/home/ubuntu/spr-fast/tests/corebench/grep/grep-case-deccad69-db9d6340/tempworkdir2/srcVerifing Negative cases!
Running test command:
/home/ubuntu/spr-fast/tools/grep-test.py /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-deccad69-db9d6340/tempworkdir2/src /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-deccad69-db9d6340/tempworkdir2/tests /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-deccad69-db9d6340/tempworkdir2 0  > __res
Verifying positive cases
Running test command:
/home/ubuntu/spr-fast/tools/grep-test.py /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-deccad69-db9d6340/tempworkdir2/src /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-deccad69-db9d6340/tempworkdir2/tests /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-deccad69-db9d6340/tempworkdir2 9  > __res
Failed positive case 9
Not passed!
Trying a synthesis expr size != 2
Building:src at:
/home/ubuntu/spr-fast/tests/corebench/grep/grep-case-deccad69-db9d6340/tempworkdir2/srcVerifing Negative cases!
Running test command:
/home/ubuntu/spr-fast/tools/grep-test.py /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-deccad69-db9d6340/tempworkdir2/src /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-deccad69-db9d6340/tempworkdir2/tests /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-deccad69-db9d6340/tempworkdir2 0  > __res
Verifying positive cases
Running test command:
/home/ubuntu/spr-fast/tools/grep-test.py /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-deccad69-db9d6340/tempworkdir2/src /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-deccad69-db9d6340/tempworkdir2/tests /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-deccad69-db9d6340/tempworkdir2 9  > __res
Failed positive case 9
Not passed!
Trying a synthesis expr size != 5
Building:src at:
/home/ubuntu/spr-fast/tests/corebench/grep/grep-case-deccad69-db9d6340/tempworkdir2/srcVerifing Negative cases!
Running test command:
/home/ubuntu/spr-fast/tools/grep-test.py /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-deccad69-db9d6340/tempworkdir2/src /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-deccad69-db9d6340/tempworkdir2/tests /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-deccad69-db9d6340/tempworkdir2 0  > __res
Verifying positive cases
Running test command:
/home/ubuntu/spr-fast/tools/grep-test.py /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-deccad69-db9d6340/tempworkdir2/src /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-deccad69-db9d6340/tempworkdir2/tests /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-deccad69-db9d6340/tempworkdir2 9  > __res
Failed positive case 9
Not passed!
Trying a synthesis expr size != 7
Building:src at:
/home/ubuntu/spr-fast/tests/corebench/grep/grep-case-deccad69-db9d6340/tempworkdir2/srcVerifing Negative cases!
Running test command:
/home/ubuntu/spr-fast/tools/grep-test.py /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-deccad69-db9d6340/tempworkdir2/src /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-deccad69-db9d6340/tempworkdir2/tests /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-deccad69-db9d6340/tempworkdir2 0  > __res
Verifying positive cases
Running test command:
/home/ubuntu/spr-fast/tools/grep-test.py /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-deccad69-db9d6340/tempworkdir2/src /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-deccad69-db9d6340/tempworkdir2/tests /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-deccad69-db9d6340/tempworkdir2 9  > __res
Failed positive case 9
Not passed!
Initial synthesize failed, final attempt
Skipping two clauses!(1) &&(0)
Found a clause! (offset == (size_t)-1) 
Skipping a clause! (offset == (size_t)-1) 
Postprocessing failed!
a batched test job starts!
Building merged code:
src_file: src/search.c
full src: int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
/* search.c - searching subroutines using dfa, kwset and regex for grep.
   Copyright 1992, 1998, 2000, 2007, 2009-2010 Free Software Foundation, Inc.

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 3, or (at your option)
   any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program; if not, write to the Free Software
   Foundation, Inc., 51 Franklin Street - Fifth Floor, Boston, MA
   02110-1301, USA.  */

/* Written August 1992 by Mike Haertel. */

#include <config.h>

#include <sys/types.h>

#include "mbsupport.h"
#ifdef MBS_SUPPORT
/* We can handle multibyte strings. */
# include <wchar.h>
# include <wctype.h>
#endif

#include "system.h"
#include "grep.h"
#ifndef FGREP_PROGRAM
# include <regex.h>
# include "dfa.h"
#endif
#include "kwset.h"
#include "error.h"
#include "xalloc.h"
#ifdef HAVE_LIBPCRE
# include <pcre.h>
#endif

#define NCHAR (UCHAR_MAX + 1)

/* For -w, we also consider _ to be word constituent.  */
#define WCHAR(C) (ISALNUM(C) || (C) == '_')

/* KWset compiled pattern.  For Ecompile and Gcompile, we compile
   a list of strings, at least one of which is known to occur in
   any string matching the regexp. */
static kwset_t kwset;

static void
kwsinit (void)
{
  static char trans[NCHAR];
  int i;

  if (match_icase && MB_CUR_MAX == 1)
    {
      for (i = 0; i < NCHAR; ++i)
        trans[i] = TOLOWER (i);

      kwset = kwsalloc (trans);
    }
  else
    kwset = kwsalloc (NULL);

  if (!kwset)
    xalloc_die ();
}

#ifdef MBS_SUPPORT
/* Convert the *N-byte string, BEG, to lowercase, and write the
   NUL-terminated result into malloc'd storage.  Upon success, set *N
   to the length (in bytes) of the resulting string (not including the
   trailing NUL byte), and return a pointer to the lowercase string.
   Upon memory allocation failure, this function exits.

   Note that while this function returns a pointer to malloc'd storage,
   the caller must not free it, since this function retains a pointer
   to the buffer and reuses it on any subsequent call.  As a consequence,
   this function is not thread-safe.  */
static char *
mbtolower (const char *beg, size_t *n)
{
  static char *out;
  static size_t outalloc;
  size_t outlen, mb_cur_max;
  mbstate_t is, os;
  const char *end;
  char *p;

  if (*n > outalloc)
    {
      out = xrealloc (out, *n);
      outalloc = *n;
    }

  memset (&is, 0, sizeof (is));
  memset (&os, 0, sizeof (os));
  end = beg + *n;

  mb_cur_max = MB_CUR_MAX;
  p = out;
  outlen = 0;
  while (beg < end)
    {
      wchar_t wc;
      size_t mbclen = mbrtowc(&wc, beg, end - beg, &is);
      if (outlen + mb_cur_max >= outalloc)
        {
          out = x2nrealloc (out, &outalloc, 1);
          p = out + outlen;
        }

      if (mbclen == (size_t) -1 || mbclen == (size_t) -2 || mbclen == 0)
        {
          /* An invalid sequence, or a truncated multi-octet character.
             We treat it as a single-octet character.  */
          *p++ = *beg++;
          outlen++;
          memset (&is, 0, sizeof (is));
          memset (&os, 0, sizeof (os));
        }
      else
        {
          beg += mbclen;
          mbclen = wcrtomb (p, towlower ((wint_t) wc), &os);
          p += mbclen;
          outlen += mbclen;
        }
    }

  *n = p - out;
  *p++ = 0;
  return out;
}
#endif


#ifndef FGREP_PROGRAM
/* DFA compiled regexp. */
static struct dfa dfa;

/* The Regex compiled patterns.  */
static struct patterns
{
  /* Regex compiled regexp. */
  struct re_pattern_buffer regexbuf;
  struct re_registers regs; /* This is here on account of a BRAIN-DEAD
			       Q@#%!# library interface in regex.c.  */
} patterns0;

struct patterns *patterns;
size_t pcount;

void
dfaerror (char const *mesg)
{
  error (EXIT_TROUBLE, 0, "%s", mesg);
}

/* Number of compiled fixed strings known to exactly match the regexp.
   If kwsexec returns < kwset_exact_matches, then we don't need to
   call the regexp matcher at all. */
static int kwset_exact_matches;

static char const *
kwsincr_case (const char *must)
{
  const char *buf;
  size_t n;

  n = strlen (must);
#ifdef MBS_SUPPORT
  if (match_icase && MB_CUR_MAX > 1)
    buf = mbtolower (must, &n);
  else
#endif
    buf = must;
  return kwsincr (kwset, buf, n);
}

/* If the DFA turns out to have some set of fixed strings one of
   which must occur in the match, then we build a kwset matcher
   to find those strings, and thus quickly filter out impossible
   matches. */
static void
kwsmusts (void)
{
  struct dfamust const *dm;
  char const *err;

  if (dfa.musts)
    {
      kwsinit ();
      /* First, we compile in the substrings known to be exact
	 matches.  The kwset matcher will return the index
	 of the matching string that it chooses. */
      for (dm = dfa.musts; dm; dm = dm->next)
	{
	  if (!dm->exact)
	    continue;
	  ++kwset_exact_matches;
	  if ((err = kwsincr_case (dm->must)) != NULL)
	    error (EXIT_TROUBLE, 0, "%s", err);
	}
      /* Now, we compile the substrings that will require
	 the use of the regexp matcher.  */
      for (dm = dfa.musts; dm; dm = dm->next)
	{
	  if (dm->exact)
	    continue;
	  if ((err = kwsincr_case (dm->must)) != NULL)
	    error (EXIT_TROUBLE, 0, "%s", err);
	}
      if ((err = kwsprep (kwset)) != NULL)
	error (EXIT_TROUBLE, 0, "%s", err);
    }
}
#endif /* !FGREP_PROGRAM */

#ifdef MBS_SUPPORT

static bool
is_mb_middle(const char **good, const char *buf, const char *end)
{
  const char *p = *good;
  const char *prev = p;
  mbstate_t cur_state;

  /* TODO: can be optimized for UTF-8.  */
  memset(&cur_state, 0, sizeof(mbstate_t));
  while (p < buf)
    {
      size_t mbclen = mbrlen(p, end - p, &cur_state);

      /* Store the beginning of the previous complete multibyte character.  */
      if (mbclen != (size_t) -2)
        prev = p;

      if (mbclen == (size_t) -1 || mbclen == (size_t) -2 || mbclen == 0)
	{
	  /* An invalid sequence, or a truncated multibyte character.
	     We treat it as a single byte character.  */
	  mbclen = 1;
	}
      p += mbclen;
    }

  *good = prev;
  return p > buf;
}
#endif /* MBS_SUPPORT */

#if defined(GREP_PROGRAM) || defined(EGREP_PROGRAM)
#ifdef EGREP_PROGRAM
COMPILE_FCT(Ecompile)
{
  reg_syntax_t syntax_bits = RE_SYNTAX_POSIX_EGREP;
#else
/* No __VA_ARGS__ in C89.  So we have to do it this way.  */
static COMPILE_RET
GEAcompile (char const *pattern, size_t size, reg_syntax_t syntax_bits)
{
#endif /* EGREP_PROGRAM */
  const char *err;
  const char *p, *sep;
  size_t total = size;
  char *motif;

  if (match_icase)
    syntax_bits |= RE_ICASE;
  re_set_syntax (syntax_bits);
  dfasyntax (syntax_bits, match_icase, eolbyte);

  /* For GNU regex compiler we have to pass the patterns separately to detect
     errors like "[\nallo\n]\n".  The patterns here are "[", "allo" and "]"
     GNU regex should have raise a syntax error.  The same for backref, where
     the backref should have been local to each pattern.  */
  p = pattern;
  do
    {
      size_t len;
      sep = memchr (p, '\n', total);
      if (sep)
	{
	  len = sep - p;
	  sep++;
	  total -= (len + 1);
	}
      else
	{
	  len = total;
	  total = 0;
	}

      patterns = realloc (patterns, (pcount + 1) * sizeof (*patterns));
      if (patterns == NULL)
	error (EXIT_TROUBLE, errno, _("memory exhausted"));
      patterns[pcount] = patterns0;

      if ((err = re_compile_pattern (p, len,
				    &(patterns[pcount].regexbuf))) != NULL)
	error (EXIT_TROUBLE, 0, "%s", err);
      pcount++;

      p = sep;
    } while (sep && total != 0);

  /* In the match_words and match_lines cases, we use a different pattern
     for the DFA matcher that will quickly throw out cases that won't work.
     Then if DFA succeeds we do some hairy stuff using the regex matcher
     to decide whether the match should really count. */
  if (match_words || match_lines)
    {
      static char const line_beg_no_bk[] = "^(";
      static char const line_end_no_bk[] = ")$";
      static char const word_beg_no_bk[] = "(^|[^[:alnum:]_])(";
      static char const word_end_no_bk[] = ")([^[:alnum:]_]|$)";
#ifdef EGREP_PROGRAM
# define IF_BK(x, y) (y)
      char *n = xmalloc (sizeof word_beg_no_bk - 1 + size + sizeof word_end_no_bk);
#else
      static char const line_beg_bk[] = "^\\(";
      static char const line_end_bk[] = "\\)$";
      static char const word_beg_bk[] = "\\(^\\|[^[:alnum:]_]\\)\\(";
      static char const word_end_bk[] = "\\)\\([^[:alnum:]_]\\|$\\)";
      int bk = !(syntax_bits & RE_NO_BK_PARENS);
# define IF_BK(x, y) ((bk) ? (x) : (y))
      char *n = xmalloc (sizeof word_beg_bk - 1 + size + sizeof word_end_bk);
#endif /* EGREP_PROGRAM */

      strcpy (n, match_lines ? IF_BK(line_beg_bk, line_beg_no_bk)
			     : IF_BK(word_beg_bk, word_beg_no_bk));
      total = strlen(n);
      memcpy (n + total, pattern, size);
      total += size;
      strcpy (n + total, match_lines ? IF_BK(line_end_bk, line_end_no_bk)
				     : IF_BK(word_end_bk, word_end_no_bk));
      total += strlen (n + total);
      pattern = motif = n;
      size = total;
    }
  else
    motif = NULL;

  dfacomp (pattern, size, &dfa, 1);
  kwsmusts ();

  free(motif);
}

#ifndef EGREP_PROGRAM
COMPILE_FCT(Gcompile)
{
  return GEAcompile (pattern, size,
		     RE_SYNTAX_GREP | RE_HAT_LISTS_NOT_NEWLINE);
}

COMPILE_FCT(Acompile)
{
  return GEAcompile (pattern, size, RE_SYNTAX_AWK);
}

COMPILE_FCT(Ecompile)
{
  return GEAcompile (pattern, size, RE_SYNTAX_POSIX_EGREP);
}
#endif /* !EGREP_PROGRAM */

EXECUTE_FCT(EGexecute)
{
  char const *buflim, *beg, *end, *match, *best_match, *mb_start;
  char eol = eolbyte;
  int backref, start, len, best_len;
  struct kwsmatch kwsm;
  size_t i, ret_val;
#ifdef MBS_SUPPORT
  if (MB_CUR_MAX > 1)
    {
      if (match_icase)
        {
          /* mbtolower adds a NUL byte at the end.  That will provide
	     space for the sentinel byte dfaexec may add.  */
          char *case_buf = mbtolower (buf, &size);
	  if (start_ptr)
	    start_ptr = case_buf + (start_ptr - buf);
          buf = case_buf;
        }
    }
#endif /* MBS_SUPPORT */

  mb_start = buf;
  buflim = buf + size;

  for (beg = end = buf; end < buflim; beg = end)
    {
      if (!start_ptr)
	{
	  /* We don't care about an exact match.  */
	  if (kwset)
	    {
	      /* Find a possible match using the KWset matcher. */
	      size_t offset = kwsexec (kwset, beg, buflim - beg, &kwsm);
	      if (offset == (size_t) -1)
		goto failure;
	      beg += offset;
	      /* Narrow down to the line containing the candidate, and
		 run it through DFA. */
	      if ((end = memchr(beg, eol, buflim - beg)) != NULL)
	        end++;
              else
                end = buflim;
	      match = beg;
	      while (beg > buf && beg[-1] != eol)
		--beg;
	      if (kwsm.index < kwset_exact_matches)
                {
#ifdef MBS_SUPPORT
                  if (mb_start < beg)
                    mb_start = beg;
                  if (MB_CUR_MAX == 1 || !is_mb_middle (&mb_start, match, buflim))
#endif
                    goto success;
                }
	      if (dfaexec (&dfa, beg, (char *) end, 0, NULL, &backref) == NULL)
		continue;
	    }
	  else
	    {
	      /* No good fixed strings; start with DFA. */
	      char const *next_beg = dfaexec (&dfa, beg, (char *) buflim,
					      0, NULL, &backref);
	      if (next_beg == NULL)
		break;
	      /* Narrow down to the line we've found. */
	      beg = next_beg;
	      if ((end = memchr(beg, eol, buflim - beg)) != NULL)
	        end++;
              else
                end = buflim;
	      while (beg > buf && beg[-1] != eol)
		--beg;
	    }
	  /* Successful, no backreferences encountered! */
	  if (!backref)
	    goto success;
	}
      else
	{
	  /* We are looking for the leftmost (then longest) exact match.
	     We will go through the outer loop only once.  */
	  beg = start_ptr;
	  end = buflim;
	}

      /* If we've made it to this point, this means DFA has seen
	 a probable match, and we need to run it through Regex. */
      best_match = end;
      best_len = 0;
      for (i = 0; i < pcount; i++)
	{
	  patterns[i].regexbuf.not_eol = 0;
	  if (0 <= (start = re_search (&(patterns[i].regexbuf),
				       buf, end - buf - 1,
				       beg - buf, end - beg - 1,
				       &(patterns[i].regs))))
	    {
	      len = patterns[i].regs.end[0] - start;
	      match = buf + start;
	      if (match > best_match)
		continue;
	      if (start_ptr && !match_words)
		goto assess_pattern_match;
	      if ((!match_lines && !match_words)
		  || (match_lines && len == end - beg - 1))
		{
		  match = beg;
		  len = end - beg;
		  goto assess_pattern_match;
		}
	      /* If -w, check if the match aligns with word boundaries.
		 We do this iteratively because:
		 (a) the line may contain more than one occurence of the
		 pattern, and
		 (b) Several alternatives in the pattern might be valid at a
		 given point, and we may need to consider a shorter one to
		 find a word boundary.  */
	      if (match_words)
		while (match <= best_match)
		  {
		    if ((match == buf || !WCHAR ((unsigned char) match[-1]))
			&& (len == end - beg - 1
			    || !WCHAR ((unsigned char) match[len])))
		      goto assess_pattern_match;
		    if (len > 0)
		      {
			/* Try a shorter length anchored at the same place. */
			--len;
			patterns[i].regexbuf.not_eol = 1;
			len = re_match (&(patterns[i].regexbuf),
					buf, match + len - beg, match - buf,
					&(patterns[i].regs));
		      }
		    if (len <= 0)
		      {
			/* Try looking further on. */
			if (match == end - 1)
			  break;
			match++;
			patterns[i].regexbuf.not_eol = 0;
			start = re_search (&(patterns[i].regexbuf),
					   buf, end - buf - 1,
					   match - buf, end - match - 1,
					   &(patterns[i].regs));
			if (start < 0)
			  break;
			len = patterns[i].regs.end[0] - start;
			match = buf + start;
		      }
		  } /* while (match <= best_match) */
	      continue;
	    assess_pattern_match:
	      if (!start_ptr)
		{
		  /* Good enough for a non-exact match.
		     No need to look at further patterns, if any.  */
		  beg = match;
		  goto success_in_len;
		}
	      if (match < best_match || (match == best_match && len > best_len))
		{
		  /* Best exact match:  leftmost, then longest.  */
		  best_match = match;
		  best_len = len;
		}
	    } /* if re_search >= 0 */
	} /* for Regex patterns.  */
	if (best_match < end)
	  {
	    /* We have found an exact match.  We were just
	       waiting for the best one (leftmost then longest).  */
	    beg = best_match;
	    len = best_len;
	    goto success_in_len;
	  }
    } /* for (beg = end ..) */

 failure:
  ret_val = -1;
  goto out;

 success:
  len = end - beg;
 success_in_len:
  *match_size = len;
  ret_val = beg - buf;
 out:
  return ret_val;
}
#endif /* defined(GREP_PROGRAM) || defined(EGREP_PROGRAM) */

#if defined(GREP_PROGRAM) || defined(FGREP_PROGRAM)
COMPILE_FCT(Fcompile)
{
  char const *beg, *end, *lim, *err, *pat;
  size_t psize;

  kwsinit ();
  psize = size;
  if (match_icase && MB_CUR_MAX > 1)
    pat = mbtolower (pattern, &psize);
  else
    pat = pattern;

  beg = pat;
  do
    {
      for (lim = beg;; ++lim)
	{
	  end = lim;
	  if (lim >= pat + psize)
	    break;
	 if (*lim == '\n')
	   {
	     lim++;
	     break;
	   }
#if HAVE_DOS_FILE_CONTENTS
	 if (*lim == '\r' && lim + 1 < pat + psize && lim[1] == '\n')
	   {
	     lim += 2;
	     break;
	   }
#endif
	}

      if ((err = kwsincr (kwset, beg, end - beg)) != NULL)
	error (EXIT_TROUBLE, 0, "%s", err);
      beg = lim;
    }
  while (beg < pat + psize);

  if ((err = kwsprep (kwset)) != NULL)
    error (EXIT_TROUBLE, 0, "%s", err);
}

EXECUTE_FCT(Fexecute)
{
  char const *beg, *try, *end, *mb_start;
  size_t len;
  char eol = eolbyte;
  struct kwsmatch kwsmatch;
  size_t ret_val;
#ifdef MBS_SUPPORT
  if (MB_CUR_MAX > 1)
    {
      if (match_icase)
        {
          char *case_buf = mbtolower (buf, &size);
	  if (start_ptr)
	    start_ptr = case_buf + (start_ptr - buf);
          buf = case_buf;
        }
    }
#endif /* MBS_SUPPORT */

  for (mb_start = beg = start_ptr ? start_ptr : buf; beg <= buf + size; beg++)
    {
      size_t offset = kwsexec (kwset, beg, buf + size - beg, &kwsmatch);
      if (offset == (size_t) -1)
	goto failure;
#ifdef MBS_SUPPORT
      //prophet generated patch
      if (__get_mutant()==0) {
      if (((__ctype_get_mb_cur_max()) > 1 && is_mb_middle(&mb_start, beg + offset, buf + size)) && !(__is_neg(17, &(buf), sizeof (buf), &(size), sizeof (size), &(beg), sizeof (beg), &(mb_start), sizeof (mb_start), &(offset), sizeof (offset), &(kwset), sizeof (kwset), &(start_ptr), sizeof (start_ptr), &(len), sizeof (len), &(match_words), sizeof (match_words), &(match_lines), sizeof (match_lines), &(eol), sizeof (eol), &(match_icase), sizeof (match_icase), &(try), sizeof (try), &(eolbyte), sizeof (eolbyte), &(ret_val), sizeof (ret_val), &(end), sizeof (end), &(match_size), sizeof (match_size)))) {
          beg = mb_start - 1;
          continue;
      }
      }
      else if (__get_mutant()==1) {
      if (((__ctype_get_mb_cur_max()) > 1 && is_mb_middle(&mb_start, beg + offset, buf + size)) || (__is_neg(17, &(buf), sizeof (buf), &(size), sizeof (size), &(beg), sizeof (beg), &(mb_start), sizeof (mb_start), &(offset), sizeof (offset), &(kwset), sizeof (kwset), &(start_ptr), sizeof (start_ptr), &(len), sizeof (len), &(match_words), sizeof (match_words), &(match_lines), sizeof (match_lines), &(eol), sizeof (eol), &(match_icase), sizeof (match_icase), &(try), sizeof (try), &(eolbyte), sizeof (eolbyte), &(ret_val), sizeof (ret_val), &(end), sizeof (end), &(match_size), sizeof (match_size)))) {
          beg = mb_start - 1;
          continue;
      }
      }
      else if (__get_mutant()==2) {
      if ((((__ctype_get_mb_cur_max()) > 1) || (__is_neg(17, &(buf), sizeof (buf), &(size), sizeof (size), &(beg), sizeof (beg), &(mb_start), sizeof (mb_start), &(offset), sizeof (offset), &(kwset), sizeof (kwset), &(start_ptr), sizeof (start_ptr), &(len), sizeof (len), &(match_words), sizeof (match_words), &(match_lines), sizeof (match_lines), &(eol), sizeof (eol), &(match_icase), sizeof (match_icase), &(try), sizeof (try), &(eolbyte), sizeof (eolbyte), &(ret_val), sizeof (ret_val), &(end), sizeof (end), &(match_size), sizeof (match_size)))) && is_mb_middle(&mb_start, beg + offset, buf + size)) {
          beg = mb_start - 1;
          continue;
      }
      }
#endif /* MBS_SUPPORT */
      beg += offset;
      len = kwsmatch.size[0];
      if (start_ptr && !match_words)
	goto success_in_beg_and_len;
      if (match_lines)
	{
	  if (beg > buf && beg[-1] != eol)
	    continue;
	  if (beg + len < buf + size && beg[len] != eol)
	    continue;
	  goto success;
	}
      else if (match_words)
	for (try = beg; len; )
	  {
	    if (try > buf && WCHAR((unsigned char) try[-1]))
	      break;
	    if (try + len < buf + size && WCHAR((unsigned char) try[len]))
	      {
		offset = kwsexec (kwset, beg, --len, &kwsmatch);
		if (offset == (size_t) -1)
		  break;
		try = beg + offset;
		len = kwsmatch.size[0];
	      }
	    else if (!start_ptr)
	      goto success;
	    else
	      goto success_in_beg_and_len;
	  } /* for (try) */
      else
	goto success;
    } /* for (beg in buf) */

 failure:
  ret_val = -1;
  goto out;

 success:
  if ((end = memchr (beg + len, eol, (buf + size) - (beg + len))) != NULL)
    end++;
  else
    end = buf + size;
  while (buf < beg && beg[-1] != eol)
    --beg;
  len = end - beg;
 success_in_beg_and_len:
  *match_size = len;
  ret_val = beg - buf;
 out:
  return ret_val;
}
#endif /* defined(GREP_PROGRAM) || defined(FGREP_PROGRAM) */

#ifdef GREP_PROGRAM
#if HAVE_LIBPCRE
/* Compiled internal form of a Perl regular expression.  */
static pcre *cre;

/* Additional information about the pattern.  */
static pcre_extra *extra;
#endif

COMPILE_FCT(Pcompile)
{
#if !HAVE_LIBPCRE
  error (EXIT_TROUBLE, 0, "%s",
	 _("support for the -P option is not compiled into "
	   "this --disable-perl-regexp binary"));
#else
  int e;
  char const *ep;
  char *re = xmalloc (4 * size + 7);
  int flags = PCRE_MULTILINE | (match_icase ? PCRE_CASELESS : 0);
  char const *patlim = pattern + size;
  char *n = re;
  char const *p;
  char const *pnul;

  /* FIXME: Remove these restrictions.  */
  if (memchr(pattern, '\n', size))
    error (EXIT_TROUBLE, 0, _("the -P option only supports a single pattern"));

  *n = '\0';
  if (match_lines)
    strcpy (n, "^(");
  if (match_words)
    strcpy (n, "\\b(");
  n += strlen (n);

  /* The PCRE interface doesn't allow NUL bytes in the pattern, so
     replace each NUL byte in the pattern with the four characters
     "\000", removing a preceding backslash if there are an odd
     number of backslashes before the NUL.

     FIXME: This method does not work with some multibyte character
     encodings, notably Shift-JIS, where a multibyte character can end
     in a backslash byte.  */
  for (p = pattern; (pnul = memchr (p, '\0', patlim - p)); p = pnul + 1)
    {
      memcpy (n, p, pnul - p);
      n += pnul - p;
      for (p = pnul; pattern < p && p[-1] == '\\'; p--)
	continue;
      n -= (pnul - p) & 1;
      strcpy (n, "\\000");
      n += 4;
    }

  memcpy (n, p, patlim - p);
  n += patlim - p;
  *n = '\0';
  if (match_words)
    strcpy (n, ")\\b");
  if (match_lines)
    strcpy (n, ")$");

  cre = pcre_compile (re, flags, &ep, &e, pcre_maketables ());
  if (!cre)
    error (EXIT_TROUBLE, 0, "%s", ep);

  extra = pcre_study (cre, 0, &ep);
  if (ep)
    error (EXIT_TROUBLE, 0, "%s", ep);

  free (re);
#endif
}

EXECUTE_FCT(Pexecute)
{
#if !HAVE_LIBPCRE
  abort ();
  return -1;
#else
  /* This array must have at least two elements; everything after that
     is just for performance improvement in pcre_exec.  */
  int sub[300];

  const char *line_buf, *line_end, *line_next;
  int e = PCRE_ERROR_NOMATCH;
  ptrdiff_t start_ofs = start_ptr ? start_ptr - buf : 0;

  /* PCRE can't limit the matching to single lines, therefore we have to
     match each line in the buffer separately.  */
  for (line_next = buf;
       e == PCRE_ERROR_NOMATCH && line_next < buf + size;
       start_ofs -= line_next - line_buf)
    {
      line_buf = line_next;
      line_end = memchr (line_buf, eolbyte, (buf + size) - line_buf);
      if (line_end == NULL)
        line_next = line_end = buf + size;
      else
        line_next = line_end + 1;

      if (start_ptr && start_ptr >= line_end)
        continue;

      e = pcre_exec (cre, extra, line_buf, line_end - line_buf,
                     start_ofs < 0 ? 0 : start_ofs, 0,
                     sub, sizeof sub / sizeof *sub);
    }

  if (e <= 0)
    {
      switch (e)
	{
	case PCRE_ERROR_NOMATCH:
	  return -1;

	case PCRE_ERROR_NOMEMORY:
	  error (EXIT_TROUBLE, 0, _("memory exhausted"));

	default:
	  abort ();
	}
    }
  else
    {
      /* Narrow down to the line we've found.  */
      char const *beg = line_buf + sub[0];
      char const *end = line_buf + sub[1];
      char const *buflim = buf + size;
      char eol = eolbyte;
      if (!start_ptr)
	{
	  /* FIXME: The case when '\n' is not found indicates a bug:
	     Since grep is line oriented, the match should never contain
	     a newline, so there _must_ be a newline following.
	   */
	  if (!(end = memchr (end, eol, buflim - end)))
	    end = buflim;
	  else
	    end++;
	  while (buf < beg && beg[-1] != eol)
	    --beg;
	}

      *match_size = end - beg;
      return beg - buf;
    }
#endif
}

struct matcher const matchers[] = {
  { "default", Gcompile, EGexecute },
  { "grep",    Gcompile, EGexecute },
  { "egrep",   Ecompile, EGexecute },
  { "awk",     Acompile, EGexecute },
  { "fgrep",   Fcompile, Fexecute },
  { "perl",    Pcompile, Pexecute },
  { "", 0, 0 },
};
#endif /* GREP_PROGRAM */

Building:src at:
/home/ubuntu/spr-fast/tests/corebench/grep/grep-case-deccad69-db9d6340/tempworkdir2/srcMerged code building succ, going to invoke tester!
CondTester, Testing instance id 12:
//src_file:src/search.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
/* search.c - searching subroutines using dfa, kwset and regex for grep.
   Copyright 1992, 1998, 2000, 2007, 2009-2010 Free Software Foundation, Inc.

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 3, or (at your option)
   any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program; if not, write to the Free Software
   Foundation, Inc., 51 Franklin Street - Fifth Floor, Boston, MA
   02110-1301, USA.  */

/* Written August 1992 by Mike Haertel. */

#include <config.h>

#include <sys/types.h>

#include "mbsupport.h"
#ifdef MBS_SUPPORT
/* We can handle multibyte strings. */
# include <wchar.h>
# include <wctype.h>
#endif

#include "system.h"
#include "grep.h"
#ifndef FGREP_PROGRAM
# include <regex.h>
# include "dfa.h"
#endif
#include "kwset.h"
#include "error.h"
#include "xalloc.h"
#ifdef HAVE_LIBPCRE
# include <pcre.h>
#endif

#define NCHAR (UCHAR_MAX + 1)

/* For -w, we also consider _ to be word constituent.  */
#define WCHAR(C) (ISALNUM(C) || (C) == '_')

/* KWset compiled pattern.  For Ecompile and Gcompile, we compile
   a list of strings, at least one of which is known to occur in
   any string matching the regexp. */
static kwset_t kwset;

static void
kwsinit (void)
{
  static char trans[NCHAR];
  int i;

  if (match_icase && MB_CUR_MAX == 1)
    {
      for (i = 0; i < NCHAR; ++i)
        trans[i] = TOLOWER (i);

      kwset = kwsalloc (trans);
    }
  else
    kwset = kwsalloc (NULL);

  if (!kwset)
    xalloc_die ();
}

#ifdef MBS_SUPPORT
/* Convert the *N-byte string, BEG, to lowercase, and write the
   NUL-terminated result into malloc'd storage.  Upon success, set *N
   to the length (in bytes) of the resulting string (not including the
   trailing NUL byte), and return a pointer to the lowercase string.
   Upon memory allocation failure, this function exits.

   Note that while this function returns a pointer to malloc'd storage,
   the caller must not free it, since this function retains a pointer
   to the buffer and reuses it on any subsequent call.  As a consequence,
   this function is not thread-safe.  */
static char *
mbtolower (const char *beg, size_t *n)
{
  static char *out;
  static size_t outalloc;
  size_t outlen, mb_cur_max;
  mbstate_t is, os;
  const char *end;
  char *p;

  if (*n > outalloc)
    {
      out = xrealloc (out, *n);
      outalloc = *n;
    }

  memset (&is, 0, sizeof (is));
  memset (&os, 0, sizeof (os));
  end = beg + *n;

  mb_cur_max = MB_CUR_MAX;
  p = out;
  outlen = 0;
  while (beg < end)
    {
      wchar_t wc;
      size_t mbclen = mbrtowc(&wc, beg, end - beg, &is);
      if (outlen + mb_cur_max >= outalloc)
        {
          out = x2nrealloc (out, &outalloc, 1);
          p = out + outlen;
        }

      if (mbclen == (size_t) -1 || mbclen == (size_t) -2 || mbclen == 0)
        {
          /* An invalid sequence, or a truncated multi-octet character.
             We treat it as a single-octet character.  */
          *p++ = *beg++;
          outlen++;
          memset (&is, 0, sizeof (is));
          memset (&os, 0, sizeof (os));
        }
      else
        {
          beg += mbclen;
          mbclen = wcrtomb (p, towlower ((wint_t) wc), &os);
          p += mbclen;
          outlen += mbclen;
        }
    }

  *n = p - out;
  *p++ = 0;
  return out;
}
#endif


#ifndef FGREP_PROGRAM
/* DFA compiled regexp. */
static struct dfa dfa;

/* The Regex compiled patterns.  */
static struct patterns
{
  /* Regex compiled regexp. */
  struct re_pattern_buffer regexbuf;
  struct re_registers regs; /* This is here on account of a BRAIN-DEAD
			       Q@#%!# library interface in regex.c.  */
} patterns0;

struct patterns *patterns;
size_t pcount;

void
dfaerror (char const *mesg)
{
  error (EXIT_TROUBLE, 0, "%s", mesg);
}

/* Number of compiled fixed strings known to exactly match the regexp.
   If kwsexec returns < kwset_exact_matches, then we don't need to
   call the regexp matcher at all. */
static int kwset_exact_matches;

static char const *
kwsincr_case (const char *must)
{
  const char *buf;
  size_t n;

  n = strlen (must);
#ifdef MBS_SUPPORT
  if (match_icase && MB_CUR_MAX > 1)
    buf = mbtolower (must, &n);
  else
#endif
    buf = must;
  return kwsincr (kwset, buf, n);
}

/* If the DFA turns out to have some set of fixed strings one of
   which must occur in the match, then we build a kwset matcher
   to find those strings, and thus quickly filter out impossible
   matches. */
static void
kwsmusts (void)
{
  struct dfamust const *dm;
  char const *err;

  if (dfa.musts)
    {
      kwsinit ();
      /* First, we compile in the substrings known to be exact
	 matches.  The kwset matcher will return the index
	 of the matching string that it chooses. */
      for (dm = dfa.musts; dm; dm = dm->next)
	{
	  if (!dm->exact)
	    continue;
	  ++kwset_exact_matches;
	  if ((err = kwsincr_case (dm->must)) != NULL)
	    error (EXIT_TROUBLE, 0, "%s", err);
	}
      /* Now, we compile the substrings that will require
	 the use of the regexp matcher.  */
      for (dm = dfa.musts; dm; dm = dm->next)
	{
	  if (dm->exact)
	    continue;
	  if ((err = kwsincr_case (dm->must)) != NULL)
	    error (EXIT_TROUBLE, 0, "%s", err);
	}
      if ((err = kwsprep (kwset)) != NULL)
	error (EXIT_TROUBLE, 0, "%s", err);
    }
}
#endif /* !FGREP_PROGRAM */

#ifdef MBS_SUPPORT

static bool
is_mb_middle(const char **good, const char *buf, const char *end)
{
  const char *p = *good;
  const char *prev = p;
  mbstate_t cur_state;

  /* TODO: can be optimized for UTF-8.  */
  memset(&cur_state, 0, sizeof(mbstate_t));
  while (p < buf)
    {
      size_t mbclen = mbrlen(p, end - p, &cur_state);

      /* Store the beginning of the previous complete multibyte character.  */
      if (mbclen != (size_t) -2)
        prev = p;

      if (mbclen == (size_t) -1 || mbclen == (size_t) -2 || mbclen == 0)
	{
	  /* An invalid sequence, or a truncated multibyte character.
	     We treat it as a single byte character.  */
	  mbclen = 1;
	}
      p += mbclen;
    }

  *good = prev;
  return p > buf;
}
#endif /* MBS_SUPPORT */

#if defined(GREP_PROGRAM) || defined(EGREP_PROGRAM)
#ifdef EGREP_PROGRAM
COMPILE_FCT(Ecompile)
{
  reg_syntax_t syntax_bits = RE_SYNTAX_POSIX_EGREP;
#else
/* No __VA_ARGS__ in C89.  So we have to do it this way.  */
static COMPILE_RET
GEAcompile (char const *pattern, size_t size, reg_syntax_t syntax_bits)
{
#endif /* EGREP_PROGRAM */
  const char *err;
  const char *p, *sep;
  size_t total = size;
  char *motif;

  if (match_icase)
    syntax_bits |= RE_ICASE;
  re_set_syntax (syntax_bits);
  dfasyntax (syntax_bits, match_icase, eolbyte);

  /* For GNU regex compiler we have to pass the patterns separately to detect
     errors like "[\nallo\n]\n".  The patterns here are "[", "allo" and "]"
     GNU regex should have raise a syntax error.  The same for backref, where
     the backref should have been local to each pattern.  */
  p = pattern;
  do
    {
      size_t len;
      sep = memchr (p, '\n', total);
      if (sep)
	{
	  len = sep - p;
	  sep++;
	  total -= (len + 1);
	}
      else
	{
	  len = total;
	  total = 0;
	}

      patterns = realloc (patterns, (pcount + 1) * sizeof (*patterns));
      if (patterns == NULL)
	error (EXIT_TROUBLE, errno, _("memory exhausted"));
      patterns[pcount] = patterns0;

      if ((err = re_compile_pattern (p, len,
				    &(patterns[pcount].regexbuf))) != NULL)
	error (EXIT_TROUBLE, 0, "%s", err);
      pcount++;

      p = sep;
    } while (sep && total != 0);

  /* In the match_words and match_lines cases, we use a different pattern
     for the DFA matcher that will quickly throw out cases that won't work.
     Then if DFA succeeds we do some hairy stuff using the regex matcher
     to decide whether the match should really count. */
  if (match_words || match_lines)
    {
      static char const line_beg_no_bk[] = "^(";
      static char const line_end_no_bk[] = ")$";
      static char const word_beg_no_bk[] = "(^|[^[:alnum:]_])(";
      static char const word_end_no_bk[] = ")([^[:alnum:]_]|$)";
#ifdef EGREP_PROGRAM
# define IF_BK(x, y) (y)
      char *n = xmalloc (sizeof word_beg_no_bk - 1 + size + sizeof word_end_no_bk);
#else
      static char const line_beg_bk[] = "^\\(";
      static char const line_end_bk[] = "\\)$";
      static char const word_beg_bk[] = "\\(^\\|[^[:alnum:]_]\\)\\(";
      static char const word_end_bk[] = "\\)\\([^[:alnum:]_]\\|$\\)";
      int bk = !(syntax_bits & RE_NO_BK_PARENS);
# define IF_BK(x, y) ((bk) ? (x) : (y))
      char *n = xmalloc (sizeof word_beg_bk - 1 + size + sizeof word_end_bk);
#endif /* EGREP_PROGRAM */

      strcpy (n, match_lines ? IF_BK(line_beg_bk, line_beg_no_bk)
			     : IF_BK(word_beg_bk, word_beg_no_bk));
      total = strlen(n);
      memcpy (n + total, pattern, size);
      total += size;
      strcpy (n + total, match_lines ? IF_BK(line_end_bk, line_end_no_bk)
				     : IF_BK(word_end_bk, word_end_no_bk));
      total += strlen (n + total);
      pattern = motif = n;
      size = total;
    }
  else
    motif = NULL;

  dfacomp (pattern, size, &dfa, 1);
  kwsmusts ();

  free(motif);
}

#ifndef EGREP_PROGRAM
COMPILE_FCT(Gcompile)
{
  return GEAcompile (pattern, size,
		     RE_SYNTAX_GREP | RE_HAT_LISTS_NOT_NEWLINE);
}

COMPILE_FCT(Acompile)
{
  return GEAcompile (pattern, size, RE_SYNTAX_AWK);
}

COMPILE_FCT(Ecompile)
{
  return GEAcompile (pattern, size, RE_SYNTAX_POSIX_EGREP);
}
#endif /* !EGREP_PROGRAM */

EXECUTE_FCT(EGexecute)
{
  char const *buflim, *beg, *end, *match, *best_match, *mb_start;
  char eol = eolbyte;
  int backref, start, len, best_len;
  struct kwsmatch kwsm;
  size_t i, ret_val;
#ifdef MBS_SUPPORT
  if (MB_CUR_MAX > 1)
    {
      if (match_icase)
        {
          /* mbtolower adds a NUL byte at the end.  That will provide
	     space for the sentinel byte dfaexec may add.  */
          char *case_buf = mbtolower (buf, &size);
	  if (start_ptr)
	    start_ptr = case_buf + (start_ptr - buf);
          buf = case_buf;
        }
    }
#endif /* MBS_SUPPORT */

  mb_start = buf;
  buflim = buf + size;

  for (beg = end = buf; end < buflim; beg = end)
    {
      if (!start_ptr)
	{
	  /* We don't care about an exact match.  */
	  if (kwset)
	    {
	      /* Find a possible match using the KWset matcher. */
	      size_t offset = kwsexec (kwset, beg, buflim - beg, &kwsm);
	      if (offset == (size_t) -1)
		goto failure;
	      beg += offset;
	      /* Narrow down to the line containing the candidate, and
		 run it through DFA. */
	      if ((end = memchr(beg, eol, buflim - beg)) != NULL)
	        end++;
              else
                end = buflim;
	      match = beg;
	      while (beg > buf && beg[-1] != eol)
		--beg;
	      if (kwsm.index < kwset_exact_matches)
                {
#ifdef MBS_SUPPORT
                  if (mb_start < beg)
                    mb_start = beg;
                  if (MB_CUR_MAX == 1 || !is_mb_middle (&mb_start, match, buflim))
#endif
                    goto success;
                }
	      if (dfaexec (&dfa, beg, (char *) end, 0, NULL, &backref) == NULL)
		continue;
	    }
	  else
	    {
	      /* No good fixed strings; start with DFA. */
	      char const *next_beg = dfaexec (&dfa, beg, (char *) buflim,
					      0, NULL, &backref);
	      if (next_beg == NULL)
		break;
	      /* Narrow down to the line we've found. */
	      beg = next_beg;
	      if ((end = memchr(beg, eol, buflim - beg)) != NULL)
	        end++;
              else
                end = buflim;
	      while (beg > buf && beg[-1] != eol)
		--beg;
	    }
	  /* Successful, no backreferences encountered! */
	  if (!backref)
	    goto success;
	}
      else
	{
	  /* We are looking for the leftmost (then longest) exact match.
	     We will go through the outer loop only once.  */
	  beg = start_ptr;
	  end = buflim;
	}

      /* If we've made it to this point, this means DFA has seen
	 a probable match, and we need to run it through Regex. */
      best_match = end;
      best_len = 0;
      for (i = 0; i < pcount; i++)
	{
	  patterns[i].regexbuf.not_eol = 0;
	  if (0 <= (start = re_search (&(patterns[i].regexbuf),
				       buf, end - buf - 1,
				       beg - buf, end - beg - 1,
				       &(patterns[i].regs))))
	    {
	      len = patterns[i].regs.end[0] - start;
	      match = buf + start;
	      if (match > best_match)
		continue;
	      if (start_ptr && !match_words)
		goto assess_pattern_match;
	      if ((!match_lines && !match_words)
		  || (match_lines && len == end - beg - 1))
		{
		  match = beg;
		  len = end - beg;
		  goto assess_pattern_match;
		}
	      /* If -w, check if the match aligns with word boundaries.
		 We do this iteratively because:
		 (a) the line may contain more than one occurence of the
		 pattern, and
		 (b) Several alternatives in the pattern might be valid at a
		 given point, and we may need to consider a shorter one to
		 find a word boundary.  */
	      if (match_words)
		while (match <= best_match)
		  {
		    if ((match == buf || !WCHAR ((unsigned char) match[-1]))
			&& (len == end - beg - 1
			    || !WCHAR ((unsigned char) match[len])))
		      goto assess_pattern_match;
		    if (len > 0)
		      {
			/* Try a shorter length anchored at the same place. */
			--len;
			patterns[i].regexbuf.not_eol = 1;
			len = re_match (&(patterns[i].regexbuf),
					buf, match + len - beg, match - buf,
					&(patterns[i].regs));
		      }
		    if (len <= 0)
		      {
			/* Try looking further on. */
			if (match == end - 1)
			  break;
			match++;
			patterns[i].regexbuf.not_eol = 0;
			start = re_search (&(patterns[i].regexbuf),
					   buf, end - buf - 1,
					   match - buf, end - match - 1,
					   &(patterns[i].regs));
			if (start < 0)
			  break;
			len = patterns[i].regs.end[0] - start;
			match = buf + start;
		      }
		  } /* while (match <= best_match) */
	      continue;
	    assess_pattern_match:
	      if (!start_ptr)
		{
		  /* Good enough for a non-exact match.
		     No need to look at further patterns, if any.  */
		  beg = match;
		  goto success_in_len;
		}
	      if (match < best_match || (match == best_match && len > best_len))
		{
		  /* Best exact match:  leftmost, then longest.  */
		  best_match = match;
		  best_len = len;
		}
	    } /* if re_search >= 0 */
	} /* for Regex patterns.  */
	if (best_match < end)
	  {
	    /* We have found an exact match.  We were just
	       waiting for the best one (leftmost then longest).  */
	    beg = best_match;
	    len = best_len;
	    goto success_in_len;
	  }
    } /* for (beg = end ..) */

 failure:
  ret_val = -1;
  goto out;

 success:
  len = end - beg;
 success_in_len:
  *match_size = len;
  ret_val = beg - buf;
 out:
  return ret_val;
}
#endif /* defined(GREP_PROGRAM) || defined(EGREP_PROGRAM) */

#if defined(GREP_PROGRAM) || defined(FGREP_PROGRAM)
COMPILE_FCT(Fcompile)
{
  char const *beg, *end, *lim, *err, *pat;
  size_t psize;

  kwsinit ();
  psize = size;
  if (match_icase && MB_CUR_MAX > 1)
    pat = mbtolower (pattern, &psize);
  else
    pat = pattern;

  beg = pat;
  do
    {
      for (lim = beg;; ++lim)
	{
	  end = lim;
	  if (lim >= pat + psize)
	    break;
	 if (*lim == '\n')
	   {
	     lim++;
	     break;
	   }
#if HAVE_DOS_FILE_CONTENTS
	 if (*lim == '\r' && lim + 1 < pat + psize && lim[1] == '\n')
	   {
	     lim += 2;
	     break;
	   }
#endif
	}

      if ((err = kwsincr (kwset, beg, end - beg)) != NULL)
	error (EXIT_TROUBLE, 0, "%s", err);
      beg = lim;
    }
  while (beg < pat + psize);

  if ((err = kwsprep (kwset)) != NULL)
    error (EXIT_TROUBLE, 0, "%s", err);
}

EXECUTE_FCT(Fexecute)
{
  char const *beg, *try, *end, *mb_start;
  size_t len;
  char eol = eolbyte;
  struct kwsmatch kwsmatch;
  size_t ret_val;
#ifdef MBS_SUPPORT
  if (MB_CUR_MAX > 1)
    {
      if (match_icase)
        {
          char *case_buf = mbtolower (buf, &size);
	  if (start_ptr)
	    start_ptr = case_buf + (start_ptr - buf);
          buf = case_buf;
        }
    }
#endif /* MBS_SUPPORT */

  for (mb_start = beg = start_ptr ? start_ptr : buf; beg <= buf + size; beg++)
    {
      size_t offset = kwsexec (kwset, beg, buf + size - beg, &kwsmatch);
      if (offset == (size_t) -1)
	goto failure;
#ifdef MBS_SUPPORT
      
//Patch 0:
if (((__ctype_get_mb_cur_max()) > 1 && is_mb_middle(&mb_start, beg + offset, buf + size)) && !(__is_neg(17, &(buf), sizeof (buf), &(size), sizeof (size), &(beg), sizeof (beg), &(mb_start), sizeof (mb_start), &(offset), sizeof (offset), &(kwset), sizeof (kwset), &(start_ptr), sizeof (start_ptr), &(len), sizeof (len), &(match_words), sizeof (match_words), &(match_lines), sizeof (match_lines), &(eol), sizeof (eol), &(match_icase), sizeof (match_icase), &(try), sizeof (try), &(eolbyte), sizeof (eolbyte), &(ret_val), sizeof (ret_val), &(end), sizeof (end), &(match_size), sizeof (match_size)))) {
    beg = mb_start - 1;
    continue;
}

//CodeSeg 1:
#endif /* MBS_SUPPORT */
      beg += offset;
      len = kwsmatch.size[0];
      if (start_ptr && !match_words)
	goto success_in_beg_and_len;
      if (match_lines)
	{
	  if (beg > buf && beg[-1] != eol)
	    continue;
	  if (beg + len < buf + size && beg[len] != eol)
	    continue;
	  goto success;
	}
      else if (match_words)
	for (try = beg; len; )
	  {
	    if (try > buf && WCHAR((unsigned char) try[-1]))
	      break;
	    if (try + len < buf + size && WCHAR((unsigned char) try[len]))
	      {
		offset = kwsexec (kwset, beg, --len, &kwsmatch);
		if (offset == (size_t) -1)
		  break;
		try = beg + offset;
		len = kwsmatch.size[0];
	      }
	    else if (!start_ptr)
	      goto success;
	    else
	      goto success_in_beg_and_len;
	  } /* for (try) */
      else
	goto success;
    } /* for (beg in buf) */

 failure:
  ret_val = -1;
  goto out;

 success:
  if ((end = memchr (beg + len, eol, (buf + size) - (beg + len))) != NULL)
    end++;
  else
    end = buf + size;
  while (buf < beg && beg[-1] != eol)
    --beg;
  len = end - beg;
 success_in_beg_and_len:
  *match_size = len;
  ret_val = beg - buf;
 out:
  return ret_val;
}
#endif /* defined(GREP_PROGRAM) || defined(FGREP_PROGRAM) */

#ifdef GREP_PROGRAM
#if HAVE_LIBPCRE
/* Compiled internal form of a Perl regular expression.  */
static pcre *cre;

/* Additional information about the pattern.  */
static pcre_extra *extra;
#endif

COMPILE_FCT(Pcompile)
{
#if !HAVE_LIBPCRE
  error (EXIT_TROUBLE, 0, "%s",
	 _("support for the -P option is not compiled into "
	   "this --disable-perl-regexp binary"));
#else
  int e;
  char const *ep;
  char *re = xmalloc (4 * size + 7);
  int flags = PCRE_MULTILINE | (match_icase ? PCRE_CASELESS : 0);
  char const *patlim = pattern + size;
  char *n = re;
  char const *p;
  char const *pnul;

  /* FIXME: Remove these restrictions.  */
  if (memchr(pattern, '\n', size))
    error (EXIT_TROUBLE, 0, _("the -P option only supports a single pattern"));

  *n = '\0';
  if (match_lines)
    strcpy (n, "^(");
  if (match_words)
    strcpy (n, "\\b(");
  n += strlen (n);

  /* The PCRE interface doesn't allow NUL bytes in the pattern, so
     replace each NUL byte in the pattern with the four characters
     "\000", removing a preceding backslash if there are an odd
     number of backslashes before the NUL.

     FIXME: This method does not work with some multibyte character
     encodings, notably Shift-JIS, where a multibyte character can end
     in a backslash byte.  */
  for (p = pattern; (pnul = memchr (p, '\0', patlim - p)); p = pnul + 1)
    {
      memcpy (n, p, pnul - p);
      n += pnul - p;
      for (p = pnul; pattern < p && p[-1] == '\\'; p--)
	continue;
      n -= (pnul - p) & 1;
      strcpy (n, "\\000");
      n += 4;
    }

  memcpy (n, p, patlim - p);
  n += patlim - p;
  *n = '\0';
  if (match_words)
    strcpy (n, ")\\b");
  if (match_lines)
    strcpy (n, ")$");

  cre = pcre_compile (re, flags, &ep, &e, pcre_maketables ());
  if (!cre)
    error (EXIT_TROUBLE, 0, "%s", ep);

  extra = pcre_study (cre, 0, &ep);
  if (ep)
    error (EXIT_TROUBLE, 0, "%s", ep);

  free (re);
#endif
}

EXECUTE_FCT(Pexecute)
{
#if !HAVE_LIBPCRE
  abort ();
  return -1;
#else
  /* This array must have at least two elements; everything after that
     is just for performance improvement in pcre_exec.  */
  int sub[300];

  const char *line_buf, *line_end, *line_next;
  int e = PCRE_ERROR_NOMATCH;
  ptrdiff_t start_ofs = start_ptr ? start_ptr - buf : 0;

  /* PCRE can't limit the matching to single lines, therefore we have to
     match each line in the buffer separately.  */
  for (line_next = buf;
       e == PCRE_ERROR_NOMATCH && line_next < buf + size;
       start_ofs -= line_next - line_buf)
    {
      line_buf = line_next;
      line_end = memchr (line_buf, eolbyte, (buf + size) - line_buf);
      if (line_end == NULL)
        line_next = line_end = buf + size;
      else
        line_next = line_end + 1;

      if (start_ptr && start_ptr >= line_end)
        continue;

      e = pcre_exec (cre, extra, line_buf, line_end - line_buf,
                     start_ofs < 0 ? 0 : start_ofs, 0,
                     sub, sizeof sub / sizeof *sub);
    }

  if (e <= 0)
    {
      switch (e)
	{
	case PCRE_ERROR_NOMATCH:
	  return -1;

	case PCRE_ERROR_NOMEMORY:
	  error (EXIT_TROUBLE, 0, _("memory exhausted"));

	default:
	  abort ();
	}
    }
  else
    {
      /* Narrow down to the line we've found.  */
      char const *beg = line_buf + sub[0];
      char const *end = line_buf + sub[1];
      char const *buflim = buf + size;
      char eol = eolbyte;
      if (!start_ptr)
	{
	  /* FIXME: The case when '\n' is not found indicates a bug:
	     Since grep is line oriented, the match should never contain
	     a newline, so there _must_ be a newline following.
	   */
	  if (!(end = memchr (end, eol, buflim - end)))
	    end = buflim;
	  else
	    end++;
	  while (buf < beg && beg[-1] != eol)
	    --beg;
	}

      *match_size = end - beg;
      return beg - buf;
    }
#endif
}

struct matcher const matchers[] = {
  { "default", Gcompile, EGexecute },
  { "grep",    Gcompile, EGexecute },
  { "egrep",   Ecompile, EGexecute },
  { "awk",     Acompile, EGexecute },
  { "fgrep",   Fcompile, Fexecute },
  { "perl",    Pcompile, Pexecute },
  { "", 0, 0 },
};
#endif /* GREP_PROGRAM */

Testing negative cases!
Testing 0 (with abstract condition) ENVIS_NEG
Iteration 0
Running test command:
/home/ubuntu/spr-fast/tools/grep-test.py /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-deccad69-db9d6340/tempworkdir2/src /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-deccad69-db9d6340/tempworkdir2/tests /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-deccad69-db9d6340/tempworkdir2 0  > __res
Opening:/home/ubuntu/spr-fast/tests/corebench/grep/grep-case-deccad69-db9d6340/tempworkdir2/neg.tmp!
NegativeBRANCH RECORD/home/ubuntu/spr-fast/tests/corebench/grep/grep-case-deccad69-db9d6340/tempworkdir2/neg.tmp!
APPENDING TO ISNEG:/home/ubuntu/spr-fast/tests/corebench/grep/grep-case-deccad69-db9d6340/tempworkdir2/neg.tmp!
Running test command:
/home/ubuntu/spr-fast/tools/grep-test.py /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-deccad69-db9d6340/tempworkdir2/src /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-deccad69-db9d6340/tempworkdir2/tests /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-deccad69-db9d6340/tempworkdir2 0  > __res
CondTester, Testing instance id 13:
//src_file:src/search.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
/* search.c - searching subroutines using dfa, kwset and regex for grep.
   Copyright 1992, 1998, 2000, 2007, 2009-2010 Free Software Foundation, Inc.

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 3, or (at your option)
   any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program; if not, write to the Free Software
   Foundation, Inc., 51 Franklin Street - Fifth Floor, Boston, MA
   02110-1301, USA.  */

/* Written August 1992 by Mike Haertel. */

#include <config.h>

#include <sys/types.h>

#include "mbsupport.h"
#ifdef MBS_SUPPORT
/* We can handle multibyte strings. */
# include <wchar.h>
# include <wctype.h>
#endif

#include "system.h"
#include "grep.h"
#ifndef FGREP_PROGRAM
# include <regex.h>
# include "dfa.h"
#endif
#include "kwset.h"
#include "error.h"
#include "xalloc.h"
#ifdef HAVE_LIBPCRE
# include <pcre.h>
#endif

#define NCHAR (UCHAR_MAX + 1)

/* For -w, we also consider _ to be word constituent.  */
#define WCHAR(C) (ISALNUM(C) || (C) == '_')

/* KWset compiled pattern.  For Ecompile and Gcompile, we compile
   a list of strings, at least one of which is known to occur in
   any string matching the regexp. */
static kwset_t kwset;

static void
kwsinit (void)
{
  static char trans[NCHAR];
  int i;

  if (match_icase && MB_CUR_MAX == 1)
    {
      for (i = 0; i < NCHAR; ++i)
        trans[i] = TOLOWER (i);

      kwset = kwsalloc (trans);
    }
  else
    kwset = kwsalloc (NULL);

  if (!kwset)
    xalloc_die ();
}

#ifdef MBS_SUPPORT
/* Convert the *N-byte string, BEG, to lowercase, and write the
   NUL-terminated result into malloc'd storage.  Upon success, set *N
   to the length (in bytes) of the resulting string (not including the
   trailing NUL byte), and return a pointer to the lowercase string.
   Upon memory allocation failure, this function exits.

   Note that while this function returns a pointer to malloc'd storage,
   the caller must not free it, since this function retains a pointer
   to the buffer and reuses it on any subsequent call.  As a consequence,
   this function is not thread-safe.  */
static char *
mbtolower (const char *beg, size_t *n)
{
  static char *out;
  static size_t outalloc;
  size_t outlen, mb_cur_max;
  mbstate_t is, os;
  const char *end;
  char *p;

  if (*n > outalloc)
    {
      out = xrealloc (out, *n);
      outalloc = *n;
    }

  memset (&is, 0, sizeof (is));
  memset (&os, 0, sizeof (os));
  end = beg + *n;

  mb_cur_max = MB_CUR_MAX;
  p = out;
  outlen = 0;
  while (beg < end)
    {
      wchar_t wc;
      size_t mbclen = mbrtowc(&wc, beg, end - beg, &is);
      if (outlen + mb_cur_max >= outalloc)
        {
          out = x2nrealloc (out, &outalloc, 1);
          p = out + outlen;
        }

      if (mbclen == (size_t) -1 || mbclen == (size_t) -2 || mbclen == 0)
        {
          /* An invalid sequence, or a truncated multi-octet character.
             We treat it as a single-octet character.  */
          *p++ = *beg++;
          outlen++;
          memset (&is, 0, sizeof (is));
          memset (&os, 0, sizeof (os));
        }
      else
        {
          beg += mbclen;
          mbclen = wcrtomb (p, towlower ((wint_t) wc), &os);
          p += mbclen;
          outlen += mbclen;
        }
    }

  *n = p - out;
  *p++ = 0;
  return out;
}
#endif


#ifndef FGREP_PROGRAM
/* DFA compiled regexp. */
static struct dfa dfa;

/* The Regex compiled patterns.  */
static struct patterns
{
  /* Regex compiled regexp. */
  struct re_pattern_buffer regexbuf;
  struct re_registers regs; /* This is here on account of a BRAIN-DEAD
			       Q@#%!# library interface in regex.c.  */
} patterns0;

struct patterns *patterns;
size_t pcount;

void
dfaerror (char const *mesg)
{
  error (EXIT_TROUBLE, 0, "%s", mesg);
}

/* Number of compiled fixed strings known to exactly match the regexp.
   If kwsexec returns < kwset_exact_matches, then we don't need to
   call the regexp matcher at all. */
static int kwset_exact_matches;

static char const *
kwsincr_case (const char *must)
{
  const char *buf;
  size_t n;

  n = strlen (must);
#ifdef MBS_SUPPORT
  if (match_icase && MB_CUR_MAX > 1)
    buf = mbtolower (must, &n);
  else
#endif
    buf = must;
  return kwsincr (kwset, buf, n);
}

/* If the DFA turns out to have some set of fixed strings one of
   which must occur in the match, then we build a kwset matcher
   to find those strings, and thus quickly filter out impossible
   matches. */
static void
kwsmusts (void)
{
  struct dfamust const *dm;
  char const *err;

  if (dfa.musts)
    {
      kwsinit ();
      /* First, we compile in the substrings known to be exact
	 matches.  The kwset matcher will return the index
	 of the matching string that it chooses. */
      for (dm = dfa.musts; dm; dm = dm->next)
	{
	  if (!dm->exact)
	    continue;
	  ++kwset_exact_matches;
	  if ((err = kwsincr_case (dm->must)) != NULL)
	    error (EXIT_TROUBLE, 0, "%s", err);
	}
      /* Now, we compile the substrings that will require
	 the use of the regexp matcher.  */
      for (dm = dfa.musts; dm; dm = dm->next)
	{
	  if (dm->exact)
	    continue;
	  if ((err = kwsincr_case (dm->must)) != NULL)
	    error (EXIT_TROUBLE, 0, "%s", err);
	}
      if ((err = kwsprep (kwset)) != NULL)
	error (EXIT_TROUBLE, 0, "%s", err);
    }
}
#endif /* !FGREP_PROGRAM */

#ifdef MBS_SUPPORT

static bool
is_mb_middle(const char **good, const char *buf, const char *end)
{
  const char *p = *good;
  const char *prev = p;
  mbstate_t cur_state;

  /* TODO: can be optimized for UTF-8.  */
  memset(&cur_state, 0, sizeof(mbstate_t));
  while (p < buf)
    {
      size_t mbclen = mbrlen(p, end - p, &cur_state);

      /* Store the beginning of the previous complete multibyte character.  */
      if (mbclen != (size_t) -2)
        prev = p;

      if (mbclen == (size_t) -1 || mbclen == (size_t) -2 || mbclen == 0)
	{
	  /* An invalid sequence, or a truncated multibyte character.
	     We treat it as a single byte character.  */
	  mbclen = 1;
	}
      p += mbclen;
    }

  *good = prev;
  return p > buf;
}
#endif /* MBS_SUPPORT */

#if defined(GREP_PROGRAM) || defined(EGREP_PROGRAM)
#ifdef EGREP_PROGRAM
COMPILE_FCT(Ecompile)
{
  reg_syntax_t syntax_bits = RE_SYNTAX_POSIX_EGREP;
#else
/* No __VA_ARGS__ in C89.  So we have to do it this way.  */
static COMPILE_RET
GEAcompile (char const *pattern, size_t size, reg_syntax_t syntax_bits)
{
#endif /* EGREP_PROGRAM */
  const char *err;
  const char *p, *sep;
  size_t total = size;
  char *motif;

  if (match_icase)
    syntax_bits |= RE_ICASE;
  re_set_syntax (syntax_bits);
  dfasyntax (syntax_bits, match_icase, eolbyte);

  /* For GNU regex compiler we have to pass the patterns separately to detect
     errors like "[\nallo\n]\n".  The patterns here are "[", "allo" and "]"
     GNU regex should have raise a syntax error.  The same for backref, where
     the backref should have been local to each pattern.  */
  p = pattern;
  do
    {
      size_t len;
      sep = memchr (p, '\n', total);
      if (sep)
	{
	  len = sep - p;
	  sep++;
	  total -= (len + 1);
	}
      else
	{
	  len = total;
	  total = 0;
	}

      patterns = realloc (patterns, (pcount + 1) * sizeof (*patterns));
      if (patterns == NULL)
	error (EXIT_TROUBLE, errno, _("memory exhausted"));
      patterns[pcount] = patterns0;

      if ((err = re_compile_pattern (p, len,
				    &(patterns[pcount].regexbuf))) != NULL)
	error (EXIT_TROUBLE, 0, "%s", err);
      pcount++;

      p = sep;
    } while (sep && total != 0);

  /* In the match_words and match_lines cases, we use a different pattern
     for the DFA matcher that will quickly throw out cases that won't work.
     Then if DFA succeeds we do some hairy stuff using the regex matcher
     to decide whether the match should really count. */
  if (match_words || match_lines)
    {
      static char const line_beg_no_bk[] = "^(";
      static char const line_end_no_bk[] = ")$";
      static char const word_beg_no_bk[] = "(^|[^[:alnum:]_])(";
      static char const word_end_no_bk[] = ")([^[:alnum:]_]|$)";
#ifdef EGREP_PROGRAM
# define IF_BK(x, y) (y)
      char *n = xmalloc (sizeof word_beg_no_bk - 1 + size + sizeof word_end_no_bk);
#else
      static char const line_beg_bk[] = "^\\(";
      static char const line_end_bk[] = "\\)$";
      static char const word_beg_bk[] = "\\(^\\|[^[:alnum:]_]\\)\\(";
      static char const word_end_bk[] = "\\)\\([^[:alnum:]_]\\|$\\)";
      int bk = !(syntax_bits & RE_NO_BK_PARENS);
# define IF_BK(x, y) ((bk) ? (x) : (y))
      char *n = xmalloc (sizeof word_beg_bk - 1 + size + sizeof word_end_bk);
#endif /* EGREP_PROGRAM */

      strcpy (n, match_lines ? IF_BK(line_beg_bk, line_beg_no_bk)
			     : IF_BK(word_beg_bk, word_beg_no_bk));
      total = strlen(n);
      memcpy (n + total, pattern, size);
      total += size;
      strcpy (n + total, match_lines ? IF_BK(line_end_bk, line_end_no_bk)
				     : IF_BK(word_end_bk, word_end_no_bk));
      total += strlen (n + total);
      pattern = motif = n;
      size = total;
    }
  else
    motif = NULL;

  dfacomp (pattern, size, &dfa, 1);
  kwsmusts ();

  free(motif);
}

#ifndef EGREP_PROGRAM
COMPILE_FCT(Gcompile)
{
  return GEAcompile (pattern, size,
		     RE_SYNTAX_GREP | RE_HAT_LISTS_NOT_NEWLINE);
}

COMPILE_FCT(Acompile)
{
  return GEAcompile (pattern, size, RE_SYNTAX_AWK);
}

COMPILE_FCT(Ecompile)
{
  return GEAcompile (pattern, size, RE_SYNTAX_POSIX_EGREP);
}
#endif /* !EGREP_PROGRAM */

EXECUTE_FCT(EGexecute)
{
  char const *buflim, *beg, *end, *match, *best_match, *mb_start;
  char eol = eolbyte;
  int backref, start, len, best_len;
  struct kwsmatch kwsm;
  size_t i, ret_val;
#ifdef MBS_SUPPORT
  if (MB_CUR_MAX > 1)
    {
      if (match_icase)
        {
          /* mbtolower adds a NUL byte at the end.  That will provide
	     space for the sentinel byte dfaexec may add.  */
          char *case_buf = mbtolower (buf, &size);
	  if (start_ptr)
	    start_ptr = case_buf + (start_ptr - buf);
          buf = case_buf;
        }
    }
#endif /* MBS_SUPPORT */

  mb_start = buf;
  buflim = buf + size;

  for (beg = end = buf; end < buflim; beg = end)
    {
      if (!start_ptr)
	{
	  /* We don't care about an exact match.  */
	  if (kwset)
	    {
	      /* Find a possible match using the KWset matcher. */
	      size_t offset = kwsexec (kwset, beg, buflim - beg, &kwsm);
	      if (offset == (size_t) -1)
		goto failure;
	      beg += offset;
	      /* Narrow down to the line containing the candidate, and
		 run it through DFA. */
	      if ((end = memchr(beg, eol, buflim - beg)) != NULL)
	        end++;
              else
                end = buflim;
	      match = beg;
	      while (beg > buf && beg[-1] != eol)
		--beg;
	      if (kwsm.index < kwset_exact_matches)
                {
#ifdef MBS_SUPPORT
                  if (mb_start < beg)
                    mb_start = beg;
                  if (MB_CUR_MAX == 1 || !is_mb_middle (&mb_start, match, buflim))
#endif
                    goto success;
                }
	      if (dfaexec (&dfa, beg, (char *) end, 0, NULL, &backref) == NULL)
		continue;
	    }
	  else
	    {
	      /* No good fixed strings; start with DFA. */
	      char const *next_beg = dfaexec (&dfa, beg, (char *) buflim,
					      0, NULL, &backref);
	      if (next_beg == NULL)
		break;
	      /* Narrow down to the line we've found. */
	      beg = next_beg;
	      if ((end = memchr(beg, eol, buflim - beg)) != NULL)
	        end++;
              else
                end = buflim;
	      while (beg > buf && beg[-1] != eol)
		--beg;
	    }
	  /* Successful, no backreferences encountered! */
	  if (!backref)
	    goto success;
	}
      else
	{
	  /* We are looking for the leftmost (then longest) exact match.
	     We will go through the outer loop only once.  */
	  beg = start_ptr;
	  end = buflim;
	}

      /* If we've made it to this point, this means DFA has seen
	 a probable match, and we need to run it through Regex. */
      best_match = end;
      best_len = 0;
      for (i = 0; i < pcount; i++)
	{
	  patterns[i].regexbuf.not_eol = 0;
	  if (0 <= (start = re_search (&(patterns[i].regexbuf),
				       buf, end - buf - 1,
				       beg - buf, end - beg - 1,
				       &(patterns[i].regs))))
	    {
	      len = patterns[i].regs.end[0] - start;
	      match = buf + start;
	      if (match > best_match)
		continue;
	      if (start_ptr && !match_words)
		goto assess_pattern_match;
	      if ((!match_lines && !match_words)
		  || (match_lines && len == end - beg - 1))
		{
		  match = beg;
		  len = end - beg;
		  goto assess_pattern_match;
		}
	      /* If -w, check if the match aligns with word boundaries.
		 We do this iteratively because:
		 (a) the line may contain more than one occurence of the
		 pattern, and
		 (b) Several alternatives in the pattern might be valid at a
		 given point, and we may need to consider a shorter one to
		 find a word boundary.  */
	      if (match_words)
		while (match <= best_match)
		  {
		    if ((match == buf || !WCHAR ((unsigned char) match[-1]))
			&& (len == end - beg - 1
			    || !WCHAR ((unsigned char) match[len])))
		      goto assess_pattern_match;
		    if (len > 0)
		      {
			/* Try a shorter length anchored at the same place. */
			--len;
			patterns[i].regexbuf.not_eol = 1;
			len = re_match (&(patterns[i].regexbuf),
					buf, match + len - beg, match - buf,
					&(patterns[i].regs));
		      }
		    if (len <= 0)
		      {
			/* Try looking further on. */
			if (match == end - 1)
			  break;
			match++;
			patterns[i].regexbuf.not_eol = 0;
			start = re_search (&(patterns[i].regexbuf),
					   buf, end - buf - 1,
					   match - buf, end - match - 1,
					   &(patterns[i].regs));
			if (start < 0)
			  break;
			len = patterns[i].regs.end[0] - start;
			match = buf + start;
		      }
		  } /* while (match <= best_match) */
	      continue;
	    assess_pattern_match:
	      if (!start_ptr)
		{
		  /* Good enough for a non-exact match.
		     No need to look at further patterns, if any.  */
		  beg = match;
		  goto success_in_len;
		}
	      if (match < best_match || (match == best_match && len > best_len))
		{
		  /* Best exact match:  leftmost, then longest.  */
		  best_match = match;
		  best_len = len;
		}
	    } /* if re_search >= 0 */
	} /* for Regex patterns.  */
	if (best_match < end)
	  {
	    /* We have found an exact match.  We were just
	       waiting for the best one (leftmost then longest).  */
	    beg = best_match;
	    len = best_len;
	    goto success_in_len;
	  }
    } /* for (beg = end ..) */

 failure:
  ret_val = -1;
  goto out;

 success:
  len = end - beg;
 success_in_len:
  *match_size = len;
  ret_val = beg - buf;
 out:
  return ret_val;
}
#endif /* defined(GREP_PROGRAM) || defined(EGREP_PROGRAM) */

#if defined(GREP_PROGRAM) || defined(FGREP_PROGRAM)
COMPILE_FCT(Fcompile)
{
  char const *beg, *end, *lim, *err, *pat;
  size_t psize;

  kwsinit ();
  psize = size;
  if (match_icase && MB_CUR_MAX > 1)
    pat = mbtolower (pattern, &psize);
  else
    pat = pattern;

  beg = pat;
  do
    {
      for (lim = beg;; ++lim)
	{
	  end = lim;
	  if (lim >= pat + psize)
	    break;
	 if (*lim == '\n')
	   {
	     lim++;
	     break;
	   }
#if HAVE_DOS_FILE_CONTENTS
	 if (*lim == '\r' && lim + 1 < pat + psize && lim[1] == '\n')
	   {
	     lim += 2;
	     break;
	   }
#endif
	}

      if ((err = kwsincr (kwset, beg, end - beg)) != NULL)
	error (EXIT_TROUBLE, 0, "%s", err);
      beg = lim;
    }
  while (beg < pat + psize);

  if ((err = kwsprep (kwset)) != NULL)
    error (EXIT_TROUBLE, 0, "%s", err);
}

EXECUTE_FCT(Fexecute)
{
  char const *beg, *try, *end, *mb_start;
  size_t len;
  char eol = eolbyte;
  struct kwsmatch kwsmatch;
  size_t ret_val;
#ifdef MBS_SUPPORT
  if (MB_CUR_MAX > 1)
    {
      if (match_icase)
        {
          char *case_buf = mbtolower (buf, &size);
	  if (start_ptr)
	    start_ptr = case_buf + (start_ptr - buf);
          buf = case_buf;
        }
    }
#endif /* MBS_SUPPORT */

  for (mb_start = beg = start_ptr ? start_ptr : buf; beg <= buf + size; beg++)
    {
      size_t offset = kwsexec (kwset, beg, buf + size - beg, &kwsmatch);
      if (offset == (size_t) -1)
	goto failure;
#ifdef MBS_SUPPORT
      
//Patch 0:
if (((__ctype_get_mb_cur_max()) > 1 && is_mb_middle(&mb_start, beg + offset, buf + size)) || (__is_neg(17, &(buf), sizeof (buf), &(size), sizeof (size), &(beg), sizeof (beg), &(mb_start), sizeof (mb_start), &(offset), sizeof (offset), &(kwset), sizeof (kwset), &(start_ptr), sizeof (start_ptr), &(len), sizeof (len), &(match_words), sizeof (match_words), &(match_lines), sizeof (match_lines), &(eol), sizeof (eol), &(match_icase), sizeof (match_icase), &(try), sizeof (try), &(eolbyte), sizeof (eolbyte), &(ret_val), sizeof (ret_val), &(end), sizeof (end), &(match_size), sizeof (match_size)))) {
    beg = mb_start - 1;
    continue;
}

//CodeSeg 1:
#endif /* MBS_SUPPORT */
      beg += offset;
      len = kwsmatch.size[0];
      if (start_ptr && !match_words)
	goto success_in_beg_and_len;
      if (match_lines)
	{
	  if (beg > buf && beg[-1] != eol)
	    continue;
	  if (beg + len < buf + size && beg[len] != eol)
	    continue;
	  goto success;
	}
      else if (match_words)
	for (try = beg; len; )
	  {
	    if (try > buf && WCHAR((unsigned char) try[-1]))
	      break;
	    if (try + len < buf + size && WCHAR((unsigned char) try[len]))
	      {
		offset = kwsexec (kwset, beg, --len, &kwsmatch);
		if (offset == (size_t) -1)
		  break;
		try = beg + offset;
		len = kwsmatch.size[0];
	      }
	    else if (!start_ptr)
	      goto success;
	    else
	      goto success_in_beg_and_len;
	  } /* for (try) */
      else
	goto success;
    } /* for (beg in buf) */

 failure:
  ret_val = -1;
  goto out;

 success:
  if ((end = memchr (beg + len, eol, (buf + size) - (beg + len))) != NULL)
    end++;
  else
    end = buf + size;
  while (buf < beg && beg[-1] != eol)
    --beg;
  len = end - beg;
 success_in_beg_and_len:
  *match_size = len;
  ret_val = beg - buf;
 out:
  return ret_val;
}
#endif /* defined(GREP_PROGRAM) || defined(FGREP_PROGRAM) */

#ifdef GREP_PROGRAM
#if HAVE_LIBPCRE
/* Compiled internal form of a Perl regular expression.  */
static pcre *cre;

/* Additional information about the pattern.  */
static pcre_extra *extra;
#endif

COMPILE_FCT(Pcompile)
{
#if !HAVE_LIBPCRE
  error (EXIT_TROUBLE, 0, "%s",
	 _("support for the -P option is not compiled into "
	   "this --disable-perl-regexp binary"));
#else
  int e;
  char const *ep;
  char *re = xmalloc (4 * size + 7);
  int flags = PCRE_MULTILINE | (match_icase ? PCRE_CASELESS : 0);
  char const *patlim = pattern + size;
  char *n = re;
  char const *p;
  char const *pnul;

  /* FIXME: Remove these restrictions.  */
  if (memchr(pattern, '\n', size))
    error (EXIT_TROUBLE, 0, _("the -P option only supports a single pattern"));

  *n = '\0';
  if (match_lines)
    strcpy (n, "^(");
  if (match_words)
    strcpy (n, "\\b(");
  n += strlen (n);

  /* The PCRE interface doesn't allow NUL bytes in the pattern, so
     replace each NUL byte in the pattern with the four characters
     "\000", removing a preceding backslash if there are an odd
     number of backslashes before the NUL.

     FIXME: This method does not work with some multibyte character
     encodings, notably Shift-JIS, where a multibyte character can end
     in a backslash byte.  */
  for (p = pattern; (pnul = memchr (p, '\0', patlim - p)); p = pnul + 1)
    {
      memcpy (n, p, pnul - p);
      n += pnul - p;
      for (p = pnul; pattern < p && p[-1] == '\\'; p--)
	continue;
      n -= (pnul - p) & 1;
      strcpy (n, "\\000");
      n += 4;
    }

  memcpy (n, p, patlim - p);
  n += patlim - p;
  *n = '\0';
  if (match_words)
    strcpy (n, ")\\b");
  if (match_lines)
    strcpy (n, ")$");

  cre = pcre_compile (re, flags, &ep, &e, pcre_maketables ());
  if (!cre)
    error (EXIT_TROUBLE, 0, "%s", ep);

  extra = pcre_study (cre, 0, &ep);
  if (ep)
    error (EXIT_TROUBLE, 0, "%s", ep);

  free (re);
#endif
}

EXECUTE_FCT(Pexecute)
{
#if !HAVE_LIBPCRE
  abort ();
  return -1;
#else
  /* This array must have at least two elements; everything after that
     is just for performance improvement in pcre_exec.  */
  int sub[300];

  const char *line_buf, *line_end, *line_next;
  int e = PCRE_ERROR_NOMATCH;
  ptrdiff_t start_ofs = start_ptr ? start_ptr - buf : 0;

  /* PCRE can't limit the matching to single lines, therefore we have to
     match each line in the buffer separately.  */
  for (line_next = buf;
       e == PCRE_ERROR_NOMATCH && line_next < buf + size;
       start_ofs -= line_next - line_buf)
    {
      line_buf = line_next;
      line_end = memchr (line_buf, eolbyte, (buf + size) - line_buf);
      if (line_end == NULL)
        line_next = line_end = buf + size;
      else
        line_next = line_end + 1;

      if (start_ptr && start_ptr >= line_end)
        continue;

      e = pcre_exec (cre, extra, line_buf, line_end - line_buf,
                     start_ofs < 0 ? 0 : start_ofs, 0,
                     sub, sizeof sub / sizeof *sub);
    }

  if (e <= 0)
    {
      switch (e)
	{
	case PCRE_ERROR_NOMATCH:
	  return -1;

	case PCRE_ERROR_NOMEMORY:
	  error (EXIT_TROUBLE, 0, _("memory exhausted"));

	default:
	  abort ();
	}
    }
  else
    {
      /* Narrow down to the line we've found.  */
      char const *beg = line_buf + sub[0];
      char const *end = line_buf + sub[1];
      char const *buflim = buf + size;
      char eol = eolbyte;
      if (!start_ptr)
	{
	  /* FIXME: The case when '\n' is not found indicates a bug:
	     Since grep is line oriented, the match should never contain
	     a newline, so there _must_ be a newline following.
	   */
	  if (!(end = memchr (end, eol, buflim - end)))
	    end = buflim;
	  else
	    end++;
	  while (buf < beg && beg[-1] != eol)
	    --beg;
	}

      *match_size = end - beg;
      return beg - buf;
    }
#endif
}

struct matcher const matchers[] = {
  { "default", Gcompile, EGexecute },
  { "grep",    Gcompile, EGexecute },
  { "egrep",   Ecompile, EGexecute },
  { "awk",     Acompile, EGexecute },
  { "fgrep",   Fcompile, Fexecute },
  { "perl",    Pcompile, Pexecute },
  { "", 0, 0 },
};
#endif /* GREP_PROGRAM */

Testing negative cases!
Testing 0 (with abstract condition) ENVIS_NEG
Iteration 0
Running test command:
/home/ubuntu/spr-fast/tools/grep-test.py /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-deccad69-db9d6340/tempworkdir2/src /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-deccad69-db9d6340/tempworkdir2/tests /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-deccad69-db9d6340/tempworkdir2 0  > __res
Opening:/home/ubuntu/spr-fast/tests/corebench/grep/grep-case-deccad69-db9d6340/tempworkdir2/neg.tmp!
NegativeBRANCH RECORD/home/ubuntu/spr-fast/tests/corebench/grep/grep-case-deccad69-db9d6340/tempworkdir2/neg.tmp!
Not caught by the negative case, give up!
APPENDING TO ISNEG:/home/ubuntu/spr-fast/tests/corebench/grep/grep-case-deccad69-db9d6340/tempworkdir2/neg.tmp!
Running test command:
/home/ubuntu/spr-fast/tools/grep-test.py /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-deccad69-db9d6340/tempworkdir2/src /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-deccad69-db9d6340/tempworkdir2/tests /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-deccad69-db9d6340/tempworkdir2 0  > __res
CondTester, Testing instance id 14:
//src_file:src/search.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
/* search.c - searching subroutines using dfa, kwset and regex for grep.
   Copyright 1992, 1998, 2000, 2007, 2009-2010 Free Software Foundation, Inc.

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 3, or (at your option)
   any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program; if not, write to the Free Software
   Foundation, Inc., 51 Franklin Street - Fifth Floor, Boston, MA
   02110-1301, USA.  */

/* Written August 1992 by Mike Haertel. */

#include <config.h>

#include <sys/types.h>

#include "mbsupport.h"
#ifdef MBS_SUPPORT
/* We can handle multibyte strings. */
# include <wchar.h>
# include <wctype.h>
#endif

#include "system.h"
#include "grep.h"
#ifndef FGREP_PROGRAM
# include <regex.h>
# include "dfa.h"
#endif
#include "kwset.h"
#include "error.h"
#include "xalloc.h"
#ifdef HAVE_LIBPCRE
# include <pcre.h>
#endif

#define NCHAR (UCHAR_MAX + 1)

/* For -w, we also consider _ to be word constituent.  */
#define WCHAR(C) (ISALNUM(C) || (C) == '_')

/* KWset compiled pattern.  For Ecompile and Gcompile, we compile
   a list of strings, at least one of which is known to occur in
   any string matching the regexp. */
static kwset_t kwset;

static void
kwsinit (void)
{
  static char trans[NCHAR];
  int i;

  if (match_icase && MB_CUR_MAX == 1)
    {
      for (i = 0; i < NCHAR; ++i)
        trans[i] = TOLOWER (i);

      kwset = kwsalloc (trans);
    }
  else
    kwset = kwsalloc (NULL);

  if (!kwset)
    xalloc_die ();
}

#ifdef MBS_SUPPORT
/* Convert the *N-byte string, BEG, to lowercase, and write the
   NUL-terminated result into malloc'd storage.  Upon success, set *N
   to the length (in bytes) of the resulting string (not including the
   trailing NUL byte), and return a pointer to the lowercase string.
   Upon memory allocation failure, this function exits.

   Note that while this function returns a pointer to malloc'd storage,
   the caller must not free it, since this function retains a pointer
   to the buffer and reuses it on any subsequent call.  As a consequence,
   this function is not thread-safe.  */
static char *
mbtolower (const char *beg, size_t *n)
{
  static char *out;
  static size_t outalloc;
  size_t outlen, mb_cur_max;
  mbstate_t is, os;
  const char *end;
  char *p;

  if (*n > outalloc)
    {
      out = xrealloc (out, *n);
      outalloc = *n;
    }

  memset (&is, 0, sizeof (is));
  memset (&os, 0, sizeof (os));
  end = beg + *n;

  mb_cur_max = MB_CUR_MAX;
  p = out;
  outlen = 0;
  while (beg < end)
    {
      wchar_t wc;
      size_t mbclen = mbrtowc(&wc, beg, end - beg, &is);
      if (outlen + mb_cur_max >= outalloc)
        {
          out = x2nrealloc (out, &outalloc, 1);
          p = out + outlen;
        }

      if (mbclen == (size_t) -1 || mbclen == (size_t) -2 || mbclen == 0)
        {
          /* An invalid sequence, or a truncated multi-octet character.
             We treat it as a single-octet character.  */
          *p++ = *beg++;
          outlen++;
          memset (&is, 0, sizeof (is));
          memset (&os, 0, sizeof (os));
        }
      else
        {
          beg += mbclen;
          mbclen = wcrtomb (p, towlower ((wint_t) wc), &os);
          p += mbclen;
          outlen += mbclen;
        }
    }

  *n = p - out;
  *p++ = 0;
  return out;
}
#endif


#ifndef FGREP_PROGRAM
/* DFA compiled regexp. */
static struct dfa dfa;

/* The Regex compiled patterns.  */
static struct patterns
{
  /* Regex compiled regexp. */
  struct re_pattern_buffer regexbuf;
  struct re_registers regs; /* This is here on account of a BRAIN-DEAD
			       Q@#%!# library interface in regex.c.  */
} patterns0;

struct patterns *patterns;
size_t pcount;

void
dfaerror (char const *mesg)
{
  error (EXIT_TROUBLE, 0, "%s", mesg);
}

/* Number of compiled fixed strings known to exactly match the regexp.
   If kwsexec returns < kwset_exact_matches, then we don't need to
   call the regexp matcher at all. */
static int kwset_exact_matches;

static char const *
kwsincr_case (const char *must)
{
  const char *buf;
  size_t n;

  n = strlen (must);
#ifdef MBS_SUPPORT
  if (match_icase && MB_CUR_MAX > 1)
    buf = mbtolower (must, &n);
  else
#endif
    buf = must;
  return kwsincr (kwset, buf, n);
}

/* If the DFA turns out to have some set of fixed strings one of
   which must occur in the match, then we build a kwset matcher
   to find those strings, and thus quickly filter out impossible
   matches. */
static void
kwsmusts (void)
{
  struct dfamust const *dm;
  char const *err;

  if (dfa.musts)
    {
      kwsinit ();
      /* First, we compile in the substrings known to be exact
	 matches.  The kwset matcher will return the index
	 of the matching string that it chooses. */
      for (dm = dfa.musts; dm; dm = dm->next)
	{
	  if (!dm->exact)
	    continue;
	  ++kwset_exact_matches;
	  if ((err = kwsincr_case (dm->must)) != NULL)
	    error (EXIT_TROUBLE, 0, "%s", err);
	}
      /* Now, we compile the substrings that will require
	 the use of the regexp matcher.  */
      for (dm = dfa.musts; dm; dm = dm->next)
	{
	  if (dm->exact)
	    continue;
	  if ((err = kwsincr_case (dm->must)) != NULL)
	    error (EXIT_TROUBLE, 0, "%s", err);
	}
      if ((err = kwsprep (kwset)) != NULL)
	error (EXIT_TROUBLE, 0, "%s", err);
    }
}
#endif /* !FGREP_PROGRAM */

#ifdef MBS_SUPPORT

static bool
is_mb_middle(const char **good, const char *buf, const char *end)
{
  const char *p = *good;
  const char *prev = p;
  mbstate_t cur_state;

  /* TODO: can be optimized for UTF-8.  */
  memset(&cur_state, 0, sizeof(mbstate_t));
  while (p < buf)
    {
      size_t mbclen = mbrlen(p, end - p, &cur_state);

      /* Store the beginning of the previous complete multibyte character.  */
      if (mbclen != (size_t) -2)
        prev = p;

      if (mbclen == (size_t) -1 || mbclen == (size_t) -2 || mbclen == 0)
	{
	  /* An invalid sequence, or a truncated multibyte character.
	     We treat it as a single byte character.  */
	  mbclen = 1;
	}
      p += mbclen;
    }

  *good = prev;
  return p > buf;
}
#endif /* MBS_SUPPORT */

#if defined(GREP_PROGRAM) || defined(EGREP_PROGRAM)
#ifdef EGREP_PROGRAM
COMPILE_FCT(Ecompile)
{
  reg_syntax_t syntax_bits = RE_SYNTAX_POSIX_EGREP;
#else
/* No __VA_ARGS__ in C89.  So we have to do it this way.  */
static COMPILE_RET
GEAcompile (char const *pattern, size_t size, reg_syntax_t syntax_bits)
{
#endif /* EGREP_PROGRAM */
  const char *err;
  const char *p, *sep;
  size_t total = size;
  char *motif;

  if (match_icase)
    syntax_bits |= RE_ICASE;
  re_set_syntax (syntax_bits);
  dfasyntax (syntax_bits, match_icase, eolbyte);

  /* For GNU regex compiler we have to pass the patterns separately to detect
     errors like "[\nallo\n]\n".  The patterns here are "[", "allo" and "]"
     GNU regex should have raise a syntax error.  The same for backref, where
     the backref should have been local to each pattern.  */
  p = pattern;
  do
    {
      size_t len;
      sep = memchr (p, '\n', total);
      if (sep)
	{
	  len = sep - p;
	  sep++;
	  total -= (len + 1);
	}
      else
	{
	  len = total;
	  total = 0;
	}

      patterns = realloc (patterns, (pcount + 1) * sizeof (*patterns));
      if (patterns == NULL)
	error (EXIT_TROUBLE, errno, _("memory exhausted"));
      patterns[pcount] = patterns0;

      if ((err = re_compile_pattern (p, len,
				    &(patterns[pcount].regexbuf))) != NULL)
	error (EXIT_TROUBLE, 0, "%s", err);
      pcount++;

      p = sep;
    } while (sep && total != 0);

  /* In the match_words and match_lines cases, we use a different pattern
     for the DFA matcher that will quickly throw out cases that won't work.
     Then if DFA succeeds we do some hairy stuff using the regex matcher
     to decide whether the match should really count. */
  if (match_words || match_lines)
    {
      static char const line_beg_no_bk[] = "^(";
      static char const line_end_no_bk[] = ")$";
      static char const word_beg_no_bk[] = "(^|[^[:alnum:]_])(";
      static char const word_end_no_bk[] = ")([^[:alnum:]_]|$)";
#ifdef EGREP_PROGRAM
# define IF_BK(x, y) (y)
      char *n = xmalloc (sizeof word_beg_no_bk - 1 + size + sizeof word_end_no_bk);
#else
      static char const line_beg_bk[] = "^\\(";
      static char const line_end_bk[] = "\\)$";
      static char const word_beg_bk[] = "\\(^\\|[^[:alnum:]_]\\)\\(";
      static char const word_end_bk[] = "\\)\\([^[:alnum:]_]\\|$\\)";
      int bk = !(syntax_bits & RE_NO_BK_PARENS);
# define IF_BK(x, y) ((bk) ? (x) : (y))
      char *n = xmalloc (sizeof word_beg_bk - 1 + size + sizeof word_end_bk);
#endif /* EGREP_PROGRAM */

      strcpy (n, match_lines ? IF_BK(line_beg_bk, line_beg_no_bk)
			     : IF_BK(word_beg_bk, word_beg_no_bk));
      total = strlen(n);
      memcpy (n + total, pattern, size);
      total += size;
      strcpy (n + total, match_lines ? IF_BK(line_end_bk, line_end_no_bk)
				     : IF_BK(word_end_bk, word_end_no_bk));
      total += strlen (n + total);
      pattern = motif = n;
      size = total;
    }
  else
    motif = NULL;

  dfacomp (pattern, size, &dfa, 1);
  kwsmusts ();

  free(motif);
}

#ifndef EGREP_PROGRAM
COMPILE_FCT(Gcompile)
{
  return GEAcompile (pattern, size,
		     RE_SYNTAX_GREP | RE_HAT_LISTS_NOT_NEWLINE);
}

COMPILE_FCT(Acompile)
{
  return GEAcompile (pattern, size, RE_SYNTAX_AWK);
}

COMPILE_FCT(Ecompile)
{
  return GEAcompile (pattern, size, RE_SYNTAX_POSIX_EGREP);
}
#endif /* !EGREP_PROGRAM */

EXECUTE_FCT(EGexecute)
{
  char const *buflim, *beg, *end, *match, *best_match, *mb_start;
  char eol = eolbyte;
  int backref, start, len, best_len;
  struct kwsmatch kwsm;
  size_t i, ret_val;
#ifdef MBS_SUPPORT
  if (MB_CUR_MAX > 1)
    {
      if (match_icase)
        {
          /* mbtolower adds a NUL byte at the end.  That will provide
	     space for the sentinel byte dfaexec may add.  */
          char *case_buf = mbtolower (buf, &size);
	  if (start_ptr)
	    start_ptr = case_buf + (start_ptr - buf);
          buf = case_buf;
        }
    }
#endif /* MBS_SUPPORT */

  mb_start = buf;
  buflim = buf + size;

  for (beg = end = buf; end < buflim; beg = end)
    {
      if (!start_ptr)
	{
	  /* We don't care about an exact match.  */
	  if (kwset)
	    {
	      /* Find a possible match using the KWset matcher. */
	      size_t offset = kwsexec (kwset, beg, buflim - beg, &kwsm);
	      if (offset == (size_t) -1)
		goto failure;
	      beg += offset;
	      /* Narrow down to the line containing the candidate, and
		 run it through DFA. */
	      if ((end = memchr(beg, eol, buflim - beg)) != NULL)
	        end++;
              else
                end = buflim;
	      match = beg;
	      while (beg > buf && beg[-1] != eol)
		--beg;
	      if (kwsm.index < kwset_exact_matches)
                {
#ifdef MBS_SUPPORT
                  if (mb_start < beg)
                    mb_start = beg;
                  if (MB_CUR_MAX == 1 || !is_mb_middle (&mb_start, match, buflim))
#endif
                    goto success;
                }
	      if (dfaexec (&dfa, beg, (char *) end, 0, NULL, &backref) == NULL)
		continue;
	    }
	  else
	    {
	      /* No good fixed strings; start with DFA. */
	      char const *next_beg = dfaexec (&dfa, beg, (char *) buflim,
					      0, NULL, &backref);
	      if (next_beg == NULL)
		break;
	      /* Narrow down to the line we've found. */
	      beg = next_beg;
	      if ((end = memchr(beg, eol, buflim - beg)) != NULL)
	        end++;
              else
                end = buflim;
	      while (beg > buf && beg[-1] != eol)
		--beg;
	    }
	  /* Successful, no backreferences encountered! */
	  if (!backref)
	    goto success;
	}
      else
	{
	  /* We are looking for the leftmost (then longest) exact match.
	     We will go through the outer loop only once.  */
	  beg = start_ptr;
	  end = buflim;
	}

      /* If we've made it to this point, this means DFA has seen
	 a probable match, and we need to run it through Regex. */
      best_match = end;
      best_len = 0;
      for (i = 0; i < pcount; i++)
	{
	  patterns[i].regexbuf.not_eol = 0;
	  if (0 <= (start = re_search (&(patterns[i].regexbuf),
				       buf, end - buf - 1,
				       beg - buf, end - beg - 1,
				       &(patterns[i].regs))))
	    {
	      len = patterns[i].regs.end[0] - start;
	      match = buf + start;
	      if (match > best_match)
		continue;
	      if (start_ptr && !match_words)
		goto assess_pattern_match;
	      if ((!match_lines && !match_words)
		  || (match_lines && len == end - beg - 1))
		{
		  match = beg;
		  len = end - beg;
		  goto assess_pattern_match;
		}
	      /* If -w, check if the match aligns with word boundaries.
		 We do this iteratively because:
		 (a) the line may contain more than one occurence of the
		 pattern, and
		 (b) Several alternatives in the pattern might be valid at a
		 given point, and we may need to consider a shorter one to
		 find a word boundary.  */
	      if (match_words)
		while (match <= best_match)
		  {
		    if ((match == buf || !WCHAR ((unsigned char) match[-1]))
			&& (len == end - beg - 1
			    || !WCHAR ((unsigned char) match[len])))
		      goto assess_pattern_match;
		    if (len > 0)
		      {
			/* Try a shorter length anchored at the same place. */
			--len;
			patterns[i].regexbuf.not_eol = 1;
			len = re_match (&(patterns[i].regexbuf),
					buf, match + len - beg, match - buf,
					&(patterns[i].regs));
		      }
		    if (len <= 0)
		      {
			/* Try looking further on. */
			if (match == end - 1)
			  break;
			match++;
			patterns[i].regexbuf.not_eol = 0;
			start = re_search (&(patterns[i].regexbuf),
					   buf, end - buf - 1,
					   match - buf, end - match - 1,
					   &(patterns[i].regs));
			if (start < 0)
			  break;
			len = patterns[i].regs.end[0] - start;
			match = buf + start;
		      }
		  } /* while (match <= best_match) */
	      continue;
	    assess_pattern_match:
	      if (!start_ptr)
		{
		  /* Good enough for a non-exact match.
		     No need to look at further patterns, if any.  */
		  beg = match;
		  goto success_in_len;
		}
	      if (match < best_match || (match == best_match && len > best_len))
		{
		  /* Best exact match:  leftmost, then longest.  */
		  best_match = match;
		  best_len = len;
		}
	    } /* if re_search >= 0 */
	} /* for Regex patterns.  */
	if (best_match < end)
	  {
	    /* We have found an exact match.  We were just
	       waiting for the best one (leftmost then longest).  */
	    beg = best_match;
	    len = best_len;
	    goto success_in_len;
	  }
    } /* for (beg = end ..) */

 failure:
  ret_val = -1;
  goto out;

 success:
  len = end - beg;
 success_in_len:
  *match_size = len;
  ret_val = beg - buf;
 out:
  return ret_val;
}
#endif /* defined(GREP_PROGRAM) || defined(EGREP_PROGRAM) */

#if defined(GREP_PROGRAM) || defined(FGREP_PROGRAM)
COMPILE_FCT(Fcompile)
{
  char const *beg, *end, *lim, *err, *pat;
  size_t psize;

  kwsinit ();
  psize = size;
  if (match_icase && MB_CUR_MAX > 1)
    pat = mbtolower (pattern, &psize);
  else
    pat = pattern;

  beg = pat;
  do
    {
      for (lim = beg;; ++lim)
	{
	  end = lim;
	  if (lim >= pat + psize)
	    break;
	 if (*lim == '\n')
	   {
	     lim++;
	     break;
	   }
#if HAVE_DOS_FILE_CONTENTS
	 if (*lim == '\r' && lim + 1 < pat + psize && lim[1] == '\n')
	   {
	     lim += 2;
	     break;
	   }
#endif
	}

      if ((err = kwsincr (kwset, beg, end - beg)) != NULL)
	error (EXIT_TROUBLE, 0, "%s", err);
      beg = lim;
    }
  while (beg < pat + psize);

  if ((err = kwsprep (kwset)) != NULL)
    error (EXIT_TROUBLE, 0, "%s", err);
}

EXECUTE_FCT(Fexecute)
{
  char const *beg, *try, *end, *mb_start;
  size_t len;
  char eol = eolbyte;
  struct kwsmatch kwsmatch;
  size_t ret_val;
#ifdef MBS_SUPPORT
  if (MB_CUR_MAX > 1)
    {
      if (match_icase)
        {
          char *case_buf = mbtolower (buf, &size);
	  if (start_ptr)
	    start_ptr = case_buf + (start_ptr - buf);
          buf = case_buf;
        }
    }
#endif /* MBS_SUPPORT */

  for (mb_start = beg = start_ptr ? start_ptr : buf; beg <= buf + size; beg++)
    {
      size_t offset = kwsexec (kwset, beg, buf + size - beg, &kwsmatch);
      if (offset == (size_t) -1)
	goto failure;
#ifdef MBS_SUPPORT
      
//Patch 0:
if ((((__ctype_get_mb_cur_max()) > 1) || (__is_neg(17, &(buf), sizeof (buf), &(size), sizeof (size), &(beg), sizeof (beg), &(mb_start), sizeof (mb_start), &(offset), sizeof (offset), &(kwset), sizeof (kwset), &(start_ptr), sizeof (start_ptr), &(len), sizeof (len), &(match_words), sizeof (match_words), &(match_lines), sizeof (match_lines), &(eol), sizeof (eol), &(match_icase), sizeof (match_icase), &(try), sizeof (try), &(eolbyte), sizeof (eolbyte), &(ret_val), sizeof (ret_val), &(end), sizeof (end), &(match_size), sizeof (match_size)))) && is_mb_middle(&mb_start, beg + offset, buf + size)) {
    beg = mb_start - 1;
    continue;
}

//CodeSeg 1:
#endif /* MBS_SUPPORT */
      beg += offset;
      len = kwsmatch.size[0];
      if (start_ptr && !match_words)
	goto success_in_beg_and_len;
      if (match_lines)
	{
	  if (beg > buf && beg[-1] != eol)
	    continue;
	  if (beg + len < buf + size && beg[len] != eol)
	    continue;
	  goto success;
	}
      else if (match_words)
	for (try = beg; len; )
	  {
	    if (try > buf && WCHAR((unsigned char) try[-1]))
	      break;
	    if (try + len < buf + size && WCHAR((unsigned char) try[len]))
	      {
		offset = kwsexec (kwset, beg, --len, &kwsmatch);
		if (offset == (size_t) -1)
		  break;
		try = beg + offset;
		len = kwsmatch.size[0];
	      }
	    else if (!start_ptr)
	      goto success;
	    else
	      goto success_in_beg_and_len;
	  } /* for (try) */
      else
	goto success;
    } /* for (beg in buf) */

 failure:
  ret_val = -1;
  goto out;

 success:
  if ((end = memchr (beg + len, eol, (buf + size) - (beg + len))) != NULL)
    end++;
  else
    end = buf + size;
  while (buf < beg && beg[-1] != eol)
    --beg;
  len = end - beg;
 success_in_beg_and_len:
  *match_size = len;
  ret_val = beg - buf;
 out:
  return ret_val;
}
#endif /* defined(GREP_PROGRAM) || defined(FGREP_PROGRAM) */

#ifdef GREP_PROGRAM
#if HAVE_LIBPCRE
/* Compiled internal form of a Perl regular expression.  */
static pcre *cre;

/* Additional information about the pattern.  */
static pcre_extra *extra;
#endif

COMPILE_FCT(Pcompile)
{
#if !HAVE_LIBPCRE
  error (EXIT_TROUBLE, 0, "%s",
	 _("support for the -P option is not compiled into "
	   "this --disable-perl-regexp binary"));
#else
  int e;
  char const *ep;
  char *re = xmalloc (4 * size + 7);
  int flags = PCRE_MULTILINE | (match_icase ? PCRE_CASELESS : 0);
  char const *patlim = pattern + size;
  char *n = re;
  char const *p;
  char const *pnul;

  /* FIXME: Remove these restrictions.  */
  if (memchr(pattern, '\n', size))
    error (EXIT_TROUBLE, 0, _("the -P option only supports a single pattern"));

  *n = '\0';
  if (match_lines)
    strcpy (n, "^(");
  if (match_words)
    strcpy (n, "\\b(");
  n += strlen (n);

  /* The PCRE interface doesn't allow NUL bytes in the pattern, so
     replace each NUL byte in the pattern with the four characters
     "\000", removing a preceding backslash if there are an odd
     number of backslashes before the NUL.

     FIXME: This method does not work with some multibyte character
     encodings, notably Shift-JIS, where a multibyte character can end
     in a backslash byte.  */
  for (p = pattern; (pnul = memchr (p, '\0', patlim - p)); p = pnul + 1)
    {
      memcpy (n, p, pnul - p);
      n += pnul - p;
      for (p = pnul; pattern < p && p[-1] == '\\'; p--)
	continue;
      n -= (pnul - p) & 1;
      strcpy (n, "\\000");
      n += 4;
    }

  memcpy (n, p, patlim - p);
  n += patlim - p;
  *n = '\0';
  if (match_words)
    strcpy (n, ")\\b");
  if (match_lines)
    strcpy (n, ")$");

  cre = pcre_compile (re, flags, &ep, &e, pcre_maketables ());
  if (!cre)
    error (EXIT_TROUBLE, 0, "%s", ep);

  extra = pcre_study (cre, 0, &ep);
  if (ep)
    error (EXIT_TROUBLE, 0, "%s", ep);

  free (re);
#endif
}

EXECUTE_FCT(Pexecute)
{
#if !HAVE_LIBPCRE
  abort ();
  return -1;
#else
  /* This array must have at least two elements; everything after that
     is just for performance improvement in pcre_exec.  */
  int sub[300];

  const char *line_buf, *line_end, *line_next;
  int e = PCRE_ERROR_NOMATCH;
  ptrdiff_t start_ofs = start_ptr ? start_ptr - buf : 0;

  /* PCRE can't limit the matching to single lines, therefore we have to
     match each line in the buffer separately.  */
  for (line_next = buf;
       e == PCRE_ERROR_NOMATCH && line_next < buf + size;
       start_ofs -= line_next - line_buf)
    {
      line_buf = line_next;
      line_end = memchr (line_buf, eolbyte, (buf + size) - line_buf);
      if (line_end == NULL)
        line_next = line_end = buf + size;
      else
        line_next = line_end + 1;

      if (start_ptr && start_ptr >= line_end)
        continue;

      e = pcre_exec (cre, extra, line_buf, line_end - line_buf,
                     start_ofs < 0 ? 0 : start_ofs, 0,
                     sub, sizeof sub / sizeof *sub);
    }

  if (e <= 0)
    {
      switch (e)
	{
	case PCRE_ERROR_NOMATCH:
	  return -1;

	case PCRE_ERROR_NOMEMORY:
	  error (EXIT_TROUBLE, 0, _("memory exhausted"));

	default:
	  abort ();
	}
    }
  else
    {
      /* Narrow down to the line we've found.  */
      char const *beg = line_buf + sub[0];
      char const *end = line_buf + sub[1];
      char const *buflim = buf + size;
      char eol = eolbyte;
      if (!start_ptr)
	{
	  /* FIXME: The case when '\n' is not found indicates a bug:
	     Since grep is line oriented, the match should never contain
	     a newline, so there _must_ be a newline following.
	   */
	  if (!(end = memchr (end, eol, buflim - end)))
	    end = buflim;
	  else
	    end++;
	  while (buf < beg && beg[-1] != eol)
	    --beg;
	}

      *match_size = end - beg;
      return beg - buf;
    }
#endif
}

struct matcher const matchers[] = {
  { "default", Gcompile, EGexecute },
  { "grep",    Gcompile, EGexecute },
  { "egrep",   Ecompile, EGexecute },
  { "awk",     Acompile, EGexecute },
  { "fgrep",   Fcompile, Fexecute },
  { "perl",    Pcompile, Pexecute },
  { "", 0, 0 },
};
#endif /* GREP_PROGRAM */

Testing negative cases!
Testing 0 (with abstract condition) ENVIS_NEG
Iteration 0
Running test command:
/home/ubuntu/spr-fast/tools/grep-test.py /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-deccad69-db9d6340/tempworkdir2/src /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-deccad69-db9d6340/tempworkdir2/tests /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-deccad69-db9d6340/tempworkdir2 0  > __res
Opening:/home/ubuntu/spr-fast/tests/corebench/grep/grep-case-deccad69-db9d6340/tempworkdir2/neg.tmp!
NegativeBRANCH RECORD/home/ubuntu/spr-fast/tests/corebench/grep/grep-case-deccad69-db9d6340/tempworkdir2/neg.tmp!
Not caught by the negative case, give up!
APPENDING TO ISNEG:/home/ubuntu/spr-fast/tests/corebench/grep/grep-case-deccad69-db9d6340/tempworkdir2/neg.tmp!
Running test command:
/home/ubuntu/spr-fast/tools/grep-test.py /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-deccad69-db9d6340/tempworkdir2/src /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-deccad69-db9d6340/tempworkdir2/tests /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-deccad69-db9d6340/tempworkdir2 0  > __res
Total cnt of passed cond schemas: 6
Total cnt of cond schemas: 29
Counter: 40
Batcher Size:0
The found score 19999975.000000 is greater than current score 7489.000000!
Terminate current session!
Generated a patch at candidate schema no 26
Total cnt of passed cond schemas: 6
Total cnt of cond schemas: 29
Candidate count:0!!
Found a fix! Store to: grep-fix-deccad69-db9d6340src_search.c
Found a fix! Store to: grep-fix-deccad69-db9d6340src_search.c-1
Repair process ends successfully!
Total 3127 different repair candidate schema!!!!
Total number of compiles: 100
Total number of test eval: 418
